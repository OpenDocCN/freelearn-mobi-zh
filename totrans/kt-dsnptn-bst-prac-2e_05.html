<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-109"><em class="italic"><a id="_idTextAnchor115"/>Chapter 4</em>: Getting Familiar with Behavioral Patterns</h1>&#13;
			<p>This chapter discusses behavioral patterns in terms of Kotlin. <strong class="bold">Behavioral patterns</strong> deal with how objects interact with one another. </p>&#13;
			<p>We'll learn how an object can alter its behavior based on the situation, how objects can communicate without knowledge of one another, and how to iterate over complex structures easily. We'll also touch on the concept of functional programming in Kotlin, which will help us implement some of these patterns easily.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Strategy</li>&#13;
				<li>Iterator</li>&#13;
				<li>State</li>&#13;
				<li>Command</li>&#13;
				<li>Chain of Responsibility</li>&#13;
				<li>Interpreter</li>&#13;
				<li>Mediator</li>&#13;
				<li>Memento</li>&#13;
				<li>Visitor</li>&#13;
				<li>Template method</li>&#13;
				<li>Observer</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you'll be able to structure your code in a highly decoupled and flexible manner.</p>&#13;
			<h1 id="_idParaDest-110"><a id="_idTextAnchor116"/>Technical requirements</h1>&#13;
			<p>In addition to the requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled <strong class="bold">Kotlin</strong> project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04</a>.</p>&#13;
			<h1 id="_idParaDest-111"><a id="_idTextAnchor117"/>Strategy</h1>&#13;
			<p>The goal <a id="_idIndexMarker293"/>of the <strong class="bold">Strategy</strong> design pattern is to allow an object to alter its behavior at runtime.</p>&#13;
			<p>Let's recall the platformer game we were designing in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>, while discussing<a id="_idIndexMarker294"/> the <strong class="bold">Facade</strong> design pattern.</p>&#13;
			<p>Canary Michael, who acts as a game designer in our small indie game development company, came up with a great idea. <em class="italic">What if we were to give our hero an arsenal of weapons to protect us from those horrible carnivorous snails?</em></p>&#13;
			<p>Weapons all shoot projectiles (you don't want to get too close to those dangerous snails) in the direction our hero is facing:</p>&#13;
			<pre>enum class Direction { </pre>&#13;
			<pre>    LEFT, RIGHT </pre>&#13;
			<pre>}</pre>&#13;
			<p>All projectiles should have a pair of coordinates (<em class="italic">our game is 2D, remember?</em>) and a direction:</p>&#13;
			<pre>data class Projectile(private var x: Int, </pre>&#13;
			<pre>                      private var y: Int, </pre>&#13;
			<pre>                      private var direction: Direction)</pre>&#13;
			<p>If we were to shoot only one type of projectile, that would be simple, since we covered the Factory pattern in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>.</p>&#13;
			<p>We could do something like that here:</p>&#13;
			<pre>class OurHero { </pre>&#13;
			<pre>    private var direction = Direction.LEFT </pre>&#13;
			<pre>    private var x: Int = 42 </pre>&#13;
			<pre>    private var y: Int = 173 </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun shoot(): Projectile { </pre>&#13;
			<pre>        return Projectile(x, y, direction) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>But Michael<a id="_idIndexMarker295"/> wants our hero to have at least three different weapons:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Peashooter</strong>: Shoots small <a id="_idIndexMarker296"/>peas that fly straight. Our hero starts with it.</li>&#13;
				<li><strong class="bold">Pomegranate</strong>: Explodes when hitting an enemy, much like a grenade.</li>&#13;
				<li><strong class="bold">Banana</strong>: Returns like a boomerang when it reaches the end of the screen.</li>&#13;
			</ul>&#13;
			<p><em class="italic">Come on, Michael, give us some slack! Can't you just stick with regular guns that all work the same?</em></p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor118"/>Fruit arsenal</h2>&#13;
			<p>First, let's discuss<a id="_idIndexMarker297"/> how we could solve this in the Java way.</p>&#13;
			<p>In Java, we would have created an interface that abstracts these changes. In our case, what changes is our hero's weapon:</p>&#13;
			<pre>interface Weapon { </pre>&#13;
			<pre>    fun shoot(x: Int, </pre>&#13;
			<pre>              y: Int, </pre>&#13;
			<pre>              direction: Direction): Projectile </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, all the other weapons would implement this interface. Since we don't deal with aspects such as<a id="_idIndexMarker298"/> rendering or animating objects, no specific behavior will be implemented here:</p>&#13;
			<pre>// Flies straight </pre>&#13;
			<pre>class Peashooter : Weapon {</pre>&#13;
			<pre>    override fun shoot(</pre>&#13;
			<pre>        x: Int,</pre>&#13;
			<pre>        y: Int,</pre>&#13;
			<pre>        direction: Direction</pre>&#13;
			<pre>    ) = Projectile(x, y, direction)</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>// Returns back after reaching end of the screen</pre>&#13;
			<pre>class Banana : Weapon {</pre>&#13;
			<pre>    override fun shoot(</pre>&#13;
			<pre>        x: Int,</pre>&#13;
			<pre>        y: Int,</pre>&#13;
			<pre>        direction: Direction</pre>&#13;
			<pre>    ) = Projectile(x, y, direction)</pre>&#13;
			<pre>}</pre>&#13;
			<pre>// Other similar implementations here </pre>&#13;
			<p>All of the weapons in our game will implement the same interface, overriding its single method.</p>&#13;
			<p>Our hero will hold a reference to a weapon, <code>Peashooter</code>, at the beginning:</p>&#13;
			<pre>private var currentWeapon: Weapon = Peashooter()</pre>&#13;
			<p>This reference will delegate the actual shooting process to it:</p>&#13;
			<pre>fun shoot(): Projectile = currentWeapon.shoot(x, y,   direction)</pre>&#13;
			<p>What's left is the ability to equip another <code>weapon</code>:</p>&#13;
			<pre>fun equip(weapon: Weapon) { </pre>&#13;
			<pre>    currentWeapon = weapon </pre>&#13;
			<pre>}</pre>&#13;
			<p>And that's <a id="_idIndexMarker299"/>what the <strong class="bold">Strategy</strong> design pattern is all about. It makes our algorithms – in this case, the weapons in our game – interchangeable.</p>&#13;
			<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/>Citizen functions</h2>&#13;
			<p>With Kotlin, there's a<a id="_idIndexMarker300"/> more efficient way to implement the same functionality using fewer classes. That's thanks to the fact that functions in Kotlin are first-class citizens. <em class="italic">But what does that mean?</em> </p>&#13;
			<p>For one, we can assign functions to the variables of our class, just like any other standard value. It makes sense that you can assign a primitive value to your variable:</p>&#13;
			<pre>val x = 7</pre>&#13;
			<p>You could also assign an object to a variable, as we have done many times already:</p>&#13;
			<pre>var myPet = Canary("Michael")</pre>&#13;
			<p><em class="italic">So, why shouldn't you be able to assign a function to your variable? </em></p>&#13;
			<p>In Kotlin, you can easily do that. Here's an example:</p>&#13;
			<pre>val square = fun(x: Int): Long { </pre>&#13;
			<pre>    return (x * x).toLong() </pre>&#13;
			<pre>}</pre>&#13;
			<p>Let's see how that may help us simplify our design. </p>&#13;
			<p>First, we'll define a namespace for all our weapons. We can use an object for that. This is not mandatory but it helps keep everything in check. Then, instead of classes, each of our weapons <a id="_idIndexMarker301"/>will become a function:</p>&#13;
			<pre>object Weapons {</pre>&#13;
			<pre>    // Flies straight</pre>&#13;
			<pre>    fun peashooter(x: Int, y: Int, direction: Direction): </pre>&#13;
			<pre>        Projectile {</pre>&#13;
			<pre>        return Projectile(x, y, direction)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    // Returns back after reaching end of the screen</pre>&#13;
			<pre>    fun banana(x: Int, y: Int, direction: Direction): </pre>&#13;
			<pre>        Projectile {</pre>&#13;
			<pre>        return Projectile(x, y, direction)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    // Other similar implementations here   </pre>&#13;
			<pre>}  </pre>&#13;
			<p>As you can see, instead of implementing an interface, we have multiple functions receiving the same parameters and returning the same object.</p>&#13;
			<p>The most interesting part is our hero. The <code>OurHero</code> class now contains two values, both of which are functions:</p>&#13;
			<pre>class OurHero { </pre>&#13;
			<pre>    var currentWeapon = Weapons::peashooter </pre>&#13;
			<pre> </pre>&#13;
			<pre>    val shoot = fun() { </pre>&#13;
			<pre>        currentWeapon(x, y, direction) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>The interchangeable part is <code>currentWeapon</code>, while <code>shoot</code> is now an anonymous function that wraps it.</p>&#13;
			<p>To test that our idea works, we can shoot the default weapon once, then switch to another weapon and shoot with it again:</p>&#13;
			<pre>val hero = OurHero()</pre>&#13;
			<pre>hero.shoot()</pre>&#13;
			<pre>hero.currentWeapon = Weapons<strong class="bold">::</strong>banana</pre>&#13;
			<pre>hero.shoot()</pre>&#13;
			<p>Notice that <a id="_idIndexMarker302"/>this dramatically reduces the number of classes we have to write while keeping the same functionality. If your interchangeable algorithm doesn't have a state, you can replace it with a simple function. Otherwise, introduce an interface, and let each Strategy pattern implement it. </p>&#13;
			<p>That's also the first time we used the function reference operator, <code>::</code>. This operator allows us to refer to a function as if it was a variable instead of invoking it. </p>&#13;
			<p><strong class="bold">Strategy</strong> is a valuable pattern whenever your application needs to change its behavior at runtime. One example is a booking system for flights that allows for overbooking; that is, placing more passengers on a flight than there are seats. You may decide that you wish to enable overbooking up until one day before the flight and then disallow it. You can do this by switching strategies instead of adding complex checks to your code.</p>&#13;
			<p>Now, let's look at another pattern that should help us work with complex data structures.</p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor120"/>Iterator</h1>&#13;
			<p>When we were <a id="_idIndexMarker303"/>discussing <a id="_idIndexMarker304"/>the <strong class="bold">Composite</strong> design pattern in the previous chapter, we noted that the design pattern felt a bit incomplete. Now is the time to reunite the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito, they're very different but complement each other well.</p>&#13;
			<p>As you may remember from the previous chapter, a squad consists of troopers or other squads. Let's <a id="_idIndexMarker305"/>create one now:</p>&#13;
			<pre>val platoon = Squad(</pre>&#13;
			<pre>    Trooper(),</pre>&#13;
			<pre>    Squad(</pre>&#13;
			<pre>        Trooper(),</pre>&#13;
			<pre>    ),</pre>&#13;
			<pre>    Trooper(),</pre>&#13;
			<pre>    Squad(</pre>&#13;
			<pre>        Trooper(),</pre>&#13;
			<pre>        Trooper(),</pre>&#13;
			<pre>    ),</pre>&#13;
			<pre>    Trooper()</pre>&#13;
			<pre>)</pre>&#13;
			<p>Here, we created a platoon that consists of four troopers in total. </p>&#13;
			<p>It would be useful if we could print all the troopers in this platoon using a <code>for-each</code> loop, which we learned about back in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>. </p>&#13;
			<p>Let's just try to write that code and see what happens: </p>&#13;
			<pre>for (trooper in platoon) {</pre>&#13;
			<pre>    println(trooper)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Although this code doesn't compile, the Kotlin compiler provides us with a useful hint:</p>&#13;
			<pre>&gt;For loop range must have an iterator method </pre>&#13;
			<p>Before we follow the compiler's guidance and implement the method, let's briefly discuss what problem we have at the moment. </p>&#13;
			<p>Our platoon, which implements a Composite design pattern, is not a flat data structure. It can contain objects that contain other objects – squads can contain troopers as well as other squads. In this case, however, we want to abstract that complexity and work with it as if it was just a list of troopers. The Iterator pattern does just that – it <em class="italic">flattens</em> our complex data structure into a simple sequence of elements. The order of the elements and what elements to ignore is for the iterator to decide.</p>&#13;
			<p>To use our <code>Squad</code> object in a <code>for-each</code> loop, we will need to implement a special function called <code>iterator()</code>. And<a id="_idIndexMarker306"/> since it's a special function, we'll need to use the <code>operator</code> keyword:</p>&#13;
			<pre>operator fun iterator() = ...</pre>&#13;
			<p>What our function returns is an anonymous object that implements the <code>Iterator&lt;T&gt;</code> interface:</p>&#13;
			<pre>operator fun iterator() = object: Iterator&lt;Trooper&gt; {</pre>&#13;
			<pre>    override fun hasNext(): Boolean {</pre>&#13;
			<pre>        // Are there more objects to iterate over?</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun next(): Trooper {</pre>&#13;
			<pre>        // Return next Trooper</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Once again, we can see the use of generics in Kotlin. <code>Iterator&lt;Trooper&gt;</code> means that the objects that our <code>next()</code> method returns will always be of the <code>Trooper</code> type. </p>&#13;
			<p>To be able to iterate all the elements, we need to implement two methods – one to fetch the next element and one to let the loop know when to stop. Let's do that by executing the following steps:</p>&#13;
			<ol>&#13;
				<li>First, we need a state for our iterator. It will remember that the last element is returned:<pre>operator fun iterator() = object: Iterator&lt;Trooper&gt; { 
    private var i = 0 
    // More code here 
}</pre></li>&#13;
				<li>Next, we need to tell it when to stop. In simple cases, this would be equal to the size of the underlying data structure:<pre>override fun hasNext(): Boolean { 
    return i &lt; units.size 
}</pre><p>This will be a<a id="_idIndexMarker307"/> bit more complex since we need to handle some edge cases. You can find the complete implementation in this book's GitHub repository. </p></li>&#13;
				<li>Finally, we need to know which unit to return. For simple cases, we could just return the current element and increase the element count by one:<pre>override fun next() = units[i++]</pre><p>In our case, this is a bit more complex since squads could contain other squads. Again, you can find the full implementation in this book's GitHub repository.</p><p>Sometimes, it also makes sense to receive an iterator as a parameter of a function:</p><pre>fun &lt;T&gt; printAnything(iter: Iterator&lt;T&gt;) { 
    while (iter.hasNext()) { 
        println(iter.next()) 
    } 
}</pre><p>This function will iterate over anything that supplies an iterator. This is also an example of a generic function in Kotlin. Note <code>&lt;T&gt;</code>, which comes before the function's name. </p></li>&#13;
			</ol>&#13;
			<p>As a regular developer that doesn't invent new data structures for a living, you may not implement <a id="_idIndexMarker308"/>iterators often. However, it's still important to know how they work behind the scenes. </p>&#13;
			<p>The following section will show how to design finite-state machines efficiently.</p>&#13;
			<h1 id="_idParaDest-115"><a id="_idTextAnchor121"/>State</h1>&#13;
			<p>You can think of <a id="_idIndexMarker309"/>the <strong class="bold">State</strong> design pattern as an opinionated Strategy pattern, which we discussed at the beginning of this chapter. But while the Strategy pattern is usually replaced from the outside by the client, the state may change internally based solely on the input it gets.</p>&#13;
			<p>Look at this dialog a client wrote with the Strategy pattern:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Client</strong>: <em class="italic">Here's a new thing to do, start doing it from now on.</em></li>&#13;
				<li><strong class="bold">Strategy</strong>: <em class="italic">OK, no problem.</em></li>&#13;
				<li><strong class="bold">Client</strong>: <em class="italic">What I like about you is that you never argue with me.</em></li>&#13;
			</ul>&#13;
			<p>Compare it with this one:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Client</strong>: <em class="italic">Here's some new input I got from you.</em></li>&#13;
				<li><strong class="bold">State</strong>: <em class="italic">Oh, I don't know. Maybe I'll start doing something differently. Maybe not.</em></li>&#13;
			</ul>&#13;
			<p>The client should also expect that the state may even reject some of its inputs:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Client</strong>: <em class="italic">Here's something for you to ponder, State.</em></li>&#13;
				<li><strong class="bold">State</strong>: <em class="italic">I don't know what it is! Don't you see I'm busy? Go bother some Strategy with this!</em></li>&#13;
			</ul>&#13;
			<p><em class="italic">So, why do clients still tolerate that state of ours?</em> Well, the state is good at keeping everything under control.</p>&#13;
			<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/>Fifty shades of State</h2>&#13;
			<p>The carnivorous<a id="_idIndexMarker310"/> snails from our platformer game have had enough of this abuse. So, the player throws peas and bananas at them, only to get to another sorry castle. <em class="italic">Now, they shall act!</em> </p>&#13;
			<p>Let's see how the State design pattern can help us model a changing behavior of an actor – in our case, of the enemies in our platformer game. By default, the snail should stand still to conserve snail energy. But when the hero gets close, it should dash toward them aggressively. </p>&#13;
			<p>If the hero manages to injure it, it should retreat to lick its wounds. Then, it will repeat attacking until either of them is dead.</p>&#13;
			<p>First, we'll declare what can happen during a snail's life:</p>&#13;
			<pre>interface WhatCanHappen { </pre>&#13;
			<pre>    fun seeHero() </pre>&#13;
			<pre>    fun getHit(pointsOfDamage: Int) </pre>&#13;
			<pre>    fun calmAgain() </pre>&#13;
			<pre>}</pre>&#13;
			<p>Our snail implements this interface so that it is notified of anything that may happen to it and act accordingly:</p>&#13;
			<pre>class Snail : WhatCanHappen { </pre>&#13;
			<pre>    private var healthPoints = 10 </pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun seeHero() { </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun getHit(pointsOfDamage: Int) { </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun calmAgain() { </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, we can declare the <code>Mood</code> class, which we will mark with the <code>sealed</code> keyword:</p>&#13;
			<pre>sealed class Mood { </pre>&#13;
			<pre>   // Some abstract methods here, like draw(), for example </pre>&#13;
			<pre>}</pre>&#13;
			<p><strong class="bold">Sealed classes</strong> are abstract and cannot be instantiated. We'll see the benefit of using them in a<a id="_idIndexMarker311"/> moment. But before that, let's declare other states:</p>&#13;
			<pre>object Still : Mood()</pre>&#13;
			<pre>object Aggressive : Mood()</pre>&#13;
			<pre>object Retreating : Mood()</pre>&#13;
			<pre>object Dead : Mood()</pre>&#13;
			<p>These are all the different states – sorry, moods – of our snail.</p>&#13;
			<p>In terms of the State design pattern, <code>Snail</code> is the context. It holds the state. So, we declare a member for it:</p>&#13;
			<pre>class Snail : WhatCanHappen { </pre>&#13;
			<pre>    private var mood: Mood = Still </pre>&#13;
			<pre>    // As before </pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's define what <code>Snail</code> should do when it sees our hero:</p>&#13;
			<pre>override fun seeHero() {</pre>&#13;
			<pre>    mood = when(mood) {</pre>&#13;
			<pre>        is Still -&gt; Aggressive</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that this doesn't compile. This is where the <code>sealed</code> class comes into play. Much like with an <code>enum</code>, Kotlin knows that there's a finite number of classes that extend from it. So, it requires that our <code>when</code> is exhaustive and specifies all the different cases in it. </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">If you're using IntelliJ as your IDE, it will even suggest that you <code>Add remaining branches</code> automatically.</p>&#13;
			<p>We can<a id="_idIndexMarker312"/> use <code>else</code> to describe no state change:</p>&#13;
			<pre>override fun seeHero() {</pre>&#13;
			<pre>    mood = when(mood) {</pre>&#13;
			<pre>        is Still -&gt; Aggressive</pre>&#13;
			<pre>        <strong class="bold">else -&gt; mood</strong></pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>When the snail gets hit, we need to decide whether it's dead or not. For that, we can use <code>when</code> without an argument:</p>&#13;
			<pre>override fun getHit(pointsOfDamage: Int) {</pre>&#13;
			<pre>    healthPoints -= pointsOfDamage</pre>&#13;
			<pre> </pre>&#13;
			<pre>    mood = when {</pre>&#13;
			<pre>        (healthPoints &lt;= 0) -&gt; Dead</pre>&#13;
			<pre>        mood is Aggressive -&gt; Retreating</pre>&#13;
			<pre>        else -&gt; mood</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that we use the <code>is</code> keyword here, which is the same as <code>instanceof</code> in Java, but more <a id="_idIndexMarker313"/>concise. </p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/>State of the nation</h2>&#13;
			<p>The previous<a id="_idIndexMarker314"/> approach contains most of the logic for our context. You may sometimes see a different approach, which is valid as your context becomes bigger.</p>&#13;
			<p>In this approach, <code>Snail</code> would become thin:</p>&#13;
			<pre>class Snail { </pre>&#13;
			<pre>    <strong class="bold">internal</strong> var mood: Mood = Still(this) </pre>&#13;
			<pre> </pre>&#13;
			<pre>    private var healthPoints = 10 </pre>&#13;
			<pre>    // That's all! </pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that we marked <code>mood</code> as <code>internal</code>. This lets other classes in the same package alter it. Instead of <code>Snail</code> implementing <code>WhatCanHappen</code>, our <code>Mood</code> will implement it instead:</p>&#13;
			<pre>sealed class Mood : WhatCanHappen</pre>&#13;
			<p>Now, the logic resides within our state objects:</p>&#13;
			<pre>class Still(private val snail: Snail) : Mood() {</pre>&#13;
			<pre>    override fun seeHero() {</pre>&#13;
			<pre>        snail.mood = Aggressive</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    override fun getHit(pointsOfDamage: Int) {</pre>&#13;
			<pre>        // Same logic from before</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    override fun calmAgain() {   </pre>&#13;
			<pre>       // Return to Still state</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that our state objects now receive a reference to their context in the constructor.</p>&#13;
			<p>Use the first approach if the amount of code in your state is relatively small. Use the second approach for cases if the variants differ a lot. One example from the real world, where this pattern is widely used, is Kotlin's <strong class="bold">Coroutines</strong> mechanism. We'll discuss this in detail<a id="_idIndexMarker315"/> in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<p>Now, let's look at another pattern that encapsulates actions.</p>&#13;
			<h1 id="_idParaDest-118"><a id="_idTextAnchor124"/>Command</h1>&#13;
			<p>This design<a id="_idIndexMarker316"/> pattern allows you to encapsulate actions inside an object to be executed sometime later. Furthermore, if we can execute one action later, we could also execute many, or even schedule exactly when to execute them. </p>&#13;
			<p>Let's go back to our <code>Stormtrooper</code> management system from <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>. Here's an example of implementing the <code>attack</code> and <code>move</code> functions from before:</p>&#13;
			<pre>class Stormtrooper(...) { </pre>&#13;
			<pre>    fun attack(x: Long, y: Long) { </pre>&#13;
			<pre>        println("Attacking ($x, $y)") </pre>&#13;
			<pre>        // Actual code here </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun move(x: Long, y: Long) { </pre>&#13;
			<pre>        println("Moving to ($x, $y)") </pre>&#13;
			<pre>        // Actual code here </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>We could even <a id="_idIndexMarker317"/>use the <strong class="bold">Bridge</strong> design pattern from the previous chapter to provide the actual implementations. </p>&#13;
			<p>The problem we need to solve now is that our trooper can remember exactly one command. That's it. If they start at <code>(0, 0)</code>, which is the top of the screen, we can tell them to <code>move(20, 0)</code>, which is 20 steps to the right, and then to <code>move(20, 20)</code>. In this case, they'll move straight to <code>(20, 20)</code> and will probably get destroyed because there<a id="_idIndexMarker318"/> are rebels that we must try to avoid at all costs:</p>&#13;
			<pre>[storm trooper](0, 0) -&gt; good direction  -&gt; (20, 0) </pre>&#13;
			<pre> </pre>&#13;
			<pre>          [rebel] [rebel]                     <img src="img/Formula_4.1_B17816.png" alt="" width="35" height="38"/></pre>&#13;
			<pre>        [rebel] [rebel] [rebel]               <img src="img/Formula_4.1_B17816.png" alt="" width="35" height="38"/></pre>&#13;
			<pre>           [rebel] [rebel] </pre>&#13;
			<pre>            (5, 20)                        (20, 20)</pre>&#13;
			<p>If you've been following this book from the start or at least joined at <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>, you probably have an idea of what we need to do, since we have already discussed the concept of <em class="italic">functions as first-class citizens</em> in the language. </p>&#13;
			<p>Let's sketch a draft for this. We know that we want to hold a list of objects, but we don't know what type they should be yet. So, we'll use <code>Any</code> for now:</p>&#13;
			<pre>class Trooper { </pre>&#13;
			<pre>    private val orders = mutableListOf&lt;Any&gt;()  </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun addOrder(order: Any) {</pre>&#13;
			<pre>        this.orders.add(order)</pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    // More code here </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, we want<a id="_idIndexMarker319"/> to iterate over the list and execute the orders we have:</p>&#13;
			<pre>class Trooper { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    // This will be triggered from the outside once in a while</pre>&#13;
			<pre>    fun executeOrders() {</pre>&#13;
			<pre>        while (orders.isNotEmpty()) {</pre>&#13;
			<pre>            val order = orders.removeFirst()</pre>&#13;
			<pre>            order.execute() // Compile error for now </pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that Kotlin provides us with the <code>isNotEmpty()</code> function on collections, as an alternative to the <code>!orders.isEmpty()</code> check, as well as a <code>removeFirst()</code> function, which allows us to use our collection as if it was a queue.</p>&#13;
			<p>Even if you're not familiar with the Command design pattern, you can guess that if we want our code to compile, we can define an interface with a single method, <code>execute()</code>:</p>&#13;
			<pre>interface Command { </pre>&#13;
			<pre>    fun execute() </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, we can hold a list at the same time in a member property:</p>&#13;
			<pre>private val commands = mutableListOf&lt;Command&gt;()</pre>&#13;
			<p>Each type of order, be it a move order or an attack order, would implement this interface as needed. That's basically what the Java implementation of this pattern would suggest in most cases. <em class="italic">But isn't there a better way?</em> </p>&#13;
			<p>Let's look at <code>Command</code> again. The <code>execute()</code> method receives nothing, returns nothing, and does something. It's the same as writing the following code:</p>&#13;
			<pre>fun command(): Unit { </pre>&#13;
			<pre>    // Some code here </pre>&#13;
			<pre>}</pre>&#13;
			<p>It's no<a id="_idIndexMarker320"/> different from what we've seen previously. We could simplify this further:</p>&#13;
			<pre>() -&gt; Unit</pre>&#13;
			<p>And instead of having an interface for this called <code>Command</code>, we'll have <code>typealias</code>:</p>&#13;
			<pre>typealias Command = ()-&gt; Unit</pre>&#13;
			<p>This makes our <code>Command</code> interface redundant and allows us to remove it.</p>&#13;
			<p>Now, this line stops compiling again:</p>&#13;
			<pre>command.execute() // Unresolved reference: execute </pre>&#13;
			<p>This is because <code>execute()</code> is just some name we invented. In Kotlin, functions use <code>invoke()</code>:</p>&#13;
			<pre>command.invoke() // Compiles</pre>&#13;
			<p>We can also omit <code>invoke()</code>, which will leaves us with the following code:</p>&#13;
			<pre>fun executeOrders() {</pre>&#13;
			<pre>    while (orders.isNotEmpty()) {</pre>&#13;
			<pre>        val order = orders.removeFirst()</pre>&#13;
			<pre>        order() // Executed the next order</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>That's nice, but currently, our function has no parameters at all. <em class="italic">What happens if our function receives arguments?</em> </p>&#13;
			<p>One option would be to change the signature of our <code>Command</code> so that we receive two parameters: </p>&#13;
			<pre>(x: Int, y: Int)-&gt; Unit</pre>&#13;
			<p><em class="italic">But what if some commands receive no arguments, or only one, or more than two?</em> We also need to remember what to pass to <code>invoke()</code> at each step.</p>&#13;
			<p>A much<a id="_idIndexMarker321"/> better way is to have a <strong class="bold">function generator</strong>. This is a function that returns another function. If you have ever worked with the JavaScript language, then you'll know that it's a common practice to use closures to limit the scope and remember stuff. We'll do the same here:</p>&#13;
			<pre>val moveGenerator = fun(trooper: Trooper, </pre>&#13;
			<pre>                        x: Int, </pre>&#13;
			<pre>                        y: Int): Command { </pre>&#13;
			<pre>    return fun() { </pre>&#13;
			<pre>        trooper.move(x, y) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>When called with proper arguments, <code>moveGenerator</code> will return a new function. This function can be invoked whenever we find it suitable and it will remember three things:</p>&#13;
			<ul>&#13;
				<li>What method to call</li>&#13;
				<li>Which arguments to use</li>&#13;
				<li>Which object to use it on</li>&#13;
			</ul>&#13;
			<p>Now, our <code>Trooper</code> may have a method like this:</p>&#13;
			<pre>fun appendMove(x: Int, y: Int) = apply { </pre>&#13;
			<pre>    commands.add(moveGenerator(this, x, y)) </pre>&#13;
			<pre>}</pre>&#13;
			<p>This provides us with a nice fluent syntax:</p>&#13;
			<pre>val trooper = Trooper() </pre>&#13;
			<pre>trooper.appendMove(20, 0) </pre>&#13;
			<pre>    .appendMove(20, 20) </pre>&#13;
			<pre>    .appendMove(5, 20) </pre>&#13;
			<pre>    .execute()</pre>&#13;
			<p><strong class="bold">Fluent syntax</strong> means that<a id="_idIndexMarker322"/> we can chain methods on the same object easily without the need to repeat its name many times.</p>&#13;
			<p>This code will print the following output:</p>&#13;
			<pre>&gt; Moving to (20, 0) </pre>&#13;
			<pre>&gt; Moving to (20, 20) </pre>&#13;
			<pre>&gt; Moving to (5, 20)</pre>&#13;
			<p>Now, we may issue any number of commands to our <code>Trooper</code> without needing to know how<a id="_idIndexMarker323"/> they are executed internally.</p>&#13;
			<p>A function that receives or returns another<a id="_idIndexMarker324"/> function is called a <strong class="bold">higher-order function</strong>. We'll explore such functions many more times in this book.</p>&#13;
			<h2 id="_idParaDest-119"><a id="_idTextAnchor125"/>Undoing commands</h2>&#13;
			<p>While not<a id="_idIndexMarker325"/> directly related, one of the advantages of the Command design pattern is the ability to undo commands. <em class="italic">What if we wanted to support such a functionality?</em></p>&#13;
			<p>Undoing is usually very tricky because it involves one of the following:</p>&#13;
			<ul>&#13;
				<li>Returning to the previous state (this is impossible if there's more than one client as this requires a lot of memory)</li>&#13;
				<li>Computing deltas (tricky to implement)</li>&#13;
				<li>Defining opposite operations (not always possible)</li>&#13;
			</ul>&#13;
			<p>In our case, the opposite of the <em class="italic">move from (0,0) to (0, 20)</em> command would be <em class="italic">move from wherever you're now to (0,0)</em>. This can be achieved by storing a pair of commands:</p>&#13;
			<pre>private val commands =   mutableListOf&lt;Pair&lt;Command, Command&gt;&gt;()</pre>&#13;
			<p>We'll need to change our <code>appendMove</code> function so that it also stores the reverse command every time:</p>&#13;
			<pre>fun appendMove(x: Int, y: Int) = apply { </pre>&#13;
			<pre>    val oppositeMove = /* If it's the first command,       generate move to current location. Otherwise, get the       previous command */ </pre>&#13;
			<pre>    commands.add(moveGenerator(this, x, y) to oppositeMove) </pre>&#13;
			<pre>}</pre>&#13;
			<p>Computing the opposite move is quite complex as we don't save the position of our soldier currently (it was something we should have implemented anyway). We'll also have to deal with some edge cases. But this should provide you with an idea of how such behavior can be achieved. </p>&#13;
			<p>The <strong class="bold">Command</strong> design<a id="_idIndexMarker326"/> pattern is yet another example of functionality that is already embedded inside the language. In this case, this functions as a first-class citizen, which reduces the need to implement design patterns yourself. In the real world, this pattern is practical whenever you want to enqueue multiple actions or schedule an action to be executed later.</p>&#13;
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/>Chain of Responsibility</h1>&#13;
			<p>I'm a horrible <a id="_idIndexMarker327"/>software architect, and I don't particularly appreciate speaking with people. Hence, while sitting in <em class="italic">The Ivory Tower</em> (<em class="italic">that's the name of the cafe I often visit</em>), I wrote a small web application. If a developer has a question, they shouldn't approach me directly, oh no! They'll need to send me a proper request through this system and I shall only answer them if I deem their request worthy. </p>&#13;
			<p>A <strong class="bold">filter chain</strong> is a <a id="_idIndexMarker328"/>ubiquitous concept in web servers. Usually, when a request reaches you, it's expected that the following is true:</p>&#13;
			<ul>&#13;
				<li>Its parameters have already been validated.</li>&#13;
				<li>The user has already been authenticated, if possible.</li>&#13;
				<li>User roles and permissions are known and the user is authorized to perform an action.</li>&#13;
			</ul>&#13;
			<p>So, the <a id="_idIndexMarker329"/>code I initially wrote looked something like this:</p>&#13;
			<pre>data class Request(val email: String, val question: String)</pre>&#13;
			<pre>fun handleRequest(r: Request) {</pre>&#13;
			<pre>    // Validate </pre>&#13;
			<pre>    if (r.email.isEmpty() || r.question.isEmpty()) {</pre>&#13;
			<pre>        return</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    // Authenticate </pre>&#13;
			<pre>    // Make sure that you know whos is this user </pre>&#13;
			<pre>    if (r.isKnownEmail()) {</pre>&#13;
			<pre>        return</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    // Authorize </pre>&#13;
			<pre>    // Requests from juniors are automatically ignored by </pre>&#13;
			<pre>       architects </pre>&#13;
			<pre>    if (r.isFromJuniorDeveloper()) {</pre>&#13;
			<pre>        return</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    println("I don't know. Did you check StackOverflow?")</pre>&#13;
			<pre>}</pre>&#13;
			<p>It's a bit messy, but it works. </p>&#13;
			<p>Then, I noticed that some developers decided that they can send me two questions at once. We have to add some more logic to this function. But wait – I'm an architect, after all. <em class="italic">So, isn't there a better way to delegate this?</em> </p>&#13;
			<p>The goal<a id="_idIndexMarker330"/> of the <strong class="bold">Chain of Responsibility</strong> design pattern is to break a complex piece of logic into a collection of smaller steps, where each step, or link in the chain, decides whether to proceed to the next one or to return a result.</p>&#13;
			<p>This time, we won't learn new Kotlin tricks but use those that we already know about. So, for example, we could start by implementing an interface such as this one:</p>&#13;
			<pre>interface Handler { </pre>&#13;
			<pre>    fun handle(request: Request): Response </pre>&#13;
			<pre>}</pre>&#13;
			<p>We never discussed what my response to one of the developers looked like. That's because I keep my chain of responsibility so long and complex that usually, they tend to solve the problems by themselves. I've never had to answer one of them, quite frankly. But let's assume the response looks something like this:</p>&#13;
			<pre>data class Response(val answer: String)</pre>&#13;
			<p>We could do this <em class="italic">the Java way</em> and start implementing each piece of logic inside its own handler:</p>&#13;
			<pre>class BasicValidationHandler(private val next: Handler) :   Handler { </pre>&#13;
			<pre>    override fun handle(request: Request): Response { </pre>&#13;
			<pre>        if (request.email.isEmpty() ||</pre>&#13;
			<pre>          request.question.isEmpty()) { </pre>&#13;
			<pre>            throw IllegalArgumentException() </pre>&#13;
			<pre>        } </pre>&#13;
			<pre> </pre>&#13;
			<pre>        return next.handle(request) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>As you can see, here, we are implementing an interface with a single method, which we override with our desired behavior. </p>&#13;
			<p>Other filters <a id="_idIndexMarker331"/>would look very similar to this one. We can compose them in any order we want:</p>&#13;
			<pre>val req = Request("developer@company.com",          "Who broke my build?") </pre>&#13;
			<pre> </pre>&#13;
			<pre>val chain = BasicValidationHandler(</pre>&#13;
			<pre>    KnownEmailHandler(</pre>&#13;
			<pre>        JuniorDeveloperFilterHandler(</pre>&#13;
			<pre>            AnswerHandler()</pre>&#13;
			<pre>        )</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>) </pre>&#13;
			<pre> </pre>&#13;
			<pre>val res = chain.handle(req) </pre>&#13;
			<p>But I won't even ask you the rhetorical question this time about better ways to do things. Of course, there's a better way. We're in the Kotlin world now. And we've seen how to use various functions in the previous section. So, let's define a function for this task:</p>&#13;
			<pre>typealias Handler = (request: Request) -&gt; Response</pre>&#13;
			<p>We don't have a separate class and interface for something that simply receives a request and returns a response. Here's an example of how we can implement authentication <a id="_idIndexMarker332"/>in our application by using a simple function as a value:</p>&#13;
			<pre>val authentication = fun(next: Handler) =</pre>&#13;
			<pre>    fun(request: Request): Response {</pre>&#13;
			<pre>        if (!request.isKnownEmail()) {</pre>&#13;
			<pre>            throw IllegalArgumentException()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        return next(request)</pre>&#13;
			<pre>    }</pre>&#13;
			<p>Here, <code>authentication</code> is a function that receives a function and returns a function. This pattern allows us to easily compose those functions:</p>&#13;
			<pre>val req = Request("developer@company.com",     "Why do we need Software Architects?") </pre>&#13;
			<pre>val chain = basicValidation(authentication</pre>&#13;
			<pre>  (finalResponse())) </pre>&#13;
			<pre>val res = chain(req) </pre>&#13;
			<pre>println(res)</pre>&#13;
			<p>Which method you choose to use is up to you. For example, using interfaces is more explicit and would suit you better if you're creating a library or framework that others may want to extend. </p>&#13;
			<p>Using functions is more concise and if you just want to split your code in a more manageable way, it may be the better choice. </p>&#13;
			<p>You've probably seen this approach many times in the real world. For example, many web server frameworks use it to handle cross-cutting concerns, such as authentication, authorization, logging, and even routing requests. Sometimes, these<a id="_idIndexMarker333"/> are called <strong class="bold">filters</strong> or <strong class="bold">middleware</strong>, but it's <a id="_idIndexMarker334"/>the same Chain of Responsibility design pattern in the end. We'll discuss it again in more detail in <a href="B17816_10_ePub.xhtml#_idTextAnchor237"><em class="italic">Chapter 10</em></a>, <em class="italic">Concurrent Microservices with Ktor</em>, and <a href="B17816_11_ePub.xhtml#_idTextAnchor251"><em class="italic">Chapter 11</em></a>, <em class="italic">Reactive Microservices with Vert.x</em>, where we'll see how it's implemented <a id="_idIndexMarker335"/>by some of the most popular Kotlin frameworks.</p>&#13;
			<p>The next design pattern will be a bit different from all the others and also somewhat more complex.</p>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor127"/>Interpreter</h1>&#13;
			<p>This design<a id="_idIndexMarker336"/> pattern may seem very simple or very hard, based on how much background you have in computer science. Some books that discuss classical software design patterns even decide to omit it altogether or put it somewhere at the end, for curious readers only. </p>&#13;
			<p>The reason behind this is that the <strong class="bold">Interpreter</strong> design pattern deals with translating specific languages. <em class="italic">But why would we need that? Don't we have compilers to do that anyway?</em></p>&#13;
			<h2 id="_idParaDest-122"><a id="_idTextAnchor128"/>We need to go deeper</h2>&#13;
			<p>All developers <a id="_idIndexMarker337"/>have to speak many languages or sub-languages. Even as regular developers, we use more than one language. Think of tools that build your projects, such as Maven or Gradle. You can consider their configuration files and build scripts as languages with specific grammar. If you put elements out of order, your project won't be built correctly. This is because such projects have interpreters to analyze configuration files and act upon them.</p>&#13;
			<p>Other examples are query languages, whether one of the SQL variations or one of the languages specific to NoSQL databases. If you're an Android developer, you may think of XML layouts as such languages too. Even HTML could be considered as a language that defines user interfaces. And there are others, of course.</p>&#13;
			<p>Maybe you've worked with one of the testing frameworks that defines a custom language for<a id="_idIndexMarker338"/> testing, such as <strong class="bold">Cucumber</strong> (<a href="http://github.com/cucumber">github.com/cucumber</a>).</p>&#13;
			<p>Each of these examples<a id="_idIndexMarker339"/> can be called a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). A DSL is a language inside a language, built for a particular domain. We'll discuss how they work in the next section.</p>&#13;
			<h2 id="_idParaDest-123"><a id="_idTextAnchor129"/>A language of your own</h2>&#13;
			<p>In this<a id="_idIndexMarker340"/> section, we'll define a simple <em class="italic">DSL-for-SQL</em> language. We<a id="_idIndexMarker341"/> won't define the format or grammar for it; instead, we'll provide an example of what it should look like:</p>&#13;
			<pre>val sql = select("name, age") {</pre>&#13;
			<pre>    from("users") {</pre>&#13;
			<pre>        where("age &gt; 25")</pre>&#13;
			<pre>    } // Closes from</pre>&#13;
			<pre>} // Closes select </pre>&#13;
			<pre> </pre>&#13;
			<pre>println(sql)</pre>&#13;
			<p>The goal of our language is to improve readability and prevent some common SQL mistakes, such as typos (such as using <em class="italic">FORM</em> instead of <code>FROM</code>). We'll cover the compile-time validations and autocompletion along the way.</p>&#13;
			<p>The preceding code prints the following output:</p>&#13;
			<pre>&gt; SELECT name, age FROM users WHERE age &gt; 25</pre>&#13;
			<p>We'll start with the easiest part – implementing the <code>select</code> function:</p>&#13;
			<pre>fun select(columns: String, from: SelectClause.()-&gt;Unit):  </pre>&#13;
			<pre>    SelectClause { </pre>&#13;
			<pre>    return SelectClause(columns).apply(from) </pre>&#13;
			<pre>}</pre>&#13;
			<p>We could write this using single expression notation, but we are using the more verbose version for clarity here. This is a function that has two parameters. The first is a <code>String</code>, which is simple. The second is another function that receives nothing and returns nothing.</p>&#13;
			<p>The most interesting part is that we specify the receiver for our lambda: </p>&#13;
			<pre><strong class="bold">SelectClause</strong>.()-&gt;Unit</pre>&#13;
			<p>This is a very smart trick, so be sure to follow along. Remember extension functions, which we discussed in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, and expanded on in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. The preceding code can be translated into the following code:</p>&#13;
			<pre>(<strong class="bold">SelectClause</strong>)-&gt;Unit</pre>&#13;
			<p>Here, you can see that although it may seem like this lambda receives nothing, it receives one argument: an object of the <code>SelectClause</code> type. The second trick lies in the usage of the <code>apply()</code> function, which we've already seen.</p>&#13;
			<p>Let's<a id="_idIndexMarker342"/> look <a id="_idIndexMarker343"/>at this line:</p>&#13;
			<pre>SelectClause(columns).apply(from)</pre>&#13;
			<p>This can be translated into the following piece of code:</p>&#13;
			<pre>val selectClause = SelectClause(columns) </pre>&#13;
			<pre>from(selectClause) </pre>&#13;
			<pre>return selectClause</pre>&#13;
			<p>Here are the steps the preceding code will perform:</p>&#13;
			<ol>&#13;
				<li value="1">Initialize <code>SelectClause</code>, which is a simple object that receives one argument in its constructor.</li>&#13;
				<li>Call the <code>from()</code> function with an instance of <code>SelectClause</code> as its only argument.</li>&#13;
				<li>Return an instance of <code>SelectClause</code>.</li>&#13;
			</ol>&#13;
			<p>This code only makes sense if <code>from()</code> does something useful with <code>SelectClause</code>.</p>&#13;
			<p>Let's look at our DSL example again:</p>&#13;
			<pre>select("name, age", { </pre>&#13;
			<pre><strong class="bold">    this@select.</strong>from("users", { </pre>&#13;
			<pre>        where("age &gt; 25") </pre>&#13;
			<pre>    }) </pre>&#13;
			<pre>})</pre>&#13;
			<p>We've made the receiver explicit now, meaning that the <code>from()</code> function will call the <code>from()</code> method on the <code>SelectClause</code> object.</p>&#13;
			<p>You can start guessing what this method looks like. It receives <code>String</code> as its first argument and <a id="_idIndexMarker344"/>another lambda as its<a id="_idIndexMarker345"/> second:</p>&#13;
			<pre>class SelectClause(private val columns: String) {</pre>&#13;
			<pre>    private lateinit var from: FromClause</pre>&#13;
			<pre>    fun from(</pre>&#13;
			<pre>        table: String,</pre>&#13;
			<pre>        where: FromClause.() -&gt; Unit</pre>&#13;
			<pre>    ): FromClause {</pre>&#13;
			<pre>        this.from = FromClause(table)</pre>&#13;
			<pre>        return this.from.apply(where)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun toString() = "SELECT $columns $from"</pre>&#13;
			<pre>}</pre>&#13;
			<p>This example could be shortened, but then we'd need to use <code>apply()</code> within <code>apply()</code>, which may seem confusing at this point.</p>&#13;
			<p>This is the first time we've seen the <code>lateinit</code> keyword. Remember that the Kotlin compiler is very serious about null safety. If we omit <code>lateinit</code>, it will require us to initialize the variable with a default value. But since we'll only know this at a later time, we are asking the compiler to relax a bit. </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Note that if we don't make good on our promises and forget to initialize the variable, we'll get <code>UninitializedPropertyAccessException</code> when we access it for the first time.</p>&#13;
			<p>This keyword is quite dangerous, so use it with caution.</p>&#13;
			<p>Let's go back to our preceding code; all we do is the following:</p>&#13;
			<ol>&#13;
				<li value="1">Create an instance of <code>FromClause</code>.</li>&#13;
				<li>Store <code>FromClause</code> as a member of <code>SelectClause</code>.</li>&#13;
				<li>Pass an instance of <code>FromClause</code> to the <code>where</code> lambda.</li>&#13;
				<li>Return an instance of <code>FromClause</code>.</li>&#13;
			</ol>&#13;
			<p>Hopefully, you're<a id="_idIndexMarker346"/> starting<a id="_idIndexMarker347"/> to get the gist of it:</p>&#13;
			<pre>select("name, age", { </pre>&#13;
			<pre>    this@select.from("users", { </pre>&#13;
			<pre><strong class="bold">        this@from.</strong>where("age &gt; 25") </pre>&#13;
			<pre>    }) </pre>&#13;
			<pre>})</pre>&#13;
			<p><em class="italic">What does this mean?</em> After understanding the <code>from()</code> method, this should be much simpler. <code>FromClause</code> must have a method called <code>where()</code> that receives one argument of the <code>String</code> type:</p>&#13;
			<pre>class FromClause(private val table: String) {</pre>&#13;
			<pre>    private lateinit var where: WhereClause</pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun where(conditions: String) = this.apply {</pre>&#13;
			<pre>        where = WhereClause(conditions)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun toString() = "FROM $table $where"</pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that we have made good on our promise and shortened the method this time.</p>&#13;
			<p>We initialized an instance of <code>WhereClause</code> with the string we received and returned it – simple as that:</p>&#13;
			<pre>class WhereClause(private val conditions: String) {</pre>&#13;
			<pre>    override fun toString() = "WHERE $conditions"</pre>&#13;
			<pre>}</pre>&#13;
			<p><code>WhereClause</code> only prints <a id="_idIndexMarker348"/>the word <code>WHERE</code> and<a id="_idIndexMarker349"/> the conditions it received:</p>&#13;
			<pre>class FromClause(private val table: String) { </pre>&#13;
			<pre>    // More code here... </pre>&#13;
			<pre>    override fun toString() = "FROM $table $where"</pre>&#13;
			<pre>}</pre>&#13;
			<p><code>FromClause</code> prints the word <code>FROM</code>, as well as the table name it received and everything <code>WhereClause</code> printed:</p>&#13;
			<pre>class SelectClause(private val columns: String) { </pre>&#13;
			<pre>    // More code here... </pre>&#13;
			<pre>    override fun toString() = "SELECT $columns $from" </pre>&#13;
			<pre>}</pre>&#13;
			<p><code>SelectClause</code> prints the word <code>SELECT</code>, the columns it got, and whatever <code>FromClause</code> printed.</p>&#13;
			<h3>Taking a break</h3>&#13;
			<p>Kotlin provides <a id="_idIndexMarker350"/>beautiful capabilities for creating readable and type-safe DSLs. But the Interpreter design pattern is one of the hardest in the toolbox. If you didn't get it from the get-go, take some time to debug the previous code. Understand what the <code>this</code> expression means at each step, as well as when we call the function of an object and when we call the method of an object.</p>&#13;
			<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/>Call suffix</h2>&#13;
			<p>We left out <a id="_idIndexMarker351"/>one<a id="_idIndexMarker352"/> last notion of Kotlin's DSL until the end of this section so that we didn't confuse you.</p>&#13;
			<p>Let's look at our DSL again:</p>&#13;
			<pre>val sql = select<strong class="bold">(</strong>"name, age"<strong class="bold">)</strong> { </pre>&#13;
			<pre>              from("users") { </pre>&#13;
			<pre>                  where("age &gt; 25") </pre>&#13;
			<pre>              } // Closes from </pre>&#13;
			<pre>          } // Closes select</pre>&#13;
			<p>Note that although the <code>select</code> function receives two arguments – a string and a lambda – the lambda is written outside of the round brackets, not inside them.</p>&#13;
			<p>This is called <strong class="bold">call suffix</strong> and is a widespread practice in Kotlin. If our function receives another function as its last argument, we can pass it out of parentheses.</p>&#13;
			<p>This results in a much clearer syntax, especially for DSLs such as this one. </p>&#13;
			<p>The Interpreter design pattern and Kotlin's abilities to produce DSLs with type-safe builders are compelling. But as they say, <em class="italic">with great power comes great responsibility</em>. So, consider if your case is complex enough to construct a language within a language, or whether using the Kotlin basic syntax will be enough. </p>&#13;
			<p>Now, let's go back to the game we were building to see how we can decouple object communication.</p>&#13;
			<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/>Mediator</h1>&#13;
			<p>The development<a id="_idIndexMarker353"/> team of our game has some real problems – and they're not related to code directly. As you may recall, our little indie company consists of only me, a canary named <em class="italic">Michael</em> that acts as a product manager, and two cat designers that sleep most of the day but produce some decent mockups from time to time. We have<a id="_idIndexMarker354"/> no <strong class="bold">Quality</strong> <strong class="bold">Assurance</strong> (<strong class="bold">QA</strong>) whatsoever. Maybe that's one of the reasons our game keeps crashing all the time.</p>&#13;
			<p>Recently Michael has introduced me to a parrot named Kenny, who happens to be QA:</p>&#13;
			<pre>interface QA { </pre>&#13;
			<pre>    fun doesMyCodeWork(): Boolean </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>interface Parrot { </pre>&#13;
			<pre>    fun isEating(): Boolean </pre>&#13;
			<pre>    fun isSleeping(): Boolean </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>object Kenny : QA, Parrot { </pre>&#13;
			<pre>    // Implements interface methods based on parrot     // schedule </pre>&#13;
			<pre>}</pre>&#13;
			<p><code>Kenny</code> is a simple object that implements two interfaces: <code>QA</code>, to do QA work, and <code>Parrot</code>, because it's a parrot.</p>&#13;
			<p>Parrot QAs are very motivated. They're ready to test the latest version of my game at any time. But they don't like to be bothered when they are either sleeping or eating:</p>&#13;
			<pre>object Me</pre>&#13;
			<pre>object MyCompany {</pre>&#13;
			<pre>    val cto = Me</pre>&#13;
			<pre>    val qa = Kenny</pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun taskCompleted() {</pre>&#13;
			<pre>        if (!qa.isEating() &amp;&amp; !qa.isSleeping()) {</pre>&#13;
			<pre>            println(qa.doesMyCodeWork())</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In case Kenny has any questions, I gave him my direct number:</p>&#13;
			<pre>object Kenny : ... { </pre>&#13;
			<pre>    val developer = Me </pre>&#13;
			<pre>}</pre>&#13;
			<p>Kenny is a<a id="_idIndexMarker355"/> hard-working parrot. But we had so many bugs that we also had to hire a second parrot QA, Brad. If Kenny is free, I give the job to him as he's more acquainted with our project. But if he's busy, I check if Brad is free and give the task to him:</p>&#13;
			<pre>class MyCompany { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    val qa2 = Brad </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun taskCompleted() { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>        else if (!qa2.isEating() &amp;&amp; !qa2.isSleeping()) { </pre>&#13;
			<pre>            println(qa2.doesMyCodeWork()) </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Brad, being more junior, usually checks with Kenny first. And Kenny also gave my number to him:</p>&#13;
			<pre>object Brad : QA, Parrot { </pre>&#13;
			<pre>    val senior = Kenny </pre>&#13;
			<pre>    val developer = Me </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, Brad<a id="_idIndexMarker356"/> introduces me to George. George is an owl, so he sleeps at different times than Kenny and Brad. This means that he can check my code at night. </p>&#13;
			<p>George checks everything with Kenny and with me: </p>&#13;
			<pre>object George : QA, Owl { </pre>&#13;
			<pre>    val developer = Me </pre>&#13;
			<pre>    val mate = Kenny</pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>The problem is that George is an avid football fan. So, before calling him, we need to check if he's watching a game:</p>&#13;
			<pre>class MyCompany { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    val qa3 = George </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun taskCompleted() { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>        else if (!qa3.isWatchingFootball()) { </pre>&#13;
			<pre>            println(qa3.doesMyCodeWork()) </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Kenny, out of habit, checks in with George too, because George is a very knowledgeable owl:</p>&#13;
			<pre>object Kenny : QA, Parrot { </pre>&#13;
			<pre>    val peer = George </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, there's <a id="_idIndexMarker357"/>Sandra. She's a different kind of bird because she's not part of QA but a copywriter:</p>&#13;
			<pre>interface Copywriter { </pre>&#13;
			<pre>    fun areAllTextsCorrect(): Boolean </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>interface Kiwi </pre>&#13;
			<pre> </pre>&#13;
			<pre>object Sandra : Copywriter, Kiwi { </pre>&#13;
			<pre>    override fun areAllTextsCorrect(): Boolean { </pre>&#13;
			<pre>        return ... </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>I try not to bother her unless there's a major release:</p>&#13;
			<pre>class MyMind { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    val translator = Sandra </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun taskCompleted(isMajorRelease: Boolean) { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>        if (isMajorRelease) { </pre>&#13;
			<pre>            println(translator.areAllTranslationsCorrect()) </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>I have a few problems here:</p>&#13;
			<ul>&#13;
				<li>First, my mind almost explodes trying to remember all those names. So might yours.</li>&#13;
				<li>Second, I need to remember how to interact with each person. I'm the one doing all the checks before calling them.</li>&#13;
				<li>Third, notice how George tries to confirm everything with Kenny, and Kenny with George. Luckily, up until now, George has always been watching a football game when Kenny calls him. And Kenny is asleep when George needs to confirm something with him. Otherwise, they would get stuck on the phone for eternity.</li>&#13;
				<li>Fourth, and <a id="_idIndexMarker358"/>what bothers me the most, is that Kenny plans to leave soon to open his own startup, ParrotPi. Imagine all the code we'll have to change now!</li>&#13;
			</ul>&#13;
			<p>All I want to do is check if everything is alright with my code. Someone else should do all this talking!</p>&#13;
			<h2 id="_idParaDest-126"><a id="_idTextAnchor132"/>The middleman</h2>&#13;
			<p>The <strong class="bold">Mediator</strong> design <a id="_idIndexMarker359"/>pattern is simply a control freak. It doesn't like <a id="_idIndexMarker360"/>it when one object speaks to the other directly. It gets mad sometimes when that happens. No – everybody should only speak through him. <em class="italic">What's the explanation for this?</em> It reduces coupling between objects. Instead of knowing some other objects, everybody should know only them, the mediator.</p>&#13;
			<p>I decided that Michael should manage all those processes and act as the mediator of them:</p>&#13;
			<pre>interface Manager { </pre>&#13;
			<pre>    fun isAllGood(majorRelease: Boolean): Boolean </pre>&#13;
			<pre>}</pre>&#13;
			<p>Only Michael will know all the other birds:</p>&#13;
			<pre>object Michael : Canary, ProductManager {</pre>&#13;
			<pre>    private val kenny = Kenny(this)</pre>&#13;
			<pre>    private val brad = Brad(this)</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun isAllGood(majorRelease: Boolean): Boolean {</pre>&#13;
			<pre>        if (!kenny.isEating() &amp;&amp; !kenny.isSleeping()) {</pre>&#13;
			<pre>            println(kenny.doesMyCodeWork())</pre>&#13;
			<pre>        } else if (!brad.isEating() &amp;&amp; !brad.isSleeping()) {</pre>&#13;
			<pre>            println(brad.doesMyCodeWork())</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        return true</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice how the mediator encapsulates the complex interactions between different objects, exposing a very simple interface.</p>&#13;
			<p>I'll only remember Michael and he'll do the rest:</p>&#13;
			<pre>class MyCompany(private val manager: Manager) { </pre>&#13;
			<pre>    fun taskCompleted(isMajorRelease: Boolean) { </pre>&#13;
			<pre>        println(manager.isAllGood(isMajorRelease)) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>I'll also change<a id="_idIndexMarker361"/> my phone number and make sure that everybody<a id="_idIndexMarker362"/> gets only Michael's:</p>&#13;
			<pre>class Brad(private val manager: Manager) : ... { </pre>&#13;
			<pre>   // No reference to Me here </pre>&#13;
			<pre>   ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, if somebody needs somebody else's opinion, they'll need to go through Michael first:</p>&#13;
			<pre>class Kenny(private val manager: Manager) : ... { </pre>&#13;
			<pre>   // No reference to George, or anyone else </pre>&#13;
			<pre>   ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>As you can see, there's nothing new we can learn about Kotlin through this pattern. </p>&#13;
			<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/>Mediator flavors</h2>&#13;
			<p>There are<a id="_idIndexMarker363"/> two <em class="italic">flavors</em> to the Mediator pattern. We'll call them <em class="italic">strict</em> and <em class="italic">loose</em>. We saw the strict version previously. We tell the mediator exactly what to do and expect an answer from it.</p>&#13;
			<p>The loose version will expect us to notify the mediator of what happened, but not to expect an<a id="_idIndexMarker364"/> immediate answer. Instead, if they need to notify us in return, they should call us.</p>&#13;
			<h2 id="_idParaDest-128"><a id="_idTextAnchor134"/>Mediator caveats</h2>&#13;
			<p>Michael<a id="_idIndexMarker365"/> suddenly becomes ever so important. Everybody knows only him and only he can manage their interactions. He may even become a <em class="italic">God Object</em>, all-knowing and almighty, which is an antipattern from <a href="B17816_09_ePub.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, <em class="italic">Idioms and Anti-Patterns</em>. Even if he's that important, be sure to define what this mediator should, and – even more importantly – shouldn't do.</p>&#13;
			<p>Let's continue with our example and discuss yet another behavioral pattern. </p>&#13;
			<h1 id="_idParaDest-129"><a id="_idTextAnchor135"/>Memento</h1>&#13;
			<p>Since Michael became<a id="_idIndexMarker366"/> a manager, it's been tough to catch him if I have a question. And when I do ask him something, he just throws something and runs to the next meeting. </p>&#13;
			<p>Yesterday, I asked him what new weapon we should introduce in our game. He told me it should be a <em class="italic">Coconut Cannon</em>, clear as day. But today, when I presented him with this feature, he chirped at me angrily! Finally, he said he told me to implement a <em class="italic">Pineapple Launcher</em> instead. I'm lucky he's just a canary. </p>&#13;
			<p>It would be great if I could record him so that when we have another meeting that goes awry because he's not paying full attention, I can simply replay everything he said. </p>&#13;
			<p>Let's sum up my problems first – Michael's thoughts are his and his only:</p>&#13;
			<pre>class Manager { </pre>&#13;
			<pre>    private var thoughts = mutableListOf&lt;String&gt;()</pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>The problem is that since Michael is a canary, he can only hold <code>2</code> thoughts in his mind:</p>&#13;
			<pre>class Manager {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    fun think(thought: String) {</pre>&#13;
			<pre>        thoughts.add(thought)</pre>&#13;
			<pre>        if (thoughts.size &gt; 2) {</pre>&#13;
			<pre>            thoughts.removeFirst()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>If Michael thinks about more than <code>2</code> things at a time, he'll forget the first thing he thought <a id="_idIndexMarker367"/>about:</p>&#13;
			<pre>michael.think("Need to implement Coconut Cannon")</pre>&#13;
			<pre>michael.think("Should get some coffee")</pre>&#13;
			<pre>michael.think("Or maybe tea?") // Forgot about Coconut   Cannon</pre>&#13;
			<pre>michael.think("No, actually, let's implement Pineapple   Launcher") // Forgot that he wanted coffee</pre>&#13;
			<p>Even in the recording, what he says is quite hard to understand (because he doesn't return anything).</p>&#13;
			<p>And even if I do record him, Michael can claim it's what he said, not what he meant.</p>&#13;
			<p>The Memento design pattern solves this problem by saving the internal state of an object, which can't be altered from the outside (so that Michael cannot deny that he said it) and can only be used by the object itself.</p>&#13;
			<p>In Kotlin, we can use an <code>inner</code> class to implement this:</p>&#13;
			<pre>class Manager { </pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    inner class Memory(private val mindState: List&lt;String&gt;) {</pre>&#13;
			<pre>        fun restore() {</pre>&#13;
			<pre>            thoughts = mindState.toMutableList()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see a new keyword, <code>inner</code>, for marking our class. If we omit this keyword, the class is called <code>Nested</code> and is similar to the static nested class from Java. Inner classes have access to the private fields of the outer class. For that reason, our <code>Memory</code> class can change the internal state of the <code>Manager</code> class easily.</p>&#13;
			<p>Now, we can record what Michael says at this moment by creating an imprint of the current state:</p>&#13;
			<pre>fun saveThatThought(): Memory {</pre>&#13;
			<pre>    return Memory(thoughts.toList())</pre>&#13;
			<pre>}</pre>&#13;
			<p>At this point, we <a id="_idIndexMarker368"/>can capture his thoughts in an object:</p>&#13;
			<pre>val michael = Manager()</pre>&#13;
			<pre>michael.think("Need to implement Coconut Cannon")</pre>&#13;
			<pre>michael.think("Should get some coffee")</pre>&#13;
			<pre>val memento = michael.saveThatThought()</pre>&#13;
			<pre>michael.think("Or maybe tea?")</pre>&#13;
			<pre>michael.think("No, actually, let's implement Pineapple   Launcher")</pre>&#13;
			<p>Now, we need to add a means of going back to a previous line of thought:</p>&#13;
			<pre>class Manager {</pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    fun `what was I thinking back then?`(memory: Memory) {</pre>&#13;
			<pre>        memory.restore()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that if we want to use special characters in function names, such as spaces, we can, but only if a function name is wrapped in <em class="italic">backticks</em>. Usually, that's not the best idea, but it has its uses, as we'll cover in <a href="B17816_10_ePub.xhtml#_idTextAnchor237"><em class="italic">Chapter 10</em></a>, <em class="italic">Concurrent Microservices with Ktor</em>.</p>&#13;
			<p>What's left is using <code>memento</code> to go back in time:</p>&#13;
			<pre>with(michael) {</pre>&#13;
			<pre>    think("Or maybe tea?")</pre>&#13;
			<pre>    think("No, actually, let's implement Pineapple         Launcher")</pre>&#13;
			<pre>}</pre>&#13;
			<pre>michael.`what was I thinking back then?`(memento)</pre>&#13;
			<p>The last invocation will return Michael's mind to thinking about Coconut Cannon, of all things.</p>&#13;
			<p>Note how we use the <code>with</code> standard function to avoid repeating <code>michael.think()</code> on each line. This function is helpful if you need to refer to the same object often in the same block of<a id="_idIndexMarker369"/> code and would like to avoid repetition.</p>&#13;
			<p>I don't expect you to see the Memento design pattern implemented very often in the real world. But it still may be useful in some types of applications that need to recover to some previous state.</p>&#13;
			<p>At the beginning of this chapter, we discussed the Iterator design pattern, which helps us work with complex data structures. Next, we'll look at another design pattern with a somewhat similar goal. </p>&#13;
			<h1 id="_idParaDest-130"><a id="_idTextAnchor136"/>Visitor</h1>&#13;
			<p>This design <a id="_idIndexMarker370"/>pattern is usually a close friend of the Composite design pattern, which we discussed in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>. It can<a id="_idIndexMarker371"/> either extract data from a complex tree-like structure or add behavior to each node of the tree, much like the Decorator design pattern does for a single object.</p>&#13;
			<p>My plan, being a lazy software architect, worked out quite well. My request-answering system from the chain of responsibility worked quite well and I don't have plenty of time for coffee. But I'm afraid some developers begin to suspect that I'm a bit of a fraud.</p>&#13;
			<p>To confuse them, I plan to produce weekly emails with links to all the latest buzzword articles. Of <a id="_idIndexMarker372"/>course, I don't plan to read them myself – I just want to collect them from some popular technology sites.</p>&#13;
			<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>Writing a crawler</h2>&#13;
			<p>Let's look <a id="_idIndexMarker373"/>at the following data structure, which is very similar to what we had when we discussed the Iterator design pattern:</p>&#13;
			<pre>Page(Container(Image(), </pre>&#13;
			<pre>               Link(), </pre>&#13;
			<pre>               Image()), </pre>&#13;
			<pre>     Table(), </pre>&#13;
			<pre>     Link(), </pre>&#13;
			<pre>     Container(Table(), </pre>&#13;
			<pre>               Link()), </pre>&#13;
			<pre>     Container(Image(), </pre>&#13;
			<pre>               Container(Image(), </pre>&#13;
			<pre>                         Link())))</pre>&#13;
			<p><code>Page</code> is a container for other HTML elements, but not <code>HtmlElement</code> by itself. <code>Container</code> holds other containers, tables, links, and images. <code>Image</code> holds its link in the <code>src</code> attribute. <code>Link</code> has the <code>href</code> attribute instead.</p>&#13;
			<p>What we would like to do is extract all the URLs from the object.</p>&#13;
			<p>We will start by creating a function that will receive the root of our object tree – a <code>Page</code> container, in this case – and return a list of all the available links:</p>&#13;
			<pre>fun collectLinks(page: Page): List&lt;String&gt; { </pre>&#13;
			<pre>    // No need for intermediate variable there </pre>&#13;
			<pre>    return LinksCrawler().run { </pre>&#13;
			<pre>        page.accept(this) </pre>&#13;
			<pre>        this.links </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Using <code>run</code> allows us to control what we return from the block's body. In this case, we will return the <code>links</code> objects we've gathered. Inside the <code>run</code> block, this refers to the object it operates on – in our case, <code>LinksCrawler</code>.</p>&#13;
			<p>In Java, the suggested way to implement the Visitor design pattern is to add a method for each class that will accept our new functionality. We'll do the same, but not for all the <a id="_idIndexMarker374"/>classes. Instead, we'll only define this method for container elements:</p>&#13;
			<pre>private fun Container.accept(feature: LinksCrawler) { </pre>&#13;
			<pre>    feature.visit(this) </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>// Or using a shorter syntax: </pre>&#13;
			<pre>private fun Page.accept(feature: LinksCrawler) =   feature.visit(this)</pre>&#13;
			<p>Our feature will need to hold a collection internally and expose it for read purposes. In Java, we will only specify the getter for this member; no setter is required. In Kotlin, we can specify the value without a backing field:</p>&#13;
			<pre>class LinksCrawler { </pre>&#13;
			<pre>    private var _links = mutableListOf&lt;String&gt;() </pre>&#13;
			<pre> </pre>&#13;
			<pre>    val links </pre>&#13;
			<pre>        get()= _links.toList() </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>We want our data structure to be immutable. That's the reason we're calling <code>toList()</code> on it.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">The functions that iterate over branches could be simplified even further if we use the Iterator design pattern.</p>&#13;
			<p>For containers, we<a id="_idIndexMarker375"/> simply pass their elements further:</p>&#13;
			<pre>class LinksCrawler { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    fun visit(page: Page) { </pre>&#13;
			<pre>        visit(page.elements) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun visit(container: Container) =         visit(container.elements) </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Specifying the parent class as <code>sealed</code> helps the compiler further. We discussed sealed classes earlier in this chapter while covering the State design pattern. Here is the code:</p>&#13;
			<pre>sealed class HtmlElement </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Container(...) : HtmlElement(){ </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Image(...) : HtmlElement() { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Link(...) : HtmlElement() { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Table : HtmlElement()</pre>&#13;
			<p>The most<a id="_idIndexMarker376"/> interesting logic is in the leaves of our tree-like structure:</p>&#13;
			<pre>class LinksCrawler { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    private fun visit(elements: List&lt;HtmlElement&gt;) { </pre>&#13;
			<pre>        for (e in elements) { </pre>&#13;
			<pre>            when (e) { </pre>&#13;
			<pre>                is Container -&gt; e.accept(this) </pre>&#13;
			<pre>                is Link -&gt; _links.add(e.href) </pre>&#13;
			<pre>                is Image -&gt; _links.add(e.src) </pre>&#13;
			<pre>                else -&gt; {} </pre>&#13;
			<pre>            } </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that in some cases, we don't want to do anything. This is specified by an empty block in our <code>else</code> clause, <code>else -&gt; {}</code>. This is yet another example of <strong class="bold">smart casts</strong> in Kotlin. </p>&#13;
			<p>Notice that after we checked that the element is a <code>Link</code>, we gained type-safe access to its <code>href</code> attribute. That's because the compiler is doing the casts for us. The same is true for the <code>Image</code> element.</p>&#13;
			<p>Although we achieved our goals, the usability of this pattern can be debated. As you can see, it's one<a id="_idIndexMarker377"/> of the more verbose elements we have and introduces tight coupling between classes that are receiving additional behavior and the Visitor pattern itself.</p>&#13;
			<h1 id="_idParaDest-132"><a id="_idTextAnchor138"/>Template method</h1>&#13;
			<p>Some lazy <a id="_idIndexMarker378"/>people make art out of their laziness. Take me, for example. Here's my daily schedule:</p>&#13;
			<ol>&#13;
				<li value="1">8:00 A.M. – 9:00 A.M.: Arrive at the office</li>&#13;
				<li>9:00 A.M. – 10:00 A.M.: Drink coffee</li>&#13;
				<li>10:00 A.M. –1 2:00 P.M.: Attend some meetings or review code</li>&#13;
				<li>12:00 P.M. – 1:00 P.M.: Go out for lunch</li>&#13;
				<li>1:00 P.M. – 4:00 P.M.: Attend some meetings or review code</li>&#13;
				<li>4:00 P.M.: Sneak back home</li>&#13;
			</ol>&#13;
			<p>Some parts of my schedule never change, while some do. Specifically, I have two slots in my calendar that any number of meetings could occupy. </p>&#13;
			<p>At first, I thought I could decorate my changing schedule with that setup and teardown logic, which happens before and after. But then there's lunch, which is holy for architects and happens in between.</p>&#13;
			<p>Java is pretty clear on what you should do. First, you create an abstract class. Then, you mark all the <a id="_idIndexMarker379"/>methods that you want to implement by yourself as <code>private</code>:</p>&#13;
			<pre>abstract class DayRoutine { </pre>&#13;
			<pre>    private fun arriveToWork() { </pre>&#13;
			<pre>        println("Hi boss! I appear in the office </pre>&#13;
			<pre>            sometimes!") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    private fun drinkCoffee() { </pre>&#13;
			<pre>        println("Coffee is delicious today") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre> </pre>&#13;
			<pre>    private fun goToLunch() { </pre>&#13;
			<pre>        println("Hamburger and chips, please!") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre> </pre>&#13;
			<pre>    private fun goHome() { </pre>&#13;
			<pre>        // Very important no one notices me, so I must keep         // quiet! </pre>&#13;
			<pre>        println() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>All the methods that are changing from day to day should be defined as <code>abstract</code>:</p>&#13;
			<pre>abstract class DayRoutine { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    abstract fun doBeforeLunch() </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    abstract fun doAfterLunch() </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>If you want to be<a id="_idIndexMarker380"/> able to replace a function but also want to provide a default implementation, you should leave it <code>public</code>:</p>&#13;
			<pre>abstract class DayRoutine { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    open fun bossHook() { </pre>&#13;
			<pre>        // Hope he doesn't hook me there </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Remember that <code>public</code> is the default visibility in Kotlin.</p>&#13;
			<p>Finally, you have a method that executes your algorithm. It's <code>final</code> by default:</p>&#13;
			<pre>abstract class DayRoutine { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    fun runSchedule() { </pre>&#13;
			<pre>        arriveToWork() </pre>&#13;
			<pre>        drinkCoffee() </pre>&#13;
			<pre>        doAfterLunch() </pre>&#13;
			<pre>        goToLunch() </pre>&#13;
			<pre>        doAfterLunch() </pre>&#13;
			<pre>        goHome() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, if we want <a id="_idIndexMarker381"/>to have a schedule for Monday, we can simply implement the missing parts:</p>&#13;
			<pre>class MondaySchedule : DayRoutine() { </pre>&#13;
			<pre>    override fun doBeforeLunch() { </pre>&#13;
			<pre>        println("Some pointless meeting") </pre>&#13;
			<pre>        println("Code review. What this does?") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun doAfterLunch() { </pre>&#13;
			<pre>        println("Meeting with Ralf") </pre>&#13;
			<pre>        println("Telling jokes to other architects") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun bossHook() { </pre>&#13;
			<pre>        println("Hey, can I have you for a sec in my             office?") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p><em class="italic">What does Kotlin add on top of that?</em> What it usually does – conciseness. As we saw previously, this can be achieved through functions.</p>&#13;
			<p>We have three <em class="italic">moving parts</em> – two mandatory activities (the software architect must do something before and after lunch) and one optional (the boss may stop him before he sneaks off home):</p>&#13;
			<pre>fun runSchedule(beforeLunch: () -&gt; Unit, </pre>&#13;
			<pre>               afterLunch: () -&gt; Unit, </pre>&#13;
			<pre>               bossHook: (() -&gt; Unit)? = fun() { println() }) { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>We'll have a function that accepts up to three other functions as its arguments. The first two are <a id="_idIndexMarker382"/>mandatory, while the third may not be supplied at all or assigned with <code>null</code> to explicitly state that we don't want that function to occur:</p>&#13;
			<pre>fun runSchedule(...) { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    arriveToWork() </pre>&#13;
			<pre>    drinkCoffee() </pre>&#13;
			<pre>    <strong class="bold">beforeLunch()</strong> </pre>&#13;
			<pre>    goToLunch() </pre>&#13;
			<pre>    <strong class="bold">afterLunch()</strong> </pre>&#13;
			<pre>    <strong class="bold">bossHook?.let { it() }</strong> </pre>&#13;
			<pre>    goHome() </pre>&#13;
			<pre>}</pre>&#13;
			<p>Inside this function, we'll have our algorithm. The invocations of <code>beforeLunch()</code> and <code>afterLunch()</code> should be clear; after all, those are the functions that are passed to us as arguments. The third one, <code>bossHook</code>, may be <code>null</code>, so we only execute it if it's not. We can use the following construct for that:</p>&#13;
			<pre>?.let { it() }</pre>&#13;
			<p><em class="italic">But what about the other functions – the ones we want to always implement by ourselves? </em></p>&#13;
			<p>Kotlin has a <a id="_idIndexMarker383"/>notion of <strong class="bold">local functions</strong>. These are functions that reside in other functions:</p>&#13;
			<pre>fun runSchedule(...) { </pre>&#13;
			<pre>    fun arriveToWork(){ </pre>&#13;
			<pre>        println("How are you all?") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    val drinkCoffee = { println("Did someone left the milk         out?") } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun goToLunch() = println("I would like something         italian") </pre>&#13;
			<pre> </pre>&#13;
			<pre>    val goHome = fun () { </pre>&#13;
			<pre>        println("Finally some rest") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    arriveToWork() </pre>&#13;
			<pre>    drinkCoffee() </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    goToLunch() </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    goHome() </pre>&#13;
			<pre>}</pre>&#13;
			<p>These are all valid ways to declare a local function. No matter how you define them, they're invoked in the same way. Local functions can only be accessed by the parent function they were declared in and are a great way to extract common logic without the need to expose it.</p>&#13;
			<p>With that, we're left with the code structure. Defining the algorithm's structure but letting others decide what to do at some points – that's what the Template method is all about.</p>&#13;
			<p>We're almost<a id="_idIndexMarker384"/> at the end of this chapter. There is just one more design pattern to discuss, but it's one of the most important ones. </p>&#13;
			<h1 id="_idParaDest-133"><a id="_idTextAnchor139"/>Observer</h1>&#13;
			<p>Probably one of the <a id="_idIndexMarker385"/>highlights of this chapter, this design pattern provides us with a bridge to the following chapters, which are dedicated to functional programming.</p>&#13;
			<p><em class="italic">So, what is the</em> <strong class="bold">Observer</strong> <em class="italic">pattern all about?</em> You have one <em class="italic">publisher</em>, which may also be called a <em class="italic">subject</em>, that may have many <em class="italic">subscribers</em>, also known as <em class="italic">observers</em>. Each time something interesting happens with the publisher, all of its subscribers should be updated. </p>&#13;
			<p>This may look a lot like the <strong class="bold">Mediator</strong> design pattern, but there's a twist. Subscribers should be able to register or unregister themselves at runtime. </p>&#13;
			<p>In the classical implementation, all subscribers/observers need to implement a particular interface for the publisher to update them. But since Kotlin has higher-order functions, we can omit this part. The publisher will still have to provide a means for observers to be able to subscribe and unsubscribe.</p>&#13;
			<p>This may have sounded a bit complex, so let's take a look at the following example.</p>&#13;
			<h2 id="_idParaDest-134"><a id="_idTextAnchor140"/>Animal choir example</h2>&#13;
			<p>So, some animals <a id="_idIndexMarker386"/>have decided to have a choir of their own. The cat was elected as the conductor of the choir (it doesn't like to sing anyway).</p>&#13;
			<p>The problem is that these animals escaped from the Java world, so they don't have a common interface. Instead, each has a different way of making a sound:</p>&#13;
			<pre>class Bat { </pre>&#13;
			<pre>    fun screech() { </pre>&#13;
			<pre>        println("Eeeeeee") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Turkey { </pre>&#13;
			<pre>    fun gobble() { </pre>&#13;
			<pre>        println("Gob-gob") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Dog { </pre>&#13;
			<pre>    fun bark() { </pre>&#13;
			<pre>        println("Woof") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun howl() { </pre>&#13;
			<pre>        println("Auuuu") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Luckily, the cat was elected not only because it was vocally challenged, but also because it was smart enough to follow this chapter until now. So, it knows that in the Kotlin world, it can accept functions:</p>&#13;
			<pre>class Cat {</pre>&#13;
			<pre>    fun joinChoir(whatToCall: ()-&gt;Unit) {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun leaveChoir(whatNotToCall: ()-&gt;Unit) {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Previously, we <a id="_idIndexMarker387"/>learned how to pass a new function as an argument, as well as a literal function. <em class="italic">But how do we pass a reference to a member function?</em></p>&#13;
			<p>We can do this in the same way that we did in the Strategy design pattern; that is, by using the member reference operator (<code>::</code>):</p>&#13;
			<pre>val catTheConductor = Cat() </pre>&#13;
			<pre> </pre>&#13;
			<pre>val bat = Bat() </pre>&#13;
			<pre>val dog = Dog() </pre>&#13;
			<pre>val turkey = Turkey() </pre>&#13;
			<pre> </pre>&#13;
			<pre>catTheConductor.joinChoir(bat::screech) </pre>&#13;
			<pre>catTheConductor.joinChoir(dog::howl) </pre>&#13;
			<pre>catTheConductor.joinChoir(dog::bark) </pre>&#13;
			<pre>catTheConductor.joinChoir(turkey::gobble)</pre>&#13;
			<p>Now, the cat needs to save all those subscribers somehow. Luckily, we can put them on a map. <em class="italic">What would be the key?</em> This should be the function itself:</p>&#13;
			<pre>class Cat { </pre>&#13;
			<pre>    private val participants = mutableMapOf&lt;()-&gt;Unit, ()-        &gt;Unit&gt;() </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun joinChoir(whatToCall: ()-&gt;Unit) { </pre>&#13;
			<pre>        participants[whatToCall] = whatToCall </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>If all those <code>()-&gt;Unit</code> instances<a id="_idIndexMarker388"/> are making you dizzy, be sure to use <code>typealias</code> to give them more semantic meaning, such as <em class="italic">subscriber</em>.</p>&#13;
			<p>Now, the bat decides to leave the choir. After all, no one can hear its beautiful singing:</p>&#13;
			<pre>class Cat { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    fun leaveChoir(whatNotToCall: ()-&gt;Unit) { </pre>&#13;
			<pre>        participants.remove(whatNotToCall) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>All <code>bat</code> needs to do is pass its subscriber function again:</p>&#13;
			<pre>catTheConductor.leaveChoir(bat::screech)</pre>&#13;
			<p>That's the reason we used the map in the first place. Now, the cat can call all its choir members and tell them to sing – well, produce sounds:</p>&#13;
			<pre>typealias Times = Int </pre>&#13;
			<pre>class Cat { </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>    fun conduct(n: Times) { </pre>&#13;
			<pre>        for (p in participants.values) { </pre>&#13;
			<pre>            for (i in 1..n) { </pre>&#13;
			<pre>                p() </pre>&#13;
			<pre>            } </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>So, the rehearsal <a id="_idIndexMarker389"/>went well. But the cat is very tired after doing all those loops. It would rather delegate the job to choir members. That's not a problem:</p>&#13;
			<pre>class Cat { </pre>&#13;
			<pre>    private val participants = mutableMapOf&lt;(Int)-&gt;Unit, </pre>&#13;
			<pre>         (Int)-&gt;Unit&gt;() </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun joinChoir(whatToCall: (Int)-&gt;Unit) { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun leaveChoir(whatNotToCall: (Int)-&gt;Unit) { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun conduct(n: Times) { </pre>&#13;
			<pre>        for (p in participants.values) { </pre>&#13;
			<pre>            p(n) </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Our subscribers will have to change slightly to receive a new argument. Here's an example <a id="_idIndexMarker390"/>for the <code>Turkey</code> class: </p>&#13;
			<pre>class Turkey { </pre>&#13;
			<pre>    fun gobble(repeat: Times) { </pre>&#13;
			<pre>        for (i in 1..repeat) { </pre>&#13;
			<pre>            println("Gob-gob") </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>This is a bit of a problem. <em class="italic">What if the cat was to tell each animal what sound to make: high or low?</em> We'd have to change all the subscribers again, as well as the cat.</p>&#13;
			<p>While designing your publisher, pass the single data classes with many properties, instead of sets of data classes or other types. That way, you won't have to refactor your subscribers as much if new properties are added:</p>&#13;
			<pre>enum class SoundPitch {HIGH, LOW} </pre>&#13;
			<pre>data class Message(val repeat: Times, val pitch:     SoundPitch) </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Bat { </pre>&#13;
			<pre>    fun screech(message: Message) { </pre>&#13;
			<pre>        for (i in 1..message.repeat) { </pre>&#13;
			<pre>            println("${message.pitch} Eeeeeee") </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we used <code>enum</code> to describe the different types of pitches and a data class to encapsulate <a id="_idIndexMarker391"/>the pitch to be used, as well as how many times the message should be repeated.</p>&#13;
			<p>Make sure that your messages are immutable. <em class="italic">Otherwise, you may experience strange behavior! What if you have sets of different messages you're sending from the same publisher?</em> We could use smart casts to solve this:</p>&#13;
			<pre>interface Message { </pre>&#13;
			<pre>    val repeat: Times </pre>&#13;
			<pre>    val pitch: SoundPitch  </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>data class LowMessage(override val repeat: Times) : Message { </pre>&#13;
			<pre>    override val pitch = SoundPitch.LOW </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>data class HighMessage(override val repeat: Times) : </pre>&#13;
			<pre>  Message { </pre>&#13;
			<pre>    override val pitch = SoundPitch.HIGH </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Bat { </pre>&#13;
			<pre>    fun screech(message: Message) { </pre>&#13;
			<pre>        when (message) { </pre>&#13;
			<pre>            is HighMessage -&gt; { </pre>&#13;
			<pre>                for (i in 1..message.repeat) { </pre>&#13;
			<pre>                    println("${message.pitch} Eeeeeee") </pre>&#13;
			<pre>                } </pre>&#13;
			<pre>            } </pre>&#13;
			<pre>            else -&gt; println("Can't :(") </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>The Observer design pattern is enormously useful. Its power lies in its flexibility. The publisher doesn't need to know anything about the subscribers, except the signature of the function it invokes. In the real world, it is widely used both in reactive frameworks, which we'll <a id="_idIndexMarker392"/>discuss in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>, and <a href="B17816_11_ePub.xhtml#_idTextAnchor251"><em class="italic">Chapter 11</em></a>, <em class="italic">Reactive Microservices with Vert.x</em>, and in Android, where all the UI events are implemented as subscriptions. </p>&#13;
			<h1 id="_idParaDest-135"><a id="_idTextAnchor141"/>Summary</h1>&#13;
			<p>This was a long chapter, but we've also learned a lot. We finished covering all the classical design patterns, including 11 behavioral ones. In Kotlin, functions can be passed to other functions, returned from functions, and assigned to variables. That's what the higher-order functions and functions as first-class citizens concepts are all about. If your class is all about behavior, it often makes sense to replace it with a function. This concept helped us implement the Strategy and Command design patterns.</p>&#13;
			<p>We learned that the Iterator design pattern is yet another <code>operator</code> in the language. Sealed classes make the <code>when</code> statements exhaustive and we used them to implement the State design pattern. </p>&#13;
			<p>We also looked at the Interpreter design pattern and learned that lambda with a receiver allows clearer syntax in your DSLs. Another keyword, <code>lateinit</code>, tells the compiler to relax a bit when it's performing its null safety checks. <em class="italic">Use it with care!</em> </p>&#13;
			<p>Finally, we covered how to reference an existing method with function references while talking about the Observer design pattern.</p>&#13;
			<p>In the next chapter, we'll move on from the object-oriented programming paradigm, with its well-known design patterns, to another paradigm – functional programming.</p>&#13;
			<h1 id="_idParaDest-136"><a id="_idTextAnchor142"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What's the difference between the Mediator and Observer design patterns?</li>&#13;
				<li>What is a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>)?</li>&#13;
				<li>What are the benefits of using a sealed class or interface?</li>&#13;
			</ol>&#13;
		</p>&#13;
	</div></body></html>