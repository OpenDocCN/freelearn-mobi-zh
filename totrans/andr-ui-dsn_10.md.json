["```java\nres/xml/network_security_config.xml:\n```", "```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n\n... \n\n<app ...> \n\n   <meta-data android:name=\"android.security.net.config\" \n              android:resource=\"@xml/network_security_config\" /> \n\n... \n\n</app> \n\n```", "```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<network-security-config> \n   <base-config> \n\n//This is the default configuration used by all connections that are not covered by a specific domain-config// \n\n       <trust-anchors> \n\n<certificates src=\"img/trusted_cas\"/> \n\n        //This is a reference to an XML file where you'd name any trusted Certificate Authorities//  \n\n       </trust-anchors> \n\n   </base-config> \n\n   <domain-config> \n\n       <domain>mydomain.com</domain> \n\n... \n... \n\n //This is where you'd create a configuration to use for connections to a specific destination, in this example that's www.mydomain.com//   \n\n        </domain-config> \n</network-security-config>\n\n```", "```java\n<manifest     \n\n package=\"com.me.app.myapp\" > \n\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/> \n       android:label=\"@string/permlab_fineLocation\" \n\n//Provide a label for each permission your app requests, using android:label. This label is displayed to the user when they're viewing a list of permissions. Try to keep this label short - a few words will usually be sufficient//   \n\n       android:description=\"@string/permdesc_fineLocation\" \n\n//Describe what granting this permission request will allow your app to do, using the android:description attribute. Ideally, your descriptions will be two sentences long - the first should describe the permission that's being requested, and the second should warn the user about the dangers of granting this particular permission//   \n\n       android:protectionLevel=\"dangerous\" /> \n\n//Indicates the potential risk associated with this permission. The possible values are normal, dangerous, signature, and SignatureOrSystem//   \n   ... \n</manifest> \n\n```", "```java\n <string name=\"permlab_fineLocation\">Precise location (GPS and network-based)</string> \n\n   <string name=\"permdesc_fineLocation\"> \nThis app will be able to retrieve your precise location using the GPS or network location sources. Apps may consume additional battery power while using location services</string> \n\n```", "```java\nint permissionCheck = ContextCompat.checkSelfPermission(this,                Manifest.permission.INTERNET); \n\n```", "```java\nif (ContextCompat.checkSelfPermission(myActivity, \n               Manifest.permission.INTERNET) \n\n//Does this app have permission to access the Internet?//  \n\n       != PackageManager.PERMISSION_GRANTED) { \n      if (ActivityCompat.shouldShowRequestPermissionRationale(myActivity, \n           Manifest.permission.INTERNET)) { \n\n//If shouldShowRequestPermissionRationale returns true, the app doesn't currently have this permission, and you'll need to request access//  \n           .......... \n      .......... \n\n   } else { \n\n         ActivityCompat.requestPermissions(myActivity, \n\n//Request the permission. Note, when your app calls requestPermissions(),the system displays a standard dialogue that you cannot customize. If you want to provide some additional information, such as an explanation about why your app needs this permission, you must do so before calling requestPermissions()// \n\n               new String[]{Manifest.permission.INTERNET}, \n               MY_PERMISSIONS_REQUEST_INTERNET); \n\n   } \n} \n\n```", "```java\n@Override \npublic void onRequestPermissionsResult(int requestCode, \n       String permissions[], int[] grantResults) { \n//The Activity's onRequestPermissionsResult method is called and passes the user's response//  \n   switch (requestCode) { \n       case MY_PERMISSIONS_REQUEST_INTERNET: { \n                    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { \n........ \n......... \n// If the user has granted the permission, this is where you'd perform your app's Internet-related tasks//  \n\n           } else { \n.......   \n....... \n// The user has denied the permission request. This is where you'd disable the functionality that depends on Internet access. Since denying a permission may prevent parts of your app from working correctly, you may also want to provide some feedback explaining what impact denying this permission will have on your app's functionality//   \n\n           } \n           return; \n       } \n\n   } \n} \n\n```", "```java\n<uses-feature android:name=\"android.hardware.camera\" /> \n\n```", "```java\n<uses-feature android:name=\"android.hardware.camera\" \n             android:required=\"true\"/> \n\n```", "```java\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" /> \n\n```", "```java\nNotificationCompat.Builder nBuilder = new NotificationCompat.Builder(context) \n       .setContentTitle(\"This is a notification title\")  \n\n//Sets the notification's title// \n\n      .setContentText(\"This is the notification's body text.\")  \n\n//Sets the second line of the notification's text// \n\n            .addAction(R.drawable.accept, \"Download\", pIntent) \n\n//Adds a 'Download' action to this notification, complete with icon// \n\n      .addAction(R.drawable.cancel, \"Cancel\", pIntent); \n\n//Adds a 'Cancel' button, complete with icon - this time the R.drawable.cancel icon//  \n\n```", "```java\n.setStyle(new NotificationCompat.BigTextStyle() \n               .bigText(\"This text replaces the context text in the big view\")) \n\n```", "```java\n.setStyle(new Notification.BigPictureStyle() \n        .bigPicture(aBigImage)) \n\n```", "```java\n.setStyle(new Notification.InboxStyle() \n        .addLine(string1) \n        .addLine(string2) \n        .addLine(string3) \n        .setSummaryText(\"+2 more\")) \n\n```", "```java\nprivate static final String KEY_QUICK_REPLY = \"key_quick_reply\"; \nString replyLabel = getResources().getString(R.string.reply_label); \nRemoteInput remoteInput = new RemoteInput.Builder(KEY_QUICK_REPLY) \n       .setLabel(replyLabel) \n       .build(); \n\n```", "```java\n   Bundle remoteInput =\n RemoteInput.getResultsFromIntent(intent); \n\n//This method returns a Bundle that contains the text response// \n\n   if (remoteInput != null) { \n           return remoteInput.getCharSequence(KEY_QUICK_REPLY); \n\n//Query the bundle using the result key, which is provided to the RemoteInput.Builder constructor// \n\n```", "```java\nfinal static String GROUP_KEY_MESSAGES = \"group_key_messages\"; \nNotification notif = new NotificationCompat.Builder(mContext) \n        .setContentTitle(\"New SMS from \" + sender1) \n        .setContentText(subject1) \n        .setSmallIcon(R.drawable.new_message) \n        .setGroup(GROUP_KEY_MESSAGES) \n        .build(); \n\n```", "```java\nNotification notif2 = new NotificationCompat.Builder(mContext) \n   .setContentTitle(\"New SMS from \" + sender1) \n    .setContentText(subject2) \n     .setGroup(GROUP_KEY_MESSAGES) \n  .build(); \n\n```", "```java\n<receiver android:name=\"MyAppWidgetProvider\" > \n\n//Specifies the AppWidgetProvider that's used by this widget// \n\n   <intent-filter> \n\n       <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /> \n\n//The <action> element specifies that this AppWidgetProvider accepts the ACTION_APPWIDGET_UPDATE. This is the only broadcast event you need to declare explicitly, as the AppWidgetManager class forwards all other app widget broadcasts to the AppWidgetProvider automatically// \n\n   </intent-filter> \n\n   <meta-data android:name=\"android.appwidget.provider\" \n\n//Specifies the AppWidgetProviderInfo resource, which in this example is   \nandroid.appwidget.provider// \n\n              android:resource=\"@xml/my_appwidget_info\" /> \n\n//The <meta-data> element also requires an android:resource attribute, which specifies the location of the AppWidgetProviderInfo resource// \n\n</receiver> \n\n```", "```java\n<appwidget-provider  \n\n   android:minWidth=\"50dp\" \n\n   android:minHeight=\"50dp\" \n\n//Specifies the minimum height and width the widget consumes by default// \n\n   android:updatePeriodMillis=\"80000000\" \n\n//This is how often the app widget framework requests an update from the AppWidgetProvider. By default, if the device is asleep when the widget requests an update, the device will wake up in order to perform this operation. For the sake of the user's battery, don't set this value too low//  \n\n   android:initialLayout=\"@layout/my_appwidget\" \n\n//The layout resource where you'll define the widget's layout// \n\n   android:resizeMode=\"horizontal\" \n\n//Specifies how the widget can be resized. The possible values are horizontal, vertical, and none. You can also combine these values, for example android:resizeMode=\"horizontal|vertical\"// \n\n   android:widgetCategory=\"home_screen\"> \n\n//Declares whether your widget can be displayed on the home screen (home_screen), the lockscreen (keyguard) or both. Only devices running lower than Android 5.0 support lockscreen widgets//  \n\n</appwidget-provider> \n\n```", "```java\n        <dimen name=\"widget_margins\">0dp</dimen>\n```", "```java\n        <dimen name=\"widget_margins\">10dp</dimen> \n\n```", "```java\nandroid:padding=\"@dimen/widget_margins\" \n\n```", "```java\nalarmManager.setRepeating(AlarmManager.RTC... \n\n```", "```java\n<ImageButton \n   android:id=\"@+id/newSMS\" \n   android:src=\"img/newSMS\" \n   android:contentDescription=\"@string/newSMS\"/> \n\n```", "```java\n   <TextView android:id=\"@+id/text\" \n      android:text=\"Hello, world\" \n        android:focusable=\"true\" \n       android:nextFocusDown=\"@+id/Button\" \n       ... /> \n   <Button android:id=\"@+id/button\" \n       android:focusable=\"true\" \n\n       android:nextFocusUp=\"@id/text\" \n       ... /> \n\n```"]