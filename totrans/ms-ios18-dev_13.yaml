- en: <st c="0">13</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">13</st>
- en: <st c="3">Exposing Your App to Siri with App Intents</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">使用应用程序意图将您的应用程序暴露给Siri</st>
- en: <st c="46">For many years, apps have lived and operated alone in system space.</st>
    <st c="115">Each app is totally isolated from the others, without the capability
    to communicate or</st> <st c="202">expose data.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46">多年来，应用程序一直独立于系统空间中生活和运行。</st> <st c="115">每个应用程序与其他应用程序完全隔离，没有能力进行通信或</st>
    <st c="202">暴露数据。</st>
- en: <st c="214">Over the years, things have changed a bit.</st> <st c="258">One
    of the most exciting</st> <st c="282">features apps gained was enhancements in</st>
    **<st c="324">App Intents</st>**<st c="335">. At this point, you should be familiar
    with App Intents—we discussed them in</st> [*<st c="413">Chapter 5</st>*](B21795_05.xhtml#_idTextAnchor186)<st
    c="422">. However, in iOS 18, App Intents became even more powerful as they worked
    closely with Apple Intelligence and not just with WidgetKit.</st> <st c="558">That’s
    why we are going to cover App Intents in</st> <st c="606">more detail.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="214">多年来，事情发生了一些变化。</st> <st c="258">应用程序获得的最令人兴奋的</st> <st c="282">特性之一是**<st
    c="324">应用程序意图**</st>的增强。<st c="335">此时，你应该熟悉应用程序意图——我们在**<st c="413">第5章</st>**中讨论了它们。</st>
    <st c="422">然而，在iOS 18中，应用程序意图变得更加强大，因为它们与Apple Intelligence紧密合作，而不仅仅是与WidgetKit。</st>
    <st c="558">这就是为什么我们将更详细地介绍应用程序意图。</st>
- en: <st c="618">In this chapter, we will learn about</st> <st c="656">the following:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="618">在本章中，我们将学习以下内容：</st> <st c="656">以下内容：</st>
- en: <st c="670">Understanding the App</st> <st c="693">Intents concept</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="670">理解应用程序</st> <st c="693">意图概念</st>
- en: <st c="708">Creating a simple</st> <st c="727">app intent</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="708">创建一个简单的</st> <st c="727">应用程序意图</st>
- en: <st c="737">Formalizing our content using</st> <st c="768">app entities</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="737">使用</st> <st c="768">应用程序实体</st>正式化我们的内容
- en: <st c="780">Adjusting our app intents to work with</st> <st c="820">Apple Intelligence</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="780">调整我们的应用程序意图以与</st> <st c="820">Apple Intelligence</st>
- en: <st c="838">The ability of App Intents to open up our app is truly remarkable
    and full of potential.</st> <st c="928">But first, let’s understand the App</st>
    <st c="964">Intents concept.</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="838">应用程序意图打开我们应用程序的能力真正令人印象深刻，充满潜力。</st> <st c="928">但首先，让我们了解应用程序</st>
    <st c="964">意图概念。</st>
- en: <st c="980">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="980">技术要求</st>
- en: <st c="1003">For this chapter, it’s essential to download Xcode version 16.0
    or higher from the</st> <st c="1087">App Store.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1003">对于本章，从App Store下载Xcode版本16.0或更高版本是必不可少的。</st> <st c="1087">App
    Store。</st>
- en: <st c="1097">Ensure you’re operating on the most recent version of macOS (Ventura
    or newer).</st> <st c="1178">Just search for Xcode in the App Store, choose the
    latest version, and proceed with the download.</st> <st c="1276">Open Xcode and
    complete any further setup instructions that appear.</st> <st c="1344">After Xcode
    is completely up and running, you</st> <st c="1390">can begin.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1097">确保您正在使用最新的macOS版本（Ventura或更新版本）。</st> <st c="1178">只需在App Store中搜索Xcode，选择最新版本，然后继续下载。</st>
    <st c="1276">打开Xcode并完成出现的任何进一步设置说明。</st> <st c="1344">在Xcode完全运行后，您</st> <st
    c="1390">就可以开始了。</st>
- en: <st c="1400">This chapter includes many code examples, some of which can be
    found in the following GitHub</st> <st c="1494">repository:</st> [<st c="1505">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013)<st
    c="1592">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1400">本章包含许多代码示例，其中一些可以在以下GitHub</st> <st c="1494">仓库中找到：</st> [<st c="1505">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013)<st
    c="1592">。</st>
- en: <st c="1593">Notice that some examples in this chapter require running on a
    modern device, such as an iPhone 15 Pro/Max, iPad with M1 and above, or Apple</st>
    <st c="1735">Silicon Mac.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1593">请注意，本章中的一些示例需要在现代设备上运行，例如iPhone 15 Pro/Max、搭载M1及更高版本的iPad或Apple</st>
    <st c="1735">Silicon Mac。</st>
- en: <st c="1747">Understanding the App Intents concept</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1747">理解应用程序意图概念</st>
- en: <st c="1785">We first encountered App Intents</st> <st c="1818">in</st> [*<st
    c="1822">Chapter 1</st>*](B21795_01.xhtml#_idTextAnchor014) <st c="1831">and then
    in</st> [*<st c="1844">Chapter 5</st>*](B21795_05.xhtml#_idTextAnchor186)<st c="1853">,
    when we discussed WidgetKit.</st> <st c="1884">But do we really understand the
    concept of App Intents?</st> <st c="1940">Let’s get a short background about Apple’s
    efforts to integrate AI deeply inside the system across many apps, including</st>
    <st c="2060">third-party apps.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1785">我们第一次遇到应用意图是在</st> [*<st c="1822">第一章</st>*](B21795_01.xhtml#_idTextAnchor014)
    <st c="1831">然后是在</st> [*<st c="1844">第五章</st>*](B21795_05.xhtml#_idTextAnchor186)
    <st c="1853">，当我们讨论WidgetKit时。</st> <st c="1884">但我们真的理解应用意图的概念吗？</st> <st c="1940">让我们简要了解一下苹果在多个应用中，包括</st>
    <st c="2060">第三方应用中，将人工智能深度集成到系统中的努力。</st>
- en: <st c="2077">To implement this integration, we need to create an API for our
    app that exposes the app’s core content and main actions.</st> <st c="2200">For
    example, a to-do app can create an API that lets Siri or other system components
    create a new task, complete an existing task, or pull the list of tasks stored
    in core data.</st> <st c="2378">A delivery app can have an API that returns an
    answer to whether the delivery services are now open or at what time the</st>
    <st c="2498">delivery arrives.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2077">为了实现这一集成，我们需要为我们的应用创建一个API，该API可以公开应用的核心内容和主要操作。</st> <st c="2200">例如，一个待办事项应用可以创建一个API，允许Siri或其他系统组件创建一个新任务，完成现有任务，或从核心数据中检索任务列表。</st>
    <st c="2378">一个配送应用可以有一个API，返回配送服务是否现在开放或配送到达的时间。</st>
- en: <st c="2515">This API, called App Intents, is our way of exposing our app’s
    main use cases and content to the world.</st> <st c="2620">It’s one of the tools
    we use to integrate our app with Apple Intelligence</st> <st c="2694">as well.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2515">这个名为App Intents的API，是我们向世界展示我们应用的主要用例和内容的方式。</st> <st c="2620">它是我们用来将应用与苹果智能集成</st>
    <st c="2694">的工具之一。</st>
- en: <st c="2702">If this sounds complex, you’ll be surprised how simple it is to
    create an app intent.</st> <st c="2789">Let’s see how</st> <st c="2803">it works.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2702">如果这听起来很复杂，你会惊讶于创建应用意图有多么简单。</st> <st c="2789">让我们看看它是如何工作的。</st>
- en: <st c="2812">Creating a simple app intent</st>
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2812">创建一个简单的应用意图</st>
- en: <st c="2841">To demonstrate how to create</st> <st c="2870">an app intent, let’s
    imagine we have an amazing to-do list.</st> <st c="2931">Not just amazing, even
    mighty!</st> <st c="2962">So, we’ll call</st> <st c="2977">it</st> `<st c="2980">MightyTasksList</st>`<st
    c="2995">.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2841">为了演示如何创建</st> <st c="2870">应用意图，让我们想象我们有一个令人惊叹的待办事项列表。</st> <st
    c="2931">不仅仅是令人惊叹，甚至是强大的！</st> <st c="2962">所以，我们将它称为</st> <st c="2977">它</st>
    `<st c="2980">MightyTasksList</st>`<st c="2995">。</st>
- en: <st c="2996">Our</st> `<st c="3001">MightyTasksList</st>` <st c="3016">app is
    so great that our users demand that they use it with Siri while they are driving.</st>
    <st c="3106">So, we decided to create an</st> <st c="3134">app intent.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2996">我们的</st> `<st c="3001">MightyTasksList</st>` <st c="3016">应用如此出色，以至于我们的用户要求他们在开车时使用它与Siri配合。</st>
    <st c="3106">因此，我们决定创建一个</st> <st c="3134">应用意图。</st>
- en: <st c="3145">To do that, we’ll open a new file and write the</st> <st c="3194">following
    code:</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3145">为此，我们将打开一个新文件并编写以下代码：</st> <st c="3194">以下代码：</st>
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3513">This is it?</st> <st c="3526">Yes!</st> <st c="3531">Writing a
    simple</st> <st c="3547">app intent is extremely easy.</st> <st c="3578">Let’s
    narrow down what we</st> <st c="3604">did here:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3513">这就是全部了吗？</st> <st c="3526">是的！</st> <st c="3531">编写一个简单的</st> <st
    c="3547">应用意图非常简单。</st> <st c="3578">让我们缩小一下我们</st> <st c="3604">在这里做了什么：</st>
- en: <st c="3613">We imported the</st> `<st c="3630">AppIntents</st>` <st c="3640">framework.</st>
    <st c="3652">In this case, we need this framework to have the</st> `<st c="3701">AppIntent</st>`
    <st c="3710">protocol.</st>
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3613">我们导入了</st> `<st c="3630">AppIntents</st>` <st c="3640">框架。</st>
    <st c="3652">在这种情况下，我们需要这个框架来拥有</st> `<st c="3701">AppIntent</st>` <st c="3710">协议。</st>
- en: <st c="3720">We created a</st> `<st c="3734">GetTasksIntent</st>` <st c="3748">structure
    that conformed to the</st> `<st c="3781">AppIntent</st>` <st c="3790">protocol.</st>
    <st c="3801">This structure defines our</st> <st c="3828">intent functionality.</st>
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3720">我们创建了一个符合</st> `<st c="3781">AppIntent</st>` <st c="3790">协议的</st>
    `<st c="3734">GetTasksIntent</st>` <st c="3748">结构。</st> <st c="3801">这个结构定义了我们的</st>
    <st c="3828">意图功能。</st>
- en: <st c="3849">As part of the</st> `<st c="3865">AppIntent</st>` <st c="3874">protocol,
    we must implement two things.</st> <st c="3915">The first one is the intent’s</st>
    `<st c="3945">title</st>`<st c="3950">, which appears in the intent gallery in
    the Shortcuts app (we’ll get there shortly in the</st> *<st c="4041">Running the
    intent in the Shortcuts app</st>* <st c="4080">section).</st> <st c="4091">The
    second thing we need to implement is the</st> `<st c="4136">perform()</st>` <st
    c="4145">function, which is the actual code that will be executed when the</st>
    <st c="4212">intent runs.</st>
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `<st c="3865">AppIntent</st>` <st c="3874">协议的一部分，我们必须实现两件事。</st> <st c="3915">第一件事是意图的</st>
    `<st c="3945">标题</st>`<st c="3950">，它出现在快捷方式应用中的意图画廊中（我们将在 *<st c="4041">在快捷方式应用中运行意图</st>
    <st c="4080">部分中很快就会看到）。</st> <st c="4091">第二件事是我们需要实现的是</st> `<st c="4136">perform()</st>`
    <st c="4145">函数，这是意图运行时实际执行的代码。</st>
- en: <st c="4224">The</st> `<st c="4229">perform()</st>` <st c="4238">function always
    returns an</st> `<st c="4266">IntentResult</st>` <st c="4278">protocol-based type—in
    this case, we return a</st> `<st c="4325">ProvidesDialog</st>` <st c="4339">instance
    that conforms to the</st> `<st c="4370">IntentResult</st>` <st c="4382">protocol
    and displays a message to the user.</st> <st c="4428">However, there are additional</st>
    <st c="4458">types, and we’ll discuss them in the</st> <st c="4495">following
    sections.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4224">The</st>` `<st c="4229">perform()</st>` <st c="4238">函数始终返回一个基于
    `<st c="4266">IntentResult</st>` <st c="4278">协议的类型——在这种情况下，我们返回一个符合 `<st c="4370">IntentResult</st>`
    <st c="4382">协议的 `<st c="4325">ProvidesDialog</st>` <st c="4339">实例，并向用户显示一条消息。</st>
    <st c="4428">然而，还有其他类型，我们将在接下来的章节中讨论。</st>`'
- en: <st c="4514">Next, let’s run our intent using the</st> <st c="4552">Shortcuts
    app.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个，让我们使用快捷方式应用来运行我们的意图。
- en: <st c="4566">Running the intent with the Shortcuts app</st>
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行意图的快捷方式应用
- en: <st c="4608">The</st> **<st c="4613">Shortcuts app</st>** <st c="4626">is a
    powerful automation tool</st> <st c="4656">that allows users to create</st> <st
    c="4684">shortcuts for routines and actions in their system.</st> <st c="4737">Users
    can also use the Shortcuts app to create scripting, automation, conditional statements,
    and</st> <st c="4835">complex logic.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4608">The</st> **<st c="4613">Shortcuts app</st>** <st c="4626">is a
    powerful automation tool</st> <st c="4656">that allows users to create</st> <st
    c="4684">shortcuts for routines and actions in their system.</st> <st c="4737">Users
    can also use the Shortcuts app to create scripting, automation, conditional statements,
    and</st> <st c="4835">complex logic.</st>
- en: <st c="4849">Apple acquired the Shortcuts app back in 2017, which was initially
    developed by a start-up</st> <st c="4941">called Workflows.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司在 2017 年收购了快捷方式应用，该应用最初由一家名为 Workflows 的初创公司开发。
- en: <st c="4958">When we build and run our app, iOS scans for structures that conform
    to the</st> `<st c="5035">AppIntent</st>` <st c="5044">protocol and add them to
    the</st> **<st c="5074">Shortcuts</st>** <st c="5083">gallery in the Shortcuts
    app (</st>*<st c="5114">Figure 13</st>**<st c="5124">.1</st>*<st c="5126">):</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建和运行我们的应用时，iOS 会扫描符合 `<st c="5035">AppIntent</st>` <st c="5044">协议的结构，并将它们添加到快捷方式应用中的
    **<st c="5074">快捷方式</st>** **<st c="5083">画廊（</st>*<st c="5114">图 13</st>**<st
    c="5124">.1</st>**<st c="5126">）：</st>**
- en: '![Figure 13.1: Our intent is shown in the Shortcuts app](img/B21795_figure_13.01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：我们的意图在快捷方式应用中显示](img/B21795_figure_13.01.jpg)'
- en: '<st c="5208">Figure 13.1: Our intent is shown in the Shortcuts app</st>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.1：我们的意图在快捷方式应用中显示](https://wiki.example.org/figure_13.1_our_intent_is_shown_in_the_shortcuts_app)'
- en: <st c="5261">In</st> *<st c="5265">Figure 13</st>**<st c="5274">.1</st>*<st
    c="5276">, we can see the intent of the</st> **<st c="5307">Get number of the
    opened tasks</st>** <st c="5337">shortcut in the Shortcuts app when searching
    for action for our app.</st> <st c="5407">Then, we can add the action as a new
    shortcut.</st> <st c="5454">Let’s see what happens when we run our intent (</st>*<st
    c="5501">Figure 13</st>**<st c="5511">.2</st>*<st c="5513">):</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *<st c="5265">图 13</st>**<st c="5274">.1</st>**<st c="5276">中，我们可以看到在搜索我们应用的操作时，快捷方式应用中**获取打开任务数量**的快捷方式的意图。然后，我们可以将操作添加为新快捷方式。接下来，让我们看看当我们运行意图时会发生什么（**<st
    c="5501">图 13</st>**<st c="5511">.2</st>**<st c="5513">）：**
- en: '![Figure 13.2: Running the Get number of opened tasks shortcut](img/B21795_figure_13.02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：运行获取打开任务数量的快捷方式](img/B21795_figure_13.02.jpg)'
- en: '<st c="5561">Figure 13.2: Running the Get number of opened tasks shortcut</st>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.2：运行获取打开任务数量的快捷方式](https://wiki.example.org/figure_13.2_running_the_get_number_of_opened_tasks_shortcut)'
- en: '*<st c="5621">Figure 13</st>**<st c="5631">.2</st>* <st c="5633">shows what
    happens when we run our app intent.</st> <st c="5681">We can see the message we
    defined as part of the</st> `<st c="5730">perform()</st>` <st c="5739">function
    results.</st>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="5621">图13</st>**<st c="5631">.2</st>* <st c="5633">展示了当我们运行我们的应用意图时会发生什么。</st>
    <st c="5681">我们可以看到我们定义的消息作为</st> `<st c="5730">perform()</st>` <st c="5739">函数的结果。</st>'
- en: <st c="5757">Way to go!</st> <st c="5769">We created</st> <st c="5779">our first</st>
    <st c="5790">app</st> <st c="5793">intent!</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5757">做得好！</st> <st c="5769">我们创建了</st> <st c="5779">我们的第一个</st> <st
    c="5790">应用</st> <st c="5793">意图！</st>
- en: <st c="5801">Now, let’s try to ease our users and create the shortcut as part
    of</st> <st c="5870">the app.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5801">现在，让我们尝试简化用户的使用，并将快捷方式作为</st> <st c="5870">应用的一部分。</st>
- en: <st c="5878">Creating an app shortcut</st>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5878">创建应用快捷方式</st>
- en: <st c="5903">Instead of letting the user create</st> <st c="5938">a shortcut
    based on the action (intent) we provide, we can create a shortcut for them</st>
    <st c="6025">to use.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5903">我们不是让用户根据我们提供的操作（意图）创建快捷方式，而是为他们创建一个可以使用的快捷方式。</st>
- en: <st c="6032">To do that, we need to create a structure that conforms to the</st>
    `<st c="6096">AppShortcutsProvider</st>` <st c="6116">protocol to create a</st>
    <st c="6138">pre-configured shortcut:</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6032">为了做到这一点，我们需要创建一个符合</st> `<st c="6096">AppShortcutsProvider</st>`
    <st c="6116">协议的结构来创建一个</st> <st c="6138">预配置的快捷方式：</st>
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6493">In this code, we have a struct called</st> `<st c="6532">AppShortcuts</st>`<st
    c="6544">. This struct has one variable to implement—</st>`<st c="6588">appShortcuts</st>`<st
    c="6601">, which contains a list of the</st> <st c="6632">app shortcuts.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6493">在这段代码中，我们有一个名为</st> `<st c="6532">AppShortcuts</st>`<st c="6544">的结构体。这个结构体有一个变量需要实现——</st>`<st
    c="6588">appShortcuts</st>`<st c="6601">，它包含一个应用快捷方式的列表。</st>
- en: <st c="6646">In this case, we create a new</st> `<st c="6677">AppShortcut</st>`
    <st c="6688">instance that contains</st> <st c="6712">the following:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6646">在这种情况下，我们创建了一个新的</st> `<st c="6677">AppShortcut</st>` <st c="6688">实例，它包含以下内容：</st>
- en: <st c="6726">The intent that will be executed.</st> <st c="6761">Here, we put
    the intent we created in the preceding</st> <st c="6813">section (</st>`<st c="6822">GetTasksIntent</st>`<st
    c="6837">).</st>
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6726">将要执行的意图。</st> <st c="6761">在这里，我们将前面</st> <st c="6813">部分（</st>`<st
    c="6822">GetTasksIntent</st>`<st c="6837">）中创建的意图放入。</st>
- en: <st c="6840">The exact phrases the user has to say to Siri.</st> <st c="6888">In
    our case, we added two phrases.</st> <st c="6923">Notice that the phrases must
    include the</st> <st c="6964">application name.</st>
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6840">用户必须对Siri说的确切短语。</st> <st c="6888">在我们的例子中，我们添加了两个短语。</st> <st
    c="6923">请注意，短语必须包含</st> <st c="6964">应用程序名称。</st>
- en: <st c="6981">A title and a system image for</st> <st c="7013">the shortcut.</st>
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6981">快捷方式的标题和系统图像。</st>
- en: <st c="7026">Once we run our app, the user doesn’t need to create a shortcut
    using the Shortcuts app—the shortcut is ready</st> <st c="7136">for the user to
    use</st> <st c="7157">with Siri.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7026">一旦我们运行了我们的应用，用户不需要使用快捷方式应用来创建快捷方式——快捷方式已经准备好供用户使用Siri了。</st>
- en: <st c="7167">Now that we have created our first intent and shortcut, let’s dive
    in for more complex</st> <st c="7255">use cases.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7167">现在我们已经创建了第一个意图和快捷方式，让我们深入研究更复杂的</st> <st c="7255">用例。</st>
- en: <st c="7265">Adding a parameter to our app intent</st>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7265">向我们的应用意图添加一个参数</st>
- en: <st c="7302">In the</st> *<st c="7310">Creating a simple app intent</st>* <st
    c="7338">section, we</st> <st c="7350">created a</st> `<st c="7361">GetTasksIntent</st>`
    <st c="7375">struct that went to the persistent store and returned the user’s
    number of open tasks.</st> <st c="7463">Now, let’s see how we can use the</st>
    `<st c="7497">AppIntents</st>` <st c="7507">framework to create an action that
    inserts a new task into</st> <st c="7567">the system.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7302">在</st> *<st c="7310">创建简单的应用意图</st>* <st c="7338">部分，我们</st> <st
    c="7350">创建了一个</st> `<st c="7361">GetTasksIntent</st>` <st c="7375">结构体，它访问持久存储并返回用户的打开任务数量。</st>
    <st c="7463">现在，让我们看看我们如何使用</st> `<st c="7497">AppIntents</st>` <st c="7507">框架来创建一个将新任务插入到</st>
    <st c="7567">系统中的操作。</st>
- en: <st c="7578">We’ll open a new file and add the</st> <st c="7613">following code:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7578">我们将打开一个新文件并添加以下代码：</st>
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`<st c="7942">AddTaskIntent</st>` <st c="7956">is a little bit more complex
    but not</st> <st c="7994">too complex.</st>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="7942">AddTaskIntent</st>` <st c="7956">稍微复杂一些，但并不复杂。</st>'
- en: <st c="8006">To start, we create a new</st> `<st c="8033">AddTaskIntent</st>`
    <st c="8046">that conforms to the</st> `<st c="8068">AppIntent</st>` <st c="8077">protocol,
    similar to</st> `<st c="8099">GetTasksIntent</st>`<st c="8113">. We also provide
    a readable title for the Shortcuts app.</st> <st c="8171">But then we see a new
    variable—a title marked with a</st> `<st c="8224">@</st>``<st c="8225">Parameter</st>`
    <st c="8234">attribute.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8006">首先，我们创建一个新的</st> `<st c="8033">AddTaskIntent</st>` <st c="8046">，它符合</st>
    `<st c="8068">AppIntent</st>` <st c="8077">协议，类似于</st> `<st c="8099">GetTasksIntent</st>`<st
    c="8113">。我们还为Shortcuts应用提供了一个可读的标题。</st> <st c="8171">但随后我们看到一个新的变量——一个带有</st>
    `<st c="8224">@</st>``<st c="8225">Parameter</st>` <st c="8234">属性的标题。</st>
- en: <st c="8245">We said that app intents are actually our application API.</st>
    <st c="8305">Some APIs require input, so when adding a new task, the title is
    our Intent input.</st> <st c="8388">We can provide this input using Siri, a dialog,
    or even another intent.</st> <st c="8460">When we run</st> `<st c="8472">AddTaskIntent</st>`<st
    c="8485">, the user must provide a title for</st> <st c="8521">the task.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8245">我们说过应用意图实际上是我们应用的API。</st> <st c="8305">一些API需要输入，所以当添加一个新任务时，标题是我们的Intent输入。</st>
    <st c="8388">我们可以通过Siri、对话框或甚至另一个intent来提供这个输入。</st> <st c="8460">当我们运行</st> `<st
    c="8472">AddTaskIntent</st>`<st c="8485">时，用户必须为</st> `<st c="8521">任务</st>` <st
    c="8521">提供一个标题。</st>
- en: <st c="8530">When we reach the</st> `<st c="8549">perform()</st>` <st c="8558">function,
    we can see how we use the</st> `<st c="8595">title</st>` <st c="8600">parameter
    to insert a new task into the persistent store.</st> <st c="8659">We can also
    see a change compared to the</st> `<st c="8700">GetTasksIntent</st>` <st c="8714">example
    in how the function returns</st> <st c="8751">a value.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8530">当我们到达</st> `<st c="8549">perform()</st>` <st c="8558">函数时，我们可以看到我们如何使用</st>
    `<st c="8595">title</st>` <st c="8600">参数将一个新任务插入到持久存储中。</st> <st c="8659">我们还可以看到与</st>
    `<st c="8700">GetTasksIntent</st>` <st c="8714">示例相比的一个变化，即函数如何返回</st> <st c="8751">一个值。</st>
- en: <st c="8759">In</st> `<st c="8763">GetTasksIntent</st>`<st c="8777">, we used</st>
    <st c="8786">the</st> `<st c="8791">ProvidesDialog</st>` <st c="8805">protocol.</st>
    <st c="8816">Now, we use</st> `<st c="8828">ReturnsValue<String></st>`<st c="8848">,
    which returns a value to our shortcut.</st> <st c="8889">We can use the returned
    value as input for other actions.</st> <st c="8947">For example, in this case,
    we can use the task title to create a reminder in the Reminders app with the same
    title or even send a message with this title to someone else.</st> <st c="9118">This
    feature makes App Intents and the Shortcuts app extremely useful for</st> <st
    c="9192">power users.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8759">在</st> `<st c="8763">GetTasksIntent</st>`<st c="8777">中，我们使用了</st>
    `<st c="8786">the</st>` `<st c="8791">ProvidesDialog</st>` <st c="8805">协议。</st>
    <st c="8816">现在，我们使用</st> `<st c="8828">ReturnsValue<String></st>`<st c="8848">，它返回一个值给我们的快捷方式。</st>
    <st c="8889">我们可以使用返回的值作为其他动作的输入。</st> <st c="8947">例如，在这种情况下，我们可以使用任务标题在Reminders应用中创建具有相同标题的提醒，甚至可以用这个标题给其他人发送消息。</st>
    <st c="9118">这个功能使得App Intents和Shortcuts应用对高级用户来说非常有用。</st>
- en: <st c="9204">Let’s see how it looks in the</st> <st c="9235">Shortcuts app:</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9204">让我们看看它在Shortcuts应用中的样子：</st>
- en: '![Figure 13.3: Shortcuts with two actions](img/B21795_figure_13.03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：包含两个操作的快捷方式](img/B21795_figure_13.03.jpg)'
- en: '<st c="9355">Figure 13.3: Shortcuts with two actions</st>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9355">图13.3：包含两个操作的快捷方式</st>
- en: <st c="9394">In</st> *<st c="9398">Figure 13</st>**<st c="9407">.3</st>*<st
    c="9409">, we can see our shortcut with</st> <st c="9440">two actions:</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9394">在</st> *<st c="9398">图13</st>**<st c="9407">.3</st>*<st c="9409">中，我们可以看到我们的快捷方式包含两个操作：</st>
- en: <st c="9452">The first is</st> `<st c="9466">AddTaskIntent</st>` <st c="9479">from</st>
    <st c="9485">our app.</st>
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9452">第一个是</st> `<st c="9466">AddTaskIntent</st>` <st c="9479">来自</st>
    `<st c="9485">我们的应用。</st>
- en: <st c="9493">The second is that the result of our intent is the task title and
    the input of the</st> *<st c="9577">send message</st>* <st c="9589">action from
    the</st> <st c="9606">messages app.</st>
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9493">第二个是，我们的意图的结果是任务标题和来自</st> *<st c="9577">发送消息</st>* <st c="9589">动作的消息应用。</st>
- en: <st c="9619">We can see that it is possible</st> <st c="9650">to chain actions
    together and create</st> <st c="9688">powerful streams.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9619">我们可以看到，可以将操作串联起来，创建</st> `<st c="9650">强大的流。</st>`
- en: <st c="9705">Let’s see how it looks when we run our shortcut (</st>*<st c="9755">Figure
    13</st>**<st c="9765">.4</st>*<st c="9767">):</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9705">让我们看看当我们运行我们的快捷方式时（</st>*<st c="9755">图13</st>**<st c="9765">.4</st>*<st
    c="9767">）的样子：</st>
- en: '![Figure 13.4: Running AddTaskIntent](img/B21795_figure_13.04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：运行AddTaskIntent](img/B21795_figure_13.04.jpg)'
- en: '<st c="9793">Figure 13.4: Running AddTaskIntent</st>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9793">图13.4：运行AddTaskIntent</st>
- en: '*<st c="9827">Figure 13</st>**<st c="9837">.4</st>* <st c="9839">shows that
    the system asks for the task title when we run our shortcut by providing a standard
    input field.</st> <st c="9948">Besides the Siri integration, this is part of what
    we get for free—a standard user interface</st> <st c="10040">that handles all
    of that</st> <st c="10066">for us.</st>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="9827">图13</st>**<st c="9837">.4</st>* <st c="9839">显示，当我们通过提供标准输入字段来运行我们的快捷方式时，系统会要求输入任务标题。</st>
    <st c="9948">除了Siri集成之外，这是我们免费获得的部分——一个标准用户界面</st> <st c="10040">，为我们处理所有这些。</st>'
- en: <st c="10073">However, we can also create our own user interface for the shortcut!</st>
    <st c="10143">Let’s see how to</st> <st c="10160">do that.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10073">然而，我们也可以为快捷方式创建自己的用户界面！</st> <st c="10143">让我们看看如何</st> <st c="10160">做到这一点。</st>
- en: <st c="10168">Returning a custom view</st>
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10168">返回自定义视图</st>
- en: <st c="10192">We have added two important</st> <st c="10220">intents in the
    previous sections.</st> <st c="10255">The first receives a string containing the
    number of opened tasks, and the second is an app intent that creates a new task
    in the</st> <st c="10385">persistent store.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10192">我们在前面的部分中添加了两个重要的</st> <st c="10220">意图。</st> <st c="10255">第一个接收一个包含打开任务数量的字符串，第二个是一个应用程序意图，它在持久存储中创建一个新任务。</st>
- en: <st c="10402">Let’s discuss another use case—getting the list of opened tasks.</st>
    <st c="10468">In this case, we want to present the user with a custom view since
    Shortcuts and Siri don’t know how to deal with a list of</st> <st c="10592">entities
    natively.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10402">让我们讨论另一个用例——获取打开的任务列表。</st> <st c="10468">在这种情况下，我们希望向用户展示一个自定义视图，因为快捷方式和Siri无法原生地处理实体列表。</st>
- en: <st c="10610">So, let’s create a</st> <st c="10630">custom view:</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10610">因此，让我们创建一个</st> <st c="10630">自定义视图：</st>
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10774">Our code example contains a struct named</st> `<st c="10816">MiniTasksList</st>`
    <st c="10829">with a VStack that displays an array</st> <st c="10867">of</st>
    `<st c="10870">TaskView</st>`<st c="10878">.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10774">我们的代码示例包含一个名为</st> `<st c="10816">MiniTasksList</st>` <st c="10829">的结构，其中包含一个显示</st>
    `<st c="10867">数组</st>` <st c="10870">的</st> `<st c="10878">TaskView</st>`。</st>
- en: <st c="10879">There are two weird</st> <st c="10900">things here:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10879">这里有两个奇怪的地方：</st>
- en: <st c="10912">First, why do we need to create a dedicated list view?</st> <st
    c="10968">Can’t we reuse the view we already have in</st> <st c="11011">our app?</st>
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10912">首先，为什么我们需要创建一个专门的列表视图？</st> <st c="10968">我们不能在我们应用程序中重用已经存在的视图吗？</st>
- en: <st c="11019">Second, why do we use a VStack and not a</st> <st c="11061">List
    view?</st>
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11019">其次，为什么我们使用VStack而不是列表视图？</st>
- en: <st c="11071">These arguments</st> <st c="11087">are usually valid.</st> <st
    c="11107">We should aim to reuse our code as much as possible and use the right
    view for the right behavior.</st> <st c="11206">However, one limitation is that
    we cannot use List or Scroll views as part of our custom view.</st> <st c="11301">We
    also can’t display animations or allow user interaction.</st> <st c="11361">If
    we want to achieve more functionality, we should use the app itself or create
    additional app intents to fulfill</st> <st c="11476">our needs.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11071">这些论点</st> <st c="11087">通常是有效的。</st> <st c="11107">我们应该尽可能重用我们的代码，并为正确的行为使用正确的视图。</st>
    <st c="11206">然而，一个限制是我们不能将列表或滚动视图作为我们自定义视图的一部分使用。</st> <st c="11301">我们也不能显示动画或允许用户交互。</st>
    <st c="11361">如果我们想实现更多功能，我们应该使用应用程序本身或创建额外的应用程序意图来满足</st> <st c="11476">我们的需求。</st>
- en: <st c="11486">Now that we have a custom view, let’s create an app intent that</st>
    <st c="11551">uses it:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11486">现在我们有一个自定义视图，让我们创建一个应用程序意图，使用它：</st>
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="11819">The</st> `<st c="11824">GetTasksListIntent</st>` <st c="11842">structure
    is similar to the previous intents we created in the previous sections.</st> <st
    c="11925">It also has a</st> `<st c="11939">title</st>` <st c="11944">property
    and a</st> `<st c="11960">perform()</st>` <st c="11969">function.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11819">`<st c="11824">GetTasksListIntent</st>` <st c="11842">结构与我们前面部分创建的意图类似。</st>
    <st c="11925">它也有一个</st> `<st c="11939">标题</st>` <st c="11944">属性和一个</st> `<st
    c="11960">perform()</st>` <st c="11969">函数。</st>
- en: <st c="11979">There are two important</st> <st c="12003">changes here:</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11979">这里有两个重要的</st> <st c="12003">变化：</st>
- en: <st c="12017">The return type of the</st> `<st c="12041">perform()</st>` <st
    c="12050">function is now</st> `<st c="12067">ShowsSnippetView</st>`<st c="12083">.
    We use</st> `<st c="12092">ShowsSnippetView</st>` <st c="12108">if we want to
    present a custom view as a result of</st> <st c="12160">our function.</st>
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12017">`perform()` 函数的返回类型现在是</st> `<st c="12041">ShowsSnippetView</st>`
    <st c="12050">。如果我们想将自定义视图作为函数的结果展示，我们使用</st> `<st c="12092">ShowsSnippetView</st>`
    <st c="12108">。</st> `<st c="12160">我们的函数。</st>
- en: <st c="12173">We returned a different intent result with the</st> `<st c="12221">MiniTasksList</st>`
    <st c="12234">view</st> <st c="12240">we created.</st>
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12173">我们返回了一个不同的意图结果，使用了我们创建的</st> `<st c="12221">MiniTasksList</st>`
    <st c="12234">视图。</st>
- en: <st c="12251">Now, let’s run our intent using the Shortcuts app and see what
    happens (</st>*<st c="12324">Figure 13</st>**<st c="12334">.5</st>*<st c="12336">):</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12251">现在，让我们使用快捷方式应用运行我们的意图，看看会发生什么（</st>*<st c="12324">图13</st>**<st
    c="12334">.5</st>*<st c="12336">）：</st>
- en: '![Figure 13.5: The list of tasks as part of the intent response](img/B21795_figure_13.05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：意图响应中的任务列表](img/B21795_figure_13.05.jpg)'
- en: '<st c="12487">Figure 13.5: The list of tasks as part of the intent response</st>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12487">图13.5：意图响应中的任务列表</st>
- en: '*<st c="12548">Figure 13</st>**<st c="12558">.5</st>* <st c="12560">shows</st>
    `<st c="12567">MiniTasksList</st>` <st c="12580">as our intent response.</st>
    <st c="12605">Looking at how the list is displayed, we can understand why Apple
    limits how we can customize this view.</st> <st c="12710">The goal is for our
    view to be as simple as possible and aligned with the rest of</st> <st c="12792">the
    intents.</st>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="12548">图13</st>**<st c="12558">.5</st>* <st c="12560">显示了</st> `<st
    c="12567">MiniTasksList</st>` <st c="12580">作为我们的意图响应。</st> `<st c="12605">通过查看列表的显示方式，我们可以理解为什么苹果限制了我们可以如何自定义此视图。</st>
    `<st c="12710">目标是使我们的视图尽可能简单，并与其他意图保持一致。</st>'
- en: <st c="12804">Returning a view</st> <st c="12821">is great.</st> <st c="12832">But
    what if we want to return a custom view and a value that can be used for other
    purposes?</st> <st c="12925">Is it possible?</st> <st c="12941">Let’s find out
    if and how to</st> <st c="12970">do that.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12804">返回一个视图</st> `<st c="12821">是很好的。</st> `<st c="12832">但如果我们想返回一个自定义视图和可以用于其他目的的值呢？</st>
    `<st c="12925">这是否可能？</st> `<st c="12941">让我们找出是否以及如何</st> `<st c="12970">做到这一点。</st>
- en: <st c="12978">Having multiple result types</st>
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12978">具有多个结果类型</st>
- en: <st c="13007">Imagine that, besides</st> <st c="13030">getting the tasks list,
    the user wants to add another step to its shortcut.</st> <st c="13106">If the
    number of tasks is bigger than, let’s say, five, they want to open the calendar
    to re-arrange</st> <st c="13207">the day.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13007">想象一下，除了获取任务列表，用户还希望向其快捷方式添加另一个步骤。</st> `<st c="13030">如果任务数量超过，比如说，五个，他们希望打开日历来重新安排</st>
    `<st c="13207">这一天。</st>
- en: <st c="13215">So, we would like to show the list of tasks and also return</st>
    <st c="13276">their quantity.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13215">因此，我们希望显示任务列表，并返回</st> `<st c="13276">它们的数量。</st>
- en: <st c="13291">We can do that by returning</st> <st c="13320">multiple types:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13291">我们可以通过返回</st> <st c="13320">多种类型来实现这一点：</st>
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="13634">In our code example,</st> `<st c="13656">perform()</st>` <st c="13665">returns
    two types of results –</st> `<st c="13697">ShowsSnippetView</st>` <st c="13713">for
    displaying the tasks list and</st> `<st c="13748">ReturnsValue<Int></st>` <st
    c="13765">for the number of tasks to be used in</st> <st c="13804">other intents.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13634">在我们的代码示例中，</st> `<st c="13656">perform()</st>` <st c="13665">返回两种类型的结果——</st>
    `<st c="13697">ShowsSnippetView</st>` <st c="13713">用于显示任务列表，以及</st> `<st c="13748">ReturnsValue<Int></st>`
    <st c="13765">用于在其他意图中使用任务数量。</st>
- en: <st c="13818">We also changed</st> `<st c="13835">IntentResult</st>` <st c="13847">at
    the function’s</st> <st c="13866">return statement:</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13818">我们还修改了函数的</st> `<st c="13835">IntentResult</st>` <st c="13847">返回语句：</st>
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13953">Notice that the value we return</st> <st c="13985">needs to be
    the same as the</st> `<st c="14014">ReturnsValue</st>` <st c="14026">instance
    we declare in the</st> <st c="14054">function signature.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13953">请注意，我们返回的值需要与我们在函数签名中声明的</st> `<st c="14014">ReturnsValue</st>`
    <st c="14026">实例相同。</st>
- en: <st c="14073">Adding confirmation and conditions</st>
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14073">添加确认和条件</st>
- en: <st c="14108">Having the app perform</st> <st c="14131">actions can lead to
    more complex use cases.</st> <st c="14176">For example, there are cases where
    we need to confirm a specific action with the user, such as deleting or ordering
    something.</st> <st c="14303">In other cases, we might want to inform the user
    that we cannot perform the action or even request</st> <st c="14402">more information.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14108">让应用执行操作可能导致更复杂的使用场景。</st> <st c="14131">例如，有些情况下我们需要与用户确认特定的操作，比如删除或订购某物。</st>
    <st c="14176">在其他情况下，我们可能想通知用户我们无法执行该操作，甚至请求</st> <st c="14303">更多信息。</st>
- en: <st c="14419">The</st> `<st c="14424">AppIntents</st>` <st c="14434">protocol
    has the capability to create a dialog with our users.</st> <st c="14498">This
    dialog can be used with Siri to make the process feel</st> <st c="14557">more
    conversational.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14419">`<st c="14424">AppIntents</st>` <st c="14434">协议具有创建与用户对话的能力。</st>
    <st c="14498">这个对话框可以与 Siri 一起使用，使过程感觉</st> <st c="14557">更像对话。</st>
- en: <st c="14577">Let’s go back to our to-do app and create an app intent that allows
    the user to delete all of</st> <st c="14672">its tasks:</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14577">让我们回到我们的待办事项应用，创建一个允许用户删除所有</st> <st c="14672">其任务的</st> 应用意图：</st>
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="15203">This intent is a bit more complex</st> <st c="15237">and smarter
    than our previous examples.</st> <st c="15278">At the beginning of the</st> `<st
    c="15302">perform()</st>` <st c="15311">function, we check to see if there are
    any tasks in the persistent store to delete.</st> <st c="15396">If there are no
    tasks to delete, we notify the user by returning a simple</st> <st c="15470">text
    dialog.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15203">这个意图比我们之前的例子要复杂一些</st> <st c="15237">并且更智能。</st> <st c="15278">在</st>
    `<st c="15302">perform()</st>` <st c="15311">函数的开始，我们检查持久存储中是否有任何要删除的任务。</st>
    <st c="15396">如果没有要删除的任务，我们通过返回一个简单的</st> <st c="15470">文本对话框</st> 来通知用户。
- en: <st c="15482">Next, since it is a destructive action, we want to confirm it
    with our user.</st> <st c="15560">So, we use the</st> `<st c="15575">requestConfirmation()</st>`
    <st c="15596">function.</st> <st c="15607">This function presents a dialog with
    a given text and a confirmation button (</st>*<st c="15684">Figure 13</st>**<st
    c="15694">.6</st>*<st c="15696">):</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15482">接下来，由于这是一个破坏性操作，我们希望与用户确认。</st> <st c="15560">因此，我们使用</st> `<st
    c="15575">requestConfirmation()</st>` <st c="15596">函数。</st> <st c="15607">这个函数显示一个带有给定文本和确认按钮的对话框（</st>*<st
    c="15684">图 13</st>**<st c="15694">.6</st>*<st c="15696">）：</st>
- en: '![Figure 13.6: A confirmation dialog](img/B21795_figure_13.06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6：一个确认对话框](img/B21795_figure_13.06.jpg)'
- en: '<st c="15764">Figure 13.6: A confirmation dialog</st>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15764">图 13.6：一个确认对话框</st>
- en: '*<st c="15798">Figure 13</st>**<st c="15808">.6</st>* <st c="15810">shows a
    confirmation dialog that was derived from the</st> `<st c="15865">requestConfirmation()</st>`
    <st c="15886">function.</st> <st c="15897">Notice that we can choose from a set
    of confirmation button titles.</st> <st c="15965">In our</st> <st c="15972">case,
    we selected the</st> **<st c="15994">Go</st>** <st c="15996">title.</st>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="15798">图 13</st>**<st c="15808">.6</st>* <st c="15810">显示了从</st> `<st
    c="15865">requestConfirmation()</st>` <st c="15886">函数派生出的确认对话框。</st> <st c="15897">注意，我们可以从一组确认按钮标题中选择。</st>
    <st c="15965">在我们的</st> <st c="15972">情况下，我们选择了</st> **<st c="15994">Go</st>**
    <st c="15996">标题。</st>'
- en: '<st c="16003">The next steps are straightforward: We perform the deletion action
    and notify our user that it has</st> <st c="16103">been executed.</st>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16003">接下来的步骤很简单：我们执行删除操作，并通知用户该操作已</st> <st c="16103">执行。</st>
- en: <st c="16117">Up until now, our app intents returned primitive types such as
    strings and int.</st> <st c="16198">But what about working with our app types?</st>
    <st c="16241">Is it possible to transfer them as part of the shortcut actions
    chain?</st> <st c="16312">This is what</st> `<st c="16325">AppEntity</st>` <st
    c="16334">is for.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16117">到目前为止，我们的应用意图返回的是原始类型，如字符串和 int。</st> <st c="16198">但是，我们如何处理我们的应用类型呢？</st>
    <st c="16241">是否可以将它们作为快捷操作链的一部分进行传输？</st> <st c="16312">这就是</st> `<st c="16325">AppEntity</st>`
    <st c="16334">的作用。</st>
- en: <st c="16342">Formalizing our content using app entities</st>
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="16342">使用应用实体正式化我们的内容</st>
- en: <st c="16385">In our app intents, when we created</st> <st c="16421">a task,
    we returned a string value</st> <st c="16456">of the task’s title.</st> <st c="16478">However,
    a task is more than just a title – it contains a description, status, ID, and
    many more properties.</st> <st c="16587">In other</st> <st c="16595">words, a
    task is not a string or a</st> `<st c="16705">Task</st>`<st c="16709">.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16385">在我们的应用意图中，当我们创建</st> <st c="16421">一个任务时，我们返回了任务的标题的字符串值。</st>
    <st c="16456">然而，任务不仅仅是标题——它还包含描述、状态、ID以及许多其他属性。</st> <st c="16478">换句话说，任务不仅仅是一个字符串或一个</st>
    `<st c="16705">Task</st>`<st c="16709">。</st>
- en: <st c="16710">The problem with App Intents is that no other app or the system
    knows what a</st> `<st c="16788">Task</st>` <st c="16792">structure is since it’s
    our app’s internal type.</st> <st c="16842">We need to expose the type to the
    system intent world to make</st> `<st c="16904">Task</st>` <st c="16908">a known
    type by</st> <st c="16925">the system.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16710">App Intents的问题在于，没有其他应用或系统知道</st> `<st c="16788">Task</st>` <st
    c="16792">结构是什么，因为它是我们应用的内部类型。</st> <st c="16842">我们需要将类型暴露给系统意图世界，以便系统通过</st>
    <st c="16904">Task</st> <st c="16908">使其成为一个已知类型。</st>
- en: '<st c="16936">Let’s connect that to a use case: creating and opening a task
    in the app.</st> <st c="17011">To make it modular, we want to create two intents:
    creating a task and opening a task.</st> <st c="17098">When we have the two intents,
    we can chain them in</st> <st c="17149">a shortcut.</st>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16936">让我们将其与一个用例联系起来：在应用中创建并打开一个任务。</st> <st c="17011">为了使其模块化，我们希望创建两个意图：创建任务和打开任务。</st>
    <st c="17098">当我们有了这两个意图时，我们可以在</st> <st c="17149">快捷方式中串联它们。</st>
- en: <st c="17160">Let’s start by letting the system know what</st> `<st c="17205">Task</st>`
    <st c="17209">is.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17160">让我们首先让系统知道</st> `<st c="17205">Task</st>` <st c="17209">是什么。</st>
- en: <st c="17213">Conforming to AppEntity</st>
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17213">遵循AppEntity</st>
- en: <st c="17237">Conforming to the</st> `<st c="17256">AppEntity</st>` <st c="17265">protocol</st>
    <st c="17274">makes app entities available to Siri and Shortcuts.</st> <st c="17327">It
    means that when our app intent returns one of our entities, we can pass it as
    input to the next intent in</st> <st c="17436">the chain.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17237">遵循</st> `<st c="17256">AppEntity</st>` <st c="17265">协议</st> <st
    c="17274">使得应用实体对Siri和快捷方式可用。</st> <st c="17327">这意味着当我们的应用意图返回我们的一个实体时，我们可以将其作为输入传递给链中的下一个意图。</st>
    <st c="17436">在链中。</st>
- en: <st c="17446">Let’s see how we can take our</st> `<st c="17477">Task</st>` <st
    c="17481">structure and make it</st> <st c="17504">conform</st> <st c="17512">to</st>
    `<st c="17515">AppEntity</st>`<st c="17524">:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17446">让我们看看我们如何将我们的</st> `<st c="17477">Task</st>` <st c="17481">结构转换为</st>
    <st c="17504">符合</st> <st c="17512">于</st> `<st c="17515">AppEntity</st>`<st c="17524">:</st>
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="18071">Let’s break down</st> <st c="18088">the</st> `<st c="18093">AppEntity</st>`
    <st c="18102">protocol implementation:</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18071">让我们分解</st> <st c="18088">的</st> `<st c="18093">AppEntity</st>`
    <st c="18102">协议实现：</st>
- en: '`<st c="18127">typeDisplayRepresentation</st>`<st c="18153">: Our entity needs
    to have a name in the system so we can display it in the Shortcuts app.</st> <st
    c="18245">In this case, we</st> <st c="18262">return</st> `<st c="18269">Task</st>`<st
    c="18273">.</st>'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18127">typeDisplayRepresentation</st>`<st c="18153">: 我们的实体需要在系统中有一个名称，这样我们就可以在快捷方式应用中显示它。</st>
    <st c="18245">在这种情况下，我们</st> <st c="18262">返回</st> `<st c="18269">Task</st>`<st
    c="18273">。</st>'
- en: '`<st c="18274">displayRepresentation</st>`<st c="18296">: While</st> `<st c="18305">typeDisplayRepresentation</st>`
    <st c="18330">shows the entity type name, the</st> `<st c="18363">displayRepresentation</st>`
    <st c="18384">property returns the entity value representation.</st> <st c="18435">In
    this case, this is the title value (e.g.,</st> *<st c="18480">Call</st>* *<st
    c="18485">my mom</st>*<st c="18491">).</st>'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18274">displayRepresentation</st>`<st c="18296">: 虽然</st> `<st c="18305">typeDisplayRepresentation</st>`
    <st c="18330">显示了实体类型名称，但</st> `<st c="18363">displayRepresentation</st>` <st
    c="18384">属性返回实体值表示。</st> <st c="18435">在这种情况下，这是标题值（例如，</st> *<st c="18480">Call</st>*
    *<st c="18485">my mom</st>*<st c="18491">）。</st>'
- en: '`<st c="18576">@Property</st>` <st c="18585">attribute to some</st> <st c="18603">of
    the entity’s properties, we define the entity structure for use in the</st> <st
    c="18678">Shortcuts app.</st>'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18576">@Property</st>` <st c="18585">属性用于实体的一些</st> <st c="18603">属性，我们定义了实体结构以用于</st>
    <st c="18678">快捷方式应用。</st>'
- en: '`<st c="18692">defaultQuery</st>`<st c="18705">: Declaring our app’s entities
    is not enough; we also need to provide the system with a way to retrieve them.</st>
    <st c="18816">Our next step will be to create the query that the system will use
    to fetch</st> <st c="18892">our entities.</st>'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18692">defaultQuery</st>`<st c="18705">：仅声明我们的应用程序实体是不够的；我们还需要向系统提供一个检索它们的方法。</st>
    <st c="18816">我们的下一步将是创建系统将用于检索我们的实体的查询。</st>'
- en: <st c="18905">Now that our</st> `<st c="18919">Task</st>` <st c="18923">struct
    is known by the system, let’s finish the implementation by</st> <st c="18990">creating</st>
    `<st c="18999">TaskQuery</st>`<st c="19008">:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18905">现在我们的</st> `<st c="18919">Task</st>` <st c="18923">结构已被系统所知，让我们通过创建</st>
    `<st c="18999">TaskQuery</st>`<st c="19008">来完成实现：</st>
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="19253">In this code example, we can see that the</st> `<st c="19296">TaskQuery</st>`
    <st c="19305">structure conforms to the</st> `<st c="19332">EntityQuery</st>`
    <st c="19343">protocol.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19253">在这个代码示例中，我们可以看到</st> `<st c="19296">TaskQuery</st>` <st c="19305">结构符合</st>
    `<st c="19332">EntityQuery</st>` <st c="19343">协议。</st>
- en: <st c="19353">The system uses the first function,</st> `<st c="19390">entities()</st>`<st
    c="19400">, to retrieve the entities by identifiers.</st> <st c="19443">At this
    point, we reach the app services (in this example,</st> `<st c="19502">TaskManager</st>`<st
    c="19513">) to fetch, filter, and return an array of entities.</st> <st c="19567">That’s
    why this function</st> <st c="19592">is required.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19353">系统使用第一个函数，</st> `<st c="19390">entities()</st>`<st c="19400">，通过标识符检索实体。</st>
    <st c="19443">此时，我们到达应用服务（在这个例子中，</st> `<st c="19502">TaskManager</st>`<st c="19513">）以获取、过滤并返回实体数组。</st>
    <st c="19567">这就是为什么这个函数</st> <st c="19592">是必需的。</st>
- en: <st c="19604">The second function (</st>`<st c="19626">suggestedEntities()</st>`<st
    c="19646">) is not required, but it can help the system present the user with
    a list of entities while we are fetching the list</st> <st c="19765">of entities.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19604">第二个函数（</st>`<st c="19626">suggestedEntities()</st>`<st c="19646">）不是必需的，但它可以帮助系统在我们获取实体列表时向用户展示实体列表。</st>
    <st c="19765">在获取实体列表的过程中。</st>
- en: <st c="19777">We know how to define</st> `<st c="19800">AppEntity</st>` <st
    c="19809">and its query at this point, but we need to connect it to an app intent</st>
    <st c="19881">to understand how they are</st> <st c="19909">being used.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19777">我们知道如何定义</st> `<st c="19800">AppEntity</st>` <st c="19809">及其查询，但我们需要将其连接到应用意图</st>
    <st c="19881">以了解它们是如何被使用的。</st>
- en: <st c="19920">Let’s do that by creating an</st> `<st c="19950">Open a</st>`
    `<st c="19957">task</st>` <st c="19961">intent.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19920">让我们通过创建一个</st> `<st c="19950">打开一个</st>` `<st c="19957">任务</st>`
    <st c="19961">意图来做到这一点。</st>
- en: <st c="19969">Creating an Open a task intent</st>
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19969">创建一个打开任务意图</st>
- en: <st c="20000">Creating an</st> `<st c="20013">Open a task</st>` <st c="20024">intent
    is not that different</st> <st c="20053">from what we saw in the previous examples.</st>
    <st c="20097">This time, we’ll integrate the new app intent with the</st> `<st
    c="20152">AppEntity</st>` <st c="20161">struct we’ve</st> <st c="20175">just created:</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20000">创建一个</st> `<st c="20013">打开一个任务</st>` <st c="20024">意图与之前示例中的不同不大。</st>
    <st c="20053">这次，我们将新的应用意图与我们已经创建的</st> `<st c="20152">AppEntity</st>` <st c="20161">结构</st>
    集成：</st>
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="20701">Our</st> `<st c="20706">Open a task</st>` <st c="20717">intent
    is structured</st> <st c="20738">like our previous intent examples.</st> <st c="20774">Still,
    there are additional changes we need</st> <st c="20818">to discuss:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20701">我们的</st> `<st c="20706">打开任务</st>` <st c="20717">意图的结构</st> <st
    c="20738">类似于我们之前的意图示例。</st> <st c="20774">尽管如此，我们还需要讨论一些额外的更改：</st>
- en: <st c="20829">We added</st> `<st c="20839">@Parameter</st>` <st c="20849">to</st>
    `<st c="20853">Task</st>`<st c="20857">. Using</st> `<st c="20865">@Parameter</st>`
    <st c="20875">is not new to us—we discussed it in the</st> *<st c="20916">Adding
    a parameter to our app intent</st>* <st c="20953">section.</st> <st c="20962">However,
    this time, we do that with the</st> `<st c="21002">Task</st>` <st c="21006">structure
    itself.</st> <st c="21025">We can do that because</st> `<st c="21048">Task</st>`
    <st c="21052">now conforms</st> <st c="21066">to</st> `<st c="21069">AppEntity</st>`<st
    c="21078">.</st>
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20829">我们向</st> `<st c="20853">Task</st>`<st c="20857">中添加了</st> `<st
    c="20839">@Parameter</st>` <st c="20849">。使用</st> `<st c="20865">@Parameter</st>`
    <st c="20875">对我们来说并不新鲜——我们在</st> *<st c="20916">在我们的应用意图中添加参数</st>* <st c="20953">部分讨论过。</st>
    <st c="20962">然而，这次，我们通过</st> `<st c="21002">Task</st>` <st c="21006">结构本身</st>
    来实现这一点。</st> <st c="21025">我们可以这样做，因为</st> `<st c="21048">Task</st>` <st c="21052">现在符合</st>
    `<st c="21069">AppEntity</st>`<st c="21078">。</st>
- en: <st c="21079">We set</st> `<st c="21087">openAppWhenRun</st>` <st c="21101">property
    to</st> `<st c="21114">true</st>` <st c="21118">so we can open the app and display
    the</st> <st c="21158">task details.</st>
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="21171">If the app intent doesn’t receive a task parameter, we can ask
    the user to select a task using the</st> `<st c="21271">requestDisambiguation</st>`
    <st c="21292">function.</st> <st c="21303">This function presents a dialog to
    the user with a given list of tasks and asks them to select</st> <st c="21398">a
    task.</st>
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="21405">After we have a task, we call the app navigator to open the task
    details.</st> <st c="21480">(To read more about how navigation works in SwiftUI,
    go to</st> [*<st c="21539">Chapter 4</st>*](B21795_04.xhtml#_idTextAnchor148)<st
    c="21548">.)</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21550">Now, let’s see what happens when we run this intent (</st>*<st
    c="21604">Figure 13</st>**<st c="21614">.7</st>*<st c="21616">):</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: The Open a task intent](img/B21795_figure_13.07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '<st c="21993">Figure 13.7: The Open a task intent</st>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="22028">Figure 13</st>**<st c="22038">.7</st>* <st c="22040">shows how
    the</st> `<st c="22055">Open a task</st>` <st c="22066">intent looks in the two
    stages where the task parameter</st> <st c="22123">is nil.</st>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22130">First, it opens the app (that’s because we set the</st> `<st c="22182">openAppWhenRun</st>`
    <st c="22196">variable</st> <st c="22206">to</st> `<st c="22209">true</st>`<st
    c="22213">).</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22216">Then, it displays a native dialog where the user can pick a task.</st>
    <st c="22283">Notice that the task display name (</st>`<st c="22318">title:<title
    of task></st>`<st c="22340">) is something we defined in the</st> `<st c="22374">displayRepresentation</st>`
    <st c="22395">variable when we conformed to</st> `<st c="22426">AppEntity</st>`
    <st c="22435">(in the</st> *<st c="22444">Conforming to</st>* *<st c="22458">AppEntity</st>*
    <st c="22467">section).</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22477">Later, we navigate to our task details screen and notify the user
    by returning a dialog with a</st> <st c="22573">corresponding message.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22595">Letting the user pick a task</st> <st c="22624">to display is
    a nice use case, but that’s not where the real power of</st> <st c="22695">intents
    is.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22706">Let’s try and integrate the</st> `<st c="22735">Open a task</st>`
    <st c="22746">intent into another intent by chaining</st> <st c="22786">them together.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22800">Chaining app intents</st>
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="22821">Let’s go back to</st> `<st c="22839">AddTaskIntent</st>`<st c="22852">,
    which we created</st> <st c="22870">in the</st> *<st c="22878">Adding a parameter
    to our app intent</st>* <st c="22914">section, and examine its</st> `<st c="22940">perform()</st>`
    <st c="22949">function:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="23117">The return type in the</st> `<st c="23140">perform()</st>` <st
    c="23149">function is</st> `<st c="23162">ReturnsValue<String></st>`<st c="23182">.
    Let’s modify this function to return a</st> `<st c="23223">Task</st>` <st c="23227">instance:</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23117">`<st c="23140">perform()</st>` <st c="23149">函数中的返回类型是</st> `<st
    c="23162">ReturnsValue<String></st>`<st c="23182">。让我们修改这个函数以返回一个</st> `<st c="23223">Task</st>`
    <st c="23227">实例：</st>
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="23418">In the new</st> `<st c="23430">perform()</st>` <st c="23439">function,
    we changed</st> <st c="23460">only two parts – the return type (now it’s</st>
    `<st c="23504">ReturnsValue<Task></st>`<st c="23522">) and the return statement,
    which now returns our newly</st> <st c="23579">created task.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23418">在新</st> `<st c="23430">perform()</st>` <st c="23439">函数中，我们只更改了两个部分——返回类型（现在它是</st>
    `<st c="23504">ReturnsValue<Task></st>`<st c="23522">）和返回语句，现在它返回我们新创建的任务。</st>
- en: <st c="23592">Let’s go back to the Shortcuts app and chain</st> `<st c="23638">AddTaskIntent</st>`
    <st c="23651">and</st> `<st c="23656">OpenTaskIntent</st>` <st c="23670">together
    (</st>*<st c="23681">Figure 13</st>**<st c="23691">.8</st>*<st c="23693">):</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23592">让我们回到Shortcuts应用，并将</st> `<st c="23638">AddTaskIntent</st>` <st
    c="23651">和</st> `<st c="23656">OpenTaskIntent</st>` <st c="23670">一起链式连接（</st>*<st
    c="23681">图13</st>**<st c="23691">.8</st>*<st c="23693">）：</st>
- en: '![Figure 13.8: A shortcut with Create and Open a task intents](img/B21795_figure_13.08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.8: A shortcut with Create and Open a task intents](img/B21795_figure_13.08.jpg)'
- en: '<st c="23810">Figure 13.8: A shortcut with Create and Open a task intents</st>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="23810">Figure 13.8: A shortcut with Create and Open a task intents</st>'
- en: <st c="23869">Now we have a shortcut that creates a new task and opens it in
    the app, and we’ve done this with very</st> <st c="23972">little code!</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23869">现在我们有一个快捷方式可以创建一个新任务并在应用中打开它，而且我们用非常</st> <st c="23972">少的代码就做到了！</st>
- en: <st c="23984">But what about the properties</st> <st c="24014">we defined as
    part of the</st> `<st c="24041">Task</st>` <st c="24045">entity?</st> <st c="24054">We
    haven’t used them yet!</st> <st c="24080">Let’s see how to use them with</st>
    <st c="24111">other intents.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23984">但是关于我们定义的作为</st> `<st c="24041">Task</st>` <st c="24045">实体一部分的属性呢？</st>
    <st c="24054">我们还没有使用它们！</st> <st c="24080">让我们看看如何使用它们与其他意图一起。</st> <st c="24111">其他意图。</st>
- en: <st c="24125">Integrating our intent to other intents</st>
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24125">将我们的意图与其他意图集成</st>
- en: <st c="24165">We’ve seen how to chain</st> <st c="24189">the added task with
    the</st> `<st c="24214">Open a task</st>` <st c="24225">intents, but that was
    straightforward – we created both intents, so both were aware of the</st> `<st
    c="24317">Task</st>` <st c="24321">entity.</st> <st c="24330">But what do we do
    when we need to return the</st> `<st c="24375">Task</st>` <st c="24379">entity
    to an intent from another app developer?</st> <st c="24428">The first option is
    to select one of</st> <st c="24465">the properties.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24165">我们已经看到了如何将添加的任务与</st> `<st c="24214">打开任务</st>` <st c="24225">意图链式连接，但这很简单——我们创建了两个意图，所以它们都知道</st>
    `<st c="24317">Task</st>` <st c="24321">实体。</st> <st c="24330">但是当我们需要将</st> `<st
    c="24375">Task</st>` <st c="24379">实体返回给另一个应用开发者的意图时，我们该怎么办呢？</st> <st c="24428">第一个选择是选择其中一个</st>
    <st c="24465">属性。</st>
- en: <st c="24480">Selecting one of the properties</st>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="24480">选择其中一个属性</st>
- en: <st c="24512">One of the good things</st> <st c="24535">about</st> `<st c="24542">AppEntity</st>`
    <st c="24551">is that it creates a structure that can be utilized across</st>
    <st c="24611">our system:</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24512">关于</st> <st c="24535">`<st c="24542">AppEntity</st>`</st> <st
    c="24551">的一个好处</st> <st c="24611">是它创建了一个可以在</st> <st c="24611">我们的系统中</st> <st
    c="24611">利用的结构：</st>
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="24870">Our</st> `<st c="24875">Task</st>` <st c="24879">structure contains</st>
    <st c="24898">a display name (</st>`<st c="24915">Task</st>`<st c="24920">) and
    two properties –</st> `<st c="24944">Title</st>` <st c="24949">and</st> `<st c="24954">Description</st>`<st
    c="24965">. We can use that to pass on one of these values to the next action
    in the</st> <st c="25040">Shortcuts app.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24870">我们的</st> `<st c="24875">Task</st>` <st c="24879">结构</st> <st c="24898">包含一个显示名称（</st>`<st
    c="24915">Task</st>`<st c="24920">）和两个属性 –</st> `<st c="24944">Title</st>` <st
    c="24949">和</st> `<st c="24954">Description</st>`<st c="24965">。我们可以使用这些属性之一传递给Shortcuts应用中的下一个操作。</st>
    <st c="25040">Shortcuts应用。</st>
- en: <st c="25054">For example, let’s say we want to create a new task and send its
    title in a message.</st> <st c="25140">Because we defined the</st> `<st c="25163">title</st>`
    <st c="25168">variable as an</st> `<st c="25184">AppEntity</st>` <st c="25193">property,
    it will show up in the Shortcuts app (</st>*<st c="25242">Figure 13</st>**<st
    c="25252">.9</st>*<st c="25254">):</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25054">例如，让我们假设我们想要创建一个新的任务并在消息中发送其标题。</st> <st c="25140">因为我们定义了</st>
    `<st c="25163">标题</st>` <st c="25168">变量为一个</st> `<st c="25184">AppEntity</st>`
    <st c="25193">属性</st>`，它将显示在快捷方式应用中（</st>*<st c="25242">图13</st>**<st c="25252">.9</st>*<st
    c="25254">）：</st>
- en: '![Figure 13.9: Choosing the Title property in the Shortcuts app](img/B21795_figure_13.09.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9：在快捷方式应用中选择标题属性](img/B21795_figure_13.09.jpg)'
- en: '<st c="25429">Figure 13.9: Choosing the Title property in the Shortcuts app</st>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25429">图13.9：在快捷方式应用中选择标题属性</st>
- en: '*<st c="25490">Figure 13</st>**<st c="25500">.9</st>* <st c="25502">shows how
    we can select one of the</st> `<st c="25538">AppEntity</st>` <st c="25547">properties
    to pass on to the</st> *<st c="25577">send</st>* *<st c="25582">message</st>*
    <st c="25589">intent.</st>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="25490">图13</st>**<st c="25500">.9</st>* <st c="25502">展示了我们如何选择一个 `<st
    c="25538">AppEntity</st>` <st c="25547">属性</st>` 并将其传递给 *<st c="25577">发送</st>*
    *<st c="25582">消息</st>* <st c="25589">意图。</st>'
- en: <st c="25597">Passing on</st> `<st c="25609">Title</st>` <st c="25614">is obvious—</st>`<st
    c="25626">Title</st>` <st c="25632">is a string, and we can easily use it as an
    input for other actions.</st> <st c="25702">But what if we used</st> `<st c="25722">Task</st>`
    <st c="25726">as an input for the</st> *<st c="25747">send message</st>* <st c="25759">action?</st>
    <st c="25768">We did that in the</st> *<st c="25787">Chaining app intents</st>*
    <st c="25807">section, but that was between two actions from the same app.</st>
    <st c="25869">Can we share</st> <st c="25881">an entity between two</st> <st c="25904">different
    apps?</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `<st c="25609">标题</st>` <st c="25614">是显而易见的——</st>`<st c="25626">标题</st>`
    <st c="25632">是一个字符串，我们可以轻松地将其用作其他操作的输入。</st> <st c="25702">但如果我们使用</st> `<st
    c="25722">任务</st>` <st c="25726">作为</st> *<st c="25747">发送消息</st>* <st c="25759">操作的输入呢？</st>
    <st c="25768">我们在</st> *<st c="25787">链式应用意图</st>* <st c="25807">部分做过这样的事情，但那是在同一应用的两个操作之间。</st>
    <st c="25869">我们能否在两个</st> <st c="25881">不同的应用</st> <st c="25904">之间共享</st> <st
    c="25904">一个实体？</st>
- en: <st c="25919">That’s why we have the</st> **<st c="25943">Transferable</st>**
    <st c="25955">protocol.</st> <st c="25966">Let’s</st> <st c="25972">use it!</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25919">这就是为什么我们有</st> **<st c="25943">Transferable</st>** <st c="25955">协议。</st>
    <st c="25966">让我们</st> <st c="25972">使用它！</st>
- en: <st c="25979">Use the Transferable protocol to pass the entire entity</st>
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="25979">使用 Transferable 协议传递整个实体</st>
- en: <st c="26035">Let’s step outside the framework</st> <st c="26069">of</st> `<st
    c="26072">AppIntent</st>` <st c="26081">for a second.</st> <st c="26096">The idea
    of sharing data is not limited to</st> `<st c="26139">AppIntent</st>`<st c="26148">—we
    have more use cases when we need to share data.</st> <st c="26201">For example,
    dragging and dropping between views or even between apps is one example of sharing
    data.</st> <st c="26303">Another example would be copying and pasting between
    screens</st> <st c="26364">or apps.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26035">让我们暂时跳出</st> <st c="26069">《st c="26072">AppIntent</st>` <st c="26081">》的框架。</st>
    <st c="26096">共享数据的思想并不局限于</st> `<st c="26139">AppIntent</st>`<st c="26148">——当我们需要共享数据时，我们还有更多的用例。</st>
    <st c="26201">例如，在视图之间或甚至在不同应用之间拖放是共享数据的一个例子。</st> <st c="26303">另一个例子是在屏幕或应用之间复制粘贴。</st>
- en: <st c="26372">The main challenge when performing sharing is finding a data type
    each app</st> <st c="26448">agrees on.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行共享时，主要挑战是找到每个应用都同意的数据类型。<st c="26448">达成共识。</st>
- en: <st c="26458">To address that sharing problem, Apple introduced the</st> `<st
    c="26513">Transferable</st>` <st c="26525">protocol in iOS 16, making sharing
    data between apps or different</st> <st c="26592">spots easy.</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26458">为了解决这个共享问题，苹果在 iOS 16 中引入了</st> `<st c="26513">Transferable</st>`
    <st c="26525">协议，使得在应用或不同</st> <st c="26592">位置之间共享数据变得容易。</st>
- en: <st c="26603">Transferable’s main usages</st> <st c="26630">are copying and
    pasting and dragging and dropping, but it is also great for sharing app entities
    in the</st> <st c="26735">Shortcuts app.</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26603">Transferable` 的主要用途是复制粘贴和拖放，但它也非常适合在 `<st c="26735">快捷方式应用</st>`
    中共享应用实体。'
- en: <st c="26749">Now, let’s extend</st> `<st c="26768">Task</st>` <st c="26772">to
    conform</st> <st c="26784">to</st> `<st c="26787">Transferable</st>`<st c="26799">:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26749">现在，让我们扩展</st> `<st c="26768">任务</st>` <st c="26772">以符合</st> `<st
    c="26784">Transferable</st>`<st c="26799">:</st>
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="26902">The</st> `<st c="26906">Transferable</st>` <st c="26918">protocol
    has one static variable called</st> `<st c="26959">transferRepresentation</st>`<st
    c="26981">. This variable allows us to define how the structure is represented
    when sharing it with different apps</st> <st c="27086">or views.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26902">《st c="26906">可传输</st>` <st c="26918">协议有一个名为</st> `<st c="26959">transferRepresentation</st>`<st
    c="26981">的静态变量。这个变量允许我们定义在与其他应用</st> <st c="27086">或视图共享结构时如何表示。</st>
- en: <st c="27095">When working with the</st> `<st c="27118">AppIntent</st>` <st
    c="27127">framework, we</st> <st c="27141">have several ways to fulfill the</st>
    `<st c="27175">transferRepresentation</st>` <st c="27197">variable:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27095">当使用</st> `<st c="27118">AppIntent</st>` <st c="27127">框架时，我们有几种方法来满足</st>
    `<st c="27175">transferRepresentation</st>` <st c="27197">变量：</st>
- en: '`<st c="27207">DataRepresentation</st>`<st c="27226">: We use</st> `<st c="27236">DataRepresentation</st>`
    <st c="27254">to convert our object to a data format such as RTF or an</st> <st
    c="27312">image PNG</st>'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27207">数据表示</st>`<st c="27226">：我们使用</st> `<st c="27236">数据表示</st>`
    <st c="27254">将我们的对象转换为RTF或PNG图像等数据格式</st>'
- en: '`<st c="27321">FileRepresentation</st>`<st c="27340">: We use</st> `<st c="27350">FileRepresentation</st>`
    <st c="27368">to export our entity as a file, such as</st> <st c="27409">a PDF</st>'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27321">文件表示</st>`<st c="27340">：我们使用</st> `<st c="27350">文件表示</st>`
    <st c="27368">将我们的实体导出为文件，例如</st> <st c="27409">PDF</st>'
- en: '`<st c="27414">ProxyRepresentation</st>`<st c="27434">: This provides an alternative
    in case none of the other representations</st> <st c="27508">are suitable</st>'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27414">代理表示</st>`<st c="27434">：这为其他表示都不合适时提供了一个替代方案</st>'
- en: <st c="27520">Let’s see how we can support both RTF and</st> <st c="27563">plain
    text:</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27520">让我们看看我们如何支持RTF和</st> <st c="27563">纯文本：</st>
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="27788">In our code example, we used both</st> `<st c="27823">DataRepresentation</st>`
    <st c="27841">and</st> `<st c="27846">ProxyRepresentation</st>` <st c="27865">to
    support both RTF and</st> <st c="27890">plain text.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27788">在我们的代码示例中，我们使用了</st> `<st c="27823">数据表示</st>` <st c="27841">和</st>
    `<st c="27846">代理表示</st>` <st c="27865">来支持RTF和</st> <st c="27890">纯文本。</st>
- en: <st c="27901">This means that when we try</st> <st c="27929">to share the</st>
    `<st c="27943">Task</st>` <st c="27947">entity, the</st> `<st c="27960">Transferable</st>`
    <st c="27972">mechanism will try to export the</st> `<st c="28006">RTF</st>` <st
    c="28009">first and turn to</st> `<st c="28028">ProxyRepresentation</st>` <st
    c="28047">as</st> <st c="28051">a fallback.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27901">这意味着当我们尝试</st> <st c="27929">共享</st> `<st c="27943">任务</st>` <st
    c="27947">实体时，</st> `<st c="27960">可传输</st>` <st c="27972">机制将尝试首先导出RTF，然后作为后备方案转向</st>
    `<st c="28028">代理表示</st>` <st c="28047">。</st>
- en: <st c="28062">In addition, in the Shortcuts app, the user can select the data
    type they want to be exported to the next step in the script (</st>*<st c="28189">Figure
    13</st>**<st c="28199">.10</st>*<st c="28202">):</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28062">此外，在快捷方式应用中，用户可以选择他们想要导出到脚本下一步的数据类型（</st>*<st c="28189">图13</st>**<st
    c="28199">.10</st>*<st c="28202">）：</st>
- en: '![Figure 13.10: The Shortcuts app with different data formats](img/B21795_figure_13.10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10：具有不同数据格式的快捷方式应用](img/B21795_figure_13.10.jpg)'
- en: '<st c="28671">Figure 13.10: The Shortcuts app with different data formats</st>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28671">图13.10：具有不同数据格式的快捷方式应用</st>
- en: '*<st c="28730">Figure 13</st>**<st c="28740">.10</st>* <st c="28743">shows
    how the user selects the data format for the</st> <st c="28795">exported item.</st>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="28730">图13</st>**<st c="28740">.10</st>* <st c="28743">展示了用户如何选择导出项目的数据格式。</st>
    <st c="28795">导出项。</st>'
- en: <st c="28809">The more formats and data types we support in our app entities,
    the more choices our users have for using</st> <st c="28916">our data.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28809">我们在应用实体中支持更多格式和数据类型，用户在使用我们的数据时就有更多的选择。</st>
- en: <st c="28925">At this stage, we know how to export</st> <st c="28962">our app
    intents and entities.</st> <st c="28993">In a way, the system knows what our app
    is capable of.</st> <st c="29048">Let’s see how we can take this one step further
    and adjust it to work with</st> <st c="29123">Apple Intelligence.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28925">在这个阶段，我们知道如何导出</st> <st c="28962">我们的应用意图和实体。</st> <st c="28993">从某种意义上说，系统知道我们的应用能做什么。</st>
    <st c="29048">让我们看看我们如何更进一步，并调整它以与</st> <st c="29123">苹果智能技术</st>一起工作。</st>
- en: <st c="29142">Adjusting our app intents to work with Apple Intelligence</st>
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="29142">调整我们的应用意图以与苹果智能技术一起工作</st>
- en: <st c="29200">In the previous chapter, we discussed</st> <st c="29238">how we
    can take advantage of some of iOS’s machine learning and AI capabilities.</st>
    <st c="29320">One of the things that evolved in that area in iOS 18 is Siri.</st>
    <st c="29383">Siri is now smarter than ever and can allow users to perform tasks
    in</st> <st c="29453">natural language.</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29200">在上一章中，我们讨论了</st> <st c="29238">如何利用一些 iOS 的机器学习和人工智能功能。</st> <st
    c="29320">iOS 18 中在该领域演变的一件事是 Siri。</st> <st c="29383">Siri 现在比以往任何时候都更聪明，并允许用户以</st>
    <st c="29453">自然语言执行任务。</st>
- en: <st c="29470">For example, the user can say something like</st> *<st c="29516">Send
    this photo to my mom</st>* <st c="29541">to Siri, and Siri can handle that task
    without needing the</st> <st c="29601">exact phrase.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29470">例如，用户可以说</st> *<st c="29516">将这张照片发送给我的妈妈</st>* <st c="29541">给
    Siri，Siri 可以处理这个任务而无需</st> <st c="29601">确切的短语。</st>
- en: <st c="29614">Siri’s new capabilities are exactly where our app intents come
    in.</st> <st c="29682">Imagine that on one side, we have Siri, which can understand
    the user intent.</st> <st c="29760">On the other hand, we have the various actions
    we expose</st> <st c="29816">to the system.</st> <st c="29832">So, we must find
    a way to bind between the user intent, as Siri understands it, and our app actions.</st>
    <st c="29933">This is what we call an</st> **<st c="29957">Assistant Schema</st>**<st
    c="29973">.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29614">Siri 的新功能正是我们的应用程序意图所在。</st> <st c="29682">想象一下，在一侧，我们有 Siri，它可以理解用户意图。</st>
    <st c="29760">在另一侧，我们有我们向系统公开的各种操作。</st> <st c="29816">因此，我们必须找到一种方法来绑定用户意图，正如
    Siri 所理解的那样，以及我们的应用程序操作。</st> <st c="29933">这就是我们所说的</st> **<st c="29957">助手模式</st>**<st
    c="29973">。</st>
- en: <st c="29974">Exploring the Assistant Schema</st>
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29974">探索助手模式</st>
- en: <st c="30005">The Assistant Schema</st> <st c="30027">idea is simple yet advanced
    and full</st> <st c="30064">of potential.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30005">助手模式</st> <st c="30027">的想法简单而先进，充满潜力。</st>
- en: <st c="30077">Let’s look at</st> *<st c="30092">Figure 13</st>**<st c="30101">.11</st>*<st
    c="30104">, which describes how Assistant</st> <st c="30136">Schema works:</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30077">让我们看看</st> *<st c="30092">图 13</st>**<st c="30101">.11</st>*<st
    c="30104">，它描述了助手</st> <st c="30136">模式的工作方式：</st>
- en: '![Figure 13.11: The Assistant Schema flow](img/B21795_figure_13.11.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11：助手模式流程](img/B21795_figure_13.11.jpg)'
- en: '<st c="30343">Figure 13.11: The Assistant Schema flow</st>'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30343">图 13.11：助手模式流程</st>
- en: '*<st c="30382">Figure 13</st>**<st c="30392">.11</st>* <st c="30395">describes
    how the Assistant Schema</st> <st c="30431">flow works:</st>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="30382">图 13</st>**<st c="30392">.11</st>* <st c="30395">描述了助手模式</st>
    <st c="30431">流程的工作方式：</st>'
- en: <st c="30442">The user requests Siri in a</st> *<st c="30471">free and natural
    phrase</st>* <st c="30494">for a specific action.</st> <st c="30518">In this case,
    the user says, “Email this to</st> <st c="30562">my wife.”</st>
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30442">用户以</st> *<st c="30471">自由而自然的短语</st>* <st c="30494">请求 Siri 执行特定操作。</st>
    <st c="30518">在这种情况下，用户说，“将这封邮件发送给我的妻子。”</st>
- en: <st c="30571">Siri and Apple Intelligence convert the request to one of the
    system’s predefined schemas using sophisticated machine learning models.</st>
    <st c="30707">In this case, Apple Intelligence translates the user request to
    the</st> `<st c="30775">createDraft</st>` <st c="30786">schema from the</st> `<st
    c="30803">mail</st>` <st c="30807">domain.</st>
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30571">Siri 和苹果智能使用复杂的机器学习模型将请求转换为系统预定义的其中一个模式。</st> <st c="30707">在这种情况下，苹果智能将用户请求转换为来自</st>
    `<st c="30775">createDraft</st>` <st c="30786">模式</st> 的 `<st c="30803">mail</st>`
    <st c="30807">域。</st>
- en: <st c="30815">Now that Siri knows the selected schema, it looks to find a matching
    intent in its toolbox.</st> <st c="30908">We can associate some of our app intents
    with a</st> <st c="30956">specific schema.</st>
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30815">现在 Siri 知道所选模式后，它会寻找工具箱中匹配的意图。</st> <st c="30908">我们可以将一些应用程序意图与特定的模式关联起来。</st>
- en: <st c="30972">Siri launches and performs a corresponding app intent according
    to the decision taken in the previous step (the</st> <st c="31085">toolbox step).</st>
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30972">Siri 启动并执行上一步（工具箱步骤）中做出的相应应用程序意图。</st>
- en: <st c="31099">The fact that Apple Intelligence takes responsibility for understanding
    our users and picking the right action makes our job as developers simple – all
    we need to do is ensure our intents match a predefined</st> <st c="31307">Assistant
    Schema.</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31099">苹果智能负责理解我们的用户并选择正确的操作，这使得我们的工作作为开发者变得简单——我们只需要确保我们的意图与预定义的</st>
    <st c="31307">助手模式</st> 匹配。</st>
- en: <st c="31324">Let’s see how to do that.</st> <st c="31351">Imagine</st> <st
    c="31358">we have an amazing mail client app that we’ve built.</st> <st c="31412">Users
    can browse their email accounts using our app and create and send new</st> <st
    c="31488">email messages.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31324">让我们看看如何做到这一点。</st> <st c="31351">想象一下</st> <st c="31358">我们有一个我们构建的令人惊叹的邮件客户端应用。</st>
    <st c="31412">用户可以使用我们的应用浏览他们的电子邮件账户，并创建和发送新的</st> <st c="31488">电子邮件消息。</st>
- en: <st c="31503">One of the app’s main actions is creating a new draft; so, we’ve
    created an app intent to expose</st> <st c="31601">that capability:</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31503">该应用的主要操作之一是创建新草稿；因此，我们创建了一个应用意图来暴露</st> <st c="31601">该功能：</st>
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="32051">In this code example, we created a</st> `<st c="32087">SendDraftIntent</st>`
    <st c="32102">app intent that takes a</st> `<st c="32127">body</st>` <st c="32131">variable,
    creates a mail draft entity, and launches the</st> <st c="32188">mail composer.</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32051">在这个代码示例中，我们创建了一个 `<st c="32087">SendDraftIntent</st>` <st c="32102">应用意图，它接受一个</st>
    `<st c="32127">body</st>` <st c="32131">变量，创建一个邮件草稿实体，并启动邮件编辑器。</st>
- en: <st c="32202">It’s great that we have a</st> *<st c="32229">create draft</st>*
    <st c="32241">action our users can add to their shortcuts.</st> <st c="32287">However,
    Siri doesn’t care that we called our app intent</st> `<st c="32344">SendDraftIntent</st>`
    <st c="32359">– we want our intent to be part of its Apple Intelligence toolbox.</st>
    <st c="32427">In other words – add it to the</st> <st c="32458">Assistant Schema.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32202">很棒的是，我们有一个</st> *<st c="32229">创建草稿</st>* <st c="32241">操作，用户可以将它添加到他们的快捷方式中。</st>
    <st c="32287">然而，Siri 并不在乎我们给我们的应用意图命名为 `<st c="32344">SendDraftIntent</st>` <st
    c="32359">，我们希望我们的意图成为其苹果智能工具箱的一部分。</st> <st c="32427">换句话说 – 将其添加到</st> <st c="32458">助手模式。</st>
- en: <st c="32475">To do that, we add a special Swift macro</st> <st c="32517">called</st>
    `<st c="32524">AssistantIntent(schema:)</st>`<st c="32548">:</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32475">为此，我们添加了一个特殊的 Swift 宏</st> <st c="32517">，称为</st> `<st c="32524">AssistantIntent(schema:)</st>`<st
    c="32548">：</st>
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="32629">Adding the</st> `<st c="32641">AssistantIntent</st>` <st c="32656">Swift
    macro with the</st> `<st c="32678">.mail.createDraft</st>` <st c="32695">schema
    to our app intent signals Apple Intelligence.</st> <st c="32749">This is a</st>
    *<st c="32759">create draft</st>* <st c="32771">app intent regardless of how we</st>
    <st c="32804">named it.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32629">将 `<st c="32641">AssistantIntent</st>` <st c="32656">Swift 宏与
    `<st c="32678">.mail.createDraft</st>` <st c="32695">模式添加到我们的应用意图中，向苹果智能发出信号。</st>
    <st c="32749">这是一个</st> *<st c="32759">创建草稿</st>* <st c="32771">应用意图，无论我们如何命名它。</st>
- en: <st c="32813">Swift Macros – a reminder</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32813">Swift 宏 – 提醒</st>
- en: <st c="32839">Swift Macros is a new feature</st> <st c="32869">Apple added to
    iOS 17 that can inject new properties and functions and manipulate our code to
    various needs.</st> <st c="32979">To learn more about Swift Macros, refer to</st>
    [*<st c="33022">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="33032">.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32839">Swift 宏</st> <st c="32869">是苹果公司为 iOS 17 新增的一项功能</st>，它可以注入新的属性和函数，并操纵我们的代码以满足各种需求。</st>
    <st c="32979">要了解更多关于 Swift 宏的信息，请参阅</st> [*<st c="33022">第 10 章</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="33032">。</st>
- en: <st c="33033">The</st> `<st c="33038">.mail.createDraft</st>` <st c="33055">schema</st>
    <st c="33062">is built of two parts – the domain (</st>`<st c="33099">mail</st>`<st
    c="33104">) and the schema (</st>`<st c="33123">createDraft</st>`<st c="33135">).</st>
    <st c="33139">We can use more schemas in the</st> `<st c="33170">mail</st>` <st
    c="33174">domain, such as</st> `<st c="33191">deleteDraft</st>`<st c="33202">,</st>
    `<st c="33204">saveDraft</st>`<st c="33213">, or</st> `<st c="33218">replyMail</st>`<st
    c="33227">. In addition, we have more domains and schemas to work with, such as
    presentations, payments, browsing, photos, books, and more.</st> <st c="33357">To
    see the full list</st> <st c="33377">of domains and schemas, go to Apple’s documentation</st>
    <st c="33430">at</st> [<st c="33433">https://developer.apple.com/documentation/AppIntents/app-intent-domains</st>](https://developer.apple.com/documentation/AppIntents/app-intent-domains)<st
    c="33504">.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33033">`.mail.createDraft` <st c="33038">模式</st> <st c="33055">由两部分组成
    – 域（</st>`<st c="33099">mail</st>`<st c="33104">）和模式（</st>`<st c="33123">createDraft</st>`<st
    c="33135">）。</st> <st c="33139">我们可以在 `<st c="33170">mail</st>` <st c="33174">域中使用更多模式，例如</st>
    `<st c="33191">deleteDraft</st>`<st c="33202">，`<st c="33204">saveDraft</st>`<st
    c="33213">，或</st> `<st c="33218">replyMail</st>`<st c="33227">。此外，我们还有更多域和模式可以与之配合，例如演示文稿、支付、浏览、照片、书籍等等。</st>
    <st c="33357">要查看完整的域和模式列表</st> <st c="33377">，请访问苹果公司的文档</st> <st c="33430">，网址为</st>
    [<st c="33433">https://developer.apple.com/documentation/AppIntents/app-intent-domains</st>](https://developer.apple.com/documentation/AppIntents/app-intent-domains)<st
    c="33504">。</st>
- en: <st c="33505">So, what does the</st> `<st c="33524">AssistantIntet</st>` <st
    c="33538">Swift</st> <st c="33545">macro do?</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33554">The first thing it does is add a new static variable</st> <st
    c="33608">named</st> `<st c="33614">__assistantSchemaIntent</st>`<st c="33637">:</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<st c="34389">@AssistantIntent(schema: .mail.createDraft)</st> struct SendDraftIntent:
    AppIntent { <st c="34470">var account: MailAccountEntity?</st>'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="34501">var attachments: [IntentFile]</st>'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="34531">var to: [IntentPerson]</st>'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="34554">var cc: [IntentPerson]</st>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="34577">var bcc: [IntentPerson]</st>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="34601">var subject: String?</st> var body: String? @MainActor'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: func perform() async throws -> some ReturnsValue
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <MailDraftEntity>{
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let mailDraftEntity = MailDraftEntity(body:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'EntityProperty(title: LocalizedStringResource'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '(stringLiteral: body!)))'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ComposeDraftManager.shared.isPresentingCompose =
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return .result(value: mailDraftEntity)'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<st c="36213">MailAccountEntity</st> is not part of the framework of <st c="36264">AppIntent</st>—it’s
    a type we define that must fulfill the Assistant Schema requirements, similar
    to what we did in <st c="36376">SendDraftIntent</st>. Let’s see how to implement
    it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<st c="36919">In this example, we can see that our</st> `<st c="36957">MailAccountEntity</st>`
    <st c="36974">struct has a Swift macro named</st> `<st c="37006">@AssistantEntity(schema:
    .mail.account)</st>`<st c="37045">. This macro makes our entity conform to</st>
    `<st c="37086">AssistantSchemaEntity</st>` <st c="37107">and requires the struct
    to implement important properties, such as</st> `<st c="37175">emailAddress</st>`
    <st c="37187">and</st> `<st c="37192">name</st>`<st c="37196">.</st>'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37197">The Swift macro also requires us to add a default query to help
    the system fetch and locate accounts</st> <st c="37299">when needed.</st>
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37311">The second entity</st> <st c="37329">we need to implement</st>
    <st c="37351">is</st> `<st c="37354">MailDraftEntity</st>`<st c="37369">:</st>
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`<st c="37986">MailDraftEntity</st>` <st c="38002">contains properties such
    as those of</st> `<st c="38040">SendDraftIntent</st>`<st c="38055">. That’s because
    it’s the result of the</st> `<st c="38095">SendDraftIntent</st>` `<st c="38110">perform()</st>`
    <st c="38120">function, and Siri can use it to chain the information to other
    actions in</st> <st c="38196">its toolbox.</st>'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38208">Adding both</st> `<st c="38221">MailDraftEntity</st>` <st c="38236">and</st>
    `<st c="38241">MailAccountEntity</st>` <st c="38258">can be annoying – it requires
    us to adjust our information to a specific interface.</st> <st c="38343">However,
    doing that makes our Siri integration flawless</st> <st c="38399">and effective.</st>
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38413">Once we have everything</st> <st c="38437">set, the user can see
    a photo and say something like, “Email this photo using MyMailComposer app,” and
    Siri will launch our app with a</st> <st c="38573">new draft.</st>
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38583">An important disclaimer about the code snippets of this section</st>
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38583">关于本节代码片段的重要免责声明</st>
- en: <st c="38647">Apple Intelligence</st> <st c="38666">has not yet been rolled
    out as of the time of writing this book.</st> <st c="38732">This means the code
    was successfully compiled but has not yet been tested to work with Apple Intelligence.</st>
    <st c="38839">When Apple Intelligence reaches your region, you may need to make
    some adjustments to your code in order for it to work with Siri</st> <st c="38969">as
    expected.</st>
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38647">苹果智能</st> <st c="38666">在撰写本书时尚未推出。</st> <st c="38732">这意味着代码已成功编译，但尚未测试与苹果智能兼容。</st>
    <st c="38839">当苹果智能到达您的地区时，您可能需要调整代码，以便它能够按预期与Siri协同工作。</st> <st c="38969">。</st>
- en: <st c="38981">As one of Apple’s senior managers once said, we should consider
    all of our app actions to be app intents.</st> <st c="39088">This approach makes
    the possibilities for us</st><st c="39132">ers to interact with our</st> <st c="39158">app
    limitless.</st>
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如苹果公司一位高级经理曾说过，我们应该将我们所有的应用操作视为应用意图。<st c="39088">这种做法为我们</st><st c="39132">提供了与我们的</st>
    <st c="39158">应用互动的无限可能性。</st>
- en: <st c="39172">Summary</st>
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39172">总结</st>
- en: <st c="39180">That was an exciting chapter!</st> <st c="39211">This is not only
    because app intents are a very exciting topic but also because it’s the first
    time we’re truly integrating our code with one of Apple’s most</st> <st c="39369">significant
    technologies.</st>
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39180">这是一个令人兴奋的章节！</st> <st c="39211">这不仅是因为应用意图是一个非常令人兴奋的话题，而且还因为这是我们第一次真正将我们的代码与苹果最重要的</st>
    <st c="39369">技术之一集成。</st>
- en: <st c="39394">In this chapter, we discussed the concept of app intents, created
    a simple app intent with different use cases, formalized our content using app
    entities, and even adjusted them to work with Apple Intelligence.</st> <st c="39606">By
    now, we should be ready to bring Siri to our app in</st> <st c="39661">no time!</st>
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39394">在本章中，我们讨论了应用意图的概念，创建了一个具有不同用例的简单应用意图，使用应用实体正式化我们的内容，甚至调整它们以与苹果智能协同工作。</st>
    <st c="39606">现在，我们应该准备好在</st> <st c="39661">短时间内将Siri引入我们的应用！</st>
- en: <st c="39669">The next chapter looks at our app from a different perspective
    –</st> <st c="39735">quality.</st>
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39669">下一章将从不同的角度审视我们的应用——</st> <st c="39735">质量。</st>
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
