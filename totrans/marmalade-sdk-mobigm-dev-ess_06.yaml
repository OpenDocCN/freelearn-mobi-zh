- en: Chapter 6. Implementing Fonts, User Interfaces, and Localization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 实现字体、用户界面和本地化
- en: Now that we have the knowledge to create 3D worlds populated with animated characters,
    we really need to start thinking about how to improve the look of the user interface
    we present to the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建充满动画角色的3D世界的知识，我们真的需要开始思考如何改善我们向玩家展示的用户界面的外观。
- en: 'In this chapter we''ll be covering the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating fonts that can be used in a Marmalade project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可用于Marmalade项目的字体
- en: Drawing and formatting of text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本的绘制和格式化
- en: Discussing ways of implementing your game's user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论实现您游戏用户界面的方法
- en: Localizing your game into multiple languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的游戏本地化为多种语言
- en: Implementing fonts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现字体
- en: The first step toward improving the look of our game is to say goodbye to the
    debug font and replace it with something a little more stylish. The Marmalade
    SDK comes complete with an API called IwGxFont dedicated to font rendering, so
    let's put it to good use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 改善我们游戏外观的第一步是告别调试字体，用一些更时尚的东西来替换它。Marmalade SDK附带了一个名为IwGxFont的API，专门用于字体渲染，让我们好好利用它。
- en: Adding the IwGxFont API to a project
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将IwGxFont API添加到项目中
- en: By now I'm sure you must be able to hazard a guess as to how this is done. That's
    right, just add `iwgxfont` to the subprojects section in the MKB file, and then
    make a call to `IwGxFontInit` to initialize the API, and `IwGxFontTerminate` to
    free it at shutdown time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我敢肯定您一定能猜到这是如何完成的。没错，只需在MKB文件的子项目部分添加`iwgxfont`，然后调用`IwGxFontInit`来初始化API，并在关闭时调用`IwGxFontTerminate`来释放它。
- en: 'As the name of this API suggests, it requires IwGx in order to work. We also
    need IwResManager so we can load the font data into memory, so the initialization
    call for IwGxFont must occur after these two modules have been initialized, as
    shown in the following code snippet:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如此API的名称所暗示的，它需要IwGx才能工作。我们还需要IwResManager，以便将字体数据加载到内存中，因此IwGxFont的初始化调用必须在初始化这两个模块之后进行，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a font resource
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建字体资源
- en: 'The first thing we need to do is create a `CIwGxFont` resource describing the
    font that we want to use. This is easily done thanks to the **Marmalade Studio
    - Font Builder** utility that is installed as part of the Marmalade SDK. The following
    image shows a screenshot of this program in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个描述我们想要使用的字体的`CIwGxFont`资源。这很容易做到，多亏了作为Marmalade SDK一部分安装的**Marmalade
    Studio - Font Builder**实用程序。以下图片显示了该程序运行时的截图：
- en: '![Creating a font resource](img/3363_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建字体资源](img/3363_06_01.jpg)'
- en: The IwGxFont API renders text by drawing each character individually by using
    sections of a large bitmap that contains an image of all the characters we need
    to render. Generating the bitmap itself is fairly trivial and could be done with
    any art package, but we need to somehow be able to specify which part of the bitmap
    represents which character. This is where IwGxFont and the font builder utility
    come to our aid.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IwGxFont API通过使用包含所有需要渲染的字符图像的大位图的片段来逐个绘制字符来渲染文本。生成位图本身相当简单，可以使用任何艺术包完成，但我们需要以某种方式指定位图的哪一部分代表哪个字符。这就是IwGxFont和字体构建实用程序对我们有所帮助的地方。
- en: 'Here are the basic steps needed to generate a font resource:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 生成字体资源需要以下基本步骤：
- en: Start the **Marmalade Studio - Font** **Builder** utility. You can find a Windows
    Start button menu shortcut for it under **Marmalade** | **x.x** | **Tools**, where
    **x.x** represents the version number of the Marmalade SDK you have installed.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动**Marmalade Studio - Font Builder**实用程序。您可以在**Marmalade** | **x.x** | **Tools**下找到它的Windows开始按钮菜单快捷方式，其中**x.x**代表您安装的Marmalade
    SDK的版本号。
- en: In the top-left panel labeled **Input**, first click on the **Select…** button
    to display a font selection dialog. Choose the font, size, and style you require
    and click on **OK**. You can choose any installed Windows font, whether it be
    a scalable TrueType font or a fixed-size bitmapped font.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记为**输入**的左上角面板中，首先点击**选择…**按钮以显示字体选择对话框。选择所需的字体、大小和样式，然后点击**确定**。您可以选择任何已安装的Windows字体，无论是可缩放的TrueType字体还是固定大小的位图字体。
- en: The **Characters** textbox allows you to specify a list of the characters you
    require in your font. A default selection covering most European languages is
    present, but you can add or remove as many characters as you want. Fewer characters
    is obviously better though, as it will reduce the size of the bitmap that gets
    generated and thus take up less memory. It is also possible to populate this textbox
    by loading a text file using **File** | **Load Character Map**. The **Characters**
    textbox will then contain every unique character present in the text file, minus
    formatting characters such as tabs or newlines.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符**文本框允许您指定您在字体中需要的字符列表。默认选择覆盖了大多数欧洲语言，但您可以添加或删除您想要的任意数量的字符。显然，字符越少越好，因为它将减少生成的位图大小，从而占用更少的内存。您还可以通过使用**文件**
    | **加载字符映射**来加载文本文件来填充此文本框。此时，**字符**文本框将包含文本文件中出现的每个唯一字符，不包括格式化字符，如制表符或换行符。'
- en: Moving on to the section labeled **Output Options**, you can choose a color
    for the font using the numeric entry boxes or by clicking on the **Select…** button
    to display a color selection dialog. It is recommended that you keep the color
    set to the default of bright white as the text color can then easily be set at
    runtime.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是标记为**输出选项**的部分，您可以使用数字输入框或单击**选择…**按钮来选择字体颜色，该按钮将显示颜色选择对话框。建议您将颜色设置为默认的亮白色，因为文本颜色可以在运行时轻松设置。
- en: There are also some other settings here that allow you to adjust the look of
    the font. There are checkboxes to force all characters to be in capitals and to
    enable the addition of a drop shadow to the font. If this checkbox is ticked,
    a textbox allows the pixel offset of the drop shadow to be specified.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此处还有一些其他设置，允许您调整字体的外观。有复选框可以强制所有字符为大写，并启用向字体添加阴影的功能。如果此复选框被勾选，则有一个文本框允许指定阴影的像素偏移量。
- en: Next, look at the top right panel labeled **Output**. Here we can see a preview
    of what the generated font characters will look like. Just click on the **Redraw**
    button and after a short delay the characters will appear in the view area. You
    can then use the two sets of **Prev** and **Next** buttons to cycle through each
    character.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，查看右上角的**输出**面板。在这里，我们可以看到生成的字体字符的预览。只需单击**重绘**按钮，稍后字符将出现在视图区域。然后，您可以使用两组**上一页**和**下一页**按钮来循环查看每个字符。
- en: We're nearly ready to export the font; but before we can, we need to specify
    where we want the font files to be created, which is done in the **Saving and
    Loading** panel. Click on the **Browse…** button to display a file requester to
    choose the required directory or enter it directly into the **Save Path** textbox.
    The last part of this filename is the base filename that will be used to export
    the font data.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎准备好导出字体了；但在我们能够这样做之前，我们需要指定字体文件要创建的位置，这可以在**保存和加载**面板中完成。单击**浏览…**按钮以显示文件选择器以选择所需的目录或直接将其输入到**保存路径**文本框中。此文件名的最后一部分是用于导出字体数据的基文件名。
- en: To create the font files, ensure that the two checkboxes labeled **Save .TGA**
    and **Save .gxfont** are checked, then click on the **Create** button.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建字体文件，请确保勾选了标记为**保存 .TGA**和**保存 .gxfont**的两个复选框，然后单击**创建**按钮。
- en: There are a number of options we haven't explored in this run-through, as most
    of the time you won't need to worry about them. In particular, we skipped the
    panel labeled **Input (per range) Options** entirely.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次演示中，我们还没有探索一些选项，因为在大多数情况下，您不需要担心它们。特别是，我们完全跳过了标记为**输入（按范围）选项**的面板。
- en: This panel provides control over font features such as kerning, which is the
    offset between the characters of a font. Kerning can sometimes be useful for bringing
    certain character combinations closer together. For example, consider the capital
    letters A and V. The shapes of these characters mean you may want to draw them
    slightly closer to provide a more natural looking result when they are displayed
    next to each other.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板提供了对字体特征的控制，例如字距，这是字体字符之间的偏移量。有时，字距调整可以使某些字符组合更靠近。例如，考虑大写字母A和V。这些字符的形状意味着您可能希望将它们稍微靠近一些，以便在它们并排显示时提供更自然的外观。
- en: You can also declare subranges of characters, which allow you to apply different
    global settings to certain ranges of characters. You can use this facility to
    use completely different sizes of characters or even completely different source
    fonts, for different character ranges. This can be particularly useful if we want
    to create a font that contains characters from the standard ASCII set and characters
    from another language. The font we use for the ASCII characters may not contain
    the characters for the other language, so we can create a sub range that allows
    us to pick a completely different font for those characters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明字符子范围，这允许您将不同的全局设置应用于某些字符范围。您可以使用此功能使用完全不同的字符大小，甚至为不同的字符范围使用完全不同的源字体。如果我们想创建一个包含标准ASCII集字符和另一种语言字符的字体，这尤其有用。我们用于ASCII字符的字体可能不包含其他语言的字符，因此我们可以创建一个子范围，允许我们为这些字符选择一个完全不同的字体。
- en: The GXFONT file format
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GXFONT文件格式
- en: The font builder utility creates two types of files to define a font resource.
    The first of these is the actual font bitmap, which is exported in the Targa file
    format, an image file format usually identified by the file extension `.tga`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字体构建器实用程序创建两种类型的文件来定义字体资源。其中第一种是实际的字体位图，它以Targa文件格式导出，这是一种通常通过文件扩展名`.tga`识别的图像文件格式。
- en: The second file exported is a **GXFONT file**, which acts as both a way of allowing
    the font to be reloaded into the font builder for further editing, and a way of
    loading the font into our own programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的第二个文件是一个**GXFONT文件**，它既允许字体被重新加载到字体构建器中进行进一步编辑，也是将字体加载到我们自己的程序中的方式。
- en: 'The following is an example GXFONT file for a font containing only numeric
    characters drawn using the standard Windows font Arial Black at 20 points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例GXFONT文件，它包含仅使用标准Windows字体Arial Black以20磅绘制的数字字符：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, it's fairly self-explanatory. The comments at the start of the
    file are primarily used by the font builder utility to know what settings were
    used to create the font, so you should leave these values well alone if you want
    to edit the font later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是相当直观的。文件开头的注释主要用于字体构建器实用程序了解创建字体时使用的设置，因此如果您想稍后编辑字体，应保留这些值。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can edit a font in the font builder utility at a later date by using **File**
    | **Load Font** or by pressing the **Load…** button. A file requester will appear
    allowing us to choose the GXFONT file we wish to edit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在字体构建器实用程序中稍后编辑字体，方法是使用**文件** | **加载字体**或按**加载…**按钮。将出现一个文件请求器，允许我们选择要编辑的GXFONT文件。
- en: he part of the GXFONT file we're really interested in is the definition of the
    `CIwGxFont` instance. The three parameters we see here indicate that the character
    encoding to be used with this font should be UTF-8, the bitmap image to use is
    called `numbers.tga`, and the characters present in the font are the numerals
    zero through nine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正感兴趣的GXFONT文件部分是`CIwGxFont`实例的定义。这里我们看到的三项参数表明，与该字体一起使用的字符编码应该是UTF-8，要使用的位图图像称为`numbers.tga`，而字体中包含的字符是从零到九的数字。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, UTF-8 character encoding is chosen, as this format often provides
    the most compact memory representation of text strings, at least as far as European
    languages are concerned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，选择UTF-8字符编码，因为这个格式通常提供了文本字符串最紧凑的内存表示，至少就欧洲语言而言。
- en: If we've specified any other font settings in the font builder utility, such
    as character subranges or kerning information, this will also be represented in
    both the comments at the top of the file and the `CIwGxFont` structure. We won't
    cover this here though, since the font builder takes care of all the hard work
    for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在字体构建器实用程序中指定了任何其他字体设置，例如字符子范围或字距调整信息，这也会在文件顶部的注释和`CIwGxFont`结构中表示。不过，这里我们不会涉及这一点，因为字体构建器会为我们处理所有困难的工作。
- en: Loading and accessing font resources
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和访问字体资源
- en: As with all the resource types we've seen, we load a font resource into our
    program by adding a reference to it into a GROUP file, loading the GROUP file
    using the resource manager, and then searching for the font resource.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们看到的所有资源类型一样，我们通过将对其的引用添加到GROUP文件中，使用资源管理器加载GROUP文件，然后搜索字体资源来将字体资源加载到我们的程序中。
- en: 'For completeness, here is a code snippet showing how to do this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，这里是一个代码片段，展示如何做到这一点：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Drawing text using a font resource
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字体资源绘制文本
- en: With a font resource loaded and a pointer to it obtained, we can start to draw
    some text on screen with it. First we'll look at the basics of drawing a string
    of text, then we'll take a look at how we can justify the text, change its size,
    and how we can make drawing it a little more optimized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加载了字体资源并获取了其指针后，我们可以开始使用它来在屏幕上绘制一些文本。首先，我们将探讨绘制文本字符串的基本方法，然后我们将看看如何对文本进行对齐、更改其大小，以及如何使绘制过程更加优化。
- en: Drawing text on screen
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕上绘制文本
- en: When we were looking at how to create a font resource, it was mentioned that
    a color could be chosen for the font. It is recommended to choose white so we
    can change the color of our text at runtime to any color we want. We change the
    color of the font by modulating the font bitmap with our chosen color, so if the
    font bitmap is not white this will not produce the desired color change.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看如何创建字体资源时，提到可以为字体选择颜色。建议选择白色，这样我们就可以在运行时将文本颜色更改为我们想要的任何颜色。我们通过调制字体位图与所选颜色来更改字体的颜色，因此如果字体位图不是白色，这将不会产生预期的颜色变化。
- en: We'll be seeing how to change the font color in a moment, but in order for font
    coloring to work there is one quirk of IwGxFont that must be mentioned first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到如何更改字体颜色，但为了使字体着色工作，首先必须提到 IwGxFont 的一个特性。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When attempting to recolor a font at runtime, we must ensure that emissive lighting
    is enabled using the function call `IwGxLightingEmissive(true)`. IwGxFont affects
    the color of a font by using the emissive lighting component, which will not be
    applied if it is disabled.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试在运行时重新着色字体时，我们必须确保使用函数调用 `IwGxLightingEmissive(true)` 启用发射光照。IwGxFont 通过使用发射光照组件来影响字体的颜色，如果它被禁用，则不会应用此颜色。
- en: With the note about lighting out of the way, the first step in rendering text
    is to indicate which font we want to use to draw it. This is done by passing a
    pointer to the relevant `CIwGxFont` instance into the function `IwGxFontSetFont`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完关于光照的注意事项后，渲染文本的第一步是指出我们想要使用哪个字体来绘制它。这是通过将相关 `CIwGxFont` 实例的指针传递到函数 `IwGxFontSetFont`
    中来完成的。
- en: Next, we can set the color we want to use with `IwGxFontSetCol`. There are two
    versions of this function, one that takes a reference to a `const CIwColour` instance,
    and another that takes the color value as a uint32 value. When using the latter,
    bear in mind that the color is specified as ABGR—that is, alpha in the most significant
    byte, then blue, green, and red in the least significant byte.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `IwGxFontSetCol` 设置我们想要使用的颜色。这个函数有两个版本，一个接受对 `const CIwColour` 实例的引用，另一个接受颜色值作为
    uint32 值。当使用后者时，请注意颜色是按 ABGR 格式指定的——即，最高有效字节是 alpha，然后是蓝色、绿色和红色在最低有效字节中。
- en: We now need to indicate where on the screen we want the text to appear, which
    we do by defining a rectangular area in which the text should appear. This is
    specified by using a `CIwRect` instance that contains x and y values for the top
    left of the rectangle, plus a width and height value. The function call we use
    is `IwGxFontSetRect`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要指定文本在屏幕上的位置，这通过定义一个矩形区域来完成，其中文本应该出现。这是通过使用包含矩形左上角的 x 和 y 值以及宽度和高度值的 `CIwRect`
    实例来指定的。我们使用的函数调用是 `IwGxFontSetRect`。
- en: Drawing the text is now possible using the `IwGxFontDrawText` function. The
    first parameter is the string of text to print and is specified as a `const CIwChar`
    pointer. `CIwChar` is just a `typedef` type for the standard C `char` type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IwGxFontDrawText` 函数现在可以绘制文本。第一个参数是要打印的文本字符串，指定为一个 `const CIwChar` 指针。`CIwChar`
    只是标准 C `char` 类型的 `typedef` 类型。
- en: The default encoding for text is UTF-8\. For text comprising of characters from
    the ASCII set, this means we don't have to do anything to the text data at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的默认编码为 UTF-8。对于由 ASCII 集合中的字符组成的文本，这意味着我们根本不需要对文本数据进行任何操作。
- en: The function also takes a second parameter, which is the length of the text
    to be drawn. This has a default parameter value of `-1`, which indicates the entire
    string should be drawn. Any other value will draw the specified number of characters.
    This is handy if you want to implement a system common in many games where text
    appears on screen one character at a time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还接受第二个参数，即要绘制的文本的长度。其默认参数值为 `-1`，表示应绘制整个字符串。任何其他值将绘制指定的字符数。如果你想要实现许多游戏中常见的系统，其中文本逐个字符出现在屏幕上，这将非常有用。
- en: 'Putting this all together, here''s an example that draws "Hello World" on the
    screen in yellow:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些结合起来，以下是一个示例，它在屏幕上以黄色绘制“Hello World”：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Text wrapping and justification
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本换行和调整
- en: Wondering why we specified a rectangular area for our text rather than just
    a screen position? The reason is so that IwGxFont can wrap and justify our text
    for us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道为什么我们为文本指定了一个矩形区域而不是仅仅一个屏幕位置吗？原因是这样，IwGxFont 可以为我们自动换行和调整文本。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While Marmalade does allow us to include the line feed character in our code
    to force a new line in our text, it does not provide support for other formatting
    characters such as tabs or backspace. It is far better to allow Marmalade to word
    wrap text for us than to insert line feeds in our text by hand, because if we
    change the font size or the dimension of the rectangular draw area we won't have
    to change the text itself in any way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Marmalade 允许我们在代码中包含换行符以强制在文本中换行，但它不提供对其他格式化字符（如制表符或退格符）的支持。最好让 Marmalade
    自动换行文本，而不是手动在文本中插入换行符，因为如果我们更改字体大小或矩形绘制区域的尺寸，我们就不必以任何方式更改文本本身。
- en: 'The default behavior when rendering text is to word wrap whenever a line of
    text exceeds the bounds of the rectangular area set with `IwGxFontSetRect`. We
    can alter this behavior using the `IwGxFontSetFlags` function, which can take
    a combination of the following values OR''ed together:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染文本时的默认行为是在文本行超出使用 `IwGxFontSetRect` 设置的矩形区域边界时进行换行。我们可以使用 `IwGxFontSetFlags`
    函数来改变这种行为，该函数可以组合以下值进行 OR 操作：
- en: '| Value | Definition |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 定义 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IW_GX_FONT_DEFAULT_F     ` | Uses default font settings. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_DEFAULT_F     ` | 使用默认字体设置。|'
- en: '| `IW_GX_FONT_NOWRAP_F` | Does not wrap text at the edge of the rectangle''s
    boundary. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_NOWRAP_F` | 不在矩形边界的边缘换行。|'
- en: '| `IW_GX_FONT_NOWORDWRAP_F` | Does not perform full word wrapping on text.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_NOWORDWRAP_F` | 不对文本执行完整的单词换行。|'
- en: '| `IW_GX_FONT_ONELINE_F` | Only renders a single line of text. Rendering stops
    when a newline character (`''\n''`) is reached. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ONELINE_F` | 只渲染单行文本。渲染在遇到换行符 (`''\n''`) 时停止。|'
- en: '| `IW_GX_FONT_NUMBER_ALIGN_F` | Forces all numbers to be displayed with the
    same width. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_NUMBER_ALIGN_F` | 强制所有数字以相同的宽度显示。|'
- en: '| `IW_GX_FONT_UNDERLINE_F` | Draws the text with underlining. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_UNDERLINE_F` | 以带下划线的方式绘制文本。|'
- en: '| `IW_GX_FONT_ITALIC_F` | Draws the text in italics. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ITALIC_F` | 以斜体形式绘制文本。|'
- en: '| `IW_GX_FONT_RIGHTTOLEFT_F` | Draws characters from right to left. Useful
    for drawing languages such as Arabic. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_RIGHTTOLEFT_F` | 从右到左绘制字符。对于阿拉伯语等语言很有用。|'
- en: '| `IW_GX_FONT_NOWORDSPLIT_F` | Wraps text at the end of words. A word can overlap
    the end of the rectangle boundary, but the next word will start on the next line.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_NOWORDSPLIT_F` | 在单词末尾换行。一个单词可以跨越矩形边界的末尾，但下一个单词将开始在新的一行上。|'
- en: Flags can be cleared again using `IwGxFontClearFlags`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `IwGxFontClearFlags` 再次清除标志。
- en: 'We can also specify whether text is drawn left aligned, right aligned, or centered
    in the rectangular bounding area using the function `IwGxFontSetAlignmentHor`,
    which takes one of the following values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `IwGxFontSetAlignmentHor` 函数指定文本是否在矩形边界区域内左对齐、右对齐或居中，该函数接受以下值之一：
- en: '| Value | Definition |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 定义 |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IW_GX_FONT_ALIGN_LEFT` | Aligns text to the left of the bounding box. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_LEFT` | 将文本对齐到边界框的左侧。|'
- en: '| `IW_GX_FONT_ALIGN_CENTRE` | Centres text horizontally in the bounding box.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_CENTRE` | 在边界框中水平居中文本。|'
- en: '| `IW_GX_FONT_ALIGN_RIGHT` | Aligns text to the right edge of the bounding
    box. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_RIGHT` | 将文本对齐到边界框的右侧边缘。|'
- en: '| `IW_GX_FONT_ALIGN_PARAGRAPH` | Performs left or right alignment, as defined
    by the device''s localization settings. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_PARAGRAPH` | 根据设备的本地化设置执行左对齐或右对齐。|'
- en: 'We can do similar alignments vertically as well using `IwGxFontSelAlignmentVer`
    with one of these values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `IwGxFontSelAlignmentVer` 和以下这些值之一来进行类似的垂直对齐：
- en: '| Value | Definition |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 定义 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IW_GX_FONT_ALIGN_TOP` | Text is drawn so that the top line of text touches
    the top of the bounding box. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_TOP` | 绘制文本，使文本的顶部行触及边界框的顶部。|'
- en: '| `IW_GX_FONT_ALIGN_MIDDLE` | Text is centered vertically in the bounding box.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_MIDDLE` | 在边界框中垂直居中文本。|'
- en: '| `IW_GX_FONT_ALIGN_BOTTOM` | Text is drawn so the bottom of the last line
    of text touches the bottom of the bounding box. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `IW_GX_FONT_ALIGN_BOTTOM` | 绘制文本，使最后一行的底部触及边界框的底部。|'
- en: Changing font size at runtime
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时更改字体大小
- en: Sometimes it is desirable to be able to animate text by making changes in its
    size. For example, in a shooting game the score awarded for killing an enemy might
    appear at the position of the enemy then gradually grow larger and fade out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望能够通过改变文本大小来使文本动起来。例如，在射击游戏中，击杀敌人所获得的分数可能会出现在敌人的位置，然后逐渐变大并淡出。
- en: The function `IwGxFontSetScale` enables us to do this. It takes two parameters
    so the font can be scaled by different amounts, both horizontally and vertically.
    The scaling factors are passed in as fixed point values, with `IW_GEOM_ONE` indicating
    a scaling factor of `1` and therefore no change in size.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`IwGxFontSetScale`使我们能够做到这一点。它接受两个参数，因此字体可以按不同的量进行缩放，包括水平和垂直。缩放因子以定点值的形式传递，其中`IW_GEOM_ONE`表示缩放因子为`1`，因此不改变大小。
- en: IwGxFont draws text by rendering a rectangular polygon for each character in
    our text, with the relevant part of the font image mapped on to it. By specifying
    a scaling factor we can change the size of the polygons used to render the individual
    characters, though this can yield poor results if we scale up by a large factor
    (for example, more than double the original size of the font).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: IwGxFont通过为文本中的每个字符渲染一个矩形多边形来绘制文本，并将字体图像的相关部分映射到它上面。通过指定缩放因子，我们可以改变用于渲染单个字符的多边形的大小，但如果缩放因子过大（例如，超过字体原始大小的两倍），则可能会得到较差的结果。
- en: Optimizing drawing by preparing text
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过准备文本优化绘制
- en: One of the problems with rendering text is that in order to perform alignment,
    word wrapping, and the like, it is necessary to format the text by considering
    it one character at a time to see if the next character crosses the rectangular
    bounding box area.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文本渲染的一个问题是在进行对齐、换行等操作时，需要逐个字符地格式化文本，以查看下一个字符是否跨越了矩形边界框区域。
- en: If we need to draw a piece of fixed text, such as an instructions screen, we
    can prevent having to calculate the formatting information in every frame by preparing
    the text for rendering once and then using some cached data to draw it from then
    on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要绘制一段固定文本，例如说明屏幕，我们可以通过一次准备文本用于渲染并使用一些缓存数据来绘制它，从而避免在每一帧都计算格式化信息。
- en: To do this we use the function `IwGxFontPrepareText`. This function takes a
    reference to a `CIwGxFontPreparedData` class instance, the string of text to prepare,
    and optionally the number of characters in the string that we want to consider.
    If this parameter is omitted, the entire string is processed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用函数`IwGxFontPrepareText`。这个函数接受一个指向`CIwGxFontPreparedData`类实例的引用，要准备的文本字符串，以及可选地，我们想要考虑的字符串中的字符数。如果省略此参数，则处理整个字符串。
- en: 'With the text prepared we can then draw it using another version of the `IwGxFontDrawText`
    function. This version takes a reference to the `CIwGxFontPreparedData` instance
    and two optional parameters that indicate the first character from the prepared
    data to draw and the number of characters to draw. Here''s a code example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本准备完成后，我们可以使用`IwGxFontDrawText`函数的另一个版本来绘制它。这个版本接受一个指向`CIwGxFontPreparedData`实例的引用，以及两个可选参数，分别指示从准备数据中绘制的第一个字符和要绘制的字符数。以下是一个代码示例：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the text will be drawn on screen at the position indicated by the
    formatting rectangle set in the call to `IwGxFontSetRect`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文本将在屏幕上绘制在`IwGxFontSetRect`调用中设置的格式化矩形所指示的位置。
- en: Implementing user interfaces
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用户界面
- en: Every game will need some kind of user interface, even if it is just a button
    that can be pressed to start a new game. In this section we will take a look at
    how a user interface can be implemented for your own game.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都需要某种类型用户界面，即使只是一个可以按下以开始新游戏的按钮。在本节中，我们将探讨如何为您的游戏实现用户界面。
- en: The IwUI API
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IwUI API
- en: The Marmalade SDK ships with an API called IwUI, which allows us to create user
    interfaces for our projects consisting of buttons, labels, and other common controls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK附带了一个名为IwUI的API，它允许我们为我们的项目创建由按钮、标签和其他常见控件组成用户界面。
- en: This API is very feature-rich and allows interfaces to be created not just for
    games, but also for more serious applications. Marmalade used to ship with a tool
    called the Marmalade Studio UI Builder, but this is sadly no longer a supported
    part of the SDK. However, it is still possible to access this tool by either installing
    an older version of Marmalade (one of the v5.2.x releases is probably best) or
    by downloading its source code from [https://github.com/marmalade/UI-Builder](https://github.com/marmalade/UI-Builder).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此API功能丰富，不仅允许创建游戏界面，还可以为更严肃的应用程序创建界面。Marmalade曾经附带一个名为Marmalade Studio UI Builder的工具，但遗憾的是，这不再是SDK支持的一部分。然而，仍然可以通过安装Marmalade的旧版本（v5.2.x系列中的一个版本可能最好）或从[https://github.com/marmalade/UI-Builder](https://github.com/marmalade/UI-Builder)下载其源代码来访问此工具。
- en: It is also possible to use IwUI without using the UI creation tool by constructing
    ITX files that describe our interface layouts, by hand. These layout files can
    end up being quite verbose and therefore hard to maintain, so the Marmalade Studio
    UI Builder made editing layouts a bit more manageable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在不使用UI创建工具的情况下使用IwUI，通过手动构建描述我们界面布局的ITX文件来实现。这些布局文件可能会变得相当冗长，因此难以维护，所以Marmalade
    Studio UI Builder使得编辑布局变得更加容易管理。
- en: The Marmalade documentation states that the reason for dropping the UI Builder
    from the SDK was to allow a standardized UI markup system to be used that is supported
    by a number of other third party tools. At the time of writing this book, no further
    announcement had been made regarding exactly what form this will take.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade文档中提到，从SDK中删除UI Builder的原因是为了允许使用一个标准化的UI标记系统，该系统被许多其他第三方工具支持。在撰写本书时，尚未就这一形式的具体内容做出进一步公告。
- en: There seems no doubt that the IwUI API will remain a part of Marmalade for the
    foreseeable future. However, we won't be delving any deeper into the API itself
    in this book as it seems likely that a new UI system will be making its way into
    Marmalade soon. If you are interested in what IwUI can do, take a look at the
    Marmalade documentation and the plethora of sample code that ships with the SDK.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，IwUI API将在可预见的未来仍然是Marmalade的一部分。然而，我们不会在本书中深入探讨API本身，因为它似乎很可能很快会有一个新的UI系统加入Marmalade。如果您对IwUI能做什么感兴趣，请查看Marmalade文档和随SDK提供的众多示例代码。
- en: The IwNUI API
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IwNUI API
- en: Marmalade provides a second user interface API called IwNUI. The "N" stands
    for Native, as this API allows you to construct user interfaces using the standard
    UI controls for the platform that your application runs on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade提供了一个名为IwNUI的第二个用户界面API。"N"代表Native，因为这个API允许您使用应用程序运行的平台的标准UI控件来构建用户界面。
- en: This may sound like a good idea but the main drawback is that it is only supported
    on iOS and Android. All other platforms will use a default style implemented using
    the previously mentioned IwUI API.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个好主意，但主要的缺点是它只支持iOS和Android。所有其他平台将使用使用之前提到的IwUI API实现的默认样式。
- en: At any rate most games tend to implement their own UI that is in keeping with
    the style of the game, and this normally means we don't want to use standard OS
    user interface controls, but IwNUI is a good choice if you happen to want to develop
    a utility or other application type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，大多数游戏倾向于实现符合游戏风格的UI，这通常意味着我们不想使用标准的操作系统用户界面控件，但如果您想开发实用程序或其他应用程序类型，IwNUI是一个不错的选择。
- en: Implementing our own user interface solution
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们自己的用户界面解决方案
- en: Given that we're effectively starting from square one with our user interface
    implementation, let's consider how we could go about creating our own solution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在用户界面实现上实际上是从零开始的，让我们考虑一下我们如何创建自己的解决方案。
- en: The following sections highlight some of the issues to be aware of when developing
    user interface code. One of the example projects accompanying this chapter implements
    a user interface library that tries to take most of the following into account.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分强调了在开发用户界面代码时需要注意的一些问题。本章附带的示例项目实现了一个用户界面库，试图考虑以下大部分内容。
- en: Using a generic approach
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用方法
- en: It really is worth taking the time to develop as generic a solution as possible
    when dealing with user interface code. While implementing the frontend of a game
    isn't particularly difficult to code, it is far too easy to find yourself writing
    UI code from scratch for each project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理用户界面代码时，真正值得花时间开发尽可能通用的解决方案。虽然实现游戏的界面前端在编码上并不特别困难，但很容易发现自己为每个项目从头开始编写UI代码。
- en: By investing in a generic approach, you can quickly put together a functional
    UI for all your projects. Frontend menu systems actually tend to be little more
    than a collection of buttons and labels; so why write this code multiple times?
    Implement these types of controls once and you can then spend more time creating
    customized controls when your game demands it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过投资于一种通用方法，你可以快速为所有项目构建一个功能性的UI。前端菜单系统实际上往往只是一个按钮和标签的集合；那么为什么需要多次编写这段代码呢？实现这些类型的控件一次，然后当你需要为游戏创建定制控件时，你可以有更多的时间来创建。
- en: It is recommended that you implement your UI code by creating a separate subproject,
    as this will help ensure that your solution is as generic and self-contained as
    possible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你通过创建一个单独的子项目来实现你的UI代码，因为这将有助于确保你的解决方案尽可能通用和自包含。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Marmalade makes it easy for us to create our own library modules by using the
    same system the SDK uses for including its component parts. Simply create an MKB
    file referencing all the source files that are part of the library, but save it
    with the extension `.mkf` instead of `.mkb`. You can then reference this module
    by adding the name of the MKF file (minus the extension) to the `subprojects`
    section of the main project MKB file. Library module directories should be placed
    in the same place as the main project directory so that they can be located when
    creating the project from the MKB file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade使我们能够通过使用SDK用于包含其组件部分的相同系统来轻松创建自己的库模块。只需创建一个包含库中所有源文件的MKB文件，但保存时使用`.mkf`扩展名而不是`.mkb`。然后，你可以通过将MKF文件的名称（不包括扩展名）添加到主项目MKB文件的`subprojects`部分来引用此模块。库模块目录应放置在与主项目目录相同的位置，以便在从MKB文件创建项目时可以找到它们。
- en: Making good use of class inheritance
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 充分利用类继承
- en: A good class hierarchy can make implementing your UI a much more pleasant experience
    and it is well worth taking a look at existing systems to see how they have been
    constructed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的类层次结构可以使实现你的UI体验变得更加愉快，并且查看现有系统是如何构建的非常值得。
- en: Most modern UI implementations will normally start with a base level class from
    which all other control types are derived, which for discussion purposes in this
    chapter we will call an **element**. An element will take care of things such
    as the positioning of a control and internal naming so that the handling of UI
    events can be standardized.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代UI实现通常从基类开始，所有其他控件类型都由此派生，在本章的讨论中，我们将称之为**元素**。元素将负责诸如控件定位和内部命名等问题，以便可以标准化UI事件的处理。
- en: When implementing a class representing an element, we should make use of virtual
    methods that can be overridden by child classes to change default behavior. At
    the very least this normally means that we should have methods that can be called
    to update and render the control.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现代表元素的类时，我们应该利用虚拟方法，这些方法可以被子类覆盖以改变默认行为。至少这通常意味着我们应该有可以调用的方法来更新和渲染控件。
- en: Another extremely useful concept is that of a **frame**, which has the ability
    to group several elements together so they can be moved, enabled, or hidden at
    the same time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的概念是**框架**，它能够将多个元素组合在一起，以便可以同时移动、启用或隐藏它们。
- en: When updating or rendering the user interface, the frame is responsible for
    deciding whether or not to update or render the child elements it contains.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新或渲染用户界面时，框架负责决定是否更新或渲染其包含的子元素。
- en: The positioning and sizing of all elements contained within a frame should also
    be calculated relative to the position and size of the frame itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 框架内所有元素的定位和大小也应相对于框架本身的定位和大小来计算。
- en: 'Having implemented classes representing both elements and frames, it is possible
    to implement most common UI controls very simply. Here are a few examples to illustrate
    this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了代表元素和框架的类之后，可以非常简单地实现大多数常见的UI控件。以下是一些示例来说明这一点：
- en: A **label** control simply displays a line of text on screen. It can be derived
    from the element class and at its simplest all we need to define are member variables
    to store the text to be drawn, and some font and color information. We can then
    override the virtual render method to allow the text to be drawn at the position
    indicated by the element class.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**控件简单地显示屏幕上的文本行。它可以派生自元素类，在其最简单的情况下，我们只需要定义存储要绘制的文本的成员变量，以及一些字体和颜色信息。然后我们可以重写虚拟渲染方法，以便在元素类指示的位置绘制文本。'
- en: A **bitmap** control is very similar to a label but displays an image instead
    of text. We just need to store a pointer to the image we want to draw (perhaps
    as a `CIwTexture` or `CIwMaterial` pointer) and then implement the render method
    to draw it on screen.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位图**控件与标签非常相似，但显示的是图像而不是文本。我们只需要存储指向我们想要绘制的图像的指针（可能是一个 `CIwTexture` 或 `CIwMaterial`
    指针），然后实现渲染方法来在屏幕上绘制它。'
- en: A **button** control can be derived from a frame. Most UI systems allow an image
    or a text string (or both) to be displayed on the button, so we can implement
    this just by adding label or bitmap controls to the list of elements contained
    within the frame.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**控件可以派生自框架。大多数 UI 系统允许在按钮上显示图像或文本字符串（或两者），因此我们可以通过将标签或位图控件添加到框架内包含的元素列表中来实现这一点。'
- en: A **slider** control could also use the frame as a basis and could include two
    bitmap controls, one for the backing of the slider and another for the selection
    knob. A label could also be included if you want to display the current position
    of the slider as a numeric value.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑块**控件也可以以框架为基础，并可以包括两个位图控件，一个用于滑块的背景，另一个用于选择旋钮。如果你想要显示滑块的当前位置作为数值，也可以包括一个标签。'
- en: Hopefully this gives you an idea of how, with a little initial planning, implementing
    a diverse range of user interface controls actually becomes very easy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能给你一个想法，即通过一点初步规划，实现各种用户界面控件实际上变得非常容易。
- en: Implementing a data-driven system
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现数据驱动系统
- en: With a good class hierarchy in place, the next step is to ensure that your UI
    can be created easily from a configuration datafile. While it is perfectly possible
    to create all your controls in code, this is hard to maintain and, most crucially,
    can then only be edited by a programmer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的类层次结构到位之后，下一步是确保你的 UI 可以轻松地从配置数据文件中创建。虽然完全有可能在代码中创建所有控件，但这很难维护，最重要的是，这只能由程序员编辑。
- en: Allowing your UI to be constructed from a datafile means that other members
    of your team can help with designing the UI. Having a datafile format also makes
    it easier to develop a user interface layout tool if you want to make the process
    even easier for people to use.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你的 UI 从数据文件中构建意味着你的团队的其他成员可以帮助设计 UI。拥有数据文件格式也使得开发用户界面布局工具变得更加容易，如果你想让这个过程对人们来说更容易使用的话。
- en: We've already seen how we can use the ITX file format to construct our own custom
    classes from a file at runtime, so it makes sense to employ this methodology to
    our UI code (refer back to [Chapter 2](ch02.html "Chapter 2. Resource Management
    and 2D Graphics Rendering"), *Resource Management and 2D Graphics Rendering*,
    if you want to refresh your memory on this). No point in writing more code than
    we have to!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 ITX 文件格式在运行时从文件中构建我们自己的自定义类，因此将这种方法应用于我们的 UI 代码是有意义的（如果你想要刷新对这个问题的记忆，请回顾[第
    2 章](ch02.html "第 2 章。资源管理和 2D 图形渲染")，*资源管理和 2D 图形渲染*）。没有必要编写比必需的更多代码！
- en: Responding to user input events
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应用户输入事件
- en: The user interface of a game must solve two main issues. The first is relaying
    information to the player, and we've already discussed how this can be done earlier.
    The second is responding to user inputs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的用户界面必须解决两个主要问题。第一个是向玩家传达信息，我们已经在前面讨论了如何做到这一点。第二个是响应用户输入。
- en: As discussed earlier in this book, modern mobile devices allow a great many
    ways of allowing the player to interact with a game. Which of these you support,
    depends on the devices you are trying to target, but by far the most popular choice
    is the touch screen. Pressing on-screen buttons is just a very natural way of
    interacting with a application, so it is pretty much guaranteed you will end up
    supporting touch screens for your own UI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书前面所讨论的，现代移动设备提供了许多让玩家与游戏互动的方式。你支持哪一种取决于你试图针对的设备，但最流行的选择无疑是触摸屏。按下屏幕按钮只是与应用程序互动的一种非常自然的方式，所以几乎可以肯定你最终会支持你的
    UI 中的触摸屏。
- en: Obviously not all controls need to respond to being touched. For example, a
    label is unlikely to do anything, so it makes sense to provide some mechanism
    that allows us to indicate which controls should respond to touches and which
    shouldn't.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非所有控件都需要响应触摸。例如，标签不太可能执行任何操作，因此提供一种机制来指示哪些控件应该响应触摸，哪些不应该是有意义的。
- en: While we could just add some virtual methods to the element class that gets
    called whenever a touch has been detected within its bounding area, this is probably
    not the best solution as it starts to make the element class a little cluttered.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在检测到元素类边界区域内触摸时被调用的元素类中添加一些虚拟方法，但这可能不是最好的解决方案，因为它开始使元素类变得有些杂乱。
- en: We really want to encapsulate this sort of functionality somehow, and a good
    way of doing this is by using an Event system. Such a system works by having a
    central event manager whose sole job is to receive event messages from one part
    of the code and pass those messages on to any class instance that has registered
    itself with the event manager to be notified of a particular event.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的希望以某种方式封装这种功能，一个好的方法是通过使用事件系统。这样一个系统通过拥有一个中心事件管理器来实现，其唯一任务是接收来自代码一部分的事件消息，并将这些消息传递给任何已向事件管理器注册自身以通知特定事件的类实例。
- en: To implement such a system, we can introduce two new base classes. An Event
    class, which is the base class for all event message types, and an `EventHandler`
    class, which contains a single virtual method called `Execute` that will be called
    in order to respond to an Event.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样一个系统，我们可以引入两个新的基类。一个事件类，它是所有事件消息类型的基类，以及一个`EventHandler`类，它包含一个名为`Execute`的单个虚拟方法，该方法将被调用来响应事件。
- en: At its most basic level, the Event class will just contain a single member that
    is used as a unique identifier for a particular type of event, for example, an
    enumerated type. We can declare our own event types by deriving them from an Event
    and adding members for any information we might want to pass along with the message.
    For example, a touch screen event might contain the screen coordinates of where
    the touch occurred.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，事件类将只包含一个成员，用作特定类型事件的唯一标识符，例如，枚举类型。我们可以通过从事件派生它们并添加任何我们可能想要与消息一起传递的信息的成员来声明我们自己的事件类型。例如，触摸屏事件可能包含触摸发生的屏幕坐标。
- en: Any class that wants to respond to a particular event can then derive from the
    `EventHandler` class and provide an implementation for the virtual method. When
    a new instance of a class is constructed, it registers its interest in any event
    by passing the unique identifier of the event and a pointer to itself (cast as
    an `EventHandler` pointer) to the event handler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 任何想要响应特定事件的类都可以从`EventHandler`类派生，并为虚拟方法提供一个实现。当创建一个类的新的实例时，它会通过传递事件的唯一标识符和指向自身（转换为`EventHandler`指针）的指针到事件处理器来注册对任何事件的兴趣。
- en: Now, whenever an event occurs we create an instance of the event type in question,
    populate its members with information about that event, and pass it to the event
    manager. The event manager will compare the unique identifier of the event against
    its list of registered instances and then call the `Execute` method of `EventHandler`
    for any of registered instance that wanted to be notified about the type of event
    that has just occurred. The event message will be passed into the `Execute` method
    of the instance so that its data can then be acted upon accordingly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当发生事件时，我们都会创建一个相关事件类型的实例，用关于该事件的信息填充其成员，并将其传递给事件管理器。事件管理器会将事件的唯一标识符与其已注册实例列表进行比较，然后调用任何已注册实例的`EventHandler`的`Execute`方法，这些实例希望被通知刚刚发生的事件类型。事件消息将被传递到实例的`Execute`方法中，以便其数据可以相应地被处理。
- en: Screen resolution and orientation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕分辨率和方向
- en: Chances are that your game could well be executed on a number of different devices
    that have different screen resolutions and aspect ratios, which can make creating
    a nice looking user interface a real chore.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你的游戏会在具有不同屏幕分辨率和宽高比的多个不同设备上运行，这可能会使得创建一个看起来不错的用户界面变得非常繁琐。
- en: It is therefore important to provide a very flexible way in which the position
    and size of UI controls can be specified.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提供一种非常灵活的方式来指定UI控件的位置和大小是非常重要的。
- en: When specifying screen coordinates, widths, and heights for controls, consider
    allowing both exact pixel sizes and ratios of the width and height of the containing
    frame to be used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定控件屏幕坐标、宽度和高度时，考虑允许使用精确的像素大小以及包含框架宽度和高度的比率。
- en: It is also good to allow a control to be conformed to a particular aspect ratio
    when using ratios to define sizes. Being able to ensure that the control has a
    particular aspect ratio makes it much easier to keep a consistent layout of any
    child control and is particularly important when drawing bitmapped images that
    will look strange if they end up stretched. When fixing a control to a particular
    aspect ratio, you will want to be able to indicate whether the width or the height
    should change to keep the control in the correct shape.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用比率定义大小时，允许控件适应特定的宽高比也是一个很好的做法。能够确保控件具有特定的宽高比使得保持任何子控件的统一布局变得容易得多，这在绘制最终会显得拉伸的位图图像时尤为重要。当将控件固定到特定的宽高比时，您将希望能够指示是宽度还是高度应该改变以保持控件的正确形状。
- en: Being able to lay out controls relative to each other is also a useful thing
    to be able to do. One way of doing this is by specifying that a control should
    take in its position by adding an offset to the position of another control.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 能够相对彼此布局控件也是一个非常有用的能力。实现这一目标的一种方法是通过指定一个控件应该通过向另一个控件的位置添加偏移量来获取其位置。
- en: Another thing that can throw a spanner in the works is when the user rotates
    the device and the screen changes between portrait and landscape orientations.
    For most games we will want screen orientation changes to be ignored, since most
    games are designed to either be played in portrait or landscape and not both.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户旋转设备且屏幕在纵向和横幅模式之间切换时，这可能会打乱工作流程。对于大多数游戏，我们希望忽略屏幕方向的变化，因为大多数游戏设计为在纵向或横幅模式下进行，而不是两者都进行。
- en: 'Ignoring screen orientation changes is made simple by adding the `DispFixRot`
    setting to the application''s ICF file, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`DispFixRot`设置添加到应用程序的ICF文件中，可以简单地忽略屏幕方向的变化，如下所示：
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This setting can take the following values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置可以采用以下值：
- en: '| Value | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Free` | Screen will rotate when the user rotates the device. This is the
    default value if `DispFixRot` is not used. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `Free` | 当用户旋转设备时，屏幕将旋转。如果未使用`DispFixRot`，则这是默认值。 |'
- en: '| `Portrait` | Screen will always be kept in portrait aspect but can rotate
    when the device is held in either of the possible portrait orientations. It is
    easy to miss the fact that there are two possible portrait orientations since
    the phone could be held upside down! |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `Portrait` | 屏幕将始终保持在纵向模式，但可以在设备以任何可能的纵向方向持有时旋转。由于手机可以倒置持有，因此很容易忽略存在两种可能的纵向方向这一事实！
    |'
- en: '| `Landscape` | Screen will always be kept in landscape aspect but can rotate
    when the device is held in either of the possible landscape orientations. Again,
    note that there are two possible landscape orientations depending on which direction
    you rotate the phone from its normal portrait position. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Landscape` | 屏幕将始终保持在横幅模式，但可以在设备以任何可能的横幅方向持有时旋转。再次提醒，根据您从正常纵向位置旋转手机的方向，存在两种可能的横幅方向。
    |'
- en: '| `FixedPortrait` | Screen will be fixed in the device''s default portrait
    orientation and will not rotate at all. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `FixedPortrait` | 屏幕将固定在设备的默认纵向方向，并且不会旋转。 |'
- en: '| `FixedLandscape` | Screen will be fixed in the device''s default landscape
    orientation and will not rotate at all. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `FixedLandscape` | 屏幕将固定在设备的默认横幅方向，并且不会旋转。 |'
- en: 'If we do choose to support screen orientation changes, we need some way of
    detecting when the orientation has changed. We can do this by setting up a callback
    function as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择支持屏幕方向的变化，我们需要一种方法来检测方向是否已更改。我们可以通过设置以下回调函数来实现：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is highly recommended, if you are supporting both portrait and landscape
    in your game, that you define specific layouts of your controls for each orientation
    and switch between them when the device is rotated. Trying to accommodate both
    orientations with a single layout is possible but tends to yield uninspiring results
    in both orientations, so make the most of the available screen space by providing
    custom layouts for each.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你支持你的游戏中的纵向和横向模式，强烈建议你为每个方向定义你控件的具体布局，并在设备旋转时在这些布局之间切换。尝试用一个布局来适应两种方向是可能的，但往往在两种方向上都会产生令人失望的结果，所以通过为每个方向提供自定义布局，最大限度地利用可用的屏幕空间。
- en: Adding template functionality
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板功能
- en: Consistency is an important part of the user interface design. We expect controls
    of a similar type to look the same. If they don't, the design starts to look sloppy
    and unprofessional. It's therefore useful to be able to provide a way of defining
    certain aspects of our UI once, and **Template** definitions allow us to do just
    that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是用户界面设计的重要组成部分。我们期望类似类型的控件看起来相同。如果它们看起来不一样，设计就会开始显得杂乱无章，不够专业。因此，能够提供一种方法来一次性定义我们UI的某些方面是非常有用的，**模板**定义正允许我们做到这一点。
- en: A relatively easy way of implementing templates is to be able to copy the settings
    of one UI control into another. We can create a control that will never actually
    be displayed, but will act as a template for other controls. When creating a new
    control we can copy all member settings from the template and then proceed to
    make changes to the settings so that the control displays whatever we need it
    to.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实现模板的一个相对简单的方法是将一个UI控件设置复制到另一个控件。我们可以创建一个实际上永远不会显示的控件，但会作为其他控件的模板。在创建新控件时，我们可以从模板复制所有成员设置，然后继续修改设置，以便控件显示我们需要的任何内容。
- en: One way of implementing this is to add a virtual method to the element class,
    which is given a pointer to the template control. Each class can override this
    method to set its member variables based on the values contained in the template.
    By calling the virtual method in the parent class, we can copy all member variable
    settings from the template right down to the base element class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是在元素类中添加一个虚拟方法，该方法提供了一个指向模板控件的指针。每个类都可以覆盖此方法，根据模板中包含的值设置其成员变量。通过在父类中调用虚拟方法，我们可以从模板复制所有成员变量设置，直到基元素类。
- en: Localizing your project
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化你的项目
- en: As the progress of technology marches on, the world seems to become a smaller
    place and your game may well end up being played on devices all across the globe.
    It's therefore well worth considering localizing your game so that players across
    the world can experience your game in their own language.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步，世界似乎变得越来越小，你的游戏可能会在全球各地的设备上被玩。因此，考虑本地化你的游戏，以便全球玩家都能用他们自己的语言体验你的游戏，是非常值得的。
- en: While supporting every language known to man would be impractical, many best-selling
    games now offer support for at least the **EFIGS** languages (English, French,
    Italian, German, and Spanish), and you can often add Portuguese, Russian, Polish,
    Japanese, Korean, and both Simplified and Traditional Chinese to the list as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然支持所有已知语言是不切实际的，但现在许多畅销游戏至少提供了对**EFIGS**语言（英语、法语、意大利语、德语和西班牙语）的支持，你通常还可以将葡萄牙语、俄语、波兰语、日语、韩语以及简体中文和繁体中文添加到列表中。
- en: Supporting other languages other than your own native tongue is well worth it,
    as players would much rather play a game they can read and understand than one
    they can't.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 支持除你自己的母语之外的其他语言是非常值得的，因为玩家更愿意玩他们能阅读和理解的游戏，而不是那些他们无法理解的游戏。
- en: Whether or not you decide to support other languages, there is still a benefit
    in implementing your game's text in the manner I am about to describe, since it
    allows you to remove all the text from your source code and put it all in one
    place, which makes changing the text a much easier process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否决定支持其他语言，按照我即将描述的方式实现你的游戏文本仍然有好处，因为它允许你将所有文本从源代码中移除并集中在一个地方，这使得更改文本变得容易得多。
- en: Creating a text spreadsheet
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文本电子表格
- en: 'The first step in localizing the text in your game is to use a program such
    as Microsoft Excel or OpenOffice Calc to create a spreadsheet containing all the
    text for your game. By using a spreadsheet it is very easy to add or insert new
    strings of text, and the columns of the spreadsheet can be used to provide translations
    of the strings for each language you want to support. The following screenshot
    shows an example of such a spreadsheet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的游戏中本地化文本的第一步是使用像Microsoft Excel或OpenOffice Calc这样的程序创建一个包含所有游戏文本的电子表格。通过使用电子表格，很容易添加或插入新的文本字符串，并且电子表格的列可以用来为要支持的语言提供字符串的翻译。以下截图显示了这样一个电子表格的示例：
- en: '![Creating a text spreadsheet](img/3363_06_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![创建文本电子表格](img/3363_06_02.jpg)'
- en: In this spreadsheet the first column is used as a text identifier field. This
    is just a string of text that we can use in our source code and datafiles to represent
    a particular string of text.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个电子表格中，第一列用作文本标识字段。这只是一个字符串，我们可以在源代码和数据文件中使用它来表示特定的文本字符串。
- en: The first row is used to indicate which language each column of the spreadsheet
    represents. In the example, we have used the standard two letter ISO country codes
    to represent the supported languages, namely English (EN) and French (FR).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行用于指示电子表格中每一列代表的语言。在示例中，我们使用了标准的两位字母ISO国家代码来表示支持的语言，即英语（EN）和法语（FR）。
- en: The rest of the spreadsheet is then just the actual text that we want to appear
    in the game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格的其余部分就是我们要在游戏中显示的实际文本。
- en: Getting the text into the game
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文本放入游戏
- en: With the text for our game now in a spreadsheet, how do we access it from inside
    our game code? The answer is to process the spreadsheet into a format that is
    easy for us to load and use in game code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将游戏文本放入电子表格中，如何在游戏代码中访问它？答案是处理电子表格，使其格式易于我们加载并在游戏代码中使用。
- en: Comma-separated values files
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逗号分隔值文件
- en: One option would be to export the text as a **Comma-Separated Values** (**CSV**)
    file from our spreadsheet program. This is a simple text-only format that outputs
    each row of the database as a separate line in the file, with the contents of
    each cell listed separated by commas.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将文本作为**逗号分隔值**（**CSV**）文件从我们的电子表格程序中导出。这是一个简单的纯文本格式，将数据库的每一行输出为文件中的单独一行，每个单元格的内容由逗号分隔。
- en: The trouble with this approach is it can be error-prone. Having a comma in the
    text of one of your strings can play havoc with the output since the comma is
    already used to indicate the end of one string and the beginning of the next.
    This is often gotten around by enclosing each string in quote marks, but then
    this can cause further problems if a string needs to include a quote mark too!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的麻烦在于它可能会出错。如果您的字符串文本中有一个逗号，可能会对输出造成混乱，因为逗号已经被用来表示一个字符串的结束和下一个字符串的开始。通常通过在每个字符串周围加上引号来解决这个问题，但如果字符串本身需要包含引号，这可能会引起更多问题！
- en: Remember also that IwGxFont expects text to be supplied in UTF-8 format by default.
    If you are supporting languages such as Japanese or Korean, this becomes very
    important and some spreadsheet programs do not support exporting a CSV File in
    UTF-8 format.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，IwGxFont默认期望以UTF-8格式提供文本。如果您支持像日语或韩语这样的语言，这变得非常重要，并且一些电子表格程序不支持以UTF-8格式导出CSV文件。
- en: Processing using a Python script
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python脚本处理
- en: A much better method of getting the text out of a spreadsheet and into our game
    is to process the spreadsheet into a simple datafile, which can be easily loaded
    into our game. To demonstrate this, we'll be making use of the Python scripting
    language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从电子表格中提取文本并将其放入我们的游戏中的更好方法是将其处理成简单的数据文件，这样就可以轻松地将其加载到我们的游戏中。为了演示这一点，我们将使用Python脚本语言。
- en: Python may have a rather strange approach to code layout (the scoping level
    of your code is indicated by how much it is indented, rather than using notation
    such as curly braces to indicate the start and end of a section of code), but
    there is no denying that it is extremely good at this kind of task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python可能对代码布局有相当奇怪的方法（您的代码的作用域级别是通过缩进来表示的，而不是使用大括号等符号来表示代码段的开始和结束），但不可否认的是，它在处理这类任务方面非常出色。
- en: 'You can get hold of an installer for Python from the following URL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下URL获取Python的安装程序：
- en: '[http://www.python.org/download/](http://www.python.org/download/)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.python.org/download/](http://www.python.org/download/)'
- en: 'The approach we will be using is to access the data from the text spreadsheet
    by accessing it directly. If we save the spreadsheet in Excel 97 format (file
    extension `.xls`, supported by most spreadsheet programs), there is an excellent
    Python library called `xlrd` that can be downloaded here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用直接访问文本电子表格中的数据的方法。如果我们以Excel 97格式（文件扩展名`.xls`，大多数电子表格程序都支持）保存电子表格，那么有一个名为`xlrd`的优秀的Python库可以在此处下载：
- en: '[http://pypi.python.org/pypi/xlrd/](http://pypi.python.org/pypi/xlrd/)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://pypi.python.org/pypi/xlrd/](http://pypi.python.org/pypi/xlrd/)'
- en: Install Python first and then install the `xlrd` library. It's a good idea to
    ensure that the Python executable can be easily found by adding the Python install
    directory to your path environment variable. An easy way to check if the Python
    directory is already in your path variable is to open up a command prompt window
    and enter `path` to display the current list of directories that will be searched.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装Python，然后安装`xlrd`库。确保Python可执行文件可以被轻松找到是一个好主意，可以将Python安装目录添加到你的路径环境变量中。检查Python目录是否已经在你的路径变量中的一种简单方法是打开一个命令提示符窗口，并输入`path`来显示当前将被搜索的目录列表。
- en: 'To illustrate just how simple accessing data from a spreadsheet file is, using
    Python and xlrd, the following script will open a spreadsheet file and output
    all the rows and columns it contains:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用Python和xlrd从电子表格文件中访问数据是多么简单，以下脚本将打开一个电子表格文件并输出它包含的所有行和列：
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even if you've never set eyes on a Python script before, this should be fairly
    easy to follow, but here's a brief explanation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你以前从未见过Python脚本，这也应该相当容易理解，但这里有一个简要的解释。
- en: The `import xlrd` line is equivalent to the `#include` directive in C/C++. It's
    just stating that we want to make use of the `xlrd` library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`import xlrd`行与C/C++中的`#include`指令等效。它只是声明我们想要使用`xlrd`库。'
- en: Next we open the spreadsheet file by calling the `xlrd.open_workbook` method,
    passing in the filename of the spreadsheet we want to use. This returns an instance
    of a Python class defined by `xlrd` that represents the spreadsheet file. Note
    that Python is a loosely typed language and there is no need to declare what type
    the variable must be.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`xlrd.open_workbook`方法打开电子表格文件，传递我们想要使用的电子表格的文件名。这返回一个由`xlrd`定义的Python类的实例，代表电子表格文件。请注意，Python是一种弱类型语言，不需要声明变量的类型。
- en: We call the `sheet_by_index` method on the spreadsheet object to retrieve the
    first worksheet from the spreadsheet. This yields another Python object representing
    the worksheet.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在电子表格对象上调用`sheet_by_index`方法来检索电子表格的第一个工作表。这会产生另一个代表工作表的Python对象。
- en: We then enter a `for` loop that causes the `lRow` variable to iterate between
    `0` and the number of populated rows in the spreadsheet. Within the loop we use
    the worksheet object to access the spreadsheet cells an entire row at a time using
    the `row_values` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入一个`for`循环，使`lRow`变量在`0`和电子表格中填充的行数之间迭代。在循环中，我们使用工作表对象通过`row_values`方法一次访问整个行的电子表格单元格。
- en: Python has a built-in list type and this is what is being used to access all
    the cells on the row in one go. The `lCells` variable will contain a list whose
    elements are each cell in the row.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内置的列表类型，这就是我们用来一次性访问行上所有单元格的原因。`lCells`变量将包含一个列表，其元素是行中的每个单元格。
- en: Finally we use the Python `print` command to display the entire list to standard
    output. You can use `print` in Python to display just about any type, including
    lists, in a human-readable form.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Python的`print`命令将整个列表显示到标准输出。在Python中，你可以使用`print`来显示几乎任何类型，包括列表，并以人类可读的形式显示。
- en: The UI example project that accompanies this chapter includes a Python script
    that will take a spreadsheet as input and convert it into a simple datafile for
    each language contained in the spreadsheet.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随本章的UI示例项目包括一个Python脚本，该脚本将接受电子表格作为输入，并将其转换为电子表格中包含的每种语言的简单数据文件。
- en: The datafiles list the number of strings in the file followed by a hash value
    generated from the text identifier field (the first column of the spreadsheet)
    and the string itself. It is fairly trivial to write C++ code to load this file
    into memory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件列出了文件中的字符串数量，接着是文本标识符字段（电子表格的第一列）生成的哈希值以及字符串本身。编写C++代码将此文件加载到内存中相当简单。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of a hashing function here means it is possible for two strings to end
    up with the same hash value, causing a collision in the string table that means
    the wrong string may get returned. In practice a good hashing function will mean
    this hardly ever happens, but if you start getting the wrong string returned this
    might be the cause. The easiest way to rectify such a problem is just to rename
    one of the text identifiers in the collision!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用哈希函数意味着两个字符串可能最终得到相同的哈希值，导致字符串表中发生冲突，这意味着可能会返回错误的字符串。在实践中，一个好的哈希函数意味着这种情况几乎不会发生，但如果开始返回错误的字符串，这可能是原因之一。纠正这种问题的最简单方法就是只是重命名冲突中的一个文本标识符！
- en: To access a particular text string, we use the identifier field in our code.
    A hash value is generated from the identifier field and the list of string data
    is searched for that hash value. If a match is found, the corresponding text string
    is returned, otherwise an assert can be raised and a default string of text returned.
    The default text can be something like "Missing String!", which makes it easier
    to track down problems such as getting the identifier field wrong in code, or
    the string just not being present in the text datafile when it should be.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问特定的文本字符串，我们在代码中使用标识符字段。从标识符字段生成一个哈希值，然后在字符串数据列表中搜索该哈希值。如果找到匹配项，则返回相应的文本字符串；否则，可以引发断言并返回默认的文本字符串。默认文本可以是“缺失字符串！”这样的内容，这使得追踪诸如在代码中标识符字段错误或字符串在文本数据文件中应该存在却不存在等问题变得更容易。
- en: Selecting the correct language to use at runtime
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择运行时使用的正确语言
- en: We now have the ability to supply our game with strings of text in multiple
    languages, but how do we decide which of those languages to actually use? One
    method of course is to implement a language select screen during startup of our
    game and then load the relevant string table depending on the user's input. However,
    there is a much nicer way available to us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力为我们的游戏提供多种语言的文本字符串，但我们如何决定实际使用哪种语言呢？一种方法当然是在我们游戏的启动期间实现一个语言选择屏幕，然后根据用户的输入加载相关的字符串表。然而，我们还有更好的方法可用。
- en: 'The s3eDevice API allows us to find out which language is currently in use
    on the device we are running on. Simply insert the following line of code during
    the startup portion of your game code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: s3eDevice API允许我们找出我们正在运行的设备上当前使用的语言。只需在游戏代码的启动部分插入以下代码行：
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The return value will be a member of the `s3eDeviceLanguage` enumeration, for
    example `S3E_DEVICE_LANGUAGE_ENGLISH` or `S3E_DEVICE_LANGUAGE_GERMAN`. A full
    list of all possible language codes can be found in `s3eDevice.h`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值将是`s3eDeviceLanguage`枚举的一个成员，例如`S3E_DEVICE_LANGUAGE_ENGLISH`或`S3E_DEVICE_LANGUAGE_GERMAN`。所有可能的语言代码的完整列表可以在`s3eDevice.h`中找到。
- en: With the language type determined by this call, we can then load the correct
    table of strings and the user will magically get to see your game in their own
    language, assuming you've supported it of course!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个调用确定的语种类型，我们可以然后加载正确的字符串表，并且用户将神奇地看到他们自己的语言版本的游戏，当然前提是你已经支持它！
- en: Example code
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: There are three example projects associated with this chapter, which are described
    in the following sections.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章相关的有三个示例项目，将在以下各节中描述。
- en: The Font project
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体项目
- en: 'The first example project demonstrates the use of the IwGxFont API and can
    be seen in the following screenshot. This example demonstrates how to use multiple
    fonts in a project, preparing text for printing, and scaling a font up and down
    in size:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例项目演示了IwGxFont API的使用，可以在下面的屏幕截图中看到。此示例演示了如何在项目中使用多个字体，准备打印文本，以及调整字体的大小：
- en: '![The Font project](img/3363_06_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![字体项目](img/3363_06_03.jpg)'
- en: The UI project
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI项目
- en: The UI example implements a user interface library that adheres to the discussion
    on how to implement UI code presented earlier in this chapter. It also presents
    a fully functional localization library, including a Python script that can convert
    an XLS spreadsheet into separate language datafiles. The script also produces
    a file for each language detailing all the characters that were used by any of
    the strings for that language. This can be very useful when generating a font
    resource to display the text.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: UI示例实现了一个遵循本章前面讨论的如何实现UI代码的用户界面库。它还提供了一个完整的本地化库，包括一个可以将XLS电子表格转换为单独的语言数据文件的Python脚本。脚本还为每种语言生成一个文件，详细说明所有字符串使用的字符。这在生成用于显示文本的字体资源时非常有用。
- en: The UI and localization library have been implemented as Marmalade subprojects
    (called GUI and `Localise`), which makes them very easy to re-use in other projects.
    If you find either of them useful, feel free to make use of them in your own projects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: UI 和本地化库已作为 Marmalade 子项目（称为 GUI 和 `Localise`）实现，这使得它们在其他项目中重用变得非常容易。如果你觉得它们有用，请随意在你自己的项目中使用它们。
- en: The text strings are contained in an XLS file contained in the `data/text` directory.
    English and French strings have been included, though apologies to any French-speaking
    readers if these strings are not a 100 percent correct, as they were generated
    using an online translation engine
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符串包含在 `data/text` 目录中的一个 XLS 文件中。已包含英语和法语字符串，尽管对于任何法语读者来说，如果这些字符串不是 100%
    正确，我们表示歉意，因为它们是使用在线翻译引擎生成的。
- en: In the Windows Simulator it is possible to see the program running using both
    of the supplied language files. With the application running, go to **Configuration**
    | **Device…**. In the dialog that appears, there is a drop-down box labeled **Reported
    Device Language**. Choose **ENGLISH** or **FRENCH** in this list and then click
    on the **OK** button. Quit the program and run it again and the selected language
    will be used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 模拟器中，你可以看到使用提供的两种语言文件运行的程序。程序运行时，转到**配置** | **设备…**。在出现的对话框中，有一个标记为**报告的设备语言**的下拉框。在此列表中选择**英语**或**法语**，然后点击**确定**按钮。退出程序并再次运行，将使用所选语言。
- en: 'A screenshot of this sample in action is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例动作的截图如下：
- en: '![The UI project](img/3363_06_04.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![UI 项目](img/3363_06_04.jpg)'
- en: The Skiing project
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: 'Finally we come to our evolving **Skiing!** game, which now has a simple yet
    much nicer looking user interface thanks to the GUI and `Localise` modules created
    for the UI example. The following screenshot shows the new main menu screen:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了我们不断发展的**滑雪！**游戏，现在由于为 UI 示例创建的 GUI 和 `Localise` 模块，它拥有一个简单但看起来更好的用户界面。以下截图显示了新的主菜单屏幕：
- en: '![The Skiing project](img/3363_06_05.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![滑雪项目](img/3363_06_05.jpg)'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we've seen how we can add fonts of any style and size to our
    projects using the IwGxFont API. We also learnt how to use the Marmalade Studio
    Font Builder to convert TrueType fonts into bitmapped fonts that can be loaded
    by IwGxFont.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 IwGxFont API 将任何样式和大小的字体添加到我们的项目中。我们还学习了如何使用 Marmalade Studio
    字体构建器将 TrueType 字体转换为位图字体，这些字体可以被 IwGxFont 加载。
- en: We also discussed how to implement our own user interface library and how we
    can localize our game by adding support for more than one language.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何实现我们自己的用户界面库，以及我们如何通过添加对多种语言的支持来本地化我们的游戏。
- en: In the next chapter we'll be looking at how we can stop our games from being
    silent affairs with the addition of sound effects and music. We'll also be taking
    a brief look at how to add a video file playback.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过添加音效和音乐来停止我们的游戏成为无声事件。我们还将简要地看看如何添加视频文件播放。
