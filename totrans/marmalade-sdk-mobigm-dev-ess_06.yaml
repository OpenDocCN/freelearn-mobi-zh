- en: Chapter 6. Implementing Fonts, User Interfaces, and Localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the knowledge to create 3D worlds populated with animated characters,
    we really need to start thinking about how to improve the look of the user interface
    we present to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll be covering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating fonts that can be used in a Marmalade project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and formatting of text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing ways of implementing your game's user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing your game into multiple languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step toward improving the look of our game is to say goodbye to the
    debug font and replace it with something a little more stylish. The Marmalade
    SDK comes complete with an API called IwGxFont dedicated to font rendering, so
    let's put it to good use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the IwGxFont API to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now I'm sure you must be able to hazard a guess as to how this is done. That's
    right, just add `iwgxfont` to the subprojects section in the MKB file, and then
    make a call to `IwGxFontInit` to initialize the API, and `IwGxFontTerminate` to
    free it at shutdown time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name of this API suggests, it requires IwGx in order to work. We also
    need IwResManager so we can load the font data into memory, so the initialization
    call for IwGxFont must occur after these two modules have been initialized, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a font resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a `CIwGxFont` resource describing the
    font that we want to use. This is easily done thanks to the **Marmalade Studio
    - Font Builder** utility that is installed as part of the Marmalade SDK. The following
    image shows a screenshot of this program in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a font resource](img/3363_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IwGxFont API renders text by drawing each character individually by using
    sections of a large bitmap that contains an image of all the characters we need
    to render. Generating the bitmap itself is fairly trivial and could be done with
    any art package, but we need to somehow be able to specify which part of the bitmap
    represents which character. This is where IwGxFont and the font builder utility
    come to our aid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the basic steps needed to generate a font resource:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the **Marmalade Studio - Font** **Builder** utility. You can find a Windows
    Start button menu shortcut for it under **Marmalade** | **x.x** | **Tools**, where
    **x.x** represents the version number of the Marmalade SDK you have installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-left panel labeled **Input**, first click on the **Select…** button
    to display a font selection dialog. Choose the font, size, and style you require
    and click on **OK**. You can choose any installed Windows font, whether it be
    a scalable TrueType font or a fixed-size bitmapped font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Characters** textbox allows you to specify a list of the characters you
    require in your font. A default selection covering most European languages is
    present, but you can add or remove as many characters as you want. Fewer characters
    is obviously better though, as it will reduce the size of the bitmap that gets
    generated and thus take up less memory. It is also possible to populate this textbox
    by loading a text file using **File** | **Load Character Map**. The **Characters**
    textbox will then contain every unique character present in the text file, minus
    formatting characters such as tabs or newlines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving on to the section labeled **Output Options**, you can choose a color
    for the font using the numeric entry boxes or by clicking on the **Select…** button
    to display a color selection dialog. It is recommended that you keep the color
    set to the default of bright white as the text color can then easily be set at
    runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are also some other settings here that allow you to adjust the look of
    the font. There are checkboxes to force all characters to be in capitals and to
    enable the addition of a drop shadow to the font. If this checkbox is ticked,
    a textbox allows the pixel offset of the drop shadow to be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, look at the top right panel labeled **Output**. Here we can see a preview
    of what the generated font characters will look like. Just click on the **Redraw**
    button and after a short delay the characters will appear in the view area. You
    can then use the two sets of **Prev** and **Next** buttons to cycle through each
    character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're nearly ready to export the font; but before we can, we need to specify
    where we want the font files to be created, which is done in the **Saving and
    Loading** panel. Click on the **Browse…** button to display a file requester to
    choose the required directory or enter it directly into the **Save Path** textbox.
    The last part of this filename is the base filename that will be used to export
    the font data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the font files, ensure that the two checkboxes labeled **Save .TGA**
    and **Save .gxfont** are checked, then click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a number of options we haven't explored in this run-through, as most
    of the time you won't need to worry about them. In particular, we skipped the
    panel labeled **Input (per range) Options** entirely.
  prefs: []
  type: TYPE_NORMAL
- en: This panel provides control over font features such as kerning, which is the
    offset between the characters of a font. Kerning can sometimes be useful for bringing
    certain character combinations closer together. For example, consider the capital
    letters A and V. The shapes of these characters mean you may want to draw them
    slightly closer to provide a more natural looking result when they are displayed
    next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare subranges of characters, which allow you to apply different
    global settings to certain ranges of characters. You can use this facility to
    use completely different sizes of characters or even completely different source
    fonts, for different character ranges. This can be particularly useful if we want
    to create a font that contains characters from the standard ASCII set and characters
    from another language. The font we use for the ASCII characters may not contain
    the characters for the other language, so we can create a sub range that allows
    us to pick a completely different font for those characters.
  prefs: []
  type: TYPE_NORMAL
- en: The GXFONT file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The font builder utility creates two types of files to define a font resource.
    The first of these is the actual font bitmap, which is exported in the Targa file
    format, an image file format usually identified by the file extension `.tga`.
  prefs: []
  type: TYPE_NORMAL
- en: The second file exported is a **GXFONT file**, which acts as both a way of allowing
    the font to be reloaded into the font builder for further editing, and a way of
    loading the font into our own programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example GXFONT file for a font containing only numeric
    characters drawn using the standard Windows font Arial Black at 20 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's fairly self-explanatory. The comments at the start of the
    file are primarily used by the font builder utility to know what settings were
    used to create the font, so you should leave these values well alone if you want
    to edit the font later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can edit a font in the font builder utility at a later date by using **File**
    | **Load Font** or by pressing the **Load…** button. A file requester will appear
    allowing us to choose the GXFONT file we wish to edit.
  prefs: []
  type: TYPE_NORMAL
- en: he part of the GXFONT file we're really interested in is the definition of the
    `CIwGxFont` instance. The three parameters we see here indicate that the character
    encoding to be used with this font should be UTF-8, the bitmap image to use is
    called `numbers.tga`, and the characters present in the font are the numerals
    zero through nine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, UTF-8 character encoding is chosen, as this format often provides
    the most compact memory representation of text strings, at least as far as European
    languages are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: If we've specified any other font settings in the font builder utility, such
    as character subranges or kerning information, this will also be represented in
    both the comments at the top of the file and the `CIwGxFont` structure. We won't
    cover this here though, since the font builder takes care of all the hard work
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and accessing font resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the resource types we've seen, we load a font resource into our
    program by adding a reference to it into a GROUP file, loading the GROUP file
    using the resource manager, and then searching for the font resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, here is a code snippet showing how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Drawing text using a font resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a font resource loaded and a pointer to it obtained, we can start to draw
    some text on screen with it. First we'll look at the basics of drawing a string
    of text, then we'll take a look at how we can justify the text, change its size,
    and how we can make drawing it a little more optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text on screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we were looking at how to create a font resource, it was mentioned that
    a color could be chosen for the font. It is recommended to choose white so we
    can change the color of our text at runtime to any color we want. We change the
    color of the font by modulating the font bitmap with our chosen color, so if the
    font bitmap is not white this will not produce the desired color change.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be seeing how to change the font color in a moment, but in order for font
    coloring to work there is one quirk of IwGxFont that must be mentioned first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When attempting to recolor a font at runtime, we must ensure that emissive lighting
    is enabled using the function call `IwGxLightingEmissive(true)`. IwGxFont affects
    the color of a font by using the emissive lighting component, which will not be
    applied if it is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: With the note about lighting out of the way, the first step in rendering text
    is to indicate which font we want to use to draw it. This is done by passing a
    pointer to the relevant `CIwGxFont` instance into the function `IwGxFontSetFont`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can set the color we want to use with `IwGxFontSetCol`. There are two
    versions of this function, one that takes a reference to a `const CIwColour` instance,
    and another that takes the color value as a uint32 value. When using the latter,
    bear in mind that the color is specified as ABGR—that is, alpha in the most significant
    byte, then blue, green, and red in the least significant byte.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to indicate where on the screen we want the text to appear, which
    we do by defining a rectangular area in which the text should appear. This is
    specified by using a `CIwRect` instance that contains x and y values for the top
    left of the rectangle, plus a width and height value. The function call we use
    is `IwGxFontSetRect`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the text is now possible using the `IwGxFontDrawText` function. The
    first parameter is the string of text to print and is specified as a `const CIwChar`
    pointer. `CIwChar` is just a `typedef` type for the standard C `char` type.
  prefs: []
  type: TYPE_NORMAL
- en: The default encoding for text is UTF-8\. For text comprising of characters from
    the ASCII set, this means we don't have to do anything to the text data at all.
  prefs: []
  type: TYPE_NORMAL
- en: The function also takes a second parameter, which is the length of the text
    to be drawn. This has a default parameter value of `-1`, which indicates the entire
    string should be drawn. Any other value will draw the specified number of characters.
    This is handy if you want to implement a system common in many games where text
    appears on screen one character at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together, here''s an example that draws "Hello World" on the
    screen in yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Text wrapping and justification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wondering why we specified a rectangular area for our text rather than just
    a screen position? The reason is so that IwGxFont can wrap and justify our text
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Marmalade does allow us to include the line feed character in our code
    to force a new line in our text, it does not provide support for other formatting
    characters such as tabs or backspace. It is far better to allow Marmalade to word
    wrap text for us than to insert line feeds in our text by hand, because if we
    change the font size or the dimension of the rectangular draw area we won't have
    to change the text itself in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default behavior when rendering text is to word wrap whenever a line of
    text exceeds the bounds of the rectangular area set with `IwGxFontSetRect`. We
    can alter this behavior using the `IwGxFontSetFlags` function, which can take
    a combination of the following values OR''ed together:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_DEFAULT_F     ` | Uses default font settings. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_NOWRAP_F` | Does not wrap text at the edge of the rectangle''s
    boundary. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_NOWORDWRAP_F` | Does not perform full word wrapping on text.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ONELINE_F` | Only renders a single line of text. Rendering stops
    when a newline character (`''\n''`) is reached. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_NUMBER_ALIGN_F` | Forces all numbers to be displayed with the
    same width. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_UNDERLINE_F` | Draws the text with underlining. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ITALIC_F` | Draws the text in italics. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_RIGHTTOLEFT_F` | Draws characters from right to left. Useful
    for drawing languages such as Arabic. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_NOWORDSPLIT_F` | Wraps text at the end of words. A word can overlap
    the end of the rectangle boundary, but the next word will start on the next line.
    |'
  prefs: []
  type: TYPE_TB
- en: Flags can be cleared again using `IwGxFontClearFlags`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify whether text is drawn left aligned, right aligned, or centered
    in the rectangular bounding area using the function `IwGxFontSetAlignmentHor`,
    which takes one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_LEFT` | Aligns text to the left of the bounding box. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_CENTRE` | Centres text horizontally in the bounding box.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_RIGHT` | Aligns text to the right edge of the bounding
    box. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_PARAGRAPH` | Performs left or right alignment, as defined
    by the device''s localization settings. |'
  prefs: []
  type: TYPE_TB
- en: 'We can do similar alignments vertically as well using `IwGxFontSelAlignmentVer`
    with one of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_TOP` | Text is drawn so that the top line of text touches
    the top of the bounding box. |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_MIDDLE` | Text is centered vertically in the bounding box.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IW_GX_FONT_ALIGN_BOTTOM` | Text is drawn so the bottom of the last line
    of text touches the bottom of the bounding box. |'
  prefs: []
  type: TYPE_TB
- en: Changing font size at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it is desirable to be able to animate text by making changes in its
    size. For example, in a shooting game the score awarded for killing an enemy might
    appear at the position of the enemy then gradually grow larger and fade out.
  prefs: []
  type: TYPE_NORMAL
- en: The function `IwGxFontSetScale` enables us to do this. It takes two parameters
    so the font can be scaled by different amounts, both horizontally and vertically.
    The scaling factors are passed in as fixed point values, with `IW_GEOM_ONE` indicating
    a scaling factor of `1` and therefore no change in size.
  prefs: []
  type: TYPE_NORMAL
- en: IwGxFont draws text by rendering a rectangular polygon for each character in
    our text, with the relevant part of the font image mapped on to it. By specifying
    a scaling factor we can change the size of the polygons used to render the individual
    characters, though this can yield poor results if we scale up by a large factor
    (for example, more than double the original size of the font).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing drawing by preparing text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the problems with rendering text is that in order to perform alignment,
    word wrapping, and the like, it is necessary to format the text by considering
    it one character at a time to see if the next character crosses the rectangular
    bounding box area.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to draw a piece of fixed text, such as an instructions screen, we
    can prevent having to calculate the formatting information in every frame by preparing
    the text for rendering once and then using some cached data to draw it from then
    on.
  prefs: []
  type: TYPE_NORMAL
- en: To do this we use the function `IwGxFontPrepareText`. This function takes a
    reference to a `CIwGxFontPreparedData` class instance, the string of text to prepare,
    and optionally the number of characters in the string that we want to consider.
    If this parameter is omitted, the entire string is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the text prepared we can then draw it using another version of the `IwGxFontDrawText`
    function. This version takes a reference to the `CIwGxFontPreparedData` instance
    and two optional parameters that indicate the first character from the prepared
    data to draw and the number of characters to draw. Here''s a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the text will be drawn on screen at the position indicated by the
    formatting rectangle set in the call to `IwGxFontSetRect`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game will need some kind of user interface, even if it is just a button
    that can be pressed to start a new game. In this section we will take a look at
    how a user interface can be implemented for your own game.
  prefs: []
  type: TYPE_NORMAL
- en: The IwUI API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Marmalade SDK ships with an API called IwUI, which allows us to create user
    interfaces for our projects consisting of buttons, labels, and other common controls.
  prefs: []
  type: TYPE_NORMAL
- en: This API is very feature-rich and allows interfaces to be created not just for
    games, but also for more serious applications. Marmalade used to ship with a tool
    called the Marmalade Studio UI Builder, but this is sadly no longer a supported
    part of the SDK. However, it is still possible to access this tool by either installing
    an older version of Marmalade (one of the v5.2.x releases is probably best) or
    by downloading its source code from [https://github.com/marmalade/UI-Builder](https://github.com/marmalade/UI-Builder).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use IwUI without using the UI creation tool by constructing
    ITX files that describe our interface layouts, by hand. These layout files can
    end up being quite verbose and therefore hard to maintain, so the Marmalade Studio
    UI Builder made editing layouts a bit more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: The Marmalade documentation states that the reason for dropping the UI Builder
    from the SDK was to allow a standardized UI markup system to be used that is supported
    by a number of other third party tools. At the time of writing this book, no further
    announcement had been made regarding exactly what form this will take.
  prefs: []
  type: TYPE_NORMAL
- en: There seems no doubt that the IwUI API will remain a part of Marmalade for the
    foreseeable future. However, we won't be delving any deeper into the API itself
    in this book as it seems likely that a new UI system will be making its way into
    Marmalade soon. If you are interested in what IwUI can do, take a look at the
    Marmalade documentation and the plethora of sample code that ships with the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The IwNUI API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Marmalade provides a second user interface API called IwNUI. The "N" stands
    for Native, as this API allows you to construct user interfaces using the standard
    UI controls for the platform that your application runs on.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like a good idea but the main drawback is that it is only supported
    on iOS and Android. All other platforms will use a default style implemented using
    the previously mentioned IwUI API.
  prefs: []
  type: TYPE_NORMAL
- en: At any rate most games tend to implement their own UI that is in keeping with
    the style of the game, and this normally means we don't want to use standard OS
    user interface controls, but IwNUI is a good choice if you happen to want to develop
    a utility or other application type.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our own user interface solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that we're effectively starting from square one with our user interface
    implementation, let's consider how we could go about creating our own solution.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections highlight some of the issues to be aware of when developing
    user interface code. One of the example projects accompanying this chapter implements
    a user interface library that tries to take most of the following into account.
  prefs: []
  type: TYPE_NORMAL
- en: Using a generic approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It really is worth taking the time to develop as generic a solution as possible
    when dealing with user interface code. While implementing the frontend of a game
    isn't particularly difficult to code, it is far too easy to find yourself writing
    UI code from scratch for each project.
  prefs: []
  type: TYPE_NORMAL
- en: By investing in a generic approach, you can quickly put together a functional
    UI for all your projects. Frontend menu systems actually tend to be little more
    than a collection of buttons and labels; so why write this code multiple times?
    Implement these types of controls once and you can then spend more time creating
    customized controls when your game demands it.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you implement your UI code by creating a separate subproject,
    as this will help ensure that your solution is as generic and self-contained as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Marmalade makes it easy for us to create our own library modules by using the
    same system the SDK uses for including its component parts. Simply create an MKB
    file referencing all the source files that are part of the library, but save it
    with the extension `.mkf` instead of `.mkb`. You can then reference this module
    by adding the name of the MKF file (minus the extension) to the `subprojects`
    section of the main project MKB file. Library module directories should be placed
    in the same place as the main project directory so that they can be located when
    creating the project from the MKB file.
  prefs: []
  type: TYPE_NORMAL
- en: Making good use of class inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good class hierarchy can make implementing your UI a much more pleasant experience
    and it is well worth taking a look at existing systems to see how they have been
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern UI implementations will normally start with a base level class from
    which all other control types are derived, which for discussion purposes in this
    chapter we will call an **element**. An element will take care of things such
    as the positioning of a control and internal naming so that the handling of UI
    events can be standardized.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a class representing an element, we should make use of virtual
    methods that can be overridden by child classes to change default behavior. At
    the very least this normally means that we should have methods that can be called
    to update and render the control.
  prefs: []
  type: TYPE_NORMAL
- en: Another extremely useful concept is that of a **frame**, which has the ability
    to group several elements together so they can be moved, enabled, or hidden at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: When updating or rendering the user interface, the frame is responsible for
    deciding whether or not to update or render the child elements it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The positioning and sizing of all elements contained within a frame should also
    be calculated relative to the position and size of the frame itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having implemented classes representing both elements and frames, it is possible
    to implement most common UI controls very simply. Here are a few examples to illustrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: A **label** control simply displays a line of text on screen. It can be derived
    from the element class and at its simplest all we need to define are member variables
    to store the text to be drawn, and some font and color information. We can then
    override the virtual render method to allow the text to be drawn at the position
    indicated by the element class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **bitmap** control is very similar to a label but displays an image instead
    of text. We just need to store a pointer to the image we want to draw (perhaps
    as a `CIwTexture` or `CIwMaterial` pointer) and then implement the render method
    to draw it on screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **button** control can be derived from a frame. Most UI systems allow an image
    or a text string (or both) to be displayed on the button, so we can implement
    this just by adding label or bitmap controls to the list of elements contained
    within the frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **slider** control could also use the frame as a basis and could include two
    bitmap controls, one for the backing of the slider and another for the selection
    knob. A label could also be included if you want to display the current position
    of the slider as a numeric value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully this gives you an idea of how, with a little initial planning, implementing
    a diverse range of user interface controls actually becomes very easy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a data-driven system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a good class hierarchy in place, the next step is to ensure that your UI
    can be created easily from a configuration datafile. While it is perfectly possible
    to create all your controls in code, this is hard to maintain and, most crucially,
    can then only be edited by a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing your UI to be constructed from a datafile means that other members
    of your team can help with designing the UI. Having a datafile format also makes
    it easier to develop a user interface layout tool if you want to make the process
    even easier for people to use.
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen how we can use the ITX file format to construct our own custom
    classes from a file at runtime, so it makes sense to employ this methodology to
    our UI code (refer back to [Chapter 2](ch02.html "Chapter 2. Resource Management
    and 2D Graphics Rendering"), *Resource Management and 2D Graphics Rendering*,
    if you want to refresh your memory on this). No point in writing more code than
    we have to!
  prefs: []
  type: TYPE_NORMAL
- en: Responding to user input events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user interface of a game must solve two main issues. The first is relaying
    information to the player, and we've already discussed how this can be done earlier.
    The second is responding to user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier in this book, modern mobile devices allow a great many
    ways of allowing the player to interact with a game. Which of these you support,
    depends on the devices you are trying to target, but by far the most popular choice
    is the touch screen. Pressing on-screen buttons is just a very natural way of
    interacting with a application, so it is pretty much guaranteed you will end up
    supporting touch screens for your own UI.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously not all controls need to respond to being touched. For example, a
    label is unlikely to do anything, so it makes sense to provide some mechanism
    that allows us to indicate which controls should respond to touches and which
    shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: While we could just add some virtual methods to the element class that gets
    called whenever a touch has been detected within its bounding area, this is probably
    not the best solution as it starts to make the element class a little cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: We really want to encapsulate this sort of functionality somehow, and a good
    way of doing this is by using an Event system. Such a system works by having a
    central event manager whose sole job is to receive event messages from one part
    of the code and pass those messages on to any class instance that has registered
    itself with the event manager to be notified of a particular event.
  prefs: []
  type: TYPE_NORMAL
- en: To implement such a system, we can introduce two new base classes. An Event
    class, which is the base class for all event message types, and an `EventHandler`
    class, which contains a single virtual method called `Execute` that will be called
    in order to respond to an Event.
  prefs: []
  type: TYPE_NORMAL
- en: At its most basic level, the Event class will just contain a single member that
    is used as a unique identifier for a particular type of event, for example, an
    enumerated type. We can declare our own event types by deriving them from an Event
    and adding members for any information we might want to pass along with the message.
    For example, a touch screen event might contain the screen coordinates of where
    the touch occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Any class that wants to respond to a particular event can then derive from the
    `EventHandler` class and provide an implementation for the virtual method. When
    a new instance of a class is constructed, it registers its interest in any event
    by passing the unique identifier of the event and a pointer to itself (cast as
    an `EventHandler` pointer) to the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever an event occurs we create an instance of the event type in question,
    populate its members with information about that event, and pass it to the event
    manager. The event manager will compare the unique identifier of the event against
    its list of registered instances and then call the `Execute` method of `EventHandler`
    for any of registered instance that wanted to be notified about the type of event
    that has just occurred. The event message will be passed into the `Execute` method
    of the instance so that its data can then be acted upon accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Screen resolution and orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chances are that your game could well be executed on a number of different devices
    that have different screen resolutions and aspect ratios, which can make creating
    a nice looking user interface a real chore.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore important to provide a very flexible way in which the position
    and size of UI controls can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: When specifying screen coordinates, widths, and heights for controls, consider
    allowing both exact pixel sizes and ratios of the width and height of the containing
    frame to be used.
  prefs: []
  type: TYPE_NORMAL
- en: It is also good to allow a control to be conformed to a particular aspect ratio
    when using ratios to define sizes. Being able to ensure that the control has a
    particular aspect ratio makes it much easier to keep a consistent layout of any
    child control and is particularly important when drawing bitmapped images that
    will look strange if they end up stretched. When fixing a control to a particular
    aspect ratio, you will want to be able to indicate whether the width or the height
    should change to keep the control in the correct shape.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to lay out controls relative to each other is also a useful thing
    to be able to do. One way of doing this is by specifying that a control should
    take in its position by adding an offset to the position of another control.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that can throw a spanner in the works is when the user rotates
    the device and the screen changes between portrait and landscape orientations.
    For most games we will want screen orientation changes to be ignored, since most
    games are designed to either be played in portrait or landscape and not both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignoring screen orientation changes is made simple by adding the `DispFixRot`
    setting to the application''s ICF file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This setting can take the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Free` | Screen will rotate when the user rotates the device. This is the
    default value if `DispFixRot` is not used. |'
  prefs: []
  type: TYPE_TB
- en: '| `Portrait` | Screen will always be kept in portrait aspect but can rotate
    when the device is held in either of the possible portrait orientations. It is
    easy to miss the fact that there are two possible portrait orientations since
    the phone could be held upside down! |'
  prefs: []
  type: TYPE_TB
- en: '| `Landscape` | Screen will always be kept in landscape aspect but can rotate
    when the device is held in either of the possible landscape orientations. Again,
    note that there are two possible landscape orientations depending on which direction
    you rotate the phone from its normal portrait position. |'
  prefs: []
  type: TYPE_TB
- en: '| `FixedPortrait` | Screen will be fixed in the device''s default portrait
    orientation and will not rotate at all. |'
  prefs: []
  type: TYPE_TB
- en: '| `FixedLandscape` | Screen will be fixed in the device''s default landscape
    orientation and will not rotate at all. |'
  prefs: []
  type: TYPE_TB
- en: 'If we do choose to support screen orientation changes, we need some way of
    detecting when the orientation has changed. We can do this by setting up a callback
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is highly recommended, if you are supporting both portrait and landscape
    in your game, that you define specific layouts of your controls for each orientation
    and switch between them when the device is rotated. Trying to accommodate both
    orientations with a single layout is possible but tends to yield uninspiring results
    in both orientations, so make the most of the available screen space by providing
    custom layouts for each.
  prefs: []
  type: TYPE_NORMAL
- en: Adding template functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consistency is an important part of the user interface design. We expect controls
    of a similar type to look the same. If they don't, the design starts to look sloppy
    and unprofessional. It's therefore useful to be able to provide a way of defining
    certain aspects of our UI once, and **Template** definitions allow us to do just
    that.
  prefs: []
  type: TYPE_NORMAL
- en: A relatively easy way of implementing templates is to be able to copy the settings
    of one UI control into another. We can create a control that will never actually
    be displayed, but will act as a template for other controls. When creating a new
    control we can copy all member settings from the template and then proceed to
    make changes to the settings so that the control displays whatever we need it
    to.
  prefs: []
  type: TYPE_NORMAL
- en: One way of implementing this is to add a virtual method to the element class,
    which is given a pointer to the template control. Each class can override this
    method to set its member variables based on the values contained in the template.
    By calling the virtual method in the parent class, we can copy all member variable
    settings from the template right down to the base element class.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the progress of technology marches on, the world seems to become a smaller
    place and your game may well end up being played on devices all across the globe.
    It's therefore well worth considering localizing your game so that players across
    the world can experience your game in their own language.
  prefs: []
  type: TYPE_NORMAL
- en: While supporting every language known to man would be impractical, many best-selling
    games now offer support for at least the **EFIGS** languages (English, French,
    Italian, German, and Spanish), and you can often add Portuguese, Russian, Polish,
    Japanese, Korean, and both Simplified and Traditional Chinese to the list as well.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting other languages other than your own native tongue is well worth it,
    as players would much rather play a game they can read and understand than one
    they can't.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you decide to support other languages, there is still a benefit
    in implementing your game's text in the manner I am about to describe, since it
    allows you to remove all the text from your source code and put it all in one
    place, which makes changing the text a much easier process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a text spreadsheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in localizing the text in your game is to use a program such
    as Microsoft Excel or OpenOffice Calc to create a spreadsheet containing all the
    text for your game. By using a spreadsheet it is very easy to add or insert new
    strings of text, and the columns of the spreadsheet can be used to provide translations
    of the strings for each language you want to support. The following screenshot
    shows an example of such a spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a text spreadsheet](img/3363_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this spreadsheet the first column is used as a text identifier field. This
    is just a string of text that we can use in our source code and datafiles to represent
    a particular string of text.
  prefs: []
  type: TYPE_NORMAL
- en: The first row is used to indicate which language each column of the spreadsheet
    represents. In the example, we have used the standard two letter ISO country codes
    to represent the supported languages, namely English (EN) and French (FR).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the spreadsheet is then just the actual text that we want to appear
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the text into the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the text for our game now in a spreadsheet, how do we access it from inside
    our game code? The answer is to process the spreadsheet into a format that is
    easy for us to load and use in game code.
  prefs: []
  type: TYPE_NORMAL
- en: Comma-separated values files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One option would be to export the text as a **Comma-Separated Values** (**CSV**)
    file from our spreadsheet program. This is a simple text-only format that outputs
    each row of the database as a separate line in the file, with the contents of
    each cell listed separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: The trouble with this approach is it can be error-prone. Having a comma in the
    text of one of your strings can play havoc with the output since the comma is
    already used to indicate the end of one string and the beginning of the next.
    This is often gotten around by enclosing each string in quote marks, but then
    this can cause further problems if a string needs to include a quote mark too!
  prefs: []
  type: TYPE_NORMAL
- en: Remember also that IwGxFont expects text to be supplied in UTF-8 format by default.
    If you are supporting languages such as Japanese or Korean, this becomes very
    important and some spreadsheet programs do not support exporting a CSV File in
    UTF-8 format.
  prefs: []
  type: TYPE_NORMAL
- en: Processing using a Python script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A much better method of getting the text out of a spreadsheet and into our game
    is to process the spreadsheet into a simple datafile, which can be easily loaded
    into our game. To demonstrate this, we'll be making use of the Python scripting
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Python may have a rather strange approach to code layout (the scoping level
    of your code is indicated by how much it is indented, rather than using notation
    such as curly braces to indicate the start and end of a section of code), but
    there is no denying that it is extremely good at this kind of task.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get hold of an installer for Python from the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.python.org/download/](http://www.python.org/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach we will be using is to access the data from the text spreadsheet
    by accessing it directly. If we save the spreadsheet in Excel 97 format (file
    extension `.xls`, supported by most spreadsheet programs), there is an excellent
    Python library called `xlrd` that can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pypi.python.org/pypi/xlrd/](http://pypi.python.org/pypi/xlrd/)'
  prefs: []
  type: TYPE_NORMAL
- en: Install Python first and then install the `xlrd` library. It's a good idea to
    ensure that the Python executable can be easily found by adding the Python install
    directory to your path environment variable. An easy way to check if the Python
    directory is already in your path variable is to open up a command prompt window
    and enter `path` to display the current list of directories that will be searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate just how simple accessing data from a spreadsheet file is, using
    Python and xlrd, the following script will open a spreadsheet file and output
    all the rows and columns it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even if you've never set eyes on a Python script before, this should be fairly
    easy to follow, but here's a brief explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The `import xlrd` line is equivalent to the `#include` directive in C/C++. It's
    just stating that we want to make use of the `xlrd` library.
  prefs: []
  type: TYPE_NORMAL
- en: Next we open the spreadsheet file by calling the `xlrd.open_workbook` method,
    passing in the filename of the spreadsheet we want to use. This returns an instance
    of a Python class defined by `xlrd` that represents the spreadsheet file. Note
    that Python is a loosely typed language and there is no need to declare what type
    the variable must be.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `sheet_by_index` method on the spreadsheet object to retrieve the
    first worksheet from the spreadsheet. This yields another Python object representing
    the worksheet.
  prefs: []
  type: TYPE_NORMAL
- en: We then enter a `for` loop that causes the `lRow` variable to iterate between
    `0` and the number of populated rows in the spreadsheet. Within the loop we use
    the worksheet object to access the spreadsheet cells an entire row at a time using
    the `row_values` method.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a built-in list type and this is what is being used to access all
    the cells on the row in one go. The `lCells` variable will contain a list whose
    elements are each cell in the row.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we use the Python `print` command to display the entire list to standard
    output. You can use `print` in Python to display just about any type, including
    lists, in a human-readable form.
  prefs: []
  type: TYPE_NORMAL
- en: The UI example project that accompanies this chapter includes a Python script
    that will take a spreadsheet as input and convert it into a simple datafile for
    each language contained in the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: The datafiles list the number of strings in the file followed by a hash value
    generated from the text identifier field (the first column of the spreadsheet)
    and the string itself. It is fairly trivial to write C++ code to load this file
    into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of a hashing function here means it is possible for two strings to end
    up with the same hash value, causing a collision in the string table that means
    the wrong string may get returned. In practice a good hashing function will mean
    this hardly ever happens, but if you start getting the wrong string returned this
    might be the cause. The easiest way to rectify such a problem is just to rename
    one of the text identifiers in the collision!
  prefs: []
  type: TYPE_NORMAL
- en: To access a particular text string, we use the identifier field in our code.
    A hash value is generated from the identifier field and the list of string data
    is searched for that hash value. If a match is found, the corresponding text string
    is returned, otherwise an assert can be raised and a default string of text returned.
    The default text can be something like "Missing String!", which makes it easier
    to track down problems such as getting the identifier field wrong in code, or
    the string just not being present in the text datafile when it should be.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the correct language to use at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have the ability to supply our game with strings of text in multiple
    languages, but how do we decide which of those languages to actually use? One
    method of course is to implement a language select screen during startup of our
    game and then load the relevant string table depending on the user's input. However,
    there is a much nicer way available to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The s3eDevice API allows us to find out which language is currently in use
    on the device we are running on. Simply insert the following line of code during
    the startup portion of your game code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The return value will be a member of the `s3eDeviceLanguage` enumeration, for
    example `S3E_DEVICE_LANGUAGE_ENGLISH` or `S3E_DEVICE_LANGUAGE_GERMAN`. A full
    list of all possible language codes can be found in `s3eDevice.h`.
  prefs: []
  type: TYPE_NORMAL
- en: With the language type determined by this call, we can then load the correct
    table of strings and the user will magically get to see your game in their own
    language, assuming you've supported it of course!
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three example projects associated with this chapter, which are described
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Font project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example project demonstrates the use of the IwGxFont API and can
    be seen in the following screenshot. This example demonstrates how to use multiple
    fonts in a project, preparing text for printing, and scaling a font up and down
    in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Font project](img/3363_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UI project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UI example implements a user interface library that adheres to the discussion
    on how to implement UI code presented earlier in this chapter. It also presents
    a fully functional localization library, including a Python script that can convert
    an XLS spreadsheet into separate language datafiles. The script also produces
    a file for each language detailing all the characters that were used by any of
    the strings for that language. This can be very useful when generating a font
    resource to display the text.
  prefs: []
  type: TYPE_NORMAL
- en: The UI and localization library have been implemented as Marmalade subprojects
    (called GUI and `Localise`), which makes them very easy to re-use in other projects.
    If you find either of them useful, feel free to make use of them in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: The text strings are contained in an XLS file contained in the `data/text` directory.
    English and French strings have been included, though apologies to any French-speaking
    readers if these strings are not a 100 percent correct, as they were generated
    using an online translation engine
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows Simulator it is possible to see the program running using both
    of the supplied language files. With the application running, go to **Configuration**
    | **Device…**. In the dialog that appears, there is a drop-down box labeled **Reported
    Device Language**. Choose **ENGLISH** or **FRENCH** in this list and then click
    on the **OK** button. Quit the program and run it again and the selected language
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of this sample in action is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UI project](img/3363_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Skiing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally we come to our evolving **Skiing!** game, which now has a simple yet
    much nicer looking user interface thanks to the GUI and `Localise` modules created
    for the UI example. The following screenshot shows the new main menu screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Skiing project](img/3363_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've seen how we can add fonts of any style and size to our
    projects using the IwGxFont API. We also learnt how to use the Marmalade Studio
    Font Builder to convert TrueType fonts into bitmapped fonts that can be loaded
    by IwGxFont.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to implement our own user interface library and how we
    can localize our game by adding support for more than one language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll be looking at how we can stop our games from being
    silent affairs with the addition of sound effects and music. We'll also be taking
    a brief look at how to add a video file playback.
  prefs: []
  type: TYPE_NORMAL
