<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-113" class="chapter-number"><a id="_idTextAnchor212"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor213"/><st c="2">SwiftUI Animations and  SF Symbols</st></h1>
			<p><st c="35">The previous chapter dealt with a delightful topic – widgets. </st><st c="98">Their aesthetic level is both enjoyable and effective, which makes working with them fun and easy. </st><st c="197">Now, we will take that feeling even further with </st><span class="No-Break"><st c="246">SwiftUI animations.</st></span></p>
			<p><st c="265">Animation is a crucial topic in iOS development, as it enriches the experience and makes our app more intuitive and enjoyable to use. </st><st c="400">If you are used to UIkit animations, you will notice that SwiftUI animations take a different approach than UIkit, providing a declarative API to animate </st><span class="No-Break"><st c="554">state changes.</st></span></p>
			<p><st c="568">With these new challenges also come opportunities that ensure our logic state and UI are </st><span class="No-Break"><st c="658">always aligned.</st></span></p>
			<p><st c="673">In this chapter, we will do </st><span class="No-Break"><st c="702">the following:</st></span></p>
			<ul>
				<li><st c="716">Discuss the importance </st><span class="No-Break"><st c="740">of animations</st></span></li>
				<li><st c="753">Understand the SwiftUI </st><span class="No-Break"><st c="777">animation concept</st></span></li>
				<li><st c="794">Perform basic animations with the view modifier and the </st><span class="No-Break"><strong class="source-inline"><st c="851">withAnimation</st></strong></span><span class="No-Break"><st c="864"> function</st></span></li>
				<li><st c="873">Perform advanced animations such as transitions and </st><span class="No-Break"><st c="926">keyframe animations</st></span></li>
				<li><st c="945">Animate </st><span class="No-Break"><st c="954">SF symbols</st></span></li>
			</ul>
			<p><st c="964">Explaining why we need animations sounds weird and some may raise eyebrows about this topic. </st><st c="1058">So, our first mission is to take this topic off the table before we move one pixel on the screen. </st><st c="1156">So, let’s answer the following question – why do we need to care </st><span class="No-Break"><st c="1221">about animations?</st></span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor214"/><st c="1238">Technical requirements</st></h1>
			<p><st c="1261">For this chapter, it’s essential to download Xcode version 16.0 or higher from the </st><span class="No-Break"><st c="1345">App Store.</st></span></p>
			<p><st c="1355">Ensure that you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="1441">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1539">Open Xcode and complete any further setup instructions that appear. </st><st c="1607">After Xcode is completely up and running, you </st><span class="No-Break"><st c="1653">can begin.</st></span></p>
			<p><st c="1663">Download the sample code from the following </st><span class="No-Break"><st c="1708">GitHub link:</st></span></p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%206"><span class="No-Break"><st c="1720">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%206</st></span></a></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor215"/><st c="1806">The importance of animations</st></h1>
			<p><a id="_idTextAnchor216"/><a id="_idTextAnchor217"/><st c="1835">Some of you may think that executing animations is mainly for fun and doesn’t really impact an </st><a id="_idIndexMarker282"/><st c="1931">app’s usability. </st><st c="1948">But the truth is that animations play a crucial role in enhancing user engagement and interface design, especially in mobile applications. </st><st c="2087">Here are a few benefits of </st><span class="No-Break"><st c="2114">using animations:</st></span></p>
			<ul>
				<li><st c="2131">First, animations provide </st><strong class="bold"><st c="2158">visual feedback</st></strong><st c="2173"> in response to users’ actions – a button that grows when a user taps on it helps them know that they touched the </st><span class="No-Break"><st c="2287">right place</st></span></li>
				<li><st c="2298">Animations can also provide </st><strong class="bold"><st c="2327">guidance and navigation</st></strong><st c="2350"> – transitions between pages indicate whether we move “forward” with our flow </st><span class="No-Break"><st c="2428">or backward</st></span></li>
				<li><st c="2439">Animations also help in </st><strong class="bold"><st c="2464">error handling</st></strong><st c="2478"> – we can animate error messages and general issues and reduce a </st><span class="No-Break"><st c="2543">user’s frustration</st></span></li>
				<li><st c="2561">Most importantly, in many cases, animations are part of the </st><strong class="bold"><st c="2622">app branding and uniqueness</st></strong><st c="2649"> and provide that special touch that strengthens the link between a user and </st><span class="No-Break"><st c="2726">an app</st></span><a id="_idTextAnchor218"/><a id="_idTextAnchor219"/></li>
			</ul>
			<p><st c="2732">Now that we understand the importance of animation, let’s see how SwiftUI’s declarative approach aligns with </st><span class="No-Break"><st c="2842">that concept.</st></span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor220"/><st c="2855">Understanding the concept of SwiftUI animations</st></h1>
			<p><st c="2903">For a developer </st><a id="_idIndexMarker283"/><st c="2920">coming from UIkit and taking their first steps in SwiftUI, the concept of writing animations in a declarative framework could feel a little awkward. </st><st c="3069">After all, performing animations in UIkit was extremely simple – all we had to do was respond to some event and change some view properties within an animation closure. </st><st c="3238">Here’s a simple example of how to fade out a view </st><span class="No-Break"><st c="3288">in UIkit:</st></span></p>
			<pre class="source-code"><st c="3297">
UIView.animate(withDuration: 2.0, animations: {
            sampleView.alpha = 0.0
        }) { (finished) in
}</st></pre>			<p><st c="3389">In this example, we modify the alpha level of </st><strong class="source-inline"><st c="3436">sampleView</st></strong><st c="3446"> inside a </st><strong class="source-inline"><st c="3456">UIView</st></strong> <span class="No-Break"><st c="3462">animation closure.</st></span></p>
			<p><st c="3481">While this </st><a id="_idIndexMarker284"/><st c="3493">looks pretty simple, it comes with a significant drawback – the need to sync the animation action to the screen state. </st><st c="3612">The </st><strong class="source-inline"><st c="3616">sampleView</st></strong><st c="3626"> component is now hidden – but does that mean that our view model or any other logic we incorporated in our screen is updated? </st><st c="3753">This update is our responsibility. </st><st c="3788">While this is a general </st><em class="italic"><st c="3812">UIkit</st></em><st c="3817"> problem, syncing between the view and the state can worsen when working </st><span class="No-Break"><st c="3890">with animations.</st></span></p>
			<p><st c="3906">However, in </st><em class="italic"><st c="3919">SwiftUI</st></em><st c="3926">, the screen state is always synced with the UI, and that’s true for animations as well. </st><st c="4015">The basic concept of SwiftUI animations revolves around the idea of animating changes to the view state, including properties such as position, size, opacity, </st><span class="No-Break"><st c="4174">and rotation.</st></span></p>
			<p><st c="4187">There are several ways of implementing animations in SwiftUI; some are truly simple, while others let us deliver advanced and </st><span class="No-Break"><st c="4314">complex animations.</st></span></p>
			<p><st c="4333">Let’s warm up and start with some </st><span class="No-Break"><st c="4368">basic animations.</st></span></p>
			<h1 id="_idParaDest-118"><st c="4385">Performing basic animatio</st><a id="_idTextAnchor221"/><a id="_idTextAnchor222"/><st c="4411">ns</st></h1>
			<p><st c="4414">The fundamental </st><a id="_idIndexMarker285"/><st c="4431">way to understand how SwiftUI animations work is by associating a state value with a particular </st><span class="No-Break"><st c="4527">animation flow.</st></span></p>
			<p><st c="4542">There are three ways of performing basic animations </st><span class="No-Break"><st c="4595">in SwiftUI:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="4606">Using the </st></strong><strong class="source-inline"><st c="4617">animation</st></strong><strong class="bold"><st c="4626"> modifier</st></strong><st c="4635"> – adding an animation to a </st><span class="No-Break"><st c="4663">specific view</st></span></li>
				<li><strong class="bold"><st c="4676">Using the </st></strong><strong class="source-inline"><st c="4687">withAnimation</st></strong><strong class="bold"><st c="4700"> global function</st></strong><st c="4716"> – performing animation by changing </st><span class="No-Break"><st c="4752">several states</st></span></li>
				<li><strong class="bold"><st c="4766">Using </st></strong><strong class="source-inline"><st c="4773">animation()</st></strong><strong class="bold"><st c="4784"> method</st></strong><st c="4791"> – attaching an animation to a </st><span class="No-Break"><st c="4822">binding value</st></span></li>
			</ul>
			<p><st c="4835">Developers usually get confused and think there’s some duplication here – separate ways to perform the same functionality. </st><st c="4959">But the truth is that all three serve different purposes and needs. </st><st c="5027">It’s up to us to decide the suitable way, according to our specific code structure </st><a id="_idIndexMarker286"/><st c="5110">and flow. </st><st c="5120">Sometimes, you want to perform a particular animation to a specific view; occasionally, it is a shared experience with several views. </st><st c="5254">Understanding the different use cases can help us decide how to perform an </st><span class="No-Break"><st c="5329">animation correctly.</st></span></p>
			<p><st c="5349">Let’s start by adding an animation to a </st><span class="No-Break"><st c="5390">specific view.</st></span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor223"/><st c="5404">Using the animation view modifier</st></h2>
			<p><st c="5438">The animation </st><a id="_idIndexMarker287"/><st c="5453">view modifier goal is to add </st><a id="_idIndexMarker288"/><st c="5482">animation to a specific view when a certain value changes. </st><st c="5541">Here’s an example of using the animation </st><span class="No-Break"><st c="5582">view modifier:</st></span></p>
			<pre class="source-code"><st c="5596">
struct UsingAnimationModifier: View {
    @State var width: CGFloat = 50
    @State var height: CGFloat = 50
    var body: some View {
        ZStack {
            Circle()
                .frame(width:width, height:height)
                .foregroundColor(.blue)
</st><strong class="bold"><st c="5797">                .animation(.easeIn, value: width)</st></strong><st c="5830">
                .onTapGesture {
                    width += 50
                    height += 50
                }
        }
    }
}</st></pre>			<p><st c="5878">The preceding code changes the circle size by adding </st><strong class="source-inline"><st c="5932">50</st></strong><st c="5934"> points to its width and height, and it does that by using the animation view modifier. </st><st c="6022">Note that the animation view modifier has a value parameter – the value the animation modifier monitors for changes. </st><st c="6139">In this case, we use the </st><strong class="source-inline"><st c="6164">width</st></strong> <span class="No-Break"><st c="6169">state variable.</st></span></p>
			<p><st c="6185">The animation </st><a id="_idIndexMarker289"/><st c="6200">view modifier is great for changing </st><a id="_idIndexMarker290"/><st c="6236">a specific view when a specific value changes. </st><st c="6283">However, there are cases where this approach can be confusing. </st><st c="6346">In this case, we define the animation in a specific place in the code but perform the change in another location. </st><st c="6460">Moreover, using the animation view modifie</st><a id="_idTextAnchor224"/><a id="_idTextAnchor225"/><st c="6502">r can be cumbersome if we want to perform </st><span class="No-Break"><st c="6545">multiple animations.</st></span></p>
			<p><st c="6565">If we want to perform multiple changes, we can use the </st><strong class="source-inline"><st c="6621">withAnimation:</st></strong><st c="6635"> function. </st><st c="6646">Let’s see how to </st><span class="No-Break"><st c="6663">utilize it.</st></span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor226"/><st c="6674">Using the withAnimation function</st></h2>
			<p><st c="6707">In its basic form, the </st><strong class="source-inline"><st c="6731">withAnimation:</st></strong><st c="6745"> function takes a closure as a parameter and animates </st><a id="_idIndexMarker291"/><st c="6799">any changes made within that </st><a id="_idIndexMarker292"/><st c="6828">closure. </st><st c="6837">Usually, that’s done with a trigger to an event. </st><st c="6886">Let’s see a simple </st><span class="No-Break"><st c="6905">code example:</st></span></p>
			<pre class="source-code"><st c="6918">
struct UsingWithAnimationFunction: View {
    @State var greenCircleYPosition: CGFloat = 400
    @State var redCircleYPosition: CGFloat = 800
    var body: some View {
        VStack {
            ZStack {
                Circle()
                    .size(width: 100.0, height: 100.0)
                    .foregroundColor(.green)
                    .position(x: 400, y:
                      greenCircleYPosition)
                Circle()
                    .size(width: 100.0, height: 100.0)
                    .foregroundColor(.red)
                    .position(x: 200, y:
                      redCircleYPosition)
            }
            Button("Animate") {
                </st><strong class="bold"><st c="7335">withAnimation {</st></strong>
<strong class="bold"><st c="7350">                    greenCircleYPosition =</st></strong>
<strong class="bold"><st c="7373">                      greenCircleYPosition == 400 ? </st><st c="7404">800 :</st></strong>
<strong class="bold"><st c="7409">                      400</st></strong>
<strong class="bold"><st c="7413">                    redCircleYPosition = redCircleYPosition</st></strong>
<strong class="bold"><st c="7453">                      == 800 ? </st><st c="7463">400 : 800</st></strong>
<strong class="bold"><st c="7472">                }</st></strong><st c="7474">
            }
        }
    }
}</st></pre>			<p><st c="7482">This code example simultaneously animates the positions of two circles when a button is tapped. </st><st c="7579">We can see that, unlike the animation view modifier, by using the </st><strong class="source-inline"><st c="7645">withAnimation:</st></strong><st c="7659"> function, we bind the change to the animation more clearly </st><span class="No-Break"><st c="7719">and simply.</st></span></p>
			<p><st c="7730">Another </st><a id="_idIndexMarker293"/><st c="7739">advantage that </st><strong class="source-inline"><st c="7754">withAnimation:</st></strong><st c="7768"> has is </st><a id="_idIndexMarker294"/><st c="7776">the ability to execute a </st><strong class="bold"><st c="7801">completion code</st></strong><st c="7816"> once an </st><span class="No-Break"><st c="7825">animation ends.</st></span></p>
			<p><st c="7840">Let’s take a look at the following </st><span class="No-Break"><st c="7876">code example:</st></span></p>
			<pre class="source-code"><st c="7889">
struct WithAnimationCompletionBlock: View {
    @State var yPos: CGFloat = 300
    @State var isReset: Bool = false
    var body: some View {
        VStack {
            Circle()
                .foregroundColor(.blue)
                .frame(width: 50, height:50)
                .position(x: 200, y:yPos)
            Button(isReset ? </st><st c="8134">"Reset" : "Start") {
                </st><strong class="bold"><st c="8155">withAnimation</st></strong><st c="8168"> {
                    if isReset {
                        yPos = 300
                    } else {
                        yPos = 500
                    }
               </st><strong class="bold"><st c="8217"> } completion: {</st></strong>
<strong class="bold"><st c="8232">                    isReset.toggle()</st></strong>
<strong class="bold"><st c="8249">                }</st></strong><st c="8251">
            }
        }
    }
}</st></pre>			<p><st c="8259">The code creates a blue circle and a button saying </st><strong class="bold"><st c="8311">Start</st></strong><st c="8316">. Once the user taps the button, the circle </st><a id="_idIndexMarker295"/><st c="8360">animates its position, and at the end, the button title changes to </st><strong class="bold"><st c="8427">Reset</st></strong><st c="8432">. Then, tapping the button brings back the circle, and at </st><a id="_idIndexMarker296"/><st c="8490">the end of the reverse animation, the button title returns </st><span class="No-Break"><st c="8549">to </st></span><span class="No-Break"><strong class="bold"><st c="8552">Start</st></strong></span><span class="No-Break"><st c="8557">.</st></span></p>
			<p><st c="8558">Completion blocks in animations are essential to sync flow stages. </st><st c="8626">For example, collapsing a side drawer and navigating to a new screen at the end is an excellent example of completion </st><span class="No-Break"><st c="8744">block usage.</st></span></p>
			<p><st c="8756">Now, it’s time to bring some more life to </st><span class="No-Break"><st c="8799">our animation.</st></span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor227"/><st c="8813">Bringing some life to our animations with spring animations</st></h2>
			<p><st c="8873">If you have tried out the code examples you have seen so far, you have probably noticed that the </st><a id="_idIndexMarker297"/><st c="8971">animations ran smoothly but were a little bit, well, boring. </st><st c="9032">That’s because the animations ran linearly and were not </st><span class="No-Break"><st c="9088">that interesting.</st></span></p>
			<p><st c="9105">Try adding the following parameter to the </st><span class="No-Break"><st c="9148">previous example:</st></span></p>
			<pre class="source-code"><st c="9165">
withAnimation</st><strong class="bold"><st c="9179">(.bouncy(extraBounce: 0.3))</st></strong><st c="9207"> {
       if isReset {
           yPos = 300
       } else {
           yPos = 500
       }
   } completion: {
       isReset.toggle()
   }
}</st></pre>			<p><st c="9292">In this example, we added </st><strong class="source-inline"><st c="9319">.bouncy(extraBounce: 0.3)</st></strong><st c="9344"> to our </st><strong class="source-inline"><st c="9352">withAnimation</st></strong><st c="9365"> function. </st><st c="9376">Running the code shows the same animation as before, but now, the circle bounces when it reaches the end. </st><st c="9482">It is a small but significant addition – the bounce effect adds a realistic touch to our animation and can improve </st><span class="No-Break"><st c="9597">user engagement.</st></span></p>
			<p><st c="9613">There are </st><a id="_idIndexMarker298"/><st c="9624">several interesting visual transitions we can add to our animations. </st><st c="9693">For example, we can make the bouncing smoother using the </st><strong class="source-inline"><st c="9750">.</st></strong><span class="No-Break"><strong class="source-inline"><st c="9751">smooth</st></strong></span><span class="No-Break"><st c="9758"> function:</st></span></p>
			<pre class="source-code"><st c="9768">
withAnimation(.smooth(extraBounce: 0.3))</st></pre>			<p><st c="9809">We can also make the bouncing snappier by making the animation faster with a small </st><span class="No-Break"><st c="9893">bounce amount:</st></span></p>
			<pre class="source-code"><st c="9907">
withAnimation(.snappy)</st></pre>			<p><st c="9930">It is recommended to look at Apple’s documentation to discover more visual transitions that we can apply easily to our </st><span class="No-Break"><st c="10050">animations: </st></span><a href="https://developer.apple.com/documentation/swiftui/animation"><span class="No-Break"><st c="10062">https://developer.apple.com/documentation/swiftui/animation</st></span></a><span class="No-Break"><st c="10121">.</st></span></p>
			<p><st c="10122">So far, we have performed very basic animations. </st><st c="10172">But modern apps require modern experiences. </st><st c="10216">Let’s move on to some more ways to create </st><span class="No-Break"><st c="10258">advanced animations.</st></span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor228"/><st c="10278">Performing advanced animations</st></h1>
			<p><st c="10309">We mentioned that transitions are great for guidance and navigation, and part of that concept is </st><a id="_idIndexMarker299"/><st c="10407">providing clarity about incoming and leaving views from our canvas. </st><st c="10475">Sliding a view from the bottom can provide a sense of a drawer being opened and closed, and scaling a view can visually represent the progress of an </st><span class="No-Break"><st c="10624">ongoing process.</st></span></p>
			<p><st c="10640">So far, we have discussed how to animate views from one state to another. </st><st c="10715">Now, we will explore transitions – a way to animate views when they appear </st><span class="No-Break"><st c="10790">or disappear.</st></span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor229"/><st c="10803">Performing transitions</st></h2>
			<p><st c="10826">Implementing </st><a id="_idIndexMarker300"/><st c="10840">a view transition is easy – we have some nice built-in transitions to choose from, and if that’s not enough, we can also create a </st><span class="No-Break"><st c="10970">custom transition.</st></span></p>
			<p><st c="10988">Let’s start with some basic, </st><span class="No-Break"><st c="11018">built-in transitions.</st></span></p>
			<h3><st c="11039">Implementing built-in transitions</st></h3>
			<p><st c="11073">To add </st><a id="_idIndexMarker301"/><st c="11081">a transition, we should use the </st><strong class="source-inline"><st c="11113">transition</st></strong><st c="11123"> modifier with the specific view we want to animate, triggering it using the </st><strong class="source-inline"><st c="11200">withAnimation</st></strong><st c="11213"> function we learned about in the </st><em class="italic"><st c="11247">Using the withAnimation </st></em><span class="No-Break"><em class="italic"><st c="11271">function</st></em></span><span class="No-Break"><st c="11279"> section.</st></span></p>
			<p><st c="11288">Here’s a simple example of a slide </st><span class="No-Break"><st c="11324">in transition:</st></span></p>
			<pre class="source-code"><st c="11338">
struct BuiltInTransitionsView: View {
    @State var showSlideText: Bool = false
    var body: some View {
        VStack {
            Button("Slide in text") {
</st><strong class="bold"><st c="11473">                withAnimation {</st></strong><st c="11488">
                    showSlideText.toggle()
                }
            }
            if showSlideText {
                Text("Hello, slided
                  text")</st><strong class="bold"><st c="11561">.transition(.slide)</st></strong><st c="11580">
            }
      }
}</st></pre>			<p><st c="11586">The code example consists of </st><strong class="source-inline"><st c="11616">VStack</st></strong><st c="11622"> with a button and text. </st><st c="11647">We also have a state determining whether the text is visible </st><span class="No-Break"><st c="11708">or hidden.</st></span></p>
			<p><st c="11718">Tapping on the button reveals the text using the </st><strong class="source-inline"><st c="11768">withAnimation</st></strong><st c="11781"> function. </st><st c="11792">But the text </st><a id="_idIndexMarker302"/><st c="11805">also has a transition view modifier that</st><a id="_idTextAnchor230"/><a id="_idTextAnchor231"/><st c="11845"> describes how it is supposed to appear – in this case, using a </st><span class="No-Break"><st c="11909">sliding-in transition.</st></span></p>
			<p><st c="11931">The transition view modifier describes how the view appears and how it is supposed </st><span class="No-Break"><st c="12015">to disappear.</st></span></p>
			<p><st c="12028">The </st><strong class="source-inline"><st c="12033">slide</st></strong><st c="12038"> transition inserts the view by moving it from the leading edge and removing it toward the trailing edge. </st><st c="12144">Note that the slide transition directions cannot be changed, and they are set by the SwiftUI framework. </st><st c="12248">However, there are several more transitions we can use to achieve our </st><span class="No-Break"><st c="12318">desired behavior:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="12335">move</st></strong><st c="12340">: Moves the view in/from a </st><span class="No-Break"><st c="12368">specific edge:</st></span><pre class="source-code"><st c="12382">
Text("Hello, moved text")
                    .transition(.move(edge: .bottom))</st></pre></li>				<li><strong class="source-inline"><st c="12442">scale</st></strong><st c="12448">: Scales the view in a specific amount and from a </st><span class="No-Break"><st c="12499">specific anchor:</st></span><pre class="source-code"><st c="12515">
Text("Hello, scaled text")
                    .transition(.scale(scale: 0.5, anchor: .center))</st></pre></li>				<li><strong class="source-inline"><st c="12591">opacity</st></strong><st c="12599">: Performs a “fade in/out” effect on </st><span class="No-Break"><st c="12637">the view:</st></span><pre class="source-code"><st c="12646">
Text("Hello, opacity text")
                    .transition(.opacity)</st></pre></li>			</ul>
			<p><st c="12696">These types of transitions are well documented in the Apple website and SDK, and we can also try them using the chapter’s </st><span class="No-Break"><st c="12819">GitHub repository.</st></span></p>
			<p><st c="12837">It’s important to note that we can use these transitions to show and hide animations. </st><st c="12924">Yet, in some cases, we might prefer a different animation for hiding compared to showing. </st><st c="13014">Having a different animation for hiding and showing is called an </st><strong class="bold"><st c="13079">asymmetric transition</st></strong><st c="13100">. Let’s </st><a id="_idIndexMarker303"/><st c="13108">see a code example </st><span class="No-Break"><st c="13127">for that:</st></span></p>
			<pre class="source-code"><st c="13136">
Text("Text scaled in. </st><st c="13159">Now it will slide out")
</st><strong class="bold"><st c="13183">  .transition(.asymmetric(insertion: .scale, removal:</st></strong>
<strong class="bold"><st c="13234">    .slide))</st></strong></pre>			<p><st c="13242">This code example performs a </st><strong class="source-inline"><st c="13272">scale</st></strong><st c="13277"> animation for the insertion of text and a </st><strong class="source-inline"><st c="13320">slide</st></strong><st c="13325"> animation for the removal </st><span class="No-Break"><st c="13352">of text.</st></span></p>
			<p><st c="13360">Sometimes, we may want to combine several animations. </st><st c="13415">For example, we may want to scale </st><a id="_idIndexMarker304"/><st c="13449">and slide at the same time. </st><st c="13477">We can do that using the </st><span class="No-Break"><strong class="source-inline"><st c="13502">combined</st></strong></span><span class="No-Break"><st c="13510"> function:</st></span></p>
			<pre class="source-code"><st c="13520">
Text("Scale and slide")
                    </st><strong class="bold"><st c="13545">.transition(.scale.combined(with:</st></strong>
<strong class="bold"><st c="13578">                      .slide))</st></strong></pre>			<p><st c="13586">We can even combine a </st><span class="No-Break"><st c="13609">combined transition!</st></span></p>
			<pre class="source-code"><st c="13629">
.transition(.scale.combined(with: .slide.combined(with:
   .opacity)))</st></pre>			<p><st c="13696">However, if things become too complicated, it could be a sign that we should build a </st><span class="No-Break"><st c="13782">custom transition.</st></span></p>
			<h3><st c="13800">Creating a custom transition</st></h3>
			<p><st c="13829">Building </st><strong class="bold"><st c="13839">custom transitions</st></strong><st c="13857"> gives us complete control and flexibility of how transitions </st><a id="_idIndexMarker305"/><st c="13919">work and is useful when other compound transition methods </st><a id="_idIndexMarker306"/><st c="13977">don’t provide the </st><span class="No-Break"><st c="13995">expected results.</st></span></p>
			<p><st c="14012">The idea of building a custom transition is built around providing two </st><span class="No-Break"><st c="14084">view modifiers:</st></span></p>
			<ul>
				<li><st c="14099">One that represents the </st><em class="italic"><st c="14124">identity</st></em><st c="14132"> state of the view (before we started </st><span class="No-Break"><st c="14170">the transition)</st></span></li>
				<li><st c="14185">One that represents the </st><em class="italic"><st c="14210">active</st></em><st c="14216"> state of the view (after </st><span class="No-Break"><st c="14242">the transition)</st></span></li>
			</ul>
			<p><st c="14257">Both view modifiers must be of the same type so that SwiftUI has the same properties </st><span class="No-Break"><st c="14343">to transition.</st></span></p>
			<p><st c="14357">Let’s create a custom transition that takes a view and inserts it with rotation, opacity, </st><span class="No-Break"><st c="14448">and scale.</st></span></p>
			<p><st c="14458">We will start by creating a view modifier that handles all the </st><span class="No-Break"><st c="14522">three properties:</st></span></p>
			<pre class="source-code"><st c="14539">
struct ViewRotationModifier: ViewModifier {
    let angle: Angle
    let opacity: CGFloat
    let scale: CGFloat
    func body(content: Content) -&gt; some View {
        content
            .rotationEffect(angle)
            .scaleEffect(scale)
            .opacity(opacity)
    }
}</st></pre>			<p><st c="14756">The </st><strong class="source-inline"><st c="14761">ViewRotationModifier</st></strong><st c="14781"> view modifier receives three properties, </st><strong class="source-inline"><st c="14823">angle</st></strong><st c="14828">, </st><strong class="source-inline"><st c="14830">opacity</st></strong><st c="14837">, and </st><strong class="source-inline"><st c="14843">scale</st></strong><st c="14848">, and applies them to the content. </st><st c="14883">This view modifier is like any view modifier we’re </st><span class="No-Break"><st c="14934">accustomed to.</st></span></p>
			<p><st c="14948">Now, we can </st><a id="_idIndexMarker307"/><st c="14961">build our custom transition. </st><st c="14990">If we look at the built-in transitions we covered in the previous </st><em class="italic"><st c="15056">Implementing built-in transitions</st></em><st c="15089"> section and their code’s documentation, we can see that they are from the type </st><strong class="source-inline"><st c="15169">AnyTransition</st></strong><st c="15182">. </st><strong class="source-inline"><st c="15184">AnyTransition</st></strong><st c="15197"> is a struct that describes a SwiftUI transition between </st><span class="No-Break"><st c="15254">two states.</st></span></p>
			<p><st c="15265">Let’s build our </st><span class="No-Break"><strong class="source-inline"><st c="15282">rotate</st></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><st c="15288">AnyTransition</st></strong></span><span class="No-Break"><st c="15302">:</st></span></p>
			<pre class="source-code"><st c="15304">
let rotate = AnyTransition.modifier(
    active: </st><strong class="bold"><st c="15350">ViewRotationModifier</st></strong><st c="15370">(angle: .degrees(360),
      opacity: 0.0, scale: 0.0),
    identity: </st><strong class="bold"><st c="15431">ViewRotationModifier</st></strong><st c="15451">(angle: .degrees(0),
      opacity: 1.0, scale: 1.0)
)</st></pre>			<p><st c="15500">The </st><strong class="source-inline"><st c="15505">AnyTransition</st></strong><st c="15518"> struct we created receives the </st><strong class="source-inline"><st c="15550">active</st></strong><st c="15556"> and </st><strong class="source-inline"><st c="15561">identity</st></strong><st c="15569"> view modifiers, each with </st><span class="No-Break"><st c="15596">different parameters.</st></span></p>
			<p><st c="15617">We can </st><a id="_idIndexMarker308"/><st c="15625">use the new transition in the same way as the </st><span class="No-Break"><st c="15671">built-in transitions:</st></span></p>
			<pre class="source-code"><st c="15692">
struct CustomizedTransitionView: View {
    @State private var showRectangle: Bool = false
    var body: some View {
        VStack {
            Spacer()
            if showRectangle {
                Rectangle()
                    .frame(width: 100, height: 100)
                    .foregroundColor(.blue)
                    </st><strong class="bold"><st c="15907">.transition(rotate)</st></strong><st c="15926">
            }
            Spacer()
            Button("Insert Rectangle") {
                withAnimation {
                    showRectangle.toggle()
                }
            }
        }
    }
}</st></pre>			<p><st c="16015">The preceding code creates a rectangle and a button. </st><st c="16069">Tapping on the button toggles the </st><strong class="source-inline"><st c="16103">showRectangle</st></strong><st c="16116"> state variable, which reveals the rectangle using our </st><span class="No-Break"><st c="16171">new transition.</st></span></p>
			<p><st c="16186">So far, we have discussed great animations that were pretty simple and short. </st><st c="16265">However, if we </st><a id="_idIndexMarker309"/><st c="16280">want to provide more sophisticated animations that may require multiple stages and different timing, </st><strong class="source-inline"><st c="16381">AnyTransition</st></strong><st c="16394"> structure is insufficient. </st><st c="16422">For much more advanced animations, we should try to implement </st><span class="No-Break"><st c="16484">keyframe animations.</st></span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor232"/><st c="16504">Executing keyframe animations</st></h2>
			<p><st c="16534">The idea </st><a id="_idIndexMarker310"/><st c="16544">of </st><strong class="bold"><st c="16547">keyframe animations</st></strong><st c="16566"> in SwiftUI is similar to how they are implemented </st><span class="No-Break"><st c="16617">in UIkit.</st></span></p>
			<p><st c="16626">With </st><a id="_idIndexMarker311"/><st c="16632">keyframe animations, we declare different changes in different properties over time. </st><st c="16717">There are four primary components </st><a id="_idIndexMarker312"/><st c="16751">in </st><span class="No-Break"><st c="16754">keyframe animations:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="16774">Animations properties</st></strong><st c="16796">: A structure that defines the changes we want to perform during the animation phase. </st><st c="16883">For example, the </st><strong class="source-inline"><st c="16900">AnimationsProperties</st></strong><st c="16920"> struct can define the opacity, scale, or color in different </st><span class="No-Break"><st c="16981">animation phases.</st></span></li>
				<li><strong class="source-inline"><st c="16998">KeyFrameAnimator</st></strong><st c="17015">: The keyframe animator defines the different animation tracks we have and what happens with the view in </st><span class="No-Break"><st c="17121">each track.</st></span></li>
				<li><strong class="source-inline"><st c="17132">KeyframeTrack</st></strong><st c="17146">: Each track handles a different animation property and defines the various phases (key frames) for that property. </st><st c="17262">Tracks work in parallel with each other. </st><st c="17303">A keyframe animator can have </st><span class="No-Break"><st c="17332">multiple tracks.</st></span></li>
				<li><strong class="source-inline"><st c="17348">KeyFrame</st></strong><st c="17357">: Defines a single change for a specific property within the </st><span class="No-Break"><st c="17419">keyframe track.</st></span></li>
			</ul>
			<p><st c="17434">With these </st><a id="_idIndexMarker313"/><st c="17446">four primary components, we can build amazing and complex animations. </st><st c="17516">Let’s build our first keyframe animation with SwiftUI, but we’ll start by explaining the concept behind </st><span class="No-Break"><st c="17620">keyframe animations.</st></span></p>
			<h3><st c="17640">Understanding a keyframe animation</st></h3>
			<p><st c="17675">Describing a </st><a id="_idIndexMarker314"/><st c="17689">keyframe animation can be slightly confusing at first, mainly because it is a way to create complex animations. </st><st c="17801">Let’s try to explain it in a diagram (</st><span class="No-Break"><em class="italic"><st c="17839">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="17848">.1</st></em></span><span class="No-Break"><st c="17850">):</st></span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21795_06_1.jpg" alt="Figure 6.1: A key frame animation as a diagram"/><st c="17853"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17894">Figure 6.1: A key frame animation as a diagram</st></p>
			<p><span class="No-Break"><em class="italic"><st c="17940">Figure 6</st></em></span><em class="italic"><st c="17949">.1</st></em><st c="17951"> shows two tracks – scale and opacity – positioned on a timeline. </st><st c="18017">In each track, we see two keyframes. </st><st c="18054">The number inside each keyframe describes the value, and the keyframe length describes its duration. </st><st c="18155">For example, in the scale track, we have two keyframes – the first sets the scale to 0.7, and the second brings it back to 1.0. </st><st c="18283">We can also see that the durations of both the scale and opacity tracks </st><span class="No-Break"><st c="18355">are equal.</st></span></p>
			<p><st c="18365">If you think that that resembles a video editing application such as </st><em class="italic"><st c="18435">iMovie</st></em><st c="18441"> or </st><em class="italic"><st c="18445">Premiere</st></em><st c="18453">, that’s because it is based on the </st><span class="No-Break"><st c="18489">same concept.</st></span></p>
			<p><st c="18502">Let’s try to create a breathing animation using the concept of keyframe animation. </st><st c="18586">A breathing animation mimics the way something breathes, such as a balloon slowly inflating </st><span class="No-Break"><st c="18678">and deflating.</st></span></p>
			<p><st c="18692">Let’s see how to do that </st><span class="No-Break"><st c="18718">in code:</st></span></p>
			<pre class="source-code"><st c="18726">
struct AnimationProperties {
    var scale = 1.0
    var opacity = 1.0
}
struct KeyFrameAnimations: View {
    var body: some View {
        Circle()
            .foregroundColor(.red)
            .frame(width:100, height:100)
            .</st><strong class="bold"><st c="18911">keyframeAnimator</st></strong><st c="18928">(initialValue:
              AnimationProperties(), repeating: true) {
                content, value in
                content
                    .opacity(value.opacity)
                    .scaleEffect(value.scale)
            } </st><strong class="bold"><st c="19064">keyframes</st></strong><st c="19073">: { _ in
                </st><strong class="bold"><st c="19083">KeyframeTrack</st></strong><st c="19096">(\.scale) {
                    </st><strong class="bold"><st c="19109">CubicKeyframe</st></strong><st c="19122">(0.7, duration: 0.8)
                    </st><strong class="bold"><st c="19144">CubicKeyframe</st></strong><st c="19157">(1.0,
                                  duration: 0.8)
                }
                </st><strong class="bold"><st c="19181">KeyframeTrack</st></strong><st c="19194">(\.opacity) {
                    </st><strong class="bold"><st c="19209">CubicKeyframe</st></strong><st c="19222">(0.3, duration: 0.8)
                    </st><strong class="bold"><st c="19244">CubicKeyframe</st></strong><st c="19257">(1.0, duration: 0.8)
                }
            }
    }
}</st></pre>			<p><st c="19286">The code example seems long! </st><st c="19316">However, upon closer examination, we can see that it is not that complex and contains the different components we </st><span class="No-Break"><st c="19430">discussed earlier.</st></span></p>
			<p><st c="19448">Let’s explain </st><a id="_idIndexMarker315"/><st c="19463">what we’ve </st><span class="No-Break"><st c="19474">done here:</st></span></p>
			<ol>
				<li><st c="19484">We created a circle and added a view modifier called </st><strong class="source-inline"><st c="19538">keyframeAnimator</st></strong><st c="19554">, which handles the general animations. </st><st c="19594">We initialized it with the </st><strong class="source-inline"><st c="19621">AnimationProperties</st></strong><st c="19640"> struct that holds the properties we want to modify during the animation phases, and we defined that animator to repeat by passing </st><strong class="source-inline"><st c="19771">true</st></strong><st c="19775"> in the </st><span class="No-Break"><st c="19783">corresponding parameter.</st></span></li>
				<li><st c="19807">The animator has another closure parameter with the content view and the value. </st><st c="19888">That’s where we can </st><em class="italic"><st c="19908">modify our view</st></em><st c="19923"> according to the animation properties. </st><st c="19963">In this example, we changed the view opacity </st><span class="No-Break"><st c="20008">and scale.</st></span></li>
				<li><st c="20018">Right after the closure, we define our tracks. </st><st c="20066">We have two properties we want to change over time, so we’ve created two tracks – one for scale and one for opacity. </st><st c="20183">Because we wanted a </st><em class="italic"><st c="20203">breathing</st></em><st c="20212"> animation, we’ve created two keyframes – one for exhaling (scale down and reduce opacity) and one for inhaling (scale up and </st><span class="No-Break"><st c="20338">increase opacity).</st></span></li>
				<li><st c="20356">We can see that each one of the frames is declared as </st><strong class="source-inline"><st c="20411">CubicKeyframe</st></strong><st c="20424">. Before we explain what </st><strong class="source-inline"><st c="20449">CubicKeyframe</st></strong><st c="20462"> means, let’s talk about keyframes, which are fundamental concepts </st><span class="No-Break"><st c="20529">in animations.</st></span></li>
			</ol>
			<p><st c="20543">A keyframe specifies an object’s state at a particular point in time. </st><st c="20614">The animator’s responsibility is to perform the animations between these keyframes. </st><st c="20698">In a way, it’s like animating a state change, but in this case, we define the different </st><span class="No-Break"><st c="20786">modifications upfront.</st></span></p>
			<p><st c="20808">In the case of SwiftUI’s </st><strong class="source-inline"><st c="20834">keyframeAnimator</st></strong><st c="20850">, the keyframes align with the concept of states – each keyframe defines a change in a specific property </st><span class="No-Break"><st c="20955">over time.</st></span></p>
			<p><st c="20965">In SwiftUI, we have different types of keyframes, each representing a </st><span class="No-Break"><st c="21036">different experience:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="21057">CubicKeyframe</st></strong><st c="21071">: This </st><a id="_idIndexMarker316"/><st c="21079">is the keyframe we used </st><a id="_idIndexMarker317"/><st c="21103">in our code example. </st><strong class="source-inline"><st c="21124">CubicKeyframe</st></strong><st c="21137"> provides </st><a id="_idIndexMarker318"/><st c="21147">a smooth transition to the next keyframe while computing something called </st><strong class="bold"><st c="21221">Catmull-Rom splines</st></strong><st c="21240">. Catmull-Rom splines are curves used in computer animations to provide </st><span class="No-Break"><st c="21312">smooth movement.</st></span></li>
				<li><strong class="source-inline"><st c="21328">SpringKeyframe</st></strong><st c="21343">: This </st><a id="_idIndexMarker319"/><st c="21351">represents a transition </st><a id="_idIndexMarker320"/><st c="21375">that emulates a spring experience, including a </st><span class="No-Break"><st c="21422">bouncy effect.</st></span></li>
				<li><strong class="source-inline"><st c="21436">MoveKeyframe</st></strong><st c="21449">: This </st><a id="_idIndexMarker321"/><st c="21457">type of keyframe modifies </st><a id="_idIndexMarker322"/><st c="21483">the given </st><span class="No-Break"><st c="21493">value immediately.</st></span></li>
				<li><strong class="source-inline"><st c="21511">LinearKeyframe</st></strong><st c="21526">: This </st><a id="_idIndexMarker323"/><st c="21534">keyframe animates </st><a id="_idIndexMarker324"/><st c="21552">the change without a defined curve and, instead, does that in a simple </st><span class="No-Break"><st c="21623">linear interpolation.</st></span></li>
			</ul>
			<p><st c="21644">SwiftUI is </st><a id="_idIndexMarker325"/><st c="21656">intelligent enough to smoothly handle the combination of different keyframes on the same track. </st><st c="21752">For example, let’s see what happens when we define velocity on one of </st><span class="No-Break"><st c="21822">our keyframes:</st></span></p>
			<pre class="source-code"><st c="21836">
CubicKeyframe(0.5, duration: 0.2, </st><strong class="bold"><st c="21871">startVelocity</st></strong><st c="21884">: 0.5,
  </st><strong class="bold"><st c="21892">endVelocity</st></strong><st c="21903">: 0.8)
CubicKeyframe(0.7, duration: 0.5)</st></pre>			<p><st c="21944">We can see that the end velocity of the first keyframe is </st><strong class="source-inline"><st c="22003">0.8</st></strong><st c="22006">. However, we haven’t defined any initial velocity for the second keyframe. </st><st c="22082">In this case, the second keyframe’s </st><strong class="source-inline"><st c="22118">startVelocity</st></strong><st c="22131"> value will be the end value of the previous keyframe, which </st><span class="No-Break"><st c="22192">means </st></span><span class="No-Break"><strong class="source-inline"><st c="22198">0.8</st></strong></span><span class="No-Break"><st c="22201">.</st></span></p>
			<p><st c="22202">Now, let’s discuss another crucial aspect of keyframe animations – </st><span class="No-Break"><st c="22270">animation duration.</st></span></p>
			<h3><st c="22289">Handling keyframe animation duration</st></h3>
			<p><st c="22326">The keyframe animator is a hierarchal structure with three levels – the animator, the tracks, and the keyframe. </st><st c="22439">This means that different keyframes can have different durations, and these duration values don’t always add up nicely. </st><st c="22559">That makes duration management complex, especially for long and </st><span class="No-Break"><st c="22623">intricate animations.</st></span></p>
			<p><st c="22644">How do we </st><a id="_idIndexMarker326"/><st c="22655">ensure that all the keyframe durations are always aligned with each other and maintain the same scale? </st><st c="22758">The answer is to use relative duration, not </st><span class="No-Break"><st c="22802">absolute duration.</st></span></p>
			<p><st c="22820">An absolute duration specifies the exact time an animation should take, regardless of the initial state, or without comparing it to the </st><span class="No-Break"><st c="22957">other keyframes.</st></span></p>
			<p><st c="22973">Conversely, relative duration reflects the duration time, considering the total animation duration. </st><st c="23074">For example, if the relative duration is 0.5 and the total animation duration is 3 seconds, the actual keyframe duration would be 1.5 (0.5 * </st><span class="No-Break"><st c="23215">3.0 seconds).</st></span></p>
			<p><st c="23228">By using relative duration, we can establish an animation’s overall duration and allocate specific durations for each keyframe, relative to the </st><span class="No-Break"><st c="23373">total duration.</st></span></p>
			<p><st c="23388">Let’s take our “breathing” example and try to implement </st><span class="No-Break"><st c="23445">relative duration:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="23463">let duration: TimeInterval = 1.8</st></strong><st c="23496">
    var body: some View {
        Circle()
            .foregroundColor(.red)
            .frame(width:100, height:100)
            .keyframeAnimator(initialValue:
              AnimationProperties(), repeating: true) {
              content, value in
                content
                    .opacity(value.opacity)
                    .scaleEffect(value.scale)
            } keyframes: { _ in
                KeyframeTrack(\.scale) {
                    CubicKeyframe(0.7, </st><strong class="bold"><st c="23795">duration: 0.5 *</st></strong>
<strong class="bold"><st c="23810">                      duration</st></strong><st c="23819">)
                    CubicKeyframe(1.0,
                      duration: </st><strong class="bold"><st c="23851">0.5 * duration</st></strong><st c="23865">)
                }
                KeyframeTrack(\.opacity) {
                    CubicKeyframe(0.3, </st><strong class="bold"><st c="23916">duration: 0.5 *</st></strong>
<strong class="bold"><st c="23931">                      duration</st></strong><st c="23940">)
                    CubicKeyframe(1.0, </st><strong class="bold"><st c="23962">duration: 0.5 *</st></strong>
<strong class="bold"><st c="23977">                      duration</st></strong><st c="23986">)
                }
            }</st></pre>			<p><st c="23992">In this code example, we have a keyframe animation with two keyframes, similar to our previous example. </st><st c="24097">The first keyframe handles the scale animation, and the second handles </st><span class="No-Break"><st c="24168">the opacity.</st></span></p>
			<p><st c="24180">We can see </st><a id="_idIndexMarker327"/><st c="24192">that we have a total duration variable, currently set to </st><strong class="source-inline"><st c="24249">1.8</st></strong><st c="24252">. With each keyframe, we set the duration relative to that value. </st><st c="24318">In this case, it is </st><strong class="source-inline"><st c="24338">0.5</st></strong><st c="24341"> of the total duration, but this can vary from one example </st><span class="No-Break"><st c="24400">to another.</st></span></p>
			<p><st c="24411">Relative duration can help us set a dynamic overall duration time and change it according to our needs, even </st><span class="No-Break"><st c="24521">at runtime.</st></span></p>
			<p><st c="24532">SwiftUI animations are extremely powerful and easy to use, and keyframe animations make them even more powerful by allowing us to build complex animations with multiple steps </st><span class="No-Break"><st c="24708">and durations.</st></span></p>
			<p><st c="24722">However, in many cases, animating views is one of the many challenges that app developers face. </st><st c="24819">After all, animating simple shapes such as a rectangle or a circle isn’t always what we desire. </st><st c="24915">So, what about the assets? </st><st c="24942">Fortunately, the iOS SDK contains a fantastic resource called SF Symbols. </st><st c="25016">Let’s explore </st><span class="No-Break"><st c="25030">it now.</st></span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor233"/><st c="25037">Animating SF Symbols</st></h1>
			<p><strong class="bold"><st c="25058">SF Symbols</st></strong><st c="25069"> is a library that </st><a id="_idIndexMarker328"/><st c="25088">contains over 5,000 symbols that developers can integrate within their text, using the </st><em class="italic"><st c="25175">San </st></em><span class="No-Break"><em class="italic"><st c="25179">Francisco</st></em></span><span class="No-Break"><st c="25188"> font.</st></span></p>
			<p><st c="25194">Don’t be </st><a id="_idIndexMarker329"/><st c="25204">confused – SF Symbols are not emojis. </st><st c="25242">Emojis are meant to express feelings and emotions within text. </st><st c="25305">Conversely, SF Symbols are excellent replacements for icons that represent states, actions, </st><span class="No-Break"><st c="25397">and tools.</st></span></p>
			<p><st c="25407">Here’s a basic example of displaying a clock alarm symbol with text next </st><span class="No-Break"><st c="25481">to it:</st></span></p>
			<pre class="source-code"><st c="25487">
var body: some View {
        HStack {
            </st><strong class="bold"><st c="25519">Image(systemName:</st></strong>
<strong class="bold"><st c="25536">              "alarm.waves.left.and.right.fill")</st></strong><st c="25571">
            Text("Alarm")
        }.font(.system(size: 30))
    }</st></pre>			<p><st c="25613">We can see no surprises here – we use a basic </st><strong class="source-inline"><st c="25660">Image</st></strong><st c="25665"> view with the </st><strong class="source-inline"><st c="25680">systemName</st></strong><st c="25690"> parameter to provide the </st><span class="No-Break"><st c="25716">image name.</st></span></p>
			<p><st c="25727">As mentioned earlier in this section, there are thousands of symbols available. </st><st c="25808">To get the full symbols catalog, we need </st><a id="_idIndexMarker330"/><st c="25849">to download a Mac application called </st><em class="italic"><st c="25886">SF Symbols</st></em><st c="25896"> (what a coincidence, uh?) </st><span class="No-Break"><st c="25923">from </st></span><a href="https://developer.apple.com/sf-symbols/"><span class="No-Break"><st c="25928">https://developer.apple.com/sf-symbols/</st></span></a><span class="No-Break"><st c="25967">.</st></span></p>
			<p><st c="25968">The app is simple to use, as we can see in </st><span class="No-Break"><em class="italic"><st c="26012">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="26020">.2</st></em></span><span class="No-Break"><st c="26022">:</st></span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B21795_06_2.jpg" alt="Figure 6.2: The SF Symbol Mac app"/><st c="26024"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27085">Figure 6.2: The SF Symbol Mac app</st></p>
			<p><st c="27118">By exploring </st><a id="_idIndexMarker331"/><st c="27132">the SF Symbol app, we can see how the symbols differ from emojis. </st><st c="27198">They are not only vector illustrations (meaning they can scale to any size) but also built </st><span class="No-Break"><st c="27289">as layers.</st></span></p>
			<p><st c="27299">To understand why the SF symbols contain layers, try to perform a bounce animation using the app. </st><st c="27398">Doing so lets us see how the layers create a </st><em class="italic"><st c="27443">sense of depth</st></em><st c="27457">, making them bounce at </st><span class="No-Break"><st c="27481">different intervals.</st></span></p>
			<p><st c="27501">Other than the bounce effect, SF Symbols supports other effects such as pulse, scale, and replace. </st><st c="27601">We can perform the same animations in our SwiftUI code using the </st><strong class="source-inline"><st c="27666">symbolEffect</st></strong> <span class="No-Break"><st c="27678">view modifier:</st></span></p>
			<pre class="source-code"><st c="27693">
struct SFSymbolsAnimationView: View {
    @State private var animate = false
    var body: some View {
        HStack {
            Image(systemName:
              "alarm.waves.left.and.right.fill")
                </st><strong class="bold"><st c="27851">.symbolEffect(.bounce, options: .repeating,</st></strong>
<strong class="bold"><st c="27894">                  value: animate)</st></strong><st c="27910">
            Text("10:30")
        }.font(.system(size: 40))
            .onTapGesture {
            animate = true
        }
    }
}</st></pre>			<p><st c="27987">The </st><strong class="source-inline"><st c="27992">symbolEffect</st></strong><st c="28004"> view modifier has several parameters. </st><st c="28043">The first is the </st><strong class="source-inline"><st c="28060">effect</st></strong><st c="28066"> type, the same as those found in the SF Symbol app. </st><st c="28119">The second parameter is </st><strong class="source-inline"><st c="28143">options</st></strong><st c="28150"> – we can make the effect repeat itself or even set </st><span class="No-Break"><st c="28202">its speed.</st></span></p>
			<p><st c="28212">The third </st><a id="_idIndexMarker332"/><st c="28223">parameter is the </st><strong class="source-inline"><st c="28240">value</st></strong><st c="28245"> parameter – the state variable that triggers the animation. </st><st c="28306">In this case, we trigger the animation by tapping on the </st><strong class="source-inline"><st c="28363">HStack</st></strong><st c="28369"> view that contains both the symbol and the </st><span class="No-Break"><st c="28413">attached text.</st></span></p>
			<p><st c="28427">To read more about SF Symbols, it is recommended to visit Apple’s </st><span class="No-Break"><st c="28494">website:</st></span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://developer.apple.com/sf-symbols/"><span class="No-Break"><st c="28502">https://developer.apple.com/sf-symbols/</st></span></a><span class="No-Break"><st c="28542">.</st></span></p>
			<p><st c="28543">Even though this chapter mainly concerns SwiftUI animations, there is much more to SF Symbols than just animations, such as supporting multiple colors. </st><st c="28696">Let’s see how we can modify different </st><span class="No-Break"><st c="28734">symbol colors.</st></span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor234"/><st c="28748">Modifying symbol colors</st></h2>
			<p><st c="28772">The fact </st><a id="_idIndexMarker333"/><st c="28782">that SF Symbols are built with different layers helps not only with animation but also with </st><span class="No-Break"><st c="28874">coloring them.</st></span></p>
			<p><st c="28888">Let’s take, for instance, the </st><em class="italic"><st c="28919">two persons </st></em><span class="No-Break"><em class="italic"><st c="28931">waving</st></em></span><span class="No-Break"><st c="28937"> symbol:</st></span></p>
			<pre class="source-code"><st c="28945">
Image(systemName: "person.2.wave.2")</st></pre>			<p><span class="No-Break"><em class="italic"><st c="28982">Figure 6</st></em></span><em class="italic"><st c="28991">.3</st></em><st c="28993"> shows what the symbol </st><span class="No-Break"><st c="29016">looks like:</st></span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B21795_06_3.jpg" alt="Figure 6.3: The person.2.wave.2 symbol"/><st c="29027"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29029">Figure 6.3: The person.2.wave.2 symbol</st></p>
			<p><st c="29067">We can see two different types of image components – on the one hand, two people, and on the </st><a id="_idIndexMarker334"/><st c="29161">other hand, their waves. </st><st c="29186">So, unlike a regular image, we can set one color for the people and another for </st><span class="No-Break"><st c="29266">the waves.</st></span></p>
			<p><st c="29276">Every SF Symbol has a </st><strong class="bold"><st c="29299">primary</st></strong><st c="29306"> and </st><strong class="bold"><st c="29311">secondary</st></strong><st c="29320"> color, and SwiftUI knows how to color </st><span class="No-Break"><st c="29359">it accordingly.</st></span></p>
			<p><st c="29374">For example, let’s set a primary color of brown and a secondary color of blue. </st><st c="29454">We will use the </st><strong class="source-inline"><st c="29470">foregroundStyle</st></strong><st c="29485"> view modifier </st><span class="No-Break"><st c="29500">for that:</st></span></p>
			<pre class="source-code"><st c="29509">
Image(systemName: "person.2.wave.2")
                .foregroundStyle(.brown, .blue)</st></pre>			<p><st c="29578">There are symbols that even have a third color, such as in the case of the three-person symbol (</st><span class="No-Break"><em class="italic"><st c="29675">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="29684">.4</st></em></span><span class="No-Break"><st c="29686">):</st></span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B21795_06_4.jpg" alt="Figure 6.4: The person.3.sequence.fill symbol"/><st c="29689"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29691">Figure 6.4: The person.3.sequence.fill symbol</st></p>
			<p><st c="29736">To use the third color, we just need to add one more color as </st><span class="No-Break"><st c="29799">a parameter:</st></span></p>
			<pre class="source-code"><st c="29811">
Image(systemName: "person.3.sequence.fill")
                .foregroundStyle(.red, .blue, .</st><strong class="bold"><st c="29887">brown</st></strong><st c="29893">)</st></pre>			<p><st c="29895">Anyone who has had to manage multi-color icons knows the complexity of supporting different themes and colors, especially when we need to </st><span class="No-Break"><st c="30033">animate them.</st></span></p>
			<p><st c="30046">So, we know </st><a id="_idIndexMarker335"/><st c="30059">how to add an SF Symbol, animate it nicely, and color it. </st><st c="30117">However, we can also use vector multi-layer symbols, which is known </st><span class="No-Break"><st c="30185">as localization.</st></span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor235"/><st c="30201">Localizing our symbols</st></h2>
			<p><st c="30224">Localizing our apps is a crucial topic today, more than ever. </st><st c="30287">However, how many of us pay attention </st><a id="_idIndexMarker336"/><st c="30325">to icon localization and try to adjust them according to the app </st><span class="No-Break"><st c="30390">layout direction?</st></span></p>
			<p><st c="30407">The excellent news about SF Symbols is that they can adjust to the current app locale. </st><st c="30495">The even better news is that we can force them to do that if </st><span class="No-Break"><st c="30556">we want.</st></span></p>
			<p><st c="30564">But why do SF Symbols even need to </st><span class="No-Break"><st c="30600">support localization?</st></span></p>
			<p><st c="30621">Let’s take the </st><strong class="source-inline"><st c="30637">arrowshape.turn.up.forward</st></strong><st c="30663"> SF Symbol (</st><span class="No-Break"><em class="italic"><st c="30675">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="30684">.5</st></em></span><span class="No-Break"><st c="30686">):</st></span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B21795_06_5.jpg" alt="Figure 6.5: The arrowshap.turn.up.forward SF Symbol"/><st c="30689"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30691">Figure 6.5: The arrowshap.turn.up.forward SF Symbol</st></p>
			<p><st c="30742">The forward </st><a id="_idIndexMarker337"/><st c="30755">icon arrow points to the right, which fits </st><a id="_idIndexMarker338"/><st c="30798">nicely in </st><strong class="bold"><st c="30808">LTR</st></strong><st c="30811"> (</st><strong class="bold"><st c="30813">Left-to-Right</st></strong><st c="30826">) layout views. </st><st c="30843">But what about </st><strong class="bold"><st c="30858">RTL</st></strong><st c="30861"> (</st><strong class="bold"><st c="30863">Right-to-Left</st></strong><st c="30876">) layouts, such as in Hebrew or Arabic </st><span class="No-Break"><st c="30916">localized applications?</st></span></p>
			<p><st c="30939">Well, in this case, we will have to flip the icon direction. </st><st c="31001">With SF Symbol, this adjustment is done automatically </st><span class="No-Break"><st c="31055">for us.</st></span></p>
			<p><st c="31062">Moreover, we can set the icon localization regardless of the view settings, using the </st><strong class="source-inline"><st c="31149">environment</st></strong> <span class="No-Break"><st c="31160">view modifier:</st></span></p>
			<pre class="source-code"><st c="31175">
Image(systemName: "arrowshape.turn.up.forward")
</st><strong class="bold"><st c="31224">.environment(\.layoutDirection, .rightToLeft)</st></strong></pre>			<p><st c="31269">In the preceding code, we force the SF Symbol to have an RTL layout direction, which flips the forward arrow to the </st><span class="No-Break"><st c="31386">left direction.</st></span></p>
			<p><st c="31401">Having localization </st><a id="_idIndexMarker339"/><st c="31422">support doesn’t stop with layout direction. </st><st c="31466">Some symbols even change their look according to the </st><span class="No-Break"><st c="31519">current locale.</st></span></p>
			<p><st c="31534">For example, let’s take the </st><strong class="source-inline"><st c="31563">character.book.closed</st></strong><st c="31584"> SF Symbol (</st><span class="No-Break"><em class="italic"><st c="31596">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="31605">.6</st></em></span><span class="No-Break"><st c="31607">):</st></span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B21795_06_6.jpg" alt="Figure 6.6: The character.book.closed SF Symbol"/><st c="31610"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31612">Figure 6.6: The character.book.closed SF Symbol</st></p>
			<p><st c="31659">In the case of the symbol in </st><span class="No-Break"><em class="italic"><st c="31689">Figure 6</st></em></span><em class="italic"><st c="31697">.6</st></em><st c="31699">, we can see that in addition to its layout direction (LTR), it also has a letter </st><span class="No-Break"><st c="31781">on it.</st></span></p>
			<p><st c="31787">In the case of the Hebrew locale, not only does the symbol’s direction change but also the letter (</st><span class="No-Break"><em class="italic"><st c="31887">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="31896">.7</st></em></span><span class="No-Break"><st c="31898">):</st></span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21795_06_7.jpg" alt="Figure 6.7: The character.book.closed SF Symbol in a Hebrew locale"/><st c="31901"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31903">Figure 6.7: The character.book.closed SF Symbol in a Hebrew locale</st></p>
			<p><st c="31969">We can force the symbol to retrieve a specific locale using the </st><strong class="source-inline"><st c="32034">environment</st></strong><st c="32045"> view modifier, similar to the </st><span class="No-Break"><st c="32076">layout direction:</st></span></p>
			<pre class="source-code"><st c="32093">
Image(systemName: "character.book.closed")
                </st><strong class="bold"><st c="32137">.environment(\.locale, .init(identifier: "he"))</st></strong></pre>			<p><st c="32184">To sum up, SF Symbols </st><a id="_idIndexMarker340"/><st c="32207">contain so much power and valuable features. </st><st c="32252">Trying to support standard icons in different environments, such as locales and themes, can be a hassle, and animating them without creating a dedicated image sequence is almost impossible. </st><st c="32442">So, getting all these features for free is l</st><a id="_idTextAnchor236"/><a id="_idTextAnchor237"/><st c="32486">ike a massive present from </st><span class="No-Break"><st c="32514">Apple engineers.</st></span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor238"/><st c="32530">Summary</st></h1>
			<p><st c="32538">iOS animations are like salt – they can enhance the user experience, but too much </st><span class="No-Break"><st c="32621">is overwhelming.</st></span></p>
			<p><st c="32637">The great thing about SwiftUI animations is that they are aligned to the screen state because of the declarative implementation. </st><st c="32767">However, it’s a significant change to how they work </st><span class="No-Break"><st c="32819">in UIkit.</st></span></p>
			<p><st c="32828">Because of that, in this chapter, we went from understanding the basic concepts and performing fundamental animations to custom transitions and keyframe animations, and we even discussed a great present that Apple gave us, </st><span class="No-Break"><st c="33052">SF Symbols.</st></span></p>
			<p><st c="33063">Now, we should be able to easily animate changes on our screen in a meaningful and </st><span class="No-Break"><st c="33147">expressive way!</st></span></p>
			<p><st c="33162">In our next chapter, we’ll explore enhancing user engagement using a built-in solution – </st><span class="No-Break"><st c="33252">TipKit.</st></span></p>
		</div>
	<div id="charCountTotal" value="33259"/></body></html>