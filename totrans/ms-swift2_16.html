<html><head></head><body><div class="chapter" title="Chapter&#xA0;16.&#xA0;Network Development with Swift"><div class="titlepage"><div><div><h1 class="title"><a id="ch16"/>Chapter 16. Network Development with Swift</h1></div></div></div><p>I took several networking courses when I was in college, and I still recall setting up my first Novell NetWare network in one of those courses. I was absolutely fascinated to see and learn how computers communicated over the network. Then, in the early 90s, I bought my first modem and started dialing into bulletin board services that were local to me. This was really exciting because now I could connect to bulletin board services that were located in the city that I lived in. This allowed me to download and upload files from these bulletin board services, and I started downloading everything I could find that talked about how computers communicated. This led to my early career in network security and administration. Then, when my first daughter was born, I decided that I did not want to be on call all the time, so I went back to what got me into computers in the first place, which was programming. However, I still really enjoyed the field of networking and network security. My background in both networking and programming has given me a unique understanding of both. What constitutes networking today (the Internet and TCP/IP networks) is completely different to what constituted networking back when I was in college, but the good thing is how our applications communicate over the network has become much more standardized, which makes it easier to write applications that communicate over a network.</p><p>In this chapter, you will learn the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to make an HTTP GET request using the <code class="literal">NSURLSession</code> API</li><li class="listitem" style="list-style-type: disc">How to make an HTTP POST request using the <code class="literal">NSURLSession</code> API</li><li class="listitem" style="list-style-type: disc">How to use the System Configuration API to check our network connection</li><li class="listitem" style="list-style-type: disc">How to use the <code class="literal">RSNetworking2</code> library to easily add network functionality to your applications</li></ul></div><div class="section" title="What is network development?"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec93"/>What is network development?</h1></div></div></div><p>Network development<a class="indexterm" id="id687"/> is writing code that will allow our application to send and receive data from remote services or devices. In the introduction of this chapter, I mentioned buying my first modem and connecting with bulletin board services across the city that I lived in. The large majority of these bulletin board services used a single modem, which meant that only one user could connect to them at any one time. These bulletin boards would seem very strange and archaic for those that grew up with the Internet; however, back then, they were how computers shared information. At that time, being able to connect to a computer across town and upload/download files was amazing. Today, however, we communicate with services and devices all over the world without thinking twice about it.</p><p>Back then when I first started writing applications, it was rare to develop an application that communicated over a networked connection, and it was also hard to find developers with experience in network development. In today's world, just about every application has a requirement for some sort of network communication.</p><p>In this chapter, we will show you how to connect to <span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>)-based web services. Representational State Transfer is the software architectural style of the World Wide Web. Typically, these services communicate over HTTP using the same HTTP verbs (get, put, delete, and post) which web browsers use.</p><p>In this chapter, we will use the REST-based service that Apple supplies, which lets developers search the iTunes Store. We will be using Apple's service for several examples in this chapter. Apple has documented this service very well. The documentation can be<a class="indexterm" id="id688"/> found at <a class="ulink" href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html</a>.</p><p>If you would like a more detailed discussion on network development, I would recommend you to read my first book, titled <span class="emphasis"><em>iOS and OS X Network Programming Cookbook</em></span>, by <span class="emphasis"><em>Packt Publishing</em></span>. In this chapter, we will be focusing on how to connect to the standard REST-based services.</p><p>Before we look at how to connect to REST services, let's look at the classes in Apple's networking API that we will be using. These classes are part of Apple's powerful URL loading system.</p></div></div>
<div class="section" title="An overview of the URL session classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec94"/>An overview of the URL session classes</h1></div></div></div><p>Apple's URL loading <a class="indexterm" id="id689"/>system is a framework of classes available to interact with URLs. Using these classes together lets us communicate with services that use standard Internet protocols. The classes that we will be using in this chapter to connect to and retrieve information from REST services are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSession</code>: This is the<a class="indexterm" id="id690"/> main session object. It was written as a replacement for the older <code class="literal">NSURLConnection</code> API.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSessionConfiguration</code>: This<a class="indexterm" id="id691"/> is used to configure the behavior of the <code class="literal">NSURLSession</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSessionTask</code>: This is a<a class="indexterm" id="id692"/> base class to handle the data being retrieved from the URL. Apple provides three concrete subclasses of the <code class="literal">NSURLSessionTask</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSURL</code>: This is an object<a class="indexterm" id="id693"/> that represents the URL to connect to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSMutableURLRequest</code>: This <a class="indexterm" id="id694"/>class contains information about the request that we are making<a class="indexterm" id="id695"/> and is used by the <code class="literal">NSURLSessionTask</code> service to make the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSHTTPURLResponse</code>: This<a class="indexterm" id="id696"/> class contains the response to our request.</li></ul></div><p>Now, let's look at each of these classes a little more in depth so that we have a basic understanding of what each does.</p><div class="section" title="NSURLSession"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec146"/>NSURLSession</h2></div></div></div><p>Prior to iOS 7 and OS X 10.9, when a developer wanted to retrieve contents from a URL, he/she used the <code class="literal">NSURLConnection</code> API. Starting with iOS 7 and OS X 10.9, <code class="literal">NSURLSession</code> became<a class="indexterm" id="id697"/> the preferred API. The <code class="literal">NSURLSession</code> API can be thought of as an improvement to the older <code class="literal">NSURLConnection</code> API.</p><p>An <code class="literal">NSURLSession</code> object<a class="indexterm" id="id698"/> provides an API for interacting with various protocols such as HTTP and HTTPS. The session object, which is an instance of the <code class="literal">NSURLSession</code>, manages this interaction. These session objects are highly configurable, which allows us to control how our requests are made and how we handle the data that is returned.</p><p>Like most networking API, <code class="literal">NSURLSession</code> is asynchronous. This means that we have to provide a way to return the response from the service back to the code that needs it. The most popular way to return the results from a session is to pass a completion handler block (closure) to the session. This completion handler is then called when the service successfully responds or we receive an error. All of the examples in this chapter use completion handlers to process the data that is returned from the services.</p></div><div class="section" title="NSURLSessionConfiguration"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec147"/>NSURLSessionConfiguration</h2></div></div></div><p>The <code class="literal">NSURLSessionConfiguration</code> class <a class="indexterm" id="id699"/>defines the behavior and policies to use when using the <code class="literal">NSURLSession</code> object to connect to a URL. When using the <code class="literal">NSURLSession</code> object, we usually create <a class="indexterm" id="id700"/>an <code class="literal">NSURLSessionConfiguration</code> instance first because an instance of this class is required when we create an instance of the <code class="literal">NSURLSession</code> class.</p><p>The <code class="literal">NSURLSessionConfiguration</code> class defines three session types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Default session configuration</strong></span>: This configuration behaves similar to the <code class="literal">NSURLConnection</code> <a class="indexterm" id="id701"/>API</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ephemeral session configuration</strong></span>: This configuration behaves similar to the default session <a class="indexterm" id="id702"/>configuration, except that it does not cache anything to disk</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background session configuration</strong></span>: This session allows for uploads and downloads to be<a class="indexterm" id="id703"/> performed, even when the app is running in the background</li></ul></div><p>It is important to note<a class="indexterm" id="id704"/> that we should make sure that we configure the <code class="literal">NSURLSessionConfiguration</code> object appropriately before we use it to create an instance of the <code class="literal">NSURLSession</code> class. When the session object is created, it creates a copy of the configuration object that we provided it. Any changes made to the configuration object once the session object is created are ignored by the session. If we need to make changes to the configuration, we must create another instance of the <code class="literal">NSURLSession</code> class.</p></div><div class="section" title="NSURLSessionTask"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec148"/>NSURLSessionTask</h2></div></div></div><p>The <code class="literal">NSURLSession</code> service uses<a class="indexterm" id="id705"/> an instance of the <code class="literal">NSURLSessionTask</code> classes to make the call to the service that we are connecting to. The <code class="literal">NSURLSessionTask</code> class is a base class, and Apple has provided three concrete subclasses<a class="indexterm" id="id706"/> that we can use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSessionDataTask</code>: This returns the response, in memory, directly to the application as one <a class="indexterm" id="id707"/>or more <code class="literal">NSData</code> objects. This is the task that we generally use most often.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSessionDownloadTask</code>: This <a class="indexterm" id="id708"/>writes the response directly to a temporary file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSURLSessionUploadTask</code>: This is<a class="indexterm" id="id709"/> used for making requests that require a request body such as a POST or PUT request.</li></ul></div><p>It is important to note that a task will not send the request to the service until we call the <code class="literal">resume()</code> method.</p></div><div class="section" title="Using the NSURL class"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec149"/>Using the NSURL class</h2></div></div></div><p>The <code class="literal">NSURL</code> object<a class="indexterm" id="id710"/> represents the URL that we are going to connect to. The <code class="literal">NSURL</code> class is not limited to URLs that represent remote servers, but it <a class="indexterm" id="id711"/>can also be used to represent a local file on disk. In this chapter, we will be using the <code class="literal">NSURL</code> class exclusively to represent the URL of the remote service that we are connecting to.</p></div><div class="section" title="NSMutableURLRequest"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec150"/>NSMutableURLRequest</h2></div></div></div><p>The <code class="literal">NSMutableURLRequest</code> class is a mutable subclass of the <code class="literal">NSURLRequest</code> class, which represents a URL <a class="indexterm" id="id712"/>load request. We use the <a class="indexterm" id="id713"/>
<code class="literal">NSMutableRequest</code> class to encapsulate our URL and the request properties.</p><p>It is important to understand that the <code class="literal">NSMutableURLRequest</code> class is used to encapsulate the necessary information to make our request, but it does not make the actual request. To make the request, we use instances of the <code class="literal">NSURLSession</code> and <code class="literal">NSURLSessionTask</code> classes.</p></div><div class="section" title="NSURLHTTPResponse"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec151"/>NSURLHTTPResponse</h2></div></div></div><p>The <code class="literal">NSURLHTTPResponse</code> <a class="indexterm" id="id714"/>class is a subclass of the <code class="literal">NSURLResponse</code> class that encapsulates the metadata associated with the response to a URL request. The <code class="literal">NSURLHTTPResponse</code> class provides methods for accessing specific<a class="indexterm" id="id715"/> information associated with an HTTP response. Specifically, this class allows us to access the HTTP header fields and the response status codes.</p><p>We briefly covered a number of classes in this section and it may not be clear how they all actually fit together; however, once you see the examples a little further in this chapter, it will become much clearer. Before we go into our examples, let's take a quick look at the type of service that we will be connecting to.</p></div></div>
<div class="section" title="REST web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec95"/>REST web services</h1></div></div></div><p>REST has become one<a class="indexterm" id="id716"/> of the most important technologies for stateless communications between devices. Due to the lightweight and stateless nature of the REST-based services, its importance is likely to continue to grow as more devices are connected to the Internet.</p><p>REST is an architecture style for designing networked applications. The idea behind REST is that instead of using complex mechanisms, such as SOAP or CORBA to communicate between devices, we use simple HTTP requests for the communication. While, in theory, REST is not dependent on the Internet protocols, it is almost always implemented using them. Therefore, when we are accessing REST services, we are almost always interacting with web servers in the same way that our web browsers interact with these servers.</p><p>REST web services use the HTTP POST, GET, PUT, or DELETE methods. If we think about a standard CRUD (create/read/update/delete) application, we would use a POST request to create or update data, a GET request to read data, and a DELETE request to delete data.</p><p>When we type a URL into our browser's address bar and hit <span class="emphasis"><em>Enter</em></span>, we are generally making a GET request to the server and asking it to send us the web page associated with that URL. When we fill out a web form and click the submit button, we are generally making a POST request to the server. We then include the parameters from the web form in the body of our POST request.</p><p>Now, let's look at how to make an HTTP GET request using Apple's networking API.</p></div>
<div class="section" title="Making an HTTP GET request"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec96"/>Making an HTTP GET request</h1></div></div></div><p>In this example, we<a class="indexterm" id="id717"/> will make a GET request to Apple's iTunes search API to get a list of items related to the search term Jimmy Buffett. Since we are retrieving data from the service, by REST standards, we should use a GET request to retrieve the data.</p><p>While the REST standard is to use GET requests to retrieve data from a service, there is nothing stopping a developer of a web service from using a GET request to create or update a data object. It is not recommended to use a GET request in this manner, but just be aware that there are services out there that do not adhere to the REST standards.</p><p>The following code makes a request to Apple's iTunes search API and then prints the results to the console:</p><div class="informalexample"><pre class="programlisting">public typealias dataFromURLCompletionClosure = (NSURLResponse!, NSData!) -&gt; Void
    
public func sendGetRequest(handler: public func getConnect(
        handler: dataFromURLCompletionClosure) {
            
        let sessionConfiguration =
          NSURLSessionConfiguration.defaultSessionConfiguration();
        
        let urlString =
            "https://itunes.apple.com/search?term=jimmy+buffett"
        
        if let encodeString =
     urlString.stringByAddingPercentEncodingWithAllowedCharacters(
                NSCharacterSet.URLQueryAllowedCharacterSet()),
            url = NSURL(string: encodeString) {
        
            let request = NSMutableURLRequest(URL:url)
            request.HTTPMethod = "GET"
            let urlSession = NSURLSession(
                configuration:sessionConfiguration, delegate: nil,
 delegateQueue: nil)
            
            let sessionTask = 
urlSession.dataTaskWithRequest(request) {
                (data, response, error) in
                
                handler(response, data)
            }
            sessionTask.resume()
        }
    }</pre></div><p>We start off by creating a type alias named <code class="literal">DataFromURLCompletionClosure</code>. The <code class="literal">DataFromURLCompletionClosure</code> type will be used for both the GET and POST examples of this chapter. If you are not familiar with using a <code class="literal">typealias</code> object to define a closure type, please refer to <a class="link" href="ch12.html" title="Chapter 12. Working with Closures">Chapter 12</a>, <span class="emphasis"><em>Working with Closures</em></span>, for more information.</p><p>We then create a<a class="indexterm" id="id718"/> function named <code class="literal">sendGetRequest()</code> that will be used to make the GET request to Apple's iTunes API. This function accepts one argument named handler, which is a closure that conforms to the <code class="literal">DataFromURLCompletionClosure</code> type. The handler closure will be used to return the results from the request.</p><p>Within our <code class="literal">sendGetRequest()</code> method, we begin by creating an instance of the <code class="literal">NSURLSessionConfiguration</code> class using the <code class="literal">defaultSessionConfiguration()</code> method, which creates a default session configuration instance. If we need to, we can modify the session configuration properties after we create it, but in this example, the default configuration is what we want.</p><p>After we create our session configuration, we create the URL string. This is the URL of the service we are connecting to. With a GET request, we put our parameters in the URL itself. In this specific example, <code class="literal">https://itunes.apple.com/search</code> is the URL of the web service. We then follow the web service URL with a question mark (<code class="literal">?</code>), which indicates that the rest of the URL string consists of parameters for the web service.</p><p>The parameters take the form of key/value pairs, which means that each parameter has a key and a value. The key and value of a parameter, in a URL, are separated by an equals sign (<code class="literal">=</code>). In our example, the key is <code class="literal">term</code> and the value is <code class="literal">jimmy+buffett</code>. Next, we run the URL string that we just created through the <code class="literal">stringByAddingPercentEncodingWithAllowedCharacters()</code> method to make sure our URL string is encoded properly. We use the <code class="literal">URLQueryAllowedCharacterSet</code> character set with this method to ensure we have a valid URL string.</p><p>Next, we use the URL string that we just built to create an <code class="literal">NSURL</code> instance named <code class="literal">url</code>. Since we are making a GET request, this <code class="literal">NSURL</code> instance will represent both the location of the web service and the parameters that we are sending to it.</p><p>We create an instance of the <code class="literal">NSMutableURLRequest</code> class using the <code class="literal">NSURL</code> instance that we just created. We use the <code class="literal">NSMutableURLRequest</code> class, instead of the <code class="literal">NSURLRequest</code> class so that we can set the properties needed for our request. In this example, we set the <code class="literal">HTTPMethod</code> <a class="indexterm" id="id719"/>property; however, we can also set other properties such as the timeout interval or add items to our HTTP header.</p><p>Now, we use the <code class="literal">sessionConfiguration</code> variable (instance of the <code class="literal">NSURLSessionConfiguration class</code>) that we created at the beginning of the <code class="literal">sendGetRequest()</code> function to create an instance of the <code class="literal">NSURLSession</code> class. The <code class="literal">NSURLSession</code> class provides the API that we will use to connect to Apple's iTunes search API. In this example, we use the <code class="literal">dataTaskWithRequest()</code> method of the <code class="literal">NSURLSession</code> instance to return an instance of the <code class="literal">NSURLSessionDataTask</code> instance named <code class="literal">sessionTask</code>.</p><p>The <code class="literal">sessionTask</code> instance is what makes the request to the iTunes search API. When we receive the response from the service, we use the handler callback to return both the <code class="literal">NSURLResponse</code> object and the <code class="literal">NSData</code> object. The <code class="literal">NSURLResponse</code> contains information about the response, and the <code class="literal">NSData</code> instance contains the body of the response.</p><p>Finally, we call the <code class="literal">resume()</code> method of the <code class="literal">NSURLSessionDataTask</code> instance to make the request to the web service. Remember, as we mentioned earlier, an <code class="literal">NSURLSessionTask</code> instance will not send the request to the service until we call the <code class="literal">resume()</code> method.</p><p>Now, let's look at how we would call the <code class="literal">sendGetRequest()</code> function. The first thing we need to do is to create a closure that will be passed to the <code class="literal">sendGetRequest()</code> function and called when the response from the web service is received. In this example, we will simply print the response to the console. Since the response is in the JSON format, we could use the <code class="literal">NSJSONSerialization</code> class, as describe in <a class="link" href="ch08.html" title="Chapter 8. Working with XML and JSON Data">Chapter 8</a>, <span class="emphasis"><em>Working with XML and JSON Data</em></span>, to parse the response; however, since this chapter is on networking, we will simply print the response to the console. Here is the code:</p><div class="informalexample"><pre class="programlisting">var printResultsClosure: HttpConnect.DataFromURLCompletionClosure = {

  if let data = $1 {
    let sString = NSString(data: data, encoding: NSUTF8StringEncoding)
    print(sString)
  }
}</pre></div><p>We define this closure, named <code class="literal">printResultsClosure</code>, to be an instance of the <code class="literal">DataFromURLCompletionClosure</code> type. Within the closure, we unwrap the first parameter and set the value to a constant named <code class="literal">data</code>. If the first parameter is not nil, we convert the data constant to an instance of the <code class="literal">NSString</code> class, which is then printed to the console.</p><p>Now, let's call the <code class="literal">sendGetRequest()</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">let aConnect = HttpConnect()
aConnect.sendGetRequest(printResultsClosure)</pre></div><p>This code creates an instance of the <code class="literal">HttpConnect</code> class and then calls the <code class="literal">sendGetRequest()</code> method, passing the <code class="literal">printResultsClosure</code> closure as the only parameter. If we run this code while we are connected to the Internet, we will receive a JSON response that<a class="indexterm" id="id720"/> contains a list of items related to Jimmy Buffett on iTunes.</p><p>Now that we have seen how to make a simple HTTP GET request, let's look at how we would make an HTTP POST request to a web service.</p></div>
<div class="section" title="Making an HTTP POST request"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec97"/>Making an HTTP POST request</h1></div></div></div><p>Since Apple's iTunes, APIs <a class="indexterm" id="id721"/>use GET requests to retrieve data. In this section, we will use the free <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> service to show you how to make a POST request. The POST service that <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> provides can be found at <a class="ulink" href="http://httpbin.org/post">http://httpbin.org/post</a>. This service will echo back the parameters that it receives so that we can verify that our request was made properly.</p><p>When we make a POST<a class="indexterm" id="id722"/> request, we generally have some data that we want to send or post to the server. This data takes the form of key/value pairs. These pairs are separated by an ampersand (<code class="literal">&amp;</code>) symbol, and each key is separated from its value by an equals sign (<code class="literal">=</code>). As an example, let's say that we want to submit the following data to our service:</p><div class="informalexample"><pre class="programlisting">firstname: Jon
lastname: Hoffman
age: 47 years</pre></div><p>The body of the POST request would take the following format:</p><div class="informalexample"><pre class="programlisting">firstname=Jon&amp;lastname=Hoffman&amp;age=47</pre></div><p>Once we have the data in the proper format, we will then use the <code class="literal">dataUsingEncoding()</code> method, as we did with the GET request to properly encode the POST data.</p><p>Since the data going to the server is in the key/value format, the most appropriate way to store this data, prior to sending it to the service, is with a <code class="literal">Dictionary</code> object. With this in mind, we will need to create a method that will take a <code class="literal">Dictionary</code> object and return a string object that can be used for the POST request. The following code will do that:</p><div class="informalexample"><pre class="programlisting">func dictionaryToQueryString(dict: [String : String]) -&gt; String {
  var parts = [String]()
  for (key, value) in dict {
    let part: String = key + "=" + value
    parts.append(part);
  }
  return parts.joinWithSeparator("&amp;")
}</pre></div><p>This function<a class="indexterm" id="id723"/> loops through each key/value pair of the <code class="literal">Dictionary</code> object and creates a <code class="literal">String</code> object that contains the key and the value separated by the equals sign (<code class="literal">=</code>). We then use the <code class="literal">joinWithSeperator()</code> function to join each item in the array, separated by the specified sting. In our case, we want to separate each string with the ampersand symbol (<code class="literal">&amp;</code>). We then return this newly created string to the code that called it.</p><p>Now, let's create our <code class="literal">sendPostRequest()</code> function that will send the <a class="indexterm" id="id724"/>POST request to the <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> post service. We will see a lot of similarities between this <code class="literal">sendPostRequest()</code> function and the <code class="literal">sendGetRequest()</code> function, which we showed you in the <span class="emphasis"><em>Making an HTTP GET request</em></span> section of this chapter. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">public func sendPostRequest(handler: dataFromURLCompletionClosure) {
        
        let sessionConfiguration =
        NSURLSessionConfiguration.defaultSessionConfiguration()
        
        let urlString = "http://httpbin.org/post"
        if let encodeString =
            urlString.stringByAddingPercentEncodingWithAllowedCharacters(
                NSCharacterSet.URLQueryAllowedCharacterSet()),
            url = NSURL(string: encodeString) {
            
            let request = NSMutableURLRequest(URL:url)
            request.HTTPMethod = "POST"
            let params = dictionaryToQueryString(["One":"1 and 1", "Two":"2 and 2"])
            request.HTTPBody = params.dataUsingEncoding(
                NSUTF8StringEncoding, allowLossyConversion: true)
                
            let urlSession = NSURLSession(
                configuration:sessionConfiguration, delegate: nil, delegateQueue: nil)
            
            let sessionTask = urlSession.dataTaskWithRequest(request) {
                (data, response, error) in
                
                handler(response, data)
            }
            sessionTask.resume()
        }
    }</pre></div><p>Now, let's walk though this code. Notice that we are using the same type alias, named <code class="literal">DataFromURLCompletionClosure</code>, that we used with the <code class="literal">sendGetRequest()</code> function. If you are not familiar with using a <code class="literal">typealias</code> object to define a closure type, please refer to <a class="link" href="ch12.html" title="Chapter 12. Working with Closures">Chapter 12</a>, <span class="emphasis"><em>Working with Closures</em></span>, for more information.</p><p>The <code class="literal">sendPostRequest()</code> function accepts one argument named <code class="literal">handler</code>, which is a closure that conforms to the <code class="literal">DataFromURLCompletionClosure</code> type. The handler closure will be used to process the data from the <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> service once the service<a class="indexterm" id="id725"/> responds to our request.</p><p>Within our <code class="literal">sendPostRequest()</code> method, we start off by creating an instance of the <code class="literal">NSURLSessionConfiguration</code> class using the <code class="literal">defaultSessionConfiguration()</code> method, which creates a default session configuration instance. We are able to modify the session configuration properties after we create it, but, in this example, the default configuration is what we want.</p><p>After we created our session configuration, we create our URL string. This is the URL of the service we are connecting to. In this example, the URL is <a class="ulink" href="http://httpbin.org/post">http://httpbin.org/post</a>. Next, we run the URL string that we just created through the <code class="literal">stringByAddingPercentEncodingWithAllowedCharacters()</code> method to make sure our URL string is encoded properly. We use the <code class="literal">URLQueryAllowedCharacterSet</code> character set with this method to ensure we have a valid URL string.</p><p>Next, we use the URL string that we just built to create an instance of the <code class="literal">NSURL</code> class named <code class="literal">url</code>. Since this is a POST request, this <code class="literal">NSURL</code> instance will represent the location of the web service that we are connecting to.</p><p>We now create an instance of the <code class="literal">NSMutableURLRequest</code> class using the <code class="literal">NSURL</code> instance that we just created. We use the <code class="literal">NSMutableURLRequest</code> class, instead of the <code class="literal">NSURLRequest</code> class so that we can set the properties needed for our request. In this example, we set the <code class="literal">HTTPMethod</code> property; however, we can also set other properties such as the timeout interval or add items to our HTTP header.</p><p>Now, we use our <code class="literal">dictionaryToQueryString()</code> function, which we showed you at the beginning of this section, to build the data that we are going to post to the server. We use the <code class="literal">dataUsingEncoding()</code> function to make sure that our data is properly encoded prior to sending it to the server, and finally, the data is added to the <code class="literal">HTTPBody</code> property of the <code class="literal">NSMutableURLRequest</code> instance.</p><p>We use the <code class="literal">sessionConfiguration</code> variable (instance of the <code class="literal">NSURLSessionConfiguration class</code>) that we created at the beginning of the function to create an instance of the <code class="literal">NSURLSession</code> class. The <code class="literal">NSURLSession</code> class provides the API that we will use to connect to the post <a class="indexterm" id="id726"/>on <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> post service. In this example, we use the <code class="literal">dataTaskWithRequest()</code> method of the <code class="literal">NSURLSession</code> instance to return an instance of the <code class="literal">NSURLSessionDataTask</code> class named <code class="literal">sessionTask</code>.</p><p>The <code class="literal">sessionTask</code> instance is what makes the request to the <a class="ulink" href="http://httpbin.org">http://httpbin.org</a> POST service. When<a class="indexterm" id="id727"/> we receive the response from the service, we use the handler callback to return both the <code class="literal">NSURLResponse</code> object and the <code class="literal">NSData</code> object. The <code class="literal">NSURLResponse</code> contains information about the response, and the <code class="literal">NSData</code> instance contains the body of the response.</p><p>Finally, we call the <code class="literal">resume()</code> method of the <code class="literal">NSURLSessionDataTask</code> instance to make the request to the web service. Remember, as we mentioned earlier, an <code class="literal">NSURLSessionTask</code> class will not send the request to the service until we call the <code class="literal">resume()</code> method.</p><p>We can then call the <code class="literal">sendPostRequest()</code> method in exactly the same way that we called the <code class="literal">sendGetRequest()</code> method.</p><p>When developing applications that communicate to other devices and services over the Internet, it is good practice to verify that we have a network connection. When developing mobile applications, it is also good practice to verify that we are not using a mobile connection (3G, 4G, and so on) to transfer large amounts of data.</p><p>Let's look at <a class="indexterm" id="id728"/>how to verify that we have a network connection and what type of connection we have.</p></div>
<div class="section" title="Checking network connection"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec98"/>Checking network connection</h1></div></div></div><p>As we create <a class="indexterm" id="id729"/>applications that communicate with other devices and services over the Internet, eventually, we will want to verify that we have a network connection prior to making the network calls. Another thing to consider when we are writing mobile applications is the type of network connection that the user has. As mobile application developers, we need to keep in mind that our users probably have a mobile data plan that limits the amount of data they can send/receive in a month. If they exceed that limit, they may have to pay an extra fee. If our application sends large amounts of data, it might be appropriate to warn our user prior to sending this data if they are on a cellular network.</p><p>This next example will show us how we can verify that we have a network connection and it also tells us what type of connection we have. We will begin by importing the system configuration API and also defining an enum that contains the different connection types. We will import the system configuration API like this:</p><div class="informalexample"><pre class="programlisting">import SystemConfiguration</pre></div><p>We create a <code class="literal">ConnectionType</code> enum. This enum will be used as the return type for <code class="literal">networkConnectionType()</code>:</p><div class="informalexample"><pre class="programlisting">public enum ConnectionType {
    case NONETWORK
    case MOBILE3GNETWORK
    case WIFINETWORK
}</pre></div><p>Now, let's look<a class="indexterm" id="id730"/> at the code to check the network connection type:</p><div class="informalexample"><pre class="programlisting">public func networkConnectionType(hostname: NSString) -&gt; ConnectionType {
        
    let reachabilityRef = SCNetworkReachabilityCreateWithName(nil,hostname.UTF8String)
        
    var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags()
        SCNetworkReachabilityGetFlags(reachabilityRef!, &amp;flags)
        
    let reachable: Bool = (flags.rawValue &amp; SCNetworkReachabilityFlags.Reachable.rawValue) != 0
    let needsConnection: Bool = (flags.rawValue &amp; SCNetworkReachabilityFlags.ConnectionRequired.rawValue) != 0
    if reachable &amp;&amp; !needsConnection {
        // what type of connection is available
        let isCellularConnection = (flags.rawValue &amp; SCNetworkReachabilityFlags.IsWWAN.rawValue) != 0
        if isCellularConnection {
            // cellular connection available
            return ConnectionType.MOBILE3GNETWORK 
        } else {
            // wifi connection available
            return ConnectionType.WIFINETWORK 
        }
    }
    return ConnectionType.NONETWORK // no connection at all
}</pre></div><p>The <code class="literal">networkConnectionType()</code> function begins by creating a <code class="literal">SCNetworkReachability</code> reference. To create the <code class="literal">SCNetworkRechabilityRef</code> reference, we use the <code class="literal">SCNetworkReachabilityCreateWithName()</code> function, which creates a reachability reference to the host provided.</p><p>After we get our <code class="literal">SCNetworkReachabilityRef</code> reference, we need to retrieve the <code class="literal">SCNetworkReachabilityFlags</code> enum from the reference. This is done with the <code class="literal">SCNetworkReachabilityGetFlags()</code> function.</p><p>Once we have the network reachability flags, we can begin testing our connection. We use the bitwise AND (<code class="literal">&amp;</code>) operator to see whether the host is reachable and if we need to establish a connection before we can connect to the host (<code class="literal">needsConnection</code>). If the reachable flag<a class="indexterm" id="id731"/> is false (we cannot currently connect to the host), or if <code class="literal">needsConnection</code> is true (we need to establish a connection before we can connect), we return <code class="literal">NONETWORK</code>, which means the host is currently not reachable.</p><p>If we are able to connect to the host, we then check to see whether we have a cellular connection by checking the network reachability flags again. If we have a cellular connection, we return <code class="literal">MOBILE3GNETWORK</code>, otherwise, we assume we have a Wi-Fi connection and return <code class="literal">WIFINETWORK</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>If you are writing applications that connect to other devices or services over the Internet, I would recommend putting this function in a standard library to use because you will want to check for networking connectivity, and also the type of connection that you have pretty regularly.</p></div></div><p>Now that we have seen how to use Apple's networking APIs to connect to remote services, I would like to demonstrate a network library that you can use in your own applications. This network library makes it very easy and simple to connect to various types of services on the Internet. This is a library that I created and maintained, but I would definitely welcome anyone that would like to contribute to the code base. This library is called<a class="indexterm" id="id732"/> <span class="strong"><strong>RSNetworking</strong></span>.</p></div>
<div class="section" title="RSNetworking2 for Swift 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec99"/>RSNetworking2 for Swift 2</h1></div></div></div><p>You can find <a class="indexterm" id="id733"/>
<code class="literal">RSNetworking2</code> on GitHub with <a class="ulink" href="https://github.com/hoffmanjon/RSNetworking2">https://github.com/hoffmanjon/RSNetworking2</a>
</p><p>The <code class="literal">RSNetworking2</code> library is a<a class="indexterm" id="id734"/> network library written entirely in the Swift programming language. <code class="literal">RSNetworking2</code> is built using Apple's powerful URL <a class="indexterm" id="id735"/>loading system (<a class="ulink" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html</a>), which features the <code class="literal">NSURLSession</code> class that we used earlier in this chapter. The main design goal of <code class="literal">RSNetworking2</code> is to make it easy and quick for developers to add powerful asynchronous networking requests to their applications that are written in Swift.</p><p>There are the three ways in which we can use <code class="literal">RSNetworking2</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RSURLRequest</code>: This API <a class="indexterm" id="id736"/>provides a very simple and easy interface to make single GET requests to a service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RSTransaction</code> and <code class="literal">RSTransactionRequest</code>: These APIs provide a very powerful and<a class="indexterm" id="id737"/> flexible way to make both GET and POST <a class="indexterm" id="id738"/>requests to a service. This API also makes it very easy to make multiple requests to a service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Extensions</code>: <code class="literal">RSNetworking2</code> provides extensions to both the <code class="literal">UIImageView</code> and <code class="literal">UIButton</code> <a class="indexterm" id="id739"/>classes to dynamically load images from a URL and insert them into the <code class="literal">UIImageView</code> or <code class="literal">UIButton</code> classes after they are loaded.</li></ul></div><p>Let's look at each<a class="indexterm" id="id740"/> of these APIs in greater detail and then provide some examples of how<a class="indexterm" id="id741"/> to use them.</p><div class="section" title="RSURLRequest"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec152"/>RSURLRequest</h2></div></div></div><p>With the<a class="indexterm" id="id742"/> <code class="literal">RSURLRequest</code> API, we can make a GET request to a service and the only thing we need to provide is the URL and the parameters we<a class="indexterm" id="id743"/> wish to send to the service. The <code class="literal">RSURLRequest</code> API exposes four functions. These functions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dataFromURL(url: NSURL, completionHandler handler: RSNetworking.dataFromURLCompletionClosure)</code>: This retrieves an <code class="literal">NSData</code> object <a class="indexterm" id="id744"/>from a URL. This is the main function and is used by the other three functions to retrieve an <code class="literal">NSData</code> object prior to converting it to the requested format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stringFromURL(url: NSURL, completionHandler handler: RSNetworking.stringFromURLCompletionClosure)</code>: This retrieves an <code class="literal">NSString</code> object from a<a class="indexterm" id="id745"/> URL. This function uses the <code class="literal">dataFromURL()</code> function to retrieve an <code class="literal">NSData</code> object and then converts it to an <code class="literal">NSString</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dictionaryFromJsonURL(url: NSURL, completionHandler handler: RSNetworking.dictionaryFromURLCompletionClosure)</code>: This retrieves an <code class="literal">NSDictionary</code> object from a URL. This function uses the <code class="literal">dataFromURL()</code> function<a class="indexterm" id="id746"/> to retrieve an <code class="literal">NSData</code> object and then converts it to an <code class="literal">NSDictionary</code> object. The data returned from the URL should be in the JSON format for this function to work properly.</li><li class="listitem" style="list-style-type: disc"><code class="literal">imageFromURL(url: NSURL, completionHandler handler: RSNetworking.imageFromURLCompletionClosure)</code>: This retrieves a <code class="literal">UIImage</code> object<a class="indexterm" id="id747"/> from a URL. This function uses the <code class="literal">dataFromURL()</code> function to retrieve an <code class="literal">NSData</code> object and then converts it to a <code class="literal">UIImage</code> object.</li></ul></div><p>Now, let's look at an example on how to use the <code class="literal">RSURLRequest</code> API. In this example, we will make a request to Apple's iTunes search API, as we did in the <span class="emphasis"><em>Making an HTTP GET request</em></span> section<a class="indexterm" id="id748"/> of this chapter:</p><div class="informalexample"><pre class="programlisting">func rsURLRequestExample() {
  var client = RSURLRequest()
  
  if let testURL =     NSURL(string:"https://itunes.apple.com/search?term=jimmy+buffett&amp;m edia=music") {
    
      client.dictionaryFromJsonURL(testURL, completionHandler: resultsHandler)   
  }
}</pre></div><p>Let's walk through this code. We begin by creating an instance of the <code class="literal">RSURLRequest</code> class and an instance of the <code class="literal">NSURL</code> class. The <code class="literal">NSURL</code> instance represents the URL of the service that we wish to connect to and since we are making a GET request, it also contains the parameters that we are sending to the service. If we recall from the previous <span class="emphasis"><em>Making an HTTP GET Request</em></span> section, when we make a HTTP GET request, the parameters that we are sending to the service are contained within the URL itself.</p><p>Apple's iTunes search API returns the results of the search in the JSON format. We can see that in the <a class="indexterm" id="id749"/>API documentation and also by printing out the results of the search to the console; therefore, we will use the <code class="literal">dictionaryFromJsonURL()</code> method of the <code class="literal">RSURLRequest</code> class to make our request to the service. We could also use the <code class="literal">dataFromURL()</code> or <code class="literal">stringFromURL()</code> methods to retrieve the data if we wanted to, but this method is specifically written to handle JSON data that is returned form a REST-based web service.</p><p>The <code class="literal">dictionaryFromJsonURL()</code> method will take the data that is returned from the <code class="literal">NSURLSession</code> request and convert it to an <code class="literal">NSDictionary</code> object. We use the <code class="literal">NSDictionary</code> object here rather than Swift's <code class="literal">Dictionary</code> object because the web service could return multiple types (Strings, Arrays, Numbers, and so on), and if we recall, a Swift <code class="literal">Dictionary</code> object can have only a single type for the key and a single type for the value.</p><p>When we call the <code class="literal">dictionaryFromJsonURL()</code> method, we pass the URL that we want to connect to and also a completion handler that will be called once the information from the service is returned and converted to an <code class="literal">NSDicationary</code> object.</p><p>Now, let's look at our completion handler:</p><div class="informalexample"><pre class="programlisting">var resultsHandler:RSURLRequestRSURLRequestRSURLRequestRSURLRequest.dictionaryFromURLCompletionClosure = {
  var response = $0
  var responseDictionary = $1
  var error = $2
  if error == nil {
    let res = "results"
    if let results = responseDictionary[res] as? NSArray {
      print(results[0])
      
    }
    else {
      print("Problem with data")
    }
  }
  else {
    //If there was an error, log it
    print("Error : \(error)")
  }
}</pre></div><p>Our completion handler is of the <code class="literal">RSURLRequest.dictionaryFromURLCompletionClosure</code> type. This type is defined in the same way as the <code class="literal">RSTransactionRequest.dictionaryFromRSTransactionCompletionClosure type</code>, which allows us to use this same closure for the <code class="literal">RSURLRequests</code> and <code class="literal">RSTransactionRequest</code> requests.</p><p>We begin the completion handler by retrieving the three parameters that were passed and assign them to the <code class="literal">response</code>, <code class="literal">responseDictionary</code>, and <code class="literal">error</code> variables. We then check the <code class="literal">error</code> variable to see whether it is <code class="literal">nil</code>. If it is <code class="literal">nil</code>, we received a valid response and can retrieve values for the <code class="literal">NSDictionary</code> object.</p><p>In this example, we<a class="indexterm" id="id750"/> retrieve the <code class="literal">NSArray</code> value that is associated with the <code class="literal">results</code> key in the <code class="literal">NSDictionary</code> object that was returned from the service. This <code class="literal">NSArray</code> value will contain a list of items in the iTunes store that are associated with our search term. Once we have the <code class="literal">NSArray</code> value, we print out the first element of the array to the console.</p><p>The <code class="literal">RSURLRequest</code> API is very good for making single GET requests to a service. Now, let's look at the <code class="literal">RSTransaction</code> and <code class="literal">RSTransactionRequest</code> APIs, which can be used for both POST and GET requests and should be used when we need to make multiple requests to the same service.</p></div><div class="section" title="RSTransaction and RSTransactionRequest"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lvl2sec153"/>RSTransaction and RSTransactionRequest</h2></div></div></div><p>The <code class="literal">RSTransaction</code><a class="indexterm" id="id751"/> and <code class="literal">RSTransactionRequest</code> classes<a class="indexterm" id="id752"/> allow us to configure a transaction (<code class="literal">RSTransaction</code>) and then use that transaction to make a request (<code class="literal">RSTransactionRequest</code>) to the service. One of the things that make, this API so powerful is how easy it is for us to make subsequent request by simply <a class="indexterm" id="id753"/>updating the<a class="indexterm" id="id754"/> transaction and resubmitting it. Let's look at the API that is exposed by these two classes.</p><div class="section" title="RSTransaction"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl3sec35"/>RSTransaction</h3></div></div></div><p>The <code class="literal">RSTransaction</code> <a class="indexterm" id="id755"/>class defines the transaction we wish to make. It exposes four properties and one initiator.</p><p>The properties are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TransactionType</code>: This<a class="indexterm" id="id756"/> defines the HTTP request method. Currently, there are three types defined—GET, POST, and UNKNOWN. Only the GET and POST actually send a request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">baseURL</code>: This is the base URL to use for the request. This will normally look something<a class="indexterm" id="id757"/> like <a class="ulink" href="https://itunes.apple.com">https://itunes.apple.com</a>. If we are using a nonstandard port, we would follow the server URL by a<a class="indexterm" id="id758"/> colon and the port number such as <code class="literal">http://mytestserver:8080</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">path</code>: This is the path that<a class="indexterm" id="id759"/> will be added to the base URL. This will be something like <code class="literal">search</code>. It can also include a longer path string such as <code class="literal">path/to/my/service</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">parameters</code>: This is<a class="indexterm" id="id760"/> a <code class="literal">Dictionary</code> object containing the parameters to send to the service.</li></ul></div><p>The initiator is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">init(transactionType: RSTransactionType, baseURL: String, path: String, parameters: [String: String])</code>: This will initialize the <code class="literal">RSTransaction</code> class with all the required properties</li></ul></div></div><div class="section" title="RSTransactionRequest"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl3sec36"/>RSTransactionRequest</h3></div></div></div><p>The <code class="literal">RSTransactionRequest</code> class builds and sends out the request that is defined by the four functions, which<a class="indexterm" id="id761"/> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dataFromRSTransaction(transaction: RSTransaction, completionHandler handler: RSNetworking.dataFromRSTransactionCompletionCompletionClosure)</code>: This function<a class="indexterm" id="id762"/> retrieves an <code class="literal">NSData</code> object from the service defined by the <code class="literal">RSTransaction</code> class. This is the main function and is used by the other three functions to retrieve the <code class="literal">NSData</code> object prior to converting it to the requested format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stringFromRSTransaction(transaction: RSTransaction, completionHandler handler: RSNetworking.stringFromRSTransactionCompletionCompletionClosure)</code>: This function<a class="indexterm" id="id763"/>fn-= retrieves an <code class="literal">NSString</code> object from the service defined by the <code class="literal">RSTransaction</code> class. This function uses the <code class="literal">dataFromRSTransaction()</code> function to retrieve the <code class="literal">NSData</code> object and then converts it to an <code class="literal">NSString</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dictionaryFromRSTransaction(transaction: RSTransaction, completionHandler handler: RSNetworking.dictionaryFromRSTransactionCompletionCompletionClosure)</code>: This<a class="indexterm" id="id764"/> function retrieves an<a class="indexterm" id="id765"/> <code class="literal">NSDictionary</code> object from the service defined by the <code class="literal">RSTransaction</code> class. This function uses the <code class="literal">dataFromRSTransaction()</code> function to retrieve the <code class="literal">NSData</code> object and then converts it to an <code class="literal">NSDictionary</code> object. The data returned from the URL should be in<a class="indexterm" id="id766"/> the JSON format for this function to work properly.</li><li class="listitem" style="list-style-type: disc"><code class="literal">imageFromRSTransaction(transaction: RSTransaction, completionHandler handler: RSNetworking.imageFromRSTransactionCompletionCompletionClosure)</code>: This function<a class="indexterm" id="id767"/> retrieves a <code class="literal">UIImage</code> object from the service defined by the <code class="literal">RSTransaction</code> class. This function uses the <code class="literal">dataFromRSTransaction()</code> function to retrieve the <code class="literal">NSData</code> object and then converts it to a <code class="literal">UIImage</code> object.</li></ul></div><p>Now, let's look at an example of how we would use the <code class="literal">RSTransaction</code> and <code class="literal">RSTransactionRequest</code> classes to make a GET request to Apple's iTunes search API. In this example, we will use the same <code class="literal">resultsHandler</code> closure that we defined in the <span class="emphasis"><em>RSURLRequest</em></span> section of this chapter. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">func rsTransactionExample() {
  
  let rsRequest = RSTransactionRequest()

   //First request
  let rsTransGet = RSTransaction(transactionType: RSTransactionType.GET, baseURL: "https://itunes.apple.com", path: "search", parameters: ["term":"jimmy+buffett", "media":"music"])
  rsRequest.dictionaryFromRSTransaction(rsTransGet, completionHandler: resultsHandler)
  
  //Second request  
  rsTransGet.parameters = ["term":"jim", "media":"music"]
  rsRequest.dictionaryFromRSTransaction(rsTransGet, completionHandler: resultsHandler)
}</pre></div><p>In this example, we begin by creating an instance of the <code class="literal">RSTransactionRequest</code> class named <code class="literal">rsRequest</code>. This <code class="literal">RSTransactionRequest</code> instance will be used to send our request to the service defined in our <code class="literal">RSTransaction</code> instance.</p><p>After we create the <code class="literal">RSTransactionRequest</code> instance, we use the <code class="literal">RSTransaction</code> initiator to create an instance of the <code class="literal">RSTransction</code> class named <code class="literal">rsTransGet</code>. In this initiator, we define<a class="indexterm" id="id768"/> the following properties as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">transactionType</code>: The <code class="literal">transactionType</code> is set to <code class="literal">RSTransactionType</code>.GET (this can <a class="indexterm" id="id769"/>also be <code class="literal">RSTransactionType</code>.POST or <code class="literal">RSTransactionType</code>. UNKNOWN)</li><li class="listitem" style="list-style-type: disc"><code class="literal">baseURL</code>: The <code class="literal">baseURL</code> is<a class="indexterm" id="id770"/> set to <a class="ulink" href="https://itunes.apple.com">https://itunes.apple.com</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">path</code>: The <code class="literal">path</code> is set to<a class="indexterm" id="id771"/> search</li><li class="listitem" style="list-style-type: disc"><code class="literal">parameters</code>: The parameter <a class="indexterm" id="id772"/>is set to <code class="literal">["term":"jimmy+buffett","media":"music"]</code></li></ul></div><p>Finally, we use the <code class="literal">dictionaryFromRSTransaction()</code> method of the <code class="literal">RSTransactionRequest</code> instance. This method accepts two parameters; the first being the <code class="literal">RSTransaction</code> instance that defines the transaction to send and the second being the completion handler that will be called once the data is returned from the service.</p><p>As we mentioned earlier, one of the things that makes the <code class="literal">RSTransaction</code> and <code class="literal">RSTransactionRequest</code> classes so nice to use is how easy it is to make subsequent requests to the same service. In our example, after we make the initial request, we then change the parameters and make a second request to the same service. One thing to watch out for is that since these are asynchronous requests, if we make two back-to-back requests like this, we cannot guarantee which request will be returned first.</p><p>Now, let's look at the last part of the <code class="literal">RSNetworking2</code> library—the extensions.</p></div><div class="section" title="Extensions"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl3sec37"/>Extensions</h3></div></div></div><p>In Swift, extensions add new functionality to the existing classes. <code class="literal">RSNetworking2</code> has extensions for the <code class="literal">UIImageView</code> and <code class="literal">UIbutton</code> classes. These extensions allow us to load images from a<a class="indexterm" id="id773"/> URL and then add them to <code class="literal">UIImageView</code> or <code class="literal">UIButton</code>, once the image has finished downloading. We can also put a placeholder image that will be displayed in <code class="literal">UIImageView</code> or<a class="indexterm" id="id774"/> <code class="literal">UIButton</code> until the final image is downloaded. Once the image finishes downloading, the placeholder image will be replaced by the downloaded image.</p><p>Both the <code class="literal">UIImageView</code> and <code class="literal">UIButton</code> extensions expose four new methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setImageForURL(url: NSString, placeHolder: UIImage)</code>: This method sets the<a class="indexterm" id="id775"/> image of the <code class="literal">UIImageView</code> or <code class="literal">UIButton</code> extensions to the placeholder image and then asynchronously downloads the image from the provided URL. Once the image downloads, it will replace the placeholder image with the downloaded image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setImageForURL(url: NSString)</code>: This asynchronously downloads the image from the URL. Once the image is downloaded, it sets the image of the <code class="literal">UIImageView</code> or <code class="literal">UIButton</code> extensions<a class="indexterm" id="id776"/> to the downloaded image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setImageForRSTransaction(transaction:RSTransaction, placeHolder: UIImage)</code>: This <a class="indexterm" id="id777"/>method sets the image in <code class="literal">UIImageView</code> or <code class="literal">UIButton</code> to<a class="indexterm" id="id778"/> the placeholder image and then asynchronously downloads the image from the provided <code class="literal">RSTransaction</code> object. Once the image downloads, it will replace the placeholder image with the downloaded image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setImageForRSTransaction(transaction:RSTransaction)</code>: This asynchronously downloads the image from the provided <code class="literal">RSTransaction</code> object. Once the<a class="indexterm" id="id779"/> image downloads, it sets the image of the <code class="literal">UIImageView</code> or <code class="literal">UIButton</code> extensions to the downloaded image.</li></ul></div><p>The <code class="literal">UIButton</code> and <a class="indexterm" id="id780"/>
<code class="literal">UIImageView</code> extensions are used in exactly the same way. To see how to use these extensions, let's take a look at how we would use the <code class="literal">UIImageView</code> extension to view an image that we download from the Internet:</p><div class="informalexample"><pre class="programlisting">let url = "http://is4.mzstatic.com/image/pf/us/r30/Features/2a/b7/da/dj.kkir mfzh.100x100-75.jpg"
 if let iView: UIImageView = imageView, image = UIImage(named: "loading") {
   iView.setImageForURL(url, placeHolder: image)
}</pre></div><p>In this example, we start off by defining the URL of our image. We then verify that the <code class="literal">imageView</code> variable contains an instance of a <code class="literal">UIImageView</code> class. Note that we normally would not define the constant type (the <code class="literal">UIImageView</code> type) in an <code class="literal">if-let</code> statement, but I defined the type in this example to show that the <code class="literal">imageView</code> constant should be an instance of the <code class="literal">UIImageView</code> class. Next, we create an instance of the <code class="literal">UIImage</code> class with the image named <code class="literal">loading</code>. This image will be used as the placeholder image and will be displayed while we are downloading the final image from the URL.</p><p>Now that we have the URL of the image and the placeholder image, we use the <code class="literal">setImageForURL()</code> extension method. This method accepts two parameters—the URL to download the image from and the placeholder image. Once we call this method, <code class="literal">RSNetworking2</code> will set the image of the <code class="literal">UIImageView</code> class to the placeholder image that is provided and then download the image from the URL provided. Once the image finishes downloading, <code class="literal">RSNetworking2</code> will replace the placeholder image with the downloaded image.</p><p>We looked <a class="indexterm" id="id781"/>at a few brief examples of <code class="literal">RSNetworking2</code> in this chapter. There are additional examples<a class="indexterm" id="id782"/> on the <code class="literal">RSNetworking2</code> GitHub<a class="indexterm" id="id783"/> site at <a class="ulink" href="https://github.com/hoffmanjon/RSNetworking2">https://github.com/hoffmanjon/RSNetworking2</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch16lvl1sec100"/>Summary</h1></div></div></div><p>In today's world, it is essential that a developer have a good working knowledge of network development. In this chapter, we saw how to use Apple's <code class="literal">NSURLSession</code> API, with other classes, to connect to HTTP REST-based web services. The <code class="literal">NSURLSession</code> API was written as a replacement for the older <code class="literal">NSURLConnection</code> API and is now the recommended API to use when making network requests.</p><p>We also saw how to use Apple's system configuration API to figure out what type of network connection we have. If we are developing applications for a mobile device (iPhone, iPod, or iPad), it is essential to know whether we have a network connection and what type of connection it is.</p><p>We ended the chapter discussing <code class="literal">RSNetworking2</code>, which is an open source network library, written entirely in Swift, that I maintain. <code class="literal">RSNetworking2</code> allows us to very quickly and easily add network functionality to our applications. It also adds an extension to both the <code class="literal">UIImageView</code> and <code class="literal">UIButton</code> classes to dynamically load images from the Internet and display them after the download is complete. I would encourage anyone who wishes to participate in the development of RSNetworking.</p></div></body></html>