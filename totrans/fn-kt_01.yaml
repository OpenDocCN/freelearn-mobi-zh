- en: Kotlin – Data Types, Objects, and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover Kotlin's type system, **object-oriented programming** (**OOP**)
    with Kotlin, modifiers, destructuring declarations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin is, primarily, an OOP language with some functional features. When we
    use OOP languages to resolve problems, we try to model the objects that are a
    part of our problem in an abstract way with the information that is relevant to
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: If we're designing an HR module for our company, we'll model employees with
    state or data (name, date of birth, social security number, and others) and behavior
    (pay salary, transfer to another division, and others). Because a person can be
    very complex, there is information that isn't relevant for our problem or domain.
    For example, the employee's favorite style of bicycle isn't relevant for our HR
    system, but it is very relevant for an online cycling shop.
  prefs: []
  type: TYPE_NORMAL
- en: Once we identify the objects (with data and behavior) and the relationship with
    other objects of our domain, we can start developing and writing the code that
    we'll make a part of our software solution. We'll use language constructs (construct
    is a fancy way to say allowed syntax) to write the objects, categories, relationships,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin has many constructs that we can use to write our programs and, in this
    chapter, we''ll cover many of those constructs, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin's type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Classes** are the foundational type in Kotlin. In Kotlin, a class is a template
    that provides a state, a behavior, and a type to instances (more on that later).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a class, only a name is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`VeryBasic` is not very useful, but is still a valid Kotlin syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VeryBasic` class doesn''t have any state or behavior; nonetheless, you
    can declare values of type `VeryBasic`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `basic` value has a `VeryBasic` type. To express it differently,
    `basic` is an instance of `VeryBasic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, types can be inferred; so, the previous example is equivalent to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By being a `VeryBasic` instance, `basic` has a copy of the `VeryBasic` type's
    state and behavior, namely, none. So sad.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, classes can have a state. In Kotlin, a class''s state
    is represented by **properties**. Let''s have a look at the blueberry cupcake
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The  `BlueberryCupcake` class has an *has-a* property `flavour` of type `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can have instances of the `BlueberryCupcake` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because we declare the `flavour` property as a variable, its internal
    value can be changed at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That is impossible in real life. Cupcakes do not change their flavor (unless
    they become stale). If we change the `flavour` property to a value, it cannot
    be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare a new class for almond cupcakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is something fishy here. `BlueberryCupcake` and `AlmondCupcake` are identical
    in structure; only an internal value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real life, you don''t have different baking tins for different cupcake flavors.
    The same good quality baking tin can be used for various flavors. In the same
    way, a well-designed `Cupcake` class can be used for different instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Cupcake` class has a constructor with a parameter, `flavour`, that is assigned
    to a `flavour` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a very common idiom, Kotlin has a little syntactic sugar to
    define it more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define several instances with different flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, a class''s behavior is defined by methods. Technically, a **method**
    is a member function, so, anything that we learn about functions in the following
    chapters also applies to the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eat()` method returns a `String` value. Now, let''s call the `eat()` method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following expression is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb269540-7a2c-44fa-806b-ddf52f7597cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Nothing mind-blowing, but this is our first method. Later on, we'll do more
    interesting stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we continue modelling our domain in Kotlin, we realize that specific objects
    are quite similar. If we go back to our HR example, an employee and a contractor
    are quite similar; both have a name, a date of birth, and so on; they also have
    some differences. For example, a contractor has a daily rate, while an employee
    has a monthly salary. It is obvious that they are similar—both of them are people;
    people is a superset where both contractor and employee belong. As such, both
    have their own specific features that make them different enough to be classified
    into different subsets.
  prefs: []
  type: TYPE_NORMAL
- en: This is what inheritance is all about, there are groups and subgroups and there
    are relationships between them. In an inheritance hierarchy, if you go up in the
    hierarchy, you will see more general features and behaviors, and if you go down,
    you will see more specific ones. A burrito and a microprocessor are both objects,
    but they have very different purposes and uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a new `Biscuit` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this class looks almost exactly same as `Cupcake`. We could refactor
    these classes to reduce code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a new `BakeryGood` class, with the shared behavior and state of
    both `Cupcake` and `Biscuit` classes and we made both classes extend `BakeryGood`.
    By doing so, `Cupcake` (and `Biscuit`) has an *is-a* relationship with `BakeryGood`
    now; on the other hand, `BakeryGood` is the `Cupcake` class's super or parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BakeryGood` is marked as `open`. This means that we specifically
    design this class to be extended. In Kotlin, you can't extend a class that isn't `open`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of moving common behaviors and states to a parent class is called
    **generalisation**. Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try out our new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/068015b9-405f-4a9d-b1a6-77986d9fbfd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Bummer, not what we were expecting. We need to refract it more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It works! Let''s have a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b658a569-6f48-4c67-8ddb-d491338b4481.png)'
  prefs: []
  type: TYPE_IMG
- en: We declared a new method, `name()`; it should be marked as `open`, because we
    designed it to be optionally altered in its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a method's definition on a subclass is called **override** and that
    is why the `name()` method in both subclasses is marked as `override`.
  prefs: []
  type: TYPE_NORMAL
- en: The process of extending classes and overriding behavior in a hierarchy is called
    **specialisation**.
  prefs: []
  type: TYPE_NORMAL
- en: Rule of thumb
  prefs: []
  type: TYPE_NORMAL
- en: Put general states and behaviors at the top of the hierarchy (generalisation),
    and specific states and behaviors in subclasses (specialisation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can have more bakery goods! Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Subclasses can be extended too. They just need to be marked as `open`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can also create classes with more properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, so good. Our bakery looks good. However, we have a problem with our
    current model. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the `BakeryGood` class directly, which is too generic. To
    correct this situation, we can mark `BakeryGood` as `abstract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An **abstract class** is a class designed solely to be extended. An abstract
    class can't be instantiated, which fixes our problem.
  prefs: []
  type: TYPE_NORMAL
- en: What makes `abstract` different from `open`?
  prefs: []
  type: TYPE_NORMAL
- en: Both modifiers let us extend a class, but `open` lets us instantiate while `abstract`
    does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can''t instantiate, our `name()` method in the `BakeryGood` class
    isn''t that useful anymore, and all our subclasses, except for `CinnamonRoll`,
    override it anyway (`CinnamonRoll` relays on the `Roll` implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A method marked as `abstract` doesn't have a body, just the signature declaration
    (a method signature is a way to identify a method). In Kotlin, a signature is
    composed of the method's name, its number, the type of parameters, and the return
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Any class that extends `BakeryGood` directly must override the `name()` method.
    The technical term for overriding an abstract method is **implement** and, from
    now on, we will use it. So, the `Cupcake` class implements the `name()` method
    (Kotlin doesn't have a keyword for method implementation; both cases, method implementation,
    and method overriding, use the keyword `override`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a new class, `Customer`; a bakery needs customers anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eats(food: BakeryGood)` method takes a `BakeryGood` parameter, so any
    instance of any class that extends the `BakeryGood` parameter, it doesn''t matter
    how many hierarchy levels. Just remember that we can instantiate `BakeryGood`
    directly.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we want a simple `BakeryGood`? For example, testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative, an anonymous subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A new keyword is introduced here, `object`. Later on, we'll cover `object` in
    more detail, but for now, it is enough to know that this is an **object expression**.
    An object expression defines an instance of an anonymous class that extends a
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the object expression (technically, the **anonymous class**)
    must override the `name()` method and pass a value as the parameter for the `BakeryGood`
    constructor, exactly as a standard class would do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that an `object` expression is an instance, so it can be used to declare
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open and abstract classes are great for creating hierarchies, but sometimes
    they aren't enough. Some subsets can span between apparently unrelated hierarchies,
    for example, birds and great apes are bipedal, and both are animals and vertebrates,
    but they not directly related. That is why we need a different construct and Kotlin
    gives us interfaces (other languages deal with this problem differently).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our bakery goods are great, but we need to cook them first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With our new `bake()` method , it will cook all our amazing products, but wait,
    donuts aren't baked, but fried.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we could move the  `bake()` method to a second abstract class, `Bakeable`?
    Let''s try it in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrong! In Kotlin, a class can''t extend two classes at the same time. Let''s
    have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, it can extend many interfaces. An **interface** is a type that defines
    a behavior; in the `Bakeable` interface's case, that is the `bake()` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the differences between an open/abstract class and an interface?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: Both are types. In our example, `Cupcake` has an *is-a* relationship with `BakeryGood`
    and has an *is-a* relationship with `Bakeable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both define behaviors as methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although open classes can be instantiated directly, neither abstract classes
    nor interfaces can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: A class can extend just one class (open or abstract), but can extend many interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An open/abstract class can have constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An open/abstract class can initialize its own values. An interface's values
    must be initialized in the classes that extend the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An open class must declare the methods that can be overridden as open. An abstract
    class could have both open and abstract methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In an interface, all methods are open and a method with no implementation doesn''t
    need an abstract modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When should you use one or the other?:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use open class when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class should be extended and instantiated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use abstract class when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class can't be instantiated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor is needed it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is initialization logic (using `init` blocks)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Use interface when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritances must be applied
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No initialized logic is needed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: My recommendation is that you should always start with an interface. Interfaces
    are more straightforward and cleaner; they also allow a more modular design. In
    the case that data initialization/constructors are needed, move to abstract/open.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with abstract classes, object expressions can be used with interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered object expressions, but there is more on objects. **Objects**
    are natural singletons (by natural, I mean to come as language features and not
    as behavior pattern implementations, as in other languages). A **singleton** is
    a type that has just one and only one instance and every object in Kotlin is a
    singleton. That opens a lot of interesting patterns (and also some bad practices).
    Objects as singletons are useful for coordinating actions across the system, but
    can also be dangerous if they are used to keep global state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object expressions don''t need to extend any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `expression` value is an object that doesn't have any specific
    type. We can access its properties and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one restriction—object expressions without type can be used only locally,
    inside a method, or privately, inside a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `property` value can't be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Object declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object can also have a name. This kind of object is called an **object declaration**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects are singletons; you don''t need to instantiate `Oven` to use it. Objects
    also can extend other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects declared inside a class/interface can be marked as companion objects.
    Observe the use of companion objects in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, methods inside the companion object can be used directly, using the class
    name without instantiating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Companion object''s methods can''t be used from instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Companion objects can be used outside the class as values with the name `Companion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, a `Companion` object can have a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be used without a name, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don't be confused by this syntax. The `Cupcake` value without parenthesis is
    the companion object; `Cupcake()` is an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is just a short introduction to generics; later, we'll cover it
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic programming** is a style programming that focuses on creating algorithms
    (and collaterally, data structures) that work on general problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin way to support generic programming is using type parameters. In a
    few words, we wrote our code with type parameters and, later on, we pass those
    types as parameters when we use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, our `Oven` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'An oven is a machine, so we could generalize it more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `Machine<T>` interface defines a type parameter `T` and a method `process(T)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can extend it with `Oven`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, `Oven` is extending `Machine` with the `Bakeable` type parameter, so the
    `process` method now takes `Bakeable` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Type alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Type alias** provides a way to define names of types that already exist.
    Type alias can help to make complex types easier to read, and can also provide
    other hints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Oven` interface is, in some sense, just a name, for a `Machine<Bakeable>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our new type alias, `Oven`, is exactly like our good old `Oven` interface. It
    can be extended and have the values of the type `Oven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types alias also can be used to enhance information on types, providing meaningful
    names related to your domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be used on collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be used with objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main features of Kotlin is nullable types. **Nullable types** allow
    us to define if a value can contain or being null explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t valid in Kotlin; the `Cupcake` type doesn''t allow null values.
    To allow null values, `myBlueberryCupcake` must have a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In essence, `Cupcake` is a non-null type and `Cupcake?` is a nullable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the hierarchical structure, `Cupcake` is a subtype of `Cupcake?`. So, in
    any situation where `Cupcake?` is defined, `Cupcake` can be used, but not the
    other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin's compiler makes a distinction between instances of nullable and non-null
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take these values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will invoke the `eat()` method on both nullable and non-null types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `eat()` method on `cupcake` is easy as pie; calling `eat()` on `nullableCupcake`
    is a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Why? For Kotlin, calling a method from a nullable value is dangerous, a potential
    `NullPointerException` (**NPE** from now on) could be thrown. So, to be safe,
    Kotlin marks this as a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we really want to invoke a method or access a property from
    a nullable value?
  prefs: []
  type: TYPE_NORMAL
- en: Well, Kotlin provides you options to deal with nullable values, with a catch—all
    are explicit. In some sense, Kotlin is telling you, *Show me that you know what
    you are doing*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review some options (there are more options that we'll cover in the following
    chapters).
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check for null as a condition in the `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin will do a smart cast. Inside the `if` block, `nullableCupcake` is a `Cupcake`,
    not a `Cupcake?`; so, any method or property can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for non-null types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is similar to the previous one, but it checks directly for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It also works with `when`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Both options, checking for null and non-null types, are a little bit verbose.
    Let's check other options.
  prefs: []
  type: TYPE_NORMAL
- en: Safe calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Safe calls** let you access methods and properties of nullable values if
    the value isn''t null (under the hood, at the bytecode level, a safe call is transformed
    into `if(x != null)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: But, what if you use it in an expression?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It will return null if our value is null, so `result` must have a `String?`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'That opens up the chance to use safe calls on a chain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The Elvis (?:) operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Elvis operator (`?:`) returns an alternative value if a null value is used
    in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If `nullabluCupcake?.eat()` is `null`, the `?:` operator will return the alternative
    value `""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the Elvis operator can be used with a chain of safe calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The (!!) operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of a `null` value, the `!!` operator will throw an NPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can deal with an NPE, the `!!` operator gives you a pretty convenient
    feature, a free smart cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If `nullableCupcake!!.eat()` doesn't throw an NPE, Kotlin will change its type
    from `Cupcake?` to `Cupcake` from the next line and onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin's type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Type systems** are a set of rules that determine the type of a language construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A (good) type system will help you with:'
  prefs: []
  type: TYPE_NORMAL
- en: Making sure that the constituent parts of your program are connected in a consistent
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding your program (by reducing your cognitive load)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic low-level optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already covered enough ground to understand Kotlin's type system.
  prefs: []
  type: TYPE_NORMAL
- en: The Any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All types in Kotlin extend from the `Any` type (hold on a second, actually this
    isn't true but for the sake of the explanation, bear with me).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every class and interface that we create implicitly extends `Any`. So, if we
    write a method that takes `Any` as a parameter, it will receive any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'What about a nullable value? Let''s have a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`Any` is the same as any other type and also has a nullable counterpart, `Any?`. 
    `Any` extends from `Any?`. So, in the end, `Any?` is the top class of Kotlin''s
    type system hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum common types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to its type inference and expression evaluation, sometimes there are expressions
    in Kotlin where it is not clear which type is being returned. Most languages resolve
    this problem by returning the minimum common type between the possible type options.
    Kotlin takes a different route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of an ambiguous expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'What type does `length` have? `Int` or `String`? No, `length` value''s type
    is `Any`. Pretty logical. The minimum common type between `Int` and `String` is
    `Any`. So far, so good. Let''s look at the following code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Following that logic, in this case, `length` should have the `Number` type (the
    common type between `Int` and `Double`), shouldn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrong, `length` is still `Any`. Kotlin doesn''t search for the minimum common
    type in these situations. If you want a specific type, it must be explicitly declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The Unit type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin doesn't have methods with `void` return (as Java or C do). Instead, a
    method (or, to be precise, an expression) could have a `Unit` type.
  prefs: []
  type: TYPE_NORMAL
- en: A `Unit` type means that the expression is called for its side effects, rather
    than its return. The classic example of a `Unit` expression is `println()`, a
    method invoked just for its side effects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Unit`, like any other Kotlin type, extends from `Any` and could be nullable.
    `Unit?` looks strange and unnecessary, but is needed to keep consistency with
    the type system. Having a consistent type system have several advantages, including
    better compilation times and tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The Nothing type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Nothing` is the type that sits at the bottom of the entire Kotlin hierarchy.
    `Nothing` extends all Kotlin types, including `Nothing?`.'
  prefs: []
  type: TYPE_NORMAL
- en: But, why do we need a `Nothing` and `Nothing?` types?
  prefs: []
  type: TYPE_NORMAL
- en: '`Nothing` represents an expression that can''t be executed (basically throwing
    exceptions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: On one hand of the Elvis operator, we have a `String`. On the other hand, we
    have `Nothing`. Because the common type between `String` and `Nothing` is `String`
    (instead of `Any`), the value `result` is a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Nothing` also has a special meaning for the compiler. Once a `Nothing` type
    is returned on an expression, the lines after that are marked as unreachable.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Nothing?` is the type of a null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Other types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, interfaces, and objects are a good starting point for an OOP type system,
    but Kotlin offers more constructs, such as data classes, annotations, and enums
    (there is an additional type, named sealed class, that we'll cover later).
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating classes whose primary purpose is to hold data is a common pattern in
    Kotlin (is a common pattern in other languages too, think of JSON or Protobuff).
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin has a particular kind of class for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare `data class`, there are some restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The primary constructor should have at least one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary constructor's parameters must be `val` or `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes can't be abstract, open, sealed, or inner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these restrictions, data classes give a lot of benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Canonical methods** are the methods declared in `Any`. Therefore, all instances
    in Kotlin have them.'
  prefs: []
  type: TYPE_NORMAL
- en: For data classes, Kotlin creates correct implementations of all canonical methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equals(other: Any?): Boolean`: This method compares value equivalence, rather
    than reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode(): Int`: A hash code is a numerical representation of an instance.
    When `hashCode()` is invoked several times in the same instance, it should always
    return the same value. Two instances that return true when they are compared with
    `equals` must have the same `hashCode()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString(): String`: A `String` representation of an instance. This method
    will be invoked when an instance is concatenated to a `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The copy() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to reuse values from an existing instance. The `copy()`
    method lets us create new instances of a data class, overriding the parameters
    that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `mySecondItem` copies `unitPrice` and `quantity` from `myItem`,
    and replaces the `product` property.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By convention, any instance of a class that has a series of methods named `component1()`,
    `component2()` and so on can be used in a destructuring declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin will generate these methods for any data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prod` value is initialized with the return of `component1()`, `price`
    with the return of `component2()` , and so on. Although the preceding example
    use explicit types, those aren''t needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In some circumstances, not all values are needed. All unused values can be
    replaced by (`_`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations are a way to attach meta info to your code (such as documentation,
    configuration, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'An `annotation` itself can be annotated to modify its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Tasty` annotation can be set on classes, interfaces, and
    objects, and it can be queried at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of options, check the Kotlin documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations can have parameters with one limitation, they can''t be nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To query annotation values at runtime, we must use the reflection API (`kotlin-reflect.jar`
    must be in your classpath):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enum in Kotlin is a way to define a set of constant values. Enums are very
    useful, but not limited, as configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Each element is an object that extends the `Flour` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any object, they can extend interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Enum can also have abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Any method definition must be declared after the (`;`) separating the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'When enums are used with `when` expressions, Kotlin''s compiler checks that
    all cases are covered (individually or with an `else`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re only checking for `CASSAVA` and not the other elements;
    therefore, it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of OOP and how Kotlin supports it. We
    learned how to use classes, interfaces, objects, data classes, annotations, and
    enums. We also explored the Kotlin type system and saw how it helps us to write
    better and safer code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start with an introduction to functional programming.
  prefs: []
  type: TYPE_NORMAL
