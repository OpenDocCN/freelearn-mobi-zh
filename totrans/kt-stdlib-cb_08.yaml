- en: Best Practices for the Android, JUnit, and JVM UI Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean and safe `View` binding with the Android Extensions plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying coroutines for asynchronous UI programming on Android, JavaFX, and
    Swing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy class-serialization on Android using the `@Parcelize` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom property delegate that provides lifecycle-aware values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy operations on `SharedPreferences`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less boilerplate `Cursor` data parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies with the Mockito Kotlin library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying function invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests for Kotlin coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current chapter is going to address problems specific to the popular frameworks
    that Kotlin uses most often. In general, it is going to focus on Android platform-specific
    aspects and asynchronous UI programming with coroutines both on the Android and
    JVM frameworks, such as JavaFX and Swing. It will also guide you through writing
    effective unit tests for the JVM platform using the JUnit framework ([https://junit.org/junit5/](https://junit.org/junit5/)).
    The recipes related to unit-testing will include also more advanced topics, such
    as mocking dependencies with the `mockito-kotlin` ([https://github.com/nhaarman/mockito-kotlin](https://github.com/nhaarman/mockito-kotlin))
    library, testing asynchronous code based on the coroutines framework, and working
    with assertions provided by the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Clean and safe view-binding with the Android Extensions plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore the view-binding feature provided by
    the Kotlin Android Extensions plugin. It allows us to obtain references to `View` type
    elements declared in the XML layout files in an easy and robust way, without using
    the original `findViewById()` function. We are going to declare a `TextView` element
    in the `Activity` layout and obtain a reference to it in order to display a sample
    text in it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make use of the Kotlin Android Extensions plugin, we need to enable
    it in the Android project module-level `build.gradle` script by adding the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in this book's GitHub
    repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow the Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Activity in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the UI layout in the `activity_main.xml` file under the `src/main/res/layout/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the layout for the `MainActivity` inside the `onCreate()` hook function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a reference to the `TextView` declared in the XML layout and display a
    sample text in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the result, the `MainActivity` class is going to display a greeting inside `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9734da9-b156-4c59-8934-228b2aca2451.png)'
  prefs: []
  type: TYPE_IMG
- en: Under the hood, the Android Extensions plugin has generated extension properties
    for the `MainActivity` class for each of the `View` elements declared in the `activity_main.xml`
    file. The generated properties have the same names as the IDs of their corresponding
    layout elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to the standard way of obtaining references to `View` classes using
    the `findViewById(): View` function, the Android Extensions binding mechanism
    is much cleaner and more painless. It is also safe and robust as it does not require
    casting the `View` type to specific subclasses, and it regenerates all the extension
    properties whenever any changes are made to the XML layout files. Also, compared
    to other third-party view-binding libraries, it is much easier to use as it doesn''t
    require any manual property declarations. It just works seamlessly.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the Android Extensions plugin supports the `Activity`, `Fragment`,
    and `View` type containers where you can use the automatic view binding mechanism
    out of the box. However, there is a possibility to use any class as an Android
    Extensions container, by implementing the `LayoutContainer` interface. For example,
    it can be used in the `RecyclerView.ViewHolder` subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about Android Extensions applications in the official reference: [https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html).
  prefs: []
  type: TYPE_NORMAL
- en: Applying coroutines for asynchronous UI programming on Android, JavaFX, and
    Swing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the JVM-based GUI frameworks have one thing in common—they run a specific
    thread that is responsible for updating the state of the application's UI. In
    this recipe, we're going to learn how to execute tasks asynchronously in the background
    and switch to the UI thread to update the GUI of the app. We're going to create
    a simple counter, which is going to display the incremented integer value every
    second. The mechanism responsible for infinite counter-incrementing should operate
    in the background, however, it should switch to the UI thread context every time
    it needs to perform an update of the UI state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to start working with Kotlin Coroutines is to add the core-framework
    dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the Coroutines core dependency, we will need to add one of the framework-specific
    coroutines sub-modules, providing the coroutine-context implementation responsible
    for dispatching the coroutine on the UI thread. You can find the list of coroutines''
    framework sub-modules in the official guide: [https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md).
    In this recipe, we are going to target the Android platform, however, you can
    easily port the sample code to one of the supported frameworks such as, Android,
    Swing, or JavaFx.'
  prefs: []
  type: TYPE_NORMAL
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project, available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new Activity subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the UI layout in the `activity_main.xml` file under the `src/main/res/layout/`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the layout for `MainActivity` inside the `onCreate()` hook function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new coroutine running in the background, incrementing the counter every
    second and displaying it in the `TextView` obtained from the XML layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow coroutine-cancellation by clicking the **cancel** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coroutine started in the `MainActivity.onCreate()` function is running an
    infinite `while` loop. Each iteration starts with a one-minute delay and incrementation
    of the counter variable. Next, we are applying the `withContext()` function in
    order to update `TextView` with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: The `withContext()` function allows us to switch to a new coroutine dispatcher,
    obtained from the context argument, in order to execute a block of code passed
    to it. It doesn't create and start a new coroutine, but it modifies the context
    of the parent coroutine immediately. The new dispatcher is applied only temporarily
    to execute a given block of code. Any further operations executed inside the coroutine
    scope after the `withContext()` function call will be run with the original coroutine
    context.
  prefs: []
  type: TYPE_NORMAL
- en: We are assigning a `Job` instance returned by the coroutine to the `job` variable.
    Next, we are setting up the listener to the cancel button. Whenever the cancel
    button is clicked, the `cancel()` function is invoked on the coroutine `Job` reference.
  prefs: []
  type: TYPE_NORMAL
- en: As the result, our `MainActivity` implementation is going to update the `TextView`
    value every second. Once the cancel button is clicked, the update mechanism is
    stopped immediately.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're developing an application using different JVM frameworks, in order
    to switch to the UI thread from the background, you can use the `withContext()`
    function with the `JavaFx` or `Swing` constants instead of the Android `UI` context
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to explore the basics of the coroutines framework, you should
    take a look at the recipes in [Chapter 7](331a4e70-5675-4383-970c-6f5fc75421cf.xhtml), *Making
    Asynchronous Programming Great Again*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy class serialization on Android using the @Parcelize annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to make use of the `@Parcelize` annotation to simplify
    the implementation of the Android `Parcelable` interface, allowing us to serialize
    objects efficiently. `@Parcelize` is available in the Kotlin Android Extensions
    plugin and provides automatic code-generation for Kotlin classes that implement
    the `Parcelable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement the Android instrumented test case in order to verify
    the effect of a class serialization and deserialization in action. To make use
    of the Android KTX library, we need to add it to the project dependencies. In
    our case, we will need it in the `android-test` module. We can add it with the
    following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make use of the Kotlin Android Extensions plugin, we need to enable
    it in the Android project module-level `build.gradle` script by adding the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the book's GitHub
    repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a sample User class that implements the `Parcelable`
    interface using the `@Parcelize` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify serialization and deserialization of the `User` class instance by writing
    and reading it from the `Bundle` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have started by defining the `User` class, which contains a property of the
    `Address` class. Both `User` and `Address` are decorated with the `@Parcelize`
    annotation. It tells the Android Extensions plugin to generate code for the `Parcelable`
    interface implementation. Inside the `testUserParcelisation()` function, we are
    creating an instance of the `User` class and serializing it using the Android
    `Bundle` mechanism. We are putting the original `User` class instance to the `Bundle`
    under the `"my_user"` key, and later we deserialize its instance by calling `bundle.get("my_user")
    as User`. Finally, we compare the original and deserialized `User` instances using
    the `assertEquals()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Parcelize` handles generating the `Parcelable` implementation for the following
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: All the primitive types, `String`, `CharSequence`, objects and enums, `Exception`,
    `Size`, `SizeF`, `Bundle`, `IBinder`, `IInterface`, `FileDescriptor`, `SparseArray`, `SparseIntArray`, `SparseLongArray`,
    and `SparseBooleanArray`. It also supports any `Serializable` types (for example,
    `java.util.Date`), as well as `Collection` and `Array` types. It also works with
    nullable types.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn more about the features dedicated to Android development in the
    Kotlin Android Extensions plugin by studying the official guide: [https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom property delegate that provides lifecycle-aware values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we need to declare a class property, which should depend on the lifecycle
    state of `Activity` or `Fragment`. In this recipe, we are going to employ both
    the Kotlin `Lazy` delegate and the `Lifecycle` class provided by the Android Architecture
    Components library ([https://developer.android.com/topic/libraries/architecture/](https://developer.android.com/topic/libraries/architecture/)).
    We are going to implement a custom property delegate that will provide values
    in a lazy manner. This means that they are going to be instantiated only on the
    first call. Moreover, we are going to clear their values once `Activity` or `Fragment`
    gets destroyed. This will avoid memory leaks, which can be caused by managing
    properties dependent on the `Context` instance with the standard `Lazy` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic `Lazy` delegate initialized using the `lazy()` function provided by
    the standard library gives the desired possibility of declaring a property of
    a non-null type, which can only be instantiated after a certain lifecycle event.
    For example, we reference an element of a screen layout in a property only after
    the layout was set up inside the `Activity.onCreate()` hook function.
  prefs: []
  type: TYPE_NORMAL
- en: However, such an implementation using `Lazy` will cause a memory leak if the
    property holds a reference to the `Activity` instance internally, as it will not
    allow it to be deleted by a garbage collector. The reason for this is that the
    lazy delegate is caching the instance it's holding. We are going to implement
    our own property delegate, called `LifeCycleAwareLazy`, which will both extend
    the `Lazy` interface and clear the value it's holding when the activity is about
    to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `Lifecycle` library module available with the Android
    Architecture Components provided by Google. We need to add it to the project dependencies
    in the module-level `build.gradle` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare the `LifecycleAwareLazy` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Register an observer to the given `Lifecycle` instance inside the `init` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement an internal field that represents the current value stored by the
    delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `value` property and the `isInitialized()` function required
    by the `Lazy` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GenericLifecycleObserver` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LifecycleAwareLazy` class we have implemented can be seen as an extended
    version of the standard `Lazy` delegate implementation. It observes events emitted
    by the `Lifecycle` instance passed to it in the constructor and handles the value
    accordingly. Internally, it contains the private `_value: Any?` mutable property
    set initially to the `UNINITIALIZED_VALUE` object, which represents an empty state.
    The `_value` property reflects the current state of the delegated property, which
    can be initialized or uninitialized. The `LifecycleAwareLazy` class exposes also
    the immutable `value` property, which is responsible for returning a final value
    of the delegated property. Not it is marked with the `@get:Synchronized` annotation
    which informs the compiler to generate thread-safe getter function for this property.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `value` property getter, the current value of the `_value` property
    is checked. Whenever it is equal to `UNINITIALIZED_VALUE`, first it gets reassigned
    to the result of the `initialiser` function passed in the constructor and then
    it is returned as the value of the delegated property.
  prefs: []
  type: TYPE_NORMAL
- en: '`Lifecycle` is a class that holds the information about the current lifecycle
    state of an associated component (such as an activity or a fragment). It allows
    other objects to observe this state by subscribing to the state-change events
    by passing a callback to the `Lifecycle.addObserver()` function. You can also
    obtain a current state by accessing the `Lifecycle.currentState` property.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `init` block, we are subscribing to the state updates of the `Lifecycle`
    object passed as the `LifecycleAwareLazy` constructor parameter. We are passing
    the `LifecycleAwareLazy` instance using the `GenericLifecycleObserver` implementation
    to the `lifecycle.addObserver(this)` function.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the `GenericLifeObserver` interface by overriding the `onStateChanged()`
    function inside the `LifecycleAwareLazy` class. As you can see, we are updating
    the `_value` mutable property to the `UNINITIALIZED_VALUE` object whenever the
    `Lifecycle.Event.ON_STOP` event is emitted, meaning that the activity is about
    to be destroyed. This way, we can be sure that the `_value` property won't block
    the activity or fragment from being garbage-collected, even if it holds a reference
    to an activity `Context` instance directly or indirectly. This is a huge win compared
    to the standard lazy delegate, which can lead to potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to get familiar with the basics of the property-delegation pattern,
    take a look at the *Implementing delegated class properties *recipe from [Chapter
    5](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml), *Tasteful Design Patterns Adopting
    Kotlin Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy operations on SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of the Android KTX library developed by Google,
    providing a set of useful extensions and utilities dedicated to Android app-development.
    We are going to apply extension functions that allow us to operate on the `SharedPreferences`
    class in a clean and robust way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make use of the Android KTX library, we need to add it to the project
    dependencies. In our case, we will need it in the `android-test` module. We can
    add it with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are going to implement the Android instrumented test case in order to verify
    the effects of the operations we'll perform on `SharedPreferences`. You can examine
    the implementation and configuration of recipes related to the Android framework
    in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a function that returns the `SharedPreferences` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save a sample string to the `SharedPreferences` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify whether the string was successfully saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using the `edit()` extension function provided by the KTX library for
    the `SharedPreferences` class. It takes the lambda block, including the operations
    we want to perform on the `SharedPreferences.Editor` instance, and automatically
    invokes the `SharedPreferences.Editor.apply()` function to submit the transaction.
    The lambda block passed to the `edit()` function implements the type, `SharedPreferences.Editor.()
    -> Unit`, which allows us to access an instance of `Editor` through the implicit
    `this` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to submit operations applied to the `Editor` using the blocking
    `commit()` instead of the asynchronous `apply()` function, you should pass an
    additional `commit = true` parameter to the `edit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to get familiar with more features offered by the Android KTX
    library, take a look at the library's official guide: [https://developer.android.com/kotlin/ktx](https://developer.android.com/kotlin/ktx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less boilerplate Cursor data parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to work with the Android `Cursor`
    type in a more effective and easy way.  We are going to create an extension function
    for the `Cursor` type, allowing us to query it in a clean way. We will also implement
    a practical example showing how to access the system-content resolver in order
    to fetch contacts stored on the device and transform `Cursor` into a list of strings
    representing the contacts' names.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can examine the implementation and configuration of the recipes related
    to the Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement an extension function that allows us to fetch the values of a requested
    column name from `Cursor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the `Cursor` instance that points to the system contacts table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `use` function on the `cursor` instance and iterate through the
    data inside its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are applying the `use()` extension function provided by the standard library
    to execute a set of operations on the `Cursor` instance. `use()` can be invoked
    on any class that implements the `Closeable` interface. Internally, after executing
    the lambda block passed to it as an argument, `use()` automatically invokes the
    `close()` function on the object it was called on. Thanks to that, we can safely
    perform any operation on the `Cursor` instance and be sure that, even if some
    of them fail or result in throwing an exception, the cursor will eventually be
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `use()` function's scope, we are iterating the cursor with the `while`
    loop by moving it to the next row in each iteration. For each of the rows, we
    are using the `getString()` extension function to obtain the current contact display
    name from the cursor. It allows us to avoid code duplication by combining `Cursor.getString()`
    and `Cursor.getColumnIndex()` together.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies with the Mockito Kotlin library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often when writing unit test cases for complex classes, we face the problem
    of instantiating a great number of properties that the class we want to test depends
    on. Although this problem could be solved with dependency injection, it is faster,
    more efficient, and more desirable to mock a behavior of a specific object without
    instantiating it at all. In this recipe, we are going to explore how to use the
    Mockito Kotlin library to mock dependencies when writing a unit test for a simple
    registration form that contains an internal dependency whose behavior we are going
    to mock.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the JUnit library, which provides the core framework for
    running test-case classes. We need to add it our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can examine the implementation and configuration of the recipes related
    to the Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to write a unit test for the `RegistrationFormController`
    class, declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`RegistrationApi` is defined as the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't want to implement the `RegistrationApi` interface in order to
    instantiate the `RegistrationFormController` class, we are going to mock it instead
    using the Mockito Kotlin `mock()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mocked instance of the `RegistrationApi` interface as the test-class
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a class property of the `RegistrationFormController` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the test method to check whether `checkIfEmailCanBeRegistered()` behaves
    correctly for an invalid email address occurrence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `` `email shouldn't be registered if it's not valid`() `` test method,
    we are setting up our mocked `RegistrationApi` property to return `true` any time
    its `isEmailAddressAvailable()` function is invoked, regardless of the string
    value passed to it. Next, we are updating the `currentEmailAddress` property of
    the `RegistrationFormController` class with an invalid email address value. The
    test is going to pass because the `isEmailIsValid()` function works correctly
    and returns `false` for a given email address value.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, thanks to the mocking, we've avoided implementing the dependency
    of the class we were testing. It's a proper technique that allows us to test the
    specific parts of the business logic while mimicking the desired behavior of the
    dependencies. Mocking can be also useful when we are not able to instantiate the
    dependencies because they are specific to a platform that is not compatible with
    the pure JVM (that is, Android).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can look into the *Verifying function invocations* recipe in order to explore
    how to check whether any specific interactions with the mocked dependency were
    observed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying function invocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the possibility of simulating the particular behavior of dependencies
    in test methods, mocking allows us to verify whether specific functions of the
    mocked objects were invoked. In this recipe, we are going to write a unit tests
    for a simple registration-form controller. The registration form contains two
    internal dependencies that we are going to mock using the Mockito Kotlin library.
    We are going to test whether the proper functions are being invoked in different
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the JUnit library to provide a core framework for running
    test-case classes. We need to add it to our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to write a unit test for the `RegistrationFormController`
    class, declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains the `RegistrationApi` property which is defined as the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'and the `TextView` type property defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't want to implement the `RegistrationApi` and `TextView` interface
    in order to instantiate the `RegistrationFormController` class in our test, we
    are going to mock them using the Mockito Kotlin `mock()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mocked instance of the `RegistrationApi` interface as the test-class
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mocked `TextView` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `RegistrationFormController` object as the `MyTest` class property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test method to verify whether the success message is shown if the address
    is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test method to verify whether the error message is shown if the address
    is not available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from behavior-mocking, Mockito Kotlin provides a reliable way of verifying
    interactions with mocked dependencies that occurred while executing the test method.
    In both the `` `should display success message when email address is available`()
    `` and  `` `should display error message when email address isn''t available`()
    `` functions, we just want to check whether the desired function of the `TextView`
    dependency was invoked. In order to do this, we are invoking the `verify()` function.
    For example, in order to check whether the `showErrorMessage()` function has been
    called on the mocked `view: TextView` dependency, we call the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the `showErrorMessage()` is not invoked, the test method will fail and the
    proper log message will be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests for Kotlin coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore how to effectively test code that uses
    coroutines internally. We are going to write a unit test for the part of a code
    that runs asynchronously in the background while trying to authorize the given
    user credentials using an external API. We are going to employ the Kotlin Mockito
    library to mock the calls to the external API and the `TextCoroutineContext` class,
    allowing us to test asynchronous code with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the JUnit library to provide the core framework for running
    test-case classes. We need to add it to our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to write a unit test for the `Authenticator` class,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Api` property is given as the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a mocked `Api` type test-class property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate the `Authenticator` class as the class property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the test to verify whether the `Api.authorise()` function is called
    at least 10 times in case of consecutive failed authorization attempts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, with mocking, we've avoided implementing the `Api` dependency of the `Authenticator` class
    we were writing the test for. In fact, we are not interested in testing real results
    returned by the `Api` implementation. We want to test the mechanism of the `tryToAuthorise()`
    function and verify whether it's going to retry calling the `Api.authorise()`
    function at least 10 times in case of constant authorization failures. This is
    why we have set up the `api` mock to always return an empty string for the `authorise()`
    function result.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, such a test would take a lot of time to complete because,
    internally, the `tryToAuthorise()` function waits for 10 seconds before retrying
    the authorization. In order to avoid the too-long execution time, we need to artificially
    move forward in time by 100 seconds and check whether the `Api.authorise()` function
    was invoked at least 10 times. We are able to do this by scheduling the two coroutines
    started with the `runBlocking()` function, and internally inside the `tryToAuthorise()`
    function, to run on the same instance of `TestCoroutineContext`. Then, to move
    forward in time by 100 seconds, we just call the `advanceTimeBy(100, TimeUnit.SECONDS)`
    function on the `TestCoroutineContext` instance. As a result, our test method
    is going to complete in less than a second.
  prefs: []
  type: TYPE_NORMAL
