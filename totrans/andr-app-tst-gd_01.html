<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Testing</h1></div></div></div><p>This chapter introduces the different types of testing and their applicability to software development projects in general and to<strong> Android</strong> in particular.</p><p>We will avoid introductions to Android and the<strong> Open Handset Alliance</strong> (<a class="ulink" href="http://www.openhandsetalliance.com">http://www.openhandsetalliance.com</a>) as they are covered in many books already and I am inclined to believe that if you are reading a book covering this more advanced topic you will have started with Android development before.</p><p>However, we will be reviewing the main concepts behind testing and the techniques, frameworks, and tools available to deploy your testing strategy on Android.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec01"/>Brief history</h1></div></div></div><p>Initially, when Android was introduced by the end of 2007, there was very little support for testing on the platform, and for some of us very accustomed to using testing as a component intimately coupled with the development process, it was time to start developing some frameworks and tools to permit this approach.<a class="indexterm" id="id0"/>
</p><p>By that time Android had some rudimentary support for unit testing using JUnit (<a class="ulink" href="http://www.JUnit.org">http://www.JUnit.org</a>), but it was not fully supported and even less documented.<a class="indexterm" id="id1"/>
</p><p>In the process of writing my own library and tools, I discovered Phil Smith's<strong> Positron</strong> (originally at<a class="ulink" href="http://code.google.com/p/android-positron"> http://code.google.com/p/android-positron</a> and now renamed and moved to<a class="ulink" href="http://code.google.com/p/autoandroid)"> http://code.google.com/p/autoandroid)</a>, an Open Source library and a very suitable alternative to support testing on Android, so I decided to extend his excellent work and bring some new and missing pieces to the table.</p><p>Some aspects of test automation were not included and I started a complementary project to fill that gap, it was consequently named<strong> Electron</strong>. And although positron is the anti-particle of the electron, and they annihilate if they collide, take for granted that that was not the idea, but more the conservation of energy and the generation of some visible light and waves.</p><p>Later on, Electron entered the first<strong> Android Development Challenge</strong> (<strong>ADC1</strong>) in early 2008 and though it obtained a rather good score in some categories, frameworks had no place in that competition. Should you be interested in the origin of testing on Android, please find some articles and videos that were published in my personal blog (<a class="ulink" href="http://dtmilano.blogspot.com/search/label/electron">http://dtmilano.blogspot.com/search/label/electron</a>).</p><p>By that time Unit Tests could be run on Eclipse. However, testing was not done on the real target but on a JVM on the local development computer.</p><p>Google also provided application instrumentation code through the<code class="literal"> Instrumentation</code> class. When running an application with instrumentation turned on, this class is instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an<code class="literal"> AndroidManifest.xml</code> file.<a class="indexterm" id="id2"/>
</p><p>During those early stages in the Android development evolution, I started writing some articles in my blog filling the gaps on testing. This book is the evolution and completion of that work in an orderly and understandable manner to paradoxically let you be bitten by the Android testing bug.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec02"/>Software bugs</h1></div></div></div><p>It doesn't matter how hard you try and how much time you invest in design and even how careful you are when programming, mistakes are inevitable and bugs will appear.</p><p>Bugs and software development are intimately related. However, the term<strong> bugs</strong> to describe flaws, mistakes, or errors has been used in hardware engineering many decades before even computers were invented. Notwithstanding the story about the term 'bug' coined by Mark II operators at Harvard University, Thomas Edison wrote this in 1878 in a letter to Puskás Tivadar showing the early adoption of the term:<a class="indexterm" id="id3"/>
</p><div><blockquote class="blockquote"><p>"It has been just so in all of my inventions. The first step is an intuition, and comes with a burst, then difficulties arise—this thing gives out and [it is] then that 'Bugs'—as such little faults and difficulties are called—show themselves and months of intense watching, study and labor are requisite before commercial success or failure is certainly reached."</p></blockquote></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec01"/>How bugs severely affect your projects</h2></div></div></div><p>Bugs affect many aspects of your software development project and it is clearly understood that the sooner in the process you find and<em> squash</em> them, the better. It doesn't matter if you are developing a simple application to publish on the Android Market, re-branding the Android experience for an operator, or creating a customized version of Android for a device manufacturer, bugs will delay your shipment and will cost you money.</p><p>From all of the software development methodologies and techniques,<strong> Test Driven Development</strong>, an agile component of the software development process, is likely the one that forces you to face your bugs earlier in the development process and thus it is also likely that you will solve more problems up front.<a class="indexterm" id="id4"/>
</p><p>Furthermore, the increase in productivity can be clearly appreciated in a project where a software development team uses this technique versus one that is, in the best of cases, writing tests at the end of the development cycle. If you have been involved in software development for the mobile industry, you will have reasons to believe that with all the rush this stage never occurs. It's funny because, usually, this rush is to solve problems that could have been avoided.</p><p>In a study conducted by the<strong> National Institute of Standards and Technology</strong> (<strong>USA</strong>) in 2002, it was reported that software bugs cost the economy $59.5 billion annually. More than a third of this cost could be avoided if better software testing was performed.<a class="indexterm" id="id5"/>
</p><p>But please, don't misunderstand this message. There are no<em> silver bullets</em> in software development and what will lead you to an increase in productivity and manageability of your project is discipline in applying these methodologies and techniques to stay in control.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec03"/>Why, what, how, and when to test</h1></div></div></div><p>You should understand that early bug detection saves a huge amount of project resources and reduces software maintenance costs. This is the best known reason to write software tests for your development project. Increased productivity will soon be evident.</p><p>Additionally, writing the tests will give you a deeper understanding of the requirements and the problem to be solved. You will not be able to write tests for a piece of software you don't understand.</p><p>This is also the reason behind the approach of writing tests to clearly understand legacy or third party code and having the ability to confidently change or update it.</p><p>The more the code covered by your tests, the higher would be your expectations of discovering the hidden bugs.</p><p>If during this coverage analysis you find that some areas of your code are not exercised, additional tests should be added to cover this code as well.</p><p>This technique requires a special instrumented Android build to collect probe data and must be disabled for any release code because the impact on performance could severely affect application behavior.</p><p>To fill this gap, enter EMMA (<a class="ulink" href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>), an open-source toolkit for measuring and reporting Java code coverage, that can offline instrument classes for coverage. It supports various coverage types:<a class="indexterm" id="id6"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">class</li><li class="listitem" style="list-style-type: disc">method</li><li class="listitem" style="list-style-type: disc">line</li><li class="listitem" style="list-style-type: disc">basic block</li></ul></div><p>Coverage reports can also be obtained in different output formats. EMMA is supported to some degree by the Android framework and it is possible to build an EMMA instrumented version of Android.<a class="indexterm" id="id7"/>
</p><p>We will be analyzing the use of EMMA on Android to guide us to full test coverage of our code in<a class="link" href="ch10.html" title="Chapter 10. Alternative Testing Tactics"> Chapter 10</a>, <em>Alternative Testing Tactics.</em></p><p>This screenshot shows how an EMMA code coverage report is displayed in the Eclipse editor, showing green lines where the code has been tested, provided the corresponding plugin is installed.<a class="indexterm" id="id8"/>
</p><div><img alt="Why, what, how, and when to test" src="img/3500_01_01.jpg"/></div><p>Unfortunately, the plugin doesn't support Android tests yet, so right now you can only use it for your JUnit tests. An Android coverage analysis report is only available through HTML.</p><p>Tests should be automated, and you should run some or all of them every time you introduce a change or addition to your code, in order to ensure that all the previous conditions are still met and that the new code still satisfies the tests as expected.</p><p>This leads us to the introduction of<strong> Continuous Integration</strong>, which will be discussed in detail in<a class="link" href="ch08.html" title="Chapter 8. Continuous Integration"> Chapter 8</a>,<em> Continuous Integration</em>. This relies on the automation of tests and building processes.<a class="indexterm" id="id9"/>
</p><p>If you don't use automated testing, it is practically impossible to adopt Continuous Integration as part of the development process and it is very difficult to ensure that changes do not break existing code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec02"/>What to test</h2></div></div></div><p>Strictly speaking you should test every statement in your code but this also depends on different criteria and can be reduced to test the path of execution or just some methods. Usually there is no need to test something that can't be broken, for example it usually makes no sense to test getters and setters as you probably won't be testing the Java compiler on your own code and the compiler would have already performed its own tests.<a class="indexterm" id="id10"/>
</p><p>In addition to the functional areas you should test, there are some specific areas of Android applications that you should consider. We will be looking at these in the following sections.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Activity lifecycle events</h3></div></div></div><p>You should test that your activities handle lifecycle events correctly.<a class="indexterm" id="id11"/>
</p><p>If your activity should save its state during<code class="literal"> onPause()</code> or<code class="literal"> onDestroy()</code> events and later restore it in<code class="literal"> onCreate(Bundle savedInstanceState)</code>, you should be able to reproduce and test these conditions and verify that the state was correctly saved and restored.</p><p>Configuration-changed events should also be tested as some of these events cause the current Activity to be recreated, and you should test for correct handling of the event and that the newly created Activity preserves the previous state. Configuration changes are triggered even by rotation events, so you should test your application's ability to handle these situations.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Database and filesystem operations</h3></div></div></div><p>Database and filesystem operations should be tested to ensure that they are handled correctly. These operations should be tested in isolation at the lower system level, at a higher level through<code class="literal"> ContentProviders</code>, and from the application itself.<a class="indexterm" id="id12"/>
</p><p>To test these components in isolation, Android provides some mock objects in the<code class="literal"> android.test.mock</code> package.<a class="indexterm" id="id13"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Physical characteristics of the device</h3></div></div></div><p>Well before delivering your application you should be sure that all of the different devices it can be run on are supported or at the least you should detect the situation and take appropriate measures.<a class="indexterm" id="id14"/>
</p><p>Among other characteristics of the devices, you may find that you should test:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network capabilities</li><li class="listitem" style="list-style-type: disc">Screen densities</li><li class="listitem" style="list-style-type: disc">Screen resolutions</li><li class="listitem" style="list-style-type: disc">Screen sizes</li><li class="listitem" style="list-style-type: disc">Availability of sensors</li><li class="listitem" style="list-style-type: disc">Keyboard and other input devices</li><li class="listitem" style="list-style-type: disc">GPS</li><li class="listitem" style="list-style-type: disc">External storage</li></ul></div><p>In this respect Android Virtual Devices play an important role because it is practically impossible to have access to all possible devices with all of the possible combinations of features but you can configure AVD for almost every situation. However, as was mentioned before, save your final testing for actual devices where real users will run the application to understand its behavior.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec04"/>Types of tests</h1></div></div></div><p>Testing can be implemented at any time in the development process, depending on the method employed. However, we will be promoting testing at an early stage of the development effort, even before the full set of requirements have been defined and the coding process has been started.</p><p>There are several types of test available depending on the object being tested. Regardless of its type, a test should verify a condition and return the result of this evaluation as a single Boolean value indicating success or failure.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec03"/>Unit tests</h2></div></div></div><p>Unit tests are software tests written by programmers for programmers in a programming language and they should isolate the component under test and be able to test it in a repeatable way. That's why unit tests and mock objects are usually placed together. You use mock objects to isolate the unit from its dependencies, to monitor interactions, and also to be able to repeat the test any number of times. For example, if your test deletes some data from a database you probably don't want the data to be actually deleted and not found the next time the test is run.<a class="indexterm" id="id15"/>
</p><p>JUnit is the de-facto standard for unit tests on Android. It's a simple open source framework for automating unit testing, originally written by Erich Gamma and Kent Beck.<a class="indexterm" id="id16"/>
</p><p>Android (up to Android 2.3 Gingerbread) uses JUnit 3. This version doesn't use annotations and uses introspection to detect the tests.<a class="indexterm" id="id17"/>
</p><p>A typical JUnit test would look something like this (the actual tests are highlighted):</p><div><pre class="programlisting">/**
* Android Application Testing Guide
*/
package com.example.aatg.test;
import JUnit.framework.TestCase;
/**
* @author diego
*/
public class MyUnitTests extends TestCase {
private int mFixture;
/**
* @param name test name
*/
public MyUnitTests(String name) {
super(name);
}
/* (non-Javadoc)
* @see JUnit.framework.TestCase#setUp()
*/
protected void setUp() throws Exception {
super.setUp();
mFixture = 1234;
}
/* (non-Javadoc)
* @see JUnit.framework.TestCase#tearDown()
*/
protected void tearDown() throws Exception {
super.tearDown();
}
/**
* Preconditions
*/<strong>
public void testPreconditions() {
}</strong>
/**
* Test method
*/<strong>
public void testSomething() {
fail("Not implemented yet");
}</strong>
}
</pre></div><div><h3 class="title"><a id="tip01"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for all Packt books you have purchased from your account at<a class="ulink" href="http://www.PacktPub.com"> http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit<a class="ulink" href="http://www.PacktPub.com/support"> http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p>The following sections explain in detail the components that build up our test case.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>The test fixture</h3></div></div></div><p>A test fixture is the well known state defined as a baseline to run the tests and is shared by all the test cases, and thus plays a fundamental role in the design of the tests.<a class="indexterm" id="id18"/>
</p><p>Generally it is implemented as a set of member variables and, following Android conventions, they will have names starting with<code class="literal"> m</code>, for example<code class="literal"> mActivity</code>. However, it can also contain external data, as specific entries in a database or files present in the filesystem.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>The setUp() method</h3></div></div></div><p>This method is called to initialize the fixture.<a class="indexterm" id="id19"/>
</p><p>Overriding it you have the opportunity to create objects and initialize fields that will be used by tests. It's worth noting that this setup occurs<em> before</em> every test.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>The tearDown() method</h3></div></div></div><p>This method is called to finalize the fixture.<a class="indexterm" id="id20"/>
</p><p>Overriding it you can release resources used by the initialization or tests. Again, this method is invoked<em> after</em> every test.</p><p>For example, you can release a database or a network connection here.</p><p>JUnit is designed in such a way that the entire tree of test instances is built in one pass, and then the tests are executed in a second pass. Therefore, the test runner holds strong references to all Test instances for the duration of the test execution. This means that for very large and very long test runs with many Test instances, none of the tests may be garbage collected until the end of the entire test run. This is particularly important in Android and when testing on limited devices as some tests may fail not because of an intrinsic problem but because of the amount of memory needed to run the application plus its tests exceeding the device limits.</p><p>Therefore, if you allocate external or limited resources in a test, such as<code class="literal"> Services</code> or<code class="literal"> ContentProviders</code>, you are responsible for freeing those resources. Explicitly setting an object to null in the<code class="literal"> tearDown()</code> method, for example, allows it to be garbage collected before the end of the entire test run.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Test preconditions</h3></div></div></div><p>Usually there is no way to test for preconditions as the tests are discovered using introspection and their order could vary. So it's customary to create a<code class="literal"> testPreconditions()</code> method to test for preconditions. Though there is no assurance that this test will be called in any specific order, it is good practice to keep this and the preconditions together for organizational purposes.<a class="indexterm" id="id21"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>The actual tests</h3></div></div></div><p>All<code class="literal"> public void</code> methods whose names start with<code class="literal"> test</code> will be considered as a test. JUnit 3, as opposed to JUnit 4, doesn't use annotations to discover the tests but introspection to find their names. There are some annotations available on the Android test framework such as<code class="literal"> @SmallTest, @MediumTest</code>, and<code class="literal"> @LargeTest</code>, but they don't turn a simple method into a test. Instead they organize them in different categories. Ultimately you will have the ability to run tests for a single category using the test runner.<a class="indexterm" id="id22"/>
</p><p>As a rule of thumb, name your tests in a descriptive way using nouns and the condition being tested.</p><p>For example:<code class="literal"> testValues(), testConversionError(), testConversionToString()</code> are all valid test names.</p><p>Test for exceptions and wrong values instead of just testing for positive cases.</p><p>During the execution of the test some conditions, side effects, or method returns should be compared against the expectations. To ease these operations, JUnit provides a full set of<code class="literal"> assert*</code> methods to compare the expected results from the test to the actual results after running with them throwing exceptions if conditions are not met. Then the test runner handles these exceptions and presents the results.</p><p>These methods, which are overloaded to support different arguments, include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertEquals()</code><a class="indexterm" id="id23"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertFalse()</code><a class="indexterm" id="id24"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertNotNull()</code><a class="indexterm" id="id25"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertNotSame()</code><a class="indexterm" id="id26"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertNull()</code><a class="indexterm" id="id27"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertSame()</code><a class="indexterm" id="id28"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertTrue()</code><a class="indexterm" id="id29"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">fail()</code><a class="indexterm" id="id30"/></li></ul></div><p>In addition to these JUnit assert methods, Android extends Assert in two specialized classes providing additional tests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MoreAsserts</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewAsserts</code></li></ul></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec01"/>Mock objects</h4></div></div></div><p>Mock objects are mimic objects used instead of calling the real domain objects to enable testing units in isolation.<a class="indexterm" id="id31"/>
</p><p>Generally, this is done to ensure that correct methods are called but they can also be of help, as mentioned, to isolate your tests from the surrounding universe and enable you to run them independently and repeatably.</p><p>The Android testing framework supports several mock objects that you will find very useful when writing your tests but you will need to provide some dependencies to be able to compile the tests.<a class="indexterm" id="id32"/>
</p><p>Several classes are provided by the Android testing framework in the<code class="literal"> android.test.mock</code> package:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MockApplication</code><a class="indexterm" id="id33"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockContentProvider</code><a class="indexterm" id="id34"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockContentResolver</code><a class="indexterm" id="id35"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockContext</code><a class="indexterm" id="id36"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockCursor</code><a class="indexterm" id="id37"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockDialogInterface</code><a class="indexterm" id="id38"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockPackageManager</code><a class="indexterm" id="id39"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MockResources</code><a class="indexterm" id="id40"/></li></ul></div><p>Almost any component of the platform that could interact with your Activity can be created by instantiating one of these classes.</p><p>However, they are not real implementations but stubs where every method generates an<code class="literal"> UnsupportedOperationException</code> and that you can extend to create real mock objects.</p></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec02"/>UI tests</h4></div></div></div><p>Finally, special consideration should be taken if your tests involve UI components. As you may have already known, only the main thread is allowed to alter the UI in Android. Thus a special annotation<code class="literal"> @UIThreadTest</code> is used to indicate that a particular test should be run on that thread and would have the ability to alter the UI. On the other hand, if you only want to run parts of your test on the UI thread, you may use the<code class="literal"> Activity.runOnUiThread(Runnable r)</code> method providing the corresponding<code class="literal"> Runnable</code> containing testing instructions.<a class="indexterm" id="id41"/>
</p><p>A helper class<code class="literal"> TouchUtils</code> is also provided to aid in the UI test creation allowing the generation of events to send to the Views, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">click</li><li class="listitem" style="list-style-type: disc">drag</li><li class="listitem" style="list-style-type: disc">long click</li><li class="listitem" style="list-style-type: disc">scroll</li><li class="listitem" style="list-style-type: disc">tap</li><li class="listitem" style="list-style-type: disc">touch</li></ul></div><p>By these means you can actually remote control you application from the tests.</p></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec03"/>Eclipse and other IDE support</h4></div></div></div><p>JUnit is fully supported by Eclipse and the Android ADT plugin lets you create Android testing projects. Furthermore, you can run the tests and analyze the results without leaving the IDE.<a class="indexterm" id="id42"/>
</p><p>This also provides a more subtle advantage; being able to run the tests from Eclipse allows you to debug the tests that are not behaving correctly.</p><p>In the screenshot, we can see how Eclipse runs<strong> 18 tests</strong> taking 20.008 seconds, where<strong> 0 Errors</strong> and<strong> 0 Failures</strong> were detected. The name of each test and its duration is also displayed. If there was a failure, the<strong> Failure Trace</strong> would show the related information.</p><div><img alt="Eclipse and other IDE support" src="img/3500_01_02.jpg"/></div><p>Other IDEs like ItelliJ and Netbeans have plugins integrating Android development to some degree but they are not officially supported.<a class="indexterm" id="id43"/>
</p><p>Even if you are not developing in an IDE, you can find support to run the tests with<strong> ant</strong> (check<a class="ulink" href="http://ant.apache.org"> http://ant.apache.org</a> if you are not familiar with this tool). This setup is done by the<code class="literal"> android</code> command using the subcommand<code class="literal"> create test-project</code> as described by this help text:</p><div><pre class="programlisting"><strong>$ android --help create test-project
Usage:
android [global options] create test-project [action options]
Global options:
-v --verbose Verbose mode: errors, warnings and informational messages are printed.
-h --help Help on a specific command.
-s --silent Silent mode: only errors are printed out.
Action "create test-project":
Creates a new Android project for a test package.
Options:
-p --path The new project's directory [required]
-m --main Path to directory of the app under test, relative to the test project directory [required]
-n --name Project name</strong>
</pre></div><p>As indicated by the help you should provide at least the path to the project (--path) and the path to the main project or the project under test (--main).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec04"/>Integration tests</h2></div></div></div><p>Integration tests are designed to test the way individual components work jointly. Modules that have been unit tested independently are now combined together to test the integration.<a class="indexterm" id="id44"/>
</p><p>Usually Android Activities require some integration with the system infrastructure to be able to run. They need the Activity lifecycle provided by the<code class="literal"> ActivityManager</code>, and access to resources, filesystem, and databases.</p><p>The same criteria apply to other Android components like<code class="literal"> Services</code> or<code class="literal"> ContentProviders</code> that need to interact with other parts of the system to achieve their function.</p><p>In all these cases there are specialized tests provided by the Android testing framework that facilitate the creation of tests for these components.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec05"/>Functional or acceptance tests</h2></div></div></div><p>In agile software development, functional or acceptance tests are usually created by business and Quality Assurance (QA) people and expressed in a business domain language. These are high level tests to test the completeness and correctness of a user requirement or feature. They are created ideally through collaboration between business customers, business analysts, QA, testers, and developers. However the business customers (product owners) are the primary owners of these tests.<a class="indexterm" id="id45"/>
</p><p>Some frameworks and tools can help in this field, most notably FitNesse (<a class="ulink" href="http://www.fitnesse.org">http://www.fitnesse.org</a>), which can be easily integrated, up to a point, into the Android development process and will let you create acceptance tests and check their results.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>Also check Fit,<a class="ulink" href="http://fit.c2.com"> http://fit.c2.com</a> and Slim (Simple List Invocation Method),<a class="ulink" href="http://fitnesse.org/FitNesse.UserGuide.SliM"> http://fitnesse.org/FitNesse.UserGuide.SliM</a>, as an alternative to Fit.</p></div><div><img alt="Functional or acceptance tests" src="img/3500_01_03.jpg"/></div><p>Lately, a new trend named<strong> Behavior Driven Development</strong> has gained some popularity and in a very brief description can be understood as the evolution of Test Driven Development. It aims to provide a common vocabulary between business and technology people in order to increase mutual understanding.<a class="indexterm" id="id46"/>
</p><p>Behavior Driven Development can be expressed as a framework of activities based on three principles (more information can be found at<a class="ulink" href="http://behaviour-driven.org)"> http://behaviour-driven.org):</a>
<a class="indexterm" id="id47"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Business and technology should refer to the same system in the same way</li><li class="listitem" style="list-style-type: disc">Any system should have an identified, verifiable value to the business</li><li class="listitem" style="list-style-type: disc">Upfront analysis, design, and planning all have a diminishing return</li></ul></div><p>To apply these principles, business people are usually involved in writing test case scenarios in a high level language and use some tool, such as<strong> jbehave</strong> (<a class="ulink" href="http://jbehave.org">http://jbehave.org</a>). In the following example, these scenarios are translated into code that expresses the same test scenario in a programming language.<a class="indexterm" id="id48"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Test case scenario</h3></div></div></div><p>As an illustration of this technique here is an oversimplified example.<a class="indexterm" id="id49"/>
</p><p>This scenario is:</p><div><pre class="programlisting">Given I'm using the Temperature Converter.
When I enter 100 into Celsius field.
Then I obtain 212 in Fahrenheit field.
</pre></div><p>It would be translated into something similar to:</p><div><pre class="programlisting">@Given("I am using the Temperature Converter")
public void createTemperatureConverter() {
// do nothing
}
@When("I enter $celsius into Celsius field")
public void setCelsius(int celsius) {
mCelsius= celsius;
}
@Then("I obtain $fahrenheit in Fahrenheit field")
public void testCelsiusToFahrenheit(int fahrenheit) {
assertEquals(fahrenheit, TemperatureConverter.celsiusToFahrenheit (mCelsius));
}
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Performance tests</h2></div></div></div><p>Performance tests measure performance characteristics of the components in a repeatable way. If performance improvements are required by some part of the application, the best approach is to measure performance before and after some change is introduced.<a class="indexterm" id="id50"/>
</p><p>As is widely known, premature optimization does more harm than good, so it is better to clearly understand the impact of your changes on the overall performance.</p><p>The introduction of the<strong> Dalvik JIT</strong> compiler in Android 2.2 changed some optimization patterns that were widely used in Android development. Nowadays, every recommendation about performance improvements on the Android developer's site is backed up by performance tests.<a class="indexterm" id="id51"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>System tests</h2></div></div></div><p>The system is tested as a whole and the interaction between the components, software and hardware, is exercised. Normally, system tests include additional classes of tests like:<a class="indexterm" id="id52"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GUI tests</li><li class="listitem" style="list-style-type: disc">Smoke tests</li><li class="listitem" style="list-style-type: disc">Performance tests</li><li class="listitem" style="list-style-type: disc">Installation tests</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Android testing framework</h1></div></div></div><p>Android provides a very advanced testing framework extending the industry standard JUnit with specific features suitable for implementing all of the testing strategies and types we mentioned before. In some cases, additional tools are needed but the integration of these tools is in most cases simple and straightforward.<a class="indexterm" id="id53"/>
</p><p>The key features of the Android testing environment include:<a class="indexterm" id="id54"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Android extensions to the JUnit framework that provide access to Android system objects.</li><li class="listitem" style="list-style-type: disc">An instrumentation framework that lets tests control and examine the application.</li><li class="listitem" style="list-style-type: disc">Mock versions of commonly used Android system objects.</li><li class="listitem" style="list-style-type: disc">Tools for running single tests or test suites, with or without instrumentation.</li><li class="listitem" style="list-style-type: disc">Support for managing tests and test projects in the ADT Plugin for Eclipse and at the command line.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Instrumentation</h2></div></div></div><p>The instrumentation framework is the foundation of the testing framework. Instrumentation controls the application under test and permits the injection of mock components required by the application to run. For example, you can create mock Contexts before the application starts and let the application use them.<a class="indexterm" id="id55"/>
</p><p>All interaction of the application with the surrounding environment can be controlled using this approach. You can also isolate your application in a restricted environment to be able to predict the results, forcing the values returned by some methods or mocking persistent and unchanged data for<code class="literal"> ContentProvider</code>, databases, or even the filesystem content.</p><p>A standard Android project has its tests in a correlated project that usually has the same project name but ends with<strong> Test</strong>. Inside this Test project, the<code class="literal"> AndroidManifest.xml</code> declares the Instrumentation.</p><p>As an illustrative example, assume your project has a manifest like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest <strong>
package="com.example.aatg.sample"</strong>
android:versionCode="1"
android:versionName="1.0"&gt;
&lt;application android:icon="@drawable/icon"
android:label="@string/app_name"&gt;
&lt;activity android:name=".SampleActivity"
android:label="@string/app_name"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category android:name= "android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;/application&gt;
&lt;uses-sdk android:minSdkVersion="7" /&gt;
&lt;/manifest&gt;
</pre></div><p>In this case, the correlated Test project will have the following<code class="literal"> AndroidManifest.xml:</code>
</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest <strong>
package="com.example.aatg.sample.test"</strong>
android:versionCode="1" android:versionName="1.0"&gt;
&lt;application android:icon="@drawable/icon"
android:label="@string/app_name"&gt;<strong>
&lt;uses-library android:name="android.test.runner" /&gt;</strong>
&lt;/application&gt;
&lt;uses-sdk android:minSdkVersion="7" /&gt;<strong>
&lt;instrumentation
android:targetPackage="com.example.aatg.sample"
android:name="android.test.InstrumentationTestRunner"
android:label="Sample Tests" /&gt;</strong>
&lt;uses-permission android:name=" android.permission.INJECT_EVENTS" /&gt;
&lt;/manifest&gt;
</pre></div><p>Here the Instrumentation package is the same package as the main application with the<code class="literal"> .test</code> suffix added.</p><p>Then the Instrumentation is declared specifying the target package and the test runner, in this case the default custom runner<code class="literal"> android.test.InstrumentationTestRunner</code>.<a class="indexterm" id="id56"/>
</p><p>Also notice that both, the application under test and the tests are Android applications with their corresponding APKs installed. Internally, they will be sharing the same process and thus have access to the same set of features.</p><p>When you run a test application, the<strong> Activity Manager</strong> (<a class="ulink" href="http://developer.android.com/intl/de/reference/android/app/ActivityManager.html">http://developer.android.com/intl/de/reference/android/app/ActivityManager.html</a>) uses the instrumentation framework to start and control the test runner, which in turn uses instrumentation to shut down any running instances of the main application, starts the test application, and then starts the main application in the same process. This allows various aspects of the test application to work directly with the main application.<a class="indexterm" id="id57"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Test targets</h2></div></div></div><p>During the evolution of your development project your tests would be targeted to different devices. From the simplicity, flexibility, and speed of testing on an emulator to the unavoidable final testing on the specific devices you intend your application to be run on, you should be able to run on all of them.<a class="indexterm" id="id58"/>
</p><p>There are also some intermediate cases like running your tests on a local<strong> JVM</strong> virtual machine on the development computer or on a<strong> Dalvik</strong> virtual machine or<code class="literal"> Activity</code>, depending on the case.</p><p>Every case has its pros and cons, but the good news is that you have all of these alternatives available to run your tests.</p><p>The emulator is probably the most powerful target as you can modify almost every parameter from its configuration to simulate different conditions for your tests. Ultimately, your application should be able to handle all of these situations, so it is much better to discover the problems upfront than when the application has been delivered.</p><p>The real devices are a requirement for performance tests, as it is somewhat difficult to extrapolate performance measurements from a simulated device. You will discover the real user experience only when using the real device. Rendering, scrolling, flinging, and other cases should be tested before delivering the application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Summary</h1></div></div></div><p>We have reviewed the main concepts behind testing in general and Android in particular. Having acquired this knowledge will let us start our journey and start exploiting the benefits of testing in our software development projects.</p><p>So far, we have visited the following subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We reviewed the early stages of testing on Android and mentioned some of the frameworks that created the current alternatives.</li><li class="listitem" style="list-style-type: disc">We briefly analyzed the reasons behind testing and the whys, whats, hows, and whens of it. Furthermore, from now on we will concentrate on exploring the hows, as we can assume that you are convinced by the arguments presented.</li><li class="listitem" style="list-style-type: disc">We enumerated the different and most common types of tests you would need in your projects, described some of the tools we can count on our testing toolbox, and provided an introductory example of a JUnit unit test to better understand what we are discussing.</li></ul></div><p>We also analyzed these techniques from the Android perspective and mentioned the use of Instrumentation to run our Android tests.</p><p>Now we will start analyzing the mentioned techniques, frameworks, and tools in detail, along with examples of their usage.</p></div></body></html>