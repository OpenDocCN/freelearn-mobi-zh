<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Special Effects – Sound and Particles</h1></div></div></div><p>
<em>In the previous chapter, we took a short break from our Space Fighter game to learn about physics and 2D games in Unity. We created a clone of Angry Birds. The birds utilized physics to fly through the air and destroy the pigs and their structures. We utilized parallax scrolling to make a pleasing background effect. We also created a level selection screen to load the game's various scenes from.</em>
</p><p>
<em>In this chapter, we return to the Space Fighter game. We are going to add many special effects that will round out the game experience. We start by learning about the controls that Unity provides when working with audio. We move on to add some background music to the game and warning sounds when anything gets too close. Next, we learn about particle systems, creating engine trails for our ship. Finally, we combine the effects of the chapter to create bullet blasts and explosions.</em>
</p><p>In this chapter, we will be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Importing audio clips</li><li class="listitem" style="list-style-type: disc">Playing SFX</li><li class="listitem" style="list-style-type: disc">Understanding 2D and 3D SFX</li><li class="listitem" style="list-style-type: disc">Creating particle systems</li></ul></div><p>Open up your Space Fighter project and we will get started.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec116"/>Understanding audio</h1></div></div></div><p>As with other<a id="id534" class="indexterm"/> assets, the Unity team has worked hard to make working with audio easy and pain-free. Unity is capable of importing and utilizing a broad range of audio formats, allowing you to keep your files in a format that you can edit in another program.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec122"/>Import settings</h2></div></div></div><p>Audio clips have a small assortment of important settings. They let you easily control the type and compression<a id="id535" class="indexterm"/> of files.</p><div><img src="img/2014OT_08_01.png.jpg" alt="Import settings"/></div><p>The following are the settings that we have to work with while importing audio clips:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Audio Format</strong>: This controls <a id="id536" class="indexterm"/>whether the file is included in the <strong>Native</strong> format or is <strong>Compressed</strong> in the final game. <strong>Native</strong>, though larger in file size, is best for short sound effects because they can be loaded and played quickly. <strong>Compressed</strong> is better for longer sounds and music. They will have a smaller footprint in the final build.</li><li class="listitem" style="list-style-type: disc"><strong>3D Sound</strong>: This checkbox controls whether the file will be played in 2D or 3D. 2D sounds will be played at a constant volume no matter where the player is located—perfect<a id="id537" class="indexterm"/> for background music and voice overs. 3D sounds will be adjusted in volume based on their distance from the player—excellent for explosions and gun shots.</li><li class="listitem" style="list-style-type: disc"><strong>Force to mono</strong>: This checkbox will <a id="id538" class="indexterm"/>cause Unity to change a stereo file to a mono file.</li><li class="listitem" style="list-style-type: disc"><strong>Load type</strong>: This controls <a id="id539" class="indexterm"/>how the file is loaded when the game is being played.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Load into memory</strong>: This loads a <strong>Native</strong> file directly to the memory to be played.</li><li class="listitem" style="list-style-type: disc"><strong>Stream from disc</strong>: This streams the audio as it is playing, such as streaming music or video from the Web.</li><li class="listitem" style="list-style-type: disc"><strong>Decompress on load</strong>: This removes compression on the file when it is first needed. The overhead for this option makes it a very poor choice for large files.</li><li class="listitem" style="list-style-type: disc"><strong>Compressed in memory</strong>: This only decompresses the file as it is being played. When it is just being held in memory, the file remains compressed.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Hardware decoding</strong>: This<a id="id540" class="indexterm"/> is only used for iOS devices to reduce processing cost.</li><li class="listitem" style="list-style-type: disc"><strong>Gapless looping</strong>: This<a id="id541" class="indexterm"/> adjusts the compression method to remove the small pop of silence that some methods can introduce to a file.</li><li class="listitem" style="list-style-type: disc"><strong>Compression</strong>: This is the <a id="id542" class="indexterm"/>amount of data per second to compress the file to, resulting in a smaller-sized file. It is best to find a value that minimizes the file size while losing the least amount of quality.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec123"/>Audio Listener</h2></div></div></div><p>In order to actually hear anything in the game, every scene needs an <strong>Audio Listener</strong> component in it. By default, the <code class="literal">Main Camera</code> object (included first in any new scene) and any new camera you might create has an <strong>Audio Listener</strong> component attached. There can only be one <a id="id543" class="indexterm"/>
<strong>Audio Listener</strong> component in your scene at a time. If there is more than one, or you try to play a sound when there isn't one, Unity will fill your console log with complaints. The <strong>Audio Listener</strong> component also gives the precise position for any 3D sound effects to key off.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec124"/>Audio Source</h2></div></div></div><p>The <strong>Audio Source</strong> component is like<a id="id544" class="indexterm"/> a speaker and controls the settings for playing any sound effect. If the clip is 3D, the position of this object to the <strong>Audio Listener</strong> component and the mode chosen determine the volume of the clip.</p><div><img src="img/2014OT_08_02.png.jpg" alt="Audio Source"/></div><p>The following are the various settings for an <strong>Audio Source</strong> component:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Audio Clip</strong>: This is the<a id="id545" class="indexterm"/> sound file that this <strong>Audio Source</strong> component will play by default.</li><li class="listitem" style="list-style-type: disc"><strong>Mute</strong>: This is a quick<a id="id546" class="indexterm"/> way to toggle the volume of the playing sound on and off.</li><li class="listitem" style="list-style-type: disc"><strong>Bypass Effects</strong>: This allows<a id="id547" class="indexterm"/> one to toggle any special filters applied to this <strong>Audio Source</strong> component.</li><li class="listitem" style="list-style-type: disc"><strong>Play On Awake</strong>: This will <a id="id548" class="indexterm"/>cause the <strong>Audio Clip</strong> to immediately start playing when the scene loads or the object is spawned.</li><li class="listitem" style="list-style-type: disc"><strong>Loop</strong>: This will cause the <a id="id549" class="indexterm"/>playing clip to repeat as it is played.</li><li class="listitem" style="list-style-type: disc"><strong>Priority</strong>: This dictates the relative importance <a id="id550" class="indexterm"/>of the files being played. <strong>0</strong> is most important and best for music, while <strong>256</strong> is least important. Depending on the system, only so many sounds can be played at once. The list of files to be played starts with the most important and ends when this limit is reached, excluding those with the lowest values if there are more sounds than the limit would allow.</li><li class="listitem" style="list-style-type: disc"><strong>Volume</strong>:<a id="id551" class="indexterm"/> This decides how loud the clip will be played.</li><li class="listitem" style="list-style-type: disc"><strong>Pitch</strong>: This scales the playback <a id="id552" class="indexterm"/>speed of the clip.<div><img src="img/2014OT_08_03.png.jpg" alt="Audio Source"/></div></li><li class="listitem" style="list-style-type: disc"><strong>3D Sound Settings</strong>: This<a id="id553" class="indexterm"/> contains the group of settings specific to the playing of 3D audio clips. The <strong>Volume</strong>, <strong>Pan</strong>, and <strong>Spread</strong> options can be adjusted using the graph at the end of the group. This allows one to create more dynamic transitions as the player approaches an <strong>Audio Source</strong> component.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Doppler Level</strong>: This decides how much of the doppler effect to apply to moving sounds.</li><li class="listitem" style="list-style-type: disc"><strong>Volume Rolloff</strong>: This controls how the volume fades with distance.<p>
<strong>Logarithmic Rolloff</strong>: This is a sudden and rapid falloff of the sound at a short distance from the source's center.</p><p>
<strong>Linear Rolloff</strong>: This is an even falloff with distance, the loudest being at the <strong>Min Distance</strong> value and the quietest at the <strong>Max Distance</strong> value.</p><p>
<strong>Custom Rolloff</strong>: This allows you to create a custom falloff by adjusting the graph at the end of the group. It is also automatically chosen when the graph is adjusted.</p></li><li class="listitem" style="list-style-type: disc">If the <strong>Audio Listener</strong> component is closer than the <strong>Min Distance</strong> value, the audio will be played at the current volume level. Outside this distance, the sound will fall off according to the <strong>Rolloff Mode</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Pan Level</strong>: This is the percentage of the 3D effects to be applied to this <strong>Audio Source</strong> component. This affects things such as the falloff and doppler effects.</li><li class="listitem" style="list-style-type: disc"><strong>Spread</strong>: This adjusts the amount of area in speaker space that the sound covers. It becomes more important when working with more than one or two speakers.</li><li class="listitem" style="list-style-type: disc">Beyond the <strong>Max Distance</strong> value, the sound will stop transitioning based on the graph at the bottom of the group.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>2D Sound Settings</strong>: This groups<a id="id554" class="indexterm"/> the settings that are specific to 2D audio clips.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Pan 2D</strong>: This adjusts how evenly the sound comes out of each speaker, weighing it towards the left or right speaker</li></ul></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec125"/>Adding background music</h2></div></div></div><p>Now that we know<a id="id555" class="indexterm"/> about the available audio settings, it is time to put that knowledge into action. We will start by adding some background music. This will have to be a 2D sound effect so we can hear it comfortably no matter where the <strong>Audio Source</strong> component is. We will also create a short script to fade in the music to reduce the suddenness with which sound effects bombard the player.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec117"/>Time for action – adding background music</h1></div></div></div><p>Let's get started with a single<a id="id556" class="indexterm"/> script to control our background music.</p><div><ol class="orderedlist arabic"><li class="listitem">We will start by creating a new script and naming it <code class="literal">FadeIn</code>.</li><li class="listitem">This script begins with three variables. The first is the goal volume that the script has to reach. The second is the number of seconds the transition will take. The last is the time when the transition began.<div><pre class="programlisting">public float maxVolume = 1f;
public float fadeLength = 1f;
private float fadeStartTime = -1f;</pre></div></li><li class="listitem">Next, we make use of the <code class="literal">Awake</code> function. It begins by looking at the <code class="literal">audio</code> variable, which is automatically supplied by Unity, to check for an attached <strong>Audio Source</strong> component. If one cannot be found, the <code class="literal">gameObject</code> is destroyed and the function is exited.<div><pre class="programlisting">public void Awake() {
  if(audio == null) {
    Destroy(gameObject);
    return;
  }</pre></div></li><li class="listitem">The <code class="literal">Awake</code> function ends by setting its volume to <code class="literal">0</code> and playing it if it isn't already.<div><pre class="programlisting">  audio.volume = 0;

  if(!audio.isPlaying)
    audio.Play();
}</pre></div></li><li class="listitem">To cause the transition over time, we use the <code class="literal">Update</code> function. It will first check to see whether the <code class="literal">fadeStartTime</code> variable is below zero and set it to the current time if it is. This allows us to avoid the hiccup that can be caused by the initialization of a scene starting.<div><pre class="programlisting">public void Update() {
  if(fadeStartTime &lt; 0)
    fadeStartTime = Time.time;</pre></div></li><li class="listitem">The function next checks to see if the transition's time has ended. If it has, the <strong>Audio Source</strong> component's volume is set to <code class="literal">maxVolume</code> and the script is destroyed to free resources.<div><pre class="programlisting">if(fadeStartTime + fadeLength &lt; Time.time) {
  audio.volume = maxVolume;
  Destroy(this);
  return;
}</pre></div></li><li class="listitem">Finally, the current progress is calculated by finding the amount of time that has passed<a id="id557" class="indexterm"/> since the fade started and dividing it by the length of the transition. The resulting percentage of progress is multiplied by the value of <code class="literal">maxVolume</code> and applied to the <strong>Audio Source</strong> component's volume.<div><pre class="programlisting">  float progress = (Time.time – fadeStartTime) / fadeLength;
  audio.volume = maxVolume * progress;
}</pre></div></li><li class="listitem">Back in Unity, we need to create a new empty <code class="literal">GameObject</code> and name it <code class="literal">Background</code>.</li><li class="listitem">To this object, add our <code class="literal">FadeIn</code> script and an <strong>Audio Source</strong> component.</li><li class="listitem">If you have not already, create an <code class="literal">Audio</code> folder in your <strong>Project</strong> panel and import the four sound files included in <strong>Starting Assets</strong> for the chapter.</li><li class="listitem">Select the <code class="literal">Background</code> sound file and uncheck the <strong>3D Sound</strong> checkbox in the import settings.</li><li class="listitem">Select your <code class="literal">Background</code> object in the <strong>Hierarchy</strong> window and drag the <code class="literal">Background</code> sound to the <strong>Audio Clip</strong> slot.</li><li class="listitem">Make sure the <strong>Play On Awake</strong> and <strong>Loop</strong> checkboxes are checked on the <strong>Audio Source</strong> component. The <strong>Volume</strong> option also needs to be set to <strong>0</strong>, all to make the file play throughout the game but make no noise when starting.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec126"/>
<em>What just happened?</em>
</h2></div></div></div><p>We added background music to our game. In order for the sound to be constant and not directional, we utilized the music as 2D sound. We also created a script to fade the music in when the game starts. This eases the transition into the game for the player, preventing a sudden onslaught of sound.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec127"/>Have a go hero – setting some mood</h2></div></div></div><p>Background music adds a lot to a game's experience. A horror scene is not nearly as scary without some scary music. Bosses are much less intimidating without their daunting music. Look for some good background music for your other games. Something light and cheery would work nicely for Angry Birds, while a piece that is more industrial and fast-paced would keep hearts racing through the Tank Battle game.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec128"/>Creating an alarm system</h2></div></div></div><p>To understand 3D audio effects, we are going to create an alarm system. As objects approach the ship, the alarm will increase in volume. The 3D effect will indicate the direction to the object<a id="id558" class="indexterm"/> relative to the ship. This gives the player the needed feedback when they can't see everything around them. There are several ways this effect can be achieved, but this one will demonstrate our ability to adjust the <strong>Audio Source</strong> component over time.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec118"/>Time for action – warning the player</h1></div></div></div><p>A single script attached to our objects in space will warn the player as the objects approach.</p><div><ol class="orderedlist arabic"><li class="listitem">We start by creating a new script and name it <code class="literal">Alarm</code>.</li><li class="listitem">This script starts with a single variable. It will hold the distance value at which the sound will start to fade in.<div><pre class="programlisting">public float warningDist = 100f;</pre></div></li><li class="listitem">Next, we create the <code class="literal">Update</code> function. It starts by checking for an <strong>Audio Source</strong> component and exiting the function early if there isn't one. The <code class="literal">audio</code> variable holds the reference to the attached <strong>Audio Source</strong> component.<div><pre class="programlisting">public void Update() {
  if(audio == null) return;</pre></div></li><li class="listitem">The function continues by calculating the distance to the player. Because the player never moves, we can just use the position's distance to the origin to make it simpler. We also use <code class="literal">sqrMagnitude</code>, which is the square of the length of the vector, because it is significantly faster to calculate. If the object is outside the range, the volume is set to <code class="literal">0</code> and the function is exited.<div><pre class="programlisting">float distance = transform.position.sqrMagnitude;
if(distance &gt; warningDist * warningDist) {
  audio.volume = 0;
  return;
}</pre></div></li><li class="listitem">Finally, we calculate the new volume by dividing the distance by the square of <code class="literal">warningDist</code> value and subtracting the result from one. This will result in a rounded curve as it approaches maximum volume.<div><pre class="programlisting">float volume = 1 – (distance / (warningDist * warningDist));
audio.volume = volume;
}</pre></div></li><li class="listitem">We now need to add the script to the relevant objects. To both the enemy ship and asteroid prefabs, add the <code class="literal">Alarm</code> script and an <strong>Audio Source</strong> component.</li><li class="listitem">For the <strong>Audio Clip</strong> value, select the <code class="literal">Alarm</code> clip. Also, make sure both the <strong>Play On Awake</strong> and <strong>Loop</strong> checkboxes are checked.</li><li class="listitem">Next, we don't want the alarm to overpower other sounds in our game, so set the <strong>Priority</strong> option to <strong>192</strong>.</li><li class="listitem">To keep it from making any noise when the object is spawned, set the <strong>Volume</strong> option to <strong>0</strong>.</li><li class="listitem">In order for<a id="id559" class="indexterm"/> the script to fully control the <strong>Audio Source</strong> component's volume, expand the <strong>3D Sound Settings</strong> component. Select <strong>Linear Rolloff</strong> for <strong>Volume Rolloff</strong> and <strong>495</strong> for the <strong>Min Distance</strong> option.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec129"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script to warn the player when objects get too close. As they approach the player, the volume on their audio source is increased. As they move away from the player, the volume is reduced. By utilizing 3D audio clips, we can direct the player as to where the approaching object is coming from.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Have a go hero – differentiation</h2></div></div></div><p>It is great that we can tell when objects are coming too close, but we can't tell what it is until we see it. Find some alternate alarm sounds. For each type of object that the player has to contend with, give it a different sound. This way, the player will know whether they need to start pulling some tricky maneuvers to dodge bullets or they are entering an asteroid field and need to fly carefully to avoid a collision.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec119"/>Understanding particle systems</h1></div></div></div><p>Particle systems add much to<a id="id560" class="indexterm"/> the final look of a game. They can take the form of fire, magic waves, rain, or the great many other effects you can dream up. They are often hard to create well, but are well worth the effort. Keep in mind, especially when working with the mobile platform, that less is more. Larger particles are more effective than a great amount of particles. If your particle system ever contains thousands of particles in a small space or is duplicated on itself to increase the effect, you need to rethink the design and find a more efficient solution.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Particle system settings</h2></div></div></div><p>Every particle system contains <a id="id561" class="indexterm"/>a large variety of components, each with its own settings. Most of the available settings have the option to be <strong>Constant</strong>, <strong>Curve</strong>, <strong>Random</strong> <strong>Between Two Constants</strong>, and <strong>Random Between Two Curves</strong>. <strong>Constant</strong> will be a specific value. <strong>Curve</strong> will be a set value that changes along the curve over time. The two random settings select a random value between the respective value types. It may seem confusing at first but, as we work through them, they will become more understandable.</p><p>As you will be able to see in<a id="id562" class="indexterm"/> the images and descriptions that follow, we will work through and gain an understanding of each piece of a particle system.</p><p>As you will see in the following screenshot, we will work through and gain an understanding of each piece of a particle system:</p><div><img src="img/2014OT_08_04.png.jpg" alt="Particle system settings"/></div><div><ol class="orderedlist arabic"><li class="listitem">The first portion, the<a id="id563" class="indexterm"/> <strong>Initial</strong> module, of the particle system holds all the settings used by every emitter in Unity.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Duration</strong>: This is how long the emitter lasts. A looping system will repeat after this <a id="id564" class="indexterm"/>amount of time. A non-looping system will stop emitting after this length of time.</li><li class="listitem" style="list-style-type: disc"><strong>Looping</strong>: This<a id="id565" class="indexterm"/> checkbox dictates whether or not the system loops.</li><li class="listitem" style="list-style-type: disc"><strong>Prewarm</strong>: This checkbox, if checked, <a id="id566" class="indexterm"/>will start a looping system as if it has already had a chance to loop for a while. This is useful in the case of<a id="id567" class="indexterm"/> torches that should already be lit, not start when the player enters the room.</li><li class="listitem" style="list-style-type: disc"><strong>Start Delay</strong>: This will stop the<a id="id568" class="indexterm"/> particle system from emitting for the given number of seconds when it is initially triggered.</li><li class="listitem" style="list-style-type: disc"><strong>Start Lifetime</strong>: This is the number<a id="id569" class="indexterm"/> of seconds an individual particle begins with.</li><li class="listitem" style="list-style-type: disc"><strong>Start Speed</strong>: This is how <a id="id570" class="indexterm"/>fast a particle will initially move when spawned.</li><li class="listitem" style="list-style-type: disc"><strong>Start Size</strong>: This dictates<a id="id571" class="indexterm"/> how large a particle is when spawned. It is always better to use larger particles rather than more particles.</li><li class="listitem" style="list-style-type: disc"><strong>Start Rotation</strong>: This<a id="id572" class="indexterm"/> will rotate the emitted particles.</li><li class="listitem" style="list-style-type: disc"><strong>Start Color</strong>: This is<a id="id573" class="indexterm"/> the color tint of the particles when spawned.</li><li class="listitem" style="list-style-type: disc"><strong>Gravity Multiplier</strong>: This gives <a id="id574" class="indexterm"/>the particles a greater or lesser amount of the gravity effect.</li><li class="listitem" style="list-style-type: disc"><strong>Inherit Velocity</strong>: This will cause<a id="id575" class="indexterm"/> particles to gain a portion of their transform's momentum if it is moving.</li><li class="listitem" style="list-style-type: disc"><strong>Simulation Space</strong>: This determines <a id="id576" class="indexterm"/>whether the particles will stay with the game object as it is moved (that is, local) or will remain where they are in the world.</li><li class="listitem" style="list-style-type: disc"><strong>Play On Awake</strong>: This checkbox, if checked, will cause the emitter to start emitting as<a id="id577" class="indexterm"/> soon as it is spawned or the scene starts.</li><li class="listitem" style="list-style-type: disc"><strong>Max Particles</strong>: This limits the total number of particles that this system supports at a single time. This<a id="id578" class="indexterm"/> value only comes into play if the rate particles are emitted or their life span is great enough to overbalance their rate of destruction.</li></ul></div><div><img src="img/2014OT_08_05.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Emission</strong> module<a id="id579" class="indexterm"/> controls<a id="id580" class="indexterm"/> how fast the particles are emitted.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Rate</strong>: If set to <strong>Time</strong>, this is the number of particles per second that are created. If set to <strong>Distance</strong>, this is the <a id="id581" class="indexterm"/>number of particles per unit of distance the system travels as it moves.</li><li class="listitem" style="list-style-type: disc"><strong>Bursts</strong>: This is only used when<a id="id582" class="indexterm"/> the <strong>Rate</strong> option is set to <strong>Time</strong>. It allows you to set points in the system's timeline when a specific number of particles will be emitted.</li></ul></div><div><img src="img/2014OT_08_06.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Shape</strong> module controls <a id="id583" class="indexterm"/>how the system emits particles.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Shape</strong>: This dictates what form the<a id="id584" class="indexterm"/> emission point will take. Each option comes with a few more value fields that determine its size.<p>
<strong>Sphere</strong>: This is the point from which particles are emitted in all directions. <strong>Radius</strong> determines<a id="id585" class="indexterm"/> the size of the sphere. <strong>Emit from Shell</strong> dictates whether the particles are emitted from the surface of the sphere or inside the volume.</p><p>
<strong>Hemisphere</strong>: This is, <a id="id586" class="indexterm"/>as the name suggests, half of a sphere. <strong>Radius</strong> and <strong>Emit from Shell</strong> work the same here as they do for <strong>Sphere</strong>.</p><p>
<strong>Cone</strong>: This emits particles in one direction. <strong>Angle</strong> determines whether the shape is closer to a<a id="id587" class="indexterm"/> cone or cylinder. <strong>Radius</strong> dictates the size of the emission point of the shape. <strong>Emit From</strong> will determine where the particles are emitted from. <strong>Base</strong> emits from the base disc of the shape. <strong>Base Shell</strong> emits from the base of the cone, but around the surface of the shape. <strong>Volume</strong> will emit from anywhere inside the shape and <strong>Volume Shell</strong> emits from the surface of the shape.</p></li><li class="listitem" style="list-style-type: disc"><strong>Box</strong>: This emits <a id="id588" class="indexterm"/>particles from a cube-type shape. <strong>Box X</strong>, <strong>Box Y</strong>, and <strong>Box Z</strong> determine<a id="id589" class="indexterm"/> the size of the box.</li><li class="listitem" style="list-style-type: disc"><strong>Mesh</strong>: This allows you to select a <a id="id590" class="indexterm"/>model to use as an emission point. All of the particles for the system will be emitted from the surface of the <strong>Mesh</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Random Direction</strong>: This determines<a id="id591" class="indexterm"/> whether a particle's direction is determined by the surface normal of the shape chosen, or if it is chosen at random.</li></ul></div><div><img src="img/2014OT_08_07.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Velocity over Lifetime</strong> module <a id="id592" class="indexterm"/>allows you to control the momentum of the particles after they have been spawned.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong>: These define<a id="id593" class="indexterm"/> the number of units per second along each axis of the particle's momentum</li><li class="listitem" style="list-style-type: disc"><strong>Space</strong>: This dictates<a id="id594" class="indexterm"/> whether the velocity is applied locally to the system's transform, or relative to the world</li></ul></div><div><img src="img/2014OT_08_08.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Limit Velocity over Lifetime</strong> module <a id="id595" class="indexterm"/>dampens a particle's movement if it exceeds the specified value.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Separate Axis</strong>: This allows<a id="id596" class="indexterm"/> you to define a value unique to each axis and whether that value is local or relative to the world</li><li class="listitem" style="list-style-type: disc"><strong>Speed</strong>: This is<a id="id597" class="indexterm"/> how fast the particle has to be moving before the damp is<a id="id598" class="indexterm"/> applied</li><li class="listitem" style="list-style-type: disc"><strong>Dampen</strong>: This is the percentage<a id="id599" class="indexterm"/> of speed to cut the particle by. It is a value between zero and one</li></ul></div><div><img src="img/2014OT_08_09.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Force over Lifetime</strong> module<a id="id600" class="indexterm"/> adds a constant amount of movement to each particle over the course of its life.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong>: These define how <a id="id601" class="indexterm"/>much force to apply along each axis</li><li class="listitem" style="list-style-type: disc"><strong>Space</strong>: This dictates whether<a id="id602" class="indexterm"/> the force is applied local to the system's transform or in the world space</li><li class="listitem" style="list-style-type: disc">If <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> are random values, <strong>Randomize</strong> will cause the amount of force to apply to be randomly picked each frame, resulting in a statistical averaging of the random values</li></ul></div><div><img src="img/2014OT_08_10.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Color over Lifetime</strong> module<a id="id603" class="indexterm"/> allows you to <a id="id604" class="indexterm"/>define a series of colors for the particle to transition through after it has been spawned.</li><li class="listitem">The <strong>Color by Speed</strong> module<a id="id605" class="indexterm"/> causes<a id="id606" class="indexterm"/> the particle to transition through the defined range of colors as its speed changes.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Color</strong>: This is the set of colors to transition through</li><li class="listitem" style="list-style-type: disc"><strong>Speed Range</strong>: This defines how fast the particle must be going to be at the minimum and maximum ends of the <strong>Color</strong> range</li></ul></div><div><img src="img/2014OT_08_11.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <a id="id607" class="indexterm"/><strong>Size over Lifetime</strong> module<a id="id608" class="indexterm"/> changes the size of the particle over the course of its life.</li><li class="listitem">The <a id="id609" class="indexterm"/><strong>Size by Speed</strong> module adjusts the size of each particle based on how fast it is going.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Size</strong>: This is the adjustment that the particles transition through</li><li class="listitem" style="list-style-type: disc"><strong>Speed Range</strong>: This defines the min and max values for each of the <strong>Size</strong></li></ul></div><div><img src="img/2014OT_08_12.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <a id="id610" class="indexterm"/><strong>Rotation over Lifetime</strong> module<a id="id611" class="indexterm"/> rotates particles over time after they have been spawned.</li><li class="listitem">The <strong>Rotation by Speed</strong> module <a id="id612" class="indexterm"/>rotates particles<a id="id613" class="indexterm"/> more as they go faster.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Angular Velocity</strong>: This is the number of rotations to apply</li><li class="listitem" style="list-style-type: disc"><strong>Speed Range</strong>: This is the min and max range for the <strong>Angular Velocity</strong> value if it is not set to <strong>Constant</strong></li></ul></div><div><img src="img/2014OT_08_13.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>External Forces</strong> module<a id="id614" class="indexterm"/> multiplies the effect of Wind Zone<a id="id615" class="indexterm"/> objects. Wind Zones<a id="id616" class="indexterm"/> simulate the effects of wind on particle systems and Unity's trees.</li><li class="listitem">The <strong>Collision</strong> module allows <a id="id617" class="indexterm"/>particles to collide and interact with the physical game world.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If set to <strong>Planes</strong>, you <a id="id618" class="indexterm"/>are able to define a number of flat surfaces for the particles to collide with. This is faster to process than World collisions.<p>
<strong>Planes</strong>: This is a list of transforms that define the surfaces to collide with. Particles will only collide with the local, positive y side of the transform. Any particles on the other side of the point will be destroyed.</p><p>
<strong>Visualization</strong>: This gives you the option to view the planes as a <strong>Solid</strong> surface or a <strong>Grid</strong> surface.</p><p>
<strong>Scale Plane</strong>: This adjusts the size of the <strong>Visualization</strong> option. It does not affect the actual size of the surface to collide with.</p><p>
<strong>Particle Radius</strong>: This is used to define the size of the sphere used to calculate the particle's collision with the planes.</p></li><li class="listitem" style="list-style-type: disc">If set to <strong>World</strong>, the particles will collide with every collider in your scene. This can become a lot for the processor to handle.<p>
<strong>Collides With</strong>: This defines a list of layers that will be collided with. Only colliders on layers that are checked in this list will be used for the collision calculation.</p><p>
<strong>Collision Quality</strong>: This defines how precise the collision calculations are for this particle system. <strong>High</strong> will calculate precisely for every single particle. <strong>Medium</strong> will use an approximation and a limited number of new calculations each frame. <strong>Low</strong> just calculates less often than <strong>Medium</strong>.</p><p>If <strong>Collision Quality</strong> is set to <strong>Medium</strong> or <strong>Low</strong>, <strong>Voxel Size</strong> dictates how precise the system estimates the points of collision.</p></li><li class="listitem" style="list-style-type: disc"><strong>Dampen</strong>: This removes the<a id="id619" class="indexterm"/> defined fraction amount of speed from the particle when it collides with a surface.</li><li class="listitem" style="list-style-type: disc"><strong>Bounce</strong>: This allows the particle to maintain the defined fraction of its speed, specifically along the normal of the surface that was hit.</li><li class="listitem" style="list-style-type: disc"><strong>Lifetime Loss</strong>: This is the <a id="id620" class="indexterm"/>percentage of life. When the particle collides, this percentage of life is removed from the particle. When the particle's life drops to zero over time, or through collision, it is removed.</li><li class="listitem" style="list-style-type: disc">If, after collision, the particle's speed is below the <strong>Min Kill Speed</strong> value, it is destroyed.</li><li class="listitem" style="list-style-type: disc">If the <strong>Send Collision Messages</strong> checkbox is checked, scripts attached to the particle system and the object that was collided with will be alerted every frame that the collision took place. Only one message is sent per frame, not per particle.</li></ul></div><div><img src="img/2014OT_08_14.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Sub Emitters</strong> module <a id="id621" class="indexterm"/>allows additional particle systems to be spawned at points in the life of each particle of this system.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any particle <a id="id622" class="indexterm"/>systems in the <strong>Birth</strong> list will be spawned and follow the particle when it is first created. This could be used to create a fireball or smoke trail.</li><li class="listitem" style="list-style-type: disc">The <strong>Collision</strong> list spawns particle systems when the particle hits something. This could be used for rain drop splashes.</li><li class="listitem" style="list-style-type: disc">The <strong>Death</strong> list spawns particles when the particle is destroyed. It could be used to spawn the firework explosion.</li></ul></div><div><img src="img/2014OT_08_15.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The <strong>Texture Sheet Animation</strong> module <a id="id623" class="indexterm"/>causes the particle to flip through a number of particles over the course of its life. The texture used is defined in the <strong>Renderer</strong><a id="id624" class="indexterm"/> module.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Tiles</strong>: This defines<a id="id625" class="indexterm"/> the number of rows and columns in the sheet. This will determine the total number of frames available.</li><li class="listitem" style="list-style-type: disc"><strong>Animation</strong>: This gives you the options of <strong>Whole Sheet</strong> and <strong>Single Row</strong>. If set to <strong>Single Row</strong>, the row used can either be chosen at random or specified using the <strong>Random Row</strong> checkbox and <strong>Row</strong> value.</li><li class="listitem" style="list-style-type: disc"><strong>Frame over Time</strong>: This defines how the particle transitions between frames. If set to <strong>Constant</strong>, the system will only use a single frame.</li><li class="listitem" style="list-style-type: disc"><strong>Cycles</strong>: This is the number of times the particle will loop through the animation over the course of its life.</li></ul></div><div><img src="img/2014OT_08_16.png.jpg" alt="Particle system settings"/></div></li><li class="listitem">The<a id="id626" class="indexterm"/> <strong>Renderer</strong> module <a id="id627" class="indexterm"/>dictates<a id="id628" class="indexterm"/> how the particle is drawn on the screen.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Render Mode</strong>: This defines which method a particle should use to orient itself in the game world.<p>
<strong>Billboard</strong>: This will always face directly at the camera.</p><p>
<strong>Stretched Billboard</strong>: This will face particles at the camera, but stretch them based on the speed of the camera, the particle's speed, or by a specific value.</p><p>
<strong>Horizontal Billboard</strong>: This is flat on the XZ plane of the game world.</p><p>
<strong>Vertical Billboard</strong>: This will always face the player, but will always stay straight along the y axis.</p><p>If set to <strong>Mesh</strong>, you can define a model to be used as a particle rather than a flat plane.</p></li><li class="listitem" style="list-style-type: disc"><strong>Normal Direction</strong>: This is used for the lighting and shading of the particles by adjusting the normal of each plane. A value of <strong>1</strong> points the normals directly at the camera while a value of <strong>0</strong> points them towards the center of the screen.</li><li class="listitem" style="list-style-type: disc"><strong>Material</strong>: This defines the material used to render the particles.</li><li class="listitem" style="list-style-type: disc"><strong>Sort Mode</strong>: This dictates what order the particles should be drawn in, by distance or age.</li><li class="listitem" style="list-style-type: disc"><strong>Sorting Fudge</strong>: This causes particle systems to be drawn earlier than normal. The higher the value, the earlier it will be drawn on the screen. This affects whether the system appears in front of or behind other particle systems or partially transparent objects.</li><li class="listitem" style="list-style-type: disc"><strong>Cast Shadows</strong>: This determines if the particles will block light.</li><li class="listitem" style="list-style-type: disc"><strong>Receive Shadows</strong>: This determines if the particles are affected by the shadows cast by other objects.</li><li class="listitem" style="list-style-type: disc"><strong>Max Particle Size</strong>: This is the total amount of screen space a single particle is allowed to fill. No matter what the real size of the particle is, it will <a id="id629" class="indexterm"/>never fill more than this space of the screen.</li></ul></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec132"/>Creating engine trails</h2></div></div></div><p>To enforce the player's impression<a id="id630" class="indexterm"/> that their ship is moving, we need to create some trails for the ship's engines. This exhaust will trail out as if the ship is moving even though it is not. By making the particle systems part of the group of objects that make up the ship, the engine trails will move and leave particles as one would expect them to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec120"/>Time for action – adding engine trails</h1></div></div></div><p>Engine trails can easily be added and<a id="id631" class="indexterm"/> controlled with the <a id="id632" class="indexterm"/>use of only a particle system.</p><div><ol class="orderedlist arabic"><li class="listitem">To begin with, we need to create a new particle system. Do this by going to the top of the Unity Editor and navigating to <strong>GameObject</strong> | <strong>Create Other</strong> | <strong>Particle System</strong>.</li><li class="listitem">Rename the new particle system to <code class="literal">EngineTrail</code>.</li><li class="listitem">First we look at the <strong>Initial</strong> module. We need the <strong>Looping</strong> and <strong>Prewarm</strong> checkboxes checked. This will keep the ship looking as if it is moving throughout the game and remove the build up the system would otherwise need to create the effect.</li><li class="listitem">Next, we need to control the distance the particles travel. Do this by setting the <strong>Start Lifetime</strong> option to <strong>3</strong> and the <strong>Start Speed</strong> option to <strong>1</strong>.</li><li class="listitem">To keep the <a id="id633" class="indexterm"/>particles sized and positioned properly in space, we need to set the <strong>Start Size</strong> option to <strong>0.8</strong> and choose <strong>World</strong> for <strong>Simulation Space</strong>.</li><li class="listitem">Now we move on to the <strong>Shape</strong> module. We want the particles to fly straight out from the engines. So we use a value of <strong>0</strong> for the <strong>Angle</strong> option and <strong>0.2</strong> for the <strong>Radius</strong> option.</li><li class="listitem">Exhaust tends to fade in color and dissipate in density over time. To achieve this effect, activate the <strong>Color over Lifetime</strong> and <strong>Size over Lifetime</strong> modules.</li><li class="listitem">For the <strong>Color</strong> option, set the <strong>Alpha</strong> option to <strong>0</strong> at the beginning of the gradient and <strong>255</strong> a short way in. As to colors, select a vibrant blue at the beginning, transitioning to white, and then <a id="id634" class="indexterm"/>gray at the end.<div><img src="img/2014OT_08_17.png.jpg" alt="Time for action – adding engine trails"/></div></li><li class="listitem">For the <strong>Size</strong> option, select a linear slope that is maximum at the beginning and minimum<a id="id635" class="indexterm"/> at the end. This is most easily done by clicking on the curve, to the right of the <strong>Size</strong> label, and selecting the third option from the bottom of the <strong>Particle System Curves</strong> window at the bottom of the <strong>Inspector</strong> window.<div><img src="img/2014OT_08_18.png.jpg" alt="Time for action – adding engine trails"/></div></li><li class="listitem">Now, in the <strong>Scene</strong> window, duplicate the <code class="literal">EngineTrail</code> object three times and position them behind the engines of the ship. Be sure to rotate them so the particles are emitted away from the ship.</li><li class="listitem">Finally, make<a id="id636" class="indexterm"/> all of them children of the player's ship. If this step is skipped, they will not follow the ship as it moves.<div><img src="img/2014OT_08_19.png.jpg" alt="Time for action – adding engine trails"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec133"/>
<em>What just happened?</em>
</h2></div></div></div><p>We put into practice <a id="id637" class="indexterm"/>what we learned about particle systems to create trails for our space ship's engines. Because they are children of the ship and simulate in world space, they move with the ship and trail off as one would expect.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec134"/>Have a go hero – more trails</h2></div></div></div><p>The enemy ships have engines too. Try adding trails to the enemy ships. Be careful about picking the local or world space to simulate in. Because the ships move to make it look like the player is moving, simulating in world space could have some unusual side effects.</p><p>If you gave the player a turbo boost effect earlier, it is time to add some extra effects to it now. Try changing the length of the trails when the player is boosting. Perhaps the ship taps into a special type of fuel when it boosts. If it burns a different color, then the trails would have to be a different color, or series of colors, when the player is boosting.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec121"/>Putting it together</h1></div></div></div><p>So far, we learned about audio effects and particle systems on their own. They each can add a lot to the scene, setting the mood and giving that touch of polish that sets a game apart. But there are many effects that cannot stand on their own as one or the other. Explosions, for example, are simply not that impressive unless you have both the visual and auditory effects.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec135"/>Explosions</h2></div></div></div><p>It is so much more satisfying to<a id="id638" class="indexterm"/> destroy enemies when they explode. It takes both a particle effect and the sound effect to make a proper explosion. We will start by creating an explosion prefab. Then we will update the player's shooting to spawn the explosion when asteroids and enemy ships are destroyed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec122"/>Time for action – adding explosions</h1></div></div></div><p>A single particle system and script will allow<a id="id639" class="indexterm"/> us to create some nice explosions that can be used everywhere.</p><div><ol class="orderedlist arabic"><li class="listitem">We first need some new textures to make the explosion look like fire. Luckily, Unity provides a multitude of basic particle textures. To include them in your project, go to the top of the Unity Editor and navigate to <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Particles</strong>.</li><li class="listitem">In the resulting window, select <strong>Import</strong> and wait for Unity to finish importing them. This package is a great resource, including both textures and complete particle systems. However, all of the particle systems included use the old system that will be phased out of Unity over the next few versions. Despite this, we can still make full use of the included materials.</li><li class="listitem">Create a new <code class="literal">particleSystem</code> object and name it <code class="literal">Explosion</code>.</li><li class="listitem"> First, in the <strong>Initial</strong> module, we need to make the effect last for a short time. Set the <strong>Duration</strong> to <strong>0.5</strong> and the <strong>Start Lifetime</strong> option to <strong>1</strong>.</li><li class="listitem">To keep the particles close together, use a value of <strong>0.5</strong> for the <strong>Start Speed</strong> option.<div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>When we are done with this system, it will not loop. However, it is easier to see what we are working with if we let it loop for now.</p></div></div></li><li class="listitem">Next, we need more particles, so go to the <strong>Emission</strong> module. Set the <strong>Rate</strong> option to <strong>120</strong> to generate the proper amount.</li><li class="listitem">An explosion is generally round, so we need to adjust the <strong>Shape</strong> module next. Select <strong>Sphere</strong> for the <strong>Shape</strong> setting and set the <strong>Radius</strong> option to <strong>0.5</strong>.</li><li class="listitem">Now for the<a id="id640" class="indexterm"/> <strong>Color over Lifetime</strong> module. An explosion is bright at the beginning and fades to brown, followed by black as it burns. For the <strong>Color</strong> option, start with an army green color, followed by faded yellow, then medium brown, and finally black at the end. Also, cause <strong>Alpha</strong> to fade in at the beginning and out at the end. This keeps the particles from popping in and out of existence.<div><img src="img/2014OT_08_20.png.jpg" alt="Time for action – adding explosions"/></div></li><li class="listitem">Next, we need a fire material for our particles. For the <strong>Material</strong> setting in the <strong>Renderer</strong> module, select the <strong>Fire Smoke</strong> material. It can also be found in your <strong>Project</strong> window by going to <strong>Standard Assets</strong> | <strong>Particles</strong> | <strong>Sources</strong> | <strong>Materials</strong>.</li><li class="listitem">Once we are satisfied with the look of the system, make sure the <strong>Play On Awake</strong> checkbox is checked and the <strong>Looping</strong> checkbox is not checked in the <strong>Initial</strong> module.</li><li class="listitem">As with the asteroids and enemy ships, the explosion needs to move around our player as they move. It also needs to destroy itself when it is done emitting. So, create a new script and name it <code class="literal">Explosion</code>.</li><li class="listitem">This script is short and only<a id="id641" class="indexterm"/> includes two functions. The first function, <code class="literal">Update</code>, checks to see if the <code class="literal">particleSystem</code> object is missing or has finished playing. If either is true, the <code class="literal">gameObject</code> is destroyed.<div><pre class="programlisting">public void Update() {
  if(particleSystem == null || !particleSystem.isPlaying)
    Destroy(gameObject);
}</pre></div></li><li class="listitem">The second function, <code class="literal">LateUpdate</code>, simply uses the <code class="literal">PlayerShip.Rotate</code> function, which we created in <a class="link" href="ch06.html" title="Chapter 6. Specialties of the Mobile Device – Touch and Tilt">Chapter 6</a>, <em>Specialities of the Mobile Device – Touch and Tilt</em>, to move the explosion for the player's movement. This is the same way we move the asteroids and enemy ships around as the player moves.<div><pre class="programlisting">public void LateUpdate() {
  PlayerShip.Rotate(transform);
}</pre></div></li><li class="listitem">Return to Unity and add the script to the <code class="literal">Explosion</code> object.</li><li class="listitem">Next, add an <strong>Audio Source</strong> component to the object.</li><li class="listitem">For this component, we need the <strong>Play On Awake</strong> checkbox checked. Also select <strong>Linear Rolloff</strong> for the <strong>Volume Rolloff</strong> mode and <strong>10</strong> for the <strong>Min Distance</strong>, both found under <strong>3D Sound Settings</strong>.</li><li class="listitem">And, of course, select the <strong>Explosion</strong> sound effect for the source's audio clip. These settings will cause the sound to play as soon as the explosion is spawned.</li><li class="listitem">To complete the explosion's creation, turn the object into a prefab and delete the instance from the scene.</li><li class="listitem">Next, we need to update the <code class="literal">TouchShoot</code> script to utilize the explosion. Open it now.</li><li class="listitem">To the beginning, we add a variable to hold a reference to the explosion.<div><pre class="programlisting">public GameObject explosion;</pre></div></li><li class="listitem">After the line where we make use of the <code class="literal">Physics.Raycast</code> function<a id="id642" class="indexterm"/> and before we destroy the shot object, add this line. If there is a reference to the explosion, it uses the <code class="literal">Instantiate</code> function to spawn a new instance of the explosion and sets its position and rotation to that of the object that was shot.<div><pre class="programlisting">if(explosion != null) Instantiate(explosion, hit.transform.position, hit.transform.rotation);</pre></div></li><li class="listitem">Back in Unity, find the instance of the <code class="literal">TouchShoot</code> script component on the player's ship. Add the reference to<a id="id643" class="indexterm"/> the <code class="literal">Explosion</code> prefab in the new <strong>Explosion</strong> slot.<div><img src="img/2014OT_08_21.png.jpg" alt="Time for action – adding explosions"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec136"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created an explosion. Unity provides us with a slew of particle textures with which we can create a multitude of effects. There are also a few particle systems already created, including an explosion. However, that explosion uses the old system and will not be included in Unity for much longer. We also updated our enemy ships and asteroids so they spawn the explosions when they are destroyed by the player.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Have a go hero – more types of explosions</h2></div></div></div><p>One explosion is alright, but it is odd that the asteroids explode in the same manner as the ships. Different gases, fuels, and rock compositions all burn in different colors and with varying amounts of vigor. Create some more explosions for the different objects flying around your space. Change the colors and size to suit what is exploding. Also, explore other sound effects that provide differing auditory clues as to what is exploding. Finally, try to create a multi-explosion system. Perhaps the shots from the player cause the first explosion, and a chain reaction causes explosions in the weapon hold and engine compartment. To achieve this, take a look at using subemitters, or spawn a couple of different particle systems around the ship when it is destroyed.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec138"/>Creating laser blasts</h2></div></div></div><p>Being able to destroy objects and<a id="id644" class="indexterm"/> see them explode is great. It gives the player a reward for performing a simple action. However, when one fires a gun of any sort, you expect a reaction from it, whether or not anything is hit. To that end, we are going to create a muzzle-flash-type effect for the player's ship. Every time they tap the screen to fire, some particle systems will flash and a sound effect will play.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec123"/>Time for action – adding laser blasts</h1></div></div></div><p>A muzzle flash generally consists of two parts. The first is a straight blast, forward along the barrel. The second is<a id="id645" class="indexterm"/> a fan around the base of the first.</p><div><ol class="orderedlist arabic"><li class="listitem">To begin, create a new <code class="literal">particleSystem</code> object and rename it as <code class="literal">LineBlast</code>; we will now proceed to make the first part.</li><li class="listitem">The flash does not last for very long, so find the <strong>Duration</strong> option in the <strong>Initial</strong> module and set it to <strong>0.1</strong>.</li><li class="listitem">Next, we need to set the <strong>Start Lifetime</strong> option to <strong>0.1</strong> so the particles do not stay on screen for very long.</li><li class="listitem">The flash does not move away from the muzzle, so set the <strong>Start Speed</strong> option to <strong>1</strong>, keeping the particles close.</li><li class="listitem">The particles need to be sized to correspond with the size of our ship's muzzle. Set the <strong>Start Size</strong> option to <strong>0.2</strong> to keep them small.</li><li class="listitem">It is no fun if our laser blasts are just white, so change the <strong>Start Color</strong> value to an appropriate color for your lasers.</li><li class="listitem">Last up for the <strong>Initial</strong> module is to uncheck the <strong>Play On Awake</strong> checkbox, keeping the system from triggering immediately when loaded.</li><li class="listitem">Next we need to adjust the <strong>Emission</strong> module. The flash occurs in a burst, so set the <strong>Rate</strong> option to <strong>0</strong>.</li><li class="listitem">To make the burst, click on the <strong>+</strong> sign to the right of the <strong>Bursts</strong> list. A value of <strong>5</strong> will work well.</li><li class="listitem">Next we adjust the <strong>Shape</strong> module to emit the particles along a straight line. To this end, set the <strong>Angle</strong> option to <strong>0</strong> and the <strong>Radius</strong> option to <strong>0.01</strong>.</li><li class="listitem">Finally, we need to adjust the <strong>Renderer</strong> module. To stretch out the particles, change the <strong>Render Mode</strong> option to <strong>Stretched Billboard</strong> and set the <strong>Length Scale</strong> option to <strong>-4.5</strong>.</li><li class="listitem">Now that we are satisfied with the way this system looks, uncheck the <strong>Looping</strong> checkbox<a id="id646" class="indexterm"/> in the <strong>Initial</strong> module.</li><li class="listitem">Now create the second <code class="literal">particleSystem</code> object and rename it as <code class="literal">SpreadBlast</code>.</li><li class="listitem">These particles should last for as long as those of the first system. So, in the <strong>Initial</strong> module, set the <strong>Duration</strong> option to <strong>0.1</strong>, <strong>Start Lifetime</strong> to <strong>0.1</strong>, <strong>Start Speed</strong> to <strong>1</strong>, <strong>Start Size</strong> to <strong>0.2</strong>, and uncheck <strong>Play On Awake</strong>.</li><li class="listitem">To make these particles distinct from the line, set the <strong>Start Color</strong> value to a slightly darker color.</li><li class="listitem">Next, in the <strong>Emission</strong> module, set the <strong>Rate</strong> option to <strong>0</strong> and add the <strong>Bursts</strong> option with a <strong>Particles</strong> value of <strong>30</strong>.</li><li class="listitem">For the <strong>Shape</strong> module, set the <strong>Angle</strong> option to <strong>60</strong> and the <strong>Radius</strong> option to <strong>0.01</strong>. This causes the particles to fan out when spawned.</li><li class="listitem">For the <strong>Renderer</strong> module, set the <strong>Render Mode</strong> option to <strong>Stretched Billboard</strong> and the <strong>Length Scale</strong> option to <strong>-3</strong>.</li><li class="listitem">Finally, once we are satisfied with the look of the system, again uncheck the <strong>Looping</strong> checkbox in the <strong>Initial</strong> module.</li><li class="listitem">Before we put the particle systems in place, we need to create a script. Create a new one and name it <code class="literal">LaserBlast</code>. This script will trigger the particle systems and the audio clip to play.</li><li class="listitem">This script starts with a single variable. This variable holds the list of systems to be triggered when the script is told to fire.<div><pre class="programlisting">public ParticleSystem[] particles = new ParticleSystem[0];</pre></div></li><li class="listitem">Next we have the only function in the script, <code class="literal">Fire</code>. It starts by making sure there is an <strong>Audio Source</strong> component on the same <code class="literal">GameObject</code>. If it is present, <code class="literal">PlayOneShot</code> is called using the source's clip. This function plays the passed file once without blocking the playing of other clips.<div><pre class="programlisting">public void Fire() {
  if(audio != null)
    audio.PlayOneShot(audio.clip);</pre></div></li><li class="listitem">The function continues by looping through the list of particle systems and using <code class="literal">Play</code> to trigger them if they exist.<div><pre class="programlisting">  for(int i=0;i&lt;particles.Length;i++) {
    if(particles[i] != null)
      particles[i].Play();
  }
}</pre></div></li><li class="listitem">Next, we need to update the <code class="literal">TouchShoot</code> script. It needs to call the <code class="literal">Fire</code> function on the <code class="literal">LaserBlast</code> script when the player touches the screen. To that end, we<a id="id647" class="indexterm"/> first add the <code class="literal">lasers</code> variable to hold the list of objects that need to be triggered.<div><pre class="programlisting">public LaserBlast[] lasers = new LaserBlast[0];</pre></div></li><li class="listitem">To the beginning of the <code class="literal">Update</code> function, we add the <code class="literal">didFire boolean</code> value. It will keep the lasers from being triggered more than once per frame.<div><pre class="programlisting">bool didFire = false;</pre></div></li><li class="listitem">We next set the Boolean to true after the <code class="literal">if</code> statement where we check to see if the touch's phase value is found to be equal to <code class="literal">TouchPhase.Began</code>.<div><pre class="programlisting">didFire = true;</pre></div></li><li class="listitem">At the end of the <a id="id648" class="indexterm"/><code class="literal">Update</code> function, if the <code class="literal">didFire boolean</code> is true, the <code class="literal">Fire</code> function that we will be writing shortly is called.<div><pre class="programlisting">if(didFire) Fire();</pre></div></li><li class="listitem">Last up for the script, we add the <code class="literal">Fire</code> function. This function simply loops through the <code class="literal">lasers</code> array and calls their <code class="literal">Fire</code> function if they exist.<div><pre class="programlisting">private void Fire() {
  for(int i=0;i&lt;lasers.Length;i++) {
    if(lasers[i] != null)
      lasers[i].Fire();
  }
}</pre></div></li><li class="listitem">Now that we have all of the pieces, we need to put them together. Start by creating a new empty <code class="literal">GameObject</code> and naming it <code class="literal">LaserBlast</code>.</li><li class="listitem">Next, make the <code class="literal">LineBlast</code> and <code class="literal">SpreadBlast</code> particle systems children of this new object. Be sure to set their positions and rotations to <code class="literal">0</code>.</li><li class="listitem">Add our <code class="literal">LaserBlast</code> script to the object of the same name and add the two particle systems to the <strong>Particles</strong> list on the script component.</li><li class="listitem">Next, add an <strong>Audio Source</strong> component to the object. Select the <strong>Laser</strong> sound effect for the <strong>Audio Clip </strong>value.</li><li class="listitem">Finally for this object, expand the <strong>3D Sound Settings</strong> group and select <strong>Linear Rolloff</strong> for the <strong>Volume Rolloff</strong> value; otherwise, we will not be able to hear it.</li><li class="listitem">Position the laser blast in front of the muzzles of the player's ship. Duplicate it as needed to cover all the points. Also, make sure their local z axis points forward along the muzzles.</li><li class="listitem">Next, make<a id="id649" class="indexterm"/> all of your <code class="literal">LaserBlast</code> objects children of the player's ship so they keep moving with it.</li><li class="listitem">Finally, add the objects to the <strong>Lasers</strong> list on the <code class="literal">TouchShoot</code> script component.<div><img src="img/2014OT_08_22.png.jpg" alt="Time for action – adding laser blasts"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec139"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created laser blasts for the player. Every time the player touches the screen, they are triggered. This way the player can tell that they are shooting even if they fail to hit anything. It is a quick and short effect, but adds a lot to the final experience.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec140"/>Have a go hero – more types of lasers</h2></div></div></div><p>The player can shoot lasers, now the enemy needs to too. Add some laser blasts to the enemy ships. Also, it is time to replace their sphere bullets with something better. Create a plasma ball to replace the sphere bullets. A smaller, looping version of the explosion could work for the ball. An appropriately colored version of the engine trails could work for the ball's trail as it flies towards the player. It might also be a good idea to add the alarms to the bullets. This way the player knows when they are about to be blasted out of the game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec124"/>Summary</h1></div></div></div><p>In this chapter, we learned about special effects in Unity, specifically audio and particle systems. We started with understanding how Unity handles audio files. By adding background music and an alarm system, we put what was learned into practice. We moved on to understanding particle systems, and created engine trails for our player's ship. Finally, we put the two skill sets together and created explosions and laser blasts. Particle systems and audio effects add a lot to the final polish and look of a game.</p><p>In the next chapter, we complete our experience together by taking a look at optimization in Unity. We will take a look at the tools provided for tracking performance. We will also create our own tool to track specific parts of script performance. We will also create our own tool to track specific parts of script performance. We will explore asset compression and other points that we can change to minimize the application footprint. Finally, key points will be discussed for minimizing lag.</p></div></body></html>