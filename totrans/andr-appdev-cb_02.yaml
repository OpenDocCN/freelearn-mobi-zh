- en: Chapter 2. Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Defining and inflating a layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RelativeLayout
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LinearLayout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables – TableLayout and GridLayout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ListView, GridView, and Adapters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing layout properties during runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing layouts with the Hierarchy Viewer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, the User Interface is defined in a **Layout**. A layout can be
    declared in XML or created dynamically in code. (It''s recommended to declare
    the layout in XML rather than in code to keep the presentation layer separate
    from the implementation layer.) A layout can define an individual `ListItem`,
    a fragment, or even the entire Activity. Layout files are stored in the `/res/layout`
    folder and referenced in code with the following identifier: `R.layout.<filename_without_extension>`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Android provides a useful variety of `Layout` classes that contain and organize
    individual elements of an activity (such as buttons, checkboxes, and other `Views`).
    The `ViewGroup` object is a container object that serves as the base class for
    Android's family of `Layout` classes. The Views placed in a layout form a hierarchy,
    with the topmost layout being the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Android provides several built-in layout types designed for specific purposes,
    such as the `RelativeLayout`, which allows Views to be positioned with respect
    to other elements. The `LinearLayout` can stack Views or align them horizontally,
    depending on the orientation specified. The `TableLayout` can be used for laying
    out a grid of Views. Within various layouts, we can also justify Views with `Gravity`
    and provide proportional size with `Weight` control. Layouts and `ViewGroups`
    can be nested within each other to create complex configurations. Over a dozen
    different Layout objects are provided for managing widgets, lists, tables, galleries,
    and other display formats, plus you can always derive from the base classes to
    create your own custom layouts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Defining and inflating a layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the Android Studio wizard to create a new project, it automatically
    creates the `res/layout/activity_main.xml` file (as shown in the following screenshot).
    It then inflates the XML file in the `onCreate()` callback with `setContentView(R.layout.activity_main)`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and inflating a layout](img/05057_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: For this recipe, we will create two, slightly different layouts and switch between
    them with a button.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `InflateLayout`. Once the
    project is created, expand the `res/layout` folder so we can edit the `activity_main.xml`
    file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `res/layout/activity_main.xml` file so it includes a button as defined
    here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now make a copy of `activity_main.xml` and call it `activity_main2.xml`. Change
    the button so it matches the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `MainActivity.java` and add the following two methods to handle the button
    clicks:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run this application on a device or emulator to see it in action.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key here is the call to `setContentView()`, which we have come across before
    in the autogenerated `onCreate()` code. Just pass a layout ID to `setContentView()`
    and it automatically inflates the layout.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于对`setContentView()`的调用，我们之前在自动生成的`onCreate()`代码中遇到过。只需将布局ID传递给`setContentView()`，它就会自动展开布局。
- en: This code is meant to make the concept easy to understand but would be overkill
    for simply changing the property of a Button (in this example, we could just change
    the alignment on the button click). Inflating the layout is usually needed once,
    in the `onCreate()` method, but there are times when you may want to manually
    inflate a layout, as we did here. (If you were manually handling orientation changes,
    it would be a good example.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是使概念易于理解，但仅用于更改按钮（在本例中，我们可以在按钮点击时更改对齐方式）的属性时可能会过度。展开布局通常在`onCreate()`方法中只需要一次，但有时您可能希望手动展开布局，就像我们在这里所做的那样。（如果您手动处理方向变化，这将是一个很好的例子。）
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'As well as identifying a layout using a resource ID, as we did here, `setContentView()`can
    also take a View as an argument, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用资源ID标识布局，如我们在这里所做的那样，`setContentView()`还可以接受一个视图作为参数，例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As mentioned previously, see the *Fragment* topic, in [Chapter 5](ch05.html
    "Chapter 5. Exploring Fragments, AppWidgets, and the System UI"), *Exploring Fragments,
    AppWidgets, and the System UI*, for the alternative method to change the screen
    layout
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，请参阅*Fragment*主题，在[第5章](ch05.html "第5章. 探索Fragment、AppWidget和系统UI")，*探索Fragment、AppWidget和系统UI*，了解更改屏幕布局的替代方法
- en: Using RelativeLayout
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RelativeLayout
- en: As mentioned in the *Introduction*, the `RelativeLayout` allows Views to be
    position-relative to each other and the parent. `RelativeLayout` is particularly
    useful for reducing the number of nested layouts, which is very important for
    reducing memory and processing requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如*简介*中所述，`RelativeLayout`允许视图相对于彼此和父视图进行定位。`RelativeLayout`特别适用于减少嵌套布局的数量，这对于减少内存和处理需求非常重要。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project and call it `RelativeLayout`. The default layout uses a
    `RelativeLayout`, which we will use to align Views both horizontally and vertically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并将其命名为`RelativeLayout`。默认布局使用`RelativeLayout`，我们将使用它来水平和垂直对齐视图。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Open the `res/layout/activity_main.xml` file and change it as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`文件并按以下方式修改：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code, or view the layout in the **Design** tab
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，或在**设计**选项卡中查看布局
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This is a very straightforward exercise but it demonstrates several of the
    `RelativeLayout` options: `layout_centerVertical`, `layout_centerHorizontal`,
    `layout_below`, `layout_alignParentBottom`, and so on.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的练习，但它演示了几个`RelativeLayout`选项：`layout_centerVertical`、`layout_centerHorizontal`、`layout_below`、`layout_alignParentBottom`等等。
- en: 'The most commonly used `RelativeLayout` layout attributes include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的`RelativeLayout`布局属性包括：
- en: '`layout_below`: This View should be below the View specified'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_below`: 此视图应在指定的视图之下'
- en: '`layout_above`: This View should be above the View specified'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_above`: 此视图应在指定的视图之上'
- en: '`layout_alignParentTop`: Align this View to the top edge of the parent'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentTop`: 将此视图与父视图的顶部边缘对齐'
- en: '`layout_alignParentBottom`: Align this View to the bottom edge of the parent'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentBottom`: 将此视图与父视图的底部边缘对齐'
- en: '`layout_alignParentLeft`: Align this View to the left edge of the parent'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentLeft`: 将此视图与父视图的左侧边缘对齐'
- en: '`layout_alignParentRight`: Align this View to the right edge of the parent'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentRight`: 将此视图与父视图的右侧边缘对齐'
- en: '`layout_centerVertical`: Center this View vertically within the parent'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerVertical`: 在父视图中垂直居中此视图'
- en: '`layout_centerHorizontal`: Center this View horizontally within the parent'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerHorizontal`: 在父视图中水平居中此视图'
- en: '`layout_center`: Center this View both horizontally and vertically within the
    parent'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_center`: 在父视图中水平和垂直居中此视图'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the complete list of `RelativeLayout` parameters, visit: [http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看`RelativeLayout`参数的完整列表，请访问：[http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html)。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In contrast to what we saw earlier, here is an example using a `LinearLayout`
    just to center a `TextView` (creating the same effect as the `layout_center` parameter
    of `RelativeLayout`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice this layout is one level deeper than the equivalent `RelativeLayout`
    (which is a `LinearLayout` nested within the parent `LinearLayout`.) Though a
    simple example, it's a good idea to avoid unnecessary nesting as it can impact
    performance, especially when a layout is being repeatedly inflated (such as a
    `ListItem`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Using LinearLayout*, which will give you an alternative layout
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Optimizing layouts with the Hierarchy Viewer* recipe for more information
    on efficient layout design
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LinearLayout
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common layout option is the `LinearLayout`, which arranges the child
    Views in a single column or single row, depending on the orientation specified.
    The default orientation (if not specified) is vertical, which aligns the Views
    in a single column.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The `LinearLayout` has a key feature not offered in the `RelativeLayout`—the
    `weight` attribute. We can specify a `layout_weight` parameter when defining a
    View to allow the View to dynamically size based on the available space. Options
    include having a View fill all the remaining space (if a View has a higher weight),
    having multiple Views fit within the given space (if all have the same weight),
    or spacing the Views proportionally by their weight.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `LinearLayout` with three `EditText` Views to demonstrate how
    the weight attribute can be used. For this example, we will use three `EditText`
    Views—one to enter a `To Address` parameter, another to enter a `Subject`, and
    the third to enter a `Message`. The `To` and `Subject` Views will be a single
    line each, with the remaining space given to the Message View.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project and call it `LinearLayout`. We will replace the default
    `RelativeLayout` created in `activity_main.xml` with a `LinearLayout`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `res/layout/activity_main.xml` file and replace it as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code, or view the layout in the **Design** tab.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using vertical orientation with the `LinearLayout`, the child Views are
    created in a single column (stacked on top of each other). The first two Views
    use the `android:layout_height="wrap_content"` attribute, giving them a single
    line each. `editTextMessage` uses the following to specify the height:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using the `LinearLayout`, it tells Android to calculate the height based
    on the weight. A weight of 0 (the default if not specified) indicates the View
    should not expand. In this example, `editTextMessage` is the only View defined
    with a weight, so it alone will expand to fill any remaining space in the parent
    layout.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the horizontal orientation, specify `android:layout_height="0dp"`
    (along with the weight) to have Android calculate the width.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: It might be helpful to think of the weight attribute as a percentage. In this
    case, the total weight defined is 1, so this View gets 100 percent of the remaining
    space. If we assigned a weight of 1 to another View, the total would be 2, so
    this View would get 50 percent of the space. Try adding a weight to one of the
    other Views (make sure to change the height to `0dp` as well) to see it in action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'If you added a weight to one (or both) of the other Views, did you notice the
    text position? Without specifying a value for `gravity`, the text just remains
    in the center of the View space. The `editTextMessage` specifies: `android:gravity="top"`,
    which forces the text to the top of the View.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple attribute options can be combined using bitwise `OR`. (Java uses the
    pipe character (|) for `OR`). For example, we could combine two gravity options
    to both align along the top of the parent and center within the available space:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It should be noted that the `layout_gravity` and `gravity` tags are not the
    same thing. Where `layout_gravity` dictates where in its parent a View should
    lie, `gravity` controls the positioning of the contents within a View—for example,
    the alignment of text on a button.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe, *Using the RelativeLayout*
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables – TableLayout and GridLayout
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to create a table in your UI, Android provides two convenient
    layout options: the `TableLayout` (along with `TableRow`) and the `GridLayout`
    (added in API 14). Both layout options can create similar looking tables, but
    each using a different approach. With the `TableLayout`, rows and columns are
    added dynamically as you build the table. With the `GridLayout`, row and column
    sizes are defined in the layout definition.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Neither layout is better, it's just a matter of using the best layout for your
    needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you
    could easily find yourself using both layouts, even within the same application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To stay focused on the layouts and offer an easier comparison, we will create
    two separate applications for this recipe. Create two new Android projects, the
    first called `TableLayout` and the other called `GridLayout`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with the `TableLayout` project, open **activity_main.xml**`.` Change
    the root layout to `TableLayout`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add three `TableRows` with three sets of `TextViews` to each `TableRow` to
    create a 3 x 3 matrix. For demonstration purposes, the columns are labeled A-C
    and the rows 1-3, so the first row of `TextViews` will be A1, B1, and C1\. The
    final result will look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, open the `GridLayout` project to edit `activity_main.xml`. Change the root
    layout to `GridLayout`. Add the `columnCount=3` and `rowCount=3` attributes to
    the `GridLayout` element.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add nine `TextViews` to `GridLayout`. We will use the same text as the
    preceding `TableLayout` for a consistent comparison. Since the `GridView` does
    not use `TableRows`, the first three `TextViews` are in Row 1, the next three
    are in Row 2, and so on. The final result will look like this:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can either run the application or use the **Design** tab to see the results.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see when viewing the tables created, the tables basically look the
    same on screen. The main difference is the code to create them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the `TableLayout` XML, each row is added to the table using a `TableRow`.
    Each View becomes a column. This is not a requirement as cells can be skipped
    or left empty. (See how to specify the cell location in a `TableRow` in the following
    section.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The `GridLayout` uses the opposite approach. The number of rows and columns
    are specified when creating the table. We don't have to specify the row or column
    information (though we can, discussed as follows). Android will automatically
    add each View to the cells in order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see more similarities between the layouts. Both layouts have
    the ability to stretch columns to use the remaining screen space. For the `TableLayout`,
    add the following attribute to the xml declaration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`stretchColumns` specifies the (zero based) index of the columns to stretch.
    (`android:shrinkColumns` is a zero-based index of columns that can shrink, so
    the table can fit the screen.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the same effect with the `GridLayout`, add the following attribute
    to all the Views in the B column (`textView2`, `textView5`, and `textView8`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All cells in a given column must define the weight or it will not stretch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at some of the differences, as this is really the key to determine
    which layout to use for a given task. The first thing to note is how the columns
    and rows are actually defined. In the `TableLayout`, the rows are specifically
    defined, using a `TableRow`. (Android will determine the number of columns in
    the table based on the row with the most cells.) Use the `android`:`layoutColumn`
    attribute when defining the View to specify the column.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, with the `GridLayout`, the row and column counts are specified
    when defining the table (using the `columnCount` and `rowCount` as shown previously.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we just added `TextViews` to the `GridLayout` and
    let the system position them automatically. We can alter this behavior by specifying
    the row and column position when defining the View, such as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android automatically increments the cell counter after adding each View, so
    the *next* View should also specify the row and column, otherwise, you may not
    get the intended result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Like the `LinearLayout` shown in the *LinearLayout* recipe, the `GridLayout`
    also offers the orientation attribute of supporting both horizontal (the default)
    and vertical. The orientation determines how the cells are placed. (Horizontal
    fills the columns first, then moves down to the next row. Vertical fills the first
    column on each row, then moves to the next column.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Using ListView, GridView, and Adapters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListView` and `GridView` are both descendants of `ViewGroup`, but they
    are used more like a View since they are data driven. In other words, rather than
    defining all the possible Views that might fill a `ListView` (or `GridView`) at
    design time, the contents are created dynamically from the data passed to the
    View. (The layout of the `ListItem` might be created at design time to control
    the look of the data during runtime.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you needed to present a list of countries to a user, you
    could create a `LinearLayout` and add a button for each country. There are several
    problems with this approach: determining the countries available, keeping the
    list of buttons up to date, having enough screen space to fit all the countries,
    and so on. Otherwise, you could create a list of countries to populate a `ListView`,
    which will then create a button for each entry.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We will create an example, using the second approach, to populate a `ListView`
    from an array of country names.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `ListView`. The default `ActivityMain`
    class extends the `Activity` class. We will change it to extend the `ListActivity`
    class instead. We will then create a simple string list and bind it to the `ListView`,
    to derivate the buttons at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the **MainActivity.java** file and change the base declaration so it will
    extend `ListActivity` instead of the `Activity` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change `onCreate()` so it matches the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now run the application on an emulator or device to see the populated `ListView`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a simple array of country names, then use that to populate
    a `ListAdapter`. In this example, we used an `ArrayAdapter` when constructing
    the `ListAdapter`, but Android has several other adapter types available as well.
    Such as, if your data is stored in a database, you could use the `CursorAdapter`.
    If one of the built-in types doesn't meet your needs, you can always use the `CustomAdapter`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the adapter with this line of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we instantiate the `ArrayAdapter` using our string array (the last parameter).
    Notice the `android.R.layout.simple_list_item_1` parameter? This defines the layout
    for the button. Here, we are using one of the layouts as provided by Android,
    but we could create our own layout and pass our ID instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the adapter ready, we just pass it to the underlying `ListView`
    with the `setListAdapter()` call. (The underlying `ListView` comes from extending
    the `ListViewActivity`.) Finally, we implement the `setOnItemClickListener` to
    display a Toast when the user presses a button (which represents a country) in
    the list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了适配器，我们只需通过`setListAdapter()`调用将其传递给底层的`ListView`。（底层的`ListView`来自扩展`ListViewActivity`。）最后，我们实现`setOnItemClickListener`以在用户按下列表中的按钮（代表一个国家）时显示Toast。
- en: '`ListViews` are very common in Android as they make efficient use of screen
    space with a scrolling View, which can be very handy on small screens. The `ScrollView`
    layout offers an alternative approach to create a similar scrolling effect. The
    main difference between the two approaches is that the `ScrollView` layout is
    fully inflated before being shown to the user, whereas the `ListView` only inflates
    the Views that will be visible. For limited data, this may not be an issue, but
    for larger data sets, the application could run out of memory before the list
    is even shown.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`在Android中非常常见，因为它们通过滚动视图有效地利用屏幕空间，这在小屏幕上非常有用。`ScrollView`布局提供了一个创建类似滚动效果的替代方法。这两种方法的主要区别在于，`ScrollView`布局在显示给用户之前完全填充，而`ListView`只填充将可见的视图。对于有限的数据，这可能不是问题，但对于更大的数据集，应用在列表显示之前可能会耗尽内存。'
- en: Also, since the `ListView` is driven by a data adapter, the data can easily
    be changed. Even in our limited example, adding a new country to the screen is
    as simple as adding the name to the country list. More importantly, the list can
    be updated during runtime while the user is using the app (for example, downloading
    an updated list from a website to show real-time options).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`ListView`是由数据适配器驱动的，数据可以轻松更改。即使在我们的有限示例中，将一个新国家添加到屏幕上也只需将名称添加到国家列表中。更重要的是，列表可以在用户使用应用时更新（例如，从网站下载更新列表以显示实时选项）。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ListView` also supports a multiple selection mode using the `setChoiceMode()`
    method. To see it in action, add the following line of code after `setListAdapter()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`还支持使用`setChoiceMode()`方法的多选模式。要看到它的实际效果，请在`setListAdapter()`之后添加以下代码行：'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, change the `ListItem` layout from `android.R.layout.simple_list_item_1`
    to `android.R.layout.simple_list_item_checked`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`ListItem`布局从`android.R.layout.simple_list_item_1`更改为`android.R.layout.simple_list_item_checked`。
- en: While most applications requiring a scrolling list turn to the `ListView`, Android
    also offers the `GridView`. They are very similar in functionality, even using
    the same data adapters. The main difference is visual which allows multiple columns.
    For a better understanding, let's change the `ListView` example to a `GridView`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数需要滚动列表的应用都转向使用`ListView`，但Android还提供了`GridView`。它们在功能上非常相似，甚至使用相同的数据适配器。主要区别是视觉上的，允许多列。为了更好地理解，让我们将`ListView`示例更改为`GridView`。
- en: 'To start, we need to change `MainActivity` to extend from `Activity` again,
    instead of `ListActivity`. (This will undo the preceding Step 1.) Then, replace
    `onCreate()` with the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`MainActivity`改为从`Activity`扩展，而不是`ListActivity`。（这将撤销前面的步骤1。）然后，用以下代码替换`onCreate()`：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, there's more setup code for the `GridView` than there was for
    the `ListView`. The `onCreate()` method creates a new `GridView` and passes it
    in the `setContentView()` call. (We used this variation of `setContentView`, as
    was mentioned in *Defining and inflating a layout*, instead of creating a layout
    with just a `GridView`, but the end result is the same.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为`GridView`设置的代码比`ListView`多。`onCreate()`方法创建一个新的`GridView`，并在`setContentView()`调用中传递它。（正如在*定义和填充布局*中提到的，我们使用了这种`setContentView`变体，而不是仅创建一个包含`GridView`的布局，但最终结果是一样的。）
- en: The `ListViewActivity` base class handles much of this, but the `GridView` does
    not have a corresponding activity class to extend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListViewActivity`基类处理了其中大部分工作，但`GridView`没有相应的活动类可以扩展。'
- en: Changing layout properties during runtime
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时更改布局属性
- en: In Android development, it's generally the preferred practice to define the
    UI with XML and the application code in Java, keeping the User Interface code
    separate from the application code. There are times where it is much easier or
    more efficient, to alter (or even build) the UI from the Java code. Fortunately,
    this is easily supported in Android.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We saw a small example of modifying the layout from code in the previous recipe,
    where we set the number of `GridView` column to display in the code. In this recipe,
    we will obtain a reference to the `LayoutParams` object to change the margin during
    runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will set up a simple layout with XML and use a `LinearLayout.LayoutParams`
    object to change the margins of a View during runtime.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: How to do it....
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file and change the layout from `RelativeLayout`
    to `LinearLayout`. It will look as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a TextView and include an ID as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add `Button` and include an ID as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `MainActivity.java` and add the following code to the `onCreate()` method
    to set up an `onClick` event listener:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program on a device or emulator.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every View (and therefore `ViewGroup`) has a set of layout parameters associated
    with it. In particular, all Views have parameters to inform their parent of their
    desired height and width. These are defined with the `layout_height` and `layout_width`
    parameters. We can access this layout information from the code with the `getLayoutParams()`
    method. The layout information includes the layout height, width, margins, and
    any class-specific parameters. In this example, we moved the button on each click
    by obtaining the button `LayoutParams` and changing the margin.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing layouts with the Hierarchy Viewer
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can start optimizing your layouts, it helps to understand the Android
    layout process. Inflating a layout, begins when the activity first comes into
    display. Three steps occur:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Measure**: This is where the Views determine their size, starting with the
    parent and working through all the children. The parent may have to call its children
    multiple times to work out the final size.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout**: This is where the parent determines the position of its children'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw**: This is where the Views are actually rendered'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process starts with the parent, which then iterates through all its children.
    Those children iterate through their children. This creates the Layout Tree, with
    the parent becoming the root node in the tree.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchy Viewer** is a tool included with the **Android SDK** for inspecting
    layouts. It graphically shows the Layout Tree along with timing results for each
    view/node. By examining the tree layout and the timing; you can look for inefficient
    design and bottlenecks. Armed with this information, you''re in position to optimize
    your layouts.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will use Hierarchy Viewer to inspect the example layout
    given in the *Using RelativeLayout* recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *There's more…* section of the *Using RelativeLayout* recipe, a `LinearLayout`
    example was shown to highlight the difference between the layouts. The comment
    was made stating the `LinearLayout` required a nested layout. We're going to create
    a new project called `OptimizingLayouts` using the example `LinearLayout`. We
    will then use Hierarchy Viewer to inspect the layout. We will need a rooted Android
    device or the emulator for this Recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hierarchy Viewer will only connect to rooted devices, such as an emulator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `OptimizingLayouts` project in Android Studio. Run the project on your
    rooted device (or emulator) and make sure the screen is visible (unlock if needed).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Android Studio, start the Android Device Monitor by going to the following
    menu option: **Tools** | **Android** | **Android Device Monitor**.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Android Device Monitor, change to the Hierarchy View perspective, by going
    to **Window** | **Open Perspective…** this will bring up the following dialog:![How
    to do it...](img/05057_02_02.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on **Hierarchy Viewer** and on **OK**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Windows** section on the left is the list of devices with the running
    processes. Click on the `OptimizingLayouts` process to inspect the layout.![How
    to do it...](img/05057_02_03.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the graphical representation of this activity in the **TreeView** section
    (in the center pane, which occupies most of the Hierarch Viewer perspective).![How
    to do it...](img/05057_02_04.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tree Layout section shows a graphical hierarchy of the Views that comprise
    this layout, along with the layout times. (Unfortunately for this demonstration,
    the render times are too fast for visual color-coding references.) What's important
    for this example is the nested `LinearLayouts` as shown previously. (It's worth
    taking some time to explore the other Views that make up this layout so you can
    see what Android is doing for us behind the scenes.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned in the `RelativeLayout` example, the solution is to redesign
    this layout using the `RelativeLayout`. Ideally, we want a wider, flatter layout,
    rather than deeply nested layouts to reduce the number of iterations required
    during the sizing step. For timing purposes, this is obviously a trivial example,
    but even this example can have an impact. Imagine the user flicking through a
    `ListView` with thousands of items based on this inefficient layout. If you experience
    stuttering while scrolling, your optimizing steps could start by examining the
    layout in Hierarchy Viewer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Lint** is another tool included with the Android SDK with built-in support
    by Android Studio. By default, you''re already using Lint to check your code for
    issues such as deprecated API calls, unsupported API calls for the target API
    level, security issues, and so on. For our Optimizing Layout concerns, some of
    the conditions that Lint will automatically check include the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Deep layouts — the default maximum is 10 levels
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层布局——默认最大深度为 10 级
- en: Nested weights, which are bad for performance
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套权重，这会影响性能
- en: Useless parent
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无用的父节点
- en: Useless leaf
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无用的叶子节点
- en: 'If you check the Lint warning in Android Studio for this layout, you will see
    the following warning on the second `LinearLayout` element:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 Android Studio 中此布局的 Lint 警告，你将在第二个 `LinearLayout` 元素上看到以下警告：
- en: '![There''s more...](img/05057_02_05.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/05057_02_05.jpg)'
- en: 'The `ViewStub` can also be used to optimize a layout. Think of the `ViewStub`
    as a "lazy load" for your layout. The layout in the `ViewStub` will not inflate
    until it''s needed, which reduces the Views needed to inflate. The layout will
    render faster and use less memory. This is a great way to have functionality that
    is seldom used, such as a `Print` feature, available when needed, but that does
    not take up memory when not needed. Here''s an example of a `ViewStub`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewStub` 也可以用来优化布局。将 `ViewStub` 想象成布局的“懒加载”。在 `ViewStub` 中的布局只有在需要时才会被填充，这减少了需要填充的视图数量。布局将渲染得更快，并使用更少的内存。这是一个很好的方法，可以在需要时提供很少使用的功能，例如
    `打印` 功能，但在不需要时不会占用内存。以下是一个 `ViewStub` 的示例：'
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two ways to actually inflate the `ViewStub`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两种方法可以填充 `ViewStub`：
- en: 'Set the visibility parameter of `ViewStub` to `VISIBLE`:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ViewStub` 的可见性参数设置为 `VISIBLE`：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `inflate()` method on the `ViewStub`:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ViewStub` 上调用 `inflate()` 方法：
- en: '[PRE25]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the `ViewStub` is inflated, the `ViewStub` ID will be removed from the
    layout and replaced with the inflated ID.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `ViewStub` 被填充，`ViewStub` 的 ID 将从布局中移除，并替换为填充后的 ID。
