- en: Chapter 11. Working with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My first experience with generics was back in 2004, when they were first introduced
    in the Java programming language. I can still remember picking up my copy of *The
    Java Programming Language*, *Fourth edition*, which covered Java 5, and reading
    about Java's implementation of generics. Since then, I have used generics in a
    number of projects, not only in Java but in other languages as well. If you are
    familiar with generics in other languages, such as Java, the syntax that Swift
    uses will be familiar to you. Generics allow us to write very flexible and reusable
    code; however, just like with subscripts, we need to make sure that we use them
    properly and do not overuse them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using associated types with protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of generics has been around for a while, so it should not be a new
    concept to developers coming from languages such as Java or C#. Swift's implementation
    of generics is very similar to these languages. For those developers coming from
    other languages such as Objective-C, which do not have generics, they might seem
    a bit foreign at first.
  prefs: []
  type: TYPE_NORMAL
- en: Generics allow us to write very flexible and reusable code that avoids duplication.
    With a type safe language, such as Swift, we often need to write functions or
    types that are valid for multiple types. For example, we might need to write a
    function that swaps the values of two variables; however, we may use this function
    to swap two string types, two int types, and two double types. Without generics,
    we will need to write three separate functions; however, with generics, we can
    write one generic function to provide the swap functionality for multiple types.
    Generics allow us to tell a function or type—I know Swift is a type-safe language,
    but I do not know the type that will be needed yet. I will give you a placeholder
    for now and will let you know what type to enforce later.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, we have the ability to define both generic functions and generic types.
    Let's look at generic functions first.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by examining the problem that generics try to solve and then we
    will see how generics solve this problem. Let''s say that we wanted to create
    functions that swapped the values of two variables (as described in the introduction);
    however, for our application, we have a need to swap two ints, two doubles, and
    two strings. Without generics, this would require us to write three separate functions.
    The following code shows what these functions would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With these three functions, we can swap the original values of two ints, two
    doubles, and two strings. Now, let''s say, as we develop our application further,
    we find out that we also need to swap the values of two UInt32, two floats, or
    even a couple of custom types. We might easily end up with eight or nine swap
    functions. The worst part is that each of these functions contains duplicate code.
    The only difference between these functions is the type of variable change. While
    this solution does work, generics offer a much more elegant and simple solution
    that eliminates the duplication of code. Let''s see how we would condense all
    these three preceding functions into a single generic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at how we defined the `swap()` function. The function itself looks
    pretty similar to a normal function, except for the capital `T`. The capital `T`,
    as used in the `swap()` function, is a placeholder type and tells Swift that we
    will be defining the type later. When we do define the type, the type we define
    will replace all the placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: To define a generic function, we include the placeholder type between two angular
    brackets (`<T>`) after the function's name. We can then use that placeholder type
    in place of any type definition within the parameter definitions, the return type,
    or the function itself. The big thing to keep in mind is that, once the placeholder
    is defined as a type, all the other placeholder assume that type. Therefore, any
    variable or constant defined with that placeholder must conform to that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing special about the capital `T`, we could use any valid identifier
    in place of `T`. The following definitions are perfectly valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In most documentation, generic placeholders are defined with either `T` (for
    type) or `E` (for element). For standard purposes, we will use `T` to define generic
    placeholders in this book. It is also good practice to use `T` to define a generic
    placeholder within our code so that the placeholder is easily recognized when
    we are looking at the code at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to use multiple generic types, we can create multiple placeholders
    by separating them with commas. The following example shows how to define multiple
    placeholders for a single function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are defining two generic placeholders, `T` and `E`. In this
    case, we can set the `T` placeholder to one type and the `E` placeholder to a
    different type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to call a generic function. The following code will swap
    two integers using the `swapGeneric<T>(inout a: T, inout b: T)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the `a: 10 b: 5` line will be printed to the console.
    We can see that we do not have to do anything special to call a generic function.
    The function infers the type from the first parameter and then sets all the remaining
    placeholders to that type. Now, if we need to swap the values of two strings,
    we will call the same function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we call the function in exactly the same way as we called it
    when we wanted to swap two integers. One thing that we cannot do is pass two different
    types into the `swap()` function because we defined only one generic placeholder.
    If we attempt to run the following code, we will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The error that we will receive is `cannot invoke ''swap'' with an argument
    list of type ''(inout Int, b: inout String`, which tells us that we are attempting
    to use a string value with an int value when the function wants only type. The
    reason the function is looking for an Int value is that the first parameter that
    we pass into the function is an Int value; therefore, all the generic types in
    the function became Int types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say we have the following function that has multiple generic types
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function would accept parameters of different types; however; since they
    are of different types, we would be unable to swap the values because the types
    are different. There are also other limitations on generics. For example, we may
    think that the following generic function would be valid; however, we would receive
    an error if we tried to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The error that we receive is `binary operator '==' cannot be applied to two
    'T' operands`. Since the type of the arguments is unknown at the time the code
    is compiled, Swift does not know if it is able to use the equal operator on the
    types; therefore, the error is thrown. We might think that this is a limit that
    will make generics hard to use; however, we have a way to tell Swift that we expect
    the type, represented by the placeholder will have a certain functionality. This
    is done with type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type constraint specifies that a generic type must inherit from a specific
    class or conform to a particular protocol. This allows us to use the methods and
    properties defined by the parent class or protocol within the generic function.
    Let''s look at how to use type constraints by rewriting the `genericEqual()` function
    to use the comparable protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To specify the type constraint, we put the class or protocol constraint after
    the generic placeholder, where the generic placeholder and the constraint are
    separated by a colon. This new function works as we might expect, and it will
    compare the values of the two parameters and return `true` if they are equal or
    `false` if they are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare multiple constraints just like we declare multiple generic types.
    The following example shows how to declare two generic types with different constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the type defined by the `T` placeholder must inherit from
    the `MyClass` class, and the type defined by the `E` placeholder must implement
    the `MyProtocol` protocol. Now that we have looked at generic functions, let's
    take a look at generic types.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already had a general introduction to how generic types work when we
    looked at Swift arrays and dictionaries. A generic type is a class, structure,
    or enum that can work with any type, just like the way the Swift arrays and dictionaries
    work. As we recall, Swift arrays and dictionaries are written so that they can
    contain any type. The catch is we cannot mix-and-match different types within
    an array or dictionary. When we create an instance of our generic type, we define
    the type that the instance will work with. After we define that type, we cannot
    change the type for that instance.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to create a generic type, let's create a simple `List` class.
    This class will use a Swift array as the backend storage for the list and will
    let us add items to the list or retrieve values from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by seeing how to define our generic list type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the generic list type. We can see that we use the
    `<T>` tag to define a generic placeholder, just like we did when we defined a
    generic function. This `T` placeholder can then be used anywhere within the type
    instead of a concrete type definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of this type, we would need to define the type of items
    that our list will hold. The following examples show how to create instances of
    the generic list type for various types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates three instances of the `List` class. The `stringList`
    instance can be used with String types, the `intList` instance can be used with
    Int types, and the `customList` instance can be used with instances of the `MyObject`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to using generics only with classes. We can also define
    structures and enums as generics. The following examples show how to define a
    generic structure and a generic enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step in our `List` class is to add the backend storage array. The
    items stored in this array need to be of the same type as we define when we initiate
    the class; therefore, we will use the `T` placeholder when we define the type
    for the array. The following code shows the `List` class with an array named `items`.
    The `items` array will be defined using the `T` placeholder, so it will hold the
    same types as we defined for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code defines our generic list type and uses `T` as the type placeholder.
    We can then use the `T` placeholder anywhere in the class to define the type of
    an item. That item will then be of the same type that we defined when we created
    the instance of the `List` class. Therefore, if we create an instance of the list
    type like this `var stringList = List<String>()`, the items array will be an array
    of string instances. If we created an instance of the list type like this `var
    intList = List<Int>()`, the item array will be an array of Int instances.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will need to add the `addItems()` method that will be used to add an
    item to the list. We will use the `T` placeholder within the method declaration
    to define that the item parameter will be of the same type as we declared when
    we initiated the class. Therefore, if we create an instance of the list type to
    use the string type, we would be required to use the string type as the parameter
    for the `addItems()` method. However, if we create an instance of the list type
    to use the int type, we would be required to use the int type as the parameter
    for the `addItems()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `addItems()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To create a standalone generic function, we add the `<T>` declaration after
    the function name to declare that it is a generic function; however, when we use
    a generic method within a generic type, we do not need the `<T>` declaration.
    Instead, all we need to do is to use the type that we defined in the class declaration.
    If we wanted to introduce another generic type, we could define it with the method
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `getItemAtIndex()` method that will return the item from
    the backend array, at the specified index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `getItemAtIndex()` method accepts one argument that is the index of the
    item we want to retrieve. We then use the `T` placeholder to specify that our
    return type is an optional that might be of type `T` or `nil`. If the backend
    storage array contains an item at the specified index, we will return that item;
    otherwise, we return no value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our entire generic list class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we initially defined the generic `T` placeholder type in the
    class declaration. We then used this placeholder type within our class. In our
    `List` class, we use this placeholder in three places. We use it as the type for
    our items array, as the parameter type for our `addItem()` method, and as the
    associated value for the optional return type in the `getItemAtIndex()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to use the `List` class. When we use a generic type,
    we define the type to be used within the class between angle brackets, such as
    `<type>`. The following code shows how to use the `List` class to store string
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we start off by creating an instance of the list type called `list`
    and set it to store `String` types. We then use the `addItem()` method twice to
    store two items in the list instance. Finally, we use the `getItemAtIndex()` method
    to retrieve the item at index number `1`, which will display `Optional(World)`
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define our generic types with multiple placeholder types, similar
    to how we use multiple placeholders in our generic methods. To use multiple placeholder
    types, we would separate them with commas. The following example shows how to
    define multiple placeholder types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create an instance of the `MyClass` type that uses the `String` and
    `Int` types, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use type constraints with generic types. Once again, using a type
    constraint for a generic type is exactly the same as using one with a generic
    function. The following code shows how to use a type constraint to ensure that
    the generic type conforms to the comparable protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So far, in this chapter, we have seen how to use placeholder types with functions
    and types. At times, it can be useful to declare one or more placeholder types
    in a protocol. These types are known as **associated types**.
  prefs: []
  type: TYPE_NORMAL
- en: Associated types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An associated type declares a placeholder name that can be used instead of a
    type within a protocol. The actual type to be used is not specified until the
    protocol is adopted. While creating generic functions and types, we used a very
    similar syntax. Defining associated types for a protocol, however, is very different.
    We specify an associated type using the `typealias` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use associated types when we define a protocol. In this example,
    we will define the `QueueProtocol` protocol that will define the capabilities
    that need to be implemented by the queue that implements it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this protocol, we define one associated type named `QueueType`. We then used
    this associated type twice within the protocol—once as the parameter type for
    the `addItem()` method and once when we define the return type of the `getItem()`
    method as an optional type that might return the associated type of `QueueType`
    or a `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Any type that implements the `QueueProtocol` protocol must be able to specify
    the type to use for the `QueueType` placeholder and must also ensure that only
    items of that type are used where the protocol uses the `QueueType` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to implement `QueueProtocol` in a non-generic class called
    `IntQueue`. This class will implement the `QueueProtocol` protocol using the `Int`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `IntQueue` class, we begin by defining our backend storage mechanism
    to be an array of `Int` types. We then implement each of the methods defined in
    the `QueueProtocol` protocol, replacing the `QueueType` placeholder defined in
    the protocol with the Int type. In the `addItem()` method, the parameter type
    is defined to be an `Int` type, and in the `getItem()` method the return type
    is defined to be an optional that might return an `Int` type or no value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `IntQueue` class as we would use any other class. The following
    code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an instance of the `IntQueue` class named `intQ`. We then
    call the `addItem()` method twice to add two values of the int type to the `intQ`
    instance. We then retrieve the first item in the `intQ` instance by calling the
    `getItem()` method. This line will print the number `Optional(2)` to the console.
    The final line of code adds another int type to the `intQ` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we implemented the `QueueProtocol` protocol in a
    non-generic way. This means that we replaced the placeholder types with an actual
    type (`QueueType` was replaced by the `Int` type). We can also implement the `QueueProtocol`
    protocol with a generic type. Let''s see how to implement the `QueueProtocol`
    protocol in a generic type called `GenericQueue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `GenericQueue` implementation is very similar to the `IntQueue`
    implementation, except that we define the type to use as the generic placeholder
    `T`. We can then use the `GenericQueue` class as we would use any generic class.
    Let''s take a look at how to use the `GenericQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an instance of the `GenericQueue` class that will use the
    `Int` type. This instance is named `intQ2`. Next, we call the `addItem()` method
    twice to add two Int types to the `intQ2` instance. We then retrieve the first
    `Int` type that was added using the `getItem()` method and print the value to
    the console. This line will print the number `2` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that we should watch out for while using generics is to avoid
    using them when we should be using protocols. This is, in my opinion, one of the
    most common misuses of generics in other languages. Let's take a look at an example
    so that we know what to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we define a protocol called `WidgetProtocol`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we want to create a custom type (or function) that will
    use various implementations of the `WidgetProtocol` protocol. I have seen a couple
    of instances where developers have used generics with a type constraint to create
    custom types like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is a perfectly valid use of generics, it is recommended that we
    avoid implementations like this. It is a lot cleaner and easier to read if we
    use `WidgetProtocol` without generics. For example, we can write a non-generic
    version of the `MyClass` type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The second non-generic version of the `MyClass` type is a lot easier to read
    and understand; therefore, this should be the preferable way to implement the
    class. However, there is nothing preventing us from using either implementation
    of the `MyClass` type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic types can be incredibly useful, and they are also the basis of the Swift
    standard collection types (array and dictionary); however, as mentioned in the
    introduction to this chapter, we have to be careful to use them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a couple of examples in this chapter that show how generics can
    make our lives easier. The `swapGeneric()` function that was shown at the beginning
    of the chapter is a good use of a generic function because it allows us to swap
    the two values of any type we choose while only implementing the swap code once.
  prefs: []
  type: TYPE_NORMAL
- en: The generic list type is also a good example of how to make custom collection
    types that can be used to hold any type. How we implemented the generic list type
    in this chapter is similar to how Swift implements the array and dictionary with
    generics.
  prefs: []
  type: TYPE_NORMAL
