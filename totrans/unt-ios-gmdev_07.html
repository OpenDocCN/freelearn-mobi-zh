<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Input: Let's Get Moving!</h1></div></div></div><div><blockquote class="blockquote"><p>Up to this point we've done some basic moving around a scene, but nothing like we'll need if we're going to build commercial games for iOS devices. One thing that is often overlooked when writing games for iOS is that while iPads, iPhones, etc. can perform many of the same functions as their desktop cousins — there are very specific techniques you need to be aware of when moving from the keyboard mouse world to that of touchscreens and accelerometers. In this chapter we're going to spend some time getting into the nitty gritty of what those details are.</p></blockquote></div><p>In this chapter we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about the iOS touch screen interface</li><li class="listitem" style="list-style-type: disc">Learn about accelerometers and how they work</li><li class="listitem" style="list-style-type: disc">Create an interface on the touch screen for moving through an environment</li><li class="listitem" style="list-style-type: disc">Learn how to process gestures</li></ul></div><p>This may not sound like a lot, but with iOS development there are many things that you can do incorrectly, which will lead to difficulties when working with Unity. Rather than assume that you'll get it all right we're going to talk through it step by step to make sure that you can spend your time building games and not trying to decipher mysterious error messages.</p><p>So let's get on with it…</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Input Capabilities</h1></div></div></div><p>The iPhone is a collection of a wide variety of technologies that can be used to detect input from the user. The two most important technologies, from the perspective of a game developer, are the touch screen and the accelerometer. With these two input mechanisms nearly every game available to date has been constructed, so we will perform an in-depth analysis of how they work and how we can use their capabilities to determine the intent of the user within our game.<a id="id302" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec01"/>The technology of touch</h2></div></div></div><p>A touch screen is a display device that can detect the presence and location of one or more touches within the display area. While early touch devices relied on passive instruments, such as a stylus to detect interactions with the touch surface, modern touch devices detect physical contact with the device.<a id="id303" class="indexterm"/>
</p><p>While it may not seem the case, there are a variety of technologies used to drive touch interaction with devices. The decision on which technology is chosen depends upon a multitude of factors such as cost, durability, scalability, and versatility. It is very easy for one to suggest that one touch technology is superior to others, but a technology that works well for one particular application may be entirely inappropriate for another. For example, the technology used in the iPhone requires a person to make physical contact with the surface for a touch to be registered. However, if you're building a kiosk, you may desire that users are able to interact with the device with gloved hands. This seemingly innocent choice has radical implications on the technology chosen as well as the design of the device itself.<a id="id304" class="indexterm"/>
</p><p>There are several common types of touch surfaces that are common in devices today: resistive, capacitive, and infrared. While the mechanics of their implementations vary, they all follow the same basic recipe — when you place your finger or stylus on the screen, there is some change in state on the surface that is then sent to a processor, which determines where that touch took place. It is how that change in state is measured which separates the technologies from one another.</p><p>While all of today's iOS devices utilize a particular surface type — capacitive, it is foreseeable that Apple may change technologies at some point in the future as they expand the platform to cover new types of devices. In addition, it is important to understand the other types of surfaces that you may encounter as you port your content to other platforms.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec01"/>Resistive technology</h3></div></div></div><p>A resistive screen is comprised of layers of conductive and resistive material. When pressure is placed on the screen, the pressure from the finger or stylus causes the resistive and conductive material to come into contact — resulting in a change in the electrical field. At this point, measuring the resistance on the circuits connected to the conductive material will denote the location of the touch.<a id="id305" class="indexterm"/>
</p><p>Given that any pressure can cause the contact to occur, a resistive screen works well when you want to have a passive implement such as a stylus as a possible touch instrument. In addition, you can keep your gloves on with this technology, as a gloved hand will work just as well as a naked one. As resistive technology has been around for a lot longer it tends to be cheaper to produce and is the technology most commonly found at the lower end of the cost spectrum.<a id="id306" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec02"/>Capacitive technology</h3></div></div></div><p>A capacitive screen uses a layer of capacitive material that holds an electrical charge. When touched, this material registers a difference in the amount of charge at a specific location on the surface at the point of contact. This information is then passed onto the processors which can determine precisely where the touch takes place. The iOS devices simplify this process by arranging the capacitors in a grid such that every point on the screen generates its own signal when touched. This has the added benefit of producing a very high resolution of touch data that can be processed by the processor.<a id="id307" class="indexterm"/>
</p><p>As the capacitive approach relies on having capacitive material in order to function, it requires that something that can conduct electricity performs the touching. Since the human body conducts electricity this works fine, but it rules out the stylus approach, or more specifically it requires that a special capacitive stylus be used.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec03"/>Infrared technology</h3></div></div></div><p>An infrared screen uses an array of infrared or LED light beams, which it projects beneath the protective glass, or more commonly, acrylic surface. A camera will then peer up at this grid of beams and look for any interruption of the signal, similar to the grid approach used by iOS devices — just with an infrared camera and beams of light. This approach is refined and deployed with the Microsoft Surface and has some particular unexpected benefits. Since a camera is used to determine the touch location, that camera can also look at the object at that location. If that object is a marker, it can then extract information from that marker as well. This is used to good effect with the Microsoft Surface.<a id="id308" class="indexterm"/>
</p><p>The obvious downside to the Infrared approach is that it requires a fair amount of space to work its magic. Due to the nature of the optics, the further you are away from the surface the more resolution you are able to gain on that surface. This makes the technology impractical for the typical iPhone application.<a id="id309" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec02"/>Accelerometer</h2></div></div></div><p>An accelerometer is a device that measures the acceleration of motion on a structure. In iOS devices the accelerometer is a 3-axis system such that it can determine acceleration along the various axes of the device (x,y,z). When at rest, an accelerometer would be measuring the force of gravity (1g). As the device moves, the device will be able to measure the movements of the device based upon these accelerations along the various axes and determine the orientation of the new device. Without getting into the associated math, the only thing that you really need to know is that no matter what orientation you put the device in, the device is aware of that orientation:<a id="id310" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec03"/>Gyroscope</h2></div></div></div><p>A gyroscope is a device for measuring the orientation of a device. Unlike an accelerometer, the orientation of a device can be derived without the device actually moving. Currently only available on a subset of the iOS devices, the gyroscope enables a much more refined detection of movement in the device. The 3-axis gyro in the iOS devices work in tandem with the built-in accelerometer to produce a complete 6-axis sensitivity for motion gestures. At the time of this writing there is no support within Unity for the Gyroscope so we will not focus on its use within the context of our game.<a id="id311" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec04"/>Touch screen</h2></div></div></div><p>Our game design calls for having a set of joysticks at the bottom on the screen that we can use to move around the world and manipulate the camera. The control scheme mirrors what a player would expect if they were familiar with an Xbox style controller.<a id="id312" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_14.jpg" alt="Touch screen"/></div><p>We also need to perform actions with the right button. Similar to the Xbox controller we want to be able to invoke actions by tapping down on the right joystick as an action.</p><p>The next feature we want to plan for is the ability to perform gestures on the surface so that we can avoid having to fill our interface with extraneous buttons. There are several gestures that we want to support in our gameplay.<a id="id313" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Gesture</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Swipe Up</p>
</td><td style="text-align: left" valign="top">
<p>Throw Grenade</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Left/Right</p>
</td><td style="text-align: left" valign="top">
<p>Dodge Left/Right</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Swipe Down</p>
</td><td style="text-align: left" valign="top">
<p>Guard/Take Cover</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec05"/>Accelerometer/Gyroscope</h2></div></div></div><p>Our game design doesn't call for the use of the accelerometer, but for the sake of instruction we will use the accelerometer as an additional mechanism for manipulating the camera and provide a shake command that we will use if the character is ever knocked down and needs to heal.<a id="id314" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Motion</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Shake</p>
</td><td style="text-align: left" valign="top">
<p>Heal</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Turn Left/Right</p>
</td><td style="text-align: left" valign="top">
<p>Rotate Camera</p>
</td></tr></tbody></table></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Implementing Joysticks</h1></div></div></div><p>Our game design sketch calls for playing this game while the device is in landscape orientation so we need to start off the application in landscape.<a id="id315" class="indexterm"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Time for action —  Getting oriented</h1></div></div></div><p>From our previous applications we know that we can accomplish this by performing a quick orientation change within the<code class="literal"> Awake()</code> method of our application:<a id="id316" class="indexterm"/>
</p><div><pre class="programlisting">function Awake()
{
iPhoneSettings.screenOrientation = iPhoneScreenOrientation.Landscape;
}
</pre></div><p>In previous examples we put our functions in the<code class="literal"> Start()</code> method, but we are putting this call in the<code class="literal"> Awake()</code> method. The reason for this is that we want this script, and the orientation settings, to be processed as soon as the scene is loaded, but before the joystick script tries to determine where to put the joysticks. If we didn't do this the position of the joysticks would be too close together as their positions would have been derived from the portrait orientation.<a id="id317" class="indexterm"/>
</p><p>If you were to run your application now you would find that the application will hold to a single screen orientation, however, when you rotated you would get a black outline that rotates with the screen. This black outline represents the iOS keyboard interface rotating with the device. To prevent this from happening you need to lock the keyboard so that it is in the same orientation with the application.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Key Class/Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>iPhoneSettings<code class="literal">.screenOrientation
</code></p>
</td><td style="text-align: left" valign="top">
<p>Gets/Sets the orientation of the device</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">iPhoneScreenOrientation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enumerated type of the possible device orientations</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">iPhoneKeyboard.autorotateXXXX</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets whether or not the iPhoneKeyboard will rotate to a particular orientation when the device changes orientation</p>
</td></tr></tbody></table></div><div><pre class="programlisting">void Awake()
{
iPhoneSettings.screenOrientation = iPhoneScreenOrientation.Landscape;
iPhoneKeyboard.autorotateToPortrait = false;
iPhoneKeyboard.autorotateToPortraitUpsideDown = false;
}
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec06"/>What just happened?</h2></div></div></div><p>We have configured the game so that it will default to landscape orientation when it starts. In addition, the game will do what the users expect and you won't have the graphical glitch of the iOS keyboard trying to adjust for the device orientation.</p><p>Next, our design calls for a touch interface with two joystick areas with the one on the left acting as the movement stick and the one on the right acting as the rotation joystick. We will use these to capture user interactions and drive our character around the game world.<a id="id318" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Time for action —  Implementing the joysticks</h1></div></div></div><div><ol class="orderedlist"><li class="listitem">Expand the Standard Assets (Mobile) unitypackage that we added to the project initially in one part of our solution. Inside of the<code class="literal"> Prefabs</code> folder there is a<code class="literal"> Dual Joysticks</code> prefab:<a id="id319" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_2.jpg" alt="Time for action — Implementing the joysticks"/></div></li><li class="listitem">Since this is going to be moving with the user interface plane of our camera we can simply make it a child of the camera:<a id="id320" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_3.jpg" alt="Time for action — Implementing the joysticks"/></div></li><li class="listitem">Set the<strong> Game</strong> view to display in iPhone Wide by selecting the dropdown in the upper left of the Game view. This will result in a more accurate depiction of how the game will look at startup. Now, when we take a look at the Game view we can see exactly what our camera will see when our game starts:<a id="id321" class="indexterm"/></li></ol></div><div><img src="img/978-1-84969-040-9_7_4.jpg" alt="Time for action — Implementing the joysticks"/></div><p>This figure represents what we expect to see — our two Joystick nubs in the user interface ready for user interaction. If you start your application on your iOS device you will see that as you place your fingers over the joystick nubs, they will move around as your fingers manipulate them during a touch. When you remove your finger from the nub it will snap back to the center position. This information is captured by the Prefab and passed off to the built-in Joystick script.<a id="id322" class="indexterm"/>
</p><p>To pass the input to some other script, simply alter the script that the Prefab is pointing to. Note that each Joystick can have its own script so you can have two entirely different behaviors per joystick.<a id="id323" class="indexterm"/>
</p><p>You can also change the texture that the joystick uses by updating the<strong> Texture</strong> field on the<strong> GUITexture</strong> which represents the joystick:<a id="id324" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_5.jpg" alt="Time for action — Implementing the joysticks"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec07"/>What just happened?</h2></div></div></div><p>We have just implemented the primary means of input for our game — the dual joystick nubs. As we move these joysticks around they relay data to the Joystick script. While this is interesting, it still doesn't move our character around the scene. If all we needed were some basic joystick processing we'd be done, but we need to control a character and move our camera around the scene. Fortunately, there's a prefab for that.<a id="id325" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Moving around</h1></div></div></div><p>Now that we have an interface which is ready to accept input we need to process the touches from that interface and move our character around the scene. Our plain joystick is one part of the plan, but now we need to handle the rest.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Time for action —  Implementing the camera control</h1></div></div></div><div><ol class="orderedlist"><li class="listitem">The first thing we need to do is delete our Main Camera and the Dual Joysticks from the previous scene. Don't be concerned that we've deleted the Main Camera as we will be adding a new camera to the scene.<a id="id326" class="indexterm"/></li><li class="listitem">Perform a search for the<strong> Camera Relative Controls</strong> in the<strong> Project</strong> window:<div><img src="img/978-1-84969-040-9_7_6.jpg" alt="Time for action — Implementing the camera control"/></div></li><li class="listitem">Drag the Camera Relative Controls prefab into the<strong> Hierarchy</strong> view. When you drag this prefab into your<strong> Hierarchy</strong> view you will find that it consists of both the Dual Joysticks that we were using earlier, as well as something called<strong> Camera Relative Controls</strong>. Beneath the<strong> Camera Relative Controls</strong> you will find the camera pivot and the player objects.<a id="id327" class="indexterm"/><p>The <strong>camera pivot</strong> as the name suggests is the point in space around which the camera will pivot. When you move the right joystick to rotate the camera in 3D space, its actions are relative to this point.
<a id="id328" class="indexterm"/>
</p><p>The other object is the Player which hosts our Character Controller object and has an aptly named child "ReplaceWithRealCharacter". When we have our real character we will insert it here:
</p><div><img src="img/978-1-84969-040-9_7_37.jpg" alt="Time for action — Implementing the camera control"/></div></li><li class="listitem">Switch to the<strong> Game</strong> view and we will see what this scene represents at runtime:<a id="id329" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_7.jpg" alt="Time for action — Implementing the camera control"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">As you can see, the joysticks are in place and the white capsule represents the Character Controller and Player Game Objects. If you deploy this project to your iOS device now you will see that you will be able to move around the scene with the Joysticks, the left moving you around the scene and the right one rotating the camera.<a id="id330" class="indexterm"/></li></ul></div></li><li class="listitem">Next let's import our player's character. Open the<strong> Asset Store</strong> and perform a search for the<strong> Solder Character Pack:</strong><a id="id331" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_10.jpg" alt="Time for action — Implementing the camera control"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This pack contains a fully rigged character that we can use with our game.<a id="id332" class="indexterm"/></li></ul></div></li><li class="listitem">After importing the character pack, drag the<strong> Solider</strong> prefab over to the<strong> Camera Relative Controls</strong>, Player node as a child. This will break the prefab link, but this is not a problem as we need to sever that link to add our own geometry to the game.</li><li class="listitem">Now delete the<code class="literal"> ReplaceWithReachCharacter</code> child of the Player node and you will have a soldier in your game ready to be used. This soldier isn't the most efficient model we could use for our application, but it is freely available on the asset store and will work just fine for our purposes:<a id="id333" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_9.jpg" alt="Time for action — Implementing the camera control"/></div></li><li class="listitem">Deploy this application to your iOS device and use the joysticks and you will find, that for your limited effort, you have a character in the world that will navigate the world with the left joystick and that you are able to manipulate the camera with the right joystick. We're starting to get something that looks more like a game, except that the player doesn't animate. We need a way to put some animations on this character and have the person walk around, move through the attack animations, take damage, and die if we're going to have a real game.<a id="id334" class="indexterm"/></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec08"/>What just happened?</h2></div></div></div><p>We have extended the functionality of the existing application to include controls to move around our world, along with camera controls for our player character. Now that we have imported a character for our character controller, we need to animate this character based on user input.<a id="id335" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec07"/>Time for action —  Animating the player character</h1></div></div></div><p>The character that we imported is what is known as a rigged character. A rigged character is one that has all of its bones for animation. These bones are what drive the movement of the mesh itself during animation. Let's disable the rendering of the mesh so we can see the bones themselves..<a id="id336" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Select the Soldier mesh in the<strong> Hierarchy</strong> view.</li><li class="listitem">In the<strong> Inspector</strong> view, scroll down to the Mesh Render component and click its check box. This will disable rendering of the mesh in Unity and in the Game:<div><img src="img/978-1-84969-040-9_7_36.jpg" alt="Time for action — Animating the player character"/></div></li><li class="listitem">Open the<strong> Scene</strong> view of the project and select the mesh in the Hierarchy. You should only see the bones for the soldier character we imported:</li></ol></div><div><img src="img/978-1-84969-040-9_7_16.jpg" alt="Time for action — Animating the player character"/></div><p>As mentioned earlier, Unity's animation system is fairly robust and has an easily scriptable animation blending system built right into it. As a consequence, we can deal with simple animations such as walk, run, use weapon, and so on, and we can have Unity blend between the animations to allow us to walk while using the weapon.<a id="id337" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec09"/>Importing an animation</h2></div></div></div><p>The next step is to associate an animation with this rigging so that we can 'drive' our character around the scene. There are a number of ways that you can animate a character, such as motion capture or animating by hand. Unity supports two approaches for importing this content into our game: animation splitting and multiple animation files.<a id="id338" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec04"/>Animation splitting</h3></div></div></div><p>There are times when you will receive an asset which already has multiple animations baked onto a model. In many content-purchasing scenarios this is quite a common practice. In these situations, when you import the model you will have to tell Unity how to split the single large animation into multiple distinct animations. You will do this in the<strong> FBXImporter</strong> that appears when you bring the model into the Unity IDE:</p><div><img src="img/978-1-84969-040-9_7_17.jpg" alt="Animation splitting"/></div><p>By selecting the option to<strong> Split Animations</strong>, Unity will enable a table that will allow you to specify each animation that is present. For example in this scenario there is an animation called<strong> idle</strong> which runs from frame<strong> 1</strong> through frame<strong> 25</strong>, a<strong> walk</strong> that plays from frame<strong> 26</strong> through frame<strong> 50</strong>, and so on. Once you have imported the animations you can reference them by the names that you have given them in the table for all animation actions. We will discuss this in more detail shortly.<a id="id339" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec05"/>Multiple files</h3></div></div></div><p>The preferred way to import animations is to use multiple animation files. To do this you create a separate model file for your animation data using the naming convention 'model'@'animation name'.fbx and simply drag this<code class="literal"> .fbx</code> file into Unity, the same as you would any other asset.<a id="id340" class="indexterm"/>
</p><p>Through this you can import your animations distinctly for each character and it becomes much easier in your workflow to modify these animations, without having to worry about which frames changed or ending up with extra frames in your animation data, to allow for potential changes. It is important to note that these files contain only animation data — not the actual model geometry. Further, it is important to note that Unity will not attempt to enforce the mapping of the model name to the name of your models:</p><div><img src="img/978-1-84969-040-9_7_21.jpg" alt="Multiple files"/></div><p>For example, here we have imported some animations in an FBX file. There is no default model in our scene, but we can still use these animations since the bone hierarchy of these animations matches that of the character we already have in the game.</p><p>To use this animation within our game we need to select our character and in the<strong> Inspector</strong> expand the animation settings:<a id="id341" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_19.jpg" alt="Multiple files"/></div><p>Here we see that our character has 0 animations specified. In addition in the<strong> Animation</strong> element we see that there is no animation scheduled to play. We can easily fix this by increasing the animation count to<strong> 3</strong> to match the three animations we have imported:</p><div><img src="img/978-1-84969-040-9_7_20.jpg" alt="Multiple files"/></div><p>These slots can all hold the animations that we have imported. The animation itself being represented by a document icon with a clock on it which, coincidentally, has the same name as the animation itself. Simply drag the animations onto these slots and you will have set up animations for the character:</p><div><img src="img/978-1-84969-040-9_7_23.jpg" alt="Multiple files"/></div><p>If you want to set up a default animation for the character you can drag an animation onto the<strong> Animation</strong> slot. I have chosen to select the idle animation in this case:<a id="id342" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_24.jpg" alt="Multiple files"/></div><p>Now your character is all setup and ready to animate. If you run the game in the editor you will see that your character moves from his default T position to the idle animation and plays through it:</p><div><img src="img/978-1-84969-040-9_7_25.jpg" alt="Multiple files"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec10"/>What just happened?</h2></div></div></div><p>We just took our rigged character from the asset store and added animations to it using the two approaches of animation splitting and unique FBX animation importing. Now our character can have emotion, driven by animation data.<a id="id343" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec08"/>Importing an animation</h1></div></div></div><p>There may be times when you don't have animation data readily available, or you simply want to cut down your development time by integrating an existing animation. One service that is well integrated with Unity is the animation service from Mixamo. Mixamo provides this functionality, not only for their characters, but also for any rigged character that we can find.<a id="id344" class="indexterm"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec09"/>Time for action —  Importing from Mixamo</h1></div></div></div><p>We can get started by going to the<a class="ulink" href="http://www.mixamo.com/"> http://www.mixamo.com/</a> website (there is a plugin that is integrated into the latest versions of Unity as well) and browsing through their library of animations:<a id="id345" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_11.jpg" alt="Time for action — Importing from Mixamo"/></div><p>Since we want to ensure that the animation will work properly with our character we can upload our character to Mixamo and see the animation being played on our character:<a id="id346" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_12.jpg" alt="Time for action — Importing from Mixamo"/></div><p>We have the opportunity to tweak any of the bones in our character to fit those that Mixamo has defined in their default skeleton. This will help ensure that our animation plays properly. In most cases Mixamo will map to the right bones by itself, but if you need to help it out because of some special mapping that you've done — all the tools are there:<a id="id347" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_13.jpg" width="384" alt="Time for action — Importing from Mixamo"/></div><p>Once mapped, we can reference this uploaded character as we browse through the catalog of animations in the Mixamo library when we create our own custom animations using the service. Now that our model is here we can look at exactly how the animation will perform, as Mixamo has an integrated Unity player on the website where we can preview and customize the animation as necessary.<a id="id348" class="indexterm"/>
</p><p>We can adjust the sliders to customize our character motions in real time and get them precisely the way we want them. Once we've done that we can download our animation in the appropriate Unity animation format.</p><p>If we already have an animation that we want to import into Unity, we can use this same approach to import those animations as well. Unity supports two approaches for importing this content into our game: animation splitting and multiple animation files.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec11"/>What just happened?</h2></div></div></div><p>We just took our rigged character from the asset store and added animations to it using the Mixamo animation service. Using these animations we're able to have our character move around the scene in sync with animations. Now that we can move around let's deal with the other part of our input requirements — being able to attack enemies or perform other actions on command.<a id="id349" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec10"/>Driving our character</h1></div></div></div><p>The last thing that we need to do with our character is drive him around the scene. This is the one area that will either make or break our game because it needs to be fluid with user interaction. This is important because the main character is likely to be one of the most used things in the game so it should be well made.<a id="id350" class="indexterm"/>
</p><p>As the character moves around, our character needs to move through the animation and change position in the scene as well. In addition, we need to seamlessly blend between different animations that the character is doing. We can't have the player stop walking, then swing, then start walking again.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec11"/>Time for action —  Driving our character</h1></div></div></div><p>If you deployed the application after the last step you would have observed that our current controls could already move the character around the scene. We can use the left joystick and the player will glide over the ground while going through the idle animation:</p><div><img src="img/978-1-84969-040-9_7_26.jpg" alt="Time for action — Driving our character"/></div><p>We want our character to walk when the player is moving the joystick so we can make a very simple change to the<code class="literal"> CameraRelativeControl</code> script for this to happen. You can locate this script by taking a look at the<strong> Player</strong> object in the<strong> Hierarchy</strong> view:<a id="id351" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_27.jpg" alt="Time for action — Driving our character"/></div><p>Now look at the Inspector and you will see all of the scripts that are driving this object. Keep track of this, as we will change some of this later:<a id="id352" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_28.jpg" alt="Time for action — Driving our character"/></div><p>First let's add a variable to the script so we can gain access to our soldier GameObject. You will note here that I am defining the type in this script, as opposed to just declaring it as var. In Unity iOS you must define the types of all objects, dynamic typing is not allowed for performance reasons:<a id="id353" class="indexterm"/>
</p><div><pre class="programlisting">private var thisTransform : Transform;
private var character : CharacterController;
private var velocity : Vector3; //Used for continuing momentum while in air
private var canJump = true;
private var soldier : GameObject;
function Start()
{
// Cache component lookup at startup instead of doing this every frame
thisTransform = GetComponent( Transform );
character = GetComponent( CharacterController );
</pre></div><p>Now we need to just look for some change in velocity in our character, which is conveniently managed by the Character Controller, and change the animation accordingly.</p><div><pre class="programlisting">if ( soldier )
{
if ( ( movement.x != 0 ) || ( movement.z != 0 ) )
{
soldier.animation.Play("walk");
}
else
{
soldier.animation.Play("idle");
}
}
</pre></div><p>Now, if you go back and run the application you will find that the player moves into a walk animation when we move the joystick around whenever the player reaches a certain speed:</p><div><img src="img/978-1-84969-040-9_7_29.jpg" alt="Time for action — Driving our character"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec12"/>What just happened?</h2></div></div></div><p>We have just added in functionality to drive our player around the world using the joystick numbs and the standard locomotion system employed by Unity. However, there are a number of limitations to our approach when we want to employ multiple animations.</p><p>We could certainly put in some code to look for when the player is beyond a certain velocity and have them move into a run animation with some simple conditional logic changes, but if you play around with the application you will find something very wrong with this picture. The player animates from the local origin and then snaps back to the origin when they reach the end of the animation. In addition when physics is applied to this character there will be a disconnect between the animation and the character hierarchy.<a id="id354" class="indexterm"/>
</p><p>You could certainly fix some of this by having the animator perform the animations in place, but then you would lose the ability to really see how the animation will look. Seeing the gait, stride, and swing of the character is only really possible when the character is actually in motion.</p><p>To fix all of this, however, we need another solution. What we really need to do is track where the character is during their animation so that when they are at the end of the animation we can start playing the animation again at that position and orientation. This will become increasingly important as we try to have our player walk on steps, or collide with objects. In other words we need to drive the character's motion with the animation itself, and we can't do that by simply changing the character's location and telling them to play an animation.<a id="id355" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec12"/>Time for action —  Getting a driver's license with Root Motion Controller</h1></div></div></div><p>Fortunately, there is a prebuilt solution that, unsurprisingly, is available from Mixamo that will solve this problem for us with very little impact to our application code - the Root Motion Controller:<a id="id356" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_32.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div><div><ol class="orderedlist"><li class="listitem">First, go back to the<strong> Asset Store</strong> and search for a package known as the<strong> Root Motion Controller</strong>. This package from Mixamo, and developed by Adam Mechtley, has all of the functionality necessary for us to drive our character using the animation data — we need only configure it:<div><img src="img/978-1-84969-040-9_7_33.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div></li><li class="listitem">Next we need to select the<strong> Player</strong> model from our hierarchy, since this is the component of the hierarchy that we want to control with our new controller. When adding this to a similar project, just be sure to add this to the same node that contains the Character Controller, as you want movements from the Root Motion Computer to result in motion on everything at this level of the Hierarchy:<a id="id357" class="indexterm"/><div><h3 class="title"><a id="note11"/>Note</h3><p>If you were to attach the<strong> Root Motion Computer</strong> to the Soldier node, for example, the<strong> Camera Relative Controls</strong> would not be aware that the player has actually moved.</p></div><div><img src="img/978-1-84969-040-9_7_30.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div></li><li class="listitem">Now that we have the right node in the hierarchy selected we can add the<strong> Root Motion Computer</strong> component by selecting the<strong> Mixamo</strong> menu item:<a id="id358" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_31.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div></li><li class="listitem">In the<strong> Inspector</strong> view you will see the<strong> Root Motion Computer</strong> component added to our Game Object. And with that we're actually done with the vast majority of the work that needs to be done. So let's take it out for a test drive:<a id="id359" class="indexterm"/><div><img src="img/978-1-84969-040-9_7_34.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div></li><li class="listitem">Change the settings of the animations for the character, so that the default animation is set to<strong> walk:</strong><div><img src="img/978-1-84969-040-9_7_35.jpg" alt="Time for action — Getting a driver's license with Root Motion Controller"/></div></li><li class="listitem">Next, set the<strong> Animation Wrap Mode</strong> for the animation to<strong> Loop</strong> so that it will play repeatedly. Now when you run the application the player will walk repeatedly forward until they walk off the world.<a id="id360" class="indexterm"/></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec13"/>What just happened?</h2></div></div></div><p>We've just accomplished a significant step! Not only have we imported animations, but we are also using the animations to drive the character around the scene. With all of our animations synchronized with the location and orientation of the player in the scene and controlled with the joysticks we can turn our attention to the gameplay elements.<a id="id361" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec14"/>Rotation via Accelerometer</h1></div></div></div><p>The next thing we need to handle is rotating the camera based upon the user tilting the device. In our design we said that this would represent rotation of the camera so we need to detect these motions and adjust our camera based upon the user's intent.<a id="id362" class="indexterm"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec15"/>Time for action —  Updating upon device tilt</h1></div></div></div><p>As discussed earlier, iOS devices have a defined access that allows us to determine changes in the device's orientation. We can detect this as changes in the x, y, or z values in Input.acceleration:<a id="id363" class="indexterm"/>
</p><div><img src="img/978-1-84969-040-9_7_38.jpg" alt="Time for action — Updating upon device tilt"/></div><p>Since our game design requires us to manipulate the camera based upon the tilt, the only step we need is to check for the direction of the orientation change and then rotate the camera accordingly. To accomplish this we can attach a script to a GameObject in whose<code class="literal"> Update()</code> method we examine the<code class="literal"> Input.acceleration</code> attributes and determine how the device has changed. Remember also that we have specified that our application be designed to run in landscape mode so we are looking for rotations along the device's Z-axis.<a id="id364" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Key Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Input.acceleration</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the accelerometer readings of the device</p>
</td></tr></tbody></table></div><div><pre class="programlisting">using UnityEngine;
using System.Collections;
public class CameraRotate : MonoBehaviour {
public float speed = 10.0f;
// Use this for initialization
void Start () {
}
// Update is called once per frame
void Update () {
Vector3 direction = Vector3.zero;
direction.x = - Input.acceleration.y;
direction.z = Input.acceleration.x;
if ( direction.sqrMagnitude &gt; 1 )
{
direction.Normalize();
}
direction *= Time.deltaTime;
transform.Translate( direction * speed );
}
}
</pre></div><p>With<code class="literal"> iPhoneSettings.screenOrientation</code> we can now tell the Unity player to change its orientation. You can set the orientation to any one of the<code class="literal"> iPhoneScreenOrientations</code> available. It is recommended that you don't do anything that would be uncharacteristic to the way the iOS device is expected to operate as Apple may reject your application for that behavior.<a id="id365" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec14"/>What just happened?</h2></div></div></div><p>By adding a script to our camera we get an<code class="literal"> Update()</code> notification on a frame by frame basis. We can then look to see what the device orientation is and adjust our orientation accordingly. By updating the<code class="literal"> iPhoneSettings</code> attributes we can quickly flip our scene to match whatever orientation we find ourselves in.<a id="id366" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec16"/>Shaking the device to perform a healing action</h1></div></div></div><p>The last thing we need to do is detect when the user has chosen to shake the device as our design specifies that we will use this as an indication that the user will perform a healing action.<a id="id367" class="indexterm"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec17"/>Time for action —  Detecting a shake</h1></div></div></div><div><ol class="orderedlist"><li class="listitem">The first step in handling an orientation change is to actually realize that the orientation has changed. There are two ways we can do this — we can either check when the game first starts up only, in which case we need to put our orientation detection in the<code class="literal"> Start()</code> method as it is only called once. If we want to check orientation changes as the user is playing the game then we need to check the state of the orientation on a frame-by-frame basis. We do this by putting our orientation code in the<code class="literal"> Update()</code> method.<a id="id368" class="indexterm"/></li></ol></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Key Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Input.acceleration</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the accelerometer readings of the device</p>
</td></tr></tbody></table></div><p>We will use the<code class="literal"> deviceOrientation</code> attribute of the Input class to determine what the orientation of the device is. This information comes directly from the OS in real time so as the orientation changes, we will be notified and can respond to the change without having to interrupt gameplay.<a id="id369" class="indexterm"/>
</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
public class DetectShake : MonoBehaviour {
public float shakeThreshold = 2.0f;
// Update is called once per frame
void Update () {
Vector3 accel = Input.acceleration;
float x = accel.x;
float y = accel.y;
float z = accel.z;
float shakeStrength = Mathf.Sqrt( x * x + y * y + z * z );
if ( shakeStrength &gt;= shakeThreshold )
{
// do the shake action
}
}
}
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec15"/>Physician heal thyself</h2></div></div></div><p>Now that we know that a device shake has taken place we can perform the specific action that we want associated with the shake.<a id="id370" class="indexterm"/>
</p><p>In our<code class="literal"> player</code> class we have a simple representation of the player's health as an integer within our<code class="literal"> Player</code> class:</p><div><pre class="programlisting">public class Player {
public static int MAX_HEALTH = 100;
private int health = 0;
public Player()
{
}
public int getHealth()
{
return health;
}
public void heal()
{
health = health + 10;
if ( health &gt; MAX_HEALTH )
{
health = MAX_HEALTH;
}
}
}
</pre></div><p>In our<code class="literal"> Player</code> class is a simple heal method that we call whenever we detect that a shake of the device has happened.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec16"/>What just happened?</h2></div></div></div><p>We have implemented the last input features for the game by detecting shakes of the device. Based upon this shake we have changed the user's state and taken an action. While shaking isn't a common action in games today, and I encourage you to use it sparingly, there are certainly times when it represents the best input option available.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter we discussed the primary sensors used for input on iOS, namely the touch screen, gyroscope, and accelerometer. With this task covered we can provide a touch screen interface from our player which they can interact with, as well as gather information from movement and orientation of the iOS device.</p><p>Specifically, we covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different types of touch technologies, their strengths and weaknesses</li><li class="listitem" style="list-style-type: disc">How to build a touchable user interface for the user on the device and gather input from it</li><li class="listitem" style="list-style-type: disc">How to import existing animations and how to import Mixamo animations</li><li class="listitem" style="list-style-type: disc">How to detect gestures and determine the user's intent</li><li class="listitem" style="list-style-type: disc">How to detect movement of the device and orientation changes</li><li class="listitem" style="list-style-type: disc">How to use this information to move an on-screen character through a 3D world</li><li class="listitem" style="list-style-type: disc">How to drive a character from animation data as opposed to programmatically</li></ul></div><p>Now we have a character that we can control through our 3D world and we can animate this character based on input from the user. We have the beginnings of an actual game now, but the world is very quiet and the game is without flair. In the next chapter, Multimedia, we will explore how to add sound, music, and video to our game to give it some sex appeal.</p></div></body></html>