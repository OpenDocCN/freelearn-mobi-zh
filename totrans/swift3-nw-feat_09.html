<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Improving Your Code with Xcode Server and LLDB Debugging</h1></div></div></div><p>One of the biggest skills you can learn to improve in your code is by learning how to test it. Adding unit tests to your code with the <code class="literal">XCTest</code> Testing framework will help you improve the quality of your code and will provide a secondary benefit of documenting how your code works. As you move from solo developer projects to multi-member teams, it becomes harder to maintain tests that are written in isolation. Automated testing, added to a continuous integration pipeline on a server, helps to address these pain points in the same way that source repositories help to manage code over larger projects.</p><p>In the first part of this chapter, we will cover Xcode Server's capabilities as a continuous integration server and how automated testing can be included to improve your testing workflow. In the second half, we will describe how to use LLDB for debugging your code on Linux.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Continuous integration overview with Xcode server</h1></div></div></div><p>Using server-based testing has several benefits that could justify the time investment for your team. If you're on the fence about whether going this route works for your team, make sure to consider the following in your evaluations:</p><div><ol class="orderedlist arabic"><li class="listitem">Moving your builds and unit tests to a server frees your local box to keep working on features and debugging, while your builds and test suites run remotely.</li><li class="listitem">Build triggers can run your tests on code check-ins and alert your team when things change expectantly due to tests failing.</li><li class="listitem">Tests on your server are consistent and run the same way each time; meaning that individual developer environment and project tweaks won't affect test runs.</li><li class="listitem">You can schedule full test suites to run at your convenience and short running tests to execute on every code check-in as an example.</li><li class="listitem">You can have your tests executed against multiple development environments and hardware. For example, you could have your test run on multiple iPad models and OS versions along with several iPhones with ease using a server environment. This would be a time-consuming task to do manually.</li></ol></div><p>A continuous integration workflow is a process that starts with developing locally on a development machine and then checking your code into a repository. Next, you migrate your project to Xcode server for processing. In order for Xcode Server to process your code, you have to provide it with some instructions in the form of <em>bots</em>. On your development box, you create <em>bots</em> with your processing rules that run on Xcode Server. The execution of a <em>bot</em> is called an <em>integration</em>, which can be run manually or according to a schedule. Once an <em>integration</em> finishes, the activity is reported back to your development Mac.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec39"/>Bot features</h2></div></div></div><p>Without <em>bots</em>, you can't do anything useful with Xcode Server. <em>Bots</em> build your code and run your tests, using a supplied Xcode project scheme. A well-crafted <em>bot</em> can control when it runs and how it communicates its activity to you and your team. For instance, you could have the <em>bot</em> run when a new commit has occurred and have it e-mail the <em>integration</em> status (for example, success or failure) to you and/or your development team. You can also add pre and post <em>integration</em> triggers that can execute scripts to communicate with web services or to run additional performance tests based on initial <em>integration</em> outputs.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec40"/>Monitoring and managing bots</h2></div></div></div><p>Once you have created your <em>bots</em>, you can manage and monitor them in Xcode Server. Xcode Server can be configured to push <em>bot</em> statuses to your development Mac, provide a web hook to view activity in a browser or third-party app (for example, Slack/HipChat), or send you an e-mail report. On your development Mac, you can see very detailed reports using the report navigator in Xcode.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Configuring Xcode server</h1></div></div></div><p>To use Xcode server, you have to download and install macOS Server (formerly known as OS X Server) from the App Store on a Mac.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>Installing is straightforward, and you can find detailed instructions at <a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1">https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html - //apple_ref/doc/uid/TP40013292-CH3-SW1</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec41"/>Adding repositories for the Xcode server</h2></div></div></div><p>The Xcode Server needs a code repository to do work and is compatible with either Git or Subversion. Any <em>bots</em> that you create will need access to a repository. A bot will try to connect to a repository via SSH or HTTPS. Apple does a really good job of describing your repository setup options.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>You can refer to the following section of their setup guide for step-by-step instructions on how to configure your repos to give access to Xcode Server and your <em>bot</em>: <a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1">https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html - //apple_ref/doc/uid/TP40013292-CH8-SW1</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec42"/>Configuring bots</h2></div></div></div><p>A <em>bot</em> is a process, run by the Xcode Server to build and test code from a source repository. Each time you run an instance of your bot, you are performing what's known as <em>integration</em>. You create a <em>bot</em> and add an associated scheme to the <em>bot</em> that references your development box. The <em>bot</em> creation wizard walks you through options for choosing the scheme to use, setting the frequency to run, and providing any shell scripts to run before or after an <em>integration</em>.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>You can read more about how to setup a bot at <a class="ulink" href="https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1">https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html - //apple_ref/doc/uid/TP40013292-CH9-SW1</a>.</p></div></div><p>Last year, Xcode Server introduced a new feature that allows us to add custom environment variables that our <em>bots</em> can access. This year Xcode Server allows us to add pre and post scripts that will run on each <em>integration</em>. This feature could allow you to pre-load your environment with external files or data for unit testing before your <em>bot</em> builds and executes tests. Another example might be to have a post <em>integration</em> script communicate with a Rest API to send the success or failure status.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Managing and monitoring your integration runs</h1></div></div></div><p>You can access detailed reports on <em>integration</em> runs for each <em>bot</em> in Xcode's Report Navigator (<strong>View</strong> | <strong>Navigators</strong> | <strong>Show Report Navigator</strong>). This view also gives you the ability to create additional <em>bots</em> or edit existing ones. Selecting any of the <em>bots</em> listed in the sidebar gives you a summary report of the integration results.</p><p>
</p><div><img alt="Managing and monitoring your integration runs" src="img/B05719_09_01.jpg"/><div><p>Report Navigator</p></div></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Debugging with LLDB</h1></div></div></div><p>
<em>LLDB</em> is the debugger that powers Xcode. In Xcode's debug console, you can find a console window that gives you access to an <em>LLDB</em> prompt. On Linux or from the command line, you can access <em>LLDB</em> from the Swift <em>REPL</em>. Let's explore how we can use <em>LLDB</em> to debug our programs using some of the commands of which you may or may not already be aware.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>You can read more about debugging with LLDB in the LLDB Debugging Guide:
<a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42">https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html - //apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec43"/>LLDB command syntax</h2></div></div></div><p>Interacting with <em>LLDB</em> is as easy as entering a command into the prompt. The command structure contains zero or more subcommands followed by zero or more options or arguments.</p><pre class="programlisting">
<strong>&lt;command&gt; [&lt;subcommand&gt;...] [--&lt;option&gt; [&lt;option-value&gt;]]... [argument]...</strong>
</pre><p>Subcommands and arguments are space-delimited tokens; while options are space delimited, but use double dashes (and sometimes single dash) as a prefix. An example <em>LLDB</em> command would be to set a breakpoint on a function. In the following example, we would set a <code class="literal">breakpoint</code> for the <code class="literal">speakToMe()</code> function:</p><pre class="programlisting">
<strong>(lldb) breakpoint set -n speakToMe</strong>
</pre><p>You can always get help by typing help at the <em>LLDB</em> prompt. Typing help without arguments will list all of the commands available with short descriptions:</p><pre class="programlisting">
<strong>(lldb) help</strong>
</pre><p>You can get help on a specific command by typing help along with the command name or the command name and subcommand name for even more specialized results.</p><pre class="programlisting">
<strong> &#13;
(lldb) help breakpoint &#13;
(lldb) help breakpoint set</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Managing breakpoints</h1></div></div></div><p>Breakpoints are the main way to interrupt your running program for inspection at specific points. We can create, modify, delete, or list breakpoints through <em>LLDB</em>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec44"/>Creating a breakpoint</h2></div></div></div><p>We use the <code class="literal">breakpoint set</code> command to create a breakpoint:</p><pre class="programlisting">4&gt; func sayHello(){ &#13;
  5.     print("Hi") &#13;
  6. } &#13;
  7&gt; sayHello() &#13;
Hi &#13;
  8&gt; :breakpoint set --name sayHello &#13;
Breakpoint 1: where = $__lldb_expr5`__lldb_expr_4.sayHello () -&gt; () + 4 at repl.swift:5, address = 0x00000001005c6064 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec45"/>Listing breakpoints</h2></div></div></div><p>We use the <code class="literal">breakpoint list</code> command to list the names and locations of breakpoints in a program:</p><pre class="programlisting">(lldb) breakpoint list &#13;
Current breakpoints: &#13;
1: name = 'sayHello', locations = 1, resolved = 1, hit count = 1 &#13;
  1.1: where = $__lldb_expr5`__lldb_expr_4.sayHello () -&gt; () + 4 at repl.swift:5, address = 0x00000001005c6064, resolved, hit count = 1 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Modifying a breakpoint</h2></div></div></div><p>Another interesting thing you can do with breakpoints is to add conditions on activation. Using the <code class="literal">breakpoint modify</code> command, you can use any of the following options to change the target breakpoint's behavior.</p><pre class="programlisting">-D ( --dummy-breakpoints ) : Sets Dummy breakpoints &#13;
 &#13;
-T &lt;thread-name&gt; ( --thread-name &lt;thread-name&gt; ) The breakpoint stops only for the thread whose thread name matches this argument. &#13;
 &#13;
-c &lt;expr&gt; ( --condition &lt;expr&gt; ) The breakpoint stops only if this condition expression evaluates to true. &#13;
 &#13;
-d ( --disable ) Disable the breakpoint. &#13;
        &#13;
-e ( --enable )Enable the breakpoint. &#13;
        &#13;
-i &lt;count&gt; ( --ignore-count &lt;count&gt; ) Set the number of times this breakpoint is skipped before stopping. &#13;
      &#13;
-o &lt;boolean&gt; ( --one-shot &lt;boolean&gt; ) The breakpoint is deleted the first time it stop causes a stop. &#13;
        &#13;
-q &lt;queue-name&gt; ( --queue-name &lt;queue-name&gt; ) The breakpoint stops only for threads in the queue whose name is given by this argument. &#13;
        &#13;
-t &lt;thread-id&gt; ( --thread-id &lt;thread-id&gt; ) The breakpoint stops only for the thread whose TID matches this argument. &#13;
        &#13;
-x &lt;thread-index&gt; ( --thread-index &lt;thread-index&gt; ) The breakpoint stops only for the thread whose index matches this argument. &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec47"/>Enabling and disabling a breakpoint</h2></div></div></div><p>You can enable and disable a breakpoint using either the breakpoint ID or the location. You pass the ID to the <code class="literal">enable</code> or <code class="literal">disable</code> subcommands:</p><pre class="programlisting">(lldb) breakpoint enable 1.1 &#13;
1 breakpoint enabled. &#13;
 &#13;
(lldb) breakpoint disable 1.1 &#13;
1 breakpoint disabled. &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec48"/>Deleting a breakpoint</h2></div></div></div><p>When you no longer need your breakpoint, you can simply remove it using the delete subcommand with the breakpoint ID or location:</p><pre class="programlisting">(lldb) breakpoint delete 1.1 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec49"/>Command aliases</h2></div></div></div><p>Command aliases allow you to create a shorter syntax for commands that you use often. You can also provide help text to accompany your alias. You can see additional details on how to manage a command alias by typing <code class="literal">help command</code>.</p><p>
</p><div><img alt="Command aliases" src="img/image_09_002.jpg"/></div><p>
</p><p>In the following example, we create a command alias to execute a command we pass to our alias using the Unix shell:</p><p>
</p><div><img alt="Command aliases" src="img/image_09_003.jpg"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we covered the basics of a continuous integration workflow using Xcode Server. You learned what a bot is and how they are used to build and test your code on Xcode Server. With the addition of Swift on Linux, we needed to explore other options outside Xcode for testing code. LLDB is extremely powerful and even has customization options for your debugging sessions. In our next and final chapter, we will discuss writing Swift on a Linux server.</p></div></body></html>