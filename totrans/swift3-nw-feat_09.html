<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Improving Your Code with Xcode Server and LLDB Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Improving Your Code with Xcode Server and LLDB Debugging</h1></div></div></div><p>One of the biggest skills you can learn to improve in your code is by learning how to test it. Adding unit tests to your code with the <code class="literal">XCTest</code> Testing framework will help you improve the quality of your code and will provide a secondary benefit of documenting how your code works. As you move from solo developer projects to multi-member teams, it becomes harder to maintain tests that are written in isolation. Automated testing, added to a continuous integration pipeline on a server, helps to address these pain points in the same way that source repositories help to manage code over larger projects.</p><p>In the first part of this chapter, we will cover Xcode Server's capabilities as a continuous integration server and how automated testing can be included to improve your testing workflow. In the second half, we will describe how to use LLDB for debugging your code on Linux.</p><div class="section" title="Continuous integration overview with Xcode server"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Continuous integration overview with Xcode server</h1></div></div></div><p>Using server-based testing has several benefits that could justify the time investment for your team. If you're on the fence about whether going this route works for your team, make sure to consider the following in your evaluations:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Moving your builds and unit tests to a server frees your local box to keep working on features and debugging, while your builds and test suites run remotely.</li><li class="listitem">Build triggers can run your tests on code check-ins and alert your team when things change expectantly due to tests failing.</li><li class="listitem">Tests on your server are consistent and run the same way each time; meaning that individual developer environment and project tweaks won't affect test runs.</li><li class="listitem">You can schedule full test suites to run at your convenience and short running tests to execute on every code check-in as an example.</li><li class="listitem">You can have your tests executed against multiple development environments and hardware. For example, you could have your test run on multiple iPad models and OS versions along with several iPhones with ease using a server environment. This would be a time-consuming task to do manually.</li></ol></div><p>A continuous integration workflow is a process that starts with developing locally on a development machine and then checking your code into a repository. Next, you migrate your project to Xcode server for processing. In order for Xcode Server to process your code, you have to provide it with some instructions in the form of <span class="emphasis"><em>bots</em></span>. On your development box, you create <span class="emphasis"><em>bots</em></span> with your processing rules that run on Xcode Server. The execution of a <span class="emphasis"><em>bot</em></span> is called an <span class="emphasis"><em>integration</em></span>, which can be run manually or according to a schedule. Once an <span class="emphasis"><em>integration</em></span> finishes, the activity is reported back to your development Mac.</p><div class="section" title="Bot features"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec39"/>Bot features</h2></div></div></div><p>Without <span class="emphasis"><em>bots</em></span>, you can't do anything useful with Xcode Server. <span class="emphasis"><em>Bots</em></span> build your code and run your tests, using a supplied Xcode project scheme. A well-crafted <span class="emphasis"><em>bot</em></span> can control when it runs and how it communicates its activity to you and your team. For instance, you could have the <span class="emphasis"><em>bot</em></span> run when a new commit has occurred and have it e-mail the <span class="emphasis"><em>integration</em></span> status (for example, success or failure) to you and/or your development team. You can also add pre and post <span class="emphasis"><em>integration</em></span> triggers that can execute scripts to communicate with web services or to run additional performance tests based on initial <span class="emphasis"><em>integration</em></span> outputs.</p></div><div class="section" title="Monitoring and managing bots"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec40"/>Monitoring and managing bots</h2></div></div></div><p>Once you have created your <span class="emphasis"><em>bots</em></span>, you can manage and monitor them in Xcode Server. Xcode Server can be configured to push <span class="emphasis"><em>bot</em></span> statuses to your development Mac, provide a web hook to view activity in a browser or third-party app (for example, Slack/HipChat), or send you an e-mail report. On your development Mac, you can see very detailed reports using the report navigator in Xcode.</p></div></div></div>
<div class="section" title="Configuring Xcode server"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Configuring Xcode server</h1></div></div></div><p>To use Xcode server, you have to download and install macOS Server (formerly known as OS X Server) from the App Store on a Mac.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>Installing is straightforward, and you can find detailed instructions at <a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1">https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html - //apple_ref/doc/uid/TP40013292-CH3-SW1</a>.</p></div></div><div class="section" title="Adding repositories for the Xcode server"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec41"/>Adding repositories for the Xcode server</h2></div></div></div><p>The Xcode Server needs a code repository to do work and is compatible with either Git or Subversion. Any <span class="emphasis"><em>bots</em></span> that you create will need access to a repository. A bot will try to connect to a repository via SSH or HTTPS. Apple does a really good job of describing your repository setup options.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>You can refer to the following section of their setup guide for step-by-step instructions on how to configure your repos to give access to Xcode Server and your <span class="emphasis"><em>bot</em></span>: <a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1">https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html - //apple_ref/doc/uid/TP40013292-CH8-SW1</a>.</p></div></div></div><div class="section" title="Configuring bots"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec42"/>Configuring bots</h2></div></div></div><p>A <span class="emphasis"><em>bot</em></span> is a process, run by the Xcode Server to build and test code from a source repository. Each time you run an instance of your bot, you are performing what's known as <span class="emphasis"><em>integration</em></span>. You create a <span class="emphasis"><em>bot</em></span> and add an associated scheme to the <span class="emphasis"><em>bot</em></span> that references your development box. The <span class="emphasis"><em>bot</em></span> creation wizard walks you through options for choosing the scheme to use, setting the frequency to run, and providing any shell scripts to run before or after an <span class="emphasis"><em>integration</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>You can read more about how to setup a bot at <a class="ulink" href="https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1">https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html - //apple_ref/doc/uid/TP40013292-CH9-SW1</a>.</p></div></div><p>Last year, Xcode Server introduced a new feature that allows us to add custom environment variables that our <span class="emphasis"><em>bots</em></span> can access. This year Xcode Server allows us to add pre and post scripts that will run on each <span class="emphasis"><em>integration</em></span>. This feature could allow you to pre-load your environment with external files or data for unit testing before your <span class="emphasis"><em>bot</em></span> builds and executes tests. Another example might be to have a post <span class="emphasis"><em>integration</em></span> script communicate with a Rest API to send the success or failure status.</p></div></div>
<div class="section" title="Managing and monitoring your integration runs"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Managing and monitoring your integration runs</h1></div></div></div><p>You can access detailed reports on <span class="emphasis"><em>integration</em></span> runs for each <span class="emphasis"><em>bot</em></span> in Xcode's Report Navigator (<span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Navigators</strong></span> | <span class="strong"><strong>Show Report Navigator</strong></span>). This view also gives you the ability to create additional <span class="emphasis"><em>bots</em></span> or edit existing ones. Selecting any of the <span class="emphasis"><em>bots</em></span> listed in the sidebar gives you a summary report of the integration results.</p><p>
</p><div class="mediaobject"><img alt="Managing and monitoring your integration runs" src="graphics/B05719_09_01.jpg"/><div class="caption"><p>Report Navigator</p></div></div><p>
</p></div>
<div class="section" title="Debugging with LLDB"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Debugging with LLDB</h1></div></div></div><p>
<span class="emphasis"><em>LLDB</em></span> is the debugger that powers Xcode. In Xcode's debug console, you can find a console window that gives you access to an <span class="emphasis"><em>LLDB</em></span> prompt. On Linux or from the command line, you can access <span class="emphasis"><em>LLDB</em></span> from the Swift <span class="emphasis"><em>REPL</em></span>. Let's explore how we can use <span class="emphasis"><em>LLDB</em></span> to debug our programs using some of the commands of which you may or may not already be aware.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>You can read more about debugging with LLDB in the LLDB Debugging Guide:
<a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42">https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html - //apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42</a>.</p></div></div><div class="section" title="LLDB command syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec43"/>LLDB command syntax</h2></div></div></div><p>Interacting with <span class="emphasis"><em>LLDB</em></span> is as easy as entering a command into the prompt. The command structure contains zero or more subcommands followed by zero or more options or arguments.</p><pre class="programlisting">
<span class="strong"><strong>&lt;command&gt; [&lt;subcommand&gt;...] [--&lt;option&gt; [&lt;option-value&gt;]]... [argument]...</strong></span>
</pre><p>Subcommands and arguments are space-delimited tokens; while options are space delimited, but use double dashes (and sometimes single dash) as a prefix. An example <span class="emphasis"><em>LLDB</em></span> command would be to set a breakpoint on a function. In the following example, we would set a <code class="literal">breakpoint</code> for the <code class="literal">speakToMe()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>(lldb) breakpoint set -n speakToMe</strong></span>
</pre><p>You can always get help by typing help at the <span class="emphasis"><em>LLDB</em></span> prompt. Typing help without arguments will list all of the commands available with short descriptions:</p><pre class="programlisting">
<span class="strong"><strong>(lldb) help</strong></span>
</pre><p>You can get help on a specific command by typing help along with the command name or the command name and subcommand name for even more specialized results.</p><pre class="programlisting">
<span class="strong"><strong> &#13;
(lldb) help breakpoint &#13;
(lldb) help breakpoint set</strong></span>
</pre></div></div>
<div class="section" title="Managing breakpoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Managing breakpoints</h1></div></div></div><p>Breakpoints are the main way to interrupt your running program for inspection at specific points. We can create, modify, delete, or list breakpoints through <span class="emphasis"><em>LLDB</em></span>.</p><div class="section" title="Creating a breakpoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec44"/>Creating a breakpoint</h2></div></div></div><p>We use the <code class="literal">breakpoint set</code> command to create a breakpoint:</p><pre class="programlisting">4&gt; func sayHello(){ &#13;
  5.     print("Hi") &#13;
  6. } &#13;
  7&gt; sayHello() &#13;
Hi &#13;
  8&gt; :breakpoint set --name sayHello &#13;
Breakpoint 1: where = $__lldb_expr5`__lldb_expr_4.sayHello () -&gt; () + 4 at repl.swift:5, address = 0x00000001005c6064 &#13;
</pre></div><div class="section" title="Listing breakpoints"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec45"/>Listing breakpoints</h2></div></div></div><p>We use the <code class="literal">breakpoint list</code> command to list the names and locations of breakpoints in a program:</p><pre class="programlisting">(lldb) breakpoint list &#13;
Current breakpoints: &#13;
1: name = 'sayHello', locations = 1, resolved = 1, hit count = 1 &#13;
  1.1: where = $__lldb_expr5`__lldb_expr_4.sayHello () -&gt; () + 4 at repl.swift:5, address = 0x00000001005c6064, resolved, hit count = 1 &#13;
</pre></div><div class="section" title="Modifying a breakpoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Modifying a breakpoint</h2></div></div></div><p>Another interesting thing you can do with breakpoints is to add conditions on activation. Using the <code class="literal">breakpoint modify</code> command, you can use any of the following options to change the target breakpoint's behavior.</p><pre class="programlisting">-D ( --dummy-breakpoints ) : Sets Dummy breakpoints &#13;
 &#13;
-T &lt;thread-name&gt; ( --thread-name &lt;thread-name&gt; ) The breakpoint stops only for the thread whose thread name matches this argument. &#13;
 &#13;
-c &lt;expr&gt; ( --condition &lt;expr&gt; ) The breakpoint stops only if this condition expression evaluates to true. &#13;
 &#13;
-d ( --disable ) Disable the breakpoint. &#13;
        &#13;
-e ( --enable )Enable the breakpoint. &#13;
        &#13;
-i &lt;count&gt; ( --ignore-count &lt;count&gt; ) Set the number of times this breakpoint is skipped before stopping. &#13;
      &#13;
-o &lt;boolean&gt; ( --one-shot &lt;boolean&gt; ) The breakpoint is deleted the first time it stop causes a stop. &#13;
        &#13;
-q &lt;queue-name&gt; ( --queue-name &lt;queue-name&gt; ) The breakpoint stops only for threads in the queue whose name is given by this argument. &#13;
        &#13;
-t &lt;thread-id&gt; ( --thread-id &lt;thread-id&gt; ) The breakpoint stops only for the thread whose TID matches this argument. &#13;
        &#13;
-x &lt;thread-index&gt; ( --thread-index &lt;thread-index&gt; ) The breakpoint stops only for the thread whose index matches this argument. &#13;
</pre></div><div class="section" title="Enabling and disabling a breakpoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec47"/>Enabling and disabling a breakpoint</h2></div></div></div><p>You can enable and disable a breakpoint using either the breakpoint ID or the location. You pass the ID to the <code class="literal">enable</code> or <code class="literal">disable</code> subcommands:</p><pre class="programlisting">(lldb) breakpoint enable 1.1 &#13;
1 breakpoint enabled. &#13;
 &#13;
(lldb) breakpoint disable 1.1 &#13;
1 breakpoint disabled. &#13;
</pre></div><div class="section" title="Deleting a breakpoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec48"/>Deleting a breakpoint</h2></div></div></div><p>When you no longer need your breakpoint, you can simply remove it using the delete subcommand with the breakpoint ID or location:</p><pre class="programlisting">(lldb) breakpoint delete 1.1 &#13;
</pre></div><div class="section" title="Command aliases"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec49"/>Command aliases</h2></div></div></div><p>Command aliases allow you to create a shorter syntax for commands that you use often. You can also provide help text to accompany your alias. You can see additional details on how to manage a command alias by typing <code class="literal">help command</code>.</p><p>
</p><div class="mediaobject"><img alt="Command aliases" src="graphics/image_09_002.jpg"/></div><p>
</p><p>In the following example, we create a command alias to execute a command we pass to our alias using the Unix shell:</p><p>
</p><div class="mediaobject"><img alt="Command aliases" src="graphics/image_09_003.jpg"/></div><p>
</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we covered the basics of a continuous integration workflow using Xcode Server. You learned what a bot is and how they are used to build and test your code on Xcode Server. With the addition of Swift on Linux, we needed to explore other options outside Xcode for testing code. LLDB is extremely powerful and even has customization options for your debugging sessions. In our next and final chapter, we will discuss writing Swift on a Linux server.</p></div></body></html>