["```kt\nint hw_get_module(const char *id, const struct hw_module_t **module) \n{ \n    return hw_get_module_by_class(id, NULL, module); \n} \n\n```", "```kt\nint hw_get_module_by_class(const char *class_id, const char *inst, \n                           const struct hw_module_t **module) \n{ \n    int i = 0; \n    char prop[PATH_MAX] = {0}; \n    char path[PATH_MAX] = {0}; \n    char name[PATH_MAX] = {0}; \n    char prop_name[PATH_MAX] = {0}; \n\n    if (inst) \n        snprintf(name, PATH_MAX, \"%s.%s\", class_id, inst); \n    else \n        strlcpy(name, class_id, PATH_MAX); \n\n    snprintf(prop_name, sizeof(prop_name), \"ro.hardware.%s\", name); \n    if (property_get(prop_name, prop, NULL) > 0) { \n        if (hw_module_exists(path, sizeof(path), name, prop) == 0) { \n            goto found; \n        } \n    } \n\n    for (i=0 ; i<HAL_VARIANT_KEYS_COUNT; i++) { \n        if (property_get(variant_keys[i], prop, NULL) == 0) { \n            continue; \n        } \n        if (hw_module_exists(path, sizeof(path), name, prop) == 0) { \n            goto found; \n        } \n    } \n\n    /* Nothing found, try the default */ \n    if (hw_module_exists(path, sizeof(path), name, \"default\") == 0) { \n        goto found; \n    } \n\n    return -ENOENT; \n\nfound: \n    return load(class_id, path, module); \n} \n\n```", "```kt\ngralloc.<ro.hardware>.so \ngralloc.<ro.product.board>.so \ngralloc.<ro.board.platform>.so \ngralloc.<ro.arch>.so \n\n```", "```kt\n#define GRALLOC_HARDWARE_MODULE_ID \"gralloc\" \n\n```", "```kt\nstatic int load(const char *id, \n        const char *path, \n        const struct hw_module_t **pHmi) \n{ \n    int status = -EINVAL; \n    void *handle = NULL; \n    struct hw_module_t *hmi = NULL; \n\n    handle = dlopen(path, RTLD_NOW); \n    if (handle == NULL) { \n        char const *err_str = dlerror(); \n        ALOGE(\"load: module=%s\\n%s\", path, err_str?err_str:\"unknown\"); \n        status = -EINVAL; \n        goto done; \n    } \n\n    const char *sym = HAL_MODULE_INFO_SYM_AS_STR; \n    hmi = (struct hw_module_t *)dlsym(handle, sym); \n    if (hmi == NULL) { \n        ALOGE(\"load: couldn't find symbol %s\", sym); \n        status = -EINVAL; \n        goto done; \n    } \n\n    if (strcmp(id, hmi->id) != 0) { \n        ALOGE(\"load: id=%s != hmi->id=%s\", id, hmi->id); \n        status = -EINVAL; \n        goto done; \n    } \n\n    hmi->dso = handle; \n\n    status = 0; \n\n    done: \n    if (status != 0) { \n        hmi = NULL; \n        if (handle != NULL) { \n            dlclose(handle); \n            handle = NULL; \n        } \n    } else { \n        ALOGV(\"loaded HAL id=%s path=%s hmi=%p handle=%p\", \n                id, path, *pHmi, handle); \n    } \n\n    *pHmi = hmi; \n\n    return status; \n} \n\n```", "```kt\nstruct hw_module_t; \nstruct hw_module_methods_t; \nstruct hw_device_t; \n\n```", "```kt\nstatic struct hw_module_methods_t gralloc_module_methods = { \n        .open = gralloc_device_open \n}; \n\nstruct private_module_t HAL_MODULE_INFO_SYM = { \n    .base = { \n        .common = { \n            .tag = HARDWARE_MODULE_TAG, \n            .version_major = 1, \n            .version_minor = 0, \n            .id = GRALLOC_HARDWARE_MODULE_ID, \n            .name = \"Graphics Memory Allocator Module\", \n            .author = \"The Android Open Source Project\", \n            .methods = &gralloc_module_methods \n        }, \n        .registerBuffer = gralloc_register_buffer, \n        .unregisterBuffer = gralloc_unregister_buffer, \n        .lock = gralloc_lock, \n        .unlock = gralloc_unlock, \n    }, \n    .framebuffer = 0, \n    .flags = 0, \n    .numBuffers = 0, \n    .bufferMask = 0, \n    .lock = PTHREAD_MUTEX_INITIALIZER, \n    .currentBuffer = 0, \n}; \n\n```", "```kt\nstruct private_module_t { \n    gralloc_module_t base; \n\n    private_handle_t* framebuffer; \n    uint32_t flags; \n    uint32_t numBuffers; \n    uint32_t bufferMask; \n    pthread_mutex_t lock; \n    buffer_handle_t currentBuffer; \n    int pmem_master; \n    void* pmem_master_base; \n\n    struct fb_var_screeninfo info; \n    struct fb_fix_screeninfo finfo; \n    float xdpi; \n    float ydpi; \n    float fps; \n}; \n\n```", "```kt\ntypedef struct gralloc_module_t { \n    struct hw_module_t common; \n    int (*registerBuffer)(struct gralloc_module_t const* module, \n            buffer_handle_t handle); \n    int (*unregisterBuffer)(struct gralloc_module_t const* module, \n            buffer_handle_t handle); \n    int (*lock)(struct gralloc_module_t const* module, \n            buffer_handle_t handle, int usage, \n            int l, int t, int w, int h, \n            void** vaddr); \n    int (*unlock)(struct gralloc_module_t const* module, \n            buffer_handle_t handle); \n    ... \n} \n\n```", "```kt\nint gralloc_device_open(const hw_module_t* module, const char* name, \n        hw_device_t** device) \n{ \n    int status = -EINVAL; \n    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { \n        gralloc_context_t *dev; \n        dev = (gralloc_context_t*)malloc(sizeof(*dev)); \n\n        memset(dev, 0, sizeof(*dev)); \n\n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = gralloc_close; \n\n        dev->device.alloc   = gralloc_alloc; \n        dev->device.free    = gralloc_free; \n\n        *device = &dev->device.common; \n        status = 0; \n    } else { \n        status = fb_device_open(module, name, device); \n    } \n    return status; \n} \n\n```", "```kt\nstruct gralloc_context_t { \n    alloc_device_t  device; \n    /* our private data here */ \n}; \n\n```", "```kt\ntypedef struct alloc_device_t { \n    struct hw_device_t common; \n\n    int (*alloc)(struct alloc_device_t* dev, \n            int w, int h, int format, int usage, \n            buffer_handle_t* handle, int* stride); \n\n    int (*free)(struct alloc_device_t* dev, \n            buffer_handle_t handle); \n\n    void (*dump)(struct alloc_device_t *dev, char *buff, int buff_len); \n\n    void* reserved_proc[7]; \n} alloc_device_t; \n\n```", "```kt\nstatus = fb_device_open(module, name, device); \n\n```", "```kt\nint fb_device_open(hw_module_t const* module, const char* name, \n        hw_device_t** device) \n{ \n    int status = -EINVAL; \n    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { \n        /* initialize our state here */ \n        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev)); \n        memset(dev, 0, sizeof(*dev)); \n\n        /* initialize the procs */ \n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = fb_close; \n        dev->device.setSwapInterval = fb_setSwapInterval; \n        dev->device.post            = fb_post; \n        dev->device.setUpdateRect = 0; \n\n        private_module_t* m = (private_module_t*)module; \n        status = mapFrameBuffer(m); \n        if (status >= 0) { \n            int stride = m->finfo.line_length / \n            (m->info.bits_per_pixel >> 3); \n            /* \n             * Auto detect current depth and select mode \n             */ \n            int format; \n            if (m->info.bits_per_pixel == 32) { \n                format = (m->info.red.offset == 16) ?  \n                HAL_PIXEL_FORMAT_BGRA_8888 \n                : (m->info.red.offset == 24) ? \n                HAL_PIXEL_FORMAT_RGBA_8888 : \n                HAL_PIXEL_FORMAT_RGBX_8888; \n            } else if (m->info.bits_per_pixel == 16) { \n                format = HAL_PIXEL_FORMAT_RGB_565; \n            } else { \n                ALOGE(\"Unsupported format %d\", m->info.bits_per_pixel); \n                return -EINVAL; \n            } \n            const_cast<uint32_t&>(dev->device.flags) = 0; \n            const_cast<uint32_t&>(dev->device.width) = m->info.xres; \n            const_cast<uint32_t&>(dev->device.height) = m->info.yres; \n            const_cast<int&>(dev->device.stride) = stride; \n            const_cast<int&>(dev->device.format) = format; \n            const_cast<float&>(dev->device.xdpi) = m->xdpi; \n            const_cast<float&>(dev->device.ydpi) = m->ydpi; \n            const_cast<float&>(dev->device.fps) = m->fps; \n            const_cast<int&>(dev->device.minSwapInterval) = 1; \n            const_cast<int&>(dev->device.maxSwapInterval) = 1; \n            *device = &dev->device.common; \n        } \n    } \n    return status; \n} \n\n```", "```kt\nstruct fb_context_t { \n    framebuffer_device_t  device; \n}; \n\n```", "```kt\ntypedef struct framebuffer_device_t { \n    struct hw_device_t common; \n\n    const uint32_t  flags; \n\n    const uint32_t  width; \n    const uint32_t  height; \n\n    const int       stride; \n\n    const int       format; \n\n    const float     xdpi; \n    const float     ydpi; \n\n    const float     fps; \n\n    const int       minSwapInterval; \n\n    const int       maxSwapInterval; \n\n    const int       numFramebuffers; \n\n    int reserved[7]; \n    int (*setSwapInterval)(struct framebuffer_device_t* window, \n            int interval); \n    int (*setUpdateRect)(struct framebuffer_device_t* window, \n            int left, int top, int width, int height); \n    int (*post)(struct framebuffer_device_t* dev, buffer_handle_t \n    buffer); \n    int (*compositionComplete)(struct framebuffer_device_t* dev); \n    void (*dump)(struct framebuffer_device_t* dev, char *buff, int \n    buff_len); \n    int (*enableScreen)(struct framebuffer_device_t* dev, int enable); \n    void* reserved_proc[6]; \n\n} framebuffer_device_t; \n\n```", "```kt\nstatic int mapFrameBuffer(struct private_module_t* module) \n{ \n    pthread_mutex_lock(&module->lock); \n    int err = mapFrameBufferLocked(module); \n    pthread_mutex_unlock(&module->lock); \n    return err; \n} \n\n```", "```kt\nint mapFrameBufferLocked(struct private_module_t* module) \n{ \n    // already initialized... \n    if (module->framebuffer) { \n        return 0; \n    } \n\n    char const * const device_template[] = { \n            \"/dev/graphics/fb%u\", \n            \"/dev/fb%u\", \n            0 }; \n\n    int fd = -1; \n    int i=0; \n    char name[64]; \n\n    while ((fd==-1) && device_template[i]) { \n        snprintf(name, 64, device_template[i], 0); \n        fd = open(name, O_RDWR, 0); \n        i++; \n    } \n    if (fd < 0) \n        return -errno; \n    ... \n\n```", "```kt\n    ... \n    struct fb_fix_screeninfo finfo; \n    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1) \n        return -errno; \n\n    struct fb_var_screeninfo info; \n    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1) \n        return -errno; \n    ... \n\n```", "```kt\n    ... \n    info.reserved[0] = 0; \n    info.reserved[1] = 0; \n    info.reserved[2] = 0; \n    info.xoffset = 0; \n    info.yoffset = 0; \n    info.activate = FB_ACTIVATE_NOW; \n\n    /* \n     * Request NUM_BUFFERS screens (at lest 2 for page flipping) \n     */ \n    info.yres_virtual = info.yres * NUM_BUFFERS; \n\n    uint32_t flags = PAGE_FLIP; \n#if USE_PAN_DISPLAY \n    if (ioctl(fd, FBIOPAN_DISPLAY, &info) == -1) { \n        ALOGW(\"FBIOPAN_DISPLAY failed, page flipping not supported\"); \n#else \n    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) { \n        ALOGW(\"FBIOPUT_VSCREENINFO failed, page flipping not supported\"); \n#endif \n        info.yres_virtual = info.yres; \n        flags &= ~PAGE_FLIP; \n    } \n\n    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1) \n        return -errno; \n\n    if (finfo.smem_len <= 0) \n        return -errno; \n\n    if (finfo.smem_len / finfo.line_length < info.yres_virtual) \n        info.yres_virtual = finfo.smem_len / finfo.line_length; \n\n    if (info.yres_virtual < info.yres * 2) { \n        // we need at least 2 for page-flipping \n        info.yres_virtual = info.yres; \n        flags &= ~PAGE_FLIP; \n        ALOGW(\"page flipping not supported (yres_virtual=%d, \n        requested=%d)\", \n                info.yres_virtual, info.yres*2); \n    } \n    ... \n\n```", "```kt\n    ... \n    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1) \n        return -errno; \n\n    if (finfo.smem_len / finfo.line_length < info.yres_virtual) \n        info.yres_virtual = finfo.smem_len / finfo.line_length; \n\n    uint64_t  refreshQuotient = \n    ( \n            uint64_t( info.upper_margin + info.lower_margin + info.yres ) * \n            ( info.left_margin  + info.right_margin + info.xres ) * \n            info.pixclock \n    ); \n\n    /* Beware, info.pixclock might be 0 under emulation, so avoid  \n     * a division-by-0 here (SIGFPE on ARM) */ \n    int refreshRate = refreshQuotient > 0 ? (int)(1000000000000000LLU / \n    refreshQuotient) : 0; \n\n    if (refreshRate == 0) { \n        // bleagh, bad info from the driver \n        refreshRate = 60*1000;  // 60 Hz \n    } \n    ... \n\n```", "```kt\n    ... \n    if (int(info.width) <= 0 || int(info.height) <= 0) { \n        // the driver doesn't return that information \n        // default to 160 dpi \n        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f); \n        info.height = ((info.yres * 25.4f)/160.0f + 0.5f); \n    } \n\n    float xdpi = (info.xres * 25.4f) / info.width; \n    float ydpi = (info.yres * 25.4f) / info.height; \n    float fps  = refreshRate / 1000.0f; \n\n    module->finfo = finfo; \n    module->xdpi = xdpi; \n    module->ydpi = ydpi; \n    module->fps = fps; \n    ... \n\n```", "```kt\n    ... \n    while (info.yres_virtual > 0) { \n        size_t fbSize = roundUpToPageSize(finfo.line_length * \n        info.yres_virtual); \n        module->numBuffers = info.yres_virtual / info.yres; \n        void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, \n        fd, 0); \n        if (vaddr != MAP_FAILED) { \n            module->info = info; \n            module->flags = flags; \n            module->bufferMask = 0; \n            module->framebuffer = new private_handle_t(dup(fd), \n            fbSize, 0); \n            module->framebuffer->base = intptr_t(vaddr); \n            memset(vaddr, 0, fbSize); \n            return 0; \n        } \n\n        ALOGE(\"Error mapping the framebuffer (%s)\", strerror(errno)); \n\n        info.yres_virtual -= info.yres; \n        ALOGW(\"Fallback to use fewer buffer: %d\", info.yres_virtual /  \n        info.yres); \n        if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) \n            break; \n\n        if (info.yres_virtual <= info.yres) \n            flags &= ~PAGE_FLIP; \n    } \n\n    return -errno; \n} \n\n```", "```kt\nstatic int gralloc_alloc(alloc_device_t* dev, \n        int w, int h, int format, int usage, \n        buffer_handle_t* pHandle, int* pStride) \n{ \n    if (!pHandle || !pStride) \n        return -EINVAL; \n\n    size_t size, stride; \n\n    int align = 4; \n    int bpp = 0; \n    switch (format) { \n        case HAL_PIXEL_FORMAT_RGBA_8888: \n        case HAL_PIXEL_FORMAT_RGBX_8888: \n        case HAL_PIXEL_FORMAT_BGRA_8888: \n            bpp = 4; \n            break; \n        case HAL_PIXEL_FORMAT_RGB_888: \n            bpp = 3; \n            break; \n        case HAL_PIXEL_FORMAT_RGB_565: \n        case HAL_PIXEL_FORMAT_RAW16: \n            bpp = 2; \n            break; \n        default: \n            return -EINVAL; \n    } \n\n    private_module_t* m = reinterpret_cast<private_module_t*>( \n                        dev->common.module); \n\n    size_t bpr = usage & GRALLOC_USAGE_HW_FB ? m->finfo.line_length : \n    (w*bpp + (align-1)) & ~(align-1); \n    size = bpr * h; \n    stride = bpr / bpp; \n\n    int err; \n    if (usage & GRALLOC_USAGE_HW_FB) { \n        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle); \n    } else { \n        err = gralloc_alloc_buffer(dev, size, usage, pHandle); \n    } \n\n    if (err < 0) { \n        return err; \n    } \n\n    *pStride = stride; \n    return 0; \n} \n\n```", "```kt\ntypedef struct native_handle \n{ \n    int version;     /* sizeof(native_handle_t) */ \n    int numFds;      /* number of file-descriptors at &data[0] */ \n    int numInts;     /* number of ints at &data[numFds] */ \n    int data[0];     /* numFds + numInts ints */ \n} native_handle_t; \n\n```", "```kt\n#ifdef __cplusplus \nstruct private_handle_t : public native_handle { \n#else \nstruct private_handle_t { \n    struct native_handle nativeHandle; \n#endif \n\n    enum { \n        PRIV_FLAGS_FRAMEBUFFER = 0x00000001 \n    }; \n\n    // file-descriptors \n    int     fd; \n    // ints \n    int     magic; \n    int     flags; \n    int     size; \n    int     offset; \n\n    // FIXME: the attributes below should be out-of-line \n    uint64_t base __attribute__((aligned(8))); \n    int     pid; \n\n#ifdef __cplusplus \n    static inline int sNumInts() { \n        return (((sizeof(private_handle_t) - \n        sizeof(native_handle_t))/sizeof(int)) - sNumFds); \n    } \n    static const int sNumFds = 1; \n    static const int sMagic = 0x3141592; \n\n    private_handle_t(int fd, int size, int flags) : \n        fd(fd), magic(sMagic), flags(flags), size(size), offset(0), \n        base(0), pid(getpid()) \n    { \n        version = sizeof(native_handle); \n        numInts = sNumInts(); \n        numFds = sNumFds; \n    } \n    ~private_handle_t() { \n        magic = 0; \n    } \n\n    static int validate(const native_handle* h) { \n        const private_handle_t* hnd = (const private_handle_t*)h; \n        if (!h || h->version != sizeof(native_handle) || \n                h->numInts != sNumInts() || h->numFds != sNumFds || \n                hnd->magic != sMagic) \n        { \n            ALOGE(\"invalid gralloc handle (at %p)\", h); \n            return -EINVAL; \n        } \n        return 0; \n    } \n#endif \n}; \n\n```", "```kt\nstatic int gralloc_alloc_framebuffer_locked(alloc_device_t* dev, \n        size_t size, int usage, buffer_handle_t* pHandle) \n{ \n    private_module_t* m = reinterpret_cast<private_module_t*>( \n            dev->common.module); \n\n    // allocate the framebuffer \n    if (m->framebuffer == NULL) { \n        // initialize the framebuffer, the framebuffer is mapped once \n        // and forever. \n        int err = mapFrameBufferLocked(m); \n        if (err < 0) { \n            return err; \n        } \n    } \n\n    const uint32_t bufferMask = m->bufferMask; \n    const uint32_t numBuffers = m->numBuffers; \n    const size_t bufferSize = m->finfo.line_length * m->info.yres; \n    if (numBuffers == 1) { \n        // If we have only one buffer, we never use page-flipping.  \n        // Instead we return a regular buffer which will be \n        // memcpy'ed to the main screen when post is called. \n        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) |   \n        GRALLOC_USAGE_HW_2D; \n        return gralloc_alloc_buffer(dev, bufferSize, newUsage, \n        pHandle); \n    } \n\n    if (bufferMask >= ((1LU<<numBuffers)-1)) { \n        // We ran out of buffers. \n        return -ENOMEM; \n    } \n\n    // create a \"fake\" handles for it \n    intptr_t vaddr = intptr_t(m->framebuffer->base); \n    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer-\n    >fd), \n    size, private_handle_t::PRIV_FLAGS_FRAMEBUFFER); \n\n    // find a free slot \n    for (uint32_t i=0 ; i<numBuffers ; i++) { \n        if ((bufferMask & (1LU<<i)) == 0) { \n            m->bufferMask |= (1LU<<i); \n            break; \n        } \n        vaddr += bufferSize; \n    } \n\n    hnd->base = vaddr; \n    hnd->offset = vaddr - intptr_t(m->framebuffer->base); \n    *pHandle = hnd; \n\n    return 0; \n} \n\nstatic int gralloc_alloc_framebuffer(alloc_device_t* dev, \n        size_t size, int usage, buffer_handle_t* pHandle) \n{ \n    private_module_t* m = reinterpret_cast<private_module_t*>( \n            dev->common.module); \n    pthread_mutex_lock(&m->lock); \n    int err = gralloc_alloc_framebuffer_locked(dev, size, usage,  \n    pHandle); \n    pthread_mutex_unlock(&m->lock); \n    return err; \n} \n\n```", "```kt\nstatic int gralloc_alloc_buffer(alloc_device_t* dev, \n        size_t size, int /*usage*/, buffer_handle_t* pHandle) \n{ \n    int err = 0; \n    int fd = -1; \n\n    size = roundUpToPageSize(size); \n\n    fd = ashmem_create_region(\"gralloc-buffer\", size); \n    if (fd < 0) { \n        ALOGE(\"couldn't create ashmem (%s)\", strerror(-errno)); \n        err = -errno; \n    } \n\n    if (err == 0) { \n        private_handle_t* hnd = new private_handle_t(fd, size, 0); \n        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>( \n                dev->common.module); \n        err = mapBuffer(module, hnd); \n        if (err == 0) { \n            *pHandle = hnd; \n        } \n    } \n\n    ALOGE_IF(err, \"gralloc failed err=%s\", strerror(-err)); \n\n    return err; \n} \n\n```", "```kt\nint mapBuffer(gralloc_module_t const* module, \n        private_handle_t* hnd) \n{ \n    void* vaddr; \n    return gralloc_map(module, hnd, &vaddr); \n} \n\n```", "```kt\nstatic int gralloc_map(gralloc_module_t const* /*module*/, \n        buffer_handle_t handle, \n        void** vaddr) \n{ \n    private_handle_t* hnd = (private_handle_t*)handle; \n    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) { \n        size_t size = hnd->size; \n        void* mappedAddress = mmap(0, size, \n                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0); \n        if (mappedAddress == MAP_FAILED) { \n            ALOGE(\"Could not mmap %s\", strerror(errno)); \n            return -errno; \n        } \n        hnd->base = uintptr_t(mappedAddress) + hnd->offset; \n        //ALOGD(\"gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p\", \n        //        hnd->fd, hnd->offset, hnd->size, mappedAddress); \n    } \n    *vaddr = (void*)hnd->base; \n    return 0; \n} \n\n```", "```kt\nstatic int gralloc_free(alloc_device_t* dev, \n        buffer_handle_t handle) \n{ \n    if (private_handle_t::validate(handle) < 0) \n        return -EINVAL; \n\n    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>\n    (handle); \n    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) { \n        // free this buffer \n        private_module_t* m = reinterpret_cast<private_module_t*>( \n                dev->common.module); \n        const size_t bufferSize = m->finfo.line_length * m->info.yres; \n        int index = (hnd->base - m->framebuffer->base) / bufferSize; \n        m->bufferMask &= ~(1<<index);  \n    } else {  \n        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>( \n                dev->common.module); \n        terminateBuffer(module, const_cast<private_handle_t*>(hnd)); \n    } \n\n    close(hnd->fd); \n    delete hnd; \n    return 0; \n} \n\n```", "```kt\nint terminateBuffer(gralloc_module_t const* module, \n        private_handle_t* hnd) \n{ \n    if (hnd->base) { \n        // this buffer was mapped, unmap it now \n        gralloc_unmap(module, hnd); \n    } \n\n    return 0; \n} \n\n```", "```kt\nstatic int gralloc_unmap(gralloc_module_t const* /*module*/, \n        buffer_handle_t handle) \n{ \n    private_handle_t* hnd = (private_handle_t*)handle; \n    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER))  \n    { \n        void* base = (void*)hnd->base; \n        size_t size = hnd->size; \n        //ALOGD(\"unmapping from %p, size=%d\", base, size); \n        if (munmap(base, size) < 0) { \n            ALOGE(\"Could not unmap %s\", strerror(errno)); \n        } \n    } \n    hnd->base = 0; \n    return 0; \n} \n\n```", "```kt\n    ... \n    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { \n        gralloc_context_t *dev; \n        dev = (gralloc_context_t*)malloc(sizeof(*dev)); \n\n        /* initialize our state here */ \n        memset(dev, 0, sizeof(*dev)); \n\n        /* initialize the procs */ \n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = gralloc_close; \n\n        dev->device.alloc   = gralloc_alloc; \n        dev->device.free    = gralloc_free; \n\n        *device = &dev->device.common; \n    ... \n\n```", "```kt\n    ... \n    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { \n        /* initialize our state here */ \n        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev)); \n        memset(dev, 0, sizeof(*dev)); \n\n        /* initialize the procs */ \n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = fb_close; \n        dev->device.setSwapInterval = fb_setSwapInterval; \n        dev->device.post            = fb_post; \n        dev->device.setUpdateRect = 0; \n\n        private_module_t* m = (private_module_t*)module; \n    ... \n\n```", "```kt\nstatic int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer) \n{ \n    if (private_handle_t::validate(buffer) < 0) \n        return -EINVAL; \n\n    fb_context_t* ctx = (fb_context_t*)dev; \n\n    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>\n    (buffer); \n    private_module_t* m = reinterpret_cast<private_module_t*>( \n            dev->common.module); \n\n    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) { \n        const size_t offset = hnd->base - m->framebuffer->base; \n        m->info.activate = FB_ACTIVATE_VBL; \n        m->info.yoffset = offset / m->finfo.line_length; \n        if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) { \n            ALOGE(\"FBIOPUT_VSCREENINFO failed\"); \n            m->base.unlock(&m->base, buffer);  \n            return -errno; \n        } \n        m->currentBuffer = buffer; \n\n    } else { \n        // If we can't do the page_flip, just copy the buffer to the front  \n        // FIXME: use copybit HAL instead of memcpy \n\n        void* fb_vaddr; \n        void* buffer_vaddr; \n\n        m->base.lock(&m->base, m->framebuffer,  \n                GRALLOC_USAGE_SW_WRITE_RARELY,  \n                0, 0, m->info.xres, m->info.yres, &fb_vaddr); \n\n        m->base.lock(&m->base, buffer,  \n                GRALLOC_USAGE_SW_READ_RARELY,  \n                0, 0, m->info.xres, m->info.yres, &buffer_vaddr); \n\n        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * m-\n        >info.yres); \n\n        m->base.unlock(&m->base, buffer);  \n        m->base.unlock(&m->base, m->framebuffer);  \n    } \n\n    return 0; \n} \n\n```", "```kt\nprivate_module_t* m = reinterpret_cast<private_module_t*>( \ndev->common.module); \n\n```", "```kt\n    ... \n        m->info.activate = FB_ACTIVATE_VBL; \n        m->info.yoffset = offset / m->finfo.line_length; \n        if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) { \n    ... \n\n```", "```kt\nmemcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * m->info.yres); \n\n```", "```kt\nhw.gps=yes \nhw.gpu.enabled=yes \nhw.gpu.mode=swiftshader \n\n```", "```kt\n$ git clone https://android.googlesource.com/platform/external/qemu  \n\n```", "```kt\nstruct hw_module_t; \nstruct hw_module_methods_t; \nstruct hw_device_t; \n\n```", "```kt\nstruct private_module_t { \n    gralloc_module_t base; \n\n    private_handle_t* framebuffer; \n    uint32_t flags; \n    uint32_t numBuffers; \n    uint32_t bufferMask; \n    pthread_mutex_t lock; \n    buffer_handle_t currentBuffer; \n    int pmem_master; \n    void* pmem_master_base; \n\n    struct fb_var_screeninfo info; \n    struct fb_fix_screeninfo finfo; \n    float xdpi; \n    float ydpi; \n    float fps; \n}; \n\n```", "```kt\nstruct private_module_t { \n    gralloc_module_t base; \n}; \n\n```", "```kt\nstruct gralloc_device_t { \n    alloc_device_t  device; \n\n    AllocListNode *allocListHead;    // double linked list of allocated buffers \n    pthread_mutex_t lock; \n}; \n\nstruct fb_device_t { \n    framebuffer_device_t  device; \n}; \n\n```", "```kt\nstatic int gralloc_device_open(const hw_module_t* module, \n                               const char* name, \n                               hw_device_t** device) \n{ \n    int status = -EINVAL; \n\n    D(\"gralloc_device_open %s\\n\", name); \n\n    pthread_once( &sFallbackOnce, fallback_init ); \n    if (sFallback != NULL) { \n        return sFallback->common.methods->open(&sFallback->common, \n        name, device); \n    } \n\n    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { \n\n        // Create host connection and keep it in the TLS. \n        // return error if connection with host can not be established \n        HostConnection *hostCon = HostConnection::get(); \n        if (!hostCon) { \n            ALOGE(\"gralloc: failed to get host connection \n            while opening %s\\n\", \n            name); \n            return -EIO; \n        } \n\n        // \n        // Allocate memory for the gralloc device (alloc interface) \n        // \n        gralloc_device_t *dev; \n        dev = (gralloc_device_t*)malloc(sizeof(gralloc_device_t)); \n        if (NULL == dev) { \n            return -ENOMEM; \n        } \n\n        // Initialize our device structure \n        // \n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = gralloc_device_close; \n\n        dev->device.alloc   = gralloc_alloc; \n        dev->device.free    = gralloc_free; \n        dev->allocListHead  = NULL; \n        pthread_mutex_init(&dev->lock, NULL); \n\n        *device = &dev->device.common; \n        status = 0; \n    } \n    else if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { \n    ... \n    } \n\n    return status; \n} \n\n```", "```kt\nstatic int gralloc_device_open(const hw_module_t* module, \n                               const char* name, \n                               hw_device_t** device) \n{ \n    int status = -EINVAL; \n\n    D(\"gralloc_device_open %s\\n\", name); \n\n    pthread_once( &sFallbackOnce, fallback_init ); \n    if (sFallback != NULL) { \n        return sFallback->common.methods->open(&sFallback->common, \n        name, device); \n    } \n\n    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { \n      ... \n    } \n    else if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { \n\n        // return error if connection with host can not be established \n        DEFINE_AND_VALIDATE_HOST_CONNECTION; \n\n        // \n        // Query the host for Framebuffer attributes \n        // \n        D(\"gralloc: query Frabuffer attribs\\n\"); \n        EGLint width = rcEnc->rcGetFBParam(rcEnc, FB_WIDTH); \n        D(\"gralloc: width=%d\\n\", width); \n        EGLint height = rcEnc->rcGetFBParam(rcEnc, FB_HEIGHT); \n        D(\"gralloc: height=%d\\n\", height); \n        EGLint xdpi = rcEnc->rcGetFBParam(rcEnc, FB_XDPI); \n        D(\"gralloc: xdpi=%d\\n\", xdpi); \n        EGLint ydpi = rcEnc->rcGetFBParam(rcEnc, FB_YDPI); \n        D(\"gralloc: ydpi=%d\\n\", ydpi); \n        EGLint fps = rcEnc->rcGetFBParam(rcEnc, FB_FPS); \n        D(\"gralloc: fps=%d\\n\", fps); \n        EGLint min_si = rcEnc->rcGetFBParam(rcEnc,  \n        FB_MIN_SWAP_INTERVAL); \n        D(\"gralloc: min_swap=%d\\n\", min_si); \n        EGLint max_si = rcEnc->rcGetFBParam(rcEnc, \n        FB_MAX_SWAP_INTERVAL); \n        D(\"gralloc: max_swap=%d\\n\", max_si); \n\n        // \n        // Allocate memory for the framebuffer device \n        // \n        fb_device_t *dev; \n        dev = (fb_device_t*)malloc(sizeof(fb_device_t)); \n        if (NULL == dev) { \n            return -ENOMEM; \n        } \n        memset(dev, 0, sizeof(fb_device_t)); \n\n        // Initialize our device structure \n        // \n        dev->device.common.tag = HARDWARE_DEVICE_TAG; \n        dev->device.common.version = 0; \n        dev->device.common.module = const_cast<hw_module_t*>(module); \n        dev->device.common.close = fb_close; \n        dev->device.setSwapInterval = fb_setSwapInterval; \n        dev->device.post            = fb_post; \n        dev->device.setUpdateRect   = 0; //fb_setUpdateRect; \n        dev->device.compositionComplete = fb_compositionComplete; \n\n        const_cast<uint32_t&>(dev->device.flags) = 0; \n        const_cast<uint32_t&>(dev->device.width) = width; \n        const_cast<uint32_t&>(dev->device.height) = height; \n        const_cast<int&>(dev->device.stride) = width; \n        const_cast<int&>(dev->device.format) = \n        HAL_PIXEL_FORMAT_RGBA_8888; \n        const_cast<float&>(dev->device.xdpi) = xdpi; \n        const_cast<float&>(dev->device.ydpi) = ydpi; \n        const_cast<float&>(dev->device.fps) = fps; \n        const_cast<int&>(dev->device.minSwapInterval) = min_si; \n        const_cast<int&>(dev->device.maxSwapInterval) = max_si; \n        *device = &dev->device.common; \n\n        status = 0; \n    } \n\n```", "```kt\nstatic int gralloc_alloc(alloc_device_t* dev, \n                         int w, int h, int format, int usage, \n                         buffer_handle_t* pHandle, int* pStride) \n{ \n    D(\"gralloc_alloc w=%d h=%d usage=0x%x\\n\", w, h, usage); \n\n    gralloc_device_t *grdev = (gralloc_device_t *)dev; \n    if (!grdev || !pHandle || !pStride) { \n        ALOGE(\"gralloc_alloc: Bad inputs (grdev: %p, pHandle: %p, \n        pStride: %p\", \n        grdev, pHandle, pStride); \n        return -EINVAL; \n    } \n\n    // \n    // Note: in screen capture mode, both sw_write \n    // and hw_write will be on \n    // and this is a valid usage \n    // \n    bool sw_write = (0 != (usage & GRALLOC_USAGE_SW_WRITE_MASK)); \n    bool hw_write = (usage & GRALLOC_USAGE_HW_RENDER); \n    bool sw_read = (0 != (usage & GRALLOC_USAGE_SW_READ_MASK)); \n    bool hw_cam_write = usage & GRALLOC_USAGE_HW_CAMERA_WRITE; \n    bool hw_cam_read = usage & GRALLOC_USAGE_HW_CAMERA_READ; \n    bool hw_vid_enc_read = usage & GRALLOC_USAGE_HW_VIDEO_ENCODER; \n\n    // Keep around original requested format for later validation \n    int frameworkFormat = format; \n    // Pick the right concrete pixel format given the endpoints as    \n    // encoded in the usage bits.  \n    // Every end-point pair needs explicit listing here. \n    if (format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) { \n        // Camera as producer \n        ... \n    if (usage & GRALLOC_USAGE_HW_FB) { \n        // keep space for postCounter \n        ashmem_size += sizeof(uint32_t); \n    } \n\n    if (sw_read || sw_write || hw_cam_write || hw_vid_enc_read) { \n        // keep space for image on guest memory if SW access is needed \n        // or if the camera is doing writing \n        if (yuv_format) { \n            size_t yStride = (w*bpp + (align - 1)) & ~(align-1); \n            size_t uvStride = (yStride / 2 + (align - 1)) & ~(align-1); \n            size_t uvHeight = h / 2; \n            ashmem_size += yStride * h + 2 * (uvHeight * uvStride); \n            stride = yStride / bpp; \n        } else { \n            size_t bpr = (w*bpp + (align-1)) & ~(align-1); \n            ashmem_size += (bpr * h); \n            stride = bpr / bpp; \n        } \n    } \n\n    D(\"gralloc_alloc format=%d, ashmem_size=%d, stride=%d, \n    tid %d\\n\", format, \n            ashmem_size, stride, gettid()); \n\n```", "```kt\n    // \n    // Allocate space in ashmem if needed \n    // \n    int fd = -1; \n    if (ashmem_size > 0) { \n        // round to page size; \n        ashmem_size = (ashmem_size + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1); \n\n        fd = ashmem_create_region(\"gralloc-buffer\", ashmem_size); \n        if (fd < 0) { \n            ALOGE(\"gralloc_alloc failed to create ashmem region: %s\\n\", \n                    strerror(errno)); \n            return -errno; \n        } \n    } \n\n    cb_handle_t *cb = new cb_handle_t(fd, ashmem_size, usage, \n                                      w, h, frameworkFormat, format, \n                                      glFormat, glType); \n\n    if (ashmem_size > 0) { \n        // \n        // map ashmem region if exist \n        // \n        void *vaddr; \n        int err = map_buffer(cb, &vaddr); \n        if (err) { \n            close(fd); \n            delete cb; \n            return err; \n        } \n\n        cb->setFd(fd); \n    } \n\n    // \n    // Allocate ColorBuffer handle on the host (only if h/w access is   \n    //allowed) only do this for some h/w usages, not all. \n    // \n    if (usage & (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER | \n                    GRALLOC_USAGE_HW_2D | GRALLOC_USAGE_HW_COMPOSER | \n                    GRALLOC_USAGE_HW_FB) ) { \n        DEFINE_HOST_CONNECTION; \n        if (hostCon && rcEnc) { \n            cb->hostHandle = rcEnc->rcCreateColorBuffer(rcEnc, w, h, \n            glFormat); \n            D(\"Created host ColorBuffer 0x%x\\n\", cb->hostHandle); \n        } \n\n        if (!cb->hostHandle) { \n           // Could not create colorbuffer on host !!! \n           close(fd); \n           delete cb; \n           return -EIO; \n        } \n    } \n\n```", "```kt\nstruct cb_handle_t : public native_handle { \n\n    cb_handle_t(int p_fd, int p_ashmemSize, int p_usage, \n                int p_width, int p_height, int p_frameworkFormat, \n                int p_format, int p_glFormat, int p_glType) : \n    ... \n    // file-descriptors \n    int fd;   \n\n    // ints \n    int magic; \n    int usage; \n    int width; \n    int height; \n    int frameworkFormat; \n    int format; \n    int glFormat; \n    int glType; \n    int ashmemSize; \n\n    union { \n        intptr_t ashmemBase; \n        uint64_t padding; \n    } __attribute__((aligned(8))); \n\n    int ashmemBasePid; \n    int mappedPid; \n    int lockedLeft; \n    int lockedTop; \n    int lockedWidth; \n    int lockedHeight; \n    uint32_t hostHandle; \n}; \n\n```", "```kt\n    // \n    // alloc succeeded - insert the allocated handle to the allocated    \n    // list \n    // \n    AllocListNode *node = new AllocListNode(); \n    pthread_mutex_lock(&grdev->lock); \n    node->handle = cb; \n    node->next =  grdev->allocListHead; \n    node->prev =  NULL; \n    if (grdev->allocListHead) { \n        grdev->allocListHead->prev = node; \n    } \n    grdev->allocListHead = node; \n    pthread_mutex_unlock(&grdev->lock); \n\n    *pHandle = cb; \n    if (frameworkFormat == HAL_PIXEL_FORMAT_YCbCr_420_888) { \n        *pStride = 0; \n    } else { \n        *pStride = stride; \n    } \n    return 0; \n} \n\n```", "```kt\nstatic int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer) \n{ \n    fb_device_t *fbdev = (fb_device_t *)dev; \n    cb_handle_t *cb = (cb_handle_t *)buffer; \n\n    if (!fbdev || !cb_handle_t::validate(cb) || !cb->canBePosted()) { \n        return -EINVAL; \n    } \n\n    // Make sure we have host connection \n    DEFINE_AND_VALIDATE_HOST_CONNECTION; \n\n    // increment the post count of the buffer \n    intptr_t *postCountPtr = (intptr_t *)cb->ashmemBase; \n    if (!postCountPtr) { \n        // This should not happen \n        return -EINVAL; \n    } \n    (*postCountPtr)++; \n\n    // send post request to host \n    rcEnc->rcFBPost(rcEnc, cb->hostHandle); \n    hostCon->flush(); \n\n    return 0; \n} \n\n```"]