<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-72"><em class="italic"><a id="_idTextAnchor076"/>Chapter 6</em>: Assembling a Repository</h1>
			<p>In this chapter, we will begin by discussing the application's data layer and the components that make up this layer, including repositories and data sources. We will then move on to the topic of repositories, one of the application layer's components, and the role they play in managing the data of an application. In this chapter's exercise, we will continue the project started in the previous chapter by providing the repository implementations for the abstractions defined there and also introducing new abstractions for the different types of data sources. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating the data layer</li>
				<li>Creating repositories</li>
			</ul>
			<p>By the end of the chapter, you will have learned what the data layer is and how we can create repositories for an Android application.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3NpAhNs">https://bit.ly/3NpAhNs</a></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Creating the data layer</h1>
			<p>In this section, we will look at the data layer of <a id="_idIndexMarker448"/>an Android application and the components that typically form part of the data layer.</p>
			<p>The data layer is the layer in which data is created and managed. This means that this layer is responsible for creating, reading, updating, and deleting data, as well as for managing and ensuring that data from the internet is synced with persistent data. </p>
			<p>In the previous chapter, we have seen that use cases depend on an abstraction of a repository class, and there can be <a id="_idIndexMarker449"/>multiple repositories for different data types. Repositories represent the entry point into the data layer and are responsible for managing multiple data sources and centralizing the data. The data sources represent the other component of the data layer and are responsible for managing the data of a particular source (internet, Room, data store, and suchlike). </p>
			<p>An example of what the data layer for a particular set of data, which uses two data sources, might look like is shown in the following figure:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_6.1_B18320.jpg" alt="Figure 6.1 – Data layer example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Data layer example</p>
			<p>In the preceding diagram, we have an example of what a data layer would look like when it is connected to the domain layer. We can<a id="_idIndexMarker450"/> observe that the <strong class="source-inline">UseCase</strong> class depends on a <strong class="source-inline">Repository</strong> abstraction, which represents the domain layer. The data layer is represented by <strong class="source-inline">RepositoryImpl</strong>, which is the implementation of the <strong class="source-inline">Repository</strong> abstraction. The <strong class="source-inline">RepositoryImpl</strong> class depends on the two data source implementations: <strong class="source-inline">RemoteDataSourceImpl</strong> and <strong class="source-inline">LocalDataSourceImpl</strong>. Each data source then depends on a particular implementation for managing data from the internet using Retrofit in the case of <strong class="source-inline">RetrofitService</strong>, or using a particular data access class that uses Room in the case of <strong class="source-inline">DbDao</strong>. </p>
			<p>This approach poses a problem owing to the direct dependency between <strong class="source-inline">RepositoryImpl</strong> and <strong class="source-inline">RemoteDataSourceImpl</strong>, and the problem arises when we might want to swap out Retrofit or Room for alternatives. If we might want to swap out these libraries for others, we risk changes in the <strong class="source-inline">RepositoryImpl</strong> class, which violates the single-responsibility principle. The solution for this is like the solution we had for solving the dependencies <a id="_idIndexMarker451"/>between the use cases and the repositories, and that is to invert the dependencies between the repository and the data sources. This would look like the following:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_6.2_B18320.jpg" alt="Figure 6.2 – Data layer with inverted dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Data layer with inverted dependencies</p>
			<p>In the preceding diagram, we have introduced two abstractions for each data source, named <strong class="source-inline">RemoteDataSource</strong> and <strong class="source-inline">LocalDataSource</strong>. <strong class="source-inline">RepositoryImpl</strong> now depends on these two abstractions and all the conversions between Retrofit- or Room-related objects and domain entities should now be placed in <strong class="source-inline">RemoteDataSourceImpl</strong> or <strong class="source-inline">LocalDataSourceImpl</strong>, which inherit the new abstractions and will continue to handle the data from Retrofit or Room. If we want to split the data layer into <a id="_idIndexMarker452"/>different Gradle modules, we will have the following:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_6.3_B18320.jpg" alt="Figure 6.3 – Data layer modules&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Data layer modules</p>
			<p>The preceding diagram shows the Gradle module dependencies between the repository and local and remote data sources. Here we can see the benefit of dependency inversion, which allows us to have a separate repository module without depending on Retrofit or Room. </p>
			<p>In this section, we have discussed the data layer and the components inside it and how to manage the dependencies between all the components. In the following section, we will take a closer look at repositories and how to implement them. </p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Creating repositories</h1>
			<p>In this section, we will look<a id="_idIndexMarker453"/> at what a repository is and the role it plays in the data layer of an application, and how we can create repositories with various data sources. </p>
			<p>The repository represents an abstraction for the data than an application uses, and it is responsible for managing and centralizing the data from one or multiple data sources.</p>
			<p>In the previous chapter, we defined the following entity:</p>
			<p class="source-code">data class User(</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    val firstName: String,</p>
			<p class="source-code">    val lastName: String,</p>
			<p class="source-code">    val email: String</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getFullName() = "$firstName $lastName"</p>
			<p class="source-code">}</p>
			<p>Here we have a simple <strong class="source-inline">User</strong> data class with a few relevant fields. The repository abstraction for the <strong class="source-inline">User</strong> data is as follows:</p>
			<p class="source-code">interface UserRepository {</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>Here we have an interface named <strong class="source-inline">UserRepository</strong> that is responsible for fetching the user information in a Kotlin flow.</p>
			<p>If we want to fetch data from the internet, we must first define a <strong class="source-inline">UserRemoteDataSource</strong> abstraction:</p>
			<p class="source-code">interface UserRemoteDataSource {</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>In this case, we have an interface similar to how <strong class="source-inline">UserRepository</strong> is defined with a simple method to<a id="_idIndexMarker454"/> retrieve a <strong class="source-inline">User</strong> object. We can now implement <strong class="source-inline">UserRepository</strong> to use this data source:</p>
			<p class="source-code">class UserRepositoryImpl(private val userRemoteDataSource: </p>
			<p class="source-code">    UserRemoteDataSource) : UserRepository {</p>
			<p class="source-code">   </p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        userRemoteDataSource.getUser(id)</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p>Here we have a dependency on <strong class="source-inline">UserRemoteDataSource</strong> and invoke the <strong class="source-inline">getUser</strong> method. If we want to persist the remote user data locally, we will need to define a <strong class="source-inline">UserLocalDataSource</strong> abstraction, which will be responsible for inserting the user:</p>
			<p class="source-code">interface UserLocalDataSource {</p>
			<p class="source-code">    suspend fun insertUser(user: User)</p>
			<p class="source-code">}</p>
			<p>Here we have a method for inserting a user into the local store. We can now update <strong class="source-inline">UserRepositoryImpl</strong> to connect the data sources and insert a user after it was retrieved:</p>
			<p class="source-code">class UserRepositoryImpl(</p>
			<p class="source-code">    private val userRemoteDataSource: UserRemoteDataSource,</p>
			<p class="source-code">    private val userLocalDataSource: UserLocalDataSource</p>
			<p class="source-code">) : UserRepository {</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        userRemoteDataSource.getUser(id)</p>
			<p class="source-code">        .onEach { </p>
			<p class="source-code">            userLocalDataSource.insertUser(it)</p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p>This represents a simple use case for data sources, but we can use repositories to improve the user experience for the user. For instance, we can change the repository implementation to return the <a id="_idIndexMarker455"/>saved data and have a separate method for fetching the data remotely. We can take advantage of flows, which can emit multiple users in a stream:</p>
			<p class="source-code">interface UserLocalDataSource {</p>
			<p class="source-code">    suspend fun insertUser(user: User)</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have added the <strong class="source-inline">getUser</strong> method to retrieve a <strong class="source-inline">User</strong> object, which was persisted locally. We will need to modify the repository abstraction as follows:</p>
			<p class="source-code">interface UserRepository {</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">    fun refreshUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>Here, we have added the <strong class="source-inline">refreshUser</strong> method, which, when implemented, will be responsible for fetching a new user from the internet. The implementation will be as follows:</p>
			<p class="source-code">class UserRepositoryImpl(</p>
			<p class="source-code">    private val userRemoteDataSource: UserRemoteDataSource,</p>
			<p class="source-code">    private val userLocalDataSource: UserLocalDataSource</p>
			<p class="source-code">) : UserRepository {</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        userLocalDataSource.getUser(id)</p>
			<p class="source-code">    override fun refreshUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        userRemoteDataSource.getUser(id)</p>
			<p class="source-code">        .onEach {</p>
			<p class="source-code">            userLocalDataSource.insertUser(it)</p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p>Here, we return the persisted user in the <strong class="source-inline">getUser</strong> method and, in the <strong class="source-inline">refreshUser</strong> method, we now fetch the remote data and insert it locally. If we are using libraries such as Room, this will trigger the<a id="_idIndexMarker456"/> emission of a new <strong class="source-inline">User</strong> object, which will come from <strong class="source-inline">UserLocalDataSource</strong>. This means that all subscribers of the <strong class="source-inline">getUser</strong> method will be notified of a change and receive a new <strong class="source-inline">User</strong> object. </p>
			<p>We can also use repositories for caching data in the memory. An example of this would be as follows:</p>
			<p class="source-code">class UserRepositoryImpl(</p>
			<p class="source-code">    private val userRemoteDataSource: UserRemoteDataSource,</p>
			<p class="source-code">    private val userLocalDataSource: UserLocalDataSource</p>
			<p class="source-code">) : UserRepository {</p>
			<p class="source-code">    private val usersFlow = MutableStateFlow</p>
			<p class="source-code">        (emptyMap&lt;String, User&gt;().toMutableMap())</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        usersFlow.flatMapLatest {</p>
			<p class="source-code">        val user = it[id]</p>
			<p class="source-code">        if (user != null) {</p>
			<p class="source-code">            flowOf(user)</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            userLocalDataSource.getUser(id)</p>
			<p class="source-code">                .onEach { persistedUser -&gt;</p>
			<p class="source-code">                    saveUser(persistedUser)</p>
			<p class="source-code">                }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun refreshUser(id: String): Flow&lt;User&gt; = </p>
			<p class="source-code">        userRemoteDataSource.getUser(id)</p>
			<p class="source-code">        .onEach {</p>
			<p class="source-code">            saveUser(it)</p>
			<p class="source-code">            userLocalDataSource.insertUser(it)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    private fun saveUser(user: User) {</p>
			<p class="source-code">        val map = usersFlow.value</p>
			<p class="source-code">        map[user.id] = user</p>
			<p class="source-code">        usersFlow.value = map</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we have added a new <strong class="source-inline">MutableStateFlow</strong> object, which will hold a map in which the keys are represented by the user IDs and the values are the users. In the <strong class="source-inline">getUser</strong> method, we check whether the user is stored in memory and return the memory value if present, otherwise we get the persisted data, which we will store in memory after. In the <strong class="source-inline">refreshUser</strong> method, we persist the value in memory and persist the data locally. </p>
			<p>Because we defined the repository abstraction to return entities, we should try as much as possible to use entities across the repository and the data source abstractions. However, we might need specific object definitions to handle processing the data from the data sources. We can define these specific classes in this layer and then convert them to entities in the repository<a id="_idIndexMarker457"/> implementation. </p>
			<p>In this section, we have seen how we can create repositories and how they can be used to manage data in an application. In the section that follows, we will look at an exercise in which we will create repositories for an application.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Exercise 06.01 – Creating repositories</h2>
			<p>Modify <em class="italic">Exercise 05.01: Building a domain layer</em>, so that a new library module is created in Android Studio. The module<a id="_idIndexMarker458"/> will be named <strong class="source-inline">data-repository</strong> and will have a dependency on the <strong class="source-inline">domain</strong> module. In this module, we will implement the repository classes from the domain module as follows:</p>
			<ul>
				<li><strong class="source-inline">UserRepositoryImpl</strong> will have dependencies on the following data sources: <strong class="source-inline">UserRemoteDataSource</strong>, which will fetch a list and a user by ID, and <strong class="source-inline">UserLocalDataSource</strong>, which will have methods for inserting a list of users and obtaining a list of the same. <strong class="source-inline">UserRepositoryImpl</strong> will always load the remote users and insert them locally.</li>
				<li><strong class="source-inline">PostRepositoryImpl</strong> will have dependencies on the following data sources: <strong class="source-inline">PostRemoteDataSource</strong>, which will fetch a list of users and a user by ID, and <strong class="source-inline">PostLocalDataSource</strong>, which will have methods for inserting a list of posts and obtaining a list of the same. <strong class="source-inline">PostRepositoryImpl</strong> will always load the remote posts and insert them locally.</li>
				<li><strong class="source-inline">InteractionRepositoryImpl</strong> will have a dependency on a single data source, <strong class="source-inline">LocalInteractionDataSource</strong>, which will be responsible for loading an interaction and saving it. <strong class="source-inline">InteractionRepositoryImpl</strong> will load the interaction and save a new interaction.</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ul>
				<li>Create the data repository module in Android Studio</li>
				<li>Create the user's data sources and repository</li>
				<li>Create the post's data sources and repository</li>
				<li>Create the interaction data source and repository</li>
			</ul>
			<p>Follow these steps to complete<a id="_idIndexMarker459"/> the exercise:</p>
			<ol>
				<li>Create a new module named <strong class="source-inline">data-repository</strong>, which will be an Android Library module.</li>
				<li>Make sure that in the top-level <strong class="source-inline">build.gradle</strong> file, the following dependencies are set:<p class="source-code">buildscript {</p><p class="source-code">     …</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath gradlePlugins.android</p><p class="source-code">        classpath gradlePlugins.kotlin</p><p class="source-code">        classpath gradlePlugins.hilt</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">data-repository</strong> module, make sure that the following plugins are present:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, change<a id="_idIndexMarker460"/> the configurations to the ones defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, make sure that the following dependencies are specified:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are using the <strong class="source-inline">implementation</strong> method to add a dependency to the <strong class="source-inline">:domain</strong> module, in the same way as other libraries are referenced. In Gradle we also have the option of using the <strong class="source-inline">api</strong> method. This makes a module's dependencies public to other modules. This, in turn, might have potential side effects, such as leaking<a id="_idIndexMarker461"/> dependencies that should be kept private. In this example, we might be better served by using the <strong class="source-inline">api</strong> method for the <strong class="source-inline">:domain</strong> module because of the close relationship between the two modules (which would make all modules that depend on <strong class="source-inline">:data-repository</strong> not have to add the dependency to <strong class="source-inline">:domain</strong>). However, dependencies such as Hilt and Coroutines should be kept with the implementation method because we would want to avoid exposing these libraries in modules that do not use them. </p>
			<ol>
				<li value="6">In the <strong class="source-inline">data-repository</strong> module, create a new package named <strong class="source-inline">data_source</strong>.</li>
				<li>In the <strong class="source-inline">data_source</strong> package, create a new package named <strong class="source-inline">remote</strong>.</li>
				<li>In the <strong class="source-inline">remote</strong> package, create the <strong class="source-inline">RemoteUserDataSource</strong> interface:<p class="source-code">interface RemoteUserDataSource {</p><p class="source-code">    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;</p><p class="source-code">    fun getUser(id: Long): Flow&lt;User&gt;</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">remote</strong> package, create the <strong class="source-inline">RemotePostDataSource</strong> interface:<p class="source-code">interface RemotePostDataSource {</p><p class="source-code">    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;</p><p class="source-code">    fun getPost(id: Long): Flow&lt;Post&gt;</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">data_source</strong> package, create a<a id="_idIndexMarker462"/> new package called <strong class="source-inline">local</strong>.</li>
				<li>In the <strong class="source-inline">local</strong> package, create the <strong class="source-inline">LocalUserDataSource</strong> interface:<p class="source-code">interface LocalUserDataSource {</p><p class="source-code">    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;</p><p class="source-code">    suspend fun addUsers(users: List&lt;User&gt;)</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">local</strong> package, create the <strong class="source-inline">LocalPostDataSource</strong> interface:<p class="source-code">interface LocalPostDataSource {</p><p class="source-code">    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;</p><p class="source-code">    suspend fun addPosts(posts: List&lt;Post&gt;)</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">local</strong> package, create the <strong class="source-inline">LocalInteractionDataSource</strong> package:<p class="source-code">interface LocalInteractionDataSource {</p><p class="source-code">    fun getInteraction(): Flow&lt;Interaction&gt;</p><p class="source-code">    suspend fun saveInteraction(interaction: Interaction)</p><p class="source-code">}</p></li>
				<li>Next to the <strong class="source-inline">data_source</strong> package, create<a id="_idIndexMarker463"/> a new package named <strong class="source-inline">repository</strong>.</li>
				<li>In the <strong class="source-inline">repository</strong> package, create the <strong class="source-inline">UserRepositoryImpl</strong> class:<p class="source-code">class UserRepositoryImpl @Inject constructor(</p><p class="source-code">    private val remoteUserDataSource: </p><p class="source-code">        RemoteUserDataSource,</p><p class="source-code">    private val localUserDataSource: </p><p class="source-code">        LocalUserDataSource</p><p class="source-code">) : UserRepository {</p><p class="source-code">    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = </p><p class="source-code">        remoteUserDataSource.getUsers()</p><p class="source-code">        .onEach {</p><p class="source-code">            localUserDataSource.addUsers(it)</p><p class="source-code">        }</p><p class="source-code">    override fun getUser(id: Long): Flow&lt;User&gt; = remoteUserDataSource.getUser(id)</p><p class="source-code">        .onEach {</p><p class="source-code">            localUserDataSource.addUsers(listOf(it))</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we fetch the user<a id="_idIndexMarker464"/> data from the remote data source and store it locally.</p>
			<ol>
				<li value="16">In the same package, create the <strong class="source-inline">PostRepositoryImpl</strong> class:<p class="source-code">class PostRepositoryImpl @Inject constructor(</p><p class="source-code">    private val remotePostDataSource: </p><p class="source-code">        RemotePostDataSource,</p><p class="source-code">    private val localPostDataSource: </p><p class="source-code">        LocalPostDataSource</p><p class="source-code">) : PostRepository {</p><p class="source-code">    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = </p><p class="source-code">        remotePostDataSource.getPosts()</p><p class="source-code">        .onEach {</p><p class="source-code">            localPostDataSource.addPosts(it)</p><p class="source-code">        }</p><p class="source-code">    override fun getPost(id: Long): Flow&lt;Post&gt; = </p><p class="source-code">        remotePostDataSource.getPost(id)</p><p class="source-code">        .onEach {</p><p class="source-code">            localPostDataSource.addPosts(listOf(it))</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are fetching<a id="_idIndexMarker465"/> the post data from the remote data source and using the local data source to persist the data.</p>
			<ol>
				<li value="17">In the same package, create the <strong class="source-inline">InteractionRepositoryImpl</strong> class:<p class="source-code">class InteractionRepositoryImpl @Inject constructor(</p><p class="source-code">    private val interactionDataSource: </p><p class="source-code">        LocalInteractionDataSource</p><p class="source-code">) : InteractionRepository {</p><p class="source-code">    override fun getInteraction(): Flow&lt;Interaction&gt; = </p><p class="source-code">        interactionDataSource.getInteraction()</p><p class="source-code">    override fun saveInteraction(interaction: </p><p class="source-code">       Interaction): Flow&lt;Interaction&gt; = flow {</p><p class="source-code">        interactionDataSource.saveInteraction(interaction)</p><p class="source-code">        this.emit(Unit)</p><p class="source-code">    }.flatMapLatest {</p><p class="source-code">        getInteraction()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are just interacting with the local data source to read and store the data.</p>
			<ol>
				<li value="18">We now want to use Hilt to<a id="_idIndexMarker466"/> bind the repository abstraction with the implementation, so we will need to create a package named <strong class="source-inline">injection</strong> next to the <strong class="source-inline">data_source</strong> and <strong class="source-inline">repository</strong> packages.</li>
				<li>Inside the <strong class="source-inline">injection</strong> package, create a class named <strong class="source-inline">RepositoryModule</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class RepositoryModule {</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindPostRepository(postRepositoryImpl</p><p class="source-code">        : PostRepositoryImpl): PostRepository</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindUserRepository</p><p class="source-code">        (userRepositoryImpl: UserRepositoryImpl): </p><p class="source-code">            UserRepository</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindInteractionRepository</p><p class="source-code">        (interactionRepositoryImpl: </p><p class="source-code">            InteractionRepositoryImpl): </p><p class="source-code">                InteractionRepository</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are using the <strong class="source-inline">@Binds</strong> Hilt annotation, which maps the implementation of a repository annotated with <strong class="source-inline">@Inject</strong> with the abstraction.</p>
			<ol>
				<li value="20">To unit test the code, we will now need to create a new folder called <strong class="source-inline">resources</strong> in the test <a id="_idIndexMarker467"/>folder of the <strong class="source-inline">data-repository</strong> module.</li>
				<li>Inside the resources folder, create a folder called <strong class="source-inline">mockito-extensions</strong> and, inside this folder, create a file named <strong class="source-inline">org.mockito.plugins.MockMaker</strong>, and, inside this file, add the following text: <strong class="source-inline">mock-maker-inline</strong>.</li>
				<li>Create a <strong class="source-inline">UserRepositoryImplTest</strong> class for unit testing the <strong class="source-inline">UserRepositoryImpl</strong> methods:<p class="source-code">class UserRepositoryImplTest {</p><p class="source-code">    private val remoteUserDataSource = </p><p class="source-code">        mock&lt;RemoteUserDataSource&gt;()</p><p class="source-code">    private val localUserDataSource = </p><p class="source-code">        mock&lt;LocalUserDataSource&gt;()</p><p class="source-code">    private val repositoryImpl = UserRepositoryImpl</p><p class="source-code">        (remoteUserDataSource, localUserDataSource)</p><p class="source-code">   </p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">UserRepositoryImplTest</strong> class, add a test method for each repository <a id="_idIndexMarker468"/>method:<p class="source-code">class UserRepositoryImplTest {</p><p class="source-code">     …</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUsers() = runBlockingTest {</p><p class="source-code">        val users = listOf(User(1, "name", "username", </p><p class="source-code">            "email"))</p><p class="source-code">        whenever(remoteUserDataSource.getUsers()).</p><p class="source-code">            thenReturn(flowOf(users))</p><p class="source-code">        val result = repositoryImpl.getUsers().first()</p><p class="source-code">        assertEquals(users, result)</p><p class="source-code">        verify(localUserDataSource).addUsers(users)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUser() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        val user = User(id, "name", "username", </p><p class="source-code">            "email"</p><p class="source-code">)</p><p class="source-code">        whenever(remoteUserDataSource.getUser(id))</p><p class="source-code">            .thenReturn(flowOf(user))</p><p class="source-code">        val result = repositoryImpl.getUser(id).</p><p class="source-code">            first()</p><p class="source-code">        assertEquals(user, result)</p><p class="source-code">        verify(localUserDataSource).addUsers(listOf(user))</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this class, we unit test each of the methods in the <strong class="source-inline">UserRepositoryImpl</strong> class by mocking the local<a id="_idIndexMarker469"/> data and remote data sources and verifying that the data obtained from the remote data source is inserted into the local data source.</p>
			<ol>
				<li value="24">Create a <strong class="source-inline">PostRepositoryImplTest</strong> class to test the <strong class="source-inline">PostRepositoryImpl</strong> class:<p class="source-code">class PostRepositoryImplTest {</p><p class="source-code">    private val remotePostDataSource = </p><p class="source-code">        mock&lt;RemotePostDataSource&gt;()</p><p class="source-code">    private val localPostDataSource = </p><p class="source-code">        mock&lt;LocalPostDataSource&gt;()</p><p class="source-code">    private val repositoryImpl = PostRepositoryImpl</p><p class="source-code">        (remotePostDataSource, localPostDataSource)</p><p class="source-code">}</p></li>
				<li>Create unit tests for each of the <a id="_idIndexMarker470"/>methods in the <strong class="source-inline">PostRepositoryImpl</strong> class:<p class="source-code">class PostRepositoryImplTest {</p><p class="source-code">    …</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPosts() = runBlockingTest {</p><p class="source-code">        val posts = listOf(Post(1, 1, "title", </p><p class="source-code">            "body"))</p><p class="source-code">        whenever(remotePostDataSource.getPosts())</p><p class="source-code">            .thenReturn(flowOf(posts))</p><p class="source-code">        val result = repositoryImpl.getPosts().first()</p><p class="source-code">        Assert.assertEquals(posts, result)</p><p class="source-code">        verify(localPostDataSource).addPosts(posts)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPost() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        val post = Post(id, 1, "title", "body")</p><p class="source-code">        whenever(remotePostDataSource.getPost(id)).thenReturn(flowOf(post))</p><p class="source-code">        val result = </p><p class="source-code">            repositoryImpl.getPost(id).first()</p><p class="source-code">        Assert.assertEquals(post, result)</p><p class="source-code">        verify(localPostDataSource).addPosts(listOf(post))</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this class, we perform the same tests<a id="_idIndexMarker471"/> that we did for <strong class="source-inline">UserRepositoryImpl</strong>.</p>
			<ol>
				<li value="26">Create an <strong class="source-inline">InteractionRepositoryImplTest</strong> class to test the <strong class="source-inline">InteractionRepositoryImpl</strong> class:<p class="source-code">class InteractionRepositoryImplTest {</p><p class="source-code">    private val localInteractionDataSource = </p><p class="source-code">        mock&lt;LocalInteractionDataSource&gt;()</p><p class="source-code">    private val repositoryImpl = </p><p class="source-code">        InteractionRepositoryImpl</p><p class="source-code">        (localInteractionDataSource)</p><p class="source-code">}</p></li>
				<li>Create unit tests for each of the methods in the <strong class="source-inline">InteractionRepositoryImpl</strong> class:<p class="source-code">class InteractionRepositoryImplTest {</p><p class="source-code">    …</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetInteraction() = runBlockingTest {</p><p class="source-code">        val interaction = Interaction(10)</p><p class="source-code">        whenever(localInteractionDataSource.</p><p class="source-code">            getInteraction()).</p><p class="source-code">                thenReturn(flowOf(interaction))</p><p class="source-code">        val result = repositoryImpl.getInteraction()</p><p class="source-code">            .first()</p><p class="source-code">        assertEquals(interaction, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testSaveInteraction() = runBlockingTest {</p><p class="source-code">        val interaction = Interaction(10)</p><p class="source-code">        whenever(localInteractionDataSource.</p><p class="source-code">            getInteraction()).thenReturn</p><p class="source-code">                (flowOf(interaction))</p><p class="source-code">        val result = repositoryImpl.saveInteraction</p><p class="source-code">            (interaction).first()</p><p class="source-code">        veriy(localInteractionDataSource).</p><p class="source-code">             saveInteraction(interaction)</p><p class="source-code">        assertEquals(interaction, result)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this class, we mock the local <a id="_idIndexMarker472"/>data source and then we verify that the repository has the appropriate invocations on the <strong class="source-inline">LocalInteractionDataStore</strong> mock.</p>
			<p>If we run the tests, we should see something like the following screenshot:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_6.4_B18320.jpg" alt="Figure 6.4 – Output of the repository unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Output of the repository unit tests</p>
			<p>In this exercise, we have created a new module in which we implemented our repositories and defined new abstractions for the data sources that the repositories will use. Here, we have continued the<a id="_idIndexMarker473"/> integration with other libraries, such as Hilt for dependency injection, and Kotlin flows to handle the data in a reactive approach. The use of dependency injection made the unit tests simple to write because we could easily provide mocks. </p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor081"/>Summary </h1>
			<p>In this chapter, we started looking into the data layer of an Android application and provided an overview of the components that are part of this layer. We also looked at the Repository component, which is responsible for managing the data provided by one or more data sources, and provided examples of how we could build different repositories. We also looked at the relationship between repositories and data sources and how we can further decouple the components with dependency inversion, to keep our repositories unaffected by changes in libraries used to fetch data. Finally, we looked at an exercise on how we can build repositories with local and remote data sources. In the following chapter, we will continue with the data layer and how we can integrate the remote and local data sources with libraries such as Room and Retrofit.</p>
		</div>
	</body></html>