<html><head></head><body>
		<div><h1 id="_idParaDest-72"><em class="italic"><a id="_idTextAnchor076"/>Chapter 6</em>: Assembling a Repository</h1>
			<p>In this chapter, we will begin by discussing the application's data layer and the components that make up this layer, including repositories and data sources. We will then move on to the topic of repositories, one of the application layer's components, and the role they play in managing the data of an application. In this chapter's exercise, we will continue the project started in the previous chapter by providing the repository implementations for the abstractions defined there and also introducing new abstractions for the different types of data sources. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating the data layer</li>
				<li>Creating repositories</li>
			</ul>
			<p>By the end of the chapter, you will have learned what the data layer is and how we can create repositories for an Android application.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3NpAhNs">https://bit.ly/3NpAhNs</a></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Creating the data layer</h1>
			<p>In this section, we will look at the data layer of <a id="_idIndexMarker448"/>an Android application and the components that typically form part of the data layer.</p>
			<p>The data layer is the layer in which data is created and managed. This means that this layer is responsible for creating, reading, updating, and deleting data, as well as for managing and ensuring that data from the internet is synced with persistent data. </p>
			<p>In the previous chapter, we have seen that use cases depend on an abstraction of a repository class, and there can be <a id="_idIndexMarker449"/>multiple repositories for different data types. Repositories represent the entry point into the data layer and are responsible for managing multiple data sources and centralizing the data. The data sources represent the other component of the data layer and are responsible for managing the data of a particular source (internet, Room, data store, and suchlike). </p>
			<p>An example of what the data layer for a particular set of data, which uses two data sources, might look like is shown in the following figure:</p>
			<div><div><img src="img/Figure_6.1_B18320.jpg" alt="Figure 6.1 – Data layer example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Data layer example</p>
			<p>In the preceding diagram, we have an example of what a data layer would look like when it is connected to the domain layer. We can<a id="_idIndexMarker450"/> observe that the <code>UseCase</code> class depends on a <code>Repository</code> abstraction, which represents the domain layer. The data layer is represented by <code>RepositoryImpl</code>, which is the implementation of the <code>Repository</code> abstraction. The <code>RepositoryImpl</code> class depends on the two data source implementations: <code>RemoteDataSourceImpl</code> and <code>LocalDataSourceImpl</code>. Each data source then depends on a particular implementation for managing data from the internet using Retrofit in the case of <code>RetrofitService</code>, or using a particular data access class that uses Room in the case of <code>DbDao</code>. </p>
			<p>This approach poses a problem owing to the direct dependency between <code>RepositoryImpl</code> and <code>RemoteDataSourceImpl</code>, and the problem arises when we might want to swap out Retrofit or Room for alternatives. If we might want to swap out these libraries for others, we risk changes in the <code>RepositoryImpl</code> class, which violates the single-responsibility principle. The solution for this is like the solution we had for solving the dependencies <a id="_idIndexMarker451"/>between the use cases and the repositories, and that is to invert the dependencies between the repository and the data sources. This would look like the following:</p>
			<div><div><img src="img/Figure_6.2_B18320.jpg" alt="Figure 6.2 – Data layer with inverted dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Data layer with inverted dependencies</p>
			<p>In the preceding diagram, we have introduced two abstractions for each data source, named <code>RemoteDataSource</code> and <code>LocalDataSource</code>. <code>RepositoryImpl</code> now depends on these two abstractions and all the conversions between Retrofit- or Room-related objects and domain entities should now be placed in <code>RemoteDataSourceImpl</code> or <code>LocalDataSourceImpl</code>, which inherit the new abstractions and will continue to handle the data from Retrofit or Room. If we want to split the data layer into <a id="_idIndexMarker452"/>different Gradle modules, we will have the following:</p>
			<div><div><img src="img/Figure_6.3_B18320.jpg" alt="Figure 6.3 – Data layer modules&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Data layer modules</p>
			<p>The preceding diagram shows the Gradle module dependencies between the repository and local and remote data sources. Here we can see the benefit of dependency inversion, which allows us to have a separate repository module without depending on Retrofit or Room. </p>
			<p>In this section, we have discussed the data layer and the components inside it and how to manage the dependencies between all the components. In the following section, we will take a closer look at repositories and how to implement them. </p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Creating repositories</h1>
			<p>In this section, we will look<a id="_idIndexMarker453"/> at what a repository is and the role it plays in the data layer of an application, and how we can create repositories with various data sources. </p>
			<p>The repository represents an abstraction for the data than an application uses, and it is responsible for managing and centralizing the data from one or multiple data sources.</p>
			<p>In the previous chapter, we defined the following entity:</p>
			<pre>data class User(
    val id: String,
    val firstName: String,
    val lastName: String,
    val email: String
) {
    fun getFullName() = "$firstName $lastName"
}</pre>
			<p>Here we have a simple <code>User</code> data class with a few relevant fields. The repository abstraction for the <code>User</code> data is as follows:</p>
			<pre>interface UserRepository {
    fun getUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>Here we have an interface named <code>UserRepository</code> that is responsible for fetching the user information in a Kotlin flow.</p>
			<p>If we want to fetch data from the internet, we must first define a <code>UserRemoteDataSource</code> abstraction:</p>
			<pre>interface UserRemoteDataSource {
    fun getUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>In this case, we have an interface similar to how <code>UserRepository</code> is defined with a simple method to<a id="_idIndexMarker454"/> retrieve a <code>User</code> object. We can now implement <code>UserRepository</code> to use this data source:</p>
			<pre>class UserRepositoryImpl(private val userRemoteDataSource: 
    UserRemoteDataSource) : UserRepository {
   
    override fun getUser(id: String): Flow&lt;User&gt; = 
        userRemoteDataSource.getUser(id)
    
}</pre>
			<p>Here we have a dependency on <code>UserRemoteDataSource</code> and invoke the <code>getUser</code> method. If we want to persist the remote user data locally, we will need to define a <code>UserLocalDataSource</code> abstraction, which will be responsible for inserting the user:</p>
			<pre>interface UserLocalDataSource {
    suspend fun insertUser(user: User)
}</pre>
			<p>Here we have a method for inserting a user into the local store. We can now update <code>UserRepositoryImpl</code> to connect the data sources and insert a user after it was retrieved:</p>
			<pre>class UserRepositoryImpl(
    private val userRemoteDataSource: UserRemoteDataSource,
    private val userLocalDataSource: UserLocalDataSource
) : UserRepository {
    override fun getUser(id: String): Flow&lt;User&gt; = 
        userRemoteDataSource.getUser(id)
        .onEach { 
            userLocalDataSource.insertUser(it)
        }
}</pre>
			<p>This represents a simple use case for data sources, but we can use repositories to improve the user experience for the user. For instance, we can change the repository implementation to return the <a id="_idIndexMarker455"/>saved data and have a separate method for fetching the data remotely. We can take advantage of flows, which can emit multiple users in a stream:</p>
			<pre>interface UserLocalDataSource {
    suspend fun insertUser(user: User)
    fun getUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>In the preceding example, we have added the <code>getUser</code> method to retrieve a <code>User</code> object, which was persisted locally. We will need to modify the repository abstraction as follows:</p>
			<pre>interface UserRepository {
    fun getUser(id: String): Flow&lt;User&gt;
    fun refreshUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>Here, we have added the <code>refreshUser</code> method, which, when implemented, will be responsible for fetching a new user from the internet. The implementation will be as follows:</p>
			<pre>class UserRepositoryImpl(
    private val userRemoteDataSource: UserRemoteDataSource,
    private val userLocalDataSource: UserLocalDataSource
) : UserRepository {
    override fun getUser(id: String): Flow&lt;User&gt; = 
        userLocalDataSource.getUser(id)
    override fun refreshUser(id: String): Flow&lt;User&gt; = 
        userRemoteDataSource.getUser(id)
        .onEach {
            userLocalDataSource.insertUser(it)
        }
}</pre>
			<p>Here, we return the persisted user in the <code>getUser</code> method and, in the <code>refreshUser</code> method, we now fetch the remote data and insert it locally. If we are using libraries such as Room, this will trigger the<a id="_idIndexMarker456"/> emission of a new <code>User</code> object, which will come from <code>UserLocalDataSource</code>. This means that all subscribers of the <code>getUser</code> method will be notified of a change and receive a new <code>User</code> object. </p>
			<p>We can also use repositories for caching data in the memory. An example of this would be as follows:</p>
			<pre>class UserRepositoryImpl(
    private val userRemoteDataSource: UserRemoteDataSource,
    private val userLocalDataSource: UserLocalDataSource
) : UserRepository {
    private val usersFlow = MutableStateFlow
        (emptyMap&lt;String, User&gt;().toMutableMap())
    override fun getUser(id: String): Flow&lt;User&gt; = 
        usersFlow.flatMapLatest {
        val user = it[id]
        if (user != null) {
            flowOf(user)
        } else {
            userLocalDataSource.getUser(id)
                .onEach { persistedUser -&gt;
                    saveUser(persistedUser)
                }
        }
    }
    override fun refreshUser(id: String): Flow&lt;User&gt; = 
        userRemoteDataSource.getUser(id)
        .onEach {
            saveUser(it)
            userLocalDataSource.insertUser(it)
        }
    private fun saveUser(user: User) {
        val map = usersFlow.value
        map[user.id] = user
        usersFlow.value = map
    }
}</pre>
			<p>Here, we have added a new <code>MutableStateFlow</code> object, which will hold a map in which the keys are represented by the user IDs and the values are the users. In the <code>getUser</code> method, we check whether the user is stored in memory and return the memory value if present, otherwise we get the persisted data, which we will store in memory after. In the <code>refreshUser</code> method, we persist the value in memory and persist the data locally. </p>
			<p>Because we defined the repository abstraction to return entities, we should try as much as possible to use entities across the repository and the data source abstractions. However, we might need specific object definitions to handle processing the data from the data sources. We can define these specific classes in this layer and then convert them to entities in the repository<a id="_idIndexMarker457"/> implementation. </p>
			<p>In this section, we have seen how we can create repositories and how they can be used to manage data in an application. In the section that follows, we will look at an exercise in which we will create repositories for an application.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Exercise 06.01 – Creating repositories</h2>
			<p>Modify <em class="italic">Exercise 05.01: Building a domain layer</em>, so that a new library module is created in Android Studio. The module<a id="_idIndexMarker458"/> will be named <code>data-repository</code> and will have a dependency on the <code>domain</code> module. In this module, we will implement the repository classes from the domain module as follows:</p>
			<ul>
				<li><code>UserRepositoryImpl</code> will have dependencies on the following data sources: <code>UserRemoteDataSource</code>, which will fetch a list and a user by ID, and <code>UserLocalDataSource</code>, which will have methods for inserting a list of users and obtaining a list of the same. <code>UserRepositoryImpl</code> will always load the remote users and insert them locally.</li>
				<li><code>PostRepositoryImpl</code> will have dependencies on the following data sources: <code>PostRemoteDataSource</code>, which will fetch a list of users and a user by ID, and <code>PostLocalDataSource</code>, which will have methods for inserting a list of posts and obtaining a list of the same. <code>PostRepositoryImpl</code> will always load the remote posts and insert them locally.</li>
				<li><code>InteractionRepositoryImpl</code> will have a dependency on a single data source, <code>LocalInteractionDataSource</code>, which will be responsible for loading an interaction and saving it. <code>InteractionRepositoryImpl</code> will load the interaction and save a new interaction.</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ul>
				<li>Create the data repository module in Android Studio</li>
				<li>Create the user's data sources and repository</li>
				<li>Create the post's data sources and repository</li>
				<li>Create the interaction data source and repository</li>
			</ul>
			<p>Follow these steps to complete<a id="_idIndexMarker459"/> the exercise:</p>
			<ol>
				<li>Create a new module named <code>data-repository</code>, which will be an Android Library module.</li>
				<li>Make sure that in the top-level <code>build.gradle</code> file, the following dependencies are set:<pre>buildscript {
     …
    dependencies {
        classpath gradlePlugins.android
        classpath gradlePlugins.kotlin
        classpath gradlePlugins.hilt
    }
}</pre></li>
				<li>In the <code>build.gradle</code> file of the <code>data-repository</code> module, make sure that the following plugins are present:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, change<a id="_idIndexMarker460"/> the configurations to the ones defined in the top-level <code>build.gradle</code> file:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        …
    }
    …
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
    }
}</pre></li>
				<li>In the same file, make sure that the following dependencies are specified:<pre>dependencies {
    implementation(project(path: ":domain"))
    implementation coroutines.coroutinesAndroid
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
			</ol>
			<p>Here, we are using the <code>implementation</code> method to add a dependency to the <code>:domain</code> module, in the same way as other libraries are referenced. In Gradle we also have the option of using the <code>api</code> method. This makes a module's dependencies public to other modules. This, in turn, might have potential side effects, such as leaking<a id="_idIndexMarker461"/> dependencies that should be kept private. In this example, we might be better served by using the <code>api</code> method for the <code>:domain</code> module because of the close relationship between the two modules (which would make all modules that depend on <code>:data-repository</code> not have to add the dependency to <code>:domain</code>). However, dependencies such as Hilt and Coroutines should be kept with the implementation method because we would want to avoid exposing these libraries in modules that do not use them. </p>
			<ol>
				<li value="6">In the <code>data-repository</code> module, create a new package named <code>data_source</code>.</li>
				<li>In the <code>data_source</code> package, create a new package named <code>remote</code>.</li>
				<li>In the <code>remote</code> package, create the <code>RemoteUserDataSource</code> interface:<pre>interface RemoteUserDataSource {
    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;
    fun getUser(id: Long): Flow&lt;User&gt;
}</pre></li>
				<li>In the <code>remote</code> package, create the <code>RemotePostDataSource</code> interface:<pre>interface RemotePostDataSource {
    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;
    fun getPost(id: Long): Flow&lt;Post&gt;
}</pre></li>
				<li>In the <code>data_source</code> package, create a<a id="_idIndexMarker462"/> new package called <code>local</code>.</li>
				<li>In the <code>local</code> package, create the <code>LocalUserDataSource</code> interface:<pre>interface LocalUserDataSource {
    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;
    suspend fun addUsers(users: List&lt;User&gt;)
}</pre></li>
				<li>In the <code>local</code> package, create the <code>LocalPostDataSource</code> interface:<pre>interface LocalPostDataSource {
    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;
    suspend fun addPosts(posts: List&lt;Post&gt;)
}</pre></li>
				<li>In the <code>local</code> package, create the <code>LocalInteractionDataSource</code> package:<pre>interface LocalInteractionDataSource {
    fun getInteraction(): Flow&lt;Interaction&gt;
    suspend fun saveInteraction(interaction: Interaction)
}</pre></li>
				<li>Next to the <code>data_source</code> package, create<a id="_idIndexMarker463"/> a new package named <code>repository</code>.</li>
				<li>In the <code>repository</code> package, create the <code>UserRepositoryImpl</code> class:<pre>class UserRepositoryImpl @Inject constructor(
    private val remoteUserDataSource: 
        RemoteUserDataSource,
    private val localUserDataSource: 
        LocalUserDataSource
) : UserRepository {
    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = 
        remoteUserDataSource.getUsers()
        .onEach {
            localUserDataSource.addUsers(it)
        }
    override fun getUser(id: Long): Flow&lt;User&gt; = remoteUserDataSource.getUser(id)
        .onEach {
            localUserDataSource.addUsers(listOf(it))
        }
}</pre></li>
			</ol>
			<p>Here, we fetch the user<a id="_idIndexMarker464"/> data from the remote data source and store it locally.</p>
			<ol>
				<li value="16">In the same package, create the <code>PostRepositoryImpl</code> class:<pre>class PostRepositoryImpl @Inject constructor(
    private val remotePostDataSource: 
        RemotePostDataSource,
    private val localPostDataSource: 
        LocalPostDataSource
) : PostRepository {
    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = 
        remotePostDataSource.getPosts()
        .onEach {
            localPostDataSource.addPosts(it)
        }
    override fun getPost(id: Long): Flow&lt;Post&gt; = 
        remotePostDataSource.getPost(id)
        .onEach {
            localPostDataSource.addPosts(listOf(it))
        }
}</pre></li>
			</ol>
			<p>Here, we are fetching<a id="_idIndexMarker465"/> the post data from the remote data source and using the local data source to persist the data.</p>
			<ol>
				<li value="17">In the same package, create the <code>InteractionRepositoryImpl</code> class:<pre>class InteractionRepositoryImpl @Inject constructor(
    private val interactionDataSource: 
        LocalInteractionDataSource
) : InteractionRepository {
    override fun getInteraction(): Flow&lt;Interaction&gt; = 
        interactionDataSource.getInteraction()
    override fun saveInteraction(interaction: 
       Interaction): Flow&lt;Interaction&gt; = flow {
        interactionDataSource.saveInteraction(interaction)
        this.emit(Unit)
    }.flatMapLatest {
        getInteraction()
    }
}</pre></li>
			</ol>
			<p>Here, we are just interacting with the local data source to read and store the data.</p>
			<ol>
				<li value="18">We now want to use Hilt to<a id="_idIndexMarker466"/> bind the repository abstraction with the implementation, so we will need to create a package named <code>injection</code> next to the <code>data_source</code> and <code>repository</code> packages.</li>
				<li>Inside the <code>injection</code> package, create a class named <code>RepositoryModule</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindPostRepository(postRepositoryImpl
        : PostRepositoryImpl): PostRepository
    @Binds
    abstract fun bindUserRepository
        (userRepositoryImpl: UserRepositoryImpl): 
            UserRepository
    @Binds
    abstract fun bindInteractionRepository
        (interactionRepositoryImpl: 
            InteractionRepositoryImpl): 
                InteractionRepository
}</pre></li>
			</ol>
			<p>Here, we are using the <code>@Binds</code> Hilt annotation, which maps the implementation of a repository annotated with <code>@Inject</code> with the abstraction.</p>
			<ol>
				<li value="20">To unit test the code, we will now need to create a new folder called <code>resources</code> in the test <a id="_idIndexMarker467"/>folder of the <code>data-repository</code> module.</li>
				<li>Inside the resources folder, create a folder called <code>mockito-extensions</code> and, inside this folder, create a file named <code>org.mockito.plugins.MockMaker</code>, and, inside this file, add the following text: <code>mock-maker-inline</code>.</li>
				<li>Create a <code>UserRepositoryImplTest</code> class for unit testing the <code>UserRepositoryImpl</code> methods:<pre>class UserRepositoryImplTest {
    private val remoteUserDataSource = 
        mock&lt;RemoteUserDataSource&gt;()
    private val localUserDataSource = 
        mock&lt;LocalUserDataSource&gt;()
    private val repositoryImpl = UserRepositoryImpl
        (remoteUserDataSource, localUserDataSource)
   
}</pre></li>
				<li>In the <code>UserRepositoryImplTest</code> class, add a test method for each repository <a id="_idIndexMarker468"/>method:<pre>class UserRepositoryImplTest {
     …
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUsers() = runBlockingTest {
        val users = listOf(User(1, "name", "username", 
            "email"))
        whenever(remoteUserDataSource.getUsers()).
            thenReturn(flowOf(users))
        val result = repositoryImpl.getUsers().first()
        assertEquals(users, result)
        verify(localUserDataSource).addUsers(users)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUser() = runBlockingTest {
        val id = 1L
        val user = User(id, "name", "username", 
            "email"
)
        whenever(remoteUserDataSource.getUser(id))
            .thenReturn(flowOf(user))
        val result = repositoryImpl.getUser(id).
            first()
        assertEquals(user, result)
        verify(localUserDataSource).addUsers(listOf(user))
    }
}</pre></li>
			</ol>
			<p>In this class, we unit test each of the methods in the <code>UserRepositoryImpl</code> class by mocking the local<a id="_idIndexMarker469"/> data and remote data sources and verifying that the data obtained from the remote data source is inserted into the local data source.</p>
			<ol>
				<li value="24">Create a <code>PostRepositoryImplTest</code> class to test the <code>PostRepositoryImpl</code> class:<pre>class PostRepositoryImplTest {
    private val remotePostDataSource = 
        mock&lt;RemotePostDataSource&gt;()
    private val localPostDataSource = 
        mock&lt;LocalPostDataSource&gt;()
    private val repositoryImpl = PostRepositoryImpl
        (remotePostDataSource, localPostDataSource)
}</pre></li>
				<li>Create unit tests for each of the <a id="_idIndexMarker470"/>methods in the <code>PostRepositoryImpl</code> class:<pre>class PostRepositoryImplTest {
    …
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPosts() = runBlockingTest {
        val posts = listOf(Post(1, 1, "title", 
            "body"))
        whenever(remotePostDataSource.getPosts())
            .thenReturn(flowOf(posts))
        val result = repositoryImpl.getPosts().first()
        Assert.assertEquals(posts, result)
        verify(localPostDataSource).addPosts(posts)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPost() = runBlockingTest {
        val id = 1L
        val post = Post(id, 1, "title", "body")
        whenever(remotePostDataSource.getPost(id)).thenReturn(flowOf(post))
        val result = 
            repositoryImpl.getPost(id).first()
        Assert.assertEquals(post, result)
        verify(localPostDataSource).addPosts(listOf(post))
    }
}</pre></li>
			</ol>
			<p>In this class, we perform the same tests<a id="_idIndexMarker471"/> that we did for <code>UserRepositoryImpl</code>.</p>
			<ol>
				<li value="26">Create an <code>InteractionRepositoryImplTest</code> class to test the <code>InteractionRepositoryImpl</code> class:<pre>class InteractionRepositoryImplTest {
    private val localInteractionDataSource = 
        mock&lt;LocalInteractionDataSource&gt;()
    private val repositoryImpl = 
        InteractionRepositoryImpl
        (localInteractionDataSource)
}</pre></li>
				<li>Create unit tests for each of the methods in the <code>InteractionRepositoryImpl</code> class:<pre>class InteractionRepositoryImplTest {
    …
    @ExperimentalCoroutinesApi
    @Test
    fun testGetInteraction() = runBlockingTest {
        val interaction = Interaction(10)
        whenever(localInteractionDataSource.
            getInteraction()).
                thenReturn(flowOf(interaction))
        val result = repositoryImpl.getInteraction()
            .first()
        assertEquals(interaction, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testSaveInteraction() = runBlockingTest {
        val interaction = Interaction(10)
        whenever(localInteractionDataSource.
            getInteraction()).thenReturn
                (flowOf(interaction))
        val result = repositoryImpl.saveInteraction
            (interaction).first()
        veriy(localInteractionDataSource).
             saveInteraction(interaction)
        assertEquals(interaction, result)
    }
}</pre></li>
			</ol>
			<p>In this class, we mock the local <a id="_idIndexMarker472"/>data source and then we verify that the repository has the appropriate invocations on the <code>LocalInteractionDataStore</code> mock.</p>
			<p>If we run the tests, we should see something like the following screenshot:</p>
			<div><div><img src="img/Figure_6.4_B18320.jpg" alt="Figure 6.4 – Output of the repository unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Output of the repository unit tests</p>
			<p>In this exercise, we have created a new module in which we implemented our repositories and defined new abstractions for the data sources that the repositories will use. Here, we have continued the<a id="_idIndexMarker473"/> integration with other libraries, such as Hilt for dependency injection, and Kotlin flows to handle the data in a reactive approach. The use of dependency injection made the unit tests simple to write because we could easily provide mocks. </p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor081"/>Summary </h1>
			<p>In this chapter, we started looking into the data layer of an Android application and provided an overview of the components that are part of this layer. We also looked at the Repository component, which is responsible for managing the data provided by one or more data sources, and provided examples of how we could build different repositories. We also looked at the relationship between repositories and data sources and how we can further decouple the components with dependency inversion, to keep our repositories unaffected by changes in libraries used to fetch data. Finally, we looked at an exercise on how we can build repositories with local and remote data sources. In the following chapter, we will continue with the data layer and how we can integrate the remote and local data sources with libraries such as Room and Retrofit.</p>
		</div>
	</body></html>