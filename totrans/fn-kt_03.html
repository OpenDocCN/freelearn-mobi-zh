<html><head></head><body>
        

                            
                    <h1 class="header-title">Immutability - It's Important</h1>
                
            
            
                
<p>So, we are in the third chapter of, <em>Functional Kotlin</em>. In this chapter, we are going to discuss immutability. Immutability is probably the most important aspect of functional programming; actually, not only in functional programming, but OOP also gives some room to nurture immutability with immutable objects. So, why is it so important? What does it mean? How can we implement immutability in Kotlin? Let's answer these questions in this chapter.</p>
<p>The following are the points we are going to cover in this chapter:</p>
<ul>
<li>What is immutability?</li>
<li>The advantages of immutability</li>
<li>How to implement immutability in Kotlin?</li>
<li>Immutability in variables</li>
<li><kbd>val</kbd> versus <kbd>var</kbd></li>
<li><kbd>val</kbd> and <kbd>const val</kbd>—are they truly immutable?</li>
<li>Compiler optimization</li>
<li>Immutable collections</li>
<li>The disadvantages of immutability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is immutability?</h1>
                
            
            
                
<p>Functional programming, by its nature, is thread safe; immutability has a great role in making it thread safe. If you go by the dictionary definition, <strong>immutability</strong> means that something is unchangeable. So, as per the dictionary, an <strong>immutable variable</strong> is a variable that cannot change. Now, how can that be of any help to thread safety?</p>
<p>The following example shows a simple class, with no extra protective measures for thread safety:</p>
<pre>class MutableObject { 
    var mutableProperty:Int = 1 
} </pre>
<p>Just think of a situation when you're calling this class from multiple threads at the same time. There is no guarantee of integrity in this, right?</p>
<p>Now, imagine making <kbd>mutableProperty</kbd> immutable; the problem is partly solved, right?</p>
<p>However, if you think of immutability as creating a class and making all its variables read-only, then such a simplified explanation would not only be wrong, but would also be horrible. Actually, immutability is not about forbidding change, but about handling change. Instead of changing the underlying value of a property directly, create a new property and copy the value with applied changes. This applies to things such as the primitive data types in Kotlin and Java (or even in C). For instance, in the following example, when we're writing <kbd>var y = x.capitalize()</kbd>, the value of <kbd>x</kbd> remains unchanged, instead the <kbd>x</kbd> value is copied to <kbd>y</kbd> with applied changes:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    var x:String = "abc" 
    var y = x.capitalize() 
    println("x = $x, y = $y") 
} </pre>
<p>Most of the primitive types operate in the same way; that is what is called <strong>immutability</strong>. Now, let's see how can we implement immutability in Kotlin and then, we will have a look at its advantages and disadvantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing immutability in Kotlin</h1>
                
            
            
                
<p>Unlike Clojure, Haskell, F#, and the likes, Kotlin is not a pure functional programming language, where immutability is forced; rather, we may refer to Kotlin as a perfect blend of functional programming and OOP languages. It contains the major benefits of both worlds. So, instead of forcing immutability like pure functional programming languages, Kotlin encourages immutability, giving it automatic preference wherever possible.</p>
<p>In other words, Kotlin has immutable variables (<kbd>val</kbd>), but no language mechanisms that would guarantee true deep immutability of the state. If a <kbd>val</kbd> variable references a mutable object, its contents can still be modified. We will have a more elaborate discussion and a deeper dive on this topic, but first let us have a look at how we can get referential immutability in Kotlin and the differences between <kbd>var</kbd>, <kbd>val</kbd>, and <kbd>const val</kbd>.</p>
<p>By true deep immutability of the state, we mean a property will always return the same value whenever it is called and that the property never changes its value; we can easily avoid this if we have a <kbd>val</kbd>  property that has a custom getter. You can find more details at the following link: <a href="https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/">https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The difference between var and val</h1>
                
            
            
                
<p>So, in order to encourage immutability but still let the developers have the choice, Kotlin introduced two types of variables. The first one is <kbd>var</kbd>, which is just a simple variable, just like in any imperative language. On the other hand, <kbd>val</kbd> brings us a bit closer to immutability; again, it doesn't guarantee immutability. So, what exactly does the <kbd>val</kbd> variable provide us? It enforces read-only, you cannot write into a <kbd>val</kbd> variable after initialization. So, if you use a <kbd>val</kbd> variable without a custom getter, you can achieve referential immutability.</p>
<p>Let's have a look; the following program will not compile:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val x:String = "Kotlin" 
    x+="Immutable"//(1) 
} </pre>
<p>As I mentioned earlier, the preceding program will not compile; it will give an error on comment <kbd>(1)</kbd>. As we've declared variable <kbd>x</kbd> as <kbd>val</kbd>, <kbd>x</kbd> will be read-only and once we initialize <kbd>x</kbd>; we cannot modify it afterwards.</p>
<p>So, now you're probably asking why we cannot guarantee immutability with <kbd>val</kbd> ? Let's inspect this with the following example:</p>
<pre>object MutableVal { 
    var count = 0 
    val myString:String = "Mutable" 
        get() {//(1) 
            return "$field ${++count}"//(2) 
        } 
} 
 
fun main(args: Array&lt;String&gt;) { 
    println("Calling 1st time ${MutableVal.myString}") 
    println("Calling 2nd time ${MutableVal.myString}") 
    println("Calling 3rd time ${MutableVal.myString}")//(3) 
} </pre>
<p>In this program, we declared <kbd>myString</kbd> as a <kbd>val</kbd> property, but implemented a custom <kbd>get</kbd> function, where we tweaked the value of <kbd>myString</kbd> before returning it. Have a look at the output first, then we will further look into the program:</p>
<div><img height="127" width="367" src="img/252f866a-6301-4199-a212-ef1396d1f3a2.png"/></div>
<p>As you can see, the <kbd>myString</kbd> property, despite being <kbd>val</kbd>, returned different values every time we accessed it. So, now, let us look into the code to understand such behavior.</p>
<p>On comment <kbd>(1)</kbd>, we declared a custom getter for the <kbd>val</kbd> property <kbd>myString</kbd>. On comment <kbd>(2)</kbd>, we pre-incremented the value of <kbd>count</kbd> and added it after the value of the <kbd>field</kbd> value, <kbd>myString</kbd>, and returned the same from the getter. So, whenever we requested the <kbd>myString</kbd> property, <kbd>count</kbd> got incremented and, on the next request, we got a different value. As a result, we broke the immutable behavior of a <kbd>val</kbd> property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compile time constants</h1>
                
            
            
                
<p>So, how can we overcome this? How can we enforce immutability? The <kbd>const val</kbd> properties are here to help us. Just modify <kbd>val myString</kbd> with <kbd>const val myString</kbd> and you cannot implement the custom getter.</p>
<p>While <kbd>val</kbd> properties are read-only variables, <kbd>const val</kbd> on the other hand are compile time constants. You cannot assign the outcome (result) of a function to <kbd>const val</kbd>. Let's discuss some of the differences between <kbd>val</kbd> and <kbd>const val</kbd>:</p>
<ul>
<li>The <kbd>val</kbd> properties are read-only variables, while <kbd>const val</kbd> are compile time constants</li>
<li>The <kbd>val</kbd> properties can have custom getters, but <kbd>const val</kbd> cannot</li>
<li>We can have <kbd>val</kbd> properties anywhere in our Kotlin code, inside functions, as a class member, anywhere, but <kbd>const val</kbd> has to be a top-level member of a class/object</li>
<li>You cannot write delegates for the <kbd>const val</kbd> properties</li>
<li>We can have the <kbd>val</kbd> property of any type, be it our custom class or any primitive data type, but only primitive data types and <kbd>String</kbd> are allowed with a <kbd>const val</kbd> property</li>
<li>We cannot have nullable data types with the <kbd>const val</kbd> properties; as a result, we cannot have null values for the <kbd>const val</kbd> properties either</li>
</ul>
<p>As a result, the <kbd>const val</kbd> properties guarantee immutability of value, but have lesser flexibility and you are bound to use only primitive data types with <kbd>const val</kbd>, which cannot always serve our purposes.</p>
<p>Now, that I've used the word <em>referential immutability</em> quite a few times, let us now inspect what it means and how many types of immutability there are.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of immutability</h1>
                
            
            
                
<p>There are basically the following two types of immutability:</p>
<ul>
<li>Referential immutability</li>
<li>Immutable values</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Immutable reference  (referential immutability)</h1>
                
            
            
                
<p><strong>Referential immutability</strong> enforces that, once a reference is assigned, it can't be assigned to something else. Think of having it as a <kbd>val</kbd> property of a custom class, or even <kbd>MutableList</kbd> or <kbd>MutableMap</kbd>; after you initialize the property, you cannot reference something else from that property, except the underlying value from the object. For example, take the following program:</p>
<pre>class MutableObj { 
    var value = "" 
 
    override fun toString(): String { 
        return "MutableObj(value='$value')" 
    } 
} 
 
fun main(args: Array&lt;String&gt;) { 
    val mutableObj:MutableObj = MutableObj()//(1) 
    println("MutableObj $mutableObj") 
    mutableObj.value = "Changed"//(2) 
    println("MutableObj $mutableObj") 
 
    val list = mutableListOf("a","b","c","d","e")//(3) 
    println(list) 
    list.add("f")//(4) 
    println(list) 
} </pre>
<p>Have a look at the output before we proceed with explaining the program:</p>
<div><img height="137" width="371" src="img/23651ee2-2e8c-42e0-98f7-d2b7d2b64777.png"/></div>
<p>So, in this program we've two <kbd>val</kbd> properties—<kbd>list</kbd> and <kbd>mutableObj</kbd>. We initialized <kbd>mutableObj</kbd> with the default constructor of <kbd>MutableObj</kbd>, since it's a <kbd>val</kbd> property it'll always refer to that specific object; but, if you concentrate on comment <kbd>(2)</kbd>, we changed the <kbd>value</kbd> property of <kbd>mutableObj</kbd>, as the <kbd>value</kbd> property of the <kbd>MutableObj</kbd> class is mutable (<kbd>var</kbd>).</p>
<p>It's the same with the <kbd>list</kbd> property, we can add items to the list after initialization, changing its underlying value. Both <kbd>list</kbd> and <kbd>mutableObj</kbd> are perfect examples of immutable reference; once initialized, the properties can't be assigned to something else, but their underlying values can be changed (you can refer the output). The reason behind that is the data type we used to assign to those properties. Both the <kbd>MutableObj</kbd> class and the <kbd>MutableList&lt;String&gt;</kbd> data structures are mutable themselves, so we cannot restrict value changes for their instances.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immutable values</h1>
                
            
            
                
<p>The <strong>immutable values</strong>, on the other hand, enforce no change on values as well; it is really complex to maintain. In Kotlin, the <kbd>const val</kbd> properties enforces immutability of value, but they lack flexibility (we already discussed them) and you're bound to use only primitive types, which can be troublesome in real-life scenarios.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immutable collections</h1>
                
            
            
                
<p>Kotlin gives preference to immutability wherever possible, but leaves the choice to the developer whether or when to use it. This power of choice makes the language even more powerful. Unlike most languages, where they have either only mutable (like Java, C#, and so on) or only immutable collections (like F#, Haskell, Clojure, and so on), Kotlin has both and distinguishes between them, leaving the developer with the freedom to choose whether to use an immutable or mutable one.</p>
<p>Kotlin has two interfaces for collection objects—<kbd>Collection&lt;out E&gt;</kbd> and <kbd>MutableCollection&lt;out E&gt;</kbd>; all the collection classes (for example, <kbd>List</kbd>, <kbd>Set</kbd>, or <kbd>Map</kbd>) implement either of them. As the name suggests, the two interfaces are designed to serve immutable and mutable collections respectively. Let us have an example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val immutableList = listOf(1,2,3,4,5,6,7)//(1) 
    println("Immutable List $immutableList") 
    val mutableList:MutableList&lt;Int&gt; = immutableList.toMutableList()//(2) 
    println("Mutable List $mutableList") 
    mutableList.add(8)//(3) 
    println("Mutable List after add $mutableList") 
    println("Mutable List after add $immutableList") 
} </pre>
<p>The output is as follows:</p>
<div><img height="141" width="370" src="img/d50cd60d-e688-4025-9783-28ae0ed4a38f.png"/></div>
<p>So, in this program, we created an immutable list with the help of the <kbd>listOf</kbd> method of Kotlin, on comment <kbd>(1)</kbd>. The <kbd>listOf</kbd> method creates an immutable list with the elements (<kbd>varargs</kbd>) passed to it. This method also has a generic type parameter, which can be skipped if the elements array is not empty. The <kbd>listOf</kbd> method also has a mutable version—<kbd>mutableListOf()</kbd> which is identical except that it returns <kbd>MutableList</kbd> instead. We can convert an immutable list to a mutable one with the help of the <kbd>toMutableList()</kbd> extension function, we did the same in comment <kbd>(2)</kbd>, to add an element to it on comment <kbd>(3)</kbd>. However, if you check the output, the original <kbd>Immutable List</kbd> remains the same without any changes, the item is, however, added to the newly created <kbd>MutableList</kbd> instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The advantages of immutability</h1>
                
            
            
                
<p>We've mentioned several times that immutability brings safety along with it. But that's not all; the following is a brief list of advantages that immutability brings with it, we will discuss them one by one:</p>
<ul>
<li>Thread safety</li>
<li>Low coupling</li>
<li>Referential transparency</li>
<li>Failure atomicity</li>
<li>Compiler optimization</li>
<li>Pure functions</li>
</ul>
<p>Let us now discuss each of the advantages to understand them better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread safety</h1>
                
            
            
                
<p>We have probably seen a thousand times that immutability brings thread safety to the table along with it. What does it actually mean and how does immutability achieve thread safety? Working with multiple threads is itself a complex job. When you are accessing a class from multiple threads, you need to ensure certain things, like locking and releasing of the object and synchronization, but none of them are required if you are accessing any immutable data from multiple threads.</p>
<p>Confused? Let's have an example with threads and mutable data:</p>
<pre>class MyData { 
    var someData:Int = 0 
} 
 
fun main(args: Array&lt;String&gt;) { 
    val myData:MyData = MyData() 
 
    async(CommonPool) { 
        for(i in 11..20) { 
            myData.someData+=i 
            println("someData from 1st async ${myData.someData}") 
            delay(500) 
        } 
    } 
 
    async(CommonPool) { 
        for(i in 1..10) { 
            myData.someData++ 
            println("someData from 2nd async ${myData.someData}") 
            delay(300) 
        } 
    } 
 
    runBlocking { delay(10000) } 
} </pre>
<p>In this program, we've used two coroutines (we will cover coroutines in detail in <a href="cf296fd7-ee56-4fac-8078-c97779111daf.xhtml">Chapter 7</a>, <em>Asynchronous Processing with Coroutines</em>) which works on the same mutable data. Let's have a look in the following output and then we will describe and discuss the problems in this program:</p>
<div><img height="459" width="376" src="img/b7855232-3fee-4080-b075-5a30ee5b2071.png"/></div>
<p>So, look closely at the output. As both the coroutines works simultaneously on <kbd>myData.someData</kbd>, data consistency is not ensured in either one.</p>
<p>The traditional solution to this problem is to use locking-releasing techniques and synchronization, but then also you'll need to write a lot of code for that and to avoid deadlock while implementing locking and releasing of data.</p>
<p>Functional programming provides a one-stop solution to this problem through immutability. Let's have a look how immutability and local variables can save you in multithreading:</p>
<pre>class MyDataImmutable { 
    val someData:Int = 0 
} 
 
fun main(args: Array&lt;String&gt;) { 
    val myData: MyDataImmutable = MyDataImmutable() 
 
    async(CommonPool) { 
        var someDataCopy = myData.someData 
        for (i in 11..20) { 
            someDataCopy += i 
            println("someData from 1st async $someDataCopy") 
            delay(500) 
        } 
    } 
 
    async(CommonPool) { 
        var someDataCopy = myData.someData 
        for (i in 1..10) { 
            someDataCopy++ 
            println("someData from 2nd async $someDataCopy") 
            delay(300) 
        } 
    } 
 
    runBlocking { delay(10000) } 
} </pre>
<p>We've modified the previous program to make <kbd>someData</kbd> immutable (as we're not using custom getter with this variable, so it will remain immutable) and used local variables inside both the coroutines.</p>
<p>Have a look at the following output; it clearly shows that the problem is solved:</p>
<div><img height="375" width="307" src="img/5e4db5ac-0ef5-4026-8ca3-57d4b2519242.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Low coupling</h1>
                
            
            
                
<p>The code dependency between threads is referred to as coupling. We should try to keep coupling as low as possible, to avoid complexity and make the code base easy to read and maintain. Now, what does that actually mean? Refer to the program with threading where we accessed and modified the <kbd>someData</kbd> value from two threads simultaneously. That can be called <strong>coupling</strong>, as both the threads were dependent on each other. For your reference, we copied the following code-snippet:</p>
<pre>async(CommonPool) { 
        for(i in 11..20) { 
            myData.someData+=i 
            println("someData from 1st async ${myData.someData}") 
            delay(500) 
        } 
    } 
 
    async(CommonPool) { 
        for(i in 1..10) { 
            myData.someData++ 
            println("someData from 2nd async ${myData.someData}") 
            delay(300) 
        } 
    } </pre>
<p>In the next program, where we introduced immutability, the coupling is reduced. Here, both the threads were reading the same element, but one thread's operations and changes didn't affect the other one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Referential transparency</h1>
                
            
            
                
<p>The concept of <strong>referential transparency</strong> says that, an expression always evaluates to the same value, irrespective of context or any other variance. To be more specific, you can replace a function with its return value.</p>
<p>Immutability, with help of pure functions, can establish referential transparency. Referential transparency strongly denies the mutable state of data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Failure atomicity</h1>
                
            
            
                
<p>In traditional programming, failure in one thread can easily affect the other one. As immutability enforces low coupling, the internal state of the application will be consistent, even when we have exceptions on any module/thread.</p>
<p>The reason is simple, the immutable objects never change state. So, even if failure occurs in one part/module/thread, it stops right there and doesn't get any chance to get spread to other parts of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Caching</h1>
                
            
            
                
<p>As immutable objects are not going to change, they can be easily cached to improve performance. Thus, you can easily avoid making multiple calls to the same function/variable and, instead, cache it locally and save an ample amount of processing time. The following are some of the advantages of caching:</p>
<ul>
<li>It reduces the overhead from server resources</li>
<li>It increases the performance of the application by serving it with the cached output</li>
<li>It decreases CPU round trips for fetching data from the database by persisting data in the memory</li>
<li>It increases reliability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiler optimization</h1>
                
            
            
                
<p>Immutability and referential transparency help compilers to perform extensive optimizations, replacing the need of manual optimization of code and free programmers from this trade-off.</p>
<p>For example, this applies when you're using compile time constants (<kbd>const val</kbd>), as the compiler knows that the value of those variables will never change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pure functions</h1>
                
            
            
                
<p>Probably the biggest gift we can get by using immutability are the <em>pure functions</em> (covered in the next chapter). Basically, pure functions and immutability are not only companions, but are complimentary to each other.</p>
<p>We cannot implement pure functions without immutability and immutability isn't complete without pure functions.</p>
<p>So, as we've learned a lot about immutability and its advantages, let us now focus on the other side: the disadvantages of immutability and check if they truly are disadvantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The disadvantages of immutability</h1>
                
            
            
                
<p>Nothing in the world comes only with advantages.</p>
<p>There's a great proverb: everything comes at its own price.</p>
<p>The only thing you can hear against immutability is that you need to create a new object every time you want to modify it. That's true in some scenarios, especially where you're working with large sets of objects. However, when you are working with small datasets or objects, it doesn't have any effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about immutability and how to implement immutability with Kotlin. We learned that Kotlin provides us with the freedom to choose between immutability or mutable objects, based on our requirements. We not only discussed the advantages of immutability, but talked about its limitations as well.</p>
<p>The next chapter focuses on function, function types, and side effects. We will also learn about pure functions, which are not only a companion but a complimentary part of immutability, in the next chapter.</p>
<p>So what are you waiting for? Turn the page right now.</p>


            

            
        
    </body></html>