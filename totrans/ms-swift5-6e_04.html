<html><head></head><body>
  <div id="_idContainer046">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-69" class="chapterTitle">Optional Types</h1>
    <p class="normal">When I first started using Swift, the concept that I had the most trouble understanding was optional types. Coming from an Objective-C, C, Java, and Python background, I was able to relate most of Swift's features to how things worked in one of the other languages that I knew, but optionals were different. When Swift was first announced, there was really nothing like optionals in the other languages that I used, so it took a lot of reading to fully understand them.</p>
    <p class="normal">In this chapter, we will cover the following topics: </p>
    <ul>
      <li class="bullet">What are optional types?</li>
      <li class="bullet">Why do we need optional types in Swift?</li>
      <li class="bullet">How to unwrap an optional</li>
      <li class="bullet">What is optional binding?</li>
      <li class="bullet">What is optional chaining?</li>
    </ul>
    <h1 id="_idParaDest-70" class="title">Introducing optionals</h1>
    <p class="normal">When we <a id="_idIndexMarker166"/>declare variables in Swift, they are by default non-optional, which means that they must contain a valid, non-nil value. If we try to set a non-optional variable to <code class="Code-In-Text--PACKT-">nil</code>, it will result in an error.</p>
    <p class="normal">For example, the following code will throw an error when we attempt to set the <code class="Code-In-Text--PACKT-">message</code> variable to <code class="Code-In-Text--PACKT-">nil</code> because it is a non-optional type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> message: <span class="hljs-type">String</span> = <span class="hljs-string">"My String"</span> 
message = <span class="hljs-literal">nil</span>
</code></pre>
    <p class="normal">It is very important to understand that <code class="Code-In-Text--PACKT-">nil</code> in Swift is very different from <code class="Code-In-Text--PACKT-">nil</code> in Objective-C or other C-based languages. In these languages, <code class="Code-In-Text--PACKT-">nil</code> is a pointer to a non-existent object; however, in Swift, a <code class="Code-In-Text--PACKT-">nil</code> value is the absence of a value. Grasping this concept is very important in order to fully understand optionals in Swift.</p>
    <p class="normal">A variable defined as an optional can contain a valid value, or it can indicate the absence of a value. We indicate the absence of a value by assigning it a special <code class="Code-In-Text--PACKT-">nil</code> value. Optionals of any type can be set to <code class="Code-In-Text--PACKT-">nil</code>, whereas in Objective-C, only objects can be set to <code class="Code-In-Text--PACKT-">nil</code>.</p>
    <p class="normal">To really understand the concept behind optionals, let's look at a line of code that defines an optional:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString: <span class="hljs-type">String?</span>
</code></pre>
    <p class="normal">The question mark at the end indicates that the <code class="Code-In-Text--PACKT-">myString</code> variable is an optional. We read this line of code as saying that the <code class="Code-In-Text--PACKT-">myString</code> variable is an optional type, which may contain a value of the <code class="Code-In-Text--PACKT-">string</code> type or may contain no value. How this line is written is very important in understanding how optionals work.</p>
    <p class="normal">Optionals are <a id="_idIndexMarker167"/>a special type in Swift. When we defined the <code class="Code-In-Text--PACKT-">myString</code> variable, we actually defined it as an optional type. To understand this, let's look at some more code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString1: <span class="hljs-type">String?</span>
<span class="hljs-keyword">var</span> myString2: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">String</span>&gt;
</code></pre>
    <p class="normal">These two declarations are equivalent. Both lines declare an optional type that may contain a<code class="Code-In-Text--PACKT-">Sstring</code> type or may lack a value. In Swift, we can think of the absence of a value as being set to nil, but always remember that this is different than setting something to nil in Objective-C. In this book, when we refer to nil, we are referring to how Swift uses nil and not how Objective-C uses nil.</p>
    <p class="normal">The optional type is an enumeration with two possible values, <code class="Code-In-Text--PACKT-">None</code> and <code class="Code-In-Text--PACKT-">Some(T)</code>, where <code class="Code-In-Text--PACKT-">T</code> is the generic associated value of the appropriate type. We will discuss generics in <em class="chapterRef">Chapter 11</em>, <em class="italic">Generics</em>. If we set the optional to <code class="Code-In-Text--PACKT-">nil</code>, it will have a value of <code class="Code-In-Text--PACKT-">None</code>, and if we set a value, the optional will have a value of <code class="Code-In-Text--PACKT-">Some</code> with an associated value of the appropriate type. In <em class="chapterRef">Chapter 3</em>, <em class="italic">Learning about Variables, Constants, Strings, and Operators</em>, we explained that an enumeration in Swift might have associated values. Associated values allow us to store additional information along with the enumeration's member values.</p>
    <p class="normal">Internally, an optional is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">Optional</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt;</span>
{
<span class="hljs-keyword">    case</span> <span class="hljs-type">None</span>
<span class="hljs-keyword">    case</span> <span class="hljs-type">Some</span>(<span class="hljs-type">T</span>)
}
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">T</code> is the <a id="_idIndexMarker168"/>type to associate with the optional. The <code class="Code-In-Text--PACKT-">T</code> symbol is used to define a generic and can be used to represent any type.</p>
    <h1 id="_idParaDest-71" class="title">The need for optional types in Swift</h1>
    <p class="normal">Now, the burning <a id="_idIndexMarker169"/>question: why does Swift need optionals? To <a id="_idIndexMarker170"/>understand this question, we should examine what problems optionals are designed to solve.</p>
    <p class="normal">In most languages, it is possible to create a variable without giving it an initialized value. For example, in Objective-C, both of these lines of code are valid:</p>
    <pre class="programlisting code"><code class="hljs-code">int i;
<span class="hljs-type">MyObject</span> *m;
</code></pre>
    <p class="normal">Now, let's say that the <code class="Code-In-Text--PACKT-">MyObject</code> class, written in Objective-C, has the following method:</p>
    <pre class="programlisting code"><code class="hljs-code">-(int)myMethodWithValue:(int)i { 
<span class="hljs-keyword">    return</span> i*<span class="hljs-number">2</span>;
}
</code></pre>
    <p class="normal">This method takes the value passed in from the <code class="Code-In-Text--PACKT-">i</code> parameter, multiplies it by two, and returns the results. Let's try to call this method using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MyObject</span> *m;
<span class="hljs-type">NSLog</span>(@<span class="hljs-string">"Value: %d"</span>,[m myMethodWithValue:<span class="hljs-number">5</span>]);
</code></pre>
    <p class="normal">Our first thought might be that this code would display <code class="Code-In-Text--PACKT-">Value: 10</code>, since we are pass athe value of <code class="Code-In-Text--PACKT-">5</code> to a method that doubles the value passed in; however, this would be incorrect. In reality, this code would display <code class="Code-In-Text--PACKT-">Value: 0</code> because we did not initialize the <code class="Code-In-Text--PACKT-">m</code> object prior to using it.</p>
    <p class="normal">When we forget to initialize an object or set a value for a variable, we can get unexpected results at runtime, as we just demonstrated. The unexpected results can be, at times, very difficult to track down.</p>
    <p class="normal">With optionals, Swift is able to detect problems such as this at compile time and alert us before it becomes a runtime issue. If we expect a variable or object to always contain a value prior to using it, we will declare the variable as a non-optional (this is the default declaration). Then we will receive an error if we try to use it prior to initializing it. Let's look at an example of this. The following code would display an error because we are attempting to use a non-optional variable prior to initializing it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString: <span class="hljs-type">String</span> 
<span class="hljs-built_i">print</span>(myString)
</code></pre>
    <p class="normal">If a variable is declared as an optional, it is good programming practice to verify that it contains a <a id="_idIndexMarker171"/>valid value before attempting to use it. We should <a id="_idIndexMarker172"/>only declare a variable as an optional if there is a valid reason for the variable to contain no value. This is the reason Swift declares variables as non-optional by default.</p>
    <p class="normal">Now that we have a better understanding of what optionals are and what types of problems they are designed to solve, let's look at how to use them.</p>
    <h1 id="_idParaDest-72" class="title">Defining an optional</h1>
    <p class="normal">One thing <a id="_idIndexMarker173"/>to keep in mind is that the type we define in the variable's declaration is actually the associated value in the optional enumeration. The following code shows us how we would typically declare an optional:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myOptional: <span class="hljs-type">String?</span>
</code></pre>
    <p class="normal">This code declares an optional variable that might contain a string or might contain no value. When a variable such as this is declared, by default it is set to nil. Now that we have seen how to define an optional, let's look at how we can use it.</p>
    <h1 id="_idParaDest-73" class="title">Using optionals</h1>
    <p class="normal">The key to <a id="_idIndexMarker174"/>using optionals is to always verify that they contain a valid value prior to accessing them. The reason for this is if we attempt to use an optional value without verifying that it contains a valid value, we may encounter a runtime error, causing our application to crash. We use the term unwrapping to refer to the process of retrieving a value from an optional. We are going to introduce two methods for retrieving the values of an optional; please keep in mind that using optional binding is preferred.</p>
    <h2 id="_idParaDest-74" class="title">Forced unwrapping of an optional</h2>
    <p class="normal">To unwrap or retrieve the value of an optional, we place an exclamation mark (<code class="Code-In-Text--PACKT-">!</code>) after the variable name. This is called forced unwrapping. Forced unwrapping, in this manner, is very <a id="_idIndexMarker175"/>dangerous and should be used only if we are certain that the variable contains a non-nil value. Otherwise, if it does contain a nil value, we will get a runtime error and the application will crash.</p>
    <p class="normal">When we use the exclamation point to unwrap an optional, we are telling the compiler that we know the optional contains a value, so go ahead and give it to us. Let's look at how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString1: <span class="hljs-type">String?</span> 
myString1 = <span class="hljs-string">"test"</span>
<span class="hljs-keyword">var</span> test: <span class="hljs-type">String</span> = myString1!
</code></pre>
    <p class="normal">This code will work as we expect it to, where the <code class="Code-In-Text--PACKT-">test</code> variable will contain the <code class="Code-In-Text--PACKT-">"test"</code> string; however, if the line that set the <code class="Code-In-Text--PACKT-">myString1</code> optional to <code class="Code-In-Text--PACKT-">test</code> was removed, we would receive a runtime error when the application is run. Note that the compiler will not alert us to an issue because we are using the exclamation point to unwrap the optional; therefore, the compiler assumes that we know what we are doing and will happily compile the code for us. We should verify that the <code class="Code-In-Text--PACKT-">myString1</code> optional contains a valid value before unwrapping it. The following example is one way to do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var </span>myString1:<span class="hljs-keyword"> </span><span class="hljs-type">String?</span><span class="hljs-keyword"> </span>
myString1<span class="hljs-keyword"> </span>=<span class="hljs-keyword"> </span><span class="hljs-string">"test"</span>
<span class="hljs-keyword">if </span>myString1 !=<span class="hljs-keyword"> </span><span class="hljs-literal">nil</span><span class="hljs-keyword"> { </span>
<span class="hljs-keyword">    var </span>test = myString1!
}
</code></pre>
    <p class="normal">Now, if the line that sets the <code class="Code-In-Text--PACKT-">myString1</code> optional to <code class="Code-In-Text--PACKT-">test</code> were removed, we would not receive a runtime error because we only unwrap the <code class="Code-In-Text--PACKT-">myString1</code> optional if it contains a valid (non-nil) value.</p>
    <p class="normal">Unwrapping optionals, as we just described, is not optimal, and it is not recommended that optionals be unwrapped in this manner. We can combine verification and unwrapping in one step, called optional binding.</p>
    <h2 id="_idParaDest-75" class="title">Optional binding</h2>
    <p class="normal">Optional <a id="_idIndexMarker176"/>binding is the recommended way to unwrap an optional. With optional binding, we perform a check to see whether the optional contains a valid value and, if so, unwrap it into a temporary variable or constant. This is all performed in one step.</p>
    <p class="normal">Optional binding is performed with <code class="Code-In-Text--PACKT-">if</code> or <code class="Code-In-Text--PACKT-">while</code> conditional statements. It takes the following format if we want to put the value of the optional in a constant:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> constantName = <span class="hljs-keyword">optional</span> { 
    statements
}
</code></pre>
    <p class="normal">If we need to put the value in a variable, instead of a constant, we can use the <code class="Code-In-Text--PACKT-">var</code> keyword, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> variableName = <span class="hljs-keyword">optional</span> { 
    statements
}
</code></pre>
    <p class="normal">The following <a id="_idIndexMarker177"/>example shows how to perform optional binding:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myString3: <span class="hljs-type">String?</span>
myString3 = <span class="hljs-string">"Space, the final frontier"</span> 
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> tempVar = myString3 {
<span class="hljs-built_i">    print</span>(tempVar)
} <span class="hljs-keyword">else</span> {
<span class="hljs-built_i">    print</span>(<span class="hljs-string">"No value"</span>)
}
</code></pre>
    <p class="normal">In the example, we define the <code class="Code-In-Text--PACKT-">myString3</code> variable as an optional type. If the <code class="Code-In-Text--PACKT-">myString3</code> optional contains a valid value, the new variable, named <code class="Code-In-Text--PACKT-">tempvar</code>, is set to that value and is printed to the console. If the <code class="Code-In-Text--PACKT-">myString3</code> optional does not contain a value, <code class="Code-In-Text--PACKT-">No value</code> is printed to the console.</p>
    <p class="normal">We are able to use optional binding to unwrap multiple optionals within the same optional binding line. For example, if we had three optionals named <code class="Code-In-Text--PACKT-">optional1</code>, <code class="Code-In-Text--PACKT-">optional2</code>, and <code class="Code-In-Text--PACKT-">optional3</code>, we could use the following code to attempt to unwrap all three at once:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> tmp1 = optional1, <span class="hljs-keyword">let</span> tmp2 = optional2, <span class="hljs-keyword">let</span> tmp3 = optional3 {
}
</code></pre>
    <p class="normal">If any of the three optionals are <code class="Code-In-Text--PACKT-">nil</code>, the whole optional binding statement fails. It is also perfectly acceptable with optional binding to assign the value to a variable of the same name. The following code illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> myOptional = myOptional { 
<span class="hljs-built_i">    print</span>(myOptional)
} <span class="hljs-keyword">else</span> {
<span class="hljs-built_i">    print</span>(<span class="hljs-string">"myOptional was nil"</span>)
}
</code></pre>
    <p class="normal">One thing to note is that the temporary variable is scoped only for the conditional block and cannot be used outside it. To illustrate the scope of the temporary variable, let's take a look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myOptional: <span class="hljs-type">String?</span> 
myOptional = <span class="hljs-string">"test"</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> tmp = myOptional { 
<span class="hljs-keyword">    </span><span class="hljs-built_i">print</span>(<span class="hljs-string">"Inside:\(tmp)"</span>)
}
<span class="hljs-comment">// This next line will cause a compile time error </span>
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Outside: \(tmp)"</span>)
</code></pre>
    <p class="normal">This code <a id="_idIndexMarker178"/>would not compile because the <code class="Code-In-Text--PACKT-">tmp</code> variable is only valid within the conditional block and we are attempting to use it outside the block.</p>
    <p class="normal">Using optional binding is a lot cleaner and easier than manually verifying that the optional has a value and using forced unwrapping to retrieve the value of the optional. There are different ways that we can use optional typeswith tuples;, let's look at these.</p>
    <h2 id="_idParaDest-76" class="title">Optional types with tuples</h2>
    <p class="normal">We can <a id="_idIndexMarker179"/>define a whole tuple as an optional or any of the elements within a tuple as an optional. It is especially useful to use optionals with tuples when <a id="_idIndexMarker180"/>we return a tuple from a function or method. This allows us to return part (or all) of the tuple as <code class="Code-In-Text--PACKT-">nil</code>. The following example shows how to define a tuple as an optional, and also how to define individual elements of a tuple as optional types:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> tuple1: (one: <span class="hljs-type">String</span>, two: <span class="hljs-type">Int</span>)? 
<span class="hljs-keyword">var</span> tuple2: (one: <span class="hljs-type">String</span>, two: <span class="hljs-type">Int?</span>)
</code></pre>
    <p class="normal">The first line defines the whole tuple as an optional type. The second line defines the second value within the tuple as an optional, while the first value is a non-optional.</p>
    <h2 id="_idParaDest-77" class="title">Optional chaining</h2>
    <p class="normal">Optional chaining <a id="_idIndexMarker181"/>allows us to call properties, methods, and subscripts on an optional that might be nil. If any of the chained values return nil, the return value will be nil. The following code gives an example of optional chaining using a fictitious <code class="Code-In-Text--PACKT-">car</code> object. In this example, if either the <code class="Code-In-Text--PACKT-">car</code> or <code class="Code-In-Text--PACKT-">tires</code> optional variables are nil, the <code class="Code-In-Text--PACKT-">tireSize</code> variable will be nil, otherwise the <code class="Code-In-Text--PACKT-">tireSize</code> variable will be equal to the <code class="Code-In-Text--PACKT-">tireSize</code> property:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> tireSize = car?.tires?.tireSize
</code></pre>
    <p class="normal">We will look at optional chaining again in <em class="chapterRef">Chapter 8</em>, <em class="italic">Classes, Structures, and Protocols</em>.</p>
    <h2 id="_idParaDest-78" class="title">The nil coalescing operator</h2>
    <p class="normal">The nil coalescing <a id="_idIndexMarker182"/>operator is similar to the ternary operator that we discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Learning about Variables, Constants, Strings, and Operators</em>. The ternary operator assigns a value to a variable, based on the evaluation of a comparison operator or a Boolean value. The nil coalescing operator attempts to unwrap an optional, and if it contains a value, it will return that value, or a default value if the optional is nil, as shown in the following code.</p>
    <p class="normal">Let's look at a prototype for the nil coalescing operator:</p>
    <pre class="programlisting code"><code class="hljs-code">optionalA ?? defaultValue
</code></pre>
    <p class="normal">In this example, we demonstrate the <code class="Code-In-Text--PACKT-">nil</code> coalescing operator when the optional is set to nil and also when it contains a value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> defaultName = <span class="hljs-string">"Jon"</span>
<span class="hljs-keyword">var</span> optionalA: <span class="hljs-type">String?</span>
<span class="hljs-keyword">var</span> optionalB: <span class="hljs-type">String?</span>
optionalB = <span class="hljs-string">"Buddy"</span>
<span class="hljs-keyword">var</span> nameA = optionalA ?? defaultName 
<span class="hljs-keyword">var</span> nameB = optionalB ?? defaultName
</code></pre>
    <p class="normal">In this example, we begin by initializing our <code class="Code-In-Text--PACKT-">defaultName</code> variable to <code class="Code-In-Text--PACKT-">Jon</code>. We then define two optionals, named <code class="Code-In-Text--PACKT-">optionalA </code>and <code class="Code-In-Text--PACKT-">optionalB</code>. The <code class="Code-In-Text--PACKT-">optionalA</code> variable is set to <code class="Code-In-Text--PACKT-">nil</code>, while the <code class="Code-In-Text--PACKT-">optionalB</code> variable is set to <code class="Code-In-Text--PACKT-">Buddy</code>.</p>
    <p class="normal">The nil coalescing operator is used in the final two lines. Since the <code class="Code-In-Text--PACKT-">optionalA</code> variable contains nil, the <code class="Code-In-Text--PACKT-">nameA</code> variable will be set to the value of the <code class="Code-In-Text--PACKT-">defaultName</code> variable, which is <code class="Code-In-Text--PACKT-">Jon</code>. The <code class="Code-In-Text--PACKT-">nameB</code> variable will be set to the value of the <code class="Code-In-Text--PACKT-">optionalB</code> variable since it contains a value.</p>
    <p class="normal">The nil <a id="_idIndexMarker183"/>coalescing operator is shorthand for using the ternary operator as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> nameC = optionalA != <span class="hljs-literal">nil</span> ? optionalA! : defaultName
</code></pre>
    <p class="normal">As we can see, the nil coalescing operator is much cleaner and easier to read than the equivalent ternary operator.</p>
    <h2 id="_idParaDest-79" class="title">Summary</h2>
    <p class="normal">In this chapter, we described what optionals actually are and how they are defined internally in the Swift language. It is important to understand this concept because optionals are used a lot in Swift, and knowing how they work internally will help you to use them properly. While the concept of optional types, as used in the Swift language, might seem a little confusing at first, the more you use them, the more they will make sense. One of the biggest advantages of optional types is the additional compile-time checks that alert us if we forget to initialize non-optionals prior to using them. We will see additional examples of optionals later in this book.</p>
    <p class="normal">In the next chapter, we will look at how to use collections.</p>
  </div>
</body></html>