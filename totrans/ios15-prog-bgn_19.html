<html><head></head><body>
		<div><h1 id="_idParaDest-218"><em class="italic"><a id="_idTextAnchor223"/>Chapter 16</em>: Getting Started with MapKit</h1>
			<p>In the previous chapter, you learned about table views and table view controllers, and completed the implementation of the <strong class="bold">Locations</strong> screen. It now displays a list of restaurant locations.</p>
			<p>In this chapter, you'll display restaurant locations on the <code>MKAnnotation</code> protocol, which allows you to associate the classes you create with a specific map location. You'll create a new class, <code>RestaurantItem</code>, that conforms to this protocol. Next, you'll create <code>MapDataManager</code>, a data manager class that loads restaurant data from a <code>.plist</code> file and puts it into an array of <code>RestaurantItem</code> instances. You'll create a new <code>DataManager</code> protocol to read <code>.plist</code> files and update both the <code>MapDataManager</code> and <code>ExploreDataManager</code> classes to avoid redundant code (refactoring). After that, you'll create a <code>MapViewController</code> class, a view controller for the <code>RestaurantDetailViewController</code> class, a view controller for the <code>MapViewController</code> instance. Finally, you'll clean up and organize your code using extensions to make it easier to read and maintain. </p>
			<p>By the end of this chapter, you'll have learned how to create custom map annotation views and add them to a map, how to use storyboard references to link storyboards together, and how to use extensions to organize your code, making it easier to read.</p>
			<p>The following topics will be covered:</p>
			<ul>
				<li>Understanding and creating annotations</li>
				<li>Adding annotations to a map view</li>
				<li>Going from the map view to the <strong class="bold">Restaurant Detail</strong> screen</li>
				<li>Organizing your code</li>
			</ul>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor224"/>Technical requirements</h1>
			<p>You will continue working on the <code>LetsEat</code> project that you modified in the previous chapter.</p>
			<p>The resource files and completed Xcode project for this chapter are in the <code>Chapter16 </code>folder of the code bundle for this book, which can be downloaded here:</p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a></p>
			<p>Check out the following video to see the code in action:</p>
			<p><a href="https://bit.ly/3kEKEB7">https://bit.ly/3kEKEB7</a></p>
			<p>Now let's learn about map annotations, which are used to mark restaurant locations on the <strong class="bold">Map</strong> screen.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor225"/>Understanding and creating annotations</h1>
			<p>In <a href="B17469_11_Final_VK_ePub.xhtml#_idTextAnchor171"><em class="italic">Chapter 11</em></a><em class="italic">, Finishing Up Your User Interface</em>, you<a id="_idIndexMarker765"/> added a map <a id="_idIndexMarker766"/>view to the <code>MKMapView</code> class. You can see what it looks like in the Apple <em class="italic">Maps</em> app.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more about <code>MKMapView</code>, see <a href="https://developer.apple.com/documentation/mapkit/mkmapview">https://developer.apple.com/documentation/mapkit/mkmapview</a>.</p>
			<p>When you build and run your app, you will see a map on the screen. The part of the map that is visible onscreen can be specified by setting the <code>region</code> property of the map.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more about regions and how to make them, see <a href="https://developer.apple.com/documentation/mapkit/mkmapview/1452709-region">https://developer.apple.com/documentation/mapkit/mkmapview/1452709-region</a>.</p>
			<p>Pins on the <code>MKAnnotationView</code> class. To add a pin to a map view, you need an object that conforms to the <code>MKAnnotation</code> protocol. This protocol allows you to associate an object with a specific map location.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more about the <code>MKAnnotation</code> protocol, see <a href="https://developer.apple.com/documentation/mapkit/mkannotation">https://developer.apple.com/documentation/mapkit/mkannotation</a>.</p>
			<p>Any object can conform to the <code>MKAnnotation</code> protocol by implementing a <code>coordinate</code> property, which contains a map location. Optional <code>MKAnnotation</code> protocol properties are <code>title</code>, a string containing the annotation's title, and <code>subtitle</code>, a string containing the annotation's subtitle. </p>
			<p>When an<a id="_idIndexMarker767"/> object <a id="_idIndexMarker768"/>conforming to the <code>MKAnnotation</code> protocol is in the area of the map that is visible onscreen, the map view asks its delegate (usually a view controller) to provide a corresponding instance of the <code>MKAnnotationView</code> class. This instance appears as a pin on the map. </p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more about <code>MKAnnotationView</code>, see <a href="https://developer.apple.com/documentation/mapkit/mkannotationview">https://developer.apple.com/documentation/mapkit/mkannotationview</a>.</p>
			<p>If the user scrolls the map and the <code>MKAnnotationView</code> instance goes off screen, it will be put into a reuse queue and recycled later, similar to the way table view cells and collection view cells are recycled. An <code>MKAnnotationView</code> instance can be customized to display custom icons and can display callout bubbles when tapped. Callout bubbles can have buttons that perform actions, such as displaying a screen.</p>
			<p>For your app, you will create a new class, <code>RestaurantItem</code>, that conforms to the <code>MKAnnotation</code> protocol. Let's see how to create this class in the next section.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor226"/>Creating the RestaurantItem class</h2>
			<p>To represent <a id="_idIndexMarker769"/>restaurant locations on the <code>RestaurantItem</code>, that conforms to the <code>MKAnnotation</code> protocol. This class will have a <code>coordinate</code> property to store the restaurant's location, a <code>title</code> property to store the restaurant name, and a <code>subtitle</code> property to store the cuisines it offers.</p>
			<p>You need the restaurant location to set the <code>coordinate</code> property of the <code>RestaurantItem</code> instance. The restaurant data (including its location) will be provided as a <code>.plist</code> file. Before you create the <code>RestaurantItem</code> class, you need to import this <code>.plist</code> file into your app. Follow these steps:</p>
			<ol>
				<li>Open the <code>LetsEat</code> project. In the Project navigator, right-click the <code>LetsEat</code> folder and create a new group called <code>Map</code>.</li>
				<li>Right-click the <code>Map</code> folder and create a new group called <code>Model</code>.</li>
				<li>If you have not yet done so, download the completed project and project resources from <a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a> and find the <code>Maplocations.plist</code> file inside the <code>resources</code> folder in the <code>Chapter16</code> folder.</li>
				<li>Drag the <code>Maplocations.plist</code> file to the <code>Model</code> folder in your project, and click it to view its contents. You'll see that it is an array of dictionaries, with each dictionary containing a restaurant's details (including its location). You'll create properties in your <code>RestaurantItem</code> class for the data that you will use, which will eventually be displayed on the <strong class="bold">Restaurant Detail</strong> screen:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_16.01_B17469.jpg" alt="Figure 16.1: Editor area showing the contents of MapLocations.plist&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1: Editor area showing the contents of MapLocations.plist</p>
			<p>Let's create<a id="_idIndexMarker770"/> the <code>RestaurantItem</code> class by following these steps:</p>
			<ol>
				<li value="1">Right-click the <code>Model</code> folder and select <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should already be selected. Choose <strong class="bold">Cocoa Touch Class</strong> and then click <strong class="bold">Next</strong>.</li>
				<li>Configure the file as follows:<p><code>RestaurantItem</code></p><p><code>NSObject</code></p><p><code>Swift</code></p><p>Click <strong class="bold">Next</strong>.</p></li>
				<li>Click <code>RestaurantItem</code> file appears in the Project navigator.</li>
				<li>In the <code>RestaurantItem</code> file, type the following after the <code>import UIKit </code>statement to import the <code>MapKit</code> framework:<pre>import MapKit</pre><p>This gives you access to protocols such as <code>MKAnnotation</code> and <code>MKMapViewDelegate</code>.</p></li>
				<li>Modify the class declaration as follows to adopt the <code>MKAnnotation</code> protocol:<pre>class RestaurantItem: NSObject<code>coordinate</code> property, which is required to conform to <code>MKAnnotation</code>. You will do so shortly.</p></li>
				<li>Type the <a id="_idIndexMarker771"/>following between the curly braces:<pre>let name: String?
let cuisines: [String]
let lat: Double?
let long: Double?
let address: String?
let postalCode: String?
let state: String?
let imageURL: String?
let restaurantID: Int?</pre><p>These properties will hold the data you get from the <code>Maplocations.plist</code> file. Let's see what they are for:</p><p><code>name</code> stores the name of the restaurant.</p><p><code>cuisines</code> stores the cuisines offered by the restaurant.</p><p><code>lat</code> and <code>long</code> stores the latitude and the longitude of the restaurant location.</p><p><code>address</code> stores the restaurant's address.</p><p><code>postalCode</code> stores the restaurant's postal code.</p><p><code>state</code> stores the state in which the restaurant is located.</p><p><code>imageURL</code> stores a a link to a photo of the restaurant.</p><p><code>restaurantID</code> stores a unique number used as an identifier for the restaurant.</p><p>Note that you haven't created properties to store every detail of a restaurant contained in the <code>Maplocations.plist</code> file, and that's fine. You only need to create<a id="_idIndexMarker772"/> properties for the details that will appear on the <strong class="bold">Restaurant Detail</strong> screen.</p></li>
				<li>You'll use a custom initializer to initialize <code>RestaurantItem</code> instances with data from the <code>.plist</code> file. Type the following after the last property declaration:<pre>init(dict: [String: AnyObject]) {
   self.lat = dict["lat"] as? Double
   self.long = dict["long"] as? Double 
   self.name = dict["name"] as? String  
   self.cuisines = dict["cuisines"] as? [String] ?? []
   self.address = dict["address"] as? String
   self.postalCode = dict["postalCode"] as? String
   self.state = dict["state"] as? String 
   self.imageURL = dict["image_url"] as? String
   self.restaurantID = dict["id"] as? Int
}</pre><p>Even though this initializer looks complicated, it's actually quite straightforward. Each line looks for a specific dictionary item key and assigns its value to the corresponding property. For example, the first line looks for the dictionary item with a key containing <code>lat</code> and assigns the associated value to the <code>lat</code> property.</p></li>
				<li>You'll use the <code>lat</code> and <code>long</code> properties to create the value for the <code>coordinate</code> property, which is required to conform to <code>MKAnnotation</code>. Type the <a id="_idIndexMarker773"/>following after the <code>init(dict:)</code> method to implement it:<pre>var coordinate: CLLocationCoordinate2D {
   guard let lat = lat, let long = long else { 
      return CLLocationCoordinate2D() 
   }
   return CLLocationCoordinate2D(latitude: lat,
   longitude: long)
}</pre><p>The <code>coordinate</code> property is of type <code>CLLocationCoordinate2D</code>, and it holds a geographical location. The value of the <code>coordinate</code> property is not assigned directly; the <code>guard</code> statement gets the latitude and longitude values from the <code>lat</code> and <code>long</code> properties, which are then used to create the value for the <code>coordinate</code> property. Such <a id="_idIndexMarker774"/>properties are called <strong class="bold">computed properties</strong>.</p></li>
				<li>Implement the <code>title</code> property by adding the following code after the <code>coordinate</code> property:<pre>var title: String? {
   name
}</pre><p><code>title</code> is a computed property that returns the contents of the <code>name</code> property.</p></li>
				<li>Finally, implement the <code>subtitle</code> property by adding the following code after the <code>title</code> property:<pre>var subtitle: String? {
   if cuisines.isEmpty { 
      return "" 
   } else if cuisines.count == 1 { 
      return cuisines.first 
   } else { 
      return cuisines.joined(separator: ", ") 
   }
}</pre><p><code>subtitle</code> is also <a id="_idIndexMarker775"/>a computed property. The first line checks to see whether the <code>cuisines</code> property is empty, and if so, returns an empty string. If the <code>cuisines</code> property contains a single item, that item will be returned. If the <code>cuisines</code> property has more than a single item, each item is added to a string, with a comma in between items. For example, if <code>cuisines</code> contained the <code>["American", "Bistro", "Burgers"]</code> array, the generated string would be <code>"American, Bistro, Burgers"</code>.</p><p>Your <code>RestaurantItem</code> class is now complete and free of errors and should look like this:</p><pre>import UIKit 
import MapKit
class RestaurantItem: NSObject, MKAnnotation {
   let name: String?
   let cuisines: [String]
   let lat: Double?
   let long: Double?
   let address: String?
   let postalCode: String?
   let state: String?
   let imageURL: String?
   let restaurantID: Int?
   init(dict: [String: AnyObject]) {
      self.lat = dict["lat"] as? Double
      self.long = dict["long"] as? Double 
      self.name = dict["name"] as? String  
      self.cuisines = dict["cuisines"] as? [String] 
      ?? []
      self.address = dict["address"] as? String
      self.postalCode = dict["postalCode"] as? String
      self.state = dict["state"] as? String 
      self.imageURL = dict["image_url"] as? String
      self.restaurantID = dict["id"] as? Int
   }
   var coordinate: CLLocationCoordinate2D {
      guard let lat = lat, let long = long else {
         return CLLocationCoordinate2D() 
      }
      return CLLocationCoordinate2D(latitude: lat,
      longitude: long)
   }
   var title: String? {
      name
   }
   var subtitle: String? {
      if cuisines.isEmpty { 
         return "" 
      } else if cuisines.count == 1 { 
         return cuisines.first 
      } else { 
         return cuisines.joined(separator: ", ") 
      }
   }
}</pre></li>
			</ol>
			<p>At this point, you've added the <code>Maplocations.plist</code> file to your app, and you have created<a id="_idIndexMarker776"/> the <code>RestaurantItem</code> class. Next, let's create a data manager class that reads restaurant data from the <code>Maplocations.plist</code> file and puts it into an array of  <code>RestaurantItem</code> instances for use by your app.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor227"/>Creating the MapDataManager class</h2>
			<p>As you have done <a id="_idIndexMarker777"/>in previous chapters, you'll create a data manager class, <code>MapDataManager</code>, that will load restaurant data from the <code>Maplocations.plist</code> file and put the data into an array of <code>RestaurantItem</code> instances. Follow these steps:</p>
			<ol>
				<li value="1">Right-click the <code>Model</code> folder inside the <code>Map</code> folder and select <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should already be selected. Choose <strong class="bold">Swift File</strong> and then click <strong class="bold">Next</strong>.</li>
				<li>Name this file <code>MapDataManager</code>. Click <code>MapDataManager</code> file appears in the Project navigator.</li>
				<li>In the <code>MapDataManager</code> file, add the following after the <code>import</code> statement to declare the <code>MapDataManager</code> class:<pre>class MapDataManager {
 
}</pre></li>
				<li>Add the following properties between the curly braces to store the <code>RestaurantItem</code> instances<a id="_idIndexMarker778"/> that will be read from the <code>.plist</code> file:<pre>private var items: [RestaurantItem] = []
var annotations: [RestaurantItem] {
   items 
}</pre><p>The <code>items</code> array will contain <code>RestaurantItem</code> instances. <code>private</code> makes the <code>items</code> array only accessible within the <code>MapDataManager</code> class, and <code>annotations</code> is a computed property that returns a copy of the <code>items</code> array when accessed. This allows the contents of the <code>items</code> array to be accessed, but not modified, by other objects.</p></li>
				<li>Add the following methods after the property declarations to load the <code>.plist</code> file, read the data inside, and store it in an array of <code>RestaurantItem</code> instances:<pre>private func loadData() -&gt; [[String: AnyObject]] {
   guard let path = Bundle.main.path(forResource:
   "MapLocations", ofType: "plist"), 
   let itemsData = FileManager.default.contents(
   atPath: path),
   let items = try! PropertyListSerialization
   .propertyList(from: itemsData, format: nil) as? 
   [[String: AnyObject]] else {
      return [[:]]
   }
   return items
} 
func fetch(completion: (_ annotations: 
[RestaurantItem]) -&gt; ()){
   if !items.isEmpty { 
      items.removeAll() 
   }
   for data in loadData() {
      items.append(RestaurantItem(dict: data))
   }
   completion(items)
}</pre><p>The <code>loadData()</code> and <code>fetch(completion:)</code> methods <a id="_idIndexMarker779"/>perform the same tasks as the <code>loadData()</code> and  <code>fetch()</code> methods in the <code>ExploreDataManager</code> class. </p><p class="callout-heading">Tip</p><p class="callout">You may wish to re-read <a href="B17469_14_Final_VK_ePub.xhtml#_idTextAnchor201"><em class="italic">Chapter 14</em></a><em class="italic">, Getting Data into Collection Views</em>, to refresh your memory on the <code>ExploreDataManager</code> class.</p></li>
			</ol>
			<p>However, the <code>loadData()</code> method used here is able to return an array containing dictionaries where the values are of the <code>AnyObject</code> type. This is necessary since the <code>MapLocations.plist</code> file, unlike the <code>ExploreData.plist</code> file, does not exclusively contain dictionaries of the <code>[String: String</code>] type. Also, the <code>fetch(completion:)</code> method used here has a completion closure as a parameter, which can accept any function or closure that takes an array of <code>RestaurantItems</code> as a parameter:</p>
			<pre>(_ annotations:[RestaurantItem]) -&gt; ())</pre>
			<p>Sometimes, you don't know when an operation will be finished. For example, you need to do an action after you've downloaded a file from the internet, but you don't know how long it would take to download. You can specify a completion closure to be applied once the operation has been completed. In this case, the completion closure will process the <code>items</code> array once all the data from the <code>.plist</code> file has been read.</p>
			<p>Now consider<a id="_idIndexMarker780"/> the <code>MapLocations.plist</code> file once more:</p>
			<div><div><img src="img/Figure_16.02_B17469.jpg" alt="Figure 16.2: Editor area showing array and dictionaries in MapLocations.plist&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2: Editor area showing array and dictionaries in MapLocations.plist</p>
			<p>This file has the same structure as <code>ExploreData.plist</code>. The <code>Root</code> item is an array that contains dictionaries. Since both <code>ExploreData.plist</code> and <code>MapLocations.plist</code> have an array of dictionaries, it would be more efficient if you could create a single method to load <code>.plist</code> files and use it wherever it was needed. You will do this in the next section.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor228"/>Creating the DataManager protocol</h2>
			<p>Instead of<a id="_idIndexMarker781"/> creating a method in each class to load a <code>.plist</code> file, you will create a new protocol, <code>DataManager</code>, to handle <code>.plist</code> file loading. This protocol will implement a method to load <code>.plist</code> files using an extension. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You may wish to re-read <a href="B17469_08_Final_VK_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a><em class="italic">, Protocols, Extensions, and Error Handling</em>, which covers protocols and extensions.</p>
			<p>After you have created the <code>DataManager</code> protocol, any class that needs to load a <code>.plist</code> file can adopt it. You'll modify both <code>ExploreDataManager</code> and <code>MapDataManager</code> classes to adopt this protocol. Follow these steps:</p>
			<ol>
				<li value="1">Right-click the <code>LetsEat</code> folder and create a new group called <code>Misc</code>.</li>
				<li>Right-click on the <code>Misc</code> folder and choose <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should already be selected. Choose <strong class="bold">Swift File</strong> and then click <strong class="bold">Next</strong>.</li>
				<li>Name<a id="_idIndexMarker782"/> this file <code>DataManager</code>. Click <strong class="bold">Create</strong>.</li>
				<li>Click the <code>DataManager</code> file in the Project navigator and declare the <code>DataManager</code> protocol as follows:<pre>import Foundation
<code>loadPlist(file:)</code> that takes a string as a parameter and returns an array of dictionaries. The string will hold the name of the <code>.plist</code> file to be loaded.</p></li>
				<li>Add an extension containing the implementation of the <code>loadPlist(file:)</code> method after the protocol declaration:<pre>import Foundation
protocol DataManager {
   func loadPlist(file name: String) -&gt; 
   [[String: AnyObject]]
}
<code>loadPlist(file:)</code> method. This method looks for a <code>.plist</code> file specified in the <code>name</code> parameter inside the application bundle. If the file is not found, an empty array of dictionaries is returned. Otherwise, the contents of the <code>.plist</code> file are loaded into an array of dictionaries of type <code>[String: AnyObject]</code> and returned. </p></li>
			</ol>
			<p>Now that you have this protocol, you will modify the <code>MapDataManager</code> and <code>ExploreDataManager</code> classes to adopt it. When you take existing code and modify it to accomplish the same thing more efficiently, this process is <a id="_idIndexMarker784"/>called <strong class="bold">refactoring</strong>.</p>
			<p>You will start with refactoring the <code>MapDataManager</code> class to conform to the <code>DataManager</code> protocol<a id="_idIndexMarker785"/> in the next section.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor229"/>Refactoring the MapDataManager class</h2>
			<p>The <code>MapDataManager</code> class <a id="_idIndexMarker786"/>already has a <code>loadData()</code> method, which is hardcoded to read <code>Maplocations.plist</code>. Now that you have created the <code>DataManager</code> protocol, you will modify the <code>MapDataManager</code> class to use it instead. Follow these steps:</p>
			<ol>
				<li value="1">With the <code>MapDataManager</code> file selected in the Project navigator, find and delete the <code>loadData()</code> method. You'll see an error because the <code>fetch()</code> method calls the <code>loadData()</code> method, which you just removed. You'll fix this shortly.</li>
				<li>Add the <code>DataManager</code> protocol to the class declaration as follows:<pre>class MapDataManager<code>loadPlist(file:)</code> method available to the <code>MapDataManager</code> class.</p></li>
				<li>Modify the <code>for data in loadData()</code> line in the <code>fetch()</code> method as follows to fix the error:<pre>for data in <code>MapDataManager</code> class should look like this:</p><pre>import Foundation
class MapDataManager: DataManager {
   private var items: [RestaurantItem] = []
   var annotations: [RestaurantItem] {
      items
   }
   func fetch(completion: (_ annotations: 
   [RestaurantItem]) -&gt; ()){
      if !items.isEmpty { 
         items.removeAll() 
      }
      for data in loadPlist(file: "MapLocations") {
         items.append(RestaurantItem(dict: data))
      }
      completion(items)
   }
}</pre></li>
			</ol>
			<p>The error should be gone. In the next section, you will refactor the <code>ExploreDataManager</code> class<a id="_idIndexMarker787"/> as well to make it conform to the <code>DataManager</code> protocol.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor230"/>Refactoring the ExploreDataManager class</h2>
			<p>Like<a id="_idIndexMarker788"/> the <code>MapDataManager</code> class, the <code>ExploreDataManager</code> class has a <code>loadData()</code> method, which is hardcoded to read <code>ExploreData.plist</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You may wish to re-read <a href="B17469_14_Final_VK_ePub.xhtml#_idTextAnchor201"><em class="italic">Chapter 14</em></a><em class="italic">, Getting Data into Collection Views</em>, to refresh your memory on the <code>ExploreDataManager</code> class.</p>
			<p>You need to make the same changes to the <code>ExploreDataManager</code> class that you made to the <code>MapDataManager</code> class. Follow these steps:</p>
			<ol>
				<li value="1">With the <code>ExploreDataManager</code> file selected in the Project navigator, find and delete the <code>loadData()</code> method. Ignore the error because it will be fixed shortly.</li>
				<li>Add the <code>DataManager</code> protocol to the class declaration as follows:<pre>class ExploreDataManager<code>loadPlist(file:)</code> method available to the <code>ExploreDataManager</code> class.</p></li>
				<li>Modify<a id="_idIndexMarker789"/> the <code>fetch()</code> method as follows to fix the error:<pre>   func fetch() {
      for data in <code>data</code> is cast as <code>[String: String]</code> so that it can be used to initialize instances of the <code>ExploreItem</code> class.</p><p>You can now make any class that needs to load a <code>.plist</code> file containing an array of dictionaries adopt the <code>DataManager</code> protocol, as you did here with the <code>MapDataManager</code> and <code>ExploreDataManager</code> classes. It's not always clear when you should refactor, but the more experience you have, the easier it becomes. One indication that you need to refactor is when you are writing the same code in more than one class.</p></li>
			</ol>
			<p>You have completed the implementation of the <code>MapDataManager</code> class, created the <code>DataManager</code> protocol, and refactored both the <code>MapDataManager</code> and <code>ExploreDataManager</code> classes to conform to this protocol. With the <code>MapDataManager</code> class, you can load data from the <code>MapLocations.plist</code> file and return an array of <code>RestaurantItem</code> instances. Now, let's see how to use this array to add<a id="_idIndexMarker790"/> annotations to a map view, which will be displayed as pins in the <strong class="bold">Map</strong> screen.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor231"/>Adding annotations to a map view</h1>
			<p>In <a href="B17469_11_Final_VK_ePub.xhtml#_idTextAnchor171"><em class="italic">Chapter 11</em></a><em class="italic">, Finishing Up Your User Interface</em>, you <a id="_idIndexMarker791"/>added <a id="_idIndexMarker792"/>a map view to the <code>MapLocations.plist</code> file to your project and created the <code>RestaurantItem</code> and <code>MapDataManager</code> classes. Remember the MVC design pattern? At this point, you have created the views and models for the <strong class="bold">Map</strong> screen, so all you need now is the view controller.</p>
			<p>The view controller will be responsible for the following tasks:</p>
			<ul>
				<li>Adding <code>RestaurantItem</code> instances, which conform to the <code>MKAnnotation</code> protocol, to the map view.</li>
				<li>For <code>RestaurantItem</code> instances within the region displayed in the map view, provide <code>MKAnnotationView</code> instances requested by the map view.</li>
				<li>Provide custom <code>MKAnnotationView</code> instances that display a callout bubble containing a button when tapped, and present the <strong class="bold">Restaurant Detail</strong> screen when the button is tapped.</li>
			</ul>
			<p>You'll start by creating the <code>MapViewController</code> class as the view controller for the <strong class="bold">Map</strong> screen in the next section.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor232"/>Creating the MapViewController class</h2>
			<p>You've created the<a id="_idIndexMarker793"/> view and model objects for the <code>MapViewController</code>, to be the view controller for the<strong class="bold"> Map</strong> screen. Follow these steps:</p>
			<ol>
				<li value="1">Right-click the <code>Map</code> folder and select <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should already be selected. Choose <strong class="bold">Cocoa Touch Class</strong> and then click <strong class="bold">Next</strong>.</li>
				<li>Configure the file as follows:<p><code>MapViewController</code></p><p><code>UIViewController</code></p><p><code>Swift</code></p><p>Click <strong class="bold">Next</strong>.</p></li>
				<li>Click <code>MapViewController</code> file appears in the Project navigator.</li>
				<li>In the <code>MapViewController</code> file, add the following line after <code>import UIKit</code> to import the <code>MapKit</code> framework:<pre>import MapKit</pre></li>
				<li>Modify the class declaration as follows to make the <code>MapViewController</code> class adopt the <code>MKMapViewDelegate</code> protocol:<pre>class MapViewController: UIViewController<strong class="bold">, </strong>
<strong class="bold">MKMapViewDelegate </strong>{</pre></li>
			</ol>
			<p>You have<a id="_idIndexMarker794"/> declared the <code>MapViewController</code> class. In the next section, you'll assign this class as the view controller for the <strong class="bold">Map</strong> screen, and create an outlet for the map view.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor233"/>Connecting the outlets for the map view</h2>
			<p>The view controller <a id="_idIndexMarker795"/>scene for the <code>MapViewController</code> class to be the view controller for the <strong class="bold">Map</strong> screen and add an outlet for the map view to it. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>Main</code> storyboard file. Click the <code>MapViewController</code>:<div><img src="img/Figure_16.03_B17469.jpg" alt="Figure 16.3: Identity inspector showing Class setting for MapViewController&#13;&#10;"/></div><p class="figure-caption">Figure 16.3: Identity inspector showing Class setting for MapViewController</p></li>
				<li>Select the <strong class="bold">Map View</strong> in<a id="_idIndexMarker796"/> the document outline:<div><img src="img/Figure_16.04_B17469.jpg" alt="Figure 16.4: Document outline with Map View selected&#13;&#10;"/></div><p class="figure-caption">Figure 16.4: Document outline with Map View selected</p></li>
				<li>Click the Adjust Editor Options button.</li>
				<li>Choose Assistant in the pop-up menu.</li>
				<li>The assistant editor appears, showing the contents of the <code>MapViewController</code> file. <em class="italic">Ctrl + Drag</em> from the map view to the space just under the class declaration:<div><img src="img/Figure_16.05_B17469.jpg" alt="Figure 16.5: Editor area showing MapViewController file contents&#13;&#10;"/></div><p class="figure-caption">Figure 16.5: Editor area showing MapViewController file contents</p></li>
				<li>Type <code>mapView</code> in <a id="_idIndexMarker797"/>the <strong class="bold">Name</strong> field and click <strong class="bold">Connect</strong>:<div><img src="img/Figure_16.06_B17469.jpg" alt="Figure 16.6: Pop-up dialog box for mapView outlet creation&#13;&#10;"/></div><p class="figure-caption">Figure 16.6: Pop-up dialog box for mapView outlet creation</p></li>
				<li>The map view has been connected to the <code>mapView</code> outlet in the <code>MapViewController</code> class. Click the <strong class="bold">x</strong> button to close the assistant editor:</li>
			</ol>
			<div><div><img src="img/Figure_16.07_B17469.jpg" alt="Figure 16.7: Assistant editor close button &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.7: Assistant editor close button </p>
			<p>The <code>MapViewController</code> class now has an outlet, <code>mapView</code>, that is linked to the map view in the <code>MapDataManager</code> class by adding a method to generate a new region based on the restaurant's location, so it can<a id="_idIndexMarker798"/> provide a map region for the map view to display.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor234"/>Setting the map view region to be displayed</h2>
			<p>In a map view, the <a id="_idIndexMarker799"/>portion of the map that is visible on screen is called a region. To specify a region, you need the coordinates for the region's center point and the horizontal and vertical span representing the dimensions of the map to be displayed.</p>
			<p>The <code>fetch(completion:)</code> method in the <code>MapDataManager</code> class returns an array of <code>RestaurantItem</code> instances. You will implement a method, <code>initialRegion(latDelta:longDelta:)</code>, to get the first <code>RestaurantItem</code> instance from this array, get the restaurant's coordinates, and use them to create a region. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>MapDataManager</code> file in the Project navigator. After the <code>import Foundation</code> statement, add <code>import MapKit</code>.</li>
				<li>Just before the closing curly brace, implement the  <code>initialRegion(latDelta:longDelta:)</code> method as follows:<pre>func initialRegion(latDelta: CLLocationDegrees, 
longDelta: CLLocationDegrees) -&gt; MKCoordinateRegion {
   guard let item = items.first else {
      return MKCoordinateRegion()
   }
   let span = MKCoordinateSpan(latitudeDelta: 
   latDelta, longitudeDelta: longDelta)
   return MKCoordinateRegion(center: item.coordinate,
   span: span)
}</pre><p>Let's break this down:</p><pre>func initialRegion(latDelta: CLLocationDegrees, longDelta: CLLocationDegrees) -&gt; MKCoordinateRegion</pre><p>This method <a id="_idIndexMarker800"/>takes two parameters and returns an <code>MKCoordinateRegion</code> instance. <code>latDelta</code> specifies the north-to-south distance (measured in degrees) to display for the map region. One degree is approximately 69 miles. <code>longDelta</code> specifies the amount of east-to-west distance (measured in degrees) to display for the map region. The <code>MKCoordinateRegion</code> instance that is returned determines the region that will appear onscreen.</p><pre>guard let item = items.first else { return MKCoordinateRegion() }</pre><p>The <code>guard</code> statement gets the first item in the array of <code>RestaurantItem</code> instances and assigns it to <code>item</code>. If the array is empty, an empty <code>MKCoordinateRegion</code> instance is returned.</p><pre>let span = MKCoordinateSpan(latitudeDelta: latDelta, longitudeDelta: longDelta)</pre><p><code>latDelta</code> and <code>longDelta</code> are used to make an <code>MKCoordinateSpan</code> instance, which is the horizontal and vertical span of the region to be created.</p><pre>return MKCoordinateRegion(center: item.coordinate, span: span)</pre><p>An <code>MKCoordinateRegion</code> instance is created and returned using the coordinate property of <code>item</code> and the <code>MKCoordinateSpan</code> instance.</p></li>
			</ol>
			<p>Now that the map region has been determined, you can determine which <code>RestaurantItem</code> instances are in this region based on their <code>coordinate</code> property. Remember that the <code>RestaurantItem</code> class conforms to <code>MKAnnotation</code>. As the view controller for the map view, the <code>MapViewController</code> class is responsible for providing <code>MKAnnotationView</code> instances for any <code>RestaurantItem</code> instances in this region. </p>
			<p>In the next<a id="_idIndexMarker801"/> section, you'll modify the <code>MapViewController</code> class to provide <code>MKAnnotationViews</code> for the <code>RestaurantItem</code> instances in the region displayed by the map view.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor235"/>Displaying MKAnnotationView instances on the map view</h2>
			<p>At this <a id="_idIndexMarker802"/>point, you have the <code>MapViewController</code> class<a id="_idIndexMarker803"/> to manage the map view on the <code>initialRegion(latDelta:longDelta:)</code> method in the <code>MapDataManager</code> class to set the map region. You will now modify the <code>MapViewController</code> class to get an array of <code>RestaurantItem</code> instances from the <code>MapDataManager</code> class and add it to the map view. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>MapViewController</code> file in the Project navigator and remove the commented code.</li>
				<li>Just after the <code>mapView</code> property declaration, add the following to create an instance of the <code>MapDataManager</code> class and assign it to <code>manager</code>:<pre>private let manager = MapDataManager() </pre></li>
				<li>Add the following method after <code>viewDidLoad()</code>. This method will add <code>RestaurantItem</code> instances (which conform to the <code>MKAnnotation</code> protocol) to the map view:<pre>func setupMap(_ annotations: [RestaurantItem]) {
   mapView.setRegion(manager.initialRegion(
   latDelta: 0.5, longDelta: 0.5), animated: true)
   mapView.addAnnotations(manager.annotations)
}</pre><p>The <code>setupMap(_:)</code> method takes a parameter, <code>annotations</code>, which is an array of <code>RestaurantItem</code> instances. It sets the region of the map to be displayed in the map view using the <code>initialRegion(latDelta:longDelta:)</code> method of the <code>MapDataManager</code> class, then adds each <code>RestaurantItem</code> instance in the <code>annotations</code> array to the map view. The map view's delegate (the <code>MapViewController</code> class in this case) then automatically provides an <code>MKAnnotationView</code> instance for every <code>RestaurantItem</code> instance within the region.</p></li>
				<li>Add <a id="_idIndexMarker804"/>the <a id="_idIndexMarker805"/>following method before the <code>setupMap(_:)</code> method. This calls the <code>fetch(completion:)</code> method of the <code>MapDataManager</code> instance and passes in the <code>setupMap(_:)</code> method as a completion closure:<pre>func initialize() {
   manager.fetch {(annotations) in
   setupMap(annotations)}
}</pre><p>The <code>fetch(completion:)</code> method loads the <code>MapLocations.plist</code> file and creates and assigns the array of <code>RestaurantItem</code> instances to the <code>items</code> array. The <code>annotations</code> property returns a copy of the <code>items</code> array. This array is then processed by the <code>setupMap(_:)</code> method that was passed in as the completion closure.</p></li>
				<li>Call the <code>initialize()</code> method inside <code>viewDidLoad()</code> so it will be called when the map view is loaded:<pre>override func viewDidLoad() { 
   super.viewDidLoad() 
   <strong class="bold">initialize()</strong>
}</pre></li>
			</ol>
			<p>Build and run the application. You should see pins (<code>MKAnnotationView</code> instances) on the <strong class="bold">Map</strong> screen:</p>
			<div><div><img src="img/Figure_16.08_B17469.jpg" alt="Figure 16.8: iOS Simulator showing standard MKAnnotationView instances&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.8: iOS Simulator showing standard MKAnnotationView instances</p>
			<p>An <code>MKAnnotationView</code> instance has been added for each <code>RestaurantItem</code> instance in the map region. Each <code>MKAnnotationView</code> instance is represented by a pin. You now<a id="_idIndexMarker806"/> have <a id="_idIndexMarker807"/>pins showing restaurant locations on your map, but you need to add code to display custom pins as shown in the app tour. You will do that in the next section.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor236"/>Creating custom MKAnnotationView instances</h2>
			<p>Currently, the <code>MKAnnotationView</code> instances, which look like pins. You can replace the standard pin image with a custom image. There is a custom image in the <code>Assets.xcassets</code> file, and you'll configure the <code>MapViewController</code> class to use it. This will make the pins onscreen match the ones in the app tour. You'll also configure each pin to display a callout bubble when tapped. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>MapViewController</code> file in the Project navigator.</li>
				<li>Add the following code inside the <code>initialize()</code> method after the opening curly brace. This makes the <code>MapViewController</code> class the delegate for the map view:<pre>func initialize() {
   <strong class="bold">mapView.delegate = self</strong></pre></li>
				<li>Add the following method after the <code>setupMap(_:)</code> method. This method returns a custom <code>MKAnnotationView</code> instance for every <code>MKAnnotation</code> instance in the region displayed by the map view:<pre>func mapView(_ mapView: MKMapView, viewFor annotation:
MKAnnotation) -&gt; MKAnnotationView? {
   let identifier = "custompin"
   guard !annotation.isKind(of: MKUserLocation.self)
   else { 
      return nil 
   }
   let annotationView: MKAnnotationView
   if let customAnnotationView = 
   mapView.dequeueReusableAnnotationView(
   withIdentifier: identifier) {
      annotationView = customAnnotationView 
      annotationView.annotation = annotation
   } else {
      let av = MKAnnotationView(annotation: 
      annotation, reuseIdentifier: identifier)
      av.rightCalloutAccessoryView = 
      UIButton(type: .detailDisclosure)
      annotationView = av
   }
   annotationView.canShowCallout = true 
   if let image = UIImage(named: 
        "custom-annotation") {
            annotationView.image = image 
            annotationView.centerOffset = CGPoint(
            x: -image.size.width / 2, 
            y: -image.size.height / 2)
   }
   return annotationView
}</pre><p>Let's break <a id="_idIndexMarker809"/>this down:</p><pre>func mapView(_ mapView: MKMapView, viewFor 
annotation: MKAnnotation) -&gt; MKAnnotationView?</pre><p>This is one of the delegate methods specified in the <code>MKMapViewDelegate</code> protocol. It's triggered when an <code>MKAnnotation</code> instance is within the map region, and it returns an <code>MKAnnotationView</code> instance, which the user will see on the screen. You'll use this method to replace the default pins with custom pins.</p><pre>let identifier = "custompin"</pre><p>A constant, <code>identifier</code>, is assigned the <code>"custompin"</code> string. This will be the reuse identifier.</p><pre>guard !annotation.isKind(of: MKUserLocation.self) 
else { 
   return nil 
}</pre><p>In addition to the annotations that you specify, an <code>MKMapView</code> instance will also add an annotation for the user location. This <code>guard</code> statement checks to see whether<a id="_idIndexMarker810"/> the annotation is the user location. If it is, <code>nil</code> is returned, as the user location is not a restaurant location.</p><pre>let annotationView: MKAnnotationView</pre><p><code>annotationView</code> is a constant of the <code>MKAnnotationView</code> type. You create this so that you can configure and return it later.</p><pre>if let customAnnotationView = 
mapView.dequeueReusableAnnotationView (withIdentifier:
identifier) { 
   annotationView = customAnnotationView 
   annotationView.annotation = annotation
}</pre><p>The <code>if</code> statement checks to see whether there are any existing annotations that were initially visible but are no longer on the screen. If there are, the <code>MKAnnotationView</code> instance for that annotation can be reused and is assigned to the <code>annotationView</code> variable. The <code>annotation</code> parameter is assigned to the <code>annotation</code> property of <code>annotationView</code>.</p><pre>else {
   let av = MKAnnotationView(annotation: annotation, 
   reuseIdentifier: identifier) 
   av.rightCalloutAccessoryView = 
   UIButton(type: .detailDisclosure)
   annotationView = av
}</pre><p>The <code>else</code> clause is executed if there are no existing <code>MKAnnotationView</code> instances that can be reused. A new <code>MKAnnotationView</code> instance is created with the reuse identifier specified earlier (<code>custompin</code>). The <code>MKAnnotationView</code> instance is configured with a callout. When you tap a pin on the map, a <a id="_idIndexMarker811"/>callout bubble will appear showing the title (restaurant name), subtitle (cuisines), and a button. You'll program the button later to present the <code>MKAnnotationView</code> instance that you just created to display extra information in a callout bubble and sets the custom image to the <code>custom-annotation</code> image stored in <code>Assets.xcassets</code>. When adding a custom image, the annotation uses the center of the image as the pin point, so the <code>centerOffset</code> property is used to set the correct location of the pin point, at the tip of the pin.</p><pre>return annotationView</pre><p>The custom <code>MKAnnotationView</code> instance is returned.</p></li>
			</ol>
			<p>Build and run your app. You can see the custom pins on your map:</p>
			<div><div><img src="img/Figure_16.09_B17469.jpg" alt="Figure 16.9: iOS Simulator showing custom MKAnnotationView instances&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.9: iOS Simulator showing custom MKAnnotationView instances</p>
			<p>You have configured<a id="_idIndexMarker812"/> the <code>MKAnnotationView</code> instances using the data obtained from the <code>MapDataManager</code> class. Tapping a pin displays a callout bubble showing the restaurant name and the cuisines it offers. Tapping the button in the callout bubble doesn't do anything yet. You'll configure the button to present the <strong class="bold">Restaurant Detail</strong> screen in the next section.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor237"/>Going from the Map screen to the Restaurant Detail screen</h1>
			<p>The <code>MKAnnotationView</code> instances, and tapping one displays a callout bubble showing restaurant details. The button in the callout bubble doesn't work, though. </p>
			<p>Inside the <code>resources</code> folder that you downloaded earlier, you'll find completed storyboards named <code>RestaurantDetail.Storyboard</code>, <code>PhotoFilter.Storyboard</code>, and <code>ReviewForm.Storyboard</code>, which you'll add to your project. These storyboards contain the scenes for the <strong class="bold">Restaurant Detail</strong> screen, the <strong class="bold">Photo Filter</strong> screen and the <strong class="bold">Review Form</strong> screen.</p>
			<p>To present the <code>RestaurantDetail</code> storyboard <a id="_idIndexMarker815"/>file<a id="_idIndexMarker816"/> to it. You'll do this in the next section.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor238"/>Creating and configuring a storyboard reference</h2>
			<p>There are a<a id="_idIndexMarker817"/> lot of<a id="_idIndexMarker818"/> scenes in the <code>Main</code> storyboard file. As your project grows, you'll find it more challenging to keep track of all the scenes in your app. One way to manage this is to create additional storyboard files, and use storyboard references to link them. You will add <code>RestaurantDetail</code>, <code>PhotoFilter</code> and <code>ReviewForm</code> storyboard files to your project, and you will link the <code>Main</code> storyboard file to the <code>RestaurantDetail</code> storyboard file using a storyboard reference. Follow these steps to add a storyboard reference to your project:</p>
			<ol>
				<li value="1">Open the <code>Main</code> storyboard file, and click the Library button.</li>
				<li>Type <code>story</code> in the filter field. A <strong class="bold">Storyboard Reference</strong> object will appear in the results.</li>
				<li>Drag the <code>Main</code> storyboard file next to the <strong class="bold">Map View Controller Scene</strong>:<div><img src="img/Figure_16.10_B17469.jpg" alt="Figure 16.10: Library with Storyboard Reference object selected&#13;&#10;"/></div><p class="figure-caption">Figure 16.10: Library with Storyboard Reference object selected</p></li>
				<li>Open<a id="_idIndexMarker819"/> the <code>resources</code> folder that you downloaded<a id="_idIndexMarker820"/> earlier, and locate the three storyboard files that you will add to your project in it (<code>RestaurantDetail.storyboard</code>, <code>PhotoFilter.storyboard</code>, and <code>ReviewForm.storyboard</code>):<div><img src="img/Figure_16.11_B17469.jpg" alt="Figure 16.11: Contents of resources folder&#13;&#10;"/></div><p class="figure-caption">Figure 16.11: Contents of resources folder</p></li>
				<li>In the Project navigator, create a new folder inside your <code>LetsEat</code> folder named <code>RestaurantDetail</code> and copy the <code>RestaurantDetail</code> storyboard file into it:<div><img src="img/Figure_16.12_B17469.jpg" alt="Figure 16.12: Project navigator showing RestaurantDetail folder and contents&#13;&#10;"/></div><p class="figure-caption">Figure 16.12: Project navigator showing RestaurantDetail folder and contents</p></li>
				<li>Create a <a id="_idIndexMarker821"/>new <a id="_idIndexMarker822"/>folder inside your <code>LetsEat</code> folder named <code>ReviewForm</code> and copy the <code>ReviewForm</code> storyboard file into it, and create a new folder inside your <code>LetsEat</code> folder named <code>PhotoFilter</code> and copy the <code>PhotoFilter</code> storyboard file into it:<div><img src="img/Figure_16.13_B17469.jpg" alt="Figure 16.13: Project navigator showing PhotoFilter and ReviewForm folders and contents&#13;&#10;"/></div><p class="figure-caption">Figure 16.13: Project navigator showing PhotoFilter and ReviewForm folders and contents</p></li>
				<li>Now you'll <a id="_idIndexMarker823"/>assign the <code>RestaurantDetail</code> storyboard <a id="_idIndexMarker824"/>file to the storyboard reference you added earlier to your project. Click the <code>Main</code> storyboard file, select the storyboard reference you added earlier, and click the Attributes inspector button. Under <code>RestaurantDetail</code>:<div><img src="img/Figure_16.14_B17469.jpg" alt="Figure 16.14: Attributes inspector settings for RestaurantDetail storyboard reference&#13;&#10;"/></div><p class="figure-caption">Figure 16.14: Attributes inspector settings for RestaurantDetail storyboard reference</p></li>
				<li><em class="italic">Ctrl + Drag</em> from <a id="_idIndexMarker825"/>the <code>MKAnnotationView</code> instance's callout bubble button in the <strong class="bold">Map</strong> screen.</p></li>
				<li>You will set an identifier for this segue. Later you'll add a method that performs the segue with this identifier when the callout bubble button is tapped. Select the segue connecting the <strong class="bold">Map View Controller Scene</strong> to the storyboard reference:<div><img src="img/Figure_16.16_B17469.jpg" alt="Figure 16.16: Segue between Map View Controller Scene and RestaurantDetail storyboard reference&#13;&#10;"/></div><p class="figure-caption">Figure 16.16: Segue between Map View Controller Scene and RestaurantDetail storyboard reference</p></li>
				<li>In the Attributes inspector, under <code>showDetail</code>:</li>
			</ol>
			<div><div><img src="img/Figure_16.17_B17469.jpg" alt="Figure 16.17: Attributes inspector settings for showDetail segue&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.17: Attributes inspector settings for showDetail segue</p>
			<p>You have now linked the view controller scene for the <strong class="bold">Map</strong> screen with the view controller<a id="_idIndexMarker829"/> scene<a id="_idIndexMarker830"/> for the <strong class="bold">Restaurant Detail</strong> screen using a segue. In the next section, you'll implement a method to present the <strong class="bold">Restaurant Detail</strong> screen when the callout bubble button is tapped.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor239"/>Performing the showDetail segue</h2>
			<p>You've linked the <a id="_idIndexMarker831"/>view controller scene for the <code>showDetail</code>. Now you need a method to perform that segue, but before you implement it, you'll create an enumeration that contains all the segue identifiers for this project. This reduces potential errors by enabling autocompletion when you type the segue identifiers later in your code. Follow these steps:</p>
			<ol>
				<li value="1">Right-click on the <code>Misc</code> folder inside the <code>LetsEat</code> folder and choose <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should already be selected. Choose <strong class="bold">Swift File</strong> and then click <strong class="bold">Next</strong>.</li>
				<li>Name this file <code>Segue</code>. Click <code>Segue</code> file appears in the Project navigator.</li>
				<li>Add the<a id="_idIndexMarker832"/> following after the <code>import</code> statement to declare and define the <code>Segue</code> enumeration:<pre>enum Segue: String { 
   case showDetail 
   case showRating 
   case showReview
   case showAllReviews 
   case restaurantList 
   case locationList 
   case showPhotoReview 
   case showPhotoFilter
}</pre><p>Note that the <code>Segue</code> enum's type is <code>String</code>, so the raw values for each case are strings. For example, the raw value for case <code>showDetail</code> is <code>"showDetail"</code>.</p></li>
			</ol>
			<p>Now you can add the method to perform the <code>showDetail</code> segue when the callout button is tapped. Click the <code>MapViewController</code> file in the Project navigator and add the following method after the <code>setupMap(_:)</code> method:</p>
			<pre>func mapView(_ mapView: MKMapView, annotationView view: 
MKAnnotationView, calloutAccessoryControlTapped control: 
UIControl) {
   self.performSegue(withIdentifier: 
   Segue.showDetail.rawValue, sender: self)
}</pre>
			<p><code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code> is another method specified in the <code>MKMapViewDelegate</code> protocol. It is triggered when the user taps the callout bubble button.  </p>
			<p><code>self.performSegue(withIdentifier: Segue.showDetail.rawValue, sender: self)</code> performs the segue with the <code>"showDetail"</code> identifier, which presents the <strong class="bold">Restaurant Detail</strong> screen.</p>
			<p>Build and run your <a id="_idIndexMarker833"/>project. On the <strong class="bold">Map</strong> screen, tap a pin and tap the button inside the callout bubble:</p>
			<div><div><img src="img/Figure_16.18_B17469.jpg" alt="Figure 16.18: iOS Simulator showing callout bubble button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.18: iOS Simulator showing callout bubble button</p>
			<p>The new <strong class="bold">Restaurant Detail</strong> screen appears, but it does not contain any details about the restaurant:</p>
			<div><div><img src="img/Figure_16.19_B17469.jpg" alt="Figure 16.19: iOS Simulator showing Restaurant Detail screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.19: iOS Simulator showing Restaurant Detail screen</p>
			<p>You will make the <strong class="bold">Restaurant Detail</strong> screen display the details of a restaurant in <a href="B17469_18_Final_VK_ePub.xhtml#_idTextAnchor299"><em class="italic">Chapter 18</em></a><em class="italic">, Displaying Data in a Static Table View</em>, but<a id="_idIndexMarker834"/> for now, let's just pass the data about the selected restaurant to the <strong class="bold">Restaurant Detail</strong> screen's view controller and print it to the Debug area. You will do this in the next section.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor240"/>Passing data to the Restaurant Detail screen</h2>
			<p>The <code>MKAnnotationView</code> instances that display callout bubbles when tapped. When the button in the callout bubble is tapped, the <code>RestaurantItem</code> instance to the view controller for the <strong class="bold">Restaurant Detail</strong> screen, which has not been created yet. Follow these steps to create it now:</p>
			<ol>
				<li value="1">Right-click the <code>RestaurantDetail</code> folder and select <strong class="bold">New File</strong>.</li>
				<li><strong class="bold">iOS</strong> should<a id="_idIndexMarker837"/> already be selected. Choose <strong class="bold">Cocoa Touch Class</strong> and <a id="_idIndexMarker838"/>then click <strong class="bold">Next</strong>.</li>
				<li>Configure the file as follows:<p><code>RestaurantDetailViewController</code></p><p><code>UITableViewController</code> </p><p><code>Swift</code></p><p>Click <strong class="bold">Next</strong>.</p></li>
				<li>Click <code>RestaurantDetailViewController</code> file appears in the Project navigator.</li>
				<li>Remove all the commented code. Your file should look like this:<pre>import UIKit
class RestaurantDetailViewController: 
UITableViewController {
   override func viewDidLoad() {
      super.viewDidLoad()
   }
}</pre></li>
				<li>Declare a property named <code>selectedRestaurant</code> before the <code>viewDidLoad()</code> method:<pre>var selectedRestaurant: RestaurantItem?</pre><p>This property holds the <code>RestaurantItem</code> instance that will be passed to the <code>RestaurantDetailViewController</code> instance from the <code>MapViewController</code> instance:</p></li>
				<li>Add the following code inside the <code>viewDidLoad()</code> method before the closing curly brace to print the <code>RestaurantItem</code> instance contents to the Debug area:<pre>dump(selectedRestaurant as Any)</pre><p>This<a id="_idIndexMarker839"/> confirms <a id="_idIndexMarker840"/>that the <code>MapViewController</code> instance has successfully passed the <code>RestaurantItem</code> instance to the <code>RestaurantDetailViewController</code> instance.</p></li>
				<li>Verify your file looks like the following:<pre>import UIKit
class RestaurantDetailViewController: UITableViewController {
   <strong class="bold">var selectedRestaurant: RestaurantItem?</strong>
   override func viewDidLoad() { 
      super.viewDidLoad() 
      <strong class="bold">dump(selectedRestaurant as Any)</strong>
   }
}</pre></li>
				<li>Click the <code>RestaurantDetail</code> storyboard file inside the <code>RestaurantDetail</code> folder. Select the <code>RestaurantDetailViewController</code>:<div><img src="img/Figure_16.20_B17469.jpg" alt="Figure 16.20: Identity inspector settings for Restaurant Detail View Controller scene&#13;&#10;"/></div><p class="figure-caption">Figure 16.20: Identity inspector settings for Restaurant Detail View Controller scene</p><p>Note the <a id="_idIndexMarker841"/>scene<a id="_idIndexMarker842"/> name will change to <strong class="bold">Restaurant Detail View Controller Scene</strong>.</p></li>
				<li>Click the <code>MapViewController</code> file in the Project navigator.</li>
				<li>Add a property to hold a <code>RestaurantItem</code> instance after the <code>private let manager = MapDataManager()</code> statement:<pre>var selectedRestaurant: RestaurantItem?</pre></li>
				<li>Add the following code into the <code>func mapView(_:annotationView:calloutAccessoryControlTapped:)</code> method, before the  <code>self.performSegue(withIdentifier:sender:)</code> method call:<pre>func mapView(_ mapView: MKMapView, annotationView 
view: MKAnnotationView, calloutAccessoryControlTapped 
control: UIControl){
<code>RestaurantItem</code> instance associated with <code>MKAnnotationView</code> instance that was tapped and assigns it to <code>selectedRestaurant</code>.</p></li>
				<li>To pass <a id="_idIndexMarker843"/>the <code>RestaurantItem</code> instance from the <code>MapViewController</code> instance<a id="_idIndexMarker844"/> to the <code>RestaurantDetailViewController</code> instance, you'll override the <code>UIViewController</code> method named  <code>prepare(for:sender:)</code>. Type in the following code after <code>viewDidLoad()</code>:<pre>override func prepare(for segue: UIStoryboardSegue, sender: Any?){
   switch segue.identifier! {
      case Segue.showDetail.rawValue:
         showRestaurantDetail(segue: segue)
      default:
         print("Segue not added")
   }
}</pre><p>The <code>prepare(for:sender:)</code> method is executed by a view controller before transitioning to another view controller. In this case, this method is called before the <code>showDetail</code>, which it is in this case, the <code>showRestaurantDetail(segue:)</code> method is called. This method will set the <code>selectedRestaurant</code> property for the <code>RestaurantDetailViewController</code> instance. You'll see an error because <code>showRestaurantDetail(segue:)</code> has not been created yet.</p></li>
				<li>Add the<a id="_idIndexMarker845"/> following<a id="_idIndexMarker846"/> code after the <code>setupMap(_:)</code> method to implement <code>showRestaurantDetail(segue:)</code>:<pre>func showRestaurantDetail(segue: UIStoryboardSegue) {
   if let viewController = segue.destination as? 
   RestaurantDetailViewController, let restaurant = 
   selectedRestaurant {
      viewController.selectedRestaurant = restaurant
   }
}</pre><p>This checks to make sure the segue destination is a <code>RestaurantDetailViewController</code> instance. If it is, a temporary constant, <code>restaurant</code>, is assigned the <code>selectedRestaurant</code> property in the <code>MapViewController</code> instance. <code>restaurant</code> is then assigned to the <code>selectedRestaurant</code> property in the <code>RestaurantDetailViewController</code> instance.</p><p>In other words, the restaurant details that you get from the <code>RestaurantItem </code>instance is passed to the <code>RestaurantDetailViewController</code> instance.</p></li>
			</ol>
			<p>Build and run your app. In the <strong class="bold">Map</strong> screen, tap a pin and then tap the callout button. The <strong class="bold">Restaurant Detail</strong> screen will appear. Click the Report navigator and click the first entry as shown. You should see the restaurant details in the Editor area:</p>
			<div><div><img src="img/Figure_16.21_B17469.jpg" alt="Figure 16.21: Report navigator showing contents of first entry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.21: Report navigator showing contents of first entry</p>
			<p>You have added the storyboard for the <code>RestaurantDetailViewController</code> instance now has the data from the <code>RestaurantItem</code> instance that was selected on the <strong class="bold">Map</strong> screen. Great! You'll configure the <strong class="bold">Restaurant Detail</strong> screen to display that data in the next chapter.</p>
			<p>You have done a lot of work in this chapter, so before you go on to the next chapter, let's organize<a id="_idIndexMarker847"/> the<a id="_idIndexMarker848"/> code that you have written to make it easier to understand. You will use extensions to do so in the next section.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor241"/>Organizing your code</h1>
			<p>As your <a id="_idIndexMarker849"/>programs become more complex, you will use extensions (covered in <a href="B17469_08_Final_VK_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a><em class="italic">, Protocols, Extensions, and Error Handling</em>) to organize your code. Extensions can help you to make code more readable and avoid clutter.</p>
			<p>You will organize four classes: <code>ExploreViewController</code>, <code>RestaurantListViewController</code>, <code>LocationViewController</code>, and <code>MapViewController</code>. You will segregate blocks of related code using extensions. Let's begin with the <code>ExploreViewController</code> class in the next section.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor242"/>Refactoring the ExploreViewController class</h2>
			<p>You will <a id="_idIndexMarker850"/>divide the code in the <code>ExploreViewController</code> file into distinct sections using extensions. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>ExploreViewController</code> file in the Project navigator. After the final curly brace, add the following:<pre>// MARK: Private Extension
private extension ExploreViewController {
   // code goes here
}
// MARK: UICollectionViewDataSource
extension ExploreViewController: 
UICollectionViewDataSource {
   // code goes here
}</pre><p>Here, you are creating two extensions. The first extension will be private, which means the contents of this extension are only accessible to the <code>ExploreViewController</code> class. The second extension will contain all of the <code>UICollectionViewDataSource</code> methods.</p></li>
				<li>You'll get an error because <code>UICollectionViewDataSource</code> appears in two places. Delete <code>UICollectionViewDataSource</code> from the class declaration at the top of the file. Your class declaration should look like this:<pre>class ExploreViewController: UIViewController, UICollectionViewDelegate {</pre></li>
				<li>Move all the <code>UICollectionViewDataSource</code> methods into the second extension. It should look like this:<pre>// MARK: UICollectionViewDataSource
extension ExploreViewController: 
UICollectionViewDataSource {
   <code>viewDidLoad()</code> as clean as possible, you will create an <code>initialize()</code> method inside the <code>private</code> extension, and put everything you need to initialize the view controller in there. After that, you will call <code>initialize()</code> in <code>viewDidLoad()</code>. </p></li>
				<li>Add <a id="_idIndexMarker851"/>the <code>initialize()</code> method inside the <code>private</code> extension:<pre>func initialize() {
   manager.fetch()
}</pre></li>
				<li>Move the <code>unwindLocationCancel(segue:)</code> method inside the <code>private</code> extension as well.</li>
				<li>Verify that the private extension looks like this:<pre>// MARK: Private Extension
private extension ExploreViewController {
<strong class="bold">   func initialize() {</strong>
<strong class="bold">      manager.fetch()</strong>
<strong class="bold">   }</strong>
<strong class="bold">   @IBAction func unwindLocationCancel(segue:</strong>
<strong class="bold">   UIStoryboardSegue) {</strong>
<strong class="bold">   }</strong>
}</pre></li>
				<li>Finally, modify <code>viewDidLoad()</code> as follows:<pre>override func viewDidLoad() { 
   super.viewDidLoad() 
   <strong class="bold">initialize()</strong>
}</pre></li>
			</ol>
			<p>The benefits of segregating your code in this way may not seem obvious now, but as your classes become more complex, you will find it is easier to look for a specific method and to <a id="_idIndexMarker852"/>maintain your code. Before you do the same to the other files, let's see how the <code>// MARK:</code> syntax is used in the next section.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor243"/>Using the // MARK: syntax</h2>
			<p>The <code>// MARK:</code> syntax is <a id="_idIndexMarker853"/>used to navigate easily between different parts of your code. Let's see what it does:</p>
			<ol>
				<li value="1">Look at the path that is visible just under the Toolbar and click on the last part as shown:<div><img src="img/Figure_16.22_B17469.jpg" alt="Figure 16.22: Editor area showing path&#13;&#10;"/></div><p class="figure-caption">Figure 16.22: Editor area showing path</p></li>
				<li>A menu is displayed, and you will see both <code>// MARK:</code> syntax. This enables you to easily jump to these sections:</li>
			</ol>
			<div><div><img src="img/Figure_16.23_B17469.jpg" alt="Figure 16.23: Path menu with Private extension selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.23: Path menu with Private extension selected</p>
			<p>You have <a id="_idIndexMarker854"/>organized the <code>ExploreViewController</code> class, so let's do the <code>RestaurantListViewController</code> class next by refactoring it and adding extensions.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor244"/>Refactoring the RestaurantListViewController class</h2>
			<p>You will add<a id="_idIndexMarker855"/> two extensions to the <code>RestaurantListViewController</code> class, similar to those you added to the <code>ExploreViewController</code> class. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>RestaurantListViewController</code> file in the Project navigator. After the final curly brace, add the following:<pre>// MARK: Private Extension
private extension RestaurantListViewController {
   // code goes here
}
// MARK: UICollectionViewDataSource 
extension RestaurantListViewController: 
UICollectionViewDataSource {
   // code goes here
}</pre><p>You'll put private methods for the <code>RestaurantListViewController</code> class in the first extension, and all the <code>UICollectionViewDataSource</code> methods in the second extension.</p></li>
				<li>Delete <code>UICollectionViewDataSource</code> from the class declaration at the top of the<a id="_idIndexMarker856"/> file. Your class declaration should look like this:<pre>class RestaurantListViewController: UIViewController, UICollectionViewDelegate {</pre></li>
				<li>Move all the <code>UICollectionViewDataSource</code> methods into the second extension. It should look like this when done:<pre>// MARK: UICollectionViewDataSource extension 
RestaurantListViewController: 
UICollectionViewDataSource {
<strong class="bold">   func collectionView(_ collectionView: </strong>
<strong class="bold">   UICollectionView, numberOfItemsInSection </strong>
<strong class="bold">   section: Int) -&gt; Int {</strong>
<strong class="bold">      1</strong>
<strong class="bold">   }</strong>
<strong class="bold">   func collectionView(_ collectionView: </strong>
<strong class="bold">   UICollectionView, cellForItemAt indexPath: </strong>
<strong class="bold">   IndexPath) -&gt; UICollectionViewCell {</strong>
<strong class="bold">      collectionView.dequeueReusableCell(</strong>
<strong class="bold">      withReuseIdentifier: "restaurantCell", </strong>
<strong class="bold">      for: indexPath)</strong>
<strong class="bold">   }</strong>
}</pre></li>
			</ol>
			<p>You are done organizing the <code>RestaurantListViewController</code> class, so let's clean up <a id="_idIndexMarker857"/>the <code>LocationViewController</code> class in the next section.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor245"/>Refactoring the LocationViewController class</h2>
			<p>As you did<a id="_idIndexMarker858"/> before, you will add two extensions to the <code>LocationViewController</code> file. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>LocationViewController</code> file in the Project navigator. After the final curly brace, add the following:<pre>// MARK: Private Extension
private extension LocationViewController {
   // code goes here
}
// MARK: UITableViewDataSource
extension LocationViewController: 
UITableViewDataSource {
   // code goes here
}</pre><p>The first extension will contain private methods for the <code>LocationViewController</code> class. The second extension will contain all the <code>UITableViewDataSource</code> methods.</p></li>
				<li>Delete <code>UITableViewDataSource</code> from the class declaration at the top of the file. Your class declaration should look like this: <pre>class LocationViewController: UIViewController {</pre></li>
				<li>Move all the <code>UITableViewDataSource</code> methods into the second extension. It should <a id="_idIndexMarker859"/>look like this:<pre>// MARK: UITableViewDataSource
extension LocationViewController: UITableViewDataSource 
{
   <strong class="bold">func tableView(_ tableView: UITableView, </strong>
<strong class="bold">   numberOfRowsInSection section: Int) -&gt; Int {</strong>
<strong class="bold">      manager.numberOfLocationItems()</strong>
<strong class="bold">   }</strong>
   <strong class="bold">func tableView(_ tableView: UITableView, </strong>
<strong class="bold">   cellForRowAt indexPath: IndexPath) -&gt; </strong>
<strong class="bold">   UITableViewCell {</strong>
<strong class="bold">      let cell = tableView.dequeueReusableCell(</strong>
<strong class="bold">      withIdentifier: "locationCell", for: indexPath)</strong>
<strong class="bold">      cell.textLabel?.text = </strong>
<strong class="bold">      manager.locationItem(at: indexPath.row)</strong>
<strong class="bold">      return cell</strong>
<strong class="bold">   }</strong>
}</pre></li>
				<li>Just like you did in the <code>ExploreViewController</code> class, you will create an <code>initialize()</code> method inside the first extension, and put in it everything you need to initialize the <code>LocationViewController</code> class there. Add the following inside the first extension:<pre>// MARK: Private Extension
private extension LocationViewController {
<strong class="bold">   func initialize() {</strong>
<strong class="bold">      manager.fetch()</strong>
<strong class="bold">   }</strong>
}</pre></li>
				<li>Modify <code>viewDidLoad()</code> as follows to call the <code>initialize()</code> method:<pre>override func viewDidLoad() { 
   super.viewDidLoad() 
   <strong class="bold">initialize()</strong>
}</pre></li>
			</ol>
			<p>You are done <a id="_idIndexMarker860"/>organizing the <code>LocationViewController</code> class, so let's clean up the <code>MapViewController</code> class in the next section.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor246"/>Refactoring the MapViewController class</h2>
			<p>As you did<a id="_idIndexMarker861"/> before for the other classes, you will add two extensions to the <code>MapViewController</code> class. Follow these steps:</p>
			<ol>
				<li value="1">Click the <code>MapViewController</code> file in the Project navigator. After the final curly brace, add the following:<pre>// MARK: Private Extension
private extension MapViewController {
   // code goes here
}
// MARK: MKMapViewDelegate
extension MapViewController: MKMapViewDelegate {
   // code goes here
}</pre><p>The first extension will contain private methods for the <code>MapViewController</code> class. The second one will contain all the <code>MKMapViewDelegate</code> methods.</p></li>
				<li>Delete <code>MKMapViewDelegate</code> from the class declaration at the top of the file. Your class definition should look like this:<pre>class MapViewController: UIViewController {</pre></li>
				<li>Move all <a id="_idIndexMarker862"/>the <code>MKMapViewDelegate</code> methods into the second extension. It should look like this:<pre>// MARK: MKMapViewDelegate
extension MapViewController: MKMapViewDelegate {
<strong class="bold">   func mapView(_ mapView: MKMapView, annotationView </strong>
<strong class="bold">   view: MKAnnotationView, </strong>
<strong class="bold">   calloutAccessoryControlTapped control: UIControl){</strong>
<strong class="bold">      guard let annotation = </strong>
<strong class="bold">      mapView.selectedAnnotations.first else </strong>
<strong class="bold">      { </strong>
<strong class="bold">         return </strong>
<strong class="bold">      }</strong>
<strong class="bold">      selectedRestaurant = annotation as? </strong>
<strong class="bold">      RestaurantItem </strong>
<strong class="bold">      self.performSegue(withIdentifier: </strong>
<strong class="bold">      Segue.showDetail.rawValue, sender: self)</strong>
<strong class="bold">   }</strong>
<strong class="bold">   func mapView(_ mapView: MKMapView, viewFor </strong>
<strong class="bold">   annotation:MKAnnotation) -&gt; MKAnnotationView? {</strong>
<strong class="bold">      let identifier = "custompin"</strong>
<strong class="bold">      guard !annotation.isKind(of: </strong>
<strong class="bold">      MKUserLocation.self) else { </strong>
<strong class="bold">         return nil </strong>
<strong class="bold">      }</strong>
<strong class="bold">      let annotationView: MKAnnotationView</strong>
<strong class="bold">      if let customAnnotationView = mapView.</strong>
<strong class="bold">      dequeueReusableAnnotationView(withIdentifier: </strong>
<strong class="bold">      identifier) { </strong>
<strong class="bold">         annotationView = customAnnotationView </strong>
<strong class="bold">         annotationView.annotation = annotation</strong>
<strong class="bold">      } else {</strong>
<strong class="bold">         let av = MKAnnotationView(annotation: </strong>
<strong class="bold">         annotation, reuseIdentifier: identifier)</strong>
<strong class="bold">         av.rightCalloutAccessoryView = </strong>
<strong class="bold">         UIButton(type: .detailDisclosure)</strong>
<strong class="bold">         annotationView = av</strong>
<strong class="bold">      }</strong>
<strong class="bold">      annotationView.canShowCallout = true</strong>
<strong class="bold">      if let image = UIImage(named: "custom-</strong>
<strong class="bold">      annotation") { </strong>
<strong class="bold">         annotationView.image = image</strong>
<strong class="bold">         annotationView.centerOffset = </strong>
<strong class="bold">         CGPoint(x: -image.size.width / 2, </strong>
<strong class="bold">         y: -image.size height / 2 )</strong>
<strong class="bold">      }</strong>
<strong class="bold">      return annotationView</strong>
<strong class="bold">   }</strong>
}</pre></li>
				<li>Move the <code>initialize()</code>, <code>setupMap(_:)</code>, and <code>showRestaurantDetail(segue:)</code> methods into the first extension. It should look<a id="_idIndexMarker863"/> like this: <pre>// MARK: Private Extension
private extension MapViewController {
<strong class="bold">   func initialize() { </strong>
<strong class="bold">   mapView.delegate = self </strong>
<strong class="bold">   manager.fetch { (annotations) in </strong>
<strong class="bold">      setupMap(annotations) }</strong>
<strong class="bold">   }</strong>
<strong class="bold">   func setupMap(_ annotations: [RestaurantItem]) {</strong>
<strong class="bold">      mapView.setRegion(manager.currentRegion(</strong>
<strong class="bold">      latDelta: 0.5, longDelta: 0.5), animated: true)</strong>
<strong class="bold">      mapView.addAnnotations(manager.annotations)</strong>
<strong class="bold">   }</strong>
<strong class="bold">   func showRestaurantDetail(segue:UIStoryboardSegue){</strong>
<strong class="bold">      if let viewController = segue.destination as?</strong>
<strong class="bold">      RestaurantDetailViewController, let restaurant </strong>
<strong class="bold">      = selectedRestaurant {</strong>
<strong class="bold">         viewController.selectedRestaurant </strong>
<strong class="bold">         = restaurant</strong>
<strong class="bold">      }</strong>
<strong class="bold">   }</strong>
}</pre></li>
			</ol>
			<p>You have organized all four view controllers (<code>ExploreViewController</code>, <code>RestaurantListViewController</code>, <code>LocationViewController</code>, and <code>MapViewController</code>) using<a id="_idIndexMarker864"/> extensions. Great job!</p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor247"/>Summary</h1>
			<p>In this chapter, you created a new class, <code>RestaurantItem</code>, that conforms to the <code>MKAnnotation</code> protocol. Next, you created <code>MapDataManager</code>, a data manager class that loads restaurant data from a <code>.plist</code> file and puts it into an array of <code>RestaurantItem</code> instances. You created the <code>DataManager</code> protocol and refactored both <code>MapDataManager</code> and <code>ExploreDataManager</code> classes to use this protocol. After that, you created the <code>MapViewController</code> class, a view controller for the <code>RestaurantDetailViewController</code> class, a view controller for the <code>MapViewController</code> instance. At this point, you know how to create objects that conform to the <code>MKAnnotation</code> protocol, how to add them to a map view, and how to create custom <code>MKAnnotationViews</code>, which enables you to add annotated maps to your own projects.</p>
			<p>You also added storyboard files to your project, learned how to use storyboard references and organized your view controller classes (<code>ExploreViewController</code>, <code>RestaurantListViewController</code>, <code>LocationViewController</code>, and <code>MapViewController</code>) using extensions. This will help you organize storyboards and code for large projects, making it easier to read and maintain. </p>
			<p>In the next chapter, you'll learn about <strong class="bold">JSON</strong> files, and how to load data from them so the <strong class="bold">Restaurant List</strong> and <strong class="bold">Map</strong> screens can display details about a particular restaurant.</p>
		</div>
	</body></html>