<html><head></head><body>
		<div><h1 id="_idParaDest-127"><em class="italic"><a id="_idTextAnchor324"/>Chapter 9</em>: Test-Driven Input View in SwiftUI</h1>
			<p>In 2019, Apple introduced <strong class="bold">SwiftUI</strong> as a new way to build user interfaces for apps on Apple platforms. In contrast to user interfaces built with UIKit, SwiftUI views are a function of some kind of state. As a result, testing such views can be very easy. In a test, we would have to set the state and assert that the expected user interface elements are present.</p>
			<p>Unfortunately, the engineers in charge at Apple believe that there is no value in testing user interfaces. They believe that to prove the user interface looks and works as expected, it's enough to run the app and check with your eyes. This might be true for an app as simple as the one we are building in this book. But, if you have a look in the App Store, you will find most of the apps (if not all) are way more complicated. Usually, apps consist of many views and some of them are only visible in some rare cases. Ensuring that those views work for all input values and environment parameters is a lot of work.</p>
			<p>Also, think about refactoring. Apps are never finished. We need to change and add features all the time. How do engineers make sure that all previous features still work?</p>
			<p>Automatic tests performed by a computer are faster than manual tests by several orders of magnitude. In my opinion, engineers not using automatic tests, even for user interfaces, wastes time and money.</p>
			<p>So, what do we do when we want to build a user interface using SwiftUI and still rely on the advantages of test-driven development? Fortunately, there is a third-party library called <strong class="bold">ViewInspector</strong> on GitHub that fills this gap. In this chapter, we will add this library to our project and explore how we can write unit tests for SwiftUI code.</p>
			<p>This chapter is structured into the following sections:</p>
			<ul>
				<li>Adding the ViewInspector package</li>
				<li>Using ViewInspector to test a simple view</li>
				<li>Testing button actions with ViewInspector</li>
			</ul>
			<p>Let's start by adding ViewInspector to our test target.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor325"/>Technical requirement</h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09</a>.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor326"/>Adding the ViewInspector package</h1>
			<p>ViewInspector is<a id="_idIndexMarker356"/> an open source library that you can find on GitHub: <a href="https://github.com/nalexn/ViewInspector">https://github.com/nalexn/ViewInspector</a>. To <a id="_idIndexMarker357"/>add it to<a id="_idIndexMarker358"/> our project, follow these steps:</p>
			<ol>
				<li>Select the <strong class="bold">File</strong> | <strong class="bold">Add Packages</strong> menu item in Xcode.</li>
				<li>Type into the search field the URL of the package, <code>https://github.com/nalexn/ViewInspector</code>:</li>
			</ol>
			<div><div><img src="img/Figure_9.01_B18127.jpg" alt="Figure 9.1 – Add the ViewInspector package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Add the ViewInspector package</p>
			<p>Click <strong class="bold">Add Package</strong>.</p>
			<ol>
				<li value="3">Xcode presents a new window in which we can set the target to which the package should <a id="_idIndexMarker359"/>be added. Select the <strong class="bold">ToDoTests</strong> target. Then click <strong class="bold">Add Package</strong> again.</li>
			</ol>
			<p>The package is now added to the <strong class="bold">ToDoTests</strong> target and we can use it in our unit tests.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor327"/>Using ViewInspector to test a simple view</h1>
			<p>The view we <a id="_idIndexMarker360"/>are going to build will be used to add <a id="_idIndexMarker361"/>new to-do items to the list of items. This means it needs input fields for all information a to-do item can hold. So, let's look into that aspect in the next subsections.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor328"/>Adding a title text field</h2>
			<p>As always, we <a id="_idIndexMarker362"/>start with the test. Follow these steps to add a text field for the title of a to-do item to the input view:</p>
			<ol>
				<li value="1">Select the <code>ToDoItemInputViewTests</code>. Remove the two template test methods.</li>
				<li>Import the <code>ViewInspector</code> library and the main target (<code>ToDo</code>) so that it is testable (<code>@testable</code>):<pre>// ToDoItemInputViewTests.swift
import XCTest
@testable import ToDo
import ViewInspector</pre></li>
				<li>Before we can write tests for a SwiftUI view, we first need to extend it with the <code>Inspectable</code> protocol from the <code>ViewInspector</code> library. Add the following line right above the test case class:<pre>// ToDoItemInputViewTests.swift
extension ToDoItemInputView: Inspectable {}</pre></li>
			</ol>
			<p>At this point, Xcode complains that it <strong class="bold">Cannot find type 'ToDoItemInputView' in scope</strong>. That was expected as we haven't added this type yet.</p>
			<ol>
				<li value="4">Select<a id="_idIndexMarker363"/> the <strong class="bold">ToDo</strong> group in the project navigator and add a SwiftUI file:</li>
			</ol>
			<div><div><img src="img/Figure_9.02_B18127.jpg" alt="Figure 9.2 – Select the SwiftUI template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Select the SwiftUI template</p>
			<ol>
				<li value="5">Put <code>ToDoItemInputView.swift</code> in the <strong class="bold">Save As</strong> field:</li>
			</ol>
			<div><div><img src="img/Figure_9.03_B18127.jpg" alt="Figure 9.3 – The name of the new file is ToDoItemInputView.swift&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The name of the new file is ToDoItemInputView.swift</p>
			<p>Now, the <a id="_idIndexMarker364"/>error in the test code is gone and we can continue with the test.</p>
			<ol>
				<li value="6">Add a property for the system under test and for the data object holding the information for the new to-do item:<pre>// ToDoItemInputViewTests.swift
var sut: ToDoItemInputView!
var toDoItemData: ToDoItemData!</pre></li>
			</ol>
			<p>We will fill <code>toDoitemData</code> with the data the user puts into the view, and when they are finished, we will create a <code>ToDoItem</code> instance from that data.</p>
			<p>Again, Xcode tells us that something is missing.</p>
			<ol>
				<li value="7">Select the <code>ToDoItemData</code> as the name.</li>
				<li>Replace the contents of this file with the following code:<pre>// ToDoItemData.swift
import Foundation 
 
class ToDoItemData: ObservableObject {
}</pre></li>
			</ol>
			<p>This new<a id="_idIndexMarker365"/> type needs to be the <code>ObservableObject</code> type because we want to use it as the state of our SwiftUI view.</p>
			<ol>
				<li value="9">Go back to the <code>ToDoItemInputViewTests</code> class and replace <code>setUpWithError()</code> and <code>tearDownWithError()</code> with the following code:<pre>// ToDoItemInputViewTests .swift
override func setUpWithError() throws {
  toDoItemData = ToDoItemData()
  sut = ToDoItemInputView(data: toDoItemData)
}
 
override func tearDownWithError() throws {
  sut = nil
  toDoItemData = nil
}</pre></li>
				<li>The preceding code does not compile, as the initializer of <code>ToDoItemInputView</code> doesn't take any arguments. To fix the compilation error, add the following property to <code>ToDoItemInputView</code>:<pre>// ToDoItemInputView.swift
@ObservedObject var data: ToDoItemData</pre></li>
				<li>Now, Xcode shows an error in the <code>ToDoItemInputView_Previews</code> structure because the new property is missing in the initializer of <code>ToDoItemInputView</code>. Replace the contents of the <code>ToDoItemInputView_Previews</code> structure with the following code to fix this error:<pre>// ToDoItemInputView.swift
static var previews: some View {
  ToDoItemInputView(data: ToDoItemData())
}</pre></li>
				<li>Now, let's <a id="_idIndexMarker366"/>get back to the test case class. Add the following fragment of a test method to <code>ToDoItemInputViewTests</code>:<pre>// ToDoItemInputViewTests.swift
func test_titleInput_shouldSetValueInData() throws {
  let expected = "dummy title"
  try sut
    .inspect()
    .find(ViewType.TextField.self)
    .setInput(expected)
 
  let input = toDoItemData.title
}</pre></li>
			</ol>
			<p>The <code>toDoItemData</code> type has no <code>title</code> property. We will fix this in the next step. But first, let's try to understand what is happening here.</p>
			<p>First, we call <code>inspect()</code> on the system under test (<code>sut</code>). This is possible because we extended the <code>ToDoItemInputView</code> call with conformance to the <code>Inspectable</code> protocol. On the returned type, we can call the <code>find</code> method that returns the first instance of the given type, in this case, the <code>TextField</code> type. On the value that is returned from the <code>find</code> call, we call <code>setInput(_:)</code> to simulate user input to that text field.</p>
			<ol>
				<li value="13">Add the following <code>title</code> property to <code>ToDoItemData</code>:<pre>// ToDoItemData.swift
@Published var title = ""</pre></li>
				<li>Finish <a id="_idIndexMarker367"/>the test with the following <code>Assert</code> function call:<pre>// ToDoItemInputViewTests.swift
func test_shouldAllowTitleInput() throws {
  let expected = "dummy title"
  try sut
    .inspect()
    .find(ViewType.TextField.self)
    .setInput(expected)
 
  let input = toDoItemData.title
 
  XCTAssertEqual(input, expected)
}</pre></li>
			</ol>
			<p>Run the tests to confirm that this new test fails. The test fails in the line where we try to find the <code>TextField</code> element.</p>
			<ol>
				<li value="15">Replace the content of the <code>body</code> property in <code>ToDoItemInputView</code> with the following code:<pre>// ToDoItemInputVi<a id="_idTextAnchor329"/><a id="_idTextAnchor330"/>ew.swift
TextField("Title", text: $data.title)</pre></li>
			</ol>
			<p>Run the tests again. Now all tests pass but we haven't seen the assertion fail. The test failed previously because it could not find a <code>TextField</code> element in the body of the view. Is this a problem? It could be. If we are not careful, we could write an assertion that always passes. So, it is a good idea to change the code in a way that the assertion fails but the rest of the test passes.</p>
			<ol>
				<li value="16">Replace the <code>ToDoItemInputView</code> structure with the following code:<pre>// ToDoItemInputView.swift
struct ToDoItemInputView: View { 
  @ObservedObject var data: ToDoIt<a id="_idTextAnchor331"/><a id="_idTextAnchor332"/>emData
  @State var dummy: String = ""
  
  var body: some View {
    TextField("Title", text: $dummy)
  }
}</pre></li>
			</ol>
			<p>Here we have <a id="_idIndexMarker368"/>added a dummy variable to act as the binding for the text of <code>TextField</code>. Run the tests to confirm that the last added test now fails at the assertion. As we have checked that the assertion can fail, we can change the code so that the test passes again.</p>
			<p>That was easy. With the help of <code>ViewInspector</code>, we were able to write a test for the input text field of the title for the to-do item.</p>
			<p>In the next section, we will add a <code>DatePicker</code>  structure to allow the user to add due dates to to-do items.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor333"/>Adding a DatePicker </h2>
			<p>The title is <a id="_idIndexMarker369"/>the only required data of a to-do item. The date is optional. In the user interface of the input view, we want to use a <code>DatePicker</code> structure for the input of the date value. We will use a toggle to show the <code>DatePicker</code> structure when the user wants to add a date for that to-do item. </p>
			<p>This means we first need a test that asserts that the view initially doesn't show a date picker. Add the following test method to <code>ToDoItemInputView</code>:</p>
			<pre>// ToDoItemInputViewT<a id="_idTextAnchor334"/><a id="_idTextAnchor335"/>ests.swift
func test_whenWithoutDate_shouldNotShowDateInput() {
  XCTAssertThrowsError(try sut
    .inspect()
    .find(ViewType.DatePicker.self))
}</pre>
			<p>With this code, we assert that the code in the parameter of the <code>XCTAssertThrowsError</code> function throws an error. This means we test that there is no <code>DatePicker</code> in the view. The test fails if the <code>find</code> method finds a <code>DatePicker</code>.</p>
			<p>We don't have to do anything to make this test pass. It already passes. We could add a <code>DatePicker</code> to see it failing. Actually, we will do that next.</p>
			<p>The <a id="_idIndexMarker370"/>toggle element to show and hide the date picker will be bound to a <code>@State</code> property with the <code>withDate</code> property defined in <code>ToDoItemInputView</code>. As a result, the state of the toggle element will be reflected in the value of the <code>withDate</code> property. Interacting with a <code>@State</code> property from a unit test needs some change of the view code. We will start the implementation of the date input with the following change:</p>
			<ol>
				<li value="1">Replace the <code>ToDoItemInputView</code> structure with the following code:<pre>// ToDoItemInputView.swift
struct ToDoItemInputView: View { 
  @ObservedObject var data: ToD<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/>oItemData
  var didAppear: ((Self) -&gt; Void)?
  
  var body: <a id="_idTextAnchor338"/><a id="_idTextAnchor339"/>some View {
    VStack {
      TextField("Title", text: $data.title<a id="_idTextAnchor340"/><a id="_idTextAnchor341"/>)
    }
    .onAppear { self.didAppear?(self) }
  }
}</pre></li>
			</ol>
			<p>We added here a closure with a <code>didAppear</code> name that is called in the <code>onAppear</code> modifier of the <code>VStack</code> structure. We need a <code>VStack</code> structure or something similar here because, later in these steps, we will add more elements to the body of the view.</p>
			<ol>
				<li value="2">With<a id="_idIndexMarker371"/> this preparation we can add the first fragment of the test:<pre>// ToDoItemInputVie<a id="_idTextAnchor342"/><a id="_idTextAnchor343"/>wTests.swift
func test_whenWithDate_shouldAllowDateInput() throws {
  let exp = sut.on(\.didAppear) { view in
    try view.find(ViewType.Toggle.self).tap()
    let expected = Date(timeIntervalSinceNow:
      1_000_000)
    try view
      .find(ViewType.DatePicker.self)
      .select(date: expected)
 
    let input = self.toDoItemData.date
  }
 
  ViewHosting.host(view: sut)
  wait(for: [exp], timeout: 0.1)
}</pre></li>
			</ol>
			<p>We start the test method with an expectation. It is needed here to make updating the <code>@State</code> property accessible in the test. The reason for that lies in the implementation details of view updates in SwiftUI. </p>
			<p>All the communication with the system under test has to be put into the closure of the expectation we define using <code>sut.on(\.didAppear) {}</code>.</p>
			<p>In the closure, we first switch the toggle to make the date picker appear. Next, we search for the <code>DatePicker</code> and we try to set its date. Then we access the date of the <code>toDoItemDate</code> property. The test is not finished, but we have to pause here because the <code>Date</code> property is missing.</p>
			<p>Below the<a id="_idIndexMarker372"/> closure, we ask the <code>ViewInspector</code> library to host the system under test. This triggers the <code>onAppear</code> closure and makes working with <code>@State</code> properties possible. Finally, we have to wait for the expectation to be fulfilled. We don't have to call <code>fulfill()</code> on the expectation ourselves. This is managed by the <code>ViewInspector</code> library.</p>
			<ol>
				<li value="3">Go to <code>ToDoItemData</code> and add the <code>Date</code> property:<pre>// ToDoI<a id="_idTextAnchor344"/><a id="_idTextAnchor345"/>temData.swift
@Published var date = Date()</pre></li>
				<li>Now, we can finish the test by adding the <code>Assert</code> function call:<pre>// ToDoItemInputView.swift
func test_whenWithDate_shouldAllowDateInput() throws {
  let exp = sut.on(\.didAppear) { view in
    try view.find(ViewType.Toggle.self).tap()
 
    let expected = Date(timeIntervalSinceNow:
      1_000_000)
    try view
      .find(ViewType.DatePicker.self)
      .select(date: expected)
 
    let input = self.toDoItem<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/>Data.date
    XCTAssertEqual(input, expected)
  }
 
  ViewHosting.host(view: sut)
  wait(for: [exp], timeout: 0.1)
}</pre></li>
			</ol>
			<p>Run all tests to confirm that this new test is failing. It fails because it can't find the toggle. Let's add the toggle in the next step.</p>
			<ol>
				<li value="5">Add the following property for the state of the toggle we are about to add:<pre>// ToDoItemIn<a id="_idTextAnchor348"/><a id="_idTextAnchor349"/>putView.swift
@State var withDate = false</pre></li>
				<li>Next, replace<a id="_idIndexMarker373"/> the contents of the computed <code>body</code> property with the following code:<pre>// ToDoItemInputView.swift
VStack {
  TextField("Title", text<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/>: $data.title)
  Toggle("Add Date", isOn: $withDate)
}
.onAppear { self.didAppear?(self) }</pre></li>
			</ol>
			<p>Now the test fails because it can't find the date picker.</p>
			<ol>
				<li value="7">Add the date picker as follows:<pre>// ToDoItemInputView.swift
VStack {
  TextField("Title", text: $data.title)
  Toggle("Add Date", isOn<a id="_idTextAnchor352"/><a id="_idTextAnchor353"/>: $withDate)
  DatePicker("Date", selection: $data.date)
}
.onAppear { self.didAppear?(self) }</pre></li>
			</ol>
			<p>Now, <code>test_whenWithDate_shouldAllowDateInput</code> passes but <code>test_whenWithoutDate_shouldNotShowDateInput</code> fails. This is a good thing because we haven't seen this test fail until now. </p>
			<ol>
				<li value="8">To make <a id="_idIndexMarker374"/>both tests pass, replace the code of the computed <code>body</code> property with the following:<pre>// ToDoItemInputView.swift
var body: some Vi<a id="_idTextAnchor354"/><a id="_idTextAnchor355"/>ew {
  VStack {
    TextField("Title", text: $data.title)
    Toggle("Add Date", i<a id="_idTextAnchor356"/><a id="_idTextAnchor357"/>sOn: $withDate)
    if withDate {
      DatePicker("Date", selection: $data.date)
    }
  }
  .onAppear { self.didAppear?(self) }
}</pre></li>
			</ol>
			<p>Run all tests to confirm that all tests pass again.</p>
			<p>In making the last test pass, we learned what we have to do to test changes where a <code>@State</code> property is involved. This was shown here because you need to know this when you start writing tests for SwiftUI views.</p>
			<p>Now that we have seen how to test changes to <code>@State</code> properties, let's refactor the test code and the implementation to make both easier to understand.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor358"/>Improving the test code and the implementation</h2>
			<p>For<a id="_idIndexMarker375"/> our app, it would be better if we move the <code>withDate</code> property to <code>ToDoItemData</code> because we need this information when we try to create the to-do item. Follow these steps to move that property to <code>ToDoItemData</code>:</p>
			<ol>
				<li value="1">Go to <code>ToDoItemInputTests</code> and replace <code>test_whenWithDate_shouldAllowDateInput()</code> with the following implementation:<pre>// ToDoItem<a id="_idTextAnchor359"/><a id="_idTextAnchor360"/>InputTests.swift
func test_whenWithDate_shouldAllowDateInput() throws {
  let expected = Date()
  try sut.inspect().find(ViewType.Toggle.self).tap()
  try sut
    .inspect()
    .find(ViewType.DatePicker.self)
    .select(date: expected)
 
  let input = toDoItemData.date
 
  XCTAssertEqual(input, expected)
}</pre></li>
			</ol>
			<p>Run all tests. This<a id="_idIndexMarker376"/> test now fails because we can't interact with a <code>@State</code> property this way.</p>
			<ol>
				<li value="2">Delete the <code>@State var withDate = false</code> line from <code>ToDoItemInputView</code>.</li>
				<li>Go to <code>ToDoItemData</code> and add the following property:<pre>// T<a id="_idTextAnchor361"/><a id="_idTextAnchor362"/>oDoItemData.swift
@Published var withDate = false</pre></li>
				<li>Now in <code>ToDoItemInputView</code>, replace all occurrences of <code>withDate</code> with <code>data.withDate</code>:<pre>// ToDoItemInputView.swift
var body: some View {
  VStack {
    TextField("Title", text: $data.title)
    Toggle("Add Date", isOn: $data.withDate)
    if data.withDate {
      DatePicker("Date", selection: $data.date)
    }
  }
}</pre></li>
			</ol>
			<p>Note that we have removed the <code>.onAppear</code> call below the closing brace of  <code>VStack</code>. As it<a id="_idIndexMarker377"/> is not needed anymore, you can also remove the <code>didAppear</code> property from <code>ToDoItemInputView</code>.</p>
			<p>Run all tests to confirm that all tests now pass again.</p>
			<p>We now have an input view for the title and the date of a to-do item. Next, we need a text field for the item description. </p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor363"/>Adding another text field</h2>
			<p>Follow these <a id="_idIndexMarker378"/>steps to add another text field to the input view:</p>
			<ol>
				<li value="1">Go to <code>ToDoItemInputViewTests</code> and add the following incomplete test method:<pre>// ToDoItemI<a id="_idTextAnchor364"/><a id="_idTextAnchor365"/>nputViewTests.swift
func test_shouldAllowDescriptionInput() throws {
  let expected = "dummy description"
  try sut
    .inspect()
    .find(ViewType.TextField.self,
      where: { view in
      let label = try view
        .labelView()
        .text()
        .string()
      return label == "Description"
    })
    .setInput(expected)
  let input = toDoItemData.itemDescription
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker379"/>looks similar to the test we wrote for the <code>title</code> property, but this time we have to specify which <code>TextField</code> we are searching for. We added a <code>where</code> closure to find the text field with a <code>Description</code> label text. Within the <code>where</code> closure, we use the inspection capabilities of <code>ViewInspector</code> to find the string of the text of <code>labelView</code> of <code>TextField</code>.</p>
			<ol>
				<li value="2">The test does not compile, because the <code>itemDescription</code> property is missing in <code>ToDoItemData</code>. Add the property as shown in the following code:<pre>// ToDoItemData.swift
class ToDoItemData: ObservableObject {
  @Published var title = ""
  @Published var date = Date()
  @Published va<a id="_idTextAnchor366"/><a id="_idTextAnchor367"/>r withDate = false
  @Published var itemDescription = ""
}</pre></li>
				<li>Now we<a id="_idIndexMarker380"/> can finish the test. Add the following assertion to the test:<pre>// ToDoIte<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>mInputViewTests.swift
XCTAssertEqual(input, expected)</pre></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="4">Go to <code>ToDoItemInputView</code> and change the <code>body</code> property so that it looks as follows:<pre>// ToDoItemInputView.swift
var body: some View {
  VStack {
    TextField("Title", text: $data.title)
    Toggle("Add Date", isOn: $data.withDate)
    if data.withDate {
      DatePicker("Date", selecti<a id="_idTextAnchor370"/><a id="_idTextAnchor371"/>on: $data.date)
    }
    TextField("Description",
      text: $data.itemDescription)
  }
}</pre></li>
			</ol>
			<p>Run the tests to confirm that all tests pass.</p>
			<p>Here, we could again change the code to see the assertion of the test fail, as we did for the test of the <code>title</code> property. As the code and the test code look similar, I'm confident in the test without doing that. Think for yourself if you would like to see the assertion fail.</p>
			<p>To make the test for the <code>title</code> property more robust against changes in the user interface, add a similar <code>where</code> closure to <code>test_shouldAllowTitleInput</code>.</p>
			<p>A to-do item can <a id="_idIndexMarker381"/>also have a location associated with it. This means we need another text field for the location name. You have already seen how to add a text field to the input view, so this is left to you as an exercise. Use the <code>locationName</code> property name in<a id="_idTextAnchor372"/><a id="_idTextAnchor373"/> <code>ToDoItemData</code> and the <code>"Location name"</code> title for the title of <code>TextField</code>.</p>
			<p>Before we move on, let's make the user interface a bit nicer.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor374"/>Improving the user interface</h2>
			<p>Right now, the<a id="_idIndexMarker382"/> text fields and the date picker are structured using a <code>VStack</code> structure. This is the easiest, but not the prettiest way to do it. The user interface of the input view looks like this at the moment:</p>
			<div><div><img src="img/Figure_9.04_B18127.jpg" alt="Figure 9.4 – The user interface of the input view when using a VStack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – The user interface of the input view when using a VStack</p>
			<p>We can improve the user interface by using <code>Form</code> and <code>Section</code> structures. Replace the <code>body</code> property <a id="_idIndexMarker383"/>code of <code>ToDoItemInput</code> with the following:</p>
			<pre>// ToDoItemInput.swif<a id="_idTextAnchor375"/><a id="_idTextAnchor376"/>t
var body: some View {
  Form {
    SwiftUI.Section {
      TextField("Title", text: $data.title)
      Toggle("Add Date", isOn: $data.withDate)
      if data.withDate {
        DatePicker("Date", selection: $data.date)
      }
      TextField("Description",
        text: $data.itemDescription)
    }
    SwiftUI.Section {
      TextField("Location name",
        text: $data.locationName)
    }
  }
}</pre>
			<p>We have to specify in this code that we want <code>Section</code> defined in SwiftUI because we already defined a section type. With this code, the user interface looks as follows:</p>
			<div><div><img src="img/Figure_9.05_B18127.jpg" alt="Figure 9.5 – An improved user interface with Form and Section&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – An improved user interface with Form and Section</p>
			<p>This <a id="_idIndexMarker384"/>looks way better. Run the tests to confirm that we didn't break something. </p>
			<p>In the next section, we will add another text field and a button.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor377"/>Adding an address text field and a button</h2>
			<p>We <a id="_idIndexMarker385"/>need another text field for the address of the to-do item. Use your gained<a id="_idIndexMarker386"/> experience to add it yourself to the location section of the input form. To make your code consistent with the code of the book on <a id="_idTextAnchor378"/><a id="_idTextAnchor379"/>GitHub, name the property <code>addressString</code> in <code>ToDoItemData</code> and use the label <code>Address</code> in the <code>TextField</code> type.</p>
			<p>After <a id="_idIndexMarker387"/>entering the data for the to-do item, the user can<a id="_idIndexMarker388"/> add it to the list. For that task, we need a button in the user interface. Follow these steps to add the button:</p>
			<ol>
				<li value="1">Add the following test to <code>ToDoItemInputViewTests</code>:<pre>// T<a id="_idTextAnchor380"/><a id="_idTextAnchor381"/>oDoItemInputViewTests.swift
func test_shouldHaveASaveButton() throws {
  XCTAssertNoThrow(try sut
    .inspect()
    .find(ViewType.Button.self,
      where: { view in
      let label = try view
        .labelView()
        .text()
        .string()
      return label == "Save"
    }))
}</pre></li>
			</ol>
			<p>Run the tests to see this new test fail.</p>
			<ol>
				<li value="2">Add the following code within the Form of the body property of <code>ToDoItemInputView</code>:<a id="_idTextAnchor382"/><a id="_idTextAnchor383"/><pre>// ToDoItemInputView.swift
SwiftUI.Section {
  Button(action: addToDoItem,
    label: {
    Text("Save")
  })
}</pre></li>
				<li>To make<a id="_idIndexMarker389"/> this code compile, we need to<a id="_idIndexMarker390"/> add the action. Add the following method to <code>ToDoItemInputView</code> below the <code>body</code> propert<a id="_idTextAnchor384"/><a id="_idTextAnchor385"/>y:<pre>// ToDoItemInputView.swift
func addToDoItem() {
}</pre></li>
			</ol>
			<p>Run all tests to confirm that all tests now pass.</p>
			<p>Now we have all the user interface elements needed to move on to implementing adding the to-do item to the list of items in the next section.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor386"/>Testing button actions with ViewInspector </h1>
			<p>The user puts <a id="_idIndexMarker391"/>in the address for the to-do item. In the details view of an item, the app shows a map of that location. This means we <a id="_idIndexMarker392"/>need to convert the address of the item to a coordinate before we can add the item to the list. Apple provides a <code>GeoCoder</code> class for that task. We will write tests for fetching an address from a <code>GeoCoder</code> class in <a href="B18127_10_ePub.xhtml#_idTextAnchor444"><em class="italic">Chapter 10</em></a>, <em class="italic">Testing Networking Code</em>.</p>
			<p>In this chapter, we assume that we already have a class called <code>APIClient</code> that uses <code>GeoCoder</code> (or some similar service) to translate an address into a coordinate. In the test, we are going to use a mock object for that <code>APIClient</code> class. Follow these steps to add a protocol for the <code>APIClient</code> class and a mock conforming to that protocol:</p>
			<ol>
				<li value="1">Select the <code>APIClient.swift</code>.</li>
				<li>Add the following protocol definition to th<a id="_idTextAnchor389"/><a id="_idTextAnchor390"/>at new file:<pre>// APIClient.swift
protocol APIClientProtocol {
  func coordinate(
    for: String,
    completion: (Coordinate?) -&gt; Void)
}</pre></li>
			</ol>
			<p>This protocol defines a function that takes a <code>String</code> instance and calls a <code>completion</code> handler with a <code>Coordinate</code> instance.</p>
			<ol>
				<li value="3">Select<a id="_idIndexMarker393"/> the <code>APIClientMock.swift</code>.</li>
				<li>Replace the contents of that file with the follo<a id="_idTextAnchor393"/><a id="_idTextAnchor394"/>wing code:<pre>// APIClientMock.swift
import Foundation
@testable <a id="_idTextAnchor395"/><a id="_idTextAnchor396"/>import ToDo
 
class APIClientMock: APIClientProtocol { 
  var coordinateAddress: String?
  var coordinateReturnValue: Coordinate?
 
  func coordinate(
    for address: String,
    completion: (Coordinate?) -&gt; Void) { 
      coordinateAddress = address
      completion(coordinateReturnValue)
  }
}</pre></li>
			</ol>
			<p>With this mock in place, we can write a test that asserts that the <code>coordinate</code> instance is fetched when the user taps the <strong class="bold">Save</strong> button. Follow these steps to add that test and the implementation that makes the test pass:</p>
			<ol>
				<li value="1">Add a new property (<code>apiClientMock</code>) to the <code>ToDoItemInputViewTests</code> class<a id="_idTextAnchor397"/><a id="_idTextAnchor398"/>:<pre>// ToDoItemInputViewTests.swift
var apiClientMock: APIClientMock!</pre></li>
				<li>In <code>setUpWithError</code>, initialize <a id="_idIndexMarker395"/>an API client mock and pass it into the initializer<a id="_idIndexMarker396"/> of <code>ToDoItemInputView</code>:<pre>// ToDoItemInputViewTests.swift
override func setUpWithError() throw<a id="_idTextAnchor399"/><a id="_idTextAnchor400"/><a id="_idTextAnchor401"/>s {
  toDoItemData = ToDoItemData()
  apiClientMock = APIClientMock()
  sut = ToDoItemInputView(
    data: toDoItemData,
    apiClient: apiClientMock)
}</pre></li>
				<li>Don't forget to set this property to <code>nil</code> in <code>tearDownWithError</code>:<pre>// ToDoItemInputViewTests.swift
override func tearDownWithError() throws <a id="_idTextAnchor402"/><a id="_idTextAnchor403"/>{
  sut = nil
  toDoItemData = nil
  apiClientMock = nil
}</pre></li>
			</ol>
			<p><code>ToDoItemInputView</code> doesn't have a property for the API client. We need to add it before we can continue with the test.</p>
			<ol>
				<li value="4">Add the <code>apiClient</code> property to <code>ToDoItemInp<a id="_idTextAnchor404"/><a id="_idTextAnchor405"/><a id="_idTextAnchor406"/>utView</code>:<pre>// ToDoItemInputView.swift:
let apiClient: APIClientProtocol</pre></li>
			</ol>
			<p>As <code>ToDoItemInputView</code> is a structure, this new property changes the automatically generated initializer. We use this initializer in <code>ToDoItemInputView_Previews</code> in the same file.</p>
			<ol>
				<li value="5">Replace<a id="_idIndexMarker397"/> the <code>ToDoItemInputView_Previews</code> structure <a id="_idIndexMarker398"/>with the following implementation:<pre>// ToDoItemInputView.swift
struct ToDoItemInputView_Previews: PreviewProvider {
  static var previews: some View {
    ToDoItemInputView(data: ToDoItemData()<a id="_idTextAnchor407"/><a id="_idTextAnchor408"/>,
      apiClient: APIClient())
      .previewLayout(.sizeThatFits)
  }
}</pre></li>
			</ol>
			<p>With this code, we replaced the error with another. The implementation of <code>APIClient</code> is missing. </p>
			<ol>
				<li value="6">Add the following minimal implementation t<a id="_idTextAnchor409"/><a id="_idTextAnchor410"/>o <code>APIClient.swift</code>:<pre>// APIClient.swift
class APIClient: APIClientProtocol {
  func coordinate(
    for: String,
    completion: (Coordinate?) -&gt; Void) {
  }
}</pre></li>
				<li>Now<a id="_idIndexMarker399"/> we <a id="_idIndexMarker400"/>can add the test <a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>method:<pre>// ToDoItemInputViewTests.swift
func test_saveButton_shouldFetchCoordinate() throws {
  toDoItemData.title = "dummy title"
  let expected = "dummy address"
  toDoItemData.addressString = expected
  try sut
    .inspect()
    .find(ViewType.Button.self,
          where: { view in
      let label = try view
        .labelView()
        .text()
        .string()
      return label == "Save"
    })
    .tap()
 
  XCTAssertEqual(apiClientMock.coordinateAddress,
    expected)
}</pre></li>
			</ol>
			<p>In this test, we set up the title and the address of the input data and tap the <code>coordinate</code> instances for the address.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="8">Replace<a id="_idIndexMarker401"/> the <code>addToDoItem()</code> method<a id="_idIndexMarker402"/> in <code>ToDoItemInputView</code> with the following implementation:<pre>// ToD<a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>oItemInputView.swift
func addToDoItem() {
  apiClient.coordinate(
    for: data.addressString,
       completion: { coordinate in         
  })
}</pre></li>
			</ol>
			<p>In this implementation, we call the <code>coordinate(for:completion:)</code> method defined in <code>APIClientProtocol</code>.</p>
			<p>Run the tests to confirm that all tests now pass.</p>
			<ol>
				<li value="9">But what if the user didn't add an address to the input form? In this case, the <code>coordinate(for:completion:)</code> method should not be called because there is no coordinate to be fetched. We need a test for this case. Add the following test to <code>ToDoInputVie<a id="_idTextAnchor415"/><a id="_idTextAnchor416"/>wTests.swift</code>:<pre>// ToDoInputViewTests.swift
func test_save_whenAddressEmpty_
  shouldNotFetchCoordinate() throws {
  toDoItemData.title = "dummy title"
  try sut
    .inspect()
    .find(ViewType.Button.self,
          where: { view in
      let label = try view
        .labelView()
        .text()
        .string()
      return label == "Save"
    })
    .tap()
 
  XCTAssertNil(apiClientMock.coordinateAddress)
}</pre></li>
			</ol>
			<p>Run all tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To<a id="_idIndexMarker403"/> make it pass, change the code in <code>addToDoItem()</code> so that<a id="_idIndexMarker404"/> it looks like this:<pre>// T<a id="_idTextAnchor417"/><a id="_idTextAnchor418"/>oDoItemInputView.swift
func addToDoItem() {
  if false == data.addressString.isEmpty {
    apiClient.coordinate(
      for: data.addressString,
         completion: { coordinate in
         })
  }
}</pre></li>
			</ol>
			<p>Run all tests to confirm that all tests pass.</p>
			<p>After the <code>coordinate</code> has been fetched, the <code>addToDoItem()</code> method should call a delegate method to inform it that the input data is complete and the item can be constructed. Again, we will add a <code>delegate</code> protocol to define the interface of the <code>delegate</code> object. This <a id="_idIndexMarker405"/>helps when we create a mock object for the test.</p>
			<p>Follow these <a id="_idIndexMarker406"/>steps to add the tests and the implementation of calling the <code>delegate</code> protocol with the to-do item data:</p>
			<ol>
				<li value="1">Add the following protocol definition to <code>ToDoItemInputView.swift</code> outside of the <code>ToDoItemIn<a id="_idTextAnchor419"/><a id="_idTextAnchor420"/>putView</code> structure:<pre>// ToDoItemInputView.swift
protocol ToDoItemInputViewDelegate {
  func addToDoItem(with: ToDoItemData,
    coordinate: Coordinate?)
}</pre></li>
				<li>With this protocol in place, we can add a mock object to the test target. Select the <code>ToDoTests</code> group in the project n<a id="_idTextAnchor421"/><a id="_idTextAnchor422"/>avigator and add a Swift file with the name <code>ToDoItemInputViewDelegateMock.swift</code>. Add the following code to this new<a id="_idTextAnchor423"/><a id="_idTextAnchor424"/> file:<pre>// ToDoItemInputViewDelegateMock.swift
import Foundation
@testable import ToDo 
 
class ToDoItemInputViewDelegateMock:
  ToDoItemInputViewDelegate { 
 
  var lastToDoItemData: ToDoItemData?
  var lastCoordinate: Coordinate? 
 
  func addToDoItem(with data: ToDoItemData,
    coordinate: Coordinate?) { 
 
    lastToDoItemData = data
    lastCoordinate = coordinate
  }
}</pre></li>
				<li>Now we <a id="_idIndexMarker407"/>can start with the test. Add the<a id="_idIndexMarker408"/> following test fragment to <code>ToDoItem<a id="_idTextAnchor425"/><a id="_idTextAnchor426"/>InputViewTests</code>:<pre>// ToDoItemInputViewTests.swift
func test_save_shouldCallDelegate() throws {
  toDoItemData.title = "dummy title"
  toDoItemData.addressString = "dummy address"
  apiClientMock.coordinateReturnValue =
  Coordinate(latitude: 1, longitude: 2)
  let delegateMock = ToDoItemInputViewDelegateMock()
  sut.delegate = delegateMock
}</pre></li>
			</ol>
			<p>Here we set up the <code>apiClientMock</code> property to return a dummy coordinate when <code>coordinate(for:completion:)</code> is called, and we create an instance of <code>ToDoItemInputViewDelegateMock</code> and set it to the <code>delegate</code> property of the system under test. This property is still missing and therefore, we have to pause writing the test and first add it to <code>ToDoItemInputView</code>.</p>
			<ol>
				<li value="4">Add this <code>delegate</code> property t<a id="_idTextAnchor427"/><a id="_idTextAnchor428"/>o <code>ToDoItemInputView</code>:<pre>// ToDoItemInputView.swift
var delegate: ToDoItemInputViewDelegate?</pre></li>
			</ol>
			<p>This change makes the test compile and we can continue writing the test.</p>
			<ol>
				<li value="5">Complete<a id="_idIndexMarker409"/> the test method so that it <a id="_idIndexMarker410"/><a id="_idTextAnchor429"/><a id="_idTextAnchor430"/>looks as follows:<pre>// ToDoItemInputViewTests.swift
func test_save_shouldCallDelegate() throws {
  toDoItemData.title = "dummy title"
  toDoItemData.addressString = "dummy address"
  apiClientMock.coordinateReturnValue =
  Coordinate(latitude: 1, longitude: 2)
  let delegateMock = ToDoItemInputViewDelegateMock()
  sut.delegate = delegateMock
  try sut
    .inspect()
    .find(ViewType.Button.self,
          where: { view in
      let label = try view
        .labelView()
        .text()
        .string()
      return label == "Save"
    })
    .tap()
 
  XCTAssertEqual(delegateMock.lastToDoItemData?.title,
    "dummy title")
  XCTAssertEqual(delegateMock.lastCoordinate?
    .latitude, 1)
  XCTAssertEqual(delegateMock.lastCoordinate?
    .longitude, 2)
}</pre></li>
			</ol>
			<p>Usually, I try to keep all the relevant code in the test. But in this case, the test method is a bit <a id="_idIndexMarker411"/>messy. As an example, let's move the inspector code into a method.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker412"/> following extension in <code>ToDoItemInputViewTests.swift</code> below the <code>ToDoItemIn<a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>putViewTests</code> class:<pre>// ToDoItemInputViewTests.swift
extension ToDoItemInputView {
  func tapButtonWith(name: String) throws {
    try inspect()
      .find(ViewType.Button.self,
        where: { view in
        let label = try view
          .labelView()
          .text()
          .string()
        return label == name
      })
      .tap()
  }
}</pre></li>
				<li>With this extension we can write the last test as follows:<pre>// ToDoItemInputViewTests.swift
func test_save_shouldCallDelegate() throws {
  toDoItemData.title = "dummy title"
  toDoItemData.addressString = "dummy address"
  apiClientMock.coordinateReturnValue =
  Coordinate(latitude: 1, longitude: 2)
  let delegateMock = ToDoItemInput<a id="_idTextAnchor433"/><a id="_idTextAnchor434"/>ViewDelegateMock()
  sut.delegate = delegateMock
  try sut.tapButtonWith(name: "Save")
 
  XCTAssertEqual(delegateMock.lastToDoItemData?.title,
    "dummy title")
  XCTAssertEqual(delegateMock.lastCoordinate?
    .latitude, 1)
  XCTAssertEqual(delegateMock.lastCoordinate?
    .longitude, 2)
}</pre></li>
			</ol>
			<p>In this case, this is a bit better than the original version.</p>
			<ol>
				<li value="8">To <a id="_idIndexMarker413"/>make<a id="_idIndexMarker414"/> this test pass, replace the implementation of <code>addToDoItem()</code> with the following <a id="_idTextAnchor435"/><a id="_idTextAnchor436"/>code:<pre>// ToDoItemInputView.swift
func addToDoItem() {
  if false == data.addressString.isEmpty {
    apiClient.coordinate(
      for: data.addressString,
         completion: { coordinate in
           self.delegate?.addToDoItem(
            with: data,
            coordinate: coordinate)
         })
  }
}</pre></li>
			</ol>
			<p>In the completion closure, we now call the <code>addToDoItem(with:coordinate:)</code> method.</p>
			<p>Run the tests to confirm that this change makes all tests pass.</p>
			<ol>
				<li value="9">But <a id="_idIndexMarker415"/>what if the user didn't add an <a id="_idIndexMarker416"/>address for the to-do item? Add the following test to make sure that, in this case, the <code>delegate</code> m<a id="_idTextAnchor437"/><a id="_idTextAnchor438"/>ethod also gets called:<pre>// ToDoItemInputViewTests.swift
func test_save_whenAddressEmpty_
  shouldCallDelegate() throws {
  toDoItemData.title = "dummy title"
  apiClientMock.coordinateReturnValue =
  Coordinate(latitude: 1, longitude: 2)
  let delegateMock = ToDoItemInputViewDelegateMock()
  sut.delegate = delegateMock
 
  try sut.tapButtonWith(name: "Save")
 
  XCTAssertEqual(delegateMock.lastToDoItemData?.title,
    "dummy title")
}</pre></li>
			</ol>
			<p>Run all tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To make<a id="_idIndexMarker417"/> this test pass, replace <code>addToDoItem()</code> in <code>ToDoItemInputView</code> with <a id="_idIndexMarker418"/>the following code:<pre>// ToDoItemInputView.swift
func addToDoItem() {
  if false == data.addressString.isEmpty {
    apiClient.coordinate(
      for: data.addressString,
         completion: { coordinate in
           self.delegate?.addToDoItem(
            with:<a id="_idTextAnchor439"/><a id="_idTextAnchor440"/> data,
            coordinate: coordinate)
         })
  } else {
    delegate?.addToDoItem(with: data,
      coordinate: nil)
  }
}</pre></li>
			</ol>
			<p>If the <code>address</code> string is empty, we call the <code>delegate</code> method without a <code>coordinate</code> instance.</p>
			<p>Run all tests. All tests pass again.</p>
			<p>The input view is now complete and we can move on to implementing some networking code.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor441"/>Summary</h1>
			<p>Testing SwiftUI code works a bit differently from testing UIKit code. One reason for this is that SwiftUI itself works completely differently. In addition, Apple doesn't provide a testing framework for SwiftUI code because they believe that user interface code should be tested with UITest.</p>
			<p>I don't think that's true. UITest solve a different problem. I believe you should have access to both kinds of tests, and you should choose the right tool for the problem at hand.</p>
			<p>Fortunately, with ViewInspector we have a powerful third-party solution that fills this gap. In this chapter, we added it as a SwiftUI package to the unit test target. We used the package to write unit tests for SwiftUI code and build an input view for to-do items following test-driven development. </p>
			<p>This way, we learned how to add SwiftUI packages to test targets and how to use this specific SwiftUI package to write tests for things that aren't easily testable without it.</p>
			<p>In the next chapter, we will learn how to write unit tests for networking code.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor442"/>Exercises</h1>
			<ol>
				<li value="1">Add more convenient methods in the extension of <code>ToDoItemInputView</code> in <code>ToDoItemInputViewTests.swift</code> to make the tests easier to read as we did for <code>test_save_shouldCallDelegate()</code>. What are the advantages of these helper methods? What are the disadvantages?</li>
				<li>When the user provides an address, but <code>GeoCoder</code> cannot find the coordinate to that address, the app should show an alert and ask the user if they still want to save the item. Go to the GitHub repository of <code>ViewInspector</code> (<a href="https://github.com/nalexn/ViewInspector">https://github.com/nalexn/ViewInspector</a>) and find out how you can test the presentation of an alert. Then write the test that asserts that the alert is presented and implement that feature.</li>
			</ol>
		</div>
	</body></html>