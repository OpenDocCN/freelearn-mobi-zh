<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-127"><em class="italic"><a id="_idTextAnchor324"/>Chapter 9</em>: Test-Driven Input View in SwiftUI</h1>
			<p>In 2019, Apple introduced <strong class="bold">SwiftUI</strong> as a new way to build user interfaces for apps on Apple platforms. In contrast to user interfaces built with UIKit, SwiftUI views are a function of some kind of state. As a result, testing such views can be very easy. In a test, we would have to set the state and assert that the expected user interface elements are present.</p>
			<p>Unfortunately, the engineers in charge at Apple believe that there is no value in testing user interfaces. They believe that to prove the user interface looks and works as expected, it's enough to run the app and check with your eyes. This might be true for an app as simple as the one we are building in this book. But, if you have a look in the App Store, you will find most of the apps (if not all) are way more complicated. Usually, apps consist of many views and some of them are only visible in some rare cases. Ensuring that those views work for all input values and environment parameters is a lot of work.</p>
			<p>Also, think about refactoring. Apps are never finished. We need to change and add features all the time. How do engineers make sure that all previous features still work?</p>
			<p>Automatic tests performed by a computer are faster than manual tests by several orders of magnitude. In my opinion, engineers not using automatic tests, even for user interfaces, wastes time and money.</p>
			<p>So, what do we do when we want to build a user interface using SwiftUI and still rely on the advantages of test-driven development? Fortunately, there is a third-party library called <strong class="bold">ViewInspector</strong> on GitHub that fills this gap. In this chapter, we will add this library to our project and explore how we can write unit tests for SwiftUI code.</p>
			<p>This chapter is structured into the following sections:</p>
			<ul>
				<li>Adding the ViewInspector package</li>
				<li>Using ViewInspector to test a simple view</li>
				<li>Testing button actions with ViewInspector</li>
			</ul>
			<p>Let's start by adding ViewInspector to our test target.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor325"/>Technical requirement</h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09</a>.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor326"/>Adding the ViewInspector package</h1>
			<p>ViewInspector is<a id="_idIndexMarker356"/> an open source library that you can find on GitHub: <a href="https://github.com/nalexn/ViewInspector">https://github.com/nalexn/ViewInspector</a>. To <a id="_idIndexMarker357"/>add it to<a id="_idIndexMarker358"/> our project, follow these steps:</p>
			<ol>
				<li>Select the <strong class="bold">File</strong> | <strong class="bold">Add Packages</strong> menu item in Xcode.</li>
				<li>Type into the search field the URL of the package, <strong class="source-inline">https://github.com/nalexn/ViewInspector</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_9.01_B18127.jpg" alt="Figure 9.1 – Add the ViewInspector package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Add the ViewInspector package</p>
			<p>Click <strong class="bold">Add Package</strong>.</p>
			<ol>
				<li value="3">Xcode presents a new window in which we can set the target to which the package should <a id="_idIndexMarker359"/>be added. Select the <strong class="bold">ToDoTests</strong> target. Then click <strong class="bold">Add Package</strong> again.</li>
			</ol>
			<p>The package is now added to the <strong class="bold">ToDoTests</strong> target and we can use it in our unit tests.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor327"/>Using ViewInspector to test a simple view</h1>
			<p>The view we <a id="_idIndexMarker360"/>are going to build will be used to add <a id="_idIndexMarker361"/>new to-do items to the list of items. This means it needs input fields for all information a to-do item can hold. So, let's look into that aspect in the next subsections.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor328"/>Adding a title text field</h2>
			<p>As always, we <a id="_idIndexMarker362"/>start with the test. Follow these steps to add a text field for the title of a to-do item to the input view:</p>
			<ol>
				<li value="1">Select the <strong class="bold">ToDoTests</strong> group in the project navigator and add a <strong class="bold">Unit Test Case Class</strong> with the name <strong class="source-inline">ToDoItemInputViewTests</strong>. Remove the two template test methods.</li>
				<li>Import the <strong class="source-inline">ViewInspector</strong> library and the main target (<strong class="source-inline">ToDo</strong>) so that it is testable (<strong class="source-inline">@testable</strong>):<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">import XCTest</p><p class="source-code">@testable import ToDo</p><p class="source-code">import ViewInspector</p></li>
				<li>Before we can write tests for a SwiftUI view, we first need to extend it with the <strong class="source-inline">Inspectable</strong> protocol from the <strong class="source-inline">ViewInspector</strong> library. Add the following line right above the test case class:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">extension ToDoItemInputView: Inspectable {}</p></li>
			</ol>
			<p>At this point, Xcode complains that it <strong class="bold">Cannot find type 'ToDoItemInputView' in scope</strong>. That was expected as we haven't added this type yet.</p>
			<ol>
				<li value="4">Select<a id="_idIndexMarker363"/> the <strong class="bold">ToDo</strong> group in the project navigator and add a SwiftUI file:</li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_9.02_B18127.jpg" alt="Figure 9.2 – Select the SwiftUI template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Select the SwiftUI template</p>
			<ol>
				<li value="5">Put <strong class="source-inline">ToDoItemInputView.swift</strong> in the <strong class="bold">Save As</strong> field:</li>
			</ol>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_9.03_B18127.jpg" alt="Figure 9.3 – The name of the new file is ToDoItemInputView.swift&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The name of the new file is ToDoItemInputView.swift</p>
			<p>Now, the <a id="_idIndexMarker364"/>error in the test code is gone and we can continue with the test.</p>
			<ol>
				<li value="6">Add a property for the system under test and for the data object holding the information for the new to-do item:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">var sut: ToDoItemInputView!</p><p class="source-code">var toDoItemData: ToDoItemData!</p></li>
			</ol>
			<p>We will fill <strong class="source-inline">toDoitemData</strong> with the data the user puts into the view, and when they are finished, we will create a <strong class="source-inline">ToDoItem</strong> instance from that data.</p>
			<p>Again, Xcode tells us that something is missing.</p>
			<ol>
				<li value="7">Select the <strong class="bold">ToDo</strong> group in the project navigator and add a SwiftUI file with <strong class="source-inline">ToDoItemData</strong> as the name.</li>
				<li>Replace the contents of this file with the following code:<p class="source-code">// ToDoItemData.swift</p><p class="source-code">import Foundation </p><p class="source-code"> </p><p class="source-code">class ToDoItemData: ObservableObject {</p><p class="source-code">}</p></li>
			</ol>
			<p>This new<a id="_idIndexMarker365"/> type needs to be the <strong class="source-inline">ObservableObject</strong> type because we want to use it as the state of our SwiftUI view.</p>
			<ol>
				<li value="9">Go back to the <strong class="source-inline">ToDoItemInputViewTests</strong> class and replace <strong class="source-inline">setUpWithError()</strong> and <strong class="source-inline">tearDownWithError()</strong> with the following code:<p class="source-code">// ToDoItemInputViewTests .swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  toDoItemData = ToDoItemData()</p><p class="source-code">  sut = ToDoItemInputView(data: toDoItemData)</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">override func tearDownWithError() throws {</p><p class="source-code">  sut = nil</p><p class="source-code">  toDoItemData = nil</p><p class="source-code">}</p></li>
				<li>The preceding code does not compile, as the initializer of <strong class="source-inline">ToDoItemInputView</strong> doesn't take any arguments. To fix the compilation error, add the following property to <strong class="source-inline">ToDoItemInputView</strong>:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">@ObservedObject var data: ToDoItemData</p></li>
				<li>Now, Xcode shows an error in the <strong class="source-inline">ToDoItemInputView_Previews</strong> structure because the new property is missing in the initializer of <strong class="source-inline">ToDoItemInputView</strong>. Replace the contents of the <strong class="source-inline">ToDoItemInputView_Previews</strong> structure with the following code to fix this error:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">static var previews: some View {</p><p class="source-code">  ToDoItemInputView(data: ToDoItemData())</p><p class="source-code">}</p></li>
				<li>Now, let's <a id="_idIndexMarker366"/>get back to the test case class. Add the following fragment of a test method to <strong class="source-inline">ToDoItemInputViewTests</strong>:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_titleInput_shouldSetValueInData() throws {</p><p class="source-code">  let expected = "dummy title"</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.TextField.self)</p><p class="source-code">    .setInput(expected)</p><p class="source-code"> </p><p class="source-code">  let input = toDoItemData.title</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">toDoItemData</strong> type has no <strong class="source-inline">title</strong> property. We will fix this in the next step. But first, let's try to understand what is happening here.</p>
			<p>First, we call <strong class="source-inline">inspect()</strong> on the system under test (<strong class="source-inline">sut</strong>). This is possible because we extended the <strong class="source-inline">ToDoItemInputView</strong> call with conformance to the <strong class="source-inline">Inspectable</strong> protocol. On the returned type, we can call the <strong class="source-inline">find</strong> method that returns the first instance of the given type, in this case, the <strong class="source-inline">TextField</strong> type. On the value that is returned from the <strong class="source-inline">find</strong> call, we call <strong class="source-inline">setInput(_:)</strong> to simulate user input to that text field.</p>
			<ol>
				<li value="13">Add the following <strong class="source-inline">title</strong> property to <strong class="source-inline">ToDoItemData</strong>:<p class="source-code">// ToDoItemData.swift</p><p class="source-code">@Published var title = ""</p></li>
				<li>Finish <a id="_idIndexMarker367"/>the test with the following <strong class="source-inline">Assert</strong> function call:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_shouldAllowTitleInput() throws {</p><p class="source-code">  let expected = "dummy title"</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.TextField.self)</p><p class="source-code">    .setInput(expected)</p><p class="source-code"> </p><p class="source-code">  let input = toDoItemData.title</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(input, expected)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this new test fails. The test fails in the line where we try to find the <strong class="source-inline">TextField</strong> element.</p>
			<ol>
				<li value="15">Replace the content of the <strong class="source-inline">body</strong> property in <strong class="source-inline">ToDoItemInputView</strong> with the following code:<p class="source-code">// ToDoItemInputVi<a id="_idTextAnchor329"/><a id="_idTextAnchor330"/>ew.swift</p><p class="source-code">TextField("Title", text: $data.title)</p></li>
			</ol>
			<p>Run the tests again. Now all tests pass but we haven't seen the assertion fail. The test failed previously because it could not find a <strong class="source-inline">TextField</strong> element in the body of the view. Is this a problem? It could be. If we are not careful, we could write an assertion that always passes. So, it is a good idea to change the code in a way that the assertion fails but the rest of the test passes.</p>
			<ol>
				<li value="16">Replace the <strong class="source-inline">ToDoItemInputView</strong> structure with the following code:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">struct ToDoItemInputView: View { </p><p class="source-code">  @ObservedObject var data: ToDoIt<a id="_idTextAnchor331"/><a id="_idTextAnchor332"/>emData</p><p class="source-code">  @State var dummy: String = ""</p><p class="source-code">  </p><p class="source-code">  var body: some View {</p><p class="source-code">    TextField("Title", text: $dummy)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here we have <a id="_idIndexMarker368"/>added a dummy variable to act as the binding for the text of <strong class="source-inline">TextField</strong>. Run the tests to confirm that the last added test now fails at the assertion. As we have checked that the assertion can fail, we can change the code so that the test passes again.</p>
			<p>That was easy. With the help of <strong class="source-inline">ViewInspector</strong>, we were able to write a test for the input text field of the title for the to-do item.</p>
			<p>In the next section, we will add a <strong class="source-inline">DatePicker</strong>  structure to allow the user to add due dates to to-do items.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor333"/>Adding a DatePicker </h2>
			<p>The title is <a id="_idIndexMarker369"/>the only required data of a to-do item. The date is optional. In the user interface of the input view, we want to use a <strong class="source-inline">DatePicker</strong> structure for the input of the date value. We will use a toggle to show the <strong class="source-inline">DatePicker</strong> structure when the user wants to add a date for that to-do item. </p>
			<p>This means we first need a test that asserts that the view initially doesn't show a date picker. Add the following test method to <strong class="source-inline">ToDoItemInputView</strong>:</p>
			<p class="source-code">// ToDoItemInputViewT<a id="_idTextAnchor334"/><a id="_idTextAnchor335"/>ests.swift</p>
			<p class="source-code">func test_whenWithoutDate_shouldNotShowDateInput() {</p>
			<p class="source-code">  XCTAssertThrowsError(try sut</p>
			<p class="source-code">    .inspect()</p>
			<p class="source-code">    .find(ViewType.DatePicker.self))</p>
			<p class="source-code">}</p>
			<p>With this code, we assert that the code in the parameter of the <strong class="source-inline">XCTAssertThrowsError</strong> function throws an error. This means we test that there is no <strong class="source-inline">DatePicker</strong> in the view. The test fails if the <strong class="source-inline">find</strong> method finds a <strong class="source-inline">DatePicker</strong>.</p>
			<p>We don't have to do anything to make this test pass. It already passes. We could add a <strong class="source-inline">DatePicker</strong> to see it failing. Actually, we will do that next.</p>
			<p>The <a id="_idIndexMarker370"/>toggle element to show and hide the date picker will be bound to a <strong class="source-inline">@State</strong> property with the <strong class="source-inline">withDate</strong> property defined in <strong class="source-inline">ToDoItemInputView</strong>. As a result, the state of the toggle element will be reflected in the value of the <strong class="source-inline">withDate</strong> property. Interacting with a <strong class="source-inline">@State</strong> property from a unit test needs some change of the view code. We will start the implementation of the date input with the following change:</p>
			<ol>
				<li value="1">Replace the <strong class="source-inline">ToDoItemInputView</strong> structure with the following code:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">struct ToDoItemInputView: View { </p><p class="source-code">  @ObservedObject var data: ToD<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/>oItemData</p><p class="source-code">  var didAppear: ((Self) -&gt; Void)?</p><p class="source-code">  </p><p class="source-code">  var body: <a id="_idTextAnchor338"/><a id="_idTextAnchor339"/>some View {</p><p class="source-code">    VStack {</p><p class="source-code">      TextField("Title", text: $data.title<a id="_idTextAnchor340"/><a id="_idTextAnchor341"/>)</p><p class="source-code">    }</p><p class="source-code">    .onAppear { self.didAppear?(self) }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>We added here a closure with a <strong class="source-inline">didAppear</strong> name that is called in the <strong class="source-inline">onAppear</strong> modifier of the <strong class="source-inline">VStack</strong> structure. We need a <strong class="source-inline">VStack</strong> structure or something similar here because, later in these steps, we will add more elements to the body of the view.</p>
			<ol>
				<li value="2">With<a id="_idIndexMarker371"/> this preparation we can add the first fragment of the test:<p class="source-code">// ToDoItemInputVie<a id="_idTextAnchor342"/><a id="_idTextAnchor343"/>wTests.swift</p><p class="source-code">func test_whenWithDate_shouldAllowDateInput() throws {</p><p class="source-code">  let exp = sut.on(\.didAppear) { view in</p><p class="source-code">    try view.find(ViewType.Toggle.self).tap()</p><p class="source-code">    let expected = Date(timeIntervalSinceNow:</p><p class="source-code">      1_000_000)</p><p class="source-code">    try view</p><p class="source-code">      .find(ViewType.DatePicker.self)</p><p class="source-code">      .select(date: expected)</p><p class="source-code"> </p><p class="source-code">    let input = self.toDoItemData.date</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  ViewHosting.host(view: sut)</p><p class="source-code">  wait(for: [exp], timeout: 0.1)</p><p class="source-code">}</p></li>
			</ol>
			<p>We start the test method with an expectation. It is needed here to make updating the <strong class="source-inline">@State</strong> property accessible in the test. The reason for that lies in the implementation details of view updates in SwiftUI. </p>
			<p>All the communication with the system under test has to be put into the closure of the expectation we define using <strong class="source-inline">sut.on(\.didAppear) {}</strong>.</p>
			<p>In the closure, we first switch the toggle to make the date picker appear. Next, we search for the <strong class="source-inline">DatePicker</strong> and we try to set its date. Then we access the date of the <strong class="source-inline">toDoItemDate</strong> property. The test is not finished, but we have to pause here because the <strong class="source-inline">Date</strong> property is missing.</p>
			<p>Below the<a id="_idIndexMarker372"/> closure, we ask the <strong class="source-inline">ViewInspector</strong> library to host the system under test. This triggers the <strong class="source-inline">onAppear</strong> closure and makes working with <strong class="source-inline">@State</strong> properties possible. Finally, we have to wait for the expectation to be fulfilled. We don't have to call <strong class="source-inline">fulfill()</strong> on the expectation ourselves. This is managed by the <strong class="source-inline">ViewInspector</strong> library.</p>
			<ol>
				<li value="3">Go to <strong class="source-inline">ToDoItemData</strong> and add the <strong class="source-inline">Date</strong> property:<p class="source-code">// ToDoI<a id="_idTextAnchor344"/><a id="_idTextAnchor345"/>temData.swift</p><p class="source-code">@Published var date = Date()</p></li>
				<li>Now, we can finish the test by adding the <strong class="source-inline">Assert</strong> function call:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">func test_whenWithDate_shouldAllowDateInput() throws {</p><p class="source-code">  let exp = sut.on(\.didAppear) { view in</p><p class="source-code">    try view.find(ViewType.Toggle.self).tap()</p><p class="source-code"> </p><p class="source-code">    let expected = Date(timeIntervalSinceNow:</p><p class="source-code">      1_000_000)</p><p class="source-code">    try view</p><p class="source-code">      .find(ViewType.DatePicker.self)</p><p class="source-code">      .select(date: expected)</p><p class="source-code"> </p><p class="source-code">    let input = self.toDoItem<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/>Data.date</p><p class="source-code">    XCTAssertEqual(input, expected)</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  ViewHosting.host(view: sut)</p><p class="source-code">  wait(for: [exp], timeout: 0.1)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that this new test is failing. It fails because it can't find the toggle. Let's add the toggle in the next step.</p>
			<ol>
				<li value="5">Add the following property for the state of the toggle we are about to add:<p class="source-code">// ToDoItemIn<a id="_idTextAnchor348"/><a id="_idTextAnchor349"/>putView.swift</p><p class="source-code">@State var withDate = false</p></li>
				<li>Next, replace<a id="_idIndexMarker373"/> the contents of the computed <strong class="source-inline">body</strong> property with the following code:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">VStack {</p><p class="source-code">  TextField("Title", text<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/>: $data.title)</p><p class="source-code">  Toggle("Add Date", isOn: $withDate)</p><p class="source-code">}</p><p class="source-code">.onAppear { self.didAppear?(self) }</p></li>
			</ol>
			<p>Now the test fails because it can't find the date picker.</p>
			<ol>
				<li value="7">Add the date picker as follows:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">VStack {</p><p class="source-code">  TextField("Title", text: $data.title)</p><p class="source-code">  Toggle("Add Date", isOn<a id="_idTextAnchor352"/><a id="_idTextAnchor353"/>: $withDate)</p><p class="source-code">  DatePicker("Date", selection: $data.date)</p><p class="source-code">}</p><p class="source-code">.onAppear { self.didAppear?(self) }</p></li>
			</ol>
			<p>Now, <strong class="source-inline">test_whenWithDate_shouldAllowDateInput</strong> passes but <strong class="source-inline">test_whenWithoutDate_shouldNotShowDateInput</strong> fails. This is a good thing because we haven't seen this test fail until now. </p>
			<ol>
				<li value="8">To make <a id="_idIndexMarker374"/>both tests pass, replace the code of the computed <strong class="source-inline">body</strong> property with the following:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">var body: some Vi<a id="_idTextAnchor354"/><a id="_idTextAnchor355"/>ew {</p><p class="source-code">  VStack {</p><p class="source-code">    TextField("Title", text: $data.title)</p><p class="source-code">    Toggle("Add Date", i<a id="_idTextAnchor356"/><a id="_idTextAnchor357"/>sOn: $withDate)</p><p class="source-code">    if withDate {</p><p class="source-code">      DatePicker("Date", selection: $data.date)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  .onAppear { self.didAppear?(self) }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that all tests pass again.</p>
			<p>In making the last test pass, we learned what we have to do to test changes where a <strong class="source-inline">@State</strong> property is involved. This was shown here because you need to know this when you start writing tests for SwiftUI views.</p>
			<p>Now that we have seen how to test changes to <strong class="source-inline">@State</strong> properties, let's refactor the test code and the implementation to make both easier to understand.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor358"/>Improving the test code and the implementation</h2>
			<p>For<a id="_idIndexMarker375"/> our app, it would be better if we move the <strong class="source-inline">withDate</strong> property to <strong class="source-inline">ToDoItemData</strong> because we need this information when we try to create the to-do item. Follow these steps to move that property to <strong class="source-inline">ToDoItemData</strong>:</p>
			<ol>
				<li value="1">Go to <strong class="source-inline">ToDoItemInputTests</strong> and replace <strong class="source-inline">test_whenWithDate_shouldAllowDateInput()</strong> with the following implementation:<p class="source-code">// ToDoItem<a id="_idTextAnchor359"/><a id="_idTextAnchor360"/>InputTests.swift</p><p class="source-code">func test_whenWithDate_shouldAllowDateInput() throws {</p><p class="source-code">  let expected = Date()</p><p class="source-code">  try sut.inspect().find(ViewType.Toggle.self).tap()</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.DatePicker.self)</p><p class="source-code">    .select(date: expected)</p><p class="source-code"> </p><p class="source-code">  let input = toDoItemData.date</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(input, expected)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests. This<a id="_idIndexMarker376"/> test now fails because we can't interact with a <strong class="source-inline">@State</strong> property this way.</p>
			<ol>
				<li value="2">Delete the <strong class="source-inline">@State var withDate = false</strong> line from <strong class="source-inline">ToDoItemInputView</strong>.</li>
				<li>Go to <strong class="source-inline">ToDoItemData</strong> and add the following property:<p class="source-code">// T<a id="_idTextAnchor361"/><a id="_idTextAnchor362"/>oDoItemData.swift</p><p class="source-code">@Published var withDate = false</p></li>
				<li>Now in <strong class="source-inline">ToDoItemInputView</strong>, replace all occurrences of <strong class="source-inline">withDate</strong> with <strong class="source-inline">data.withDate</strong>:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">var body: some View {</p><p class="source-code">  VStack {</p><p class="source-code">    TextField("Title", text: $data.title)</p><p class="source-code">    Toggle("Add Date", isOn: $data.withDate)</p><p class="source-code">    if data.withDate {</p><p class="source-code">      DatePicker("Date", selection: $data.date)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Note that we have removed the <strong class="source-inline">.onAppear</strong> call below the closing brace of  <strong class="source-inline">VStack</strong>. As it<a id="_idIndexMarker377"/> is not needed anymore, you can also remove the <strong class="source-inline">didAppear</strong> property from <strong class="source-inline">ToDoItemInputView</strong>.</p>
			<p>Run all tests to confirm that all tests now pass again.</p>
			<p>We now have an input view for the title and the date of a to-do item. Next, we need a text field for the item description. </p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor363"/>Adding another text field</h2>
			<p>Follow these <a id="_idIndexMarker378"/>steps to add another text field to the input view:</p>
			<ol>
				<li value="1">Go to <strong class="source-inline">ToDoItemInputViewTests</strong> and add the following incomplete test method:<p class="source-code">// ToDoItemI<a id="_idTextAnchor364"/><a id="_idTextAnchor365"/>nputViewTests.swift</p><p class="source-code">func test_shouldAllowDescriptionInput() throws {</p><p class="source-code">  let expected = "dummy description"</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.TextField.self,</p><p class="source-code">      where: { view in</p><p class="source-code">      let label = try view</p><p class="source-code">        .labelView()</p><p class="source-code">        .text()</p><p class="source-code">        .string()</p><p class="source-code">      return label == "Description"</p><p class="source-code">    })</p><p class="source-code">    .setInput(expected)</p><p class="source-code">  let input = toDoItemData.itemDescription</p><p class="source-code">}</p></li>
			</ol>
			<p>This <a id="_idIndexMarker379"/>looks similar to the test we wrote for the <strong class="source-inline">title</strong> property, but this time we have to specify which <strong class="source-inline">TextField</strong> we are searching for. We added a <strong class="source-inline">where</strong> closure to find the text field with a <strong class="source-inline">Description</strong> label text. Within the <strong class="source-inline">where</strong> closure, we use the inspection capabilities of <strong class="source-inline">ViewInspector</strong> to find the string of the text of <strong class="source-inline">labelView</strong> of <strong class="source-inline">TextField</strong>.</p>
			<ol>
				<li value="2">The test does not compile, because the <strong class="source-inline">itemDescription</strong> property is missing in <strong class="source-inline">ToDoItemData</strong>. Add the property as shown in the following code:<p class="source-code">// ToDoItemData.swift</p><p class="source-code">class ToDoItemData: ObservableObject {</p><p class="source-code">  @Published var title = ""</p><p class="source-code">  @Published var date = Date()</p><p class="source-code">  @Published va<a id="_idTextAnchor366"/><a id="_idTextAnchor367"/>r withDate = false</p><p class="source-code">  @Published var itemDescription = ""</p><p class="source-code">}</p></li>
				<li>Now we<a id="_idIndexMarker380"/> can finish the test. Add the following assertion to the test:<p class="source-code">// ToDoIte<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>mInputViewTests.swift</p><p class="source-code">XCTAssertEqual(input, expected)</p></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="4">Go to <strong class="source-inline">ToDoItemInputView</strong> and change the <strong class="source-inline">body</strong> property so that it looks as follows:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">var body: some View {</p><p class="source-code">  VStack {</p><p class="source-code">    TextField("Title", text: $data.title)</p><p class="source-code">    Toggle("Add Date", isOn: $data.withDate)</p><p class="source-code">    if data.withDate {</p><p class="source-code">      DatePicker("Date", selecti<a id="_idTextAnchor370"/><a id="_idTextAnchor371"/>on: $data.date)</p><p class="source-code">    }</p><p class="source-code">    TextField("Description",</p><p class="source-code">      text: $data.itemDescription)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that all tests pass.</p>
			<p>Here, we could again change the code to see the assertion of the test fail, as we did for the test of the <strong class="source-inline">title</strong> property. As the code and the test code look similar, I'm confident in the test without doing that. Think for yourself if you would like to see the assertion fail.</p>
			<p>To make the test for the <strong class="source-inline">title</strong> property more robust against changes in the user interface, add a similar <strong class="source-inline">where</strong> closure to <strong class="source-inline">test_shouldAllowTitleInput</strong>.</p>
			<p>A to-do item can <a id="_idIndexMarker381"/>also have a location associated with it. This means we need another text field for the location name. You have already seen how to add a text field to the input view, so this is left to you as an exercise. Use the <strong class="source-inline">locationName</strong> property name in<a id="_idTextAnchor372"/><a id="_idTextAnchor373"/> <strong class="source-inline">ToDoItemData</strong> and the <strong class="source-inline">"Location name"</strong> title for the title of <strong class="source-inline">TextField</strong>.</p>
			<p>Before we move on, let's make the user interface a bit nicer.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor374"/>Improving the user interface</h2>
			<p>Right now, the<a id="_idIndexMarker382"/> text fields and the date picker are structured using a <strong class="source-inline">VStack</strong> structure. This is the easiest, but not the prettiest way to do it. The user interface of the input view looks like this at the moment:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_9.04_B18127.jpg" alt="Figure 9.4 – The user interface of the input view when using a VStack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – The user interface of the input view when using a VStack</p>
			<p>We can improve the user interface by using <strong class="source-inline">Form</strong> and <strong class="source-inline">Section</strong> structures. Replace the <strong class="source-inline">body</strong> property <a id="_idIndexMarker383"/>code of <strong class="source-inline">ToDoItemInput</strong> with the following:</p>
			<p class="source-code">// ToDoItemInput.swif<a id="_idTextAnchor375"/><a id="_idTextAnchor376"/>t</p>
			<p class="source-code">var body: some View {</p>
			<p class="source-code">  Form {</p>
			<p class="source-code">    SwiftUI.Section {</p>
			<p class="source-code">      TextField("Title", text: $data.title)</p>
			<p class="source-code">      Toggle("Add Date", isOn: $data.withDate)</p>
			<p class="source-code">      if data.withDate {</p>
			<p class="source-code">        DatePicker("Date", selection: $data.date)</p>
			<p class="source-code">      }</p>
			<p class="source-code">      TextField("Description",</p>
			<p class="source-code">        text: $data.itemDescription)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    SwiftUI.Section {</p>
			<p class="source-code">      TextField("Location name",</p>
			<p class="source-code">        text: $data.locationName)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We have to specify in this code that we want <strong class="source-inline">Section</strong> defined in SwiftUI because we already defined a section type. With this code, the user interface looks as follows:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_9.05_B18127.jpg" alt="Figure 9.5 – An improved user interface with Form and Section&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – An improved user interface with Form and Section</p>
			<p>This <a id="_idIndexMarker384"/>looks way better. Run the tests to confirm that we didn't break something. </p>
			<p>In the next section, we will add another text field and a button.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor377"/>Adding an address text field and a button</h2>
			<p>We <a id="_idIndexMarker385"/>need another text field for the address of the to-do item. Use your gained<a id="_idIndexMarker386"/> experience to add it yourself to the location section of the input form. To make your code consistent with the code of the book on <a id="_idTextAnchor378"/><a id="_idTextAnchor379"/>GitHub, name the property <strong class="source-inline">addressString</strong> in <strong class="source-inline">ToDoItemData</strong> and use the label <strong class="source-inline">Address</strong> in the <strong class="source-inline">TextField</strong> type.</p>
			<p>After <a id="_idIndexMarker387"/>entering the data for the to-do item, the user can<a id="_idIndexMarker388"/> add it to the list. For that task, we need a button in the user interface. Follow these steps to add the button:</p>
			<ol>
				<li value="1">Add the following test to <strong class="source-inline">ToDoItemInputViewTests</strong>:<p class="source-code">// T<a id="_idTextAnchor380"/><a id="_idTextAnchor381"/>oDoItemInputViewTests.swift</p><p class="source-code">func test_shouldHaveASaveButton() throws {</p><p class="source-code">  XCTAssertNoThrow(try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.Button.self,</p><p class="source-code">      where: { view in</p><p class="source-code">      let label = try view</p><p class="source-code">        .labelView()</p><p class="source-code">        .text()</p><p class="source-code">        .string()</p><p class="source-code">      return label == "Save"</p><p class="source-code">    }))</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to see this new test fail.</p>
			<ol>
				<li value="2">Add the following code within the Form of the body property of <strong class="source-inline">ToDoItemInputView</strong>:<a id="_idTextAnchor382"/><a id="_idTextAnchor383"/><p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">SwiftUI.Section {</p><p class="source-code">  Button(action: addToDoItem,</p><p class="source-code">    label: {</p><p class="source-code">    Text("Save")</p><p class="source-code">  })</p><p class="source-code">}</p></li>
				<li>To make<a id="_idIndexMarker389"/> this code compile, we need to<a id="_idIndexMarker390"/> add the action. Add the following method to <strong class="source-inline">ToDoItemInputView</strong> below the <strong class="source-inline">body</strong> propert<a id="_idTextAnchor384"/><a id="_idTextAnchor385"/>y:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">func addToDoItem() {</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that all tests now pass.</p>
			<p>Now we have all the user interface elements needed to move on to implementing adding the to-do item to the list of items in the next section.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor386"/>Testing button actions with ViewInspector </h1>
			<p>The user puts <a id="_idIndexMarker391"/>in the address for the to-do item. In the details view of an item, the app shows a map of that location. This means we <a id="_idIndexMarker392"/>need to convert the address of the item to a coordinate before we can add the item to the list. Apple provides a <strong class="source-inline">GeoCoder</strong> class for that task. We will write tests for fetching an address from a <strong class="source-inline">GeoCoder</strong> class in <a href="B18127_10_ePub.xhtml#_idTextAnchor444"><em class="italic">Chapter 10</em></a>, <em class="italic">Testing Networking Code</em>.</p>
			<p>In this chapter, we assume that we already have a class called <strong class="source-inline">APIClient</strong> that uses <strong class="source-inline">GeoCoder</strong> (or some similar service) to translate an address into a coordinate. In the test, we are going to use a mock object for that <strong class="source-inline">APIClient</strong> class. Follow these steps to add a protocol for the <strong class="source-inline">APIClient</strong> class and a mock conforming to that protocol:</p>
			<ol>
				<li value="1">Select the <strong class="bold">ToDo</strong> group in the project navigator and add a<a id="_idTextAnchor387"/><a id="_idTextAnchor388"/> new Swift file with the name <strong class="source-inline">APIClient.swift</strong>.</li>
				<li>Add the following protocol definition to th<a id="_idTextAnchor389"/><a id="_idTextAnchor390"/>at new file:<p class="source-code">// APIClient.swift</p><p class="source-code">protocol APIClientProtocol {</p><p class="source-code">  func coordinate(</p><p class="source-code">    for: String,</p><p class="source-code">    completion: (Coordinate?) -&gt; Void)</p><p class="source-code">}</p></li>
			</ol>
			<p>This protocol defines a function that takes a <strong class="source-inline">String</strong> instance and calls a <strong class="source-inline">completion</strong> handler with a <strong class="source-inline">Coordinate</strong> instance.</p>
			<ol>
				<li value="3">Select<a id="_idIndexMarker393"/> the <strong class="bold">ToDoTests</strong> group in the <a id="_idIndexMarker394"/>project navigator and add<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/> a new Swift file with the name <strong class="source-inline">APIClientMock.swift</strong>.</li>
				<li>Replace the contents of that file with the follo<a id="_idTextAnchor393"/><a id="_idTextAnchor394"/>wing code:<p class="source-code">// APIClientMock.swift</p><p class="source-code">import Foundation</p><p class="source-code">@testable <a id="_idTextAnchor395"/><a id="_idTextAnchor396"/>import ToDo</p><p class="source-code"> </p><p class="source-code">class APIClientMock: APIClientProtocol { </p><p class="source-code">  var coordinateAddress: String?</p><p class="source-code">  var coordinateReturnValue: Coordinate?</p><p class="source-code"> </p><p class="source-code">  func coordinate(</p><p class="source-code">    for address: String,</p><p class="source-code">    completion: (Coordinate?) -&gt; Void) { </p><p class="source-code">      coordinateAddress = address</p><p class="source-code">      completion(coordinateReturnValue)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this mock in place, we can write a test that asserts that the <strong class="source-inline">coordinate</strong> instance is fetched when the user taps the <strong class="bold">Save</strong> button. Follow these steps to add that test and the implementation that makes the test pass:</p>
			<ol>
				<li value="1">Add a new property (<strong class="source-inline">apiClientMock</strong>) to the <strong class="source-inline">ToDoItemInputViewTests</strong> class<a id="_idTextAnchor397"/><a id="_idTextAnchor398"/>:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">var apiClientMock: APIClientMock!</p></li>
				<li>In <strong class="source-inline">setUpWithError</strong>, initialize <a id="_idIndexMarker395"/>an API client mock and pass it into the initializer<a id="_idIndexMarker396"/> of <strong class="source-inline">ToDoItemInputView</strong>:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">override func setUpWithError() throw<a id="_idTextAnchor399"/><a id="_idTextAnchor400"/><a id="_idTextAnchor401"/>s {</p><p class="source-code">  toDoItemData = ToDoItemData()</p><p class="source-code">  apiClientMock = APIClientMock()</p><p class="source-code">  sut = ToDoItemInputView(</p><p class="source-code">    data: toDoItemData,</p><p class="source-code">    apiClient: apiClientMock)</p><p class="source-code">}</p></li>
				<li>Don't forget to set this property to <strong class="source-inline">nil</strong> in <strong class="source-inline">tearDownWithError</strong>:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">override func tearDownWithError() throws <a id="_idTextAnchor402"/><a id="_idTextAnchor403"/>{</p><p class="source-code">  sut = nil</p><p class="source-code">  toDoItemData = nil</p><p class="source-code">  apiClientMock = nil</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">ToDoItemInputView</strong> doesn't have a property for the API client. We need to add it before we can continue with the test.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">apiClient</strong> property to <strong class="source-inline">ToDoItemInp<a id="_idTextAnchor404"/><a id="_idTextAnchor405"/><a id="_idTextAnchor406"/>utView</strong>:<p class="source-code">// ToDoItemInputView.swift:</p><p class="source-code">let apiClient: APIClientProtocol</p></li>
			</ol>
			<p>As <strong class="source-inline">ToDoItemInputView</strong> is a structure, this new property changes the automatically generated initializer. We use this initializer in <strong class="source-inline">ToDoItemInputView_Previews</strong> in the same file.</p>
			<ol>
				<li value="5">Replace<a id="_idIndexMarker397"/> the <strong class="source-inline">ToDoItemInputView_Previews</strong> structure <a id="_idIndexMarker398"/>with the following implementation:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">struct ToDoItemInputView_Previews: PreviewProvider {</p><p class="source-code">  static var previews: some View {</p><p class="source-code">    ToDoItemInputView(data: ToDoItemData()<a id="_idTextAnchor407"/><a id="_idTextAnchor408"/>,</p><p class="source-code">      apiClient: APIClient())</p><p class="source-code">      .previewLayout(.sizeThatFits)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this code, we replaced the error with another. The implementation of <strong class="source-inline">APIClient</strong> is missing. </p>
			<ol>
				<li value="6">Add the following minimal implementation t<a id="_idTextAnchor409"/><a id="_idTextAnchor410"/>o <strong class="source-inline">APIClient.swift</strong>:<p class="source-code">// APIClient.swift</p><p class="source-code">class APIClient: APIClientProtocol {</p><p class="source-code">  func coordinate(</p><p class="source-code">    for: String,</p><p class="source-code">    completion: (Coordinate?) -&gt; Void) {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now<a id="_idIndexMarker399"/> we <a id="_idIndexMarker400"/>can add the test <a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>method:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_saveButton_shouldFetchCoordinate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  let expected = "dummy address"</p><p class="source-code">  toDoItemData.addressString = expected</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.Button.self,</p><p class="source-code">          where: { view in</p><p class="source-code">      let label = try view</p><p class="source-code">        .labelView()</p><p class="source-code">        .text()</p><p class="source-code">        .string()</p><p class="source-code">      return label == "Save"</p><p class="source-code">    })</p><p class="source-code">    .tap()</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(apiClientMock.coordinateAddress,</p><p class="source-code">    expected)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we set up the title and the address of the input data and tap the <strong class="bold">Save</strong> button. We expect that this fetches the <strong class="source-inline">coordinate</strong> instances for the address.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="8">Replace<a id="_idIndexMarker401"/> the <strong class="source-inline">addToDoItem()</strong> method<a id="_idIndexMarker402"/> in <strong class="source-inline">ToDoItemInputView</strong> with the following implementation:<p class="source-code">// ToD<a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>oItemInputView.swift</p><p class="source-code">func addToDoItem() {</p><p class="source-code">  apiClient.coordinate(</p><p class="source-code">    for: data.addressString,</p><p class="source-code">       completion: { coordinate in         </p><p class="source-code">  })</p><p class="source-code">}</p></li>
			</ol>
			<p>In this implementation, we call the <strong class="source-inline">coordinate(for:completion:)</strong> method defined in <strong class="source-inline">APIClientProtocol</strong>.</p>
			<p>Run the tests to confirm that all tests now pass.</p>
			<ol>
				<li value="9">But what if the user didn't add an address to the input form? In this case, the <strong class="source-inline">coordinate(for:completion:)</strong> method should not be called because there is no coordinate to be fetched. We need a test for this case. Add the following test to <strong class="source-inline">ToDoInputVie<a id="_idTextAnchor415"/><a id="_idTextAnchor416"/>wTests.swift</strong>:<p class="source-code">// ToDoInputViewTests.swift</p><p class="source-code">func test_save_whenAddressEmpty_</p><p class="source-code">  shouldNotFetchCoordinate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.Button.self,</p><p class="source-code">          where: { view in</p><p class="source-code">      let label = try view</p><p class="source-code">        .labelView()</p><p class="source-code">        .text()</p><p class="source-code">        .string()</p><p class="source-code">      return label == "Save"</p><p class="source-code">    })</p><p class="source-code">    .tap()</p><p class="source-code"> </p><p class="source-code">  XCTAssertNil(apiClientMock.coordinateAddress)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To<a id="_idIndexMarker403"/> make it pass, change the code in <strong class="source-inline">addToDoItem()</strong> so that<a id="_idIndexMarker404"/> it looks like this:<p class="source-code">// T<a id="_idTextAnchor417"/><a id="_idTextAnchor418"/>oDoItemInputView.swift</p><p class="source-code">func addToDoItem() {</p><p class="source-code">  if false == data.addressString.isEmpty {</p><p class="source-code">    apiClient.coordinate(</p><p class="source-code">      for: data.addressString,</p><p class="source-code">         completion: { coordinate in</p><p class="source-code">         })</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that all tests pass.</p>
			<p>After the <strong class="source-inline">coordinate</strong> has been fetched, the <strong class="source-inline">addToDoItem()</strong> method should call a delegate method to inform it that the input data is complete and the item can be constructed. Again, we will add a <strong class="source-inline">delegate</strong> protocol to define the interface of the <strong class="source-inline">delegate</strong> object. This <a id="_idIndexMarker405"/>helps when we create a mock object for the test.</p>
			<p>Follow these <a id="_idIndexMarker406"/>steps to add the tests and the implementation of calling the <strong class="source-inline">delegate</strong> protocol with the to-do item data:</p>
			<ol>
				<li value="1">Add the following protocol definition to <strong class="source-inline">ToDoItemInputView.swift</strong> outside of the <strong class="source-inline">ToDoItemIn<a id="_idTextAnchor419"/><a id="_idTextAnchor420"/>putView</strong> structure:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">protocol ToDoItemInputViewDelegate {</p><p class="source-code">  func addToDoItem(with: ToDoItemData,</p><p class="source-code">    coordinate: Coordinate?)</p><p class="source-code">}</p></li>
				<li>With this protocol in place, we can add a mock object to the test target. Select the <strong class="source-inline">ToDoTests</strong> group in the project n<a id="_idTextAnchor421"/><a id="_idTextAnchor422"/>avigator and add a Swift file with the name <strong class="source-inline">ToDoItemInputViewDelegateMock.swift</strong>. Add the following code to this new<a id="_idTextAnchor423"/><a id="_idTextAnchor424"/> file:<p class="source-code">// ToDoItemInputViewDelegateMock.swift</p><p class="source-code">import Foundation</p><p class="source-code">@testable import ToDo </p><p class="source-code"> </p><p class="source-code">class ToDoItemInputViewDelegateMock:</p><p class="source-code">  ToDoItemInputViewDelegate { </p><p class="source-code"> </p><p class="source-code">  var lastToDoItemData: ToDoItemData?</p><p class="source-code">  var lastCoordinate: Coordinate? </p><p class="source-code"> </p><p class="source-code">  func addToDoItem(with data: ToDoItemData,</p><p class="source-code">    coordinate: Coordinate?) { </p><p class="source-code"> </p><p class="source-code">    lastToDoItemData = data</p><p class="source-code">    lastCoordinate = coordinate</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now we <a id="_idIndexMarker407"/>can start with the test. Add the<a id="_idIndexMarker408"/> following test fragment to <strong class="source-inline">ToDoItem<a id="_idTextAnchor425"/><a id="_idTextAnchor426"/>InputViewTests</strong>:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_save_shouldCallDelegate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  toDoItemData.addressString = "dummy address"</p><p class="source-code">  apiClientMock.coordinateReturnValue =</p><p class="source-code">  Coordinate(latitude: 1, longitude: 2)</p><p class="source-code">  let delegateMock = ToDoItemInputViewDelegateMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">}</p></li>
			</ol>
			<p>Here we set up the <strong class="source-inline">apiClientMock</strong> property to return a dummy coordinate when <strong class="source-inline">coordinate(for:completion:)</strong> is called, and we create an instance of <strong class="source-inline">ToDoItemInputViewDelegateMock</strong> and set it to the <strong class="source-inline">delegate</strong> property of the system under test. This property is still missing and therefore, we have to pause writing the test and first add it to <strong class="source-inline">ToDoItemInputView</strong>.</p>
			<ol>
				<li value="4">Add this <strong class="source-inline">delegate</strong> property t<a id="_idTextAnchor427"/><a id="_idTextAnchor428"/>o <strong class="source-inline">ToDoItemInputView</strong>:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">var delegate: ToDoItemInputViewDelegate?</p></li>
			</ol>
			<p>This change makes the test compile and we can continue writing the test.</p>
			<ol>
				<li value="5">Complete<a id="_idIndexMarker409"/> the test method so that it <a id="_idIndexMarker410"/><a id="_idTextAnchor429"/><a id="_idTextAnchor430"/>looks as follows:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_save_shouldCallDelegate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  toDoItemData.addressString = "dummy address"</p><p class="source-code">  apiClientMock.coordinateReturnValue =</p><p class="source-code">  Coordinate(latitude: 1, longitude: 2)</p><p class="source-code">  let delegateMock = ToDoItemInputViewDelegateMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">  try sut</p><p class="source-code">    .inspect()</p><p class="source-code">    .find(ViewType.Button.self,</p><p class="source-code">          where: { view in</p><p class="source-code">      let label = try view</p><p class="source-code">        .labelView()</p><p class="source-code">        .text()</p><p class="source-code">        .string()</p><p class="source-code">      return label == "Save"</p><p class="source-code">    })</p><p class="source-code">    .tap()</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(delegateMock.lastToDoItemData?.title,</p><p class="source-code">    "dummy title")</p><p class="source-code">  XCTAssertEqual(delegateMock.lastCoordinate?</p><p class="source-code">    .latitude, 1)</p><p class="source-code">  XCTAssertEqual(delegateMock.lastCoordinate?</p><p class="source-code">    .longitude, 2)</p><p class="source-code">}</p></li>
			</ol>
			<p>Usually, I try to keep all the relevant code in the test. But in this case, the test method is a bit <a id="_idIndexMarker411"/>messy. As an example, let's move the inspector code into a method.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker412"/> following extension in <strong class="source-inline">ToDoItemInputViewTests.swift</strong> below the <strong class="source-inline">ToDoItemIn<a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>putViewTests</strong> class:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">extension ToDoItemInputView {</p><p class="source-code">  func tapButtonWith(name: String) throws {</p><p class="source-code">    try inspect()</p><p class="source-code">      .find(ViewType.Button.self,</p><p class="source-code">        where: { view in</p><p class="source-code">        let label = try view</p><p class="source-code">          .labelView()</p><p class="source-code">          .text()</p><p class="source-code">          .string()</p><p class="source-code">        return label == name</p><p class="source-code">      })</p><p class="source-code">      .tap()</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>With this extension we can write the last test as follows:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_save_shouldCallDelegate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  toDoItemData.addressString = "dummy address"</p><p class="source-code">  apiClientMock.coordinateReturnValue =</p><p class="source-code">  Coordinate(latitude: 1, longitude: 2)</p><p class="source-code">  let delegateMock = ToDoItemInput<a id="_idTextAnchor433"/><a id="_idTextAnchor434"/>ViewDelegateMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">  try sut.tapButtonWith(name: "Save")</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(delegateMock.lastToDoItemData?.title,</p><p class="source-code">    "dummy title")</p><p class="source-code">  XCTAssertEqual(delegateMock.lastCoordinate?</p><p class="source-code">    .latitude, 1)</p><p class="source-code">  XCTAssertEqual(delegateMock.lastCoordinate?</p><p class="source-code">    .longitude, 2)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this case, this is a bit better than the original version.</p>
			<ol>
				<li value="8">To <a id="_idIndexMarker413"/>make<a id="_idIndexMarker414"/> this test pass, replace the implementation of <strong class="source-inline">addToDoItem()</strong> with the following <a id="_idTextAnchor435"/><a id="_idTextAnchor436"/>code:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">func addToDoItem() {</p><p class="source-code">  if false == data.addressString.isEmpty {</p><p class="source-code">    apiClient.coordinate(</p><p class="source-code">      for: data.addressString,</p><p class="source-code">         completion: { coordinate in</p><p class="source-code">           self.delegate?.addToDoItem(</p><p class="source-code">            with: data,</p><p class="source-code">            coordinate: coordinate)</p><p class="source-code">         })</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the completion closure, we now call the <strong class="source-inline">addToDoItem(with:coordinate:)</strong> method.</p>
			<p>Run the tests to confirm that this change makes all tests pass.</p>
			<ol>
				<li value="9">But <a id="_idIndexMarker415"/>what if the user didn't add an <a id="_idIndexMarker416"/>address for the to-do item? Add the following test to make sure that, in this case, the <strong class="source-inline">delegate</strong> m<a id="_idTextAnchor437"/><a id="_idTextAnchor438"/>ethod also gets called:<p class="source-code">// ToDoItemInputViewTests.swift</p><p class="source-code">func test_save_whenAddressEmpty_</p><p class="source-code">  shouldCallDelegate() throws {</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  apiClientMock.coordinateReturnValue =</p><p class="source-code">  Coordinate(latitude: 1, longitude: 2)</p><p class="source-code">  let delegateMock = ToDoItemInputViewDelegateMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code"> </p><p class="source-code">  try sut.tapButtonWith(name: "Save")</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(delegateMock.lastToDoItemData?.title,</p><p class="source-code">    "dummy title")</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To make<a id="_idIndexMarker417"/> this test pass, replace <strong class="source-inline">addToDoItem()</strong> in <strong class="source-inline">ToDoItemInputView</strong> with <a id="_idIndexMarker418"/>the following code:<p class="source-code">// ToDoItemInputView.swift</p><p class="source-code">func addToDoItem() {</p><p class="source-code">  if false == data.addressString.isEmpty {</p><p class="source-code">    apiClient.coordinate(</p><p class="source-code">      for: data.addressString,</p><p class="source-code">         completion: { coordinate in</p><p class="source-code">           self.delegate?.addToDoItem(</p><p class="source-code">            with:<a id="_idTextAnchor439"/><a id="_idTextAnchor440"/> data,</p><p class="source-code">            coordinate: coordinate)</p><p class="source-code">         })</p><p class="source-code">  } else {</p><p class="source-code">    delegate?.addToDoItem(with: data,</p><p class="source-code">      coordinate: nil)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>If the <strong class="source-inline">address</strong> string is empty, we call the <strong class="source-inline">delegate</strong> method without a <strong class="source-inline">coordinate</strong> instance.</p>
			<p>Run all tests. All tests pass again.</p>
			<p>The input view is now complete and we can move on to implementing some networking code.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor441"/>Summary</h1>
			<p>Testing SwiftUI code works a bit differently from testing UIKit code. One reason for this is that SwiftUI itself works completely differently. In addition, Apple doesn't provide a testing framework for SwiftUI code because they believe that user interface code should be tested with UITest.</p>
			<p>I don't think that's true. UITest solve a different problem. I believe you should have access to both kinds of tests, and you should choose the right tool for the problem at hand.</p>
			<p>Fortunately, with ViewInspector we have a powerful third-party solution that fills this gap. In this chapter, we added it as a SwiftUI package to the unit test target. We used the package to write unit tests for SwiftUI code and build an input view for to-do items following test-driven development. </p>
			<p>This way, we learned how to add SwiftUI packages to test targets and how to use this specific SwiftUI package to write tests for things that aren't easily testable without it.</p>
			<p>In the next chapter, we will learn how to write unit tests for networking code.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor442"/>Exercises</h1>
			<ol>
				<li value="1">Add more convenient methods in the extension of <strong class="source-inline">ToDoItemInputView</strong> in <strong class="source-inline">ToDoItemInputViewTests.swift</strong> to make the tests easier to read as we did for <strong class="source-inline">test_save_shouldCallDelegate()</strong>. What are the advantages of these helper methods? What are the disadvantages?</li>
				<li>When the user provides an address, but <strong class="source-inline">GeoCoder</strong> cannot find the coordinate to that address, the app should show an alert and ask the user if they still want to save the item. Go to the GitHub repository of <strong class="source-inline">ViewInspector</strong> (<a href="https://github.com/nalexn/ViewInspector">https://github.com/nalexn/ViewInspector</a>) and find out how you can test the presentation of an alert. Then write the test that asserts that the alert is presented and implement that feature.</li>
			</ol>
		</div>
	</body></html>