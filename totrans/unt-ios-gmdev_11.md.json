["```swift\nusing UnityEngine;\nusing System;\nusing System.Collections;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\npublic class ObjectPool : MonoBehaviour\n{\npublic static ObjectPool instance;\n/// <summary>\n/// The object prefabs which the pool can handle.\n/// </summary>\npublic GameObject[] objectPrefabs;\n/// <summary>\n/// The pooled objects currently available.\n/// </summary>\npublic List<GameObject>[] pooledObjects;\n/// <summary>\n/// The amount of objects of each type to buffer.\n/// </summary>\npublic int[] amountToBuffer;\npublic int defaultBufferAmount = 3;\n/// <summary>\n/// The container object that we will keep unused pooled objects /// so we dont clog up the editor with objects.\n/// </summary>\nprotected GameObject containerObject;\nvoid Awake ()\nprofilingobject pooling{\ninstance = this;\n}\n// Use this for initialization\nvoid Start ()\n{\ncontainerObject = new GameObject(\"ObjectPool\");\n//Loop through the object prefabs and make a new list for //each one.\n//We do this because the pool can only support prefabs set to it //in the editor,\n//so we can assume the lists of pooled objects are in the same //order as object prefabs in the array\npooledObjects = new List<GameObject>[objectPrefabs.Length];\nint i = 0;\nforeach ( GameObject objectPrefab in objectPrefabs )\n{\npooledObjects[i] = new List<GameObject>();\nint bufferAmount;\nif(i < amountToBuffer.Length) bufferAmount = amountToBuffer[i];\nelse\nbufferAmount = defaultBufferAmount;\nfor ( int n=0; n<bufferAmount; n++)\n{\nGameObject newObj = Instantiate(objectPrefab) as GameObject;\nnewObj.name = objectPrefab.name;\nPoolObject(newObj);\n}\ni++;\n}\n}\n/// <summary>\nprofilingobject pooling/// Gets a new object for the name type provided. If no object type /// exists or if onlypooled is true and there is no objects of that /// type in the pool\n/// then null will be returned.\n/// </summary>\n/// <returns>\n/// The object for type.\n/// </returns>\n/// <param name='objectType'>\n/// Object type.\n/// </param>\n/// <param name='onlyPooled'>\n/// If true, it will only return an object if there is one currently /// pooled.\n/// </param>\npublic GameObject GetObjectForType ( string objectType , bool onlyPooled )\n{\nfor(int i=0; i<objectPrefabs.Length; i++)\n{\nGameObject prefab = objectPrefabs[i];\nif(prefab.name == objectType)\n{\nif(pooledObjects[i].Count > 0)\n{\nGameObject pooledObject = pooledObjects[i][0];\npooledObjects[i].RemoveAt(0);\npooledObject.transform.parent = null;\npooledObject.SetActiveRecursively(true);\nreturn pooledObject;\n}\nelse if(!onlyPooled) {\nreturn Instantiate(objectPrefabs[i]) as GameObject;\n}\nbreak;\n}\n}\n//If we have gotten here either there was no object of the specified //type or none were left in the pool with onlyPooled set to true\nreturn null;\nprofilingobject pooling}\n/// <summary>\n/// Pools the object specified. Will not be pooled if there are no /// prefab of that type.\n/// </summary>\n/// <param name='obj'>\n/// Object to be pooled.\n/// </param>\npublic void PoolObject ( GameObject obj )\n{\nfor ( int i=0; i<objectPrefabs.Length; i++)\n{\nif(objectPrefabs[i].name == obj.name)\n{\nobj.SetActiveRecursively(false);\nobj.transform.parent = containerObject.transform;\npooledObjects[i].Add(obj);\nreturn;\n}\n}\n}\n}\n\n```", "```swift\n    void fireWeapon()\n    {\n    GameObject bullet = ObjectPool.instance.GetObjectForType( \"Bullet\" , true);\n    bullet.transform.position = spawnPoint.transform.position;\n    bullet.transform.rotation = spawnPoint.transform.rotation;\n    }\n\n    ```"]