- en: Getting Started with Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程入门
- en: Functional programming has been making big waves in the software industry for
    the last five years, and everyone wants to jump on the bandwagon. Functional programming
    is a lot older, starting in the 1950s with **Lisp** being considered the first
    programming language (or at least, the first one to introduce functional features)
    which still exists as **Common Lisp,** and other dialects such as **Scheme** and
    **Clojure**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在过去五年中在软件行业中引起了巨大波澜，每个人都想搭上这趟车。函数式编程的历史要悠久得多，始于20世纪50年代，**Lisp**被认为是第一种编程语言（或者至少是第一个引入函数式特性的语言），它仍然以**Common
    Lisp**的形式存在，以及其他方言，如**Scheme**和**Clojure**。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is functional programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Basic concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本概念
- en: Functional collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式集合
- en: Implementing a functional list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现函数式列表
- en: What is functional programming?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: '**Functional programming** is a paradigm (a style of structuring your programs).
    In essence, the focus is on transforming data with expressions (ideally such expressions
    should not have side effects). Its name, functional, is based on the concept of
    a mathematical function (not in sub-routines, methods, or procedures). A mathematical
    function defines a relation between a set of inputs and outputs. Each input has
    just one output. For example, given a function, *f(x) = X²; f(5)* is always *25*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**是一种范式（一种组织程序的风格）。本质上，重点是使用表达式转换数据（理想情况下，这些表达式不应有副作用）。其名称“函数式”基于数学函数的概念（而不是子程序、方法或过程）。数学函数定义了一组输入和输出之间的关系。每个输入只有一个输出。例如，给定一个函数，*f(x)
    = X²; f(5)* 总是 *25*。'
- en: 'The way to guarantee, in a programming language, that calling a function with
    a parameter always returns the same value, is to avoid accessing to mutable state:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，为了保证调用带有参数的函数总是返回相同的值，需要避免访问可变状态：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `f` function doesn''t access any external state; therefore, calling *f(5)*
    will always return *25*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 函数不访问任何外部状态；因此，调用 *f(5)* 总是返回 *25*：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `g` function, on the other hand, depends on mutable state and returns different
    values for the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`g` 函数依赖于可变状态，并且对于相同的输入返回不同的值。
- en: Now, in a real-life program (a **Content Management System** (**CMS**), shopping
    cart, or chat), state changes. So, in a functional programming style, state management
    must be explicit and careful. The techniques to manage state change in functional
    programming will be covered later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在现实生活中的程序（一个**内容管理系统**（**CMS**）、购物车或聊天程序）中，状态会发生变化。因此，在函数式编程风格中，状态管理必须是明确和谨慎的。在后面的章节中，我们将介绍在函数式编程中管理状态变化的技术。
- en: 'A functional programming style will provide us with the following benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程风格将为我们提供以下好处：
- en: '**Code is easy to read and test**: Functions that don''t depend on external
    mutable state are more accessible to reason about and to prove'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码易于阅读和测试**：不依赖于外部可变状态的功能更容易推理和证明'
- en: '**State and side effects are carefully planned**: Limiting state management
    to individual and specific places in our code makes it easy to maintain and refactor'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态和副作用是精心规划的**：将状态管理限制在我们代码的个体和特定位置，使得维护和重构变得容易'
- en: '**Concurrency gets safer and more natural**: No mutable state means that concurrency
    code needs less or no locks around your code'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性变得更安全且更自然**：没有可变状态意味着并发代码在你的代码周围需要更少或没有锁'
- en: Basics concepts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本概念
- en: Functional programming is composed of a few well-defined concepts. A short introduction
    of these concepts will follow and, later on, each concept will be covered in depth,
    in the next chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程由几个定义良好的概念组成。以下是对这些概念的简要介绍，稍后将在下一章中深入探讨每个概念。
- en: First-class and higher-order functions
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等和高级函数
- en: The most foundational concept of functional programming is **first-class functions**.
    A programming language with support for first-class functions will treat functions
    as any other type; such languages will allow you to use functions as variables,
    parameters, returns, generalization types, and so on. Speaking of parameters and
    returns, a function that uses or returns other functions is a **higher-order function**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程最基础的概念是**一等函数**。支持一等函数的编程语言会将函数视为任何其他类型；这样的语言将允许你使用函数作为变量、参数、返回值、泛化类型等。说到参数和返回值，使用或返回其他函数的函数是**高阶函数**。
- en: Kotlin has support for both concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持这两个概念。
- en: 'Let''s try a simple function (in Kotlin''s documentation this kind of function
    is named lambda):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的函数（在Kotlin的文档中这种函数被称为lambda）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `capitalize` lambda function is of type `(String) -> String`; in other words,
    `capitalize` will take `String` and return another `String`—in this case, a capitalized
    `String`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`lambda函数的类型是`(String) -> String`；换句话说，`capitalize`将接受`String`并返回另一个`String`——在这种情况下，一个首字母大写的`String`。'
- en: As a lambda function, `capitalize` can be executed using parentheses with parameters
    (or no parameters at all, depending on the situation).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为lambda函数，`capitalize`可以用带参数的括号（或者完全没有参数，具体取决于情况）来执行。
- en: But what does the `(String) -> String` type mean?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但`(String) -> String`类型意味着什么呢？
- en: '`(String) -> String` is a shortcut (some could call it syntactic sugar) for
    `Function1<String, String>`, `Function1<P1, R>` is an interface defined in the
    Kotlin standard library. `Function1<P1, R>` has a single method, `invoke(P1):
    R`, that is marked as an operator (we''ll cover operators later).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`(String) -> String`是一个快捷方式（有些人可能称之为语法糖），它是`Function1<String, String>`的简称，`Function1<P1,
    R>`是在Kotlin标准库中定义的一个接口。`Function1<P1, R>`有一个标记为操作符的方法`invoke(P1): R`（我们稍后会介绍操作符）。'
- en: 'Kotlin''s compiler can translate the shortcut syntax into a fully fledged function
    object at compile time (indeed, the compiler will apply many more optimizations)
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的编译器可以在编译时将快捷语法转换为完整的函数对象（实际上，编译器还会应用更多的优化），如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is equivalent to the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它等同于以下代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the `capitalize` value's body is located inside the `invoke` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`capitalize`值的主体位于`invoke`方法内部。
- en: In Kotlin, lambda functions can be used as parameters in other functions as
    well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，lambda函数也可以用作其他函数的参数。
- en: 'Let''s take a look at the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `transform(String, (String) -> String)` function takes one `String` and
    applies a lambda function to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform(String, (String) -> String)`函数接受一个`String`并对其应用一个lambda函数。'
- en: 'For all intents and purposes, we can generalize `transform`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有目的来看，我们可以泛化`transform`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using `transform` is very simple. Take a look at the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`transform`非常简单。看看下面的代码片段：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can pass `capitalize` as a parameter directly, great stuff.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接传递`capitalize`作为参数，真是太棒了。
- en: 'There are more ways to call the `transform` function. Let''s try some more:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`transform`函数的方式有很多。让我们再试几个：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`reverse` is a function; we can pass a reference to it using a double colon
    (`::`) as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`是一个函数；我们可以使用双冒号（`::`）来传递它的引用，如下所示：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`doNothing` is an object method, and in this case, we use `::` after the `MyUtils`
    object name:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`doNothing`是一个对象方法，在这种情况下，我们在`MyUtils`对象名称后使用`::`：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also pass references to instances or companion object methods. But probably
    the most common case is to pass a lambda directly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递实例或伴生对象的引用。但最常见的情况可能是直接传递一个lambda表达式：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is a shorter version of this using the `it` implicit parameter as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`it`隐式参数的简短版本如下：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`it` is an implicit parameter (you don''t declare it explicitly) that can be
    used in lambdas with just one parameter.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`是一个隐式参数（你不需要显式声明它），它可以用作只有一个参数的lambda表达式。'
- en: Although it is tempting to use `it` for all cases, once you start using it with
    successive or nested lambdas, they can be difficult to read. Use it sparingly
    and when it is clear which type it is (no pun intended).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`it`在所有情况下都很诱人，但一旦你开始使用连续或嵌套的lambda，它们可能会很难阅读。要谨慎使用，并且当它清楚类型时（没有打趣的意思）。
- en: 'If a function receives a lambda as the last parameter, the lambda can be passed
    outside the parentheses:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数将lambda作为最后一个参数接收，lambda可以放在括号之外传递：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This feature opens up the possibility of creating **Domain Specific Language** (**DSL**)
    with Kotlin.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性为使用Kotlin创建**领域特定语言**（**DSL**）打开了可能性。
- en: Do you know about the `unless` flow control statement from **Ruby**? `unless`
    is a control statement that executes a block of code if a condition is `false`;
    it's kind of a negated `if` condition but without an `else` clause.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道**Ruby**中的`unless`流程控制语句吗？`unless`是一个在条件为`false`时执行代码块的控制语句；它有点像否定`if`条件，但没有`else`子句。
- en: 'Let''s create a version for Kotlin by executing the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码片段来为Kotlin创建一个版本：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`unless` receives a condition as a Boolean and blocks to execute as a lambda
    `() -> Unit` (no parameters and no return). When `unless` is executed, it looks
    exactly like any other Kotlin''s control flow structure.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless` 接收一个布尔条件作为参数，并以 lambda `() -> Unit`（无参数和无返回值）的形式阻塞执行。当 `unless` 执行时，它看起来就像
    Kotlin 的任何其他控制流结构。'
- en: 'Now, type alias can be mixed with functions and used to replace simple interfaces.
    Let''s take the following example, our `Machine<T>` interface from [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml),
    *Kotlin – Data Types, Objects, and Classes*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型别名可以与函数混合使用，以替换简单的接口。以下是一个例子，来自 [第 1 章](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml)，*Kotlin
    – 数据类型、对象和类*：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It can be replaced with a type alias and used with all the function''s syntactical
    features:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用类型别名替换，并使用所有函数的语法特性：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pure functions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: '**Pure functions** don''t have side effects, nor memory, nor I/O. Pure functions
    have many properties, including referential transparency, caching (memoization),
    and others (we''ll cover these features in the next chapters).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数** 没有副作用，也没有内存或 I/O。纯函数有许多属性，包括引用透明性、缓存（记忆化）以及其他（我们将在下一章中介绍这些功能）。'
- en: It is possible to write pure functions in Kotlin, but the compiler doesn't enforce
    it as in other languages. It is up to you to create pure functions to enjoy its
    benefits. Because Kotlin doesn't enforce pure functions, many programmers said
    that Kotlin isn't a real functional programming tool, and maybe they are right.
    Yes, Kotlin doesn't enforce pure functional programming, and that gives you great
    flexibility including the ability to write in a purely functional style, if you
    wish.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中可以编写纯函数，但编译器不会像其他语言那样强制执行。是否创建纯函数以享受其好处取决于你。因为 Kotlin 不强制执行纯函数，所以许多程序员说
    Kotlin 不是一个真正的函数式编程工具，也许他们是对的。是的，Kotlin 不强制执行纯函数式编程，这为你提供了极大的灵活性，包括如果你愿意，可以以纯函数式风格编写代码。
- en: Recursive functions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: '**Recursive functions** are functions that invoke themselves, with some sort
    of condition to stop the execution. In Kotlin, a recursive function maintains
    a stack but can be optimized with a `tailrec` modifier.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归函数** 是调用自身的函数，具有某种停止执行的条件。在 Kotlin 中，递归函数维护一个栈，但可以使用 `tailrec` 修饰符进行优化。'
- en: Let's look at an example, an implementation of a `factorial` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，一个 `阶乘` 函数的实现。
- en: 'First, let''s take a look at a typical imperative implementation, loops, and
    state change in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个典型的命令式实现，以下代码片段中的循环和状态变化：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s nothing fancy nor particularly elegant. Now, let''s take a look at a
    recursive implementation, no loops, and no state change:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有什么特别之处，也不特别优雅。现在，让我们看看一个递归实现，没有循环，也没有状态变化：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use an internal recursive function; the `go` function calling itself until
    a condition is reached. As you can see, we're starting with the last `n` value
    and reducing it in each recursive iteration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个内部递归函数；`go` 函数在达到条件之前调用自身。正如你所看到的，我们是从最后一个 `n` 值开始的，并在每次递归迭代中减少它。
- en: 'An optimized implementation is similar but with a `tailrec` modifier:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 优化后的实现类似，但带有 `tailrec` 修饰符：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test which implementation is faster, we can write a poor''s man profiler
    function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试哪个实现更快，我们可以编写一个简陋的分析函数：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For our purposes, the `executionTime` function is okay, but any serious production
    code should be profiled with a proper profiling tool, such as **Java Microbenchmark
    Harness** (**JMH**):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，`executionTime` 函数是可行的，但任何严肃的生产代码都应该使用适当的分析工具进行性能分析，例如 **Java Microbenchmark
    Harness**（**JMH**）：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s the output for the preceding code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/509fc2ef-db76-46ac-b62c-801fe5d72a9b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/509fc2ef-db76-46ac-b62c-801fe5d72a9b.png)'
- en: The `tailrec` optimized version is even faster than the normal imperative version.
    But `tailrec` isn't a magic incantation that will make your code run faster. As
    a general rule, the `tailrec` optimized code will run faster than the unoptimized
    version, but will not always beat a good old imperative code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`tailrec` 优化的版本甚至比正常的命令式版本更快。但 `tailrec` 不是一个魔法咒语，可以使你的代码运行得更快。一般来说，`tailrec`
    优化的代码将比未优化的版本运行得更快，但并不总是能打败好的旧命令式代码。'
- en: 'Let''s explore a Fibonacci implementation, starting with an imperative one
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个斐波那契数列的实现，从一个命令式实现开始如下：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s take a look at a functional recursive implementation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个函数式递归实现：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s check with its corresponding `tailrec` version, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查其对应的 `tailrec` 版本，如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then again, let''s see its profiling with `executionTime`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次，让我们用 `executionTime` 来查看其分析：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will look something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![](img/dbce955f-92b2-4ae5-a35e-4650eedd6043.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/dbce955f-92b2-4ae5-a35e-4650eedd6043.png)'
- en: The `tailrec` implementation is much faster than the recursive version, but
    not as fast as a normal imperative implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`tailrec` 实现比递归版本快得多，但不如正常命令式实现快。'
- en: Lazy evaluation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Some functional languages provide a `lazy` (non-strict) evaluation mode. Kotlin,
    by default, uses an *eager (strict) evaluation*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式语言提供了 `lazy`（非严格）评估模式。Kotlin 默认使用 *贪婪（严格）评估*。
- en: 'Kotlin doesn''t provide native support for lazy evaluation as part of the language
    itself, but as part of Kotlin''s Standard Library and a language feature named
    **delegate properties** (we''ll cover this in detail in future chapters):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 本身不提供对懒加载的原生支持，但作为 Kotlin 标准库的一部分，以及一个名为 **委托属性** 的语言特性（我们将在未来的章节中详细讨论）：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output will look something like the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图：
- en: '![](img/0c3a2d43-47e1-40d2-9f6b-79bbaf6f870e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![内容](img/0c3a2d43-47e1-40d2-9f6b-79bbaf6f870e.png)'
- en: After the `by` reserved word, the `lazy()` higher-function receives an `(()
    -> T)` initializer lambda function that will be executed the first time that `i`
    is accessed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `by` 保留字之后，`lazy()` 高阶函数接收一个 `(() -> T)` 初始化 lambda 函数，该函数将在第一次访问 `i` 时执行。
- en: 'But also a normal lambda function can be used for some lazy use cases:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但也可以使用正常的 lambda 函数来处理一些懒加载用例：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we try to execute this expression, it will throw an `ArithmeticException` exception,
    as we are dividing by zero:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行这个表达式，它将抛出一个 `ArithmeticException` 异常，因为我们正在除以零：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's no problem executing this. The offending code isn't being executed,
    effectively making it a `lazy` evaluation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个没有问题。出问题的代码没有被执行，实际上使其成为一个 `lazy` 评估。
- en: Functional collections
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能集合
- en: '**Functional collections** are collections that offer a way to interact with
    its elements through high-order functions. Functional collections have common
    operations with names such as `filter`, `map`, and `fold`; these names are defined
    by convention (similar to a design pattern) and are being implemented in several
    libraries and languages.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式集合** 是那些通过高阶函数提供与其元素交互方式的集合。函数式集合具有名为 `filter`、`map` 和 `fold` 等常见操作；这些名称是通过约定（类似于设计模式）定义的，并在多个库和语言中实现。'
- en: Don't get confused with purely functional data structures—a data structure implemented
    in a pure functional language. A purely functional data structure is immutable
    and uses the `lazy` evaluation and other functional techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与纯函数式数据结构混淆——这是在纯函数式语言中实现的数据结构。纯函数式数据结构是不可变的，并使用 `lazy` 评估和其他函数式技术。
- en: Functional collections can but needn't necessarily be purely functional data
    structures. We have already covered how imperative implementations of algorithms
    can be faster than functional ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式集合可以是，但不一定是纯函数式数据结构。我们已经讨论了算法的命令式实现可以比函数式实现更快。
- en: 'Kotlin comes with an excellent functional collection library. Let''s have a
    look at it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 随带一个优秀的函数式集合库。让我们看看它：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our value `numbers` as a `List<Int>` type. Now, let''s print its members as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的价值 `numbers` 是一个 `List<Int>` 类型的值。现在，让我们按照以下方式打印其成员：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So far, so good, but it doesn't look very functional.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但它看起来并不太像函数式。
- en: 'Worry no more; Kotlin collections include many functions that receive lambdas
    to operate on their members. We can replace this loop with a lambda as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不必再担心；Kotlin 集合包括许多接收 lambda 来操作其成员的函数。我们可以用 lambda 替换这个循环，如下所示：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s transform our collection in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下代码中转换我们的集合：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code doesn''t compile; `numberTwice` doesn''t have an `add(T)` method.
    `List<T>` is an immutable list; it can be modified once it is initialized. To
    add elements to a list, it must have a different type—`MutableList<T>` in our
    case:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译；`numberTwice` 没有提供 `add(T)` 方法。`List<T>` 是一个不可变列表；一旦初始化，它就可以被修改。要向列表中添加元素，它必须具有不同的类型——在我们的例子中是
    `MutableList<T>`：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`MutableList<T>` extends `List<T>`; it adds the methods to modify the collection
    itself, such as `add(T)`, `remove(T)`, `clear`, and others.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableList<T>` 扩展了 `List<T>`；它添加了修改集合本身的方法，例如 `add(T)`、`remove(T)`、`clear`
    以及其他方法。'
- en: All major Kotlin collection types (`List<T>`, `Set<T>`, and `Map<K, V>`) have
    mutable subtypes (`MutableList<T>`, `MutableSet<T>`, and `MutableMap<K, V>`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的所有主要集合类型（`List<T>`, `Set<T>`, 和 `Map<K, V>`）都有可变子类型（`MutableList<T>`,
    `MutableSet<T>`, 和 `MutableMap<K, V>`）。
- en: 'But we can replace this transformation with a single line expression as shown
    in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以将这个转换替换为以下代码中的单行表达式：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `map` operation lets you transform (technically mapping a value to another).
    This code has many advantages and is a lot cleaner, and now the `numbersTwice` value
    is a `List<Int>` list, instead of a `MutableList<T>` list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作允许你转换（技术上是对值进行映射）。这段代码有很多优点，并且更加简洁，现在 `numbersTwice` 的值是一个 `List<Int>`
    列表，而不是 `MutableList<T>` 列表。'
- en: 'Let''s have another couple of examples. We can sum all elements of numbers
    using a loop:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举几个例子。我们可以使用循环来计算数字的所有元素之和：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It could be reduced to just one line, with an immutable `sum` value as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为只有一行，使用不可变的 `sum` 值如下：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Nice, but not interesting, so let''s raise the stakes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但不是很吸引人，所以让我们提高难度：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `fold` method iterates over a collection, keeping an accumulator value.
    `fold` takes a `T` value as the initial value; in the first iteration, this initial
    value will be the accumulator and subsequent iterations will use the lambda''s
    return as the next accumulator value:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 方法遍历一个集合，保持一个累加器值。`fold` 接收一个 `T` 值作为初始值；在第一次迭代中，这个初始值将是累加器，后续迭代将使用
    lambda 的返回值作为下一个累加器值：'
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will look something like the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图：
- en: '![](img/0a7a4251-1ffb-4166-b1ba-6db828a58893.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0a7a4251-1ffb-4166-b1ba-6db828a58893.png)'
- en: 'Similar to `fold`, `reduce` iterates over a collection, with an accumulator
    but without an initial value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `fold` 类似，`reduce` 遍历一个集合，有一个累加器但没有初始值：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output will look something like the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图：
- en: '![](img/df2b6f1c-7909-4232-a5c6-546735c1e5c4.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/df2b6f1c-7909-4232-a5c6-546735c1e5c4.png)'
- en: '`fold` and `reduce` have counterparts in `foldRight` and `reduceRight` that
    start iterating from the last item to the first.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 和 `reduce` 有对应的 `foldRight` 和 `reduceRight`，它们从最后一个项目开始迭代到第一个项目。'
- en: Implementing a functional list
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个函数式列表
- en: 'With everything that we''ve learned in the first two chapters, we can implement
    a pure functional list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章学到的所有知识的基础上，我们可以实现一个纯函数式列表：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `FunList` class is a sealed class; just two possible subclasses exist—`Nil`,
    an empty list (in other books you can see this defined as `Null` or `Empty`) and
    `Cons` (a construct, name inherited from Lisp, that holds two values).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunList` 类是一个密封类；只有两个可能的子类存在——`Nil`，一个空列表（在其他书中你可以看到它被定义为 `Null` 或 `Empty`）和
    `Cons`（一个结构，名称来自 Lisp，它包含两个值）。'
- en: The `T` type is marked `out`; this is for variance, which we'll cover variance
    in future chapters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 类型被标记为 `out`；这是为了变异性，我们将在未来的章节中介绍变异性。'
- en: '`Nil` is an object (we don''t need different instances of `Nil`) extending
    `FunList<Nothing>` (remember that `Nothing` is the bottom of Kotlin''s type hierarchy).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil` 是一个对象（我们不需要 `Nil` 的不同实例）扩展 `FunList<Nothing>`（记住 `Nothing` 是 Kotlin 类型层次结构的底部）。'
- en: The `Cons` value contains two values—`head`, a single `T`, and `tail`, a `FunList<T>`;
    therefore, it can be a `Nil` value or another `Cons`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cons` 值包含两个值——`head`，一个单独的 `T`，和 `tail`，一个 `FunList<T>`；因此，它可以是一个 `Nil` 值或另一个
    `Cons`。'
- en: 'Let''s create a list instance as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个列表实例如下：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It''s functional, but not very readable. We can create a better initialization
    function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它是函数式的，但不是很易读。我们可以创建一个更好的初始化函数：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are quite a few new things here. The argument numbers are marked as `vararg`,
    which means that we can invoke this function with as many parameters as we want.
    For all intents and purposes, `numbers` is an `IntArray` value (a specialized
    type of array). If `numbers` is empty, we can return `Nil`. If not, we can extract
    the first element as our `head` value and recursively invoke `intLisfOf` for the
    `tail` value. To extract the `tail` value, we use the `drop` method and convert
    its result to an `IntArray` value. But we can't directly pass any array as `vararg`;
    therefore, we must use the spread (`*`) operator to pass each member of an array
    individually.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新东西。参数 `numbers` 被标记为 `vararg`，这意味着我们可以用尽可能多的参数调用这个函数。从所有目的来看，`numbers`
    是一个 `IntArray` 值（一种特殊的数组类型）。如果 `numbers` 为空，我们可以返回 `Nil`。如果不为空，我们可以提取第一个元素作为我们的
    `head` 值，并递归调用 `intListOf` 来获取 `tail` 值。为了提取 `tail` 值，我们使用 `drop` 方法并将结果转换为 `IntArray`
    值。但我们不能直接将任何数组作为 `vararg` 传递；因此，我们必须使用展开（`*`）运算符来逐个传递数组的每个成员。
- en: 'Now, we can create our `FunList<Int>` value:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的 `FunList<Int>` 值：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s implement `forEach ` as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式实现 `forEach`：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `forEach` implementation is similar to our examples of Factorial and Fibonacci
    functions in the recursion section, including `tailrec`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 的实现类似于我们在递归部分中的阶乘和斐波那契函数的例子，包括 `tailrec`。'
- en: '`FunList` is, technically, an **Algebraic Data Type** (**ADT**). `FunList`
    can be either a `Nil` or `Cons` and nothing else. Kotlin''s compiler can use this
    information to check that both values are evaluated when a `FunList` type is used
    as the argument in a `when` control structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，`FunList` 是一个 **代数数据类型**（**ADT**）。`FunList` 可以是 `Nil` 或 `Cons`，除此之外没有其他可能。Kotlin
    的编译器可以使用这些信息来检查当 `FunList` 类型用作 `when` 控制结构中的参数时，两个值是否都被评估：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implementing `fold` will be similar to the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `fold` 将类似于以下代码：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did you notice that these functions are very easy to implement? Let''s have
    a look at the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这些函数实现起来非常简单吗？让我们看看下面的代码：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What about a little contest between Kotlin's list and our functional list?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Kotlin 的列表和我们的函数式列表之间来一场小比赛如何？
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will look something like the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图：
- en: '![](img/dd6c4ae9-a493-4e7b-89e5-4ecda3ad2cba.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd6c4ae9-a493-4e7b-89e5-4ecda3ad2cba.png)'
- en: Ouch! Our implementation is 10 times slower. No worries, Kotlin's implementation
    is a heavily optimized imperative solution and ours is just to learn and have
    fun (pun intended).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们的实现速度慢了10倍。别担心，Kotlin 的实现是一个高度优化的命令式解决方案，而我们的只是为了学习和娱乐（当然，是字面意义上的娱乐）。
- en: What about `map`? To implement `map` in a functional way we need to implement
    other functions first. Let's start with `reverse`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `map` 呢？要在函数式编程中实现 `map`，我们需要先实现其他函数。让我们从 `reverse` 开始。
- en: '`reverse` is a function that returns a list in reverse order:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse` 是一个返回反转顺序列表的函数：'
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can reuse `fold` and build a new `Cons` value in each iteration, using the
    `acc` value as `tail`. This is one of the big advantages of functional programming—reusing
    existing functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每次迭代中重用 `fold` 并构建一个新的 `Cons` 值，使用 `acc` 值作为 `tail`。这是函数式编程的一个大优点——重用现有函数。
- en: 'Now, we can implement `foldRight`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现 `foldRight`：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, we are reusing existing functions. It is time to implement our `map`
    function. At this point, it is not surprising that we''ll reuse our existing functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们正在重用现有函数。现在是时候实现我们的 `map` 函数了。在这个阶段，我们重用现有函数并不令人惊讶：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`foldRight` is all that we need. As you can see, we can implement a complete
    list using functions and other basic concepts as building blocks. And that is
    all about functional programming.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldRight` 是我们所需要的全部。正如你所见，我们可以使用函数和其他基本概念作为构建块来实现一个完整的列表。这就是函数式编程的全部内容。'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered the basics of functional programming, including
    high-order functions, pure functions, recursion functions, and lazy evaluation.
    We also covered functional collections and we implemented a functional collection,
    using a functional programming style.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数式编程的基础，包括高阶函数、纯函数、递归函数和惰性求值。我们还介绍了函数式集合，并使用函数式编程风格实现了一个函数式集合。
- en: In the next chapter, we'll cover a foundational stone of functional programming—immutability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍函数式编程的基础——不可变性。
