- en: Getting Started with Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has been making big waves in the software industry for
    the last five years, and everyone wants to jump on the bandwagon. Functional programming
    is a lot older, starting in the 1950s with **Lisp** being considered the first
    programming language (or at least, the first one to introduce functional features)
    which still exists as **Common Lisp,** and other dialects such as **Scheme** and
    **Clojure**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a functional list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** is a paradigm (a style of structuring your programs).
    In essence, the focus is on transforming data with expressions (ideally such expressions
    should not have side effects). Its name, functional, is based on the concept of
    a mathematical function (not in sub-routines, methods, or procedures). A mathematical
    function defines a relation between a set of inputs and outputs. Each input has
    just one output. For example, given a function, *f(x) = X²; f(5)* is always *25*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to guarantee, in a programming language, that calling a function with
    a parameter always returns the same value, is to avoid accessing to mutable state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `f` function doesn''t access any external state; therefore, calling *f(5)*
    will always return *25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `g` function, on the other hand, depends on mutable state and returns different
    values for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in a real-life program (a **Content Management System** (**CMS**), shopping
    cart, or chat), state changes. So, in a functional programming style, state management
    must be explicit and careful. The techniques to manage state change in functional
    programming will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A functional programming style will provide us with the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code is easy to read and test**: Functions that don''t depend on external
    mutable state are more accessible to reason about and to prove'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State and side effects are carefully planned**: Limiting state management
    to individual and specific places in our code makes it easy to maintain and refactor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency gets safer and more natural**: No mutable state means that concurrency
    code needs less or no locks around your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is composed of a few well-defined concepts. A short introduction
    of these concepts will follow and, later on, each concept will be covered in depth,
    in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: First-class and higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most foundational concept of functional programming is **first-class functions**.
    A programming language with support for first-class functions will treat functions
    as any other type; such languages will allow you to use functions as variables,
    parameters, returns, generalization types, and so on. Speaking of parameters and
    returns, a function that uses or returns other functions is a **higher-order function**.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has support for both concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a simple function (in Kotlin''s documentation this kind of function
    is named lambda):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `capitalize` lambda function is of type `(String) -> String`; in other words,
    `capitalize` will take `String` and return another `String`—in this case, a capitalized
    `String`.
  prefs: []
  type: TYPE_NORMAL
- en: As a lambda function, `capitalize` can be executed using parentheses with parameters
    (or no parameters at all, depending on the situation).
  prefs: []
  type: TYPE_NORMAL
- en: But what does the `(String) -> String` type mean?
  prefs: []
  type: TYPE_NORMAL
- en: '`(String) -> String` is a shortcut (some could call it syntactic sugar) for
    `Function1<String, String>`, `Function1<P1, R>` is an interface defined in the
    Kotlin standard library. `Function1<P1, R>` has a single method, `invoke(P1):
    R`, that is marked as an operator (we''ll cover operators later).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin''s compiler can translate the shortcut syntax into a fully fledged function
    object at compile time (indeed, the compiler will apply many more optimizations)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `capitalize` value's body is located inside the `invoke` method.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, lambda functions can be used as parameters in other functions as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `transform(String, (String) -> String)` function takes one `String` and
    applies a lambda function to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all intents and purposes, we can generalize `transform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `transform` is very simple. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can pass `capitalize` as a parameter directly, great stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more ways to call the `transform` function. Let''s try some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`reverse` is a function; we can pass a reference to it using a double colon
    (`::`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`doNothing` is an object method, and in this case, we use `::` after the `MyUtils`
    object name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass references to instances or companion object methods. But probably
    the most common case is to pass a lambda directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a shorter version of this using the `it` implicit parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`it` is an implicit parameter (you don''t declare it explicitly) that can be
    used in lambdas with just one parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it is tempting to use `it` for all cases, once you start using it with
    successive or nested lambdas, they can be difficult to read. Use it sparingly
    and when it is clear which type it is (no pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function receives a lambda as the last parameter, the lambda can be passed
    outside the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This feature opens up the possibility of creating **Domain Specific Language** (**DSL**)
    with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Do you know about the `unless` flow control statement from **Ruby**? `unless`
    is a control statement that executes a block of code if a condition is `false`;
    it's kind of a negated `if` condition but without an `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a version for Kotlin by executing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`unless` receives a condition as a Boolean and blocks to execute as a lambda
    `() -> Unit` (no parameters and no return). When `unless` is executed, it looks
    exactly like any other Kotlin''s control flow structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type alias can be mixed with functions and used to replace simple interfaces.
    Let''s take the following example, our `Machine<T>` interface from [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml),
    *Kotlin – Data Types, Objects, and Classes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be replaced with a type alias and used with all the function''s syntactical
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pure functions** don''t have side effects, nor memory, nor I/O. Pure functions
    have many properties, including referential transparency, caching (memoization),
    and others (we''ll cover these features in the next chapters).'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to write pure functions in Kotlin, but the compiler doesn't enforce
    it as in other languages. It is up to you to create pure functions to enjoy its
    benefits. Because Kotlin doesn't enforce pure functions, many programmers said
    that Kotlin isn't a real functional programming tool, and maybe they are right.
    Yes, Kotlin doesn't enforce pure functional programming, and that gives you great
    flexibility including the ability to write in a purely functional style, if you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Recursive functions** are functions that invoke themselves, with some sort
    of condition to stop the execution. In Kotlin, a recursive function maintains
    a stack but can be optimized with a `tailrec` modifier.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example, an implementation of a `factorial` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at a typical imperative implementation, loops, and
    state change in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s nothing fancy nor particularly elegant. Now, let''s take a look at a
    recursive implementation, no loops, and no state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use an internal recursive function; the `go` function calling itself until
    a condition is reached. As you can see, we're starting with the last `n` value
    and reducing it in each recursive iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optimized implementation is similar but with a `tailrec` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To test which implementation is faster, we can write a poor''s man profiler
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For our purposes, the `executionTime` function is okay, but any serious production
    code should be profiled with a proper profiling tool, such as **Java Microbenchmark
    Harness** (**JMH**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/509fc2ef-db76-46ac-b62c-801fe5d72a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `tailrec` optimized version is even faster than the normal imperative version.
    But `tailrec` isn't a magic incantation that will make your code run faster. As
    a general rule, the `tailrec` optimized code will run faster than the unoptimized
    version, but will not always beat a good old imperative code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore a Fibonacci implementation, starting with an imperative one
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at a functional recursive implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check with its corresponding `tailrec` version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then again, let''s see its profiling with `executionTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbce955f-92b2-4ae5-a35e-4650eedd6043.png)'
  prefs: []
  type: TYPE_IMG
- en: The `tailrec` implementation is much faster than the recursive version, but
    not as fast as a normal imperative implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functional languages provide a `lazy` (non-strict) evaluation mode. Kotlin,
    by default, uses an *eager (strict) evaluation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin doesn''t provide native support for lazy evaluation as part of the language
    itself, but as part of Kotlin''s Standard Library and a language feature named
    **delegate properties** (we''ll cover this in detail in future chapters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c3a2d43-47e1-40d2-9f6b-79bbaf6f870e.png)'
  prefs: []
  type: TYPE_IMG
- en: After the `by` reserved word, the `lazy()` higher-function receives an `(()
    -> T)` initializer lambda function that will be executed the first time that `i`
    is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'But also a normal lambda function can be used for some lazy use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to execute this expression, it will throw an `ArithmeticException` exception,
    as we are dividing by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's no problem executing this. The offending code isn't being executed,
    effectively making it a `lazy` evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Functional collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional collections** are collections that offer a way to interact with
    its elements through high-order functions. Functional collections have common
    operations with names such as `filter`, `map`, and `fold`; these names are defined
    by convention (similar to a design pattern) and are being implemented in several
    libraries and languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't get confused with purely functional data structures—a data structure implemented
    in a pure functional language. A purely functional data structure is immutable
    and uses the `lazy` evaluation and other functional techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Functional collections can but needn't necessarily be purely functional data
    structures. We have already covered how imperative implementations of algorithms
    can be faster than functional ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin comes with an excellent functional collection library. Let''s have a
    look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our value `numbers` as a `List<Int>` type. Now, let''s print its members as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good, but it doesn't look very functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Worry no more; Kotlin collections include many functions that receive lambdas
    to operate on their members. We can replace this loop with a lambda as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s transform our collection in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This code doesn''t compile; `numberTwice` doesn''t have an `add(T)` method.
    `List<T>` is an immutable list; it can be modified once it is initialized. To
    add elements to a list, it must have a different type—`MutableList<T>` in our
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`MutableList<T>` extends `List<T>`; it adds the methods to modify the collection
    itself, such as `add(T)`, `remove(T)`, `clear`, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: All major Kotlin collection types (`List<T>`, `Set<T>`, and `Map<K, V>`) have
    mutable subtypes (`MutableList<T>`, `MutableSet<T>`, and `MutableMap<K, V>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can replace this transformation with a single line expression as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `map` operation lets you transform (technically mapping a value to another).
    This code has many advantages and is a lot cleaner, and now the `numbersTwice` value
    is a `List<Int>` list, instead of a `MutableList<T>` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have another couple of examples. We can sum all elements of numbers
    using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be reduced to just one line, with an immutable `sum` value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, but not interesting, so let''s raise the stakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fold` method iterates over a collection, keeping an accumulator value.
    `fold` takes a `T` value as the initial value; in the first iteration, this initial
    value will be the accumulator and subsequent iterations will use the lambda''s
    return as the next accumulator value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a7a4251-1ffb-4166-b1ba-6db828a58893.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to `fold`, `reduce` iterates over a collection, with an accumulator
    but without an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df2b6f1c-7909-4232-a5c6-546735c1e5c4.png)'
  prefs: []
  type: TYPE_IMG
- en: '`fold` and `reduce` have counterparts in `foldRight` and `reduceRight` that
    start iterating from the last item to the first.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a functional list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With everything that we''ve learned in the first two chapters, we can implement
    a pure functional list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `FunList` class is a sealed class; just two possible subclasses exist—`Nil`,
    an empty list (in other books you can see this defined as `Null` or `Empty`) and
    `Cons` (a construct, name inherited from Lisp, that holds two values).
  prefs: []
  type: TYPE_NORMAL
- en: The `T` type is marked `out`; this is for variance, which we'll cover variance
    in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '`Nil` is an object (we don''t need different instances of `Nil`) extending
    `FunList<Nothing>` (remember that `Nothing` is the bottom of Kotlin''s type hierarchy).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cons` value contains two values—`head`, a single `T`, and `tail`, a `FunList<T>`;
    therefore, it can be a `Nil` value or another `Cons`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a list instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s functional, but not very readable. We can create a better initialization
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few new things here. The argument numbers are marked as `vararg`,
    which means that we can invoke this function with as many parameters as we want.
    For all intents and purposes, `numbers` is an `IntArray` value (a specialized
    type of array). If `numbers` is empty, we can return `Nil`. If not, we can extract
    the first element as our `head` value and recursively invoke `intLisfOf` for the
    `tail` value. To extract the `tail` value, we use the `drop` method and convert
    its result to an `IntArray` value. But we can't directly pass any array as `vararg`;
    therefore, we must use the spread (`*`) operator to pass each member of an array
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create our `FunList<Int>` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement `forEach ` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `forEach` implementation is similar to our examples of Factorial and Fibonacci
    functions in the recursion section, including `tailrec`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FunList` is, technically, an **Algebraic Data Type** (**ADT**). `FunList`
    can be either a `Nil` or `Cons` and nothing else. Kotlin''s compiler can use this
    information to check that both values are evaluated when a `FunList` type is used
    as the argument in a `when` control structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing `fold` will be similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice that these functions are very easy to implement? Let''s have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: What about a little contest between Kotlin's list and our functional list?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd6c4ae9-a493-4e7b-89e5-4ecda3ad2cba.png)'
  prefs: []
  type: TYPE_IMG
- en: Ouch! Our implementation is 10 times slower. No worries, Kotlin's implementation
    is a heavily optimized imperative solution and ours is just to learn and have
    fun (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: What about `map`? To implement `map` in a functional way we need to implement
    other functions first. Let's start with `reverse`.
  prefs: []
  type: TYPE_NORMAL
- en: '`reverse` is a function that returns a list in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can reuse `fold` and build a new `Cons` value in each iteration, using the
    `acc` value as `tail`. This is one of the big advantages of functional programming—reusing
    existing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement `foldRight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we are reusing existing functions. It is time to implement our `map`
    function. At this point, it is not surprising that we''ll reuse our existing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`foldRight` is all that we need. As you can see, we can implement a complete
    list using functions and other basic concepts as building blocks. And that is
    all about functional programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of functional programming, including
    high-order functions, pure functions, recursion functions, and lazy evaluation.
    We also covered functional collections and we implemented a functional collection,
    using a functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover a foundational stone of functional programming—immutability.
  prefs: []
  type: TYPE_NORMAL
