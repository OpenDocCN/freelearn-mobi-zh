- en: Chapter 6. Architecting Applications for High Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：为高性能构建应用程序架构
- en: In previous chapters, we talked about different ways of improving code to achieve
    high-performance. Mostly we concentrated on a small part of the code and how to
    improve a function, an algorithm, and a data structure. In this chapter, we will
    concentrate on higher levels. We will talk about how to design an application
    architecture that can be scalable, maintainable, and high-performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了不同的方法来改进代码以实现高性能。我们主要集中在一个小的代码部分以及如何改进一个函数、一个算法和一个数据结构。在本章中，我们将集中讨论更高层次的内容。我们将讨论如何设计一个可扩展、可维护且高性能的应用程序架构。
- en: 'In this chapter we are going to cover these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: High-performance and concurrency overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能和并发概述
- en: Avoiding state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免状态
- en: Divide and conquer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分而治之
- en: Designing asynchronous architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计异步架构
- en: Achieving high performance
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高性能
- en: One of the ways to improve application performance is to run code concurrently.
    This not only allows us to run code faster and get the results more quickly, but
    it also frees the main-thread from doing a lot of work and being blocked. You
    should know that the main thread is responsible for events and user input handling.
    All the UI work is performed on the main thread and to achieve a really smooth
    user interaction we should do as little work as possible on the main thread.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 提高应用程序性能的一种方法是通过并行运行代码。这不仅使我们能够更快地运行代码并更快地得到结果，而且还使主线程从做大量工作并被阻塞中解放出来。你应该知道主线程负责事件和用户输入处理。所有UI工作都在主线程上执行，为了实现真正流畅的用户交互，我们应该在主线程上尽可能少地做工作。
- en: Running code concurrently can be a tricky task and sometimes it can lead to
    increased running time for an operation. Making solid concurrent application architecture
    is also not a trivial task and you should plan it carefully.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行代码可能是一个棘手的问题，有时它可能导致操作运行时间的增加。构建稳固的并发应用程序架构也不是一个简单任务，你应该仔细规划。
- en: To take full advantage of concurrency, it is very useful to understand the hardware
    we have at our disposal that allows us to do that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用并发，了解我们拥有的硬件，这对于我们来说非常有用，这一点非常重要。
- en: Device architecture
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备架构
- en: In order to be able to achieve really high-performance, first we need to learn
    and understand what kinds of tools we have at our disposal. If you are making
    an iOS application, your application will run on the iPhone and iPad; for OS X
    it would run on the Mac. Although it might seem that the iPhone and the Mac differ
    a lot, they share the same basic concept and we can think about a Mac as a more
    powerful iPad device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够实现真正的高性能，首先我们需要学习和理解我们有哪些工具可以利用。如果你正在开发iOS应用程序，你的应用程序将在iPhone和iPad上运行；对于OS
    X，它将在Mac上运行。尽管iPhone和Mac可能看起来有很大的不同，但它们共享相同的基本概念，我们可以将Mac视为一个更强大的iPad设备。
- en: Nowadays, all computers and even phones use multi-core processors that allow
    us to execute many instructions at the same time in parallel. Starting with the
    iPhone 4s, all iPhones have a dual-core processor and the iPad Air 2 even has
    a 3-core processor. We should fully use that power and take advantage of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有计算机甚至手机都使用多核处理器，这使我们能够同时并行执行许多指令。从iPhone 4s开始，所有iPhone都配备了双核处理器，而iPad Air
    2甚至配备了3核处理器。我们应该充分利用这种力量并利用它。
- en: Let's have a look at how we could design code that could be run in parallel
    on multi-core processors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何设计可以在多核处理器上并行运行的代码。
- en: Concurrency overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发概述
- en: By default, when you make an application it runs the code in a single-thread
    environment, a main thread. For example, an iOS application would call the `application:`
    `didFinishLaunchingWithOptions` method on the main thread.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你创建一个应用程序时，它将在单线程环境中运行代码，即主线程。例如，iOS应用程序会在主线程上调用`application:` `didFinishLaunchingWithOptions`方法。
- en: 'A simpler example is an OS X Command Line Tool application. It has only one
    file: `main.swift`. When you start it, the system creates a single main thread
    and runs all the code in the `main.swift` file on that thread.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的例子是一个OS X命令行工具应用程序。它只有一个文件：`main.swift`。当你启动它时，系统会创建一个主线程，并在该线程上运行`main.swift`文件中的所有代码。
- en: 'For testing code, playgrounds are the best. By default, playgrounds stop after
    executing the last line of code and don''t wait for the concurrent code to finish
    executing. We can change this behavior by telling the playgrounds to keep running
    indefinitely. To do that, include these two lines in the playground file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试代码，playgrounds是最好的。默认情况下，playgrounds在执行完最后一行代码后会停止，不会等待并发代码执行完成。我们可以通过告诉playgrounds无限期地运行来改变这种行为。为此，请在playground文件中包含这两行代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can start playing with concurrency. The first task we need to do to
    run code concurrently is to schedule a task to be run on a different thread. We
    can schedule a task for concurrent execution by using:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始玩并发了。我们需要做的第一件事是为了并行运行代码，需要在一个不同的线程上安排一个任务。我们可以通过以下方式安排一个任务以进行并发执行：
- en: Threads
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: '**GCD** (**Grand Central Dispatch**)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCD**（**Grand Central Dispatch**）'
- en: Operation Queues
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作队列
- en: Threads
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: As the first option, we could use threads. A thread is the most low-level API.
    All the concurrency is built on top of threads and runs multiple threads. We can
    use `NSThread` from the Foundation framework. The simplest way to do this is to
    create a new class with a method that will be the starting point for our new thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个选项，我们可以使用线程。线程是最底层的API。所有并发都是建立在线程之上，并运行多个线程。我们可以使用来自Foundation框架的`NSThread`。这样做最简单的方式是创建一个新的类，其中包含一个将成为我们新线程起点的方法。
- en: 'Let''s see how we could schedule the new thread:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何安排新的线程：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can create a new thread in two ways, by using the `detachNewThreadSelector`
    function or create an instance of `NSThread` and use the `start` function. We
    have to mark our `run` function with the `@objc` attribute because we use it as
    a selector when creating a thread, and `NSThread` is an Objective-C class that
    uses dynamic dispatch for method calling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式创建一个新线程：使用`detachNewThreadSelector`函数或创建`NSThread`的实例并使用`start`函数。我们必须将`run`函数标记为`@objc`属性，因为我们将其用作创建线程时的选择器，而`NSThread`是一个使用动态分派进行方法调用的Objective-C类。
- en: The `NSObject` has a simple API for performing a method on a different thread.
    Because our handler inherits for `NSObject` we can use it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSObject`有一个简单的API可以在不同的线程上执行一个方法。因为我们的处理程序继承自`NSObject`，所以我们可以使用它。'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another way is to create a subclass of `NSThread` and override the starting
    point of a thread, the `main` function. In that way we don't need a handler class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建`NSThread`的子类并覆盖线程的起点，即`main`函数。这样我们就不需要处理程序类了。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thread complexity
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程复杂度
- en: Even though the code is pretty simple here, working with threads is quite a
    complex operation. We need to take care of managing the state of the thread, correctly
    terminating it, and releasing the resources used by the thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这里的代码相当简单，但处理线程却是一个相当复杂的操作。我们需要注意管理线程的状态，正确地终止它，并释放线程使用的资源。
- en: Creating a new thread is a very expensive and time-consuming operation, and
    we should avoid it when possible. The way to solve this is to reuse created threads.
    Creating and managing a thread-pool adds extraordinary complexity to the application
    that we don't need.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新线程是一个非常昂贵且耗时的操作，我们应该尽可能避免它。解决这个问题的方法是重用创建的线程。创建和管理线程池会给应用程序增加不必要的复杂性。
- en: The process gets even harder when you need to communicate between threads and
    synchronize data between them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在线程之间进行通信并同步数据时，这个过程变得更加困难。
- en: Solution for threads
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程解决方案
- en: 'Instead of solving our initial task that we wanted to run concurrently, now
    we are spending time managing the complexity of that concurrent execution system.
    Fortunately we don''t need to do that as there is a solution: *Don''t use threads*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不是在解决我们想要并行运行的初始任务，而是在花费时间管理这个并发执行系统的复杂性。幸运的是，我们不需要这样做，因为有一个解决方案：*不要使用线程*。
- en: The *iOS and Mac Concurrency Programming Guide* recommends not using threads
    but choosing a high-level API, a GCD, or Operation Queues.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS和Mac并发编程指南*建议不要使用线程，而是选择高级API，如GCD或操作队列。'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Thread APIs are shown in this chapter only for general knowledge. You should
    almost never use threads; use GCD instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅展示线程API以供一般了解。你几乎永远不应该使用线程；请使用GCD。
- en: GCD
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GCD
- en: '**GCD** (**Grand Central Dispatch**) is a high-level API that is built on top
    of threads and performs all aspects of thread management for you. Instead of working
    with threads, GCD provides a queue and task abstraction. You schedule a task to
    a queue for execution and the queue takes care of everything else. Let''s see
    how we could rewrite our code with GCD:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**GCD**（**Grand Central Dispatch**）是一个建立在线程之上的高级API，为你处理线程管理的所有方面。与线程工作不同，GCD提供了一个队列和任务抽象。你将任务调度到队列中执行，队列负责其他所有事情。让我们看看我们如何使用GCD重写我们的代码：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the code looks simpler from the start. Before we dive into
    the details, let''s have a look at GCD and its concepts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码从一开始就看起来更简单。在我们深入细节之前，让我们看看GCD及其概念：
- en: Queues
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Tasks
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务
- en: Adding tasks to the queue
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向队列添加任务
- en: Queues
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: A **queue** is a structure that takes care of managing and executing its tasks.
    The queue is a first-in first-out data structure. That means that tasks in the
    queue are started in the order they were added to the queue.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列** 是一个负责管理和执行其任务的结构。队列是一个先进先出数据结构。这意味着队列中的任务以它们被添加到队列中的顺序启动。'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: First in first out means that tasks are started in the same order but it doesn't
    mean that they can't be executed simultaneously. Concurrent queues can start many
    tasks at the same time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 先入先出意味着任务以相同的顺序启动，但这并不意味着它们不能同时执行。并发队列可以同时启动许多任务。
- en: The queue itself doesn't have much functionality. The main operation you would
    need to do is to create a queue or get one of the global queues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 队列本身没有太多功能。你需要执行的主要操作是创建一个队列或获取全局队列中的一个。
- en: 'There are three queue types:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种队列类型：
- en: Main queue
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主队列
- en: 'Concurrent: global and own queues'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发：全局和自定义队列
- en: Serial
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行
- en: Main queues
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主队列
- en: A **main queue** represents a queue associated with a main thread. It runs tasks
    serially, one after the other. You would usually use this queue to pass the result
    of an execution from other background queues to the main queue to update the UI
    state. You can get a main queue by calling the `dispatch_get_main_queue` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**主队列** 代表与主线程关联的队列。它按顺序串行运行任务，一个接一个。你通常会使用这个队列将其他后台队列的执行结果传递到主队列以更新UI状态。你可以通过调用
    `dispatch_get_main_queue` 函数来获取主队列。'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Concurrent queues
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并发队列
- en: A **concurrent queue** runs its tasks concurrently. The easiest way to get a
    concurrent queue is to use a global concurrent queue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发队列** 并行运行其任务。获取并发队列的最简单方法是使用全局并发队列。'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get a global queue, we need to specify what kind of priority we need. There
    are five types of queue with descending task priority. `USER_INTERACTIVE` is the
    most prioritized queue and `BACKGROUND` is the least.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取全局队列，我们需要指定所需的优先级类型。有五种类型的队列，任务优先级递减。`USER_INTERACTIVE` 是优先级最高的队列，而 `BACKGROUND`
    是最低的。
- en: '`QOS_CLASS_USER_INTERACTIVE`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QOS_CLASS_USER_INTERACTIVE`'
- en: '`QOS_CLASS_USER_INITIATED`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QOS_CLASS_USER_INITIATED`'
- en: '`QOS_CLASS_DEFAULT`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QOS_CLASS_DEFAULT`'
- en: '`QOS_CLASS_UTILITY`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QOS_CLASS_UTILITY`'
- en: '`QOS_CLASS_BACKGROUND`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QOS_CLASS_BACKGROUND`'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Also available are old `DISPATCH_QUEUE_PRIORITY` constants that can be used
    when specifying a queue priority type instead of `QOS_CLASS` but `QOS_CLASS` is
    preferred.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样可用的还有旧的 `DISPATCH_QUEUE_PRIORITY` 常量，当指定队列优先级类型而不是 `QOS_CLASS` 时可以使用，但 `QOS_CLASS`
    更受欢迎。
- en: The second flag parameter is reserved and never used, so we just use 0\. The
    global queues are available for use by the whole system and everyone can add tasks
    to them. When all you need is to run some tasks, this is a perfect fit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标志参数是保留的，从不使用，所以我们只使用0。全局队列可供整个系统使用，任何人都可以向它们添加任务。当你只需要运行一些任务时，这是一个完美的选择。
- en: Own queues
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义队列
- en: When you need to do more complex handling and have full control of what tasks
    are added to the queue, you can create your own queue. Own queues fit well when
    you need to be notified of when all tasks are done, or to do more complex synchronization
    between tasks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要进行更复杂的处理并完全控制添加到队列中的任务时，你可以创建自己的队列。自定义队列非常适合当你需要通知所有任务完成时，或者需要在任务之间进行更复杂的同步时。
- en: You can create both concurrent and serial queues. Serial queues execute one
    task at a time, one after another, not concurrently.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建并发和串行队列。串行队列一次执行一个任务，一个接一个，而不是并发执行。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tasks
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务
- en: A **task** is a block of code that needs to be run. A task is defined as a `dispatch_block_t`
    type and it is defined as `() -> Void`. We could use a closure or a function as
    a task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务** 是需要运行的一段代码。任务被定义为 `dispatch_block_t` 类型，并定义为 `() -> Void`。我们可以使用闭包或函数作为任务。'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding tasks to the queue
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将任务添加到队列中
- en: 'We have a queue and we have a task that we want to run. To run a task on a
    particular queue, we need to dispatch it to that queue. We could do this in two
    ways:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个队列，我们有一个想要运行的任务。为了在特定队列上运行任务，我们需要将其调度到该队列。我们可以用两种方式来做这件事：
- en: '**Synchronous**: `dispatch_sync`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**: `dispatch_sync`'
- en: '**Asynchronous**: `dispatch_async`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**: `dispatch_async`'
- en: Both functions are very simple and have the same type. The only differences
    are in their names and the way they work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都非常简单，并且具有相同的类型。它们之间的唯一区别在于它们的名称和工作方式。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Synchronous dispatch
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 同步调度
- en: Synchronous dispatch submits a task for execution and waits until the task is
    done.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同步调度提交一个任务以执行，并等待任务完成。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you use a concurrent queue and dispatch a task to it synchronously, the
    queue can run many tasks at the same time, but the `dispatch_sync` method waits
    until the task you submitted is finished.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用并发队列并以同步方式向其调度任务时，队列可以同时运行多个任务，但 `dispatch_sync` 方法会等待您提交的任务完成。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never call the `dispatch_sync` function from a task that is executing in the
    same queue. This would cause a deadlock for the serial queue and should be avoided
    for concurrent queues as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从同一队列中执行的任务中永远不要调用 `dispatch_sync` 函数。这会导致串行队列发生死锁，并且对于并发队列也应避免。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `print("1 Done")` instruction and the rest of the code
    will wait until `Task 1` is finished.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`print("1 完成")` 指令和其余代码将等待 `任务 1` 完成。
- en: Asynchronous dispatch
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步调度
- en: Asynchronous dispatch, on the other hand, submits a task for execution and returns
    it immediately.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，异步调度提交一个任务以执行，并立即返回。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we use the previous example and change it to use `dispatch_async`, `1 Done`
    willnot wait for tasks to be finished. We can also simulate extra work by freezing
    the current thread with a sleep function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前的示例并将其更改为使用 `dispatch_async`，则 `1 完成` 将不会等待任务完成。我们还可以通过使用 sleep 函数冻结当前线程来模拟额外的工作。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As a result, `Task 2` is submitted for execution immediately after `Task 1`
    and it finishes execution before `Task 1`. Here is the console output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`任务 2` 在 `任务 1` 提交执行后立即提交执行，并在 `任务 1` 完成执行之前完成。以下是控制台输出：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: GCD also has some powerful tools for synchronizing submitted tasks, but we are
    not going to cover them here. If you want to learn more, read the *Concurrency
    Programming Guide* article in the Apple library documentation at [https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 还有一些用于同步提交任务的强大工具，但在这里我们不会介绍它们。如果您想了解更多，请阅读 Apple 库文档中的 *并发编程指南* 文章，网址为
    [https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide)。
- en: Operation queues
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作队列
- en: '`NSOperationQueue` is built on top of GCD and provides more high-level abstraction
    and an API that allows us to control an application controlflow.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperationQueue` 是建立在 GCD 之上的，它提供了更高层次的抽象和 API，使我们能够控制应用程序的控制流。'
- en: The concept is very similar to GCD; it has a queue and tasks that you add to
    the particular queue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与 GCD 非常相似；它有一个队列，您可以将任务添加到特定的队列中。
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The NSOperationQueue provides a more high-level API but it is also a bit slower
    than GCD. NSOperationQueue fits very well with controlling the application flow,
    when tasks need to be chained, depend on each other, or need to be canceled. You
    can achieve the same functionality by using GCD but it would require implementing
    some extra logic that is already implemented by the NSOperationQueue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: NSOperationQueue 提供了一个更高层次的 API，但它也比 GCD 略慢。当需要链式任务、相互依赖的任务或需要取消的任务来控制应用程序流程时，NSOperationQueue
    非常适合。您可以通过使用 GCD 实现相同的功能，但这需要实现一些已经由 NSOperationQueue 实现的额外逻辑。
- en: GCD works very well when you need to perform a task and get the result and do
    not need to control the application flow.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要执行一个任务并获取结果，而不需要控制应用程序流程时，GCD 工作得非常好。
- en: Further in this chapter we will use GCD for concurrency. Now, let's move on
    and learn some tricks that will help us to make our code architecture more solid
    for concurrent programming.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续内容中，我们将使用 GCD 进行并发编程。现在，让我们继续学习一些技巧，这些技巧将帮助我们使我们的代码架构在并发编程中更加稳固。
- en: Designing asynchronous code
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计异步代码
- en: The first characteristic of asynchronous code is that it returns immediately
    and notifies the caller when it has completed the operation. The best solution
    is to return the result of the computation as well. This way we get more function
    style *Input -> Output* functions style.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码的第一个特点是它立即返回，并在操作完成时通知调用者。最好的解决方案是返回计算结果。这样我们就能得到更多函数风格的*输入 -> 输出*函数风格。
- en: Let's have a look at this simple example. This code has many issues and will
    refactor them all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的例子。这段代码有很多问题，我们将全部重构它们。
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have made a GCD structure that provides a nice API for working with GCD
    code. In the preceding example we have used a GCD `backgroundQueue` function;
    here is its implementation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个GCD结构，它提供了一个很好的API来处理GCD代码。在先前的例子中，我们使用了GCD的`backgroundQueue`函数；下面是它的实现：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On the whole, the calculation code in that example is really bad and we could
    improve it by using a `reduce` method that would actually solve many problems
    and make the code safer and more readable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，那个例子中的计算代码真的很糟糕，我们可以通过使用`reduce`方法来改进它，这实际上会解决许多问题，并使代码更安全、更易读。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But the main point of that example was to show how dangerous it could be and
    what kinds of issues you could face with this architecture.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但那个例子中的主要目的是展示它可能有多危险，以及你可能会遇到哪些问题。
- en: 'Let''s use this code to see the problem:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这段代码来看看问题：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The problem is that `calculateAverage` returns immediately as it is supposed
    to and the average is not calculated at this moment. To solve that problem all
    the asynchronous code should have some way to notify a caller when the task is
    completed. The easiest way to do this is to add a callback completion function
    as a parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`calculateAverage`立即返回，正如它应该做的那样，此时并没有计算平均值。为了解决这个问题，所有异步代码都应该有一种方式来通知调用者在任务完成时。最简单的方法是添加一个回调完成函数作为参数。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, when using this code, we can use a nice and clear trailing closure syntax
    for the result callback parameter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用这段代码时，我们可以为结果回调参数使用一个简洁明了的尾随闭包语法。
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is one very important issue with this code. It is calling the `result`
    callback function on the background thread. It means that the closure we pass
    to `data.calculateAverage` will be called on the background but for us it's not
    documented and this behavior is not clear. We suppose that we will get that closure
    called on the main thread, because we are calling the `calculateAverage` function
    from the main thread. Let's do that. What we need to do is to switch to the main
    queue and call `result` on the main thread.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个非常重要的问题。它是调用`result`回调函数在后台线程上。这意味着我们传递给`data.calculateAverage`的闭包将在后台调用，但对于我们来说，这并没有文档说明，这种行为也不明确。我们假设我们将得到在主线程上调用该闭包，因为我们是从主线程调用`calculateAverage`函数的。让我们这样做。我们需要做的是切换到主队列，并在主线程上调用`result`。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The best practice is to always call a callback method on the main queue by default
    if another behavior is not required. If you need to call a callback on the special
    queue, then it should be passed to a function as a parameter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是默认在主队列上调用回调方法，除非需要其他行为。如果你需要在特殊队列上调用回调，那么它应该作为参数传递给函数。
- en: This code works but there is still one improvement that could be done. When
    the result callback gets called, the first thing we do is get the `average` instance.
    It would be way better if the result callback returned the result of its computation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作，但仍然有一个可以改进的地方。当结果回调被调用时，我们首先获取`average`实例。如果结果回调返回其计算结果会更好。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In general terms, it is a good functional programming style for functions to
    take input and return the result, `X -> Y`. These functions are easier to use
    and test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，对于函数来说，以输入和返回结果的方式`X -> Y`进行函数式编程是一种很好的风格。这些函数更容易使用和测试。
- en: 'Let''s refactor this code to pass an average result number to the callback
    function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构这段代码，将平均值结果传递给回调函数：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The change is not big but the benefits are quite extensive. When we use the
    `calculateAverage` function we get the result directly in the closure as a parameter.
    Now we don't need to access the instance variable of `SalesData`. `SalesData`
    becomes more of a closed-box type with hidden implementation details and because
    of that we will be able to do more refactoring in the future.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 变化不大，但好处相当广泛。当我们使用`calculateAverage`函数时，我们直接在闭包中作为参数得到结果。现在我们不需要访问`SalesData`的实例变量。`SalesData`更像是一个封闭的盒子类型，具有隐藏的实现细节，因此我们将在未来能够进行更多的重构。
- en: Avoiding state
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免状态
- en: 'The first rule is to avoid a state. When you are doing two things at the same
    time, those two processes should be as independent and isolated as possible. They
    shouldn''t know anything about each other or share any mutable resources. If they
    do, then we would need to take care of synchronizing access to that shared resource,
    which would bring a complexity to our system that we don''t want. Right now in
    our code we have two states: a `revenue` numbers array and the `average` result.
    Both of the processes have access to that state.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是避免状态。当你同时做两件事时，这两个过程应该尽可能独立和隔离。它们之间不应该有任何了解，也不应该共享任何可变资源。如果它们确实这样做了，那么我们就需要处理对这些共享资源的访问同步，这会给我们的系统带来我们不想要的复杂性。目前在我们的代码中，我们有两个状态：一个`revenue`数字数组和`average`结果。这两个过程都可以访问这个状态。
- en: 'The first problem in that the code is referencing itself. When you try to access
    an instance variable or a method that is out of the closure scope, you see an
    error message: **Reference to property ''revenue'' in closure requires explicit
    ''self.'' to make capture semantics explicit**.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码的第一个问题是它引用了自己。当你尝试访问闭包作用域之外的实例变量或方法时，你会看到一个错误信息：**在闭包中引用属性'revenue'需要显式的'self.'来使捕获语义明确**。
- en: Xcode would also propose a fix to this issue, adding explicit self-capturing.
    This would solve the Xcode error but it wouldn't solve the root problem. When
    you see this error, stop and rethink your code design; in some cases it would
    be better to change the code, like in our case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode也会提出对这个问题的修复，添加显式的自我捕获。这将解决Xcode的错误，但不会解决根本问题。当你看到这个错误时，停下来重新思考你的代码设计；在某些情况下，改变代码会更好，就像在我们的例子中一样。
- en: '![Avoiding state](img/00025.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![避免状态](img/00025.jpeg)'
- en: 'The second problem is having a mutable state and mutating an instance variable.
    Let''s use our last example once more and see why it''s a bad idea to have a state
    and access instance variables in the concurrent code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是拥有可变状态并修改实例变量。让我们再次使用我们的上一个例子，看看为什么在并发代码中拥有状态和访问实例变量是一个坏主意：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you run this code, it will crash with a **fatal error: Array index out of
    range** error due to getting the number from the array by an index operation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，它将因为通过索引操作从数组中获取数字而崩溃，出现**致命错误：数组索引超出范围**：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What is happening here is that, when we call `calculateAverage`, the revenue
    array has data, but later we remove all the revenue numbers and the arrays become
    empty; however, the indexes we are iterating over point to an old array size,
    and we are trying to access the index out of the bound arrays.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的情况是，当我们调用`calculateAverage`时，收入数组有数据，但后来我们移除了所有的收入数字，数组变空了；然而，我们迭代的索引指向旧的数组大小，我们正在尝试访问超出范围的数组索引。
- en: To solve that problem we should always try removing a state. One way to do that
    is to pass the needed data to a function as arguments or, if you want to have
    some state as in our case, capture the immutable values for a closure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该始终尝试移除状态。一种方法是将所需的数据作为参数传递给函数，或者如果你想要像我们这样的某些状态，捕获闭包的不可变值。
- en: Capture list
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获列表
- en: The first step to make this code better is to remove accessing mutable array
    variables. The easiest way to solve this is to make a local constant and use it
    in the closure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使这段代码变得更好的第一步是移除访问可变数组变量。解决这个问题的最简单方法是创建一个局部常量并在闭包中使用它。
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This solution would work, because modifying the `revenue` instance variable
    doesn't have an impact on the local constant we have created. This code has one
    small issue. The constant is visible outside the closure, but it's intended to
    be used only inside the closure. It would be better if we could move it to the
    closure. We can do this by using a capture list of a closure. The only one change
    we need to do is to remove the local constant declaration and add it to the closure
    capture list. The rest of the code stays the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we used a very short capture list notation, but we could also
    provide an alternative name for the constant we are capturing and add additional
    ARC `weak` or `unowned` attributes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Immutable state
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having a state in the concurrent code is a bad design but there are two types
    of state: mutable and immutable. In any case, you will need to have some sort
    of a state in the application. If you are going to have a state, make it immutable;
    in that way you will ensure that it won''t be changed and you can safely work
    with it.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a look at our previous code example we could make the `revenue`
    numbers immutable, which would solve the problem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first small change we would do is to change the revenue number array to
    be immutable. Because the `revenue` array is immutable it's not possible to modify
    it after we created an instance, so we need to remove this code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because `revenue` is immutable now, it's safe to use it in a concurrent code,
    so we can remove the capture list and use the immutable revenue directly by using
    `self` explicitly as we did before.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`SalesData` contains immutable sales numbers that cannot be changed. This means
    that, after we have calculated the average value once, it will be the same all
    the time for that instance. The next time we call `calculateAverage`, we don''t
    need to calculate it again if we can reuse it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can even carry out one more step to make it immutable and use `struct` instead
    of a `class` for the `SalesData` type. When we do this, we will get an error saying:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**cannot assign to property: ''self'' is immutable**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**self.average = sum / self.revenue.count**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign new values to `self.average`, you are modifying a self instance,
    and because structs are immutable by default we need to mark that method as mutating:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Those are only two changes we need to do. Also, when we are using it, we need
    to make an instance of `SalesData` as a variable, because `calculateAverage` is
    mutating it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So now we can't have a constant `let` immutable `SalesData` instance. This is
    not a sign of good architecture and we should refactor it. Using a struct for
    data entities is a very good solution so we should keep refactoring code with
    this approach.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to achieve good, solid application architecture is to structure
    code well, create appropriate abstractions, and separate it into components with
    a single responsibility.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming it goes even further. The data—and the functions to
    work on that data—are also separated. The OOP concept of data and methods to work
    with it are split into two parts. This makes code even more flexible and reusable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，这更进一步。数据——以及处理这些数据的函数——也是分离的。面向对象的数据和与之相关的操作的概念被分成两部分。这使得代码更加灵活和可重用。
- en: For concurrent code execution it's particularly important to split your code
    into standalone separate pieces because they can be sent for execution concurrently
    without blocking each other.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于并发代码执行，特别重要的是将你的代码拆分成独立的单独部分，因为它们可以并发执行而不会相互阻塞。
- en: 'Before we start refactoring the code let''s analyze it first. The goal is to
    identify a component with a single responsibility. I did it and here are those
    components:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始重构代码之前，让我们先分析它。目标是识别一个具有单一职责的组件。我已经做到了，以下是我识别出的这些组件：
- en: '**In Data**: The first part is our input data. In our case it is a `SalesData`
    structure that holds immutable data in our application.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在数据中**：第一部分是我们的输入数据。在我们的例子中，它是一个`SalesData`结构，它在我们应用程序中持有不可变数据。'
- en: '**Calculation function**: The next part is our function that knows how to calculate
    the average for `SalesData`. It''s a simple first-class function that takes `SalesData`
    and returns the average. Its mathematical notation would be `f(x) = y` and the
    code notation would be `func calculateAverage(data: SalesData) -> Int`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算函数**：下一部分是我们知道如何计算`SalesData`平均值的函数。它是一个简单的第一类函数，它接受`SalesData`并返回平均值。它的数学表示法是`f(x)
    = y`，代码表示法是`func calculateAverage(data: SalesData) -> Int`。'
- en: '**Result data:** This is a result returned by the calculation function. In
    our example, it is a simple `Int` number that represents an average.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果数据**：这是计算函数返回的结果。在我们的例子中，它是一个简单的`Int`数字，表示平均值。'
- en: '**Async execution operation**: The next part is an operation that switches
    to the background thread and back to the main thread and that actually allows
    us to perform asynchronous code execution. In our example it''s a `dispatch_async`
    function call with an appropriate queue.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步执行操作**：下一部分是一个切换到后台线程再回到主线程的操作，这实际上允许我们执行异步代码。在我们的例子中，它是一个带有适当队列的`dispatch_async`函数调用。'
- en: '**Cache**: Once we have calculated an average, we store it and don''t perform
    the calculation again. This is exactly what a cache is for.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：一旦我们计算出一个平均值，我们就存储它，不再进行计算。这正是缓存的作用。'
- en: Now we have identified separate components in our application, let's build relations
    and communication between them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们应用程序中识别出独立的组件，让我们建立它们之间的联系和通信。
- en: '![Divide and conquer](img/00026.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![分割与征服](img/00026.jpeg)'
- en: To keep interaction simple, our application will ask a cache for an average
    value of `SalesData`. If a cache contains an average value, it will return it.
    Otherwise, it will start an async operation and pass `SalesData` to it. The async
    operation will call a `calculateAverage` function, get an average result, and
    pass it back to the cache. The cache will save it and forward it to the application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持交互简单，我们的应用程序将向缓存请求`SalesData`的平均值。如果缓存包含平均值，它将返回它。否则，它将启动一个异步操作并将`SalesData`传递给它。异步操作将调用一个`calculateAverage`函数，获取平均结果，并将其返回给缓存。缓存将保存它并将其转发给应用程序。
- en: 'This might sound a bit complicated when it''s explained in words, but in code
    it''s pretty simple, straightforward, and clear. Before we begin refactoring,
    let''s have a look at the code that we made this structure for:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当用言语解释时，这可能会听起来有点复杂，但在代码中它相当简单、直接且清晰。在我们开始重构之前，让我们看看我们为这个结构编写的代码：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first idea that came to my mind was to follow the FP principle *keep data
    and functions separate* and move the `calculateAverage` function outside a `SalesData`
    type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个出现在我脑海中的想法是遵循FP原则**保持数据和函数分离**，并将`calculateAverage`函数移出`SalesData`类型之外。
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This would work, but there is one issue with this code. The `calculateAverage`
    function can only work with the `SalesData` type, so it should be hidden inside
    the `SalesData` type and not be visible to other types. Also, in the Swift method
    notation is preferred.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但这个代码有一个问题。`calculateAverage`函数只能与`SalesData`类型一起工作，因此它应该隐藏在`SalesData`类型内部，而不对其他类型可见。此外，在Swift方法表示法中更受欢迎。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Swift 2.0 moves to methods over free functions, so it prefers to use an immutable
    method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0将方法转移到自由函数之上，因此它更倾向于使用不可变方法。
- en: 'Example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '**Swift 2.0 Methods**: `[1,2,3].map { $0 + 1 }.filter { $0 > 1 }`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift 2.0 方法**：`[1,2,3].map { $0 + 1 }.filter { $0 > 1 }`'
- en: '**Swift 1.2 Function**: `filter(map([1,2,3]) { $0 + 1 }) { $0 > 2 }`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift 1.2 函数**：`filter(map([1,2,3]) { $0 + 1 }) { $0 > 2 }`'
- en: Instead of moving the `calculateAverage` function out of the `SalesData` type,
    let's make it immutable and make it only perform an average calculation instead,
    as we have shown in our schema.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将 `calculateAverage` 函数从 `SalesData` 类型中移除，而是将其改为不可变，并使其只执行平均计算，就像我们在我们的方案中所展示的那样。
- en: '`SalesData` should:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalesData` 应该：'
- en: Store revenue numbers
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储收入数字
- en: Be an immutable function for calculating its average
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为计算平均值的不可变函数
- en: Let's refactor the `SalesData` structure and remove all other methods to follow
    our new structure
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构 `SalesData` 结构，并移除所有其他方法，以遵循我们的新结构
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the solution and it''s very clean and simple. Instead of a function
    we have used a computed property. Swift tends to use more read-only properties
    for immutable data and in our example it will make for better readability in the
    future. Also, we have finally used the `reduce` method for calculating the average.
    We can use it in this way:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案，它非常干净简单。我们不是使用函数，而是使用了计算属性。Swift 倾向于使用更多只读属性来处理不可变数据，在我们的例子中，它将使未来的可读性更好。此外，我们最终使用了
    `reduce` 方法来计算平均值。我们可以这样使用它：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next step is to make it work asynchronously. Let's make a new type for it.
    It should take a `SalesData` and a callback closure, which will return `Int`,
    a calculated average result.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使其异步工作。让我们为它创建一个新的类型。它应该接受一个 `SalesData` 和一个回调闭包，该闭包将返回 `Int`，一个计算出的平均值结果。
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have added two more helper methods to our GCD type:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的 GCD 类型添加了两个额外的辅助方法：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code looks okay, but there is one more issue with it. Calling an average
    is embedded together with switching to the background and main threads. It would
    be better if we kept these functions separate, so they could be reused if we wanted
    to add growth numbers and do a similar calculation for them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来不错，但还有一个问题。调用平均值时，背景和主线程的切换是嵌入在一起的。如果我们保持这些函数分开，将更好，这样我们就可以在需要添加增长数字并为他们执行类似计算时重用这些函数。
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we created a `runAsync` generic function that performs some work on the
    background, and returns its result on the main thread. We have used an `@autoclosure(escaping)`
    attribute here in order to be able to pass an expression `data.average, ...)`
    instead of wrapping it into a closure manually. This makes the code syntax cleaner.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `runAsync` 泛型函数，它在后台执行一些工作，并在主线程上返回其结果。我们在这里使用了 `@autoclosure(escaping)`
    属性，以便能够传递一个表达式 `data.average, ...)` 而不是手动将其包装在闭包中。这使得代码语法更简洁。
- en: Now we can calculate the average in an asynchronous way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以异步的方式计算平均值。
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now it's time to build our last component, a cache. For the caching functionality
    a dictionary would be the best choice. Let's add a dictionary to store average
    results for `SalesData`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建我们的最后一个组件，一个缓存。对于缓存功能，字典将是最佳选择。让我们添加一个字典来存储 `SalesData` 的平均结果。
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have created a `SalesDataCache` struct with one property, a cache, and a
    function to get the average value that either gives a cached value or calculates
    it and then saves it to the cache and returns. A very simple solution, but it
    won''t work. It shows an error: **Type ''SalesData'' does not conform to protocol
    ''Hashable''**.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有一个属性（缓存）和获取平均值函数的 `SalesDataCache` 结构体，该函数要么返回缓存的值，要么计算它并将其保存到缓存中，然后返回。这是一个非常简单的解决方案，但它不会工作。它显示了一个错误：**类型
    'SalesData' 不符合协议 'Hashable'**。
- en: The keys in the dictionary have to be `Hashable`, so we need to implement this
    in our `SalesData` type. The `Hashable` protocol requires that we implement the
    `hashValue` property and the equality function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键必须是 `Hashable`，因此我们需要在我们的 `SalesData` 类型中实现这一点。`Hashable` 协议要求我们实现 `hashValue`
    属性和等式函数。
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Implementing a good hash function for an array of numbers is quite complex.
    The easiest way to do it is to add an `id` property to `SalesData` that will uniquely
    identify it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个数字数组的良好哈希函数相当复杂。最简单的方法是为 `SalesData` 添加一个 `id` 属性，使其具有唯一标识。
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now our cache will work and we can finally use it in our application. Let''s
    do that:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的缓存将开始工作，我们最终可以在我们的应用程序中使用它。让我们这样做：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, the API we have created is really easy to use. Even though
    there is a lot of logic going on behind the scenes, for you it''s as simple as
    calling one method: `getAverage`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建的 API 真的非常容易使用。尽管幕后有很多逻辑在运行，但对于您来说，它就像调用一个方法：`getAverage`。
- en: Also, we have structured the underlying components in such a way that they can
    be used separately—for example, if we don't need a cache or asynchronous execution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们以这种方式构建了底层组件，以便它们可以单独使用——例如，如果我们不需要缓存或异步执行。
- en: 'To wrap up the refactoring work on this example, let''s see the full code we
    have ended up with:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个示例的重构工作，让我们看看我们最终得到的完整代码：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Controlling the lifetime
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制生命周期
- en: In our code, we have used an `@autoclosure(escaping)` attribute. It is a very
    powerful attribute and it deserves to be covered in detail. There is also an `@noescape`
    attribute. Let's explore them in more detail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用了 `@autoclosure(escaping)` 属性。这是一个非常强大的属性，值得详细探讨。还有一个 `@noescape`
    属性。让我们更详细地探讨它们。
- en: Applying the @autoclosure and @noescape attributes
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 @autoclosure 和 @noescape 属性
- en: 'First, let''s have a look at when and how we could use these attributes. We
    can apply them to a function parameter with a function type. A function type can
    be represented as a method, function, or closure and it has `(parameters) -> (return)`
    notation. Here are a few examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看何时以及如何使用这些属性。我们可以将它们应用于具有函数类型的函数参数。函数类型可以表示为方法、函数或闭包，并且具有 `(parameters)
    -> (return)` 表示法。这里有一些示例：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '@autoclosure'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@autoclosure'
- en: 'The `@autoclosure` attribute can be applied to a parameter with a function
    type that has no arguments and returns any type, `() -> T`. For example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`@autoclosure` 属性可以应用于没有参数并返回任何类型的函数类型的参数，`() -> T`。例如：'
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When we use an `increase` function without the `@autoclosure` attribute, we
    need to pass a function, a method, or a closure as a parameter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用不带 `@autoclosure` 属性的 `increase` 函数时，我们需要传递一个函数、一个方法或一个闭包作为参数。
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But in this use case it would be better if we could simply use an expression
    without the need to wrap it in a closure, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个用例中，如果我们能够简单地使用一个表达式而不需要将其包装在闭包中会更好，就像这样：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: And that's exactly what `@autoclosure` allows us to do. When you make a parameter
    with the `@autoclosure` attribute, the expression you pass as an argument is automatically
    wrapped into a closure for you. It makes your code cleaner. That's all it does.
    No magic; it simply removes boilerplate code for you.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `@autoclosure` 允许我们做的那样。当你使用 `@autoclosure` 属性的参数时，你传递的表达式会自动为你包装成一个闭包。这使得你的代码更简洁。这就是它所做的全部。没有魔法；它只是为你移除了样板代码。
- en: '@noescape'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@noescape'
- en: The `@noescape` keyword is more complex and interesting. It can be applied to
    a function parameter with any function type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`@noescape` 关键字更为复杂和有趣。它可以应用于具有任何函数类型的函数参数。'
- en: The `@noescape` attribute indicates that a closure will be used inside a function
    body, before the function return is called. It means it won't escape the function
    body.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`@noescape` 属性表示闭包将在函数体内部使用，在函数返回调用之前。这意味着它不会逃离函数体。'
- en: When you apply this attribute, it indicates that a closure will be used synchronously
    inside the function body. Also, it means that it will be released when you leave
    the function. The lifetime of that closure parameter can't outlive the function
    call.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用此属性时，它表示闭包将在函数体内部同步使用。这也意味着它将在你离开函数时释放。该闭包参数的生命周期不能超过函数调用。
- en: Applying this attribute enables some performance optimization but, more importantly,
    it disables the requirement to explicitly specify "`self.`" when accessing instance
    members.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此属性可以启用一些性能优化，但更重要的是，它禁用了在访问实例成员时显式指定 "`self.`" 的要求。
- en: 'Let''s have a look at some examples to better understand this. For a simple
    example, we will use the same `increase` function, but now we will make it a method
    of a `struct`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，以更好地理解这一点。对于简单的示例，我们将使用相同的 `increase` 函数，但现在我们将它作为 `struct` 的一个方法：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `increase` function call contains an error: **Reference to property ''number''
    in closure requires explicit ''self.'' to make capture semantics explicit**; we
    need to explicitly reference `self.number`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`increase` 函数调用中存在错误：**闭包中引用属性 ''number'' 需要显式 ''self.'' 以使捕获语义明确**；我们需要显式引用
    `self.number`。'
- en: 'But let''s have a look at the `increase` function. The `f: ()-> Int` parameter
    is used inside the function body and it''s not leaving its scope. This is a great
    candidate for applying the `@noescape` attribute to it.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '但让我们看看 `increase` 函数。`f: ()-> Int` 参数在函数体内部使用，并且它没有离开其作用域。这是应用 `@noescape`
    属性的一个很好的候选。'
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we don't need to do any further changes and explicitly reference `self.numbers`,
    because `@noescape` guarantees that a closure will be called before we leave that
    function and we can safely reference `self`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要做任何进一步的更改，并且明确地引用 `self.numbers`，因为 `@noescape` 确保在离开该函数之前会调用闭包，我们可以安全地引用
    `self`。
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Apply `@noescape` wherever possible. It adds an extra security level to the
    code. Also, it enables better optimization and increases performance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地应用 `@noescape`。它为代码增加了额外的安全级别。同时，它还使优化更好，并提高性能。
- en: 'If we have a look at methods and function such as `map`, `reduce`, `contains`,
    and others in the Swift standard library, you will see that they are marked with
    the `@noescape` attribute. The golden rule is: *If you call the closure parameter
    before you leave the function, mark it with @noescape*.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Swift 标准库中的方法，如 `map`、`reduce`、`contains` 等，你会发现它们被标记为 `@noescape` 属性。黄金法则：*如果你在离开函数之前调用闭包参数，请标记为
    @noescape*。
- en: Maybe in the future Swift will automatically do this for you, but for now we
    need to do it ourselves.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在未来的 Swift 中，它将自动为你完成这些，但到目前为止，我们需要自己来做。
- en: '@autoclosure (escaping)'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@autoclosure (escaping)'
- en: The `@autoclosure` attribute also applies an `@noescape` implicitly. If you
    want to make a parameter an autoclosure, while indicating that it will have a
    bigger lifetime than a function, use an `@autoclosure(escaping)` attribute. It
    could be useful for asynchronous code execution, like in our example with `AsyncOperation`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`@autoclosure` 属性也隐式地应用了 `@noescape`。如果你想将一个参数作为一个自动闭包，同时表明它将比函数有更长的生命周期，请使用
    `@autoclosure(escaping)` 属性。这对于异步代码执行可能很有用，就像我们在 `AsyncOperation` 的例子中那样。'
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first part of this chapter, we covered multithreading concurrency and
    multi-core device architecture. This general information allows us to understand
    the core principles of concurrent code execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们介绍了多线程并发和多核设备架构。这些一般信息使我们能够理解并发代码执行的核心原则。
- en: In the second part, we covered three ways to run code asynchronously in Swift,
    by using threads, GCD, and NSOperation. We have explored the differences between
    them and the situations for which each is most suitable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们介绍了在 Swift 中使用线程、GCD 和 NSOperation 运行代码的三个异步方法。我们探讨了它们之间的区别以及每种方法最适合的情况。
- en: In the third part of the chapter, we concentrated on architecting asynchronous
    Swift code by using GCD. We have covered important tips such as passing a callback
    function parameter, avoiding a state, using immutable values, and others. Also,
    we have covered two Swift attributes—`@noescape` and `@autoclosure`—that are very
    useful.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第三部分，我们专注于使用 GCD 架构异步 Swift 代码。我们涵盖了重要的提示，例如传递回调函数参数、避免状态、使用不可变值等。此外，我们还介绍了两个非常有用的
    Swift 属性——`@noescape` 和 `@autoclosure`。
- en: 'In the next chapter, we will cover one more important performance optimization
    technique: Lazy Loading.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一种重要的性能优化技术：懒加载。
