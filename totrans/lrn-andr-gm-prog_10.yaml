- en: Working Further on 3D Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined our 3D shape, let's render it on our screen. However, before
    we begin this chapter, let's summarize everything we learned throughout the contents
    of this book since this is our last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We learned a lot of cool stuff about Android. We started from learning about
    the history of Android and quickly progressed toward the installation of software
    required to develop apps for Android. After that, we installed Android Studio
    and configured it with the latest components of Android-N.
  prefs: []
  type: TYPE_NORMAL
- en: Once our environment was set up, we learned how to create a basic app for Android
    and learned about various concepts of Android, such as package names, inputs,
    emulators, and more. After getting an air of familiarity with Android, we learned
    about how to make a transition from making apps to games wherein we learned how
    to create a surface and canvas, which would allow us to create graphics for our
    game, and then we moved on to learn various concepts about game development.
  prefs: []
  type: TYPE_NORMAL
- en: As we progressed further through our chapters, we started learning about the
    process of making games, and within a couple of chapters, we learned how to create
    a 2D game from scratch with a UI. We completed developing a fully-fledge 2D game
    with the same and then moved on to turning things into 3D.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous chapter, we learned that we can create 3D games for native Android
    using OpenGL ES, and so we started with defining basic shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last chapter for this book, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering our object on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding color to our object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating both of our 3D objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pyramid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So without further ado, let's begin with this final part of our book, which
    will set us up with the foundation needed to begin your journey in 3D game development.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering our object on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous chapter, we created a class for our `Triangle` object; however,
    if you run your game, it will still show a blank screen since we have not used
    our render class to display it. We need to create an object for our newly defined
    class, and then using our GL reference, we will draw/render it on our screen.
    Open up your `MyGLRenderer.java` file and let's start by declaring a variable
    of our triangle. We won't be altering any of our code that we wrote in `onSurfaceCreated()`
    or `onSurfaceChanged()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to draw our object on screen, we will simply follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a variable of our `Triangle` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a reference to it in our constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using gl, access the `draw()` method in our `Triangle` to display it on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can do that; just type in the code marked in bold
    in your `MyGLRenderer.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty simple, right? That''s it! Your triangle object is ready to be rendered
    on screen. Don''t believe it? Go ahead; test and run it on your emulator/device,
    and you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Our triangle rendered on screen, finally!
  prefs: []
  type: TYPE_NORMAL
- en: You might think that this object is still 2D, but wait till the part where we
    rotate it. However, before that, let's learn how to add color to this object.
    So let's add some colors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding colors to our object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will demonstrate how we can use different colors to texture
    our object. We will use RGB values using a `colorBuffer` to fetch values from
    the colors of the vertices. After this, we will enable the color-array client
    state, and then these colors are rendered together with the vertices in `glDrawElements()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will again use nio''s `FloatBuffer` to declare our `colorBuffer` variable.
    Here are the steps we would use to add color to our object:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare our `colorBuffer` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare our color array variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We copy our color vertices data to our buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable our color array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define color array buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable color array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, since this is a native property of the triangle, we will write this code
    in our `Triangle.java` class that we created and not in the `MyGLRenderer.java`
    class. Type in the code marked in bold keeping in mind the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a colored triangle. You will get an output like this if you used
    the specified color values. Of course, you are free to change and tweak the colors
    as you please by changing the RGB values in our `colors` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Our colored triangle
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now we will make our triangle rotate, which will clarify our doubts whether
    it is actually a 3D object or not.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating our object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you must have understood that any changes in the rendering of an object
    have to be done in the `MyGLRenderer`, whereas any properties that are local to
    our object are to be done in the respective object's file. So, we will write our
    rotation code in our `MyGLRenderer.java` file because rotating an object is a
    part of the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our logic to rotate our triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: We take our rotation angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We rotate our object in a specified rotation angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We increment our rotation angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s do it; we will simply declare two variables at the start for our rotational
    angle and speed; then in our `onDrawFrame()` method, implement our rotation logic,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After you compile this code, your triangle will start rotating. Cool, right?
    Build and run and see your rotating triangle in action!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Our rotating triangle
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! Now, let's use this knowledge to create a proper 3D object, our pyramid!
    We're pretty clear about the process for creating objects, so we will breeze through
    the pyramid part.
  prefs: []
  type: TYPE_NORMAL
- en: Let's repeat the same steps for our pyramid. This time our object will be purely
    3D rather than just a 2D plane object; so, let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pyramid 3D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have understood how to define shapes and render objects on screen,
    it will be comparatively easier to create our 3D object. We will follow almost
    the same procedure as we did to create our triangle. We will create our pyramid
    right besides our triangle; let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've learned from the previous part, we will first create a class of our
    pyramid in order to define our shape. So create a file `Pyramid.java` to define
    the shape of our pyramid object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pyramid has five faces, so we will require five vertices to draw our pyramid.
    So after you create your `Pyramid.java`, we will define our vertices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, now we have our vertices set, but just like our triangle, we still
    have our buffers and indices to take care of. We will quickly define our float
    and byte buffers for our shape and colors along with the indices that will make
    our pyramid faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write the constructor of our `Pyramid` based on the logic of our
    triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, of course, our `draw()` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re done defining the shape of our `Pyramid`. So, finally your entire code
    for `Pyramid` will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that's set but we still won't be getting to see the Pyramid on our screen
    since we haven't rendered it yet; let's do that now to bring our pyramid on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering our 3D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on our understanding of our previous example working with the triangle,
    we are pretty clear that in order to render our objects, we have to use our `MyGLRenderer.java`
    class. Since we are pretty clear on how our 3D rendering works, we will also add
    in our rotation code in the same code.
  prefs: []
  type: TYPE_NORMAL
- en: Here's one crucial thing to take into account though, we will be drawing our
    pyramid beside our triangle, so we have to make sure that we don't overlap our
    pyramid over our triangle. To do so, we will use the code `gl.Translate()` that
    we will observe as a follow up inside our `onDrawFrame()` code block after we
    draw our triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will work on our `MyGLRenderer.java` file, so open that file and write in
    the code marked in bold; the rest of the part remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, so everything looks set. Build and run your project, and you will
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Both our objects are visible on screen now
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created a 3D object using OpenGL. In
    a similar way, you can create any kind of object based on the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the foundation of creating a 3D basic shapes game with OpenGL.
    Creating a fully-fledged 3D game is a huge task of its own, and this is just a
    glimpse of what you can do.
  prefs: []
  type: TYPE_NORMAL
- en: We would recommend that you buy our other books on 3D game development to go
    ahead in more depth on creating games in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create 3D objects and render them on the
    screen. We also learned how to add colors to objects as well as rotate them in
    a 3D direction. With this chapter, we conclude this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to create games in 2D and 3D using native Android. With
    the knowledge gained from this chapter, you can get started on your journey into
    game development and start creating your own games for Android.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this book for creating your games with Android. The knowledge
    gained through this book will serve as a foundation for the games you make ahead.
    The advantage of creating games in native Android is that primarily, the file
    size of games turns out to be quite small, which is what users generally look
    for. If you were to create any game using an engine, you would end up creating
    a game, which would have a comparatively larger file size by the end of the development
    process; you'd need to optimize it even further, but yet there's only so much
    you can do for that. So, developing native will not only allow you to make games
    with smaller file size, but will also enhance your knowledge and core understanding
    of the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this book, it is now up to you and your imagination to start
    creating games with the help of the knowledge you learned through this book. Of
    course, creating games with an engine is definitely a faster process; if you want
    to skip through creating your own classes for each and everything, it is recommended
    that you get started with game engines. Packt has a wide variety of books to help
    you in the process. Perhaps, your best starting point to get started with a game
    engine is *Unity Game Engine*. If you're interested in learning more and giving
    your game development process a boost, then the best recommendation will be to
    go through Packt's book on *Unity Game Engine*.
  prefs: []
  type: TYPE_NORMAL
- en: Wishing you all the best for creating your next game!
  prefs: []
  type: TYPE_NORMAL
