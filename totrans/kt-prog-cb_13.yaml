- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Unit testing Kotlin code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin代码的单元测试
- en: Unit testing with Mockito
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mockito进行单元测试
- en: Running Instrumentation tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行仪器测试
- en: Writing JUnit rules in Kotlin (@Rule)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中编写JUnit规则（@Rule）
- en: Acceptance tests using Espresso Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Espresso Kotlin进行验收测试
- en: Writing assertEquals in Kotlin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中编写assertEquals
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Testing is a fundamental part of software engineering if you want your code
    base to be scalable and maintainable. In Android, there are basically two types
    of testing: one is **unit testing** and the other is **integrated testing**. Unit
    testing is a type of testing where individual units are tested independently,
    while integrated testing, which is also sometimes known as instrumentation testing,
    requires an Android device or an emulator for the tests to run. Since integrated
    testing requires real devices or an emulator, these tests are often slower to
    execute. Unit tests are fast because they don’t have any such need for real devices
    or emulators in order to run. Since unit tests are faster and instrumentation
    tests are slower, it is often thought that a robust test suite should have these
    tests in the proportion of 80% to 20%. So your code base should consist of 80%
    unit tests and 20% instrumentation tests.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望代码库可扩展且可维护，测试是软件工程的基本部分。在Android中，基本上有两种类型的测试：一种是**单元测试**，另一种是**集成测试**。单元测试是一种独立测试各个单元的测试类型，而集成测试（有时也称为仪器测试），则需要Android设备或模拟器来运行测试。由于集成测试需要真实设备或模拟器，这些测试通常执行速度较慢。单元测试速度快，因为它们不需要真实设备或模拟器来运行。由于单元测试速度快而仪器测试慢，人们通常认为一个健壮的测试套件应该有这些测试的比例为80%到20%。因此，您的代码库应该由80%的单元测试和20%的仪器测试组成。
- en: Unit testing Kotlin code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin代码的单元测试
- en: Unit tests involve, basically, *testing in units*. These tests are often faster
    to execute because they are executed in the JVM, and hence do not require the
    dexing, packaging, and installing-on-the-emulator steps, reducing test cycles
    from minutes to seconds so that you can quickly iterate and refactor your code.
    Integration tests, on the other hand, require all the aforementioned steps. Apart
    from testing your code, unit tests also work as a great documentation of the code
    base. That's why it shouldn't surprise you if you see the names of methods phrased
    in odd ways—for example, `testIfConfirmationEmailIsSent`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试基本上涉及**单元测试**。这些测试通常执行速度更快，因为它们在JVM中执行，因此不需要进行dexing、打包和在模拟器上安装的步骤，将测试周期从分钟缩短到秒，以便您可以快速迭代和重构代码。另一方面，集成测试则需要上述所有步骤。除了测试代码外，单元测试还充当代码库的绝佳文档。这就是为什么如果您看到方法名称以奇特的方式表达，例如，`testIfConfirmationEmailIsSent`，您可能不会感到惊讶。
- en: In this recipe, we will learn how to write unit tests for your Android code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为您的Android代码编写单元测试。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You’ll need Android Studio, as we will learn to write unit tests for Android
    code, and also because Android Studio provides great support for unit tests. You
    can also find the source code at [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    in the 4-unit-tests branch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要Android Studio，因为我们将学习如何为Android代码编写单元测试，并且因为Android Studio为单元测试提供了极大的支持。您还可以在[https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)的4-unit-tests分支中找到源代码。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand how to write unit tests for Android code in
    the Kotlin language:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解如何在Kotlin语言中编写Android代码的单元测试：
- en: 'When you create a new Android project in Android Studio, Android Studio will
    provide support for both unit and Android tests. It provides you with separate
    directories where you can place your test. Take a look at the following screenshot:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在Android Studio中创建一个新的Android项目时，Android Studio将提供对单元测试和Android测试的支持。它为您提供了单独的目录，您可以在其中放置您的测试。请看以下截图：
- en: '![](img/bfa262d7-f272-4c9f-b64b-e85ffe7ae866.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfa262d7-f272-4c9f-b64b-e85ffe7ae866.png)'
- en: As you can see, test is where *unit tests* are placed and androidTest is where
    *Android tests* or *instrumentation tests* are placed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，test是放置**单元测试**的地方，androidTest是放置**Android测试**或**仪器测试**的地方。
- en: 'There are two demo tests provided to you already: ExampleUnitTest and ExampleInstrumentedTest.
    To run them, just right-click on ExampleUnitTest and click on Run ExampleUnitTest.
    After running the tests, you can see the results of the tests in the console,
    as seen in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已经为你提供了两个演示测试：ExampleUnitTest 和 ExampleInstrumentedTest。要运行它们，只需右键单击 ExampleUnitTest
    并点击运行 ExampleUnitTest。运行测试后，你可以在控制台中看到测试结果，如下面的截图所示：
- en: '![](img/85dbdee5-2048-4da5-9d8b-84d8677c3d52.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85dbdee5-2048-4da5-9d8b-84d8677c3d52.png)'
- en: 'Now, let’s try creating our own unit test:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试创建我们自己的单元测试：
- en: 'We usually have the `Utility` class in our code, which has methods that can
    be used by any class, so instead of defining those methods in every class, we
    define them in the `Utility` class. So let’s create a method, `addTwoNumbers`,
    which will take two parameters, `a` and `b`, and return a result—`a+b`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通常在我们的代码中有一个 `Utility` 类，它包含可以被任何类使用的方法，所以我们不是在每一个类中定义这些方法，而是在 `Utility` 类中定义它们。所以，让我们创建一个方法，`addTwoNumbers`，它将接受两个参数，`a`
    和 `b`，并返回一个结果——`a+b`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Android Studio, you can create tests directly from the class itself. Just
    right-click on the class name and click on Create test:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，你可以直接从类本身创建测试。只需右键单击类名，然后点击创建测试：
- en: '![](img/9c9e10f0-d047-42be-a12a-4ecd57878b30.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c9e10f0-d047-42be-a12a-4ecd57878b30.png)'
- en: 'After that, you will be shown a dialog on which you can select all the methods
    for which you want to create a test. It is recommended that you have tests for
    every method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你将看到一个对话框，你可以选择你想要创建测试的所有方法。建议为每个方法都编写测试：
- en: '![](img/18f873bc-d633-45c0-833e-dca9ff3e0950.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18f873bc-d633-45c0-833e-dca9ff3e0950.png)'
- en: 'When you click on OK, you will be shown another dialog box that will ask you
    where to place your tests. In this case, this is a unit test, so we will place
    it in `app/src/test…`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击“确定”时，将显示另一个对话框，询问你将测试放在哪里。在这种情况下，这是一个单元测试，所以我们将它放在 `app/src/test…`：
- en: '![](img/390fa1db-e2fc-434d-ad77-48d1afcead43.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/390fa1db-e2fc-434d-ad77-48d1afcead43.png)'
- en: 'When you click on OK, Android Studio autogenerates boilerplate code in `UtilityTest.kt`,
    which looks like this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击“确定”时，Android Studio 会自动在 `UtilityTest.kt` 中生成样板代码，如下所示：
- en: '![](img/90515872-8af2-4d12-957e-44ab5d7f1d91.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90515872-8af2-4d12-957e-44ab5d7f1d91.png)'
- en: 'Now we will add a few `assertEquals` statements, which check the expected value
    against the results:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加几个 `assertEquals` 语句，这些语句将检查预期值与结果：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument is the expected value and the second argument is the output
    of the function. If you run the test, it will pass.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是预期值，第二个参数是函数的输出。如果你运行测试，它将通过。
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you run the unit tests, they test all the methods that have the `@Test`
    notation above them. There is also a `@Before` notation, which is placed above
    a method. The method with the `@Before` notation is run before any other method
    of the class. This can be helpful when you are setting up objects and variables
    that might be used later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行单元测试时，它们会测试所有带有 `@Test` 注释的方法。还有一个 `@Before` 注释，它位于一个方法上方。带有 `@Before` 注释的方法将在类的任何其他方法之前运行。这在你设置可能被以后使用到的对象和变量时非常有用。
- en: One thing to note here is that unit tests cannot use Android SDK components.
    To use those components, you need instrumentation tests, or use a mocking framework
    like **Mockito**, which mocks the Android components so that it can be used unit
    tests. We will cover this in the next recipe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，单元测试不能使用 Android SDK 组件。要使用这些组件，你需要使用仪器测试，或者使用像 **Mockito** 这样的模拟框架，它模拟
    Android 组件以便在单元测试中使用。我们将在下一个菜谱中介绍这一点。
- en: Unit testing with Mockito
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mockito 进行单元测试
- en: 'As we discussed in the previous recipe, we cannot use Android components in
    unit tests. This is why we are able to run them faster, and without any device.
    If you want to use Android components in your tests, there are two options:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的菜谱中讨论的，我们不能在单元测试中使用 Android 组件。这就是为什么我们能够更快地运行它们，而且不需要任何设备。如果你想在测试中使用
    Android 组件，有两种选择：
- en: Write integration tests, which run on your device or emulator.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写集成测试，这些测试将在你的设备或模拟器上运行。
- en: 'Use a mocking framework, such as Mockito, which basically mocks the Android
    SDK components so that you can use them without any device or emulator, just like
    any other unit test. The benefit of a mocking framework is that it takes a lot
    less time to run the tests, as the tests are basically unit tests only. Here''s
    an accurate definition of a mock object by Vogella:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟框架，例如Mockito，它基本上模拟了Android SDK组件，这样你就可以在不使用任何设备或模拟器的情况下使用它们，就像其他单元测试一样。模拟框架的好处是测试运行时间大大减少，因为测试基本上是单元测试。以下是Vogella对模拟对象的准确定义：
- en: '"A *mock object* is a dummy implementation for an interface or a class in which
    you define the output of certain method calls. Mock objects are configured to
    perform a certain behavior during a test. They typical record the interaction
    with the system and test can validate that."'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个**模拟对象**是一个接口或类的占位实现，在其中你定义了某些方法调用的输出。模拟对象被配置为在测试期间执行特定的行为。它们通常会记录与系统的交互，测试可以验证这些交互。"'
- en: With that in mind, let's try using Mockito to write unit tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们尝试使用Mockito编写单元测试。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You’ll need Android Studio, as it provides great support for unit tests, and
    we will also be learning to write the unit tests for Android code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要Android Studio，因为它为单元测试提供了很好的支持，我们还将学习如何编写Android代码的单元测试。
- en: You can also find the source code at [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    in the 4-unit-tests branch.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)的4-unit-tests分支中找到源代码。
- en: 'First, you need to add the Mockito dependency to your project. You can do so
    by adding the following line in your `build.gradle` file at the app level:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将Mockito依赖项添加到你的项目中。你可以在你的`build.gradle`文件中添加以下行来实现这一点，在app级别：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you have added the dependency, you are good to go ahead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了依赖项，你就可以继续前进。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We usually use Mockito to mock Android classes, but let''s test a simple class
    using Mockito:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用Mockito来模拟Android类，但让我们用Mockito测试一个简单的类：
- en: 'Here''s a small test that tests a `functionUnderTest` function of the `Utility`
    class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个小的测试，用于测试`Utility`类的`functionUnderTest`函数：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding class, we are calling the `functionUnderTest` method and then
    verifying whether the method has been called or not. (Yeah!, not a very good use
    case of a test, but let''s try to run this test) When you run it, you''ll see
    an error like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的类中，我们调用`functionUnderTest`方法，然后验证该方法是否被调用过。（是的，这不是一个很好的测试用例，但让我们尝试运行这个测试）当你运行它时，你会看到一个错误，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The reason for the preceding error is that every class is final by default
    in Kotlin. You need to *open* them if you want to extend or mock them. However,
    does that mean that you need to add open modifier to every class that you want
    to test? That sounds like a bad idea, and it is. There is a hack around this problem.
    The hack is to manually add the option of mocking the final class. You need to
    create a file in `test/resources/mockito-extensions folder called org.mockito.plugins.MockMaker`and
    put the following code into that file:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面错误的原因是Kotlin中每个类默认都是final的。如果你想扩展或模拟它们，你需要将它们打开。然而，这意味着你需要为想要测试的每个类添加`open`修饰符吗？这听起来是个坏主意，确实如此。有一个解决这个问题的方法。这个方法是在`test/resources/mockito-extensions`文件夹中手动添加模拟final类的选项。你需要创建一个名为`org.mockito.plugins.MockMaker`的文件，并将以下代码放入该文件中：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now if you run the code, it will pass smoothly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行代码，它将顺利通过。
- en: 'There are many variants of the `verify` method, such as the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`verify`方法有许多变体，如下所示：'
- en: '`verify(classUnderTest, never()).functionUnderTest()`, which tests whether
    it isn''t ever called'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify(classUnderTest, never()).functionUnderTest()`，这测试了该方法是否从未被调用过'
- en: '`atLeastOnce()`, `atLeast(2)`, `times(5)`, `atMost(3)`, which can also be used
    to verify the number of interactions with the method'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeastOnce()`、`atLeast(2)`、`times(5)`、`atMost(3)`，这些也可以用来验证与方法的交互次数'
- en: 'Let''s see another Mockito test that mocks `SharedPreferences` (an Android
    component):'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看另一个Mockito测试，它模拟了`SharedPreferences`（一个Android组件）：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `when(...).thenReturn(...)` construct keeps an eye on the object, and when
    the method inside the `when` construct is called, it returns the value under the `thenReturn`
    construct. Note the [PRE7] surrounding `when`; this is because `when` is a reserved
    keyword in Kotlin, so we call it with back ticks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`when(...).thenReturn(...)`结构会监视对象，当`when`结构内的方法被调用时，它返回`thenReturn`结构下的值。注意`when`周围的[PRE7]；这是因为`when`是Kotlin中的保留关键字，所以我们用反引号来调用它。'
- en: 'You can also return multiple values, which simulates calling a method multiple
    times:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以返回多个值，这模拟了多次调用方法：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, the first call to the `getInt` method will return
    `1`, and the second call will return `2`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，对 `getInt` 方法的第一次调用将返回 `1`，第二次调用将返回 `2`。
- en: There's more…
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Let's understand a `spy` object in unit testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解单元测试中的 `spy` 对象。
- en: Spy object
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍对象
- en: 'The mocking framework also provides a `spy` method that can be used to wrap
    the real objects. The calls to the spy objects are delegated to the real object.
    What''s the use of that, you might be thinking. It can check the interactions
    on a real object, which wasn''t possible if the object is not mocked. Let''s take
    a look at the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟框架还提供了一个 `spy` 方法，可以用来包装真实对象。对间谍对象的调用被委派给真实对象。你可能会想，这有什么用呢？它可以检查真实对象上的交互，如果对象没有被模拟，这是不可能的。让我们看看以下示例：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding test will pass.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试将会通过。
- en: Note that calling `spy.get(0)` returns `-1`, which is equal to what you'd get
    if you had interacted with the real object. Furthermore, you are also able to
    verify the interaction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 `spy.get(0)` 返回 `-1`，这与你与真实对象交互时得到的结果相同。此外，你还能验证交互。
- en: Mockito limitations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito 限制
- en: Mockito has certain limitations—for example, you cannot mock `static` and `private`
    methods. This is out of the scope of this book, so to know more about the Mockito
    limitations, visit [https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito](https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 有某些限制——例如，你不能模拟 `static` 和 `private` 方法。这超出了本书的范围，所以想了解更多关于 Mockito
    限制的信息，请访问 [https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito](https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito)。
- en: Running instrumentation tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行仪器测试
- en: In the preceding recipes, we learned how to run and write unit tests. In this
    recipe, we will learn how to run instrumentation tests. The integration tests
    are placed under the androidTest directory in your Android project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们学习了如何运行和编写单元测试。在这个菜谱中，我们将学习如何运行仪器测试。集成测试位于你的 Android 项目中的 androidTest
    目录下。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since instrumentation tests require real devices or emulators to run on, ensure
    that you have one of either of these. We'll be using Android Studio 3.0 for our
    coding purposes. You can download the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `5-instrumentation-tests` branch. We will also be using *Espresso*
    for writing instrumentation tests as it is the easiest software to use. Espresso
    is automatically included in your project when you create a new project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仪器测试需要在真实设备或模拟器上运行，请确保你拥有其中之一。我们将使用 Android Studio 3.0 进行编码。你可以从 [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    下载源代码，并切换到 `5-instrumentation-tests` 分支。我们还将使用 *Espresso* 编写仪器测试，因为它是最容易使用的软件。当你创建新项目时，Espresso
    会自动包含在你的项目中。
- en: '**Espresso** is targeted at developers who believe that automated testing is
    an integral part of the development lifecycle. While it can be used for black-box
    testing, Espresso''s full power is unlocked by those who are familiar with the
    code base under test.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Espresso** 面向那些认为自动化测试是开发生命周期中不可或缺部分的开发者。虽然它可以用于黑盒测试，但只有熟悉待测代码库的人才能解锁 Espresso
    的全部功能。'
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following steps, you will learn how to run instrumentation tests:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，你将学习如何运行仪器测试：
- en: 'Let''s create a simple app, which will just have the Hello World! text and
    a button:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序，它将只包含 Hello World! 文本和一个按钮：
- en: '![](img/114c123e-0d88-4a8e-ab7b-b23e5068c5d2.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/114c123e-0d88-4a8e-ab7b-b23e5068c5d2.jpeg)'
- en: 'On clicking the button, the text will change to Goodbye World!:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮时，文本将更改为 Goodbye World!：
- en: '![](img/e55b5e1c-5aa0-45a6-82e8-555cae505e5e.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e55b5e1c-5aa0-45a6-82e8-555cae505e5e.jpeg)'
- en: Now, let's write a test to verify this behavior.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个测试来验证这个行为。
- en: In this recipe, we will learn how to run the espresso test; in the next recipe,
    we will learn how to write an espresso test, so just bear with me until I explain
    how to write an espresso test in the later recipe because it is complicated and
    needs an entire recipe to do justice to it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何运行咖啡测试；在下一个菜谱中，我们将学习如何编写咖啡测试，所以请耐心等待，直到我解释如何在后续菜谱中编写咖啡测试，因为它很复杂，需要整个菜谱来公正地处理它。
- en: 'Here''s an espresso test:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个咖啡测试：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first line of the `testButtonBehaviour` method, we are checking whether Hello
    World! is appearing on screen. Then, we are performing a click operation on the
    button and finally checking whether Goodbye World! is appearing on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `testButtonBehaviour` 方法的第一行，我们正在检查“Hello World!”是否出现在屏幕上。然后，我们对按钮执行点击操作，最后检查“Goodbye
    World!”是否出现在屏幕上。
- en: 'To run the preceding test, just right-click on the test class and select Run
    MainActivityTest:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行前面的测试，只需右键单击测试类并选择运行 MainActivityTest：
- en: '![](img/5eedabc6-eeea-4134-b0be-7296bdfb5797.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eedabc6-eeea-4134-b0be-7296bdfb5797.png)'
- en: Once you select that option, you'll be shown a dialog box that will ask which
    device you want to run the test on. You can either choose a real device or an
    emulator.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择该选项，就会弹出一个对话框，询问您要在哪个设备上运行测试。您可以选择一个真实设备或模拟器。
- en: After that, you can see your tests running on your device (you will see the
    steps written in the code being performed on the device).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以在设备上看到测试的运行情况（您将看到代码中写出的步骤在设备上执行）。
- en: There's more…
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you run any instrumentation test, you'll note that it takes a lot of time
    to pass, even if it's a small test. In the current scenario, **test-driven development **(**TDD**)
    is becoming more and more popular, but its tests take a lot of time to execute;
    it's not a good way of using TDD. So the number of instrumentation tests should
    be kept to a minimum, and it's better to use a mocking framework, such as Mockito
    or Robolectric.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行任何仪器测试，您会注意到即使是一个小测试，它也需要很长时间才能通过。在当前场景中，**测试驱动开发（TDD**）越来越受欢迎，但它的测试执行时间很长；这不是使用
    TDD 的好方法。因此，应该将仪器测试的数量保持在最低限度，并且最好使用模拟框架，如 Mockito 或 Robolectric。
- en: 'Wikipedia says that TDDis a software development process that relies on the
    repetition of a very short development cycle: Requirements are turned into very
    specific test cases, and then the software is improved to pass the new tests only.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科表示，TDD 是一种依赖非常短的开发周期重复的软件开发过程：需求被转化为非常具体的测试用例，然后软件被改进以通过新的测试。
- en: Writing JUnit rules in Kotlin (@Rule)
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中编写 JUnit 规则（@Rule）
- en: Rules are a way to add functionalities that apply to all tests of the class.
    For example, `ExternalResource` executes the code before and after a test method.
    This can be used to set up a database, network, and filesystem connection before
    the test method, and can tear them down when the tests are complete. Of course,
    you can also do it using the `@Before` and `@After` annotations, but doing it
    with `ExternalResource` (as a JUnit rule) helps with code reuse.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是一种为类中所有测试添加功能的方式。例如，`ExternalResource` 在测试方法前后执行代码。这可以在测试方法之前设置数据库、网络和文件系统连接，并在测试完成后断开它们。当然，您也可以使用
    `@Before` 和 `@After` 注解来完成，但使用 `ExternalResource`（作为 JUnit 规则）有助于代码重用。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3.0 for coding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3.0 进行编码。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: In this recipe, we will be using `ExpectedException` as the JUnit rule because
    it helps the test declare that an exception is expected and also provides a way
    to clearly express the expected behavior. It is much more flexible than using
    the `@Test(expected= ...)` annotation because we can test specific error messages
    and custom fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `ExpectedException` 作为 JUnit 规则，因为它有助于测试声明期望出现异常，并提供了一种清晰表达期望行为的方式。它比使用
    `@Test(expected= ...)` 注解更加灵活，因为我们可以测试特定的错误消息和自定义字段。
- en: 'In the following steps, we will learn how to write JUnit tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何编写 JUnit 测试：
- en: 'Let''s first create a simple method that throws an exception. We will then
    write a test to test this method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个会抛出异常的简单方法。然后我们将编写一个测试来测试这个方法：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s create a new rule of the `ExpectedException` class and write a
    test:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为 `ExpectedException` 类创建一个新的规则并编写一个测试：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run the preceding code, you will get an error:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，您将得到一个错误：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The error is because JUnit allows the provision of rules through a test class
    field or a getter method. However, we don't have fields in Kotlin—we have properties;
    so what you've really annotated here is a property, not a field.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误是因为 JUnit 允许通过测试类字段或 getter 方法提供规则。然而，在 Kotlin 中我们没有字段——我们有属性；所以您在这里真正注解的是属性，而不是字段。
- en: 'The easiest way around this problem is by adding the `@JvmField` annotation
    with `@Rule`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是通过添加 `@JvmField` 注解和 `@Rule`：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you run the test now, it will pass.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行测试，它将通过。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We are aware of the fact that Kotlin plays with properties rather than fields
    in Java. However, to provide compatibility with the Java language, `@JvmField`
    can be used to instruct the Kotlin compiler not to generate getters–setters for
    this property and expose it as a field.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Kotlin 与 Java 不同，它操作的是属性而不是字段。然而，为了与 Java 语言兼容，可以使用 `@JvmField` 指示 Kotlin
    编译器不要为这个属性生成 getters-setters，并将其作为字段暴露。
- en: 'However, there are a few restrictions when using annotations. We can''t use
    them with the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用注解时有一些限制。我们无法与以下内容一起使用：
- en: Private properties
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性
- en: Properties with `open`, `override`, and `const` modifiers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `open`、`override` 和 `const` 修饰符的属性
- en: Delegated properties
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托属性
- en: Acceptance tests using Espresso Kotlin
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Espresso Kotlin 进行验收测试
- en: Espresso is the most popular UI testing framework for Android. It was released
    by Google in 2013 and is the easiest to use of its kind. It provides support for
    complex things, such as ensuring that an activity is run before the tests are
    run, or waiting till the observed background tasks are completed. These things
    were hard to synchronize prior to Espresso, and UI testing was considered a difficult
    thing to do.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是 Android 最受欢迎的 UI 测试框架。它于2013年由 Google 发布，是同类中最容易使用的。它支持复杂的功能，例如确保在运行测试之前运行活动，或者等待观察到的后台任务完成。在
    Espresso 之前，这些事情很难同步，UI 测试被认为是一项困难的任务。
- en: In this recipe, we will learn how to use Espresso to perform acceptance testing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Espresso 进行验收测试。
- en: '**Acceptance testing** is a level of software testing where a system is tested
    for acceptability. The purpose of this test is to evaluate the system''s compliance
    with the business requirements and assess whether it is acceptable for delivery.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试**是一种软件测试级别，其中测试系统是否可接受。此测试的目的是评估系统是否符合业务需求，并判断其是否适合交付。'
- en: Source: [http://softwaretestingfundamentals.com/](http://softwaretestingfundamentals.com/)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://softwaretestingfundamentals.com/](http://softwaretestingfundamentals.com/)
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using Android Studio 3.0 for our coding purposes. You can download
    the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the 5-instrumentation-tests branch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0 进行编码。你可以从[https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)下载源代码，并切换到5-instrumentation-tests分支。
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In Espresso, we mainly have three components:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Espresso 中，我们主要有三个组件：
- en: '`ViewMatchers`: Allows you to find a view in the current view hierarchy. This
    can be done in various ways, such as searching by `id`, `name`, `child`, and so
    on. You can also use Hamcrest matchers, such as `containsString`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewMatchers`: 允许你在当前视图层次结构中查找视图。这可以通过多种方式完成，例如通过 `id`、`name`、`child` 等进行搜索。你还可以使用
    Hamcrest 匹配器，例如 `containsString`。'
- en: '`ViewActions`: Allows you to perform actions on the views, such as clicking,
    typing, clearing text, and so on.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewActions`: 允许你在视图中执行操作，例如点击、输入、清除文本等。'
- en: '`ViewAssertions`: Allows you to assert the state of a view that checks whether
    the condition under the view assertion passes.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewAssertions`: 允许你断言视图的状态，检查视图断言下的条件是否通过。'
- en: 'Let''s take a look at the following steps to understand acceptance testing
    using Espresso:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，以了解如何使用 Espresso 进行验收测试：
- en: 'Here''s an example of a text matcher (a text matcher matches the text; it''s
    a part of `ViewMatchers`):'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个文本匹配器（文本匹配器匹配文本；它是 `ViewMatchers` 的一部分）的示例：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we will create a simple test that will test whether clicking on the button
    changes the text from Hello World! to Goodbye World!:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个简单的测试，以测试点击按钮是否将文本从 Hello World! 更改为 Goodbye World!：
- en: '![](img/4094ebc1-c715-467b-a742-8161a5712f4c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4094ebc1-c715-467b-a742-8161a5712f4c.png)'
- en: 'The following is an espresso test written to test the preceding functionality:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个用于测试前面功能的 Espresso 测试示例：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the first line, we have created a rule that provides functional testing of
    a single activity. This will open the activity before the tests are run and close
    it once the tests are completed. The statements in the `testButtonBehaviour` method
    check the UI conditions, such as whether the text is initially Hello World! (first
    condition), then performs a click action on the button, and then finally checks
    whether the text is now Goodbye World!.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个规则，它提供了单个活动的功能测试。这将打开测试运行之前的活动，并在测试完成后关闭它。`testButtonBehaviour`
    方法中的语句检查 UI 条件，例如文本是否最初为 Hello World!（第一个条件），然后对按钮执行点击操作，最后检查文本是否现在是 Goodbye World!。
- en: 'You can also get hold of the "God" object—that is, `Context`—using the instrumentation
    API:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用 instrumentation API 获取“上帝”对象——即 `Context`：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to start the activity from the intent, you just need to provide
    `false` as the third argument in the constructor of `ActivityTestRule`; it can
    be used as shown:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想从意图中启动活动，您只需在 `ActivityTestRule` 构造函数中将第三个参数提供为 `false` 即可；它可以像下面这样使用：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another cool feature of Espresso is to record the interactions using **Record
    Espresso Test**. This records all the interactions that you make with the app,
    and can generate tests from it. To use that feature, follow these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 的另一个酷特性是使用 **Record Espresso Test** 记录交互。这将记录您与应用程序的所有交互，并可以从中生成测试。要使用该功能，请按照以下步骤操作：
- en: 'Go to Run on the toolbar and select Record Espresso Test:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏上转到“运行”并选择“Record Espresso Test”：
- en: '![](img/5a560a97-496a-457d-9b3d-578e7b0a74c1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a560a97-496a-457d-9b3d-578e7b0a74c1.png)'
- en: 'It will then open a dialog, on which you can see the recorded steps:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将打开一个对话框，您可以在其中看到记录的步骤：
- en: '![](img/15f66e1f-49b8-4dd4-b7cc-588b73ddf575.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15f66e1f-49b8-4dd4-b7cc-588b73ddf575.png)'
- en: Clicking on OK will automatically generate the tests based on your interaction.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 将自动根据您的交互生成测试。
- en: There's more…
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that we have used the `@JvmField` annotation with the rule. The reason
    for this is extensively discussed in the *How to write JUnit rules in Kotlin (@Rule)* recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经在规则中使用了 `@JvmField` 注解。关于这一点，在 *如何在 Kotlin 中编写 JUnit 规则 (@Rule)* 菜谱中有详细的讨论。
- en: Writing assertEquals in Kotlin
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中编写 assertEquals
- en: The `assertEquals` statement is widely used for testing code. It basically takes
    in two arguments—an expected value and an actual value—with an optional third
    argument message. If the expected value matches the actual value, the `assertEquals`
    passes—otherwise, it fails.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEquals` 语句在测试代码中得到了广泛的应用。它基本上接受两个参数——一个预期值和一个实际值，还有一个可选的第三个参数消息。如果预期值与实际值匹配，`assertEquals`
    通过——否则，它失败。'
- en: 'Using `assertEquals` with primitive types is straightforward, but if you want
    to use it with a custom object, you''ll have to do a little more work. For example,
    the following `assertEquals` will not pass:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始类型与 `assertEquals` 一起使用很简单，但如果你想用它与自定义对象一起使用，你将不得不做更多的工作。例如，以下 `assertEquals`
    将不会通过：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this recipe, we will learn how to write `assertEquals` statements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何编写 `assertEquals` 语句。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using Android Studio 3.0 for our coding purposes. You can download
    the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `5-instrumentation-tests` branch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0 进行我们的编码。您可以从 [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    下载源代码，并切换到 `5-instrumentation-tests` 分支。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s go through the following steps to understand `assertEquals`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来了解`assertEquals`：
- en: 'In the following code, if you run the given `assertEquals`, it will not pass:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，如果您运行给定的 `assertEquals`，它将不会通过：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you check the difference, it will tell you that they aren''t equal because
    they are two different objects:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您检查差异，它将告诉您它们不相等，因为它们是两个不同的对象：
- en: '![](img/febf47ed-5421-4289-a13a-ba0b6756b9d1.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/febf47ed-5421-4289-a13a-ba0b6756b9d1.png)'
- en: 'So we will need to override the `equals` method of the `MyObj` class, and we
    will check the following things:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要重写 `MyObj` 类的 `equals` 方法，我们将检查以下内容：
- en: Whether the other object references the same object—this can be done using the
    `===` operator, which checks the referential equality
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否其他对象引用相同的对象——这可以通过使用 `===` 运算符来完成，它检查引用相等性
- en: Whether the object in question equals the other object's Java class
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否问题中的对象等于其他对象的 Java 类
- en: 'Whether the content of both objects is the same:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象的内容是否相同：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, when you run `assertEquals` with two objects of the same content, it will
    pass smoothly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你用内容相同的两个对象运行 `assertEquals` 时，它将顺利通过。
