- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing Kotlin code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Instrumentation tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing JUnit rules in Kotlin (@Rule)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance tests using Espresso Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing assertEquals in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a fundamental part of software engineering if you want your code
    base to be scalable and maintainable. In Android, there are basically two types
    of testing: one is **unit testing** and the other is **integrated testing**. Unit
    testing is a type of testing where individual units are tested independently,
    while integrated testing, which is also sometimes known as instrumentation testing,
    requires an Android device or an emulator for the tests to run. Since integrated
    testing requires real devices or an emulator, these tests are often slower to
    execute. Unit tests are fast because they don’t have any such need for real devices
    or emulators in order to run. Since unit tests are faster and instrumentation
    tests are slower, it is often thought that a robust test suite should have these
    tests in the proportion of 80% to 20%. So your code base should consist of 80%
    unit tests and 20% instrumentation tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests involve, basically, *testing in units*. These tests are often faster
    to execute because they are executed in the JVM, and hence do not require the
    dexing, packaging, and installing-on-the-emulator steps, reducing test cycles
    from minutes to seconds so that you can quickly iterate and refactor your code.
    Integration tests, on the other hand, require all the aforementioned steps. Apart
    from testing your code, unit tests also work as a great documentation of the code
    base. That's why it shouldn't surprise you if you see the names of methods phrased
    in odd ways—for example, `testIfConfirmationEmailIsSent`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write unit tests for your Android code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll need Android Studio, as we will learn to write unit tests for Android
    code, and also because Android Studio provides great support for unit tests. You
    can also find the source code at [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    in the 4-unit-tests branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to understand how to write unit tests for Android code in
    the Kotlin language:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new Android project in Android Studio, Android Studio will
    provide support for both unit and Android tests. It provides you with separate
    directories where you can place your test. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfa262d7-f272-4c9f-b64b-e85ffe7ae866.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, test is where *unit tests* are placed and androidTest is where
    *Android tests* or *instrumentation tests* are placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two demo tests provided to you already: ExampleUnitTest and ExampleInstrumentedTest.
    To run them, just right-click on ExampleUnitTest and click on Run ExampleUnitTest.
    After running the tests, you can see the results of the tests in the console,
    as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/85dbdee5-2048-4da5-9d8b-84d8677c3d52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s try creating our own unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually have the `Utility` class in our code, which has methods that can
    be used by any class, so instead of defining those methods in every class, we
    define them in the `Utility` class. So let’s create a method, `addTwoNumbers`,
    which will take two parameters, `a` and `b`, and return a result—`a+b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Android Studio, you can create tests directly from the class itself. Just
    right-click on the class name and click on Create test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c9e10f0-d047-42be-a12a-4ecd57878b30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, you will be shown a dialog on which you can select all the methods
    for which you want to create a test. It is recommended that you have tests for
    every method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/18f873bc-d633-45c0-833e-dca9ff3e0950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on OK, you will be shown another dialog box that will ask you
    where to place your tests. In this case, this is a unit test, so we will place
    it in `app/src/test…`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/390fa1db-e2fc-434d-ad77-48d1afcead43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on OK, Android Studio autogenerates boilerplate code in `UtilityTest.kt`,
    which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90515872-8af2-4d12-957e-44ab5d7f1d91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will add a few `assertEquals` statements, which check the expected value
    against the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the expected value and the second argument is the output
    of the function. If you run the test, it will pass.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run the unit tests, they test all the methods that have the `@Test`
    notation above them. There is also a `@Before` notation, which is placed above
    a method. The method with the `@Before` notation is run before any other method
    of the class. This can be helpful when you are setting up objects and variables
    that might be used later.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note here is that unit tests cannot use Android SDK components.
    To use those components, you need instrumentation tests, or use a mocking framework
    like **Mockito**, which mocks the Android components so that it can be used unit
    tests. We will cover this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the previous recipe, we cannot use Android components in
    unit tests. This is why we are able to run them faster, and without any device.
    If you want to use Android components in your tests, there are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Write integration tests, which run on your device or emulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use a mocking framework, such as Mockito, which basically mocks the Android
    SDK components so that you can use them without any device or emulator, just like
    any other unit test. The benefit of a mocking framework is that it takes a lot
    less time to run the tests, as the tests are basically unit tests only. Here''s
    an accurate definition of a mock object by Vogella:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"A *mock object* is a dummy implementation for an interface or a class in which
    you define the output of certain method calls. Mock objects are configured to
    perform a certain behavior during a test. They typical record the interaction
    with the system and test can validate that."'
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's try using Mockito to write unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll need Android Studio, as it provides great support for unit tests, and
    we will also be learning to write the unit tests for Android code.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the source code at [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    in the 4-unit-tests branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add the Mockito dependency to your project. You can do so
    by adding the following line in your `build.gradle` file at the app level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added the dependency, you are good to go ahead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We usually use Mockito to mock Android classes, but let''s test a simple class
    using Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a small test that tests a `functionUnderTest` function of the `Utility`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class, we are calling the `functionUnderTest` method and then
    verifying whether the method has been called or not. (Yeah!, not a very good use
    case of a test, but let''s try to run this test) When you run it, you''ll see
    an error like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the preceding error is that every class is final by default
    in Kotlin. You need to *open* them if you want to extend or mock them. However,
    does that mean that you need to add open modifier to every class that you want
    to test? That sounds like a bad idea, and it is. There is a hack around this problem.
    The hack is to manually add the option of mocking the final class. You need to
    create a file in `test/resources/mockito-extensions folder called org.mockito.plugins.MockMaker`and
    put the following code into that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run the code, it will pass smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many variants of the `verify` method, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`verify(classUnderTest, never()).functionUnderTest()`, which tests whether
    it isn''t ever called'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeastOnce()`, `atLeast(2)`, `times(5)`, `atMost(3)`, which can also be used
    to verify the number of interactions with the method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see another Mockito test that mocks `SharedPreferences` (an Android
    component):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `when(...).thenReturn(...)` construct keeps an eye on the object, and when
    the method inside the `when` construct is called, it returns the value under the `thenReturn`
    construct. Note the [PRE7] surrounding `when`; this is because `when` is a reserved
    keyword in Kotlin, so we call it with back ticks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also return multiple values, which simulates calling a method multiple
    times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first call to the `getInt` method will return
    `1`, and the second call will return `2`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand a `spy` object in unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Spy object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mocking framework also provides a `spy` method that can be used to wrap
    the real objects. The calls to the spy objects are delegated to the real object.
    What''s the use of that, you might be thinking. It can check the interactions
    on a real object, which wasn''t possible if the object is not mocked. Let''s take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Note that calling `spy.get(0)` returns `-1`, which is equal to what you'd get
    if you had interacted with the real object. Furthermore, you are also able to
    verify the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mockito has certain limitations—for example, you cannot mock `static` and `private`
    methods. This is out of the scope of this book, so to know more about the Mockito
    limitations, visit [https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito](https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito).
  prefs: []
  type: TYPE_NORMAL
- en: Running instrumentation tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipes, we learned how to run and write unit tests. In this
    recipe, we will learn how to run instrumentation tests. The integration tests
    are placed under the androidTest directory in your Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since instrumentation tests require real devices or emulators to run on, ensure
    that you have one of either of these. We'll be using Android Studio 3.0 for our
    coding purposes. You can download the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `5-instrumentation-tests` branch. We will also be using *Espresso*
    for writing instrumentation tests as it is the easiest software to use. Espresso
    is automatically included in your project when you create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Espresso** is targeted at developers who believe that automated testing is
    an integral part of the development lifecycle. While it can be used for black-box
    testing, Espresso''s full power is unlocked by those who are familiar with the
    code base under test.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, you will learn how to run instrumentation tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple app, which will just have the Hello World! text and
    a button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/114c123e-0d88-4a8e-ab7b-b23e5068c5d2.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking the button, the text will change to Goodbye World!:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e55b5e1c-5aa0-45a6-82e8-555cae505e5e.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's write a test to verify this behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to run the espresso test; in the next recipe,
    we will learn how to write an espresso test, so just bear with me until I explain
    how to write an espresso test in the later recipe because it is complicated and
    needs an entire recipe to do justice to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an espresso test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the `testButtonBehaviour` method, we are checking whether Hello
    World! is appearing on screen. Then, we are performing a click operation on the
    button and finally checking whether Goodbye World! is appearing on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the preceding test, just right-click on the test class and select Run
    MainActivityTest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5eedabc6-eeea-4134-b0be-7296bdfb5797.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you select that option, you'll be shown a dialog box that will ask which
    device you want to run the test on. You can either choose a real device or an
    emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you can see your tests running on your device (you will see the
    steps written in the code being performed on the device).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run any instrumentation test, you'll note that it takes a lot of time
    to pass, even if it's a small test. In the current scenario, **test-driven development **(**TDD**)
    is becoming more and more popular, but its tests take a lot of time to execute;
    it's not a good way of using TDD. So the number of instrumentation tests should
    be kept to a minimum, and it's better to use a mocking framework, such as Mockito
    or Robolectric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia says that TDDis a software development process that relies on the
    repetition of a very short development cycle: Requirements are turned into very
    specific test cases, and then the software is improved to pass the new tests only.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing JUnit rules in Kotlin (@Rule)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules are a way to add functionalities that apply to all tests of the class.
    For example, `ExternalResource` executes the code before and after a test method.
    This can be used to set up a database, network, and filesystem connection before
    the test method, and can tear them down when the tests are complete. Of course,
    you can also do it using the `@Before` and `@After` annotations, but doing it
    with `ExternalResource` (as a JUnit rule) helps with code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3.0 for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be using `ExpectedException` as the JUnit rule because
    it helps the test declare that an exception is expected and also provides a way
    to clearly express the expected behavior. It is much more flexible than using
    the `@Test(expected= ...)` annotation because we can test specific error messages
    and custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to write JUnit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a simple method that throws an exception. We will then
    write a test to test this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a new rule of the `ExpectedException` class and write a
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will get an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The error is because JUnit allows the provision of rules through a test class
    field or a getter method. However, we don't have fields in Kotlin—we have properties;
    so what you've really annotated here is a property, not a field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The easiest way around this problem is by adding the `@JvmField` annotation
    with `@Rule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you run the test now, it will pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are aware of the fact that Kotlin plays with properties rather than fields
    in Java. However, to provide compatibility with the Java language, `@JvmField`
    can be used to instruct the Kotlin compiler not to generate getters–setters for
    this property and expose it as a field.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few restrictions when using annotations. We can''t use
    them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Private properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties with `open`, `override`, and `const` modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegated properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance tests using Espresso Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Espresso is the most popular UI testing framework for Android. It was released
    by Google in 2013 and is the easiest to use of its kind. It provides support for
    complex things, such as ensuring that an activity is run before the tests are
    run, or waiting till the observed background tasks are completed. These things
    were hard to synchronize prior to Espresso, and UI testing was considered a difficult
    thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use Espresso to perform acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance testing** is a level of software testing where a system is tested
    for acceptability. The purpose of this test is to evaluate the system''s compliance
    with the business requirements and assess whether it is acceptable for delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: Source: [http://softwaretestingfundamentals.com/](http://softwaretestingfundamentals.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using Android Studio 3.0 for our coding purposes. You can download
    the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the 5-instrumentation-tests branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Espresso, we mainly have three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewMatchers`: Allows you to find a view in the current view hierarchy. This
    can be done in various ways, such as searching by `id`, `name`, `child`, and so
    on. You can also use Hamcrest matchers, such as `containsString`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewActions`: Allows you to perform actions on the views, such as clicking,
    typing, clearing text, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewAssertions`: Allows you to assert the state of a view that checks whether
    the condition under the view assertion passes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to understand acceptance testing
    using Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a text matcher (a text matcher matches the text; it''s
    a part of `ViewMatchers`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create a simple test that will test whether clicking on the button
    changes the text from Hello World! to Goodbye World!:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4094ebc1-c715-467b-a742-8161a5712f4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an espresso test written to test the preceding functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we have created a rule that provides functional testing of
    a single activity. This will open the activity before the tests are run and close
    it once the tests are completed. The statements in the `testButtonBehaviour` method
    check the UI conditions, such as whether the text is initially Hello World! (first
    condition), then performs a click action on the button, and then finally checks
    whether the text is now Goodbye World!.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also get hold of the "God" object—that is, `Context`—using the instrumentation
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to start the activity from the intent, you just need to provide
    `false` as the third argument in the constructor of `ActivityTestRule`; it can
    be used as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another cool feature of Espresso is to record the interactions using **Record
    Espresso Test**. This records all the interactions that you make with the app,
    and can generate tests from it. To use that feature, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Run on the toolbar and select Record Espresso Test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a560a97-496a-457d-9b3d-578e7b0a74c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will then open a dialog, on which you can see the recorded steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15f66e1f-49b8-4dd4-b7cc-588b73ddf575.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on OK will automatically generate the tests based on your interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that we have used the `@JvmField` annotation with the rule. The reason
    for this is extensively discussed in the *How to write JUnit rules in Kotlin (@Rule)* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing assertEquals in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `assertEquals` statement is widely used for testing code. It basically takes
    in two arguments—an expected value and an actual value—with an optional third
    argument message. If the expected value matches the actual value, the `assertEquals`
    passes—otherwise, it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `assertEquals` with primitive types is straightforward, but if you want
    to use it with a custom object, you''ll have to do a little more work. For example,
    the following `assertEquals` will not pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will learn how to write `assertEquals` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using Android Studio 3.0 for our coding purposes. You can download
    the source code from [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `5-instrumentation-tests` branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps to understand `assertEquals`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, if you run the given `assertEquals`, it will not pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the difference, it will tell you that they aren''t equal because
    they are two different objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/febf47ed-5421-4289-a13a-ba0b6756b9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So we will need to override the `equals` method of the `MyObj` class, and we
    will check the following things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether the other object references the same object—this can be done using the
    `===` operator, which checks the referential equality
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the object in question equals the other object's Java class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether the content of both objects is the same:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run `assertEquals` with two objects of the same content, it will
    pass smoothly.
  prefs: []
  type: TYPE_NORMAL
