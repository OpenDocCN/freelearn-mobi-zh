- en: Overview of Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is the official Android programming language and is statically typed.
    It is fully interoperable with Java, meaning that any Kotlin user can use the
    Java framework and mix commands from both Kotlin and Java without any limitations.
    In this chapter, we will cover the basics of Kotlin and will look at how to set
    up the environment. We will also look at its flow structures, such as `if { ...
    } else { ... }` expressions and loops. In addition to this, we will look into
    object-oriented programming for Kotlin, and we will cover classes, interfaces,
    and objects. Functions will also be covered, along with parameters, constructors,
    and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null safety, reflection, and annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code in this chapter, you will just need Android Studio and Git installed.
    This chapter won't require any additional installations.
  prefs: []
  type: TYPE_NORMAL
- en: You can find examples from this chapter on GitHub, at the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 3.0 version of Android Studio was released by Google, and it promoted Kotlin
    as a first class language for Android development. Kotlin is developed by JetBrains
    in the same way as the Intellij IDEA platform, which is the basis of Android Studio.
    This language was released in February 2016, it was in development for five years
    before it was released. It''s easy to gradually convert the code base of a project
    from Java to Kotlin, and a developer that is familiar with Java can learn Kotlin
    in a few weeks. Kotlin became popular before its release, because this language
    is full of features and is designed to interoperate with Java. The following diagram
    shows how Kotlin and Java code are compiled to the same bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88d1e3c9-8429-433c-8b21-a7d3866c1895.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, part of our application can be written in Java and another part
    in Kotlin. The **kotlinc** compiler compiles Kotlin source code to the same bytecode
    as the **javac** compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with Android development, you will need to download and install
    the **Java Development Kit** (**JDK**) from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    You will also need to download and install the Android Studio **Integrated Development
    Environment** (**IDE**), from [https://developer.android.com/studio/](https://developer.android.com/studio/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new project, launch Android Studio and press **Start** **a new
    Android Studio project**. Then, you should type a project name and your unique
    application ID, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5d7680a-910b-439f-bf86-cf254b9c9294.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, the **Application name** field is filled according
    to the name of this book, and the **Company domain** field is  `packt.com`. Android
    Studio concatenates these two values and creates the **Package name** identifier
    that is equal to the application ID identifier. In our case, the application ID
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Studio is an official IDE for Android development, and it is based
    on the Intellij IDEA platform and uses the Gradle build tool system. A typical
    project structure looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d345d27-3148-48a1-9a2a-3011d474804b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `build.gradle` file contains the project configuration and manages the
    library dependencies. To add a dependency to the Spring for Android extension,
    we should add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Basic syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Syntax is a significant part of the programming language, defining a set of
    rules that must be applied to combinations of symbols. Otherwise, a program can't
    be compiled, and will be considered incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will describe the basic syntax of Kotlin, covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packaging is a mechanism that allows us to group classes, interfaces, and sub-packages.
    In our case, a declaration of a package in a file may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All citizens of the file belong to this package and must be located in the appropriate
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, we can define a read-only variable using the `val` keyword, and we
    can use the `var` keyword for mutable variables. In Kotlin, a **variable** can
    be defined as a first class citizen, meaning that we don't have to create a class
    of a function to hold variables. Instead, we can declare them directly in a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to define read-only and mutable variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a function, we have to use the `fun` keyword; this also can be declared
    as a first class citizen. This means that a function can only be defined in a
    file. We will touch on functions in greater detail in the *Functions* section,
    but for now, let''s look at a simple example that changes the value of the `mutable`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we can see that the `changeMutable` function can be declared as
    a first class citizen in the same file as the `mutable` variable, or in any other
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a class, we have to use the `class` keyword. All of the classes in
    Kotlin are final by default, and if we want to extend a class, we should declare
    it with the `open` keyword. A class that holds the `readOnly` and `mutable` variables,
    as well as the `changeMutable` method, may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that a function that is a class member is called a **method**.
    In this way, we can explicitly specify that a function belongs to a class.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** is a model of programming language that is
    based on objects that can represent data. Kotlin supports object-oriented programming
    in the same way that Java does, but even more strictly. This is because Kotlin
    doesn''t have primitive types and static members. Instead, it provides a `companion
    object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `companion object` is an object that is created once, during class initialization.
    In Kotlin, we can refer to members of `companion object` in the same way as `static`
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, under the hood, the nested `Companion` class is created, and we actually
    use an instance of this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, Kotlin supports the following concepts, which make the type system
    stronger:'
  prefs: []
  type: TYPE_NORMAL
- en: Nullable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only and mutable collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No raw type of collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last point means that we can''t compile code, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e33769-7b0e-486b-a7f5-93ef898c6c3c.png)'
  prefs: []
  type: TYPE_IMG
- en: This message means that we have to provide a generic to specify a certain type
    of this collection.
  prefs: []
  type: TYPE_NORMAL
- en: From the object-oriented programming viewpoint, Kotlin supports the same features
    as Java. These include encapsulation, inheritance, polymorphism, composition,
    and delegation. It even provides a language-level construction that helps to implement
    these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a function in Kotlin, you have to use the `fun` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet demonstrates that we can declare functions as first class
    citizens. We can also define functions as class members, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A `local` function is a function that is declared in another one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `local` function is declared inside of the `outer`
    function. The `local` functions are only available in the scope of a function
    where they were declared. This approach can be useful if we want to avoid duplicate
    code inside of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin particularly supports a functional style that allows us to operate functions
    in the same way as variables. This approach brings many features to Kotlin, as
    well as new ways to describe the flow of a program more concisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'This subsection will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative and imperative styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative and imperative styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used to use the imperative style of programming when writing object-oriented
    programming, but for functional programming, a more natural style is declarative.
    The declarative style assumes that our code describes what to do, instead of how
    to do it, as is usual with imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how functional programming can be useful
    in certain cases. Let''s imagine that we have a list of numbers, and we want to
    find the number that is greater than `4`. In the imperative style, this may look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have to use a lot of control flow statements to implement
    this simple logic. In the declarative style, it may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates the power of functional programming. This
    code looks concise and readable. The Kotlin standard library contains a lot of
    extension functions that extend the functionality of the list type.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The extension functions feature of Kotlin doesn't relate to functional programming,
    but it's better to explain this concept before moving forward. This feature allows
    us to extend a class or type with a new functionality, without using inheritance or
    any software design patterns, such as decorators.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, a decorator is a design pattern that allows
    us to add a behavior to an object dynamically, without affecting other objects
    from the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `extension` function is added to the functionality
    of the `A` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s easy to use this feature. We just need to specify a class
    name and declare a function name after the dot. Now, we can invoke the extension
    function as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Collections in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` function that we've seen is contained in the `Collections.kt` file
    from the Kotlin standard library. This file contains a lot of extension functions
    that bring a functional approach to Kotlin and extend the functionality of Java's
    collection, in order to simplify work with them.
  prefs: []
  type: TYPE_NORMAL
- en: A collections is a hierarchy of classes and interfaces that are used to store
    and manipulate a group of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common functions from the `Collections.kt` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter`: This returns a new list that contains elements that only matched
    a passed predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find`: This returns an element that matched a passed predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach`: This performs an approved action on each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: This returns a new list, where each element was transformed according
    to the passed function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are referred to as higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is called **higher-order** if it can take or return another function.
    The following diagrams show the different cases of higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first diagram demonstrates a case in which the `f` function takes the lambda
    and returns a simple object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bfacce2-1793-4da8-90da-cbe8a9c8940d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second diagram demonstrates a case in which the `f` function takes an object
    and returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7cab906-b4cd-4c48-af5d-ea50b8c3f209.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the third diagram demonstrates a case in which the `f` function takes
    and returns lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d5b3d03-2f47-4d57-88bd-034011937008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the implementation of the `firstOrNull` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `firstOrNull` function is an extension that takes a lambda as a parameter
    and invokes it as the usual function—`predicate(element)`. This returns the first
    element that matches the `predicate` in a collection; it is `null` if there is
    no other element that meets a condition.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lambda is a function that is not declared. This is useful when we need to
    invoke an action, but we don't need to define a function for it, because we will
    use it only once, or only in one scope. A lambda is an expression, meaning that
    it returns a value. All of the functions in Kotlin are expressions, and even a
    scope of a function doesn't contain the `return` keyword; it returns a value that
    is evaluated at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lambda expression returns an object of the `Unit` type, implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A declaration of the `Unit` object looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A reference to a lambda can be saved to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this variable to invoke the saved lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Control flow elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, control flow elements are expressions. This is different from Java,
    in which they are statements. Statements just specify the flow of a program, and
    don''t return any values. This section will cover the following control flow elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if { ... } else { ... }` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `when { ... }` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The if { ... } else { ... } expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, the `if` control flow element can be used in the same way as it
    is used in Java. The following example demonstrates the use of `if` as a usual
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using the `if { ... } else { ... }` control flow element as an expression,
    you have to declare the `else` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows that `if { ... } else { ... }` returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: The when { ... } expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switch { ... }` control flow element is replaced by `when { ... }`. The
    `when { ... }` element of Kotlin is much more flexible than the `switch { ...
    }` element in Java, because it can take a value of any type. A branch only has
    to contain a matched condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use `when { ... }` as a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet contains the `else` branch, which is optional for
    a case with a statement. The `else` branch is invoked if all other branches don''t
    have a matching condition. The `else` branch is mandatory if you use `when { ...
    }` as an expression and the compiler can''t be sure that all possible cases are
    covered. The following expression returns `Unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, expressions provide a much more concise way to write code. To
    be sure that your branches cover all of the possible cases, you can use enums
    or sealed classes.
  prefs: []
  type: TYPE_NORMAL
- en: An enum is a special kind of class that is used to define a set of constants.
    A sealed class is a parent class that has a restricted hierarchy of subclasses.
    All of the subclasses can only be defined in the same file as a sealed class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, enums work similarly to how they work in Java. Sealed classes can
    be used if we want to restrict a class hierarchy. This works in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: You should declare a class using the `sealed` keyword
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All inheritors of your sealed class must be declared in the same file as their
    parent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how this can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `when { ... }` expression, we can use classes of the `Method` type,
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using this approach, we don't have to use the `else` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A loop is a special statement that allows us to execute code repeatedly. Kotlin
    supports two types of loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `for` loop statement allows us to iterate anything that contains the `iterate()`
    method. In turn, this provides an instance that matches the iterator interface
    through the principle of duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: The duck typing principle means that an interface is implemented implicitly
    if all of the methods that it contains are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Iterator` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to provide the `iterator()`, `hasNext()`, and `next()` methods as
    class members, we have to declare them with the `operator` keyword. The following
    example demonstrates a case of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Numbers` class can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation using extension functions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, extension functions allow us to make preexisting classes iterable.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `while() { ... }` and `do { ... } while()` statements work in the same
    way that they work in Java. The `while` statement takes a condition, and `do`
    specifies a block of code that should be invoked while the condition is `true`.
    The following example demonstrates how `do { ... } while()` looks in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `do { ... } while` construction works in the same way that
    it does in other C-like languages.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports the concept of ranges, which represent sequences of comparable
    types. To create a range, we can use the `rangeTo` methods that are implemented
    in classes, such as `Int`, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have two options for creating a range, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `rangeTo` method. This may look as follows—`1.rangeTo(100)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `..` operator. This may look as follows—`1..100`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ranges are extremely useful when we work with loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `0..100` range is equal to the  `1 <= i && i <= 100` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to exclude the last value, you can use the `until` function, in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `step` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet represents a range like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth mentioning that ranges support a lot of `until` functions, such
    as `filter` or `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: String templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin supports one more powerful feature—string templates. Strings can contain
    code expressions that can be executed, and their results concatenated to the string.
    The syntax of the string template assumes that we use the `$` symbol at the start
    of an expression. If the expression contains some evaluation, it has to be surrounded
    by curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use of string templates looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A more advanced example that contains an expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the string templates feature allows us to write code in a more
    concise way than the usual concatenation or the `StringBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: Null safety, reflection, and annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have already covered the most common topics that relate to a basic
    overview of Kotlin, there are a few more topics that have to be touched upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will introduce the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports a more strict type system when compared to Java, and divides
    all types into two groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Nullable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No-nullable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most popular causes of an app crashing is the `NullPointerException`.
    This happens as a result of accessing a member of a `null` reference. Kotlin provides
    a mechanism that helps us to avoid this error by using a type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what the class hierarchy looks like in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e15195cc-ae8a-43cc-acca-9fd4de20fa01.png)'
  prefs: []
  type: TYPE_IMG
- en: In Kotlin, nullable types have the same names as no-nullable types, except with
    the `?` character at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use a no-nullable variable, we can''t assign `null` to it, and the following
    code can''t be compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to compile this code, we have to explicitly declare the `name` variable
    as nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, we cannot compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To access members of nullable types, we have to use the `?.` operator, like
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'One expression can contain the `?.` operator as many times as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If a member in this chain is `null`, the next member can't be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide an alternative program flow, if `null` is encountered, we can use
    the Elvis operator (`?:`). This can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates that the Elvis operator can be used if we
    want invoke a block of code if an expression returns as `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection allows us to introspect code at runtime; this is implemented by a
    set of languages and standard library features. The Kotlin standard library contains
    the `kotlin.reflect` package that, in turn, contains classes that represent references
    to elements, such as classes, functions, or properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a reference to an element, we should use the `::` operator. The following
    example demonstrates how to obtain a reference to a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, references to classes are represented by the `KClass` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'References to functions can also be passed to high-order functions. The following
    example shows how this may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A reference to a property is represented by the `KProperty` class, and this
    can be obtained in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`KProperty` is a class that represents a property of a class, and it can be
    used to retrieve metadata, such as names or types.'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Annotations are used to attach metadata to code. This is created using the
    `annotation` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the most common cases, annotations are used by annotation processing tools
    to generate or modify code. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kotlin bytecode viewer shows the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Example1` class contains the nested `Companion` class
    that contains the `companionClassMember` method. We can mark the `companionClassMember`
    method when the `@JvmStatic` annotation and the decompiled code to Java code version
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet contains the additional static `companionClassMember` function
    in the `Example1` class that invokes the method of the `Companion` class. Using
    the `@JvmStatic` annotation, we tell the compiler to generate an additional method
    that can be used from the Java side.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a close look at the basic syntax of Kotlin. We also
    introduced and looked at examples of some features, such as lambdas, string templates,
    and ranges. Furthermore, you learned that control flow elements, such as `if {
    ... } else { ... }` and `when { ... }`, can be used as expressions that can make
    our code more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at an overview of the Spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kotlin support object-oriented programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kotlin support functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define variables in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define functions in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Kotlin Quick Start Guide* ([https://www.packtpub.com/application-development/kotlin-quick-start-guide](https://www.packtpub.com/application-development/kotlin-quick-start-guide)) by
    Marko Devcic, published by Packt.'
  prefs: []
  type: TYPE_NORMAL
