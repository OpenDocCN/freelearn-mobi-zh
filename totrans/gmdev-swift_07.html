<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Implementing Collision Events</h1></div></div></div><p>So far, we have let the SpriteKit physics simulation detect and handle collisions between game objects. You have seen that Pierre Penguin sends enemies and coins flying off into space when he flies <a id="id240" class="indexterm"/>into them. This is because the physics simulation automatically monitors collisions and sets the post-collision trajectory and velocity of each colliding body. In this chapter, we will add our own game logic when two objects come into contact: taking damage from enemies, granting the player invulnerability after touching the star, and tracking points as the player collects coins. The game will become more fun to play as the game mechanics come to life.</p><p>The topics in this chapter include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learning the SpriteKit collision vocabulary</li><li class="listitem" style="list-style-type: disc">Adding contact events to our game</li><li class="listitem" style="list-style-type: disc">Player health and damage</li><li class="listitem" style="list-style-type: disc">Collecting coins</li><li class="listitem" style="list-style-type: disc">The power-up star logic</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Learning the SpriteKit collision vocabulary</h1></div></div></div><p>SpriteKit <a id="id241" class="indexterm"/>uses some unique concepts and terms to describe physics events. If you familiarize yourself with these terms now, it will be easier to understand the implementation steps later in the chapter.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Collision versus contact</h2></div></div></div><p>There are two types <a id="id242" class="indexterm"/>of interactions when physics bodies come together in the same space:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <strong>collision</strong> is the <a id="id243" class="indexterm"/>physics simulation's mathematical analysis and repositioning of bodies after they touch. Collisions include all the automatic physical interactions between bodies: preventing overlap, bouncing apart, spinning through the air, and transferring momentum. By default, physics bodies collide with every other physics body in the scene; we have witnessed this automatic collision behavior in our game so far.</li><li class="listitem" style="list-style-type: disc">A <strong>contact</strong> event<a id="id244" class="indexterm"/> also occurs when two bodies touch. Contact events allow us to wire in our custom game logic when two bodies come into contact. Contact events do not create any change on their own; they only provide us with the chance to execute our own code. For instance, we will use contact events to assign damage to the player when he or she runs into an enemy. There are no<a id="id245" class="indexterm"/> contact events by default; we will manually configure contacts in this chapter.</li></ul></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Physics bodies collide with every other body in the scene by default, but you can configure specific bodies to ignore collisions and pass through each other without any physical reaction.</p><p>Additionally, collisions and contacts are independent; you can disable physical collision between two types of bodies and still fire custom code with a contact event when the bodies pass through each other.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Physics category masks</h2></div></div></div><p>You can<a id="id246" class="indexterm"/> assign physics categories to each physics body in your game. These categories allow you to specify the bodies that should collide, the bodies that should contact, and the bodies that should pass through each other without any event. When two bodies try to share the same space, the physics simulation will compare each body's categories and test if collision or contact events should fire.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Our game will include physics categories for the penguin, the ground, the coins, and the enemies.</p></div></div><p>Physics categories are stored as 32-bit masks, which allow the physics simulation to perform these tests with processor-efficient bitwise operations. It is not strictly necessary to understand bitwise operations to use physics categories, but it is a nice topic for further reading, if you are interested in enhancing your knowledge. If you are interested, try an Internet search for <code class="literal">swift bitwise operations</code>.</p><p>Each physics body has three properties which you can use to control collisions in your game. Let's begin with a very simple summary of each property, and then explore them in depth:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">categoryBitMask</code>: The physics body's physical categories</li><li class="listitem" style="list-style-type: disc"><code class="literal">collisionBitMask</code>: Collide with these physical categories</li><li class="listitem" style="list-style-type: disc"><code class="literal">contactTestBitMask</code>: Contact with these physical categories</li></ul></div><p>The <code class="literal">categoryBitMask</code> property<a id="id247" class="indexterm"/> stores the body's current physics categories. The default value is <code class="literal">0xFFFFFFFF</code>, equating to every category. This means that, by default, every physics body belongs to every physics category.</p><p>The <a id="id248" class="indexterm"/>
<code class="literal">collisionBitMask</code> property<a id="id249" class="indexterm"/> specifies the physical categories the body should collide with, preventing two bodies from sharing the same space. The starting value is <code class="literal">0xFFFFFFFF</code>, or all bits set, meaning that the body will collide with every category by default. When one body begins to overlap with another, the physics simulation compares each body's <code class="literal">collisionBitMask</code> against the other body's <code class="literal">categoryBitMask</code>. If there is a match, a collision takes place. Note that this test works two ways; each body can independently participate or ignore a collision.</p><p>The <a id="id250" class="indexterm"/>
<code class="literal">contactTestBitMask</code> property works just like the collision property, but specifies categories for contact events, instead of collisions. The default value is <code class="literal">0x00000000</code>, or no bits set, meaning that the body will not contact with anything by default.</p><p>This is a dense subject. It is ok to move forward if you do not yet fully understand this topic. Implementing category masks into our game will help you learn.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>Using category masks in Swift</h2></div></div></div><p>Apple's Adventure <a id="id251" class="indexterm"/>game demo provides a good implementation of bitmasks in Swift. We will follow their example and use an <code class="literal">enum</code> to store our categories as <code class="literal">UInt32</code> values, writing these bitmasks in an easy-to-read manner. The following is an example of a physics category <code class="literal">enum</code> for a theoretical war game:</p><div><pre class="programlisting">enum PhysicsCategory:UInt32 {
    case playerTank = 1
    case enemyTanks = 2
    case missiles = 4
    case bullets = 8
    case buildings = 16
}</pre></div><p>It is very important to double the value for each subsequent group; this is a necessary step to create proper bitmasks for the physics simulation. For example, if we were to add <code class="literal">fighterJets</code>, the value would need to be <code class="literal">32</code>. Always remember to double subsequent values to create unique bitmasks that perform as expected in the physics tests.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Bitmasks are binary values that the CPU can very quickly compare to check for a match. You do not need to understand bitwise operators to complete this material, but if you are already familiar and curious, this doubling method works because <code class="literal">2</code> is equivalent to <code class="literal">1 &lt;&lt; 1 </code>(binary: <code class="literal">10</code>), <code class="literal">4</code> is equivalent to <code class="literal">1 &lt;&lt; 2</code> (binary: <code class="literal">100</code>), <code class="literal">8</code> is equivalent to <code class="literal">1 &lt;&lt; 3</code> (binary: <code class="literal">1000</code>), and so on. We opt for the manual doubling since <code class="literal">enum</code> values must be literals, and these values are easier for humans to read.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Adding contact events to our game</h1></div></div></div><p>Now that<a id="id252" class="indexterm"/> you are familiar with SpriteKit's physics concepts, we can head into Xcode to implement physics categories and contact logic for our penguin game. We will start by adding in our physics categories.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>Setting up the physics categories</h2></div></div></div><p>To create our <a id="id253" class="indexterm"/>physics categories, open your <code class="literal">GameScene.swift</code> file and enter the following code at the bottom, completely outside the <code class="literal">GameScene</code> class:</p><div><pre class="programlisting">enum PhysicsCategory:UInt32 {
    case penguin = 1
    case damagedPenguin = 2
    case ground = 4
    case enemy = 8
    case coin = 16
    case powerup = 32
}</pre></div><p>Notice how we double each succeeding value, as in our previous example. We are also creating an extra category for our penguin to use after he takes damage. We will use the <code class="literal">damagedPenguin</code> physics category to allow the penguin to pass through enemies for a few seconds after taking damage.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>Assigning categories to game objects</h2></div></div></div><p>Now <a id="id254" class="indexterm"/>that we have the physics categories, we need to go back through our existing game objects and assign the categories to the physics bodies. We will start with the <code class="literal">Player</code> class.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec22"/>The player</h3></div></div></div><p>Open <code class="literal">Player.swift</code> and <a id="id255" class="indexterm"/>add the following code at the bottom of the spawn function:</p><div><pre class="programlisting">self.physicsBody?.categoryBitMask =
    PhysicsCategory.penguin.rawValue
self.physicsBody?.contactTestBitMask =
    PhysicsCategory.enemy.rawValue |
    PhysicsCategory.ground.rawValue |
    PhysicsCategory.powerup.rawValue |
    PhysicsCategory.coin.rawValue</pre></div><p>We assigned the penguin physics category to the <code class="literal">Player</code> physics body, and used the <code class="literal">contactTestBitMask</code> property to set up contact tests with enemies, the ground, power-ups, and coins.</p><p>Also, notice how we use the <code class="literal">rawValue</code> property of our <code class="literal">enum</code> values. You will need to use the <code class="literal">rawValue</code> property whenever you are using the physics category bitmasks.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec23"/>The ground</h3></div></div></div><p>Next, let's<a id="id256" class="indexterm"/> assign the physics category for the <code class="literal">Ground</code> class. Open <code class="literal">Ground.swift</code>, and add the following code at the bottom of the <code class="literal">spawn</code> function:</p><div><pre class="programlisting">self.physicsBody?.categoryBitMask =
    PhysicsCategory.ground.rawValue</pre></div><p>All we need to do is assign the ground bitmask to the <code class="literal">Ground</code> class physics body, since it already collides with everything by default.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec24"/>The star power-up</h3></div></div></div><p>Open <code class="literal">Star.swift</code> and add <a id="id257" class="indexterm"/>the following code at the bottom of the <code class="literal">spawn</code> function:</p><div><pre class="programlisting">self.physicsBody?.categoryBitMask =
    PhysicsCategory.powerup.rawValue</pre></div><p>This assigns the power-up physics category to the <code class="literal">Star</code> class.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Enemies</h3></div></div></div><p>Perform <a id="id258" class="indexterm"/>this same action in <code class="literal">Bat.swift</code>, <code class="literal">Bee.swift</code>, <code class="literal">Blade.swift</code>, <code class="literal">Ghost.swift</code>, and <code class="literal">MadFly.swift</code>. Add the following code inside their <code class="literal">spawn</code> functions:</p><div><pre class="programlisting">self.physicsBody?.categoryBitMask = PhysicsCategory.enemy.rawValue
self.physicsBody?.collisionBitMask =
    ~PhysicsCategory.damagedPenguin.rawValue</pre></div><p>We use the bitwise <code class="literal">NOT</code> operator (<code class="literal">~</code>) to remove the <code class="literal">damagedPenguin</code> physics category from collisions <a id="id259" class="indexterm"/>with enemies. Enemies will collide with all categories except the <code class="literal">damagedPenguin</code> physics category. This allows us to change the penguin's category to the <code class="literal">damagedPenguin</code> value when we want the penguin to ignore enemy collisions and pass straight through.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Coins</h3></div></div></div><p>Lastly, we will<a id="id260" class="indexterm"/> add the coin physics category. We do not want coins to collide with other game objects, but we still want to monitor for contact events. Open <code class="literal">Coin.swift</code> and add the following code at the bottom of the <code class="literal">spawn</code> function:</p><div><pre class="programlisting">self.physicsBody?.categoryBitMask = PhysicsCategory.coin.rawValue
self.physicsBody?.collisionBitMask = 0</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec77"/>Preparing GameScene for contact events</h2></div></div></div><p>Now that we <a id="id261" class="indexterm"/>have assigned the physics categories to our game objects, we <a id="id262" class="indexterm"/>can monitor for contact events in the <code class="literal">GameScene</code> class. Follow these steps to wire up the <code class="literal">GameScene</code> class:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to tell the <code class="literal">GameScene</code> class to implement the <code class="literal">SKPhysicsContactDelegate</code> protocol. SpriteKit can then inform the <code class="literal">GameScene</code> class when contact events occur. Change the <code class="literal">GameScene</code> class declaration line to look like this:<div><pre class="programlisting">class GameScene: SKScene<strong>, SKPhysicsContactDelegate</strong> {</pre></div></li><li class="listitem">We will tell SpriteKit to inform <code class="literal">GameScene</code> of contact events by setting the <code class="literal">GameScene physicsWorld contactDelegate</code> property to the <code class="literal">GameScene</code> class. At the bottom of the <code class="literal">GameScene didMoveToView</code> function, add this line:<div><pre class="programlisting">self.physicsWorld.contactDelegate = self</pre></div></li><li class="listitem"><code class="literal">SKPhysicsContactDelegate</code> defines a <code class="literal">didBeginContact</code> function that will fire when contact occurs. We can now implement this <code class="literal">didBeginContact</code> function in the <code class="literal">GameScene</code> class. Create a new function in the <code class="literal">GameScene</code> class named <code class="literal">didBeginContact</code>, as shown in the following code:<div><pre class="programlisting">func didBeginContact(contact: SKPhysicsContact) {
    // Each contact has two bodies; we do not know which is which.
    // We will find the penguin body, then use
    // the other body to determine the type of contact.
    let otherBody:SKPhysicsBody
    // Combine the two penguin physics categories into one
    // bitmask using the bitwise OR operator |
    let penguinMask = PhysicsCategory.penguin.rawValue |
        PhysicsCategory.damagedPenguin.rawValue
    // Use the bitwise AND operator &amp; to find the penguin.
    // This returns a positive number if body A's category
    // is the same as either the penguin or damagedPenguin:
    if (contact.bodyA.categoryBitMask &amp; penguinMask) &gt; 0 {
        // bodyA is the penguin, we will test bodyB: 
        otherBody = contact.bodyB
    }
    else {
        // bodyB is the penguin, we will test bodyA:
        otherBody = contact.bodyA
    }
    // Find the type of contact:
    switch otherBody.categoryBitMask {
    case PhysicsCategory.ground.rawValue:
        println("hit the ground")
    case PhysicsCategory.enemy.rawValue:
        println("take damage")
    case PhysicsCategory.coin.rawValue:
        println("collect a coin")
    case PhysicsCategory.powerup.rawValue:
        println("start the power-up")
    default:
        println("Contact with no game logic")
    }
}</pre></div></li></ol></div><p>This<a id="id263" class="indexterm"/> function will <a id="id264" class="indexterm"/>serve as a central hub for our contact events. We will print to the console when our various contact events occur, to test that our code is working.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Viewing console output</h3></div></div></div><p>You can use<a id="id265" class="indexterm"/> the <code class="literal">println</code> function to write information to the console, which is very useful for debugging. If you have not yet used the console in Xcode, follow these simple steps to view it:</p><div><ol class="orderedlist arabic"><li class="listitem">In <a id="id266" class="indexterm"/>the upper right-hand corner of Xcode, make sure the debug area is turned on, as shown in this screenshot:<div><img src="img/Image_B04532_07_01.jpg" alt="Viewing console output"/></div></li><li class="listitem">In the bottom right-hand corner of Xcode, make sure the console is turned on, as shown in this screenshot:<div><img src="img/Image_B04532_07_02.jpg" alt="Viewing console output"/></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec28"/>Testing our contact code</h3></div></div></div><p>Now that you <a id="id267" class="indexterm"/>can see your console output, run the project. You should see our <code class="literal">println</code> strings appear in the console as you fly Pierre into various game objects. Your console should look something like this:</p><div><img src="img/Image_B04532_07_03.jpg" alt="Testing our contact code"/></div><p>Congratulations – if you see the contact output in the console, you have completed the structure for our contact system.</p><p>You may notice<a id="id268" class="indexterm"/> that flying into coins produces strange collision behavior, which we will enhance later in the chapter. Next, we will add game logic for each type of contact.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Checkpoint 7-A</h1></div></div></div><p>To download my project to this point, visit this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-7">http://www.thinkingswiftly.com/game-development-with-swift/chapter-7</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Player health and damage</h1></div></div></div><p>The first custom contact logic is <a id="id269" class="indexterm"/>player damage. We will assign the player health points and take them away when damaged. The game will end when the player runs out of health. This<a id="id270" class="indexterm"/> is one of the core mechanics of our gameplay. Follow<a id="id271" class="indexterm"/> these steps to implement the health logic:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">Player.swift</code> file, add six new properties to the <code class="literal">Player</code> class:<div><pre class="programlisting">// The player will be able to take 3 hits before game over:
var health:Int = 3
// Keep track of when the player is invulnerable:
var invulnerable = false
// Keep track of when the player is newly damaged:
var damaged = false
// We will create animations to run when the player takes
// damage or dies. Add these properties to store them:
var damageAnimation = SKAction()
var dieAnimation = SKAction()
// We want to stop forward velocity if the player dies,
// so we will now store forward velocity as a property:
var forwardVelocity:CGFloat = 200</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> function, change the code that moves the player through the world to use the new <code class="literal">forwardVelocity</code> property:<div><pre class="programlisting">// Set a constant velocity to the right:
self.physicsBody?.velocity.dx = <strong>self.forwardVelocity</strong>
</pre></div></li><li class="listitem">At the very beginning of the <code class="literal">startFlapping</code> function, add this line to prevent the player from flying higher when dead:<div><pre class="programlisting">if self.health &lt;= 0 { return }</pre></div></li><li class="listitem">Add the <a id="id272" class="indexterm"/>same line at the very beginning of the <code class="literal">stopFlapping</code> function to prevent the soar animation from running after death:<div><pre class="programlisting">if self.health &lt;= 0 { return }</pre></div></li><li class="listitem">Add a new function named <code class="literal">die</code> to the <code class="literal">Player</code> class:<div><pre class="programlisting">func die() {
    // Make sure the player is fully visible:
    self.alpha = 1
    // Remove all animations:
    self.removeAllActions()
    // Run the die animation:
    self.runAction(self.dieAnimation)
    // Prevent any further upward movement:
    self.flapping = false
    // Stop forward movement:
    self.forwardVelocity = 0
}</pre></div></li><li class="listitem">Add a new function named <code class="literal">takeDamage</code> to the <code class="literal">Player</code> class:<div><pre class="programlisting">func takeDamage() {
    // If invulnerable or damaged, return:
    if self.invulnerable || self.damaged { return }

    // Remove one from our health pool
    self.health--
    if self.health == 0 {
        // If we are out of health, run the die function:
        die()
    }
    else {
        // Run the take damage animation:
        self.runAction(self.damageAnimation)
    }
}</pre></div></li><li class="listitem">Open the <code class="literal">GameScene.swift</code> file. Inside the <code class="literal">didBeginContact</code> function, update the switch case that fires when contact is made with an enemy:<div><pre class="programlisting">case PhysicsCategory.enemy.rawValue:
    println("take damage")
<strong>    player.takeDamage()</strong>
</pre></div></li><li class="listitem">We will also take damage when we hit the ground. Update the ground case in the same way:<div><pre class="programlisting">case PhysicsCategory.ground.rawValue:
    println("hit the ground")
<strong>    player.takeDamage()</strong>
</pre></div></li></ol></div><p>Good work – let's test<a id="id273" class="indexterm"/> our code to make sure everything is working correctly. Run the project and smash into some enemies. You can watch the printed output in the console to make sure everything is working correctly. After taking damage three times, the penguin should drop to the ground and become unresponsive.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>You may notice that there is no way for the player to tell how many health points he or she has remaining as they play the game. We will add a health meter to the scene in the next chapter.</p></div></div><p>Next, we will enhance the feel of the game with new animations when the player takes damage and when the game ends.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec78"/>Animations for damage and game over</h2></div></div></div><p>We will use <code class="literal">SKAction</code> sequences to create fun animations when the player takes damage. By combining actions, we will grant temporary safety in a damaged state after the player hits an enemy. We will show a fade animation that slowly pulses at first and then speeds up as the safe state starts to wear off.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec29"/>The damage animation</h3></div></div></div><p>To add the new<a id="id274" class="indexterm"/> animation, add this code at the bottom of the <code class="literal">Player</code> class <code class="literal">createAnimations</code> function:</p><div><pre class="programlisting">// --- Create the taking damage animation ---
let damageStart = SKAction.runBlock {
    // Allow the penguin to pass through enemies:
    self.physicsBody?.categoryBitMask =
        PhysicsCategory.damagedPenguin.rawValue
    // Use the bitwise NOT operator ~ to remove
    // enemies from the collision test:
    self.physicsBody?.collisionBitMask =
        ~PhysicsCategory.enemy.rawValue
}
// Create an opacity pulse, slow at first and fast at the end:
let slowFade = SKAction.sequence([
    SKAction.fadeAlphaTo(0.3, duration: 0.35),
    SKAction.fadeAlphaTo(0.7, duration: 0.35)
    ])
let fastFade = SKAction.sequence([
    SKAction.fadeAlphaTo(0.3, duration: 0.2),
    SKAction.fadeAlphaTo(0.7, duration: 0.2)
    ])
let fadeOutAndIn = SKAction.sequence([
    SKAction.repeatAction(slowFade, count: 2),
    SKAction.repeatAction(fastFade, count: 5),
    SKAction.fadeAlphaTo(1, duration: 0.15)
    ])
// Return the penguin to normal:
let damageEnd = SKAction.runBlock {
    self.physicsBody?.categoryBitMask =
        PhysicsCategory.penguin.rawValue
    // Collide with everything again:
    self.physicsBody?.collisionBitMask = 0xFFFFFFFF
    // Turn off the newly damaged flag:
    self.damaged = false
}
// Store the whole sequence in the damageAnimation property:
self.damageAnimation = SKAction.sequence([
    damageStart,
    fadeOutAndIn,
    damageEnd
    ])</pre></div><p>Next, update<a id="id275" class="indexterm"/> the <code class="literal">takeDamage</code> function to flag the player as damaged, immediately after taking a hit. The damage animation you just created will turn the damaged flag back off once it has completed. After this change, the first four lines of the <code class="literal">takeDamage</code> function should look like this (the new code is written in bold):</p><div><pre class="programlisting">// If invulnerable or damaged, return out of the function:
if self.invulnerable || self.damaged { return }
<strong>// Set the damaged state to true after being hit:</strong>
<strong>self.damaged = true</strong>
</pre></div><p>Run the project. Directly after taking damage, your penguin should fade and be able to pass through enemies, as shown in this image:</p><div><img src="img/Image_B04532_07_04.jpg" alt="The damage animation"/></div><p>We are starting<a id="id276" class="indexterm"/> to see some good results from our hard work. Notice how the penguin can pass through enemies but still collides with coins, the star, and the ground while in the invulnerable state. Next, we will add a game over animation.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec30"/>The game over animation</h3></div></div></div><p>We<a id="id277" class="indexterm"/> will create a funny, over-the-top death animation when the penguin runs out of health. When Pierre loses his last hit point, he will hang in the air, scale larger, flip over on to his back, and then finally fall to the ground. To implement this animation, add the following code at the bottom of the <code class="literal">Player</code> class <code class="literal">createAnimations</code> function:</p><div><pre class="programlisting">/* --- Create the death animation --- */
let startDie = SKAction.runBlock {
    // Switch to the death texture with X eyes:
    self.texture =
        self.textureAtlas.textureNamed("pierre-dead.png")
    // Suspend the penguin in space:
    self.physicsBody?.affectedByGravity = false
    // Stop any movement:
    self.physicsBody?.velocity = CGVector(dx: 0, dy: 0)
    // Make the penguin pass through everything except the ground:
    self.physicsBody?.collisionBitMask =
        PhysicsCategory.ground.rawValue
}

let endDie = SKAction.runBlock {
    // Turn gravity back on:
    self.physicsBody?.affectedByGravity = true
}

self.dieAnimation = SKAction.sequence([
    startDie,
    // Scale the penguin bigger:
    SKAction.scaleTo(1.3, duration: 0.5),
    // Use the waitForDuration action to provide a short pause:
    SKAction.waitForDuration(0.5),
    // Rotate the penguin on to his back:
    SKAction.rotateToAngle(3, duration: 1.5),
    SKAction.waitForDuration(0.5),
    endDie
])</pre></div><p>Run the <a id="id278" class="indexterm"/>project and bump into three enemies. You will see the comedic death animation play, as shown in this screenshot:</p><div><img src="img/Image_B04532_07_05.jpg" alt="The game over animation"/></div><p>Poor Pierre Penguin! Good job implementing the damage and death animations. Next, we will handle coin collection on the coin contact event.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Collecting coins</h1></div></div></div><p>As a main goal for <a id="id279" class="indexterm"/>the player, collecting coins should be one of the most enjoyable aspects of our game. We will create a rewarding animation when the player contacts a coin. Follow these steps to implement coin collection:</p><div><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">GameScene.swift</code>, add a new property to the <code class="literal">GameScene</code> class:<div><pre class="programlisting">var coinsCollected = 0</pre></div></li><li class="listitem">In <code class="literal">Coin.swift</code>, add a new function to the <code class="literal">Coin</code> class named <code class="literal">collect</code>:<div><pre class="programlisting">func collect() {
    // Prevent further contact:
    self.physicsBody?.categoryBitMask = 0
    // Fade out, move up, and scale up the coin:
    let collectAnimation = SKAction.group([
        SKAction.fadeAlphaTo(0, duration: 0.2),
        SKAction.scaleTo(1.5, duration: 0.2),
        SKAction.moveBy(CGVector(dx: 0, dy: 25), duration: 0.2)
    ])
    // After fading it out, move the coin out of the way
    // and reset it to initial values until the encounter
    // system re-uses it:
    let resetAfterCollected = SKAction.runBlock {
        self.position.y = 5000
        self.alpha = 1
        self.xScale = 1
        self.yScale = 1
        self.physicsBody?.categoryBitMask =
            PhysicsCategory.coin.rawValue
    }
    // Combine the actions into a sequence:
    let collectSequence = SKAction.sequence([
        collectAnimation,
        resetAfterCollected
    ])
    // Run the collect animation:
    self.runAction(collectSequence)
}</pre></div></li><li class="listitem">In <code class="literal">GameScene.swift</code>, call the new <code class="literal">collect</code> function from the coin contact case in the <code class="literal">didBeginContact</code> function:<div><pre class="programlisting">case PhysicsCategory.coin.rawValue:
    // Try to cast the otherBody's node as a Coin:
    if let coin = otherBody.node as? Coin {
        // Invoke the collect animation:
        coin.collect()
        // Add the value of the coin to our counter:
        self.coinsCollected += coin.value
        println(self.coinsCollected)
    }</pre></div></li></ol></div><p>Great work! Run<a id="id280" class="indexterm"/> the project and try to collect some coins. You will see the coins perform their collection animation. The game will keep track of how many coins you are collecting and print the number to the console. The player cannot see that number yet; we will add a text counter on the game screen in the next chapter. Next, we will implement the power-up star game logic.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>The power-up star logic</h1></div></div></div><p>When the<a id="id281" class="indexterm"/> player contacts the star, we will grant invulnerability for a short time and give the player great speed to power through encounters. Follow these steps to implement the power-up:</p><div><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">Player.swift</code>, add a new function to the <code class="literal">Player</code> class, as shown here:<div><pre class="programlisting">func starPower() {
    // Remove any existing star power-up animation, if
    // the player is already under the power of star
    self.removeActionForKey("starPower")
    // Grant great forward speed:
    self.forwardVelocity = 400
    // Make the player invulnerable:
    self.invulnerable = true
    // Create a sequence to scale the player larger,
    // wait 8 seconds, then scale back down and turn off
    // invulnerability, returning the player to normal: 
    let starSequence = SKAction.sequence([
        SKAction.scaleTo(1.5, duration: 0.3),
        SKAction.waitForDuration(8),
        SKAction.scaleTo(1, duration: 1),
        SKAction.runBlock {
            self.forwardVelocity = 200
            self.invulnerable = false
        }
    ])
    // Execute the sequence:
    self.runAction(starSequence, withKey: "starPower")
}</pre></div></li><li class="listitem">Invoke the new function from the <code class="literal">GameScene</code> class <code class="literal">didBeginContact</code> function, under the power-up case:<div><pre class="programlisting">case PhysicsCategory.powerup.rawValue:
    player.starPower()</pre></div></li></ol></div><p>You may<a id="id282" class="indexterm"/> find it helpful to increase the spawn rate of the star power-up in order to test. Remember that we are generating a random number in the <code class="literal">didSimulatePhysics</code> function of <code class="literal">GameScene</code> to determine how often we spawn the star. To spawn the star more often, comment out the line that generates a random number and replace it with a hardcoded <code class="literal">0</code>, as shown here (the new code is written in bold):</p><div><pre class="programlisting">
<strong>//</strong>let starRoll = Int(arc4random_uniform(10))
<strong>let starRoll = 0</strong>
if starRoll == 0 {</pre></div><p>Great, now it will be easy to test the star power-up. Run the project and find a star. The penguin should scale to a large size and start charging forward, blowing enemies aside as he passes, as shown here:</p><div><img src="img/Image_B04532_07_06.jpg" alt="The power-up star logic"/></div><p>Remember to change the star-spawning code back to a random number before you continue, or<a id="id283" class="indexterm"/> the star will spawn too often.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Checkpoint 7-B</h1></div></div></div><p>We have made terrific progress in this chapter. To download my project up to this point, visit this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-7">http://www.thinkingswiftly.com/game-development-with-swift/chapter-7</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Summary</h1></div></div></div><p>Our penguin game is looking great! You have brought the core mechanics to life by implementing the sprite contact events. You learned how SpriteKit handles collisions and contacts, used bitmasks to assign collision categories to different types of sprites, wired up a contact system in our penguin game, and added custom game logic for taking damage, collecting coins, and gaining the star power-up.</p><p>We have a playable game at this point; the next step is adding polish, menus, and features to make the game stand out. We will make our game shine by adding a HUD, background images, particle emitters, and more in <a class="link" href="ch08.html" title="Chapter 8. Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and More">Chapter 8</a>, <em>Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and More</em>.</p></div></body></html>