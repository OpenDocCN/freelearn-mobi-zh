- en: Chapter 9. Postscreen Processing and Image Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章.后期处理和图像效果
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Detecting scene edges with the Sobel operator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sobel算子检测场景边缘
- en: Making the scene blur with the Gaussian blur equation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高斯模糊方程使场景模糊
- en: Making a scene glow real time with the bloom effect
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光晕效果实时使场景发光
- en: Painting the scene like a cartoon shading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将场景绘制成卡通着色效果
- en: Generating an embossed scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成浮雕场景
- en: Implementing grayscale and CMYK conversions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现灰度值和CMYK转换
- en: Implementing fisheye with barrel distortion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现带有桶形畸变的鱼眼效果
- en: Implementing the binocular view with procedural texturing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用程序纹理实现双目视图
- en: Twirling the image
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转图像
- en: Sphere illusion with textured quadrilateral
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理四边形实现球形幻觉
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will unfold the endless possibilities of a scene and its image-based
    effects, which are widely used in the field of data visualization and after effects.
    Practically, objects are represented as a set of vertices in the 3D space. As
    the number of vertices go higher, the time complexity of the scene increases.
    Moreover, representing the object in terms of an image has a time complexity proportional
    to the number of fragments in the scene. Additionally, many effects can only be
    efficiently possible in the image space rather than implementing in the vertex
    space, such as blurring, blooming, cloud rendering, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展开探讨场景及其基于图像的效果的无限可能性，这些效果在数据可视化和后期效果领域被广泛应用。实际上，物体在三维空间中表现为一组顶点。随着顶点数量的增加，场景的时间复杂度也随之增加。此外，以图像的形式表示物体，其时间复杂度与场景中片段的数量成正比。另外，许多效果只能在图像空间中高效实现，而不是在顶点空间中实现，例如模糊、光晕、云渲染等等。
- en: The term post screen processing is a texel manipulation technique applied on
    an OpenGL ES scene once it's rendered. To be more specific, the scene is first
    rendered to an offscreen surface where effects are applied. Then, this manipulated
    offscreen texture is rendered back to the screen surface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 后期屏幕处理是一个应用于OpenGL ES场景的texel操作技术，一旦场景渲染完成。更具体地说，场景首先渲染到一个离屏表面，然后应用效果。然后，这个经过处理的离屏纹理被渲染回屏幕表面。
- en: In post processing, the outcome of a given texel is affected by its surrounding
    texels. Such techniques cannot be applied on live scenes because the vertex and
    fragment shader works locally. This means a vertex shader is only aware of the
    current vertex and the fragment shader about the current fragment; they cannot
    use elements information of their neighbors. This limitation can be fixed easily
    by rendering the scene into a texture, which allows the fragment shader to read
    any texel information present in the texture. After the scene is rendered to a
    texture, the image/texture-based techniques are applied to the texture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在后期处理中，给定texel的结果会受到其周围texel的影响。这些技术不能应用于实时场景，因为顶点着色器和片段着色器是局部工作的。这意味着顶点着色器只知道当前顶点，片段着色器只知道当前片段；它们不能使用邻居元素的信息。这种限制可以通过将场景渲染到纹理中来轻松解决，这允许片段着色器读取纹理中存在的任何texel信息。在场景渲染到纹理后，对纹理应用基于图像的技术。
- en: The image-based effects are applied to an image texture using the fragment shader.
    During the post-processing implementation, the rendered scene goes through a number
    of passes, depending on the complexity of the effect. At each pass, it saves the
    processed output in a texture and then passes it on to next pass as an input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图像的效果是通过片段着色器应用于图像纹理的。在后期处理实现过程中，渲染的场景会经过多个阶段，具体取决于效果复杂度。在每个阶段，它将处理后的输出保存到纹理中，然后将其作为输入传递到下一个阶段。
- en: 'The post screen processing execution model for post processing can be majorly
    divided into four sections:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 后期处理的执行模型可以大致分为四个部分：
- en: '**Creation of the framebuffer**: The first stage requires creation of an offline
    texture to render the scene into it. This is achieved by creating the **Frame
    Buffer Objects** (FBO). Depending on the requirements of the scene, various textures
    or buffers, such as color, stencil, and depth are attached to the FBO.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建帧缓冲区**：第一阶段需要创建一个离线纹理，将场景渲染到其中。这是通过创建**帧缓冲区对象**（FBO）来实现的。根据场景的需求，将各种纹理或缓冲区，如颜色、模板和深度，附加到FBO上。'
- en: '**Render the scene to texture**: By default, the OpenGL ES scene renders to
    a default framebuffer. As a prerequisite of post processing, this rendering must
    be diverted to an offline texture (the FBO texture) by binding the FBO handle
    to the current rendering pipeline. This ensures that rendering must happen on
    the FBO texture rather than the default framebuffer.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将场景渲染到纹理**：默认情况下，OpenGL ES场景渲染到默认帧缓冲区。作为后期处理的前提条件，这种渲染必须通过将FBO句柄绑定到当前渲染管线来转移到离线纹理（FBO纹理）。这确保渲染必须发生在FBO纹理而不是默认帧缓冲区上。'
- en: '**Apply texture effects**: After the scene is rendered into the texture, it''s
    like an image in the memory where various image effects can be applied. Depending
    on the post processing complexities, you may require multiple passes to process
    the desired effect. In the multipass post processing, we may require two or more
    FBO''s in order to hold the intermediate processed result of the current pass
    in it and to be used in the next or later passes.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用纹理效果**：在场景渲染成纹理之后，它就像记忆中的图像，可以应用各种图像效果。根据后期处理的复杂程度，你可能需要多次遍历来处理所需的效果。在多遍历后期处理中，我们可能需要两个或更多个FBO来存储当前遍历的中间处理结果，并在后续或后续遍历中使用。'
- en: '**Render to the default framebuffer**: Finally, the post processed textured
    scene is rendered back to the default framebuffer, which becomes visible on the
    scene. The following figure shows an edge detection example, in which various
    stages of the post screen processing are illustrated:![Introduction](img/5527OT_09_01.jpg)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染到默认帧缓冲区**：最后，后期处理过的纹理场景被渲染回默认帧缓冲区，这使得场景变得可见。以下图示了一个边缘检测示例，其中展示了后期屏幕处理的各个阶段：![介绍](img/5527OT_09_01.jpg)'
- en: Detecting scene edges with the Sobel operator
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sobel算子检测场景边缘
- en: Edge detection is an image-processing technique used to detect boundaries in
    an image. It is widely used in the field of computer vision, data visualization,
    and surface topology. For example, the pencil sketch effect of an image is nothing,
    but an application of edge detection algorithm. This recipe will demonstrate the
    edge detection technique using the Sobel operator or filter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘检测是一种图像处理技术，用于检测图像中的边界。它在计算机视觉、数据可视化和表面拓扑学领域得到广泛应用。例如，图像的铅笔素描效果并非什么，而是一种边缘检测算法的应用。本配方将演示使用Sobel算子或滤波器进行边缘检测技术。
- en: A Sobel filter measures the change in the gradient of an image in which it recognizes
    the regions of an image where the frequency of the color transition is higher.
    These higher transition regions shows sharp changes in the gradient that eventually
    correspond to the edges. The Sobel operator uses convolution kernels to detect
    the edge portions in the image. A convolution kernel is a matrix that contains
    predefined weights that formulate the calculation of the current pixel based on
    the neighboring pixels intensity and weights contained in the convolution matrix
    itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel滤波器测量图像梯度的变化，它识别图像中颜色过渡频率较高的区域。这些高过渡区域显示了梯度中的尖锐变化，最终对应于边缘。Sobel算子使用卷积核来检测图像中的边缘部分。卷积核是一个矩阵，其中包含预定义的权重，这些权重基于卷积矩阵本身中的相邻像素强度和权重来计算当前像素。
- en: 'A Sobel filter uses two 3 x 3 convolution kernels for edge detection processing;
    one operates on the neighboring pixels in the horizontal direction to the current
    pixel. Similarly, the other operates on the vertical neighboring pixels. The following
    image shows two convolution kernels:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel滤波器使用两个3 x 3卷积核进行边缘检测处理；一个作用于当前像素水平方向的相邻像素。同样，另一个作用于垂直方向的相邻像素。以下图像显示了两个卷积核：
- en: '![Detecting scene edges with the Sobel operator](img/5527OT_09_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sobel算子检测场景边缘](img/5527OT_09_02.jpg)'
- en: 'Now, we know very well that the Sobel filter approximates the gradient of an
    image. Therefore, the RGB information of the image must be brought to some gradient
    form and the best way is to calculate the brightness or luminance of the image.
    An RGB color represents a 3D space of color in the R, G, and B direction. These
    colors must bring in 1D gradient space using the brightness information of the
    image. The brightness of an image is represented by gradient colors between white
    and black:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们非常清楚Sobel滤波器近似图像的梯度。因此，图像的RGB信息必须转换为某种梯度形式，最佳方式是计算图像的亮度或亮度。RGB颜色代表R、G、B方向上的3D颜色空间。这些颜色必须使用图像的亮度信息将其带入1D梯度空间。图像的亮度由白到黑的梯度颜色表示：
- en: '![Detecting scene edges with the Sobel operator](img/5527OT_09_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Post-processing techniques heavily rely on texturing basics and FBO. Therefore,
    as a prerequisite for this chapter, you must understand these concepts. We have
    covered these concepts very well in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Textures and Mapping Techniques*. For more information,
    refer to the *See also* subsection in this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The texture filtering technique must be `GL_NEAREST` to detect more edges and
    darker appearances. Unlike the `GL_LINEAR` filtering, which uses the weighted
    average of the four surrounding pixels closest to texture coordinates, the `GL_NEAREST`
    filtering uses the pixel color that is closest to texture coordinates, therefore
    resulting gradients with higher chances of sharp changes in frequency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following step-by-step guidelines to understand the programming
    procedure. Make sure that you refer to the *See also* section for dependencies
    before you read this section. This recipe reuses the FBO recipe from textures
    and renames the class from `DemoFBO` to `EdgeDetection`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, load the `SimpleTexture` and `ObjLoader` class. The former
    class renders the polka dot pattern mesh and the latter class is used to render
    the FBO texture.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this class, create two variables called `DefaultFBO` and `FboId` to hold
    the handles of the default framebuffer and FBO respectively. Create two more variables:
    `textureId` and `depthTextureId` to hold the handles of the color texture and
    the depth texture in the FBO.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the FBO in the `initModel()` with user-defined dimensions (width and
    height) as per the application requirement. This recipe uses the same dimension
    as the render buffer dimension. The framebuffer is created in the `GenerateFBO()`
    function, which creates a color buffer and a depth buffer to store the scene color
    and depth information:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Render the scene using the `RenderObj()` function. The scene is rendered to
    the perspective projection system using `SetUpPerspectiveProjection()`, which
    is called before `RenderObj()`. FBO must be bound before drawing a scene. This
    will render the color information of scenes to FBO's color texture and depth information
    to FBO's depth texture.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the model-view matrix and draw a scene. Make sure to restore the default
    framebuffer at last after the scene is rendered to the FBO:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we are good to go with edge detection with the help of the `SimpleTexture`
    class. This class will take the saved texture from the FBO and apply the edge
    detection shader to it. For more information on how the `SimpleTexture` class
    works, refer to the *Applying texture with the UV mapping* recipe in [Chapter
    7](ch07.html "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping
    Techniques*.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The FBO texture is rendered to a quad of size two. This quad fits to the complete
    viewport. This is why the orthographic projection system must also be defined
    with the same dimensions:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FBO 纹理被渲染到大小为二的四边形。这个四边形适合完整的视口。这就是为什么正交投影系统也必须定义相同的维度：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `EdgeDetect()` function applies the Sobel filter using the `SimpleTexture`
    class. This sets the required `pixelSize` uniform in the edge detection shader:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EdgeDetect()` 函数使用 `SimpleTexture` 类应用 Sobel 滤波器。这将在边缘检测着色器中设置所需的 `pixelSize`
    统一变量：'
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the following `EdgeDetectionFragment.glsl` fragment shader for edge
    detection. There is no change required in the vertex shader. Use `SimpleTexture::InitModel()`
    to load this shader:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下用于边缘检测的 `EdgeDetectionFragment.glsl` 片段着色器。在顶点着色器中不需要进行任何更改。使用 `SimpleTexture::InitModel()`
    加载此着色器：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Edge detection is implemented in the `EdgeDetection` class. This class contains
    two objects of the `ObjLoader` and `SimpleTexture` class. The former class renders
    the 3D mesh and the latter renders the texture on the HUD. First, the scene is
    rendered to a frame buffer object. This allows you to capture the current scene
    in the texture form in the color buffer of the frame buffer object. This texture
    is then applied to the Sobel operator convolution filter, which detects edges.
    Finally, the process texture is rendered back to the HUD using the object of the
    `SimpleTexture` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘检测在 `EdgeDetection` 类中实现。这个类包含两个 `ObjLoader` 和 `SimpleTexture` 类的对象。前者类渲染
    3D 网格，后者在 HUD 上渲染纹理。首先，场景被渲染到一个帧缓冲对象中。这允许你在帧缓冲对象的颜色缓冲区中以纹理形式捕获当前场景。然后，这个纹理被应用到
    Sobel 操作符卷积滤波器上，用于检测边缘。最后，使用 `SimpleTexture` 类的对象将过程纹理渲染回 HUD。
- en: 'Let''s understand its functioning in detail. The `EdgeDetection` class first
    initializes the `ObjLoader` and `SimpleTexture` class objects in the constructor.
    In the `initModel()` function, it calls `GenerateFBO` to create an offline rendering
    buffer (FBO) with the same dimensions as the render buffer. In the render function,
    this FBO is attached to the drawing pipeline so that all drawing commands are
    diverted to our FBO, rather than going to the default buffer. The `ObjLoader`
    class renders the scene to this FBO''s texture (with `textureId`). The graphics
    pipeline again binds back to the default framebuffer so that the output is visible
    on the screen. Now, the `SimpleTexture` class handles the remaining job of finding
    the scene edges through the `EdgeDetectionFragment.glsl` shader. This shader implements
    the Sobel operator and accepts a texture as an input. This texture must be the
    FBO''s color texture (`textureId`). In the fragment shader program, each time
    a current fragment is processed, it retrieves a 3 x 3 fragment matrix around it.
    This matrix is then multiplied by the convolution kernel along the horizontal
    and vertical direction to result `px` and `py`. This result is used in calculating
    the intensity (`distance`) and compared with the given threshold (`GradientThreshold`).
    If the comparison is greater, then the fragment is colored black; otherwise, it''s
    colored with white color:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解其工作原理。`EdgeDetection` 类首先在构造函数中初始化 `ObjLoader` 和 `SimpleTexture` 类对象。在
    `initModel()` 函数中，它调用 `GenerateFBO` 创建一个与渲染缓冲区具有相同维度的离线渲染缓冲区（FBO）。在渲染函数中，这个 FBO
    被附加到绘图管道，以便所有绘图命令都转移到我们的 FBO，而不是默认缓冲区。`ObjLoader` 类将场景渲染到这个 FBO 的纹理（`textureId`）。图形管道再次绑定回默认帧缓冲区，以便输出可见于屏幕。现在，`SimpleTexture`
    类通过 `EdgeDetectionFragment.glsl` 着色器处理剩余的查找场景边缘的工作。这个着色器实现了 Sobel 操作符并接受一个纹理作为输入。这个纹理必须是
    FBO 的颜色纹理（`textureId`）。在片段着色器程序中，每次处理当前片段时，它都会检索围绕它的 3x3 片段矩阵。然后，这个矩阵沿着水平和垂直方向与卷积核相乘，得到
    `px` 和 `py`。这个结果用于计算强度（`distance`）并与给定的阈值（`GradientThreshold`）进行比较。如果比较结果更大，则片段被着色为黑色；否则，它被着色为白色：
- en: '![How it works...](img/5527OT_09_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_09_04.jpg)'
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Implementing render to texture with Frame Buffer Objects* recipe
    in [Chapter 7](ch07.html "Chapter 7. Textures and Mapping Techniques"), *Textures
    and Mapping Techniques*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 7 章 *使用帧缓冲对象实现渲染到纹理* 的配方，*纹理和映射技术*
- en: '*Implementing grayscale and CMYK conversions*'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现灰度和 CMYK 转换*'
- en: Refer to the *Generating the polka dot pattern* recipe in [Chapter 6](ch06.html
    "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 6 章 *生成圆点图案* 的配方，*使用着色器工作*
- en: Making the scene blur with the Gaussian blur equation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高斯模糊方程制作场景模糊
- en: The blur effect is an image processing technique that softens an image or makes
    it hazy. As a result, the image appears smoother like viewing it through a translucent
    mirror. It reduces the overall sharpness of the image by decreasing the image
    noise. It's used in many applications, such as blooming effect, depth-of-field,
    fuzzy glass, and heat haze effect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊效果是一种图像处理技术，可以使图像变柔和或使其变得模糊。结果，图像看起来更平滑，就像通过半透明的镜子观看一样。它通过减少图像噪声来降低图像的整体锐度。它在许多应用中使用，例如开花效果、景深、模糊玻璃和热雾效果。
- en: The blurring effect in this recipe is implemented using the Gaussian blur equation.
    Like other image processing techniques, the Gaussian blur equation also makes
    use of the convolution filter to process image pixels. Bigger the size of the
    convolution filter, better and dense is the blur effect. The working principle
    of the Gaussian blur algorithm is very simple. Basically, each pixel's color is
    mixed with the neighboring pixel's color. This mixing is performed on the basis
    of a weight system. Closer pixels are given more weight as compared to farther
    ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的模糊效果是通过使用高斯模糊方程实现的。像其他图像处理技术一样，高斯模糊方程也使用卷积滤波器来处理图像像素。卷积滤波器越大，模糊效果越好，越密集。高斯模糊算法的工作原理非常简单。基本上，每个像素的颜色与相邻像素的颜色混合。这种混合是在一个权重系统的基础上进行的。与较远的像素相比，较近的像素被赋予更多的权重。
- en: '**The math behind the Gaussian blur equation**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**高斯模糊方程背后的数学**：'
- en: 'The Gaussian blur equation makes use of the Gaussion function. The mathematical
    form of the equation and graphical representation of this function in one and
    two-dimensional space, as shown in the left-hand side of the following figure.
    This recipe uses the 2D form of this function, where *σ* is the standard deviation
    of the distribution, *x* and *y* are the texel distance in the horizontal and
    vertical axis from the current texel on which the convolution filter works. The
    Gaussian function is very useful in making high frequency values smoother:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊方程利用高斯函数。该方程的数学形式以及该函数在一维和二维空间中的图形表示，如图中左侧所示。这个配方使用该函数的二维形式，其中 *σ* 是分布的标准差，*x*
    和 *y* 是当前纹理像素在水平和垂直轴上的纹理像素距离，该卷积滤波器在其上工作。高斯函数在使高频值更平滑方面非常有用：
- en: '![Making the scene blur with the Gaussian blur equation](img/5527OT_09_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用高斯模糊方程制作场景模糊](img/5527OT_09_05.jpg)'
- en: '**Working principle**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作原理**：'
- en: The Gaussian filter is applied on each and every texel. As a result, the change
    in its original value is based on the neighboring pixels. The number of the neighboring
    pixels depends on the size of the convolution kernel. For a 9 x 9 kernel, the
    number of computations required are *9 * 9 = 81*. These can be reduced by performing
    the Gaussian blur in two passes, wherein the first pass is applied on each texel
    in the horizontal direction (*s* axis), as shown in the upper-right corner image
    by label (1), and the second pass is applied in the vertical direction (*t* axis)
    represented by label (2). This requires 18 computations and the result is the
    same as 81 calculations. The final output of the Gaussian blur is represented
    by label 3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯滤波器应用于每个纹理像素。因此，其原始值的变化基于相邻像素。相邻像素的数量取决于卷积核的大小。对于一个 9 x 9 的核，所需的计算量是 *9 *
    9 = 81*。这些可以通过执行两次高斯模糊来减少，其中第一次在水平方向（*s* 轴）上应用于每个纹理像素，如图中右上角图像的标签（1）所示，第二次在垂直方向（*t*
    轴）上应用，由标签（2）表示。这需要 18 次计算，结果与 81 次计算相同。高斯模糊的最终输出由标签 3 表示。
- en: 'There are five steps required to implement the Gaussian blur:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现高斯模糊需要五个步骤：
- en: '**Filter size**: This depends on many things, such as the processing time,
    image size, output quality, and so on. Bigger the filter size, more the processing
    time, and better the results. For this recipe, we will use the 9 x 9 convolution
    filter.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滤波器大小**：这取决于许多因素，例如处理时间、图像大小、输出质量等。滤波器越大，处理时间越长，结果越好。在这个配方中，我们将使用 9 x 9 的卷积滤波器。'
- en: '**FBO**: This creates two FBO''s, the first one with the color and depth information
    and the second one only with the color information.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FBO**：这创建了两个 FBO，第一个包含颜色和深度信息，第二个只包含颜色信息。'
- en: '**Render to texture**: This renders the scene to the first FBO''s color texture.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染到纹理**：这会将场景渲染到第一个 FBO 的颜色纹理中。'
- en: '**Horizontal pass**: This uses the color buffer of the first FBO and applies
    the horizontal Gaussian blur pass.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平传递**：这使用第一个FBO的颜色缓冲区并应用水平高斯模糊传递。'
- en: '**Vertical pass**: This reuses the first FBO''s color buffer and applies the
    vertical pass.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直传递**：这重用第一个FBO的颜色缓冲区并应用垂直传递。'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe makes use of the first recipe on edge detection. We renamed the
    class from `EdgeDetection` to `GaussianBlur`. The steps to understand the required
    changes are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用了边缘检测的第一个配方。我们将类名从`EdgeDetection`重命名为`GaussianBlur`。理解所需更改的步骤如下：
- en: 'Create a new vertex shader called `Vertex.glsl`, as shown in the following
    code. This vertex shader will be shared by horizontal and vertical Gaussian blur
    passes:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的顶点着色器，称为`Vertex.glsl`，如下代码所示。此顶点着色器将由水平和垂直高斯模糊传递共享：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new fragment shader called `BlurHorizontal.glsl` and add the following
    code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的片段着色器，称为`BlurHorizontal.glsl`并添加以下代码：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, create another new fragment shader called `BlurVertical.glsl`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建另一个新的片段着色器，称为`BlurVertical.glsl`：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and link these shaders in the `SimpleTexture::InitModel()`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SimpleTexture::InitModel()`中编译和链接这些着色器。
- en: 'Calculate the Gaussian weight using `GaussianEquation()`. We assumed sigma
    (*σ*) as 10.0\. The parameter value contains the texel distance along the horizontal
    or vertical direction, and the σ is the variance or standard deviation of the
    Gaussian distribution:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GaussianEquation()`计算高斯权重。我们假设sigma (*σ*) 为10.0。参数值包含沿水平或垂直方向的texel距离，σ是高斯分布的方差或标准差：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Calculate the weights for the horizontal and vertical Gaussian fragment shader,
    as given in the following code using the `GaussianEquation` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算水平和垂直高斯片段着色器的权重，如下代码所示，使用`GaussianEquation`函数：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create two FBO's within the `Gaussian::InitModel` with `GenerateBlurFBO1` (with
    the color and depth texture) and `GenerateBlurFBO2` (only the color buffer). These
    create two FBO's with the `blurFboId1` and `blurFboId2` handles respectively.
    The first FBO uses an additional buffer for depth because we want depth testing
    to be performed so that the correct image will be rendered to the color texture
    of this FBO.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Gaussian::InitModel`中创建两个FBO，使用`GenerateBlurFBO1`（带有颜色和深度纹理）和`GenerateBlurFBO2`（仅颜色缓冲区）。这些创建两个FBO，分别使用`blurFboId1`和`blurFboId2`句柄。第一个FBO使用额外的缓冲区用于深度，因为我们希望执行深度测试，以便将正确的图像渲染到该FBO的颜色纹理中。
- en: 'Render the scene with the perspective projection system to the first FBO (`blurFboId1`
    color texture). This will render the scene image to the color texture of this
    FBO:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用透视投影系统将场景渲染到第一个FBO（`blurFboId1`颜色纹理）。这将渲染场景图像到该FBO的颜色纹理中：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, set the second FBO (with the `blurFboId2` handle) as a render destination,
    reuse the color texture from the first FBO (which contains the scene image), and
    pass it on to the horizontal blur pass (pass 1) with the `RenderHorizontalBlur()`
    function. This will produce the horizontal blur scene image on the (`textureId2`)
    color buffer of the second FBO. Note that the project system should be orthographic
    before the second FBO is set:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将第二个FBO（带有`blurFboId2`句柄）设置为渲染目标，重用第一个FBO的颜色纹理（包含场景图像），并将其传递给水平模糊传递（传递1）的`RenderHorizontalBlur()`函数。这将产生第二个FBO的（`textureId2`）颜色缓冲区上的水平模糊场景图像。注意，在设置第二个FBO之前，投影系统应该是正交的：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, use the default framebuffer and apply the pass 2 (vertical blur) using
    the `RenderVerticalBlur` function in the second FBO''s texture (`textureId2`):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用默认帧缓冲区并使用第二个FBO的`RenderVerticalBlur`函数在第二个FBO的纹理（`textureId2`）上应用传递2（垂直模糊）：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The basic idea behind the Gaussian blur is to create a new texel of an image
    by taking a weighted average of the texels around it. Weights are applied using
    the Gaussian distribution function. For each texel, we need to create a square
    around the centered pixel. For instance, for a given texel, a square kernel of
    five texel contributes 25 texels weighted average to get the middle texel. Now,
    as the diameter of the kernel grows, the operation becomes expensive because it
    needs to read more texels to contribute. This expense is not linear fashioned
    because a 9 x 9 kernel requires 81 texels to read, which is almost four times
    the previous kernel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊的基本思想是通过对其周围的 texel 进行加权平均来创建图像的新 texel。权重是通过高斯分布函数应用的。对于每个 texel，我们需要在中心像素周围创建一个正方形。例如，对于一个特定的
    texel，一个由五个 texel 组成的正方形核对中间的 texel 贡献了 25 个 texel 的加权平均。现在，随着核直径的增长，操作变得昂贵，因为它需要读取更多的
    texel 来贡献。这种开销不是线性的，因为一个 9 x 9 的核需要读取 81 个 texel，这几乎是之前核的四倍。
- en: Now, the Gaussian blur can be optimized to read less texels and yet achieve
    the same results. This can be done by dividing the kernel operation into two passes
    as the horizontal and vertical pass. In the former, only row-wise elements of
    the kernel are used for weighted average to calculate the middle texel of the
    row. Similarly, for the latter case, columnwise elements are considered. This
    way, it requires 18 (9 + 9) pixels to read instead of 81.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，高斯模糊可以被优化以读取更少的 texel 而且仍然达到相同的结果。这可以通过将核操作分为两个步骤，即水平和垂直步骤来实现。在前者中，仅使用核的行元素进行加权平均来计算行的中间
    texel。同样，对于后者情况，考虑列元素。这样，它只需要读取 18（9 + 9）个像素，而不是 81。
- en: Now, let's understand the working of this recipe. The Gaussian blur is applied
    in two phases. Each phase works on one-dimensional row and column. The first phase
    is a horizontal pass, where texels in the horizontal direction are considered
    by the Gaussian kernel. This phase is called pass 1, which is performed using
    `BlurHorizontal.glsl`. Similarly, the second phase for pass 2 is carried within
    the `BlurVertical.glsl` fragment shader. Both these fragment shaders share a common
    vertex shader called `Vertex.glsl` and these shaders are managed by the `SimpleTexture`
    class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解这个菜谱的工作原理。高斯模糊应用于两个阶段。每个阶段都针对一维行和列。第一阶段是水平遍历，其中水平方向的 texel 被高斯核考虑。这个阶段被称为第
    1 阶段，它使用 `BlurHorizontal.glsl` 执行。同样，第二阶段的第二个阶段在 `BlurVertical.glsl` 片段着色器中执行。这两个片段着色器共享一个名为
    `Vertex.glsl` 的公共顶点着色器，这些着色器由 `SimpleTexture` 类管理。
- en: When the `GaussianBlur` class is initialized, it creates two FBO's. The first
    FBO requires the color and depth information to render the scene. However, the
    second FBO does not require any depth texture information because it works on
    the first FBO's color texture, which is already taken the depth of the scene into
    consideration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `GaussianBlur` 类被初始化时，它创建了两个 FBO。第一个 FBO 需要颜色和深度信息来渲染场景。然而，第二个 FBO 不需要任何深度纹理信息，因为它在第一个
    FBO 的颜色纹理上工作，该纹理已经考虑了场景的深度。
- en: 'The scene is rendered to the color texture of the first FBO. This color texture
    is shared with the `SimpleTexture` class where the first pass (horizontal blur)
    is applied to it. During the second pass, the second FBO is used and provided
    with the horizontal, blurred color texture (from the first FBO) as an input. This
    texture (horizontal blurred) processes the vertical blur shader and stores the
    processed texture in the color buffer of the second FBO. Finally, the scene is
    attached to the default framebuffer, and the color buffer from the second FBO
    is rendered on the screen:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 场景被渲染到第一个 FBO 的颜色纹理中。这个颜色纹理与 `SimpleTexture` 类共享，其中第一个步骤（水平模糊）应用于它。在第二个步骤中，使用第二个
    FBO，并提供了来自第一个 FBO 的水平模糊颜色纹理（作为输入）。这个纹理（水平模糊）处理垂直模糊着色器，并将处理后的纹理存储在第二个 FBO 的颜色缓冲区中。最后，场景附加到默认帧缓冲区，第二个
    FBO 的颜色缓冲区被渲染到屏幕上：
- en: '![How it works...](img/5527OT_09_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_09_06.jpg)'
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Detecting the scene edges with the Sobel operator*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Sobel 算子检测场景边缘*'
- en: Making a scene glow real time with the bloom effect
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用光晕效果实时制作场景发光
- en: Blooming is a very useful post screen processing technique that makes a real-time
    scene glow. With this effect, certain parts of the scene appear highly brighter
    and give an illusion of emitting scattered light in the atmosphere. This technique
    is widely used in gaming and cinematic effects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊是一种非常有用的后屏幕处理技术，可以使实时场景发光。使用此效果，场景的某些部分会显得非常明亮，并给人一种在空气中发出散射光的感觉。这项技术在游戏和电影效果中得到了广泛应用。
- en: 'The working principle of the bloom effect is very simple. The following image
    shows a pictorial representation of the working model, which is used in the current
    recipe. First, the scene is rendered to an offline framebuffer or texture (label
    **1**), where its texture is used as an input in the next stage that detects the
    bright portions in the scene and writes in a new texture (label **2**). This texture
    is then passed on to the horizontal (label **3**) and vertical blur (label **4**),
    which applies the Gaussian blurring effect to make it blurred and scattered a
    bit. This output (label **4**) is then finally combined on top of the original
    rendered scene (label **1**), which produces a glow-like effect:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊效果的工作原理非常简单。以下图像展示了当前配方中使用的模型的工作原理图，其中场景被渲染到离线帧缓冲区或纹理（标记**1**），其纹理作为下一阶段的输入，该阶段检测场景中的明亮部分并将其写入新的纹理（标记**2**）。然后，这个纹理被传递到水平（标记**3**）和垂直模糊（标记**4**），应用高斯模糊效果使其变得模糊并稍微分散。这个输出（标记**4**）最终与原始渲染的场景（标记**1**）结合，产生类似发光的效果：
- en: '![Making a scene glow real time with the bloom effect](img/5527OT_09_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用模糊效果实时制作场景发光](img/5527OT_09_07.jpg)'
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This recipe reuses our previous recipe on Gaussian blur. We rename the class
    from `GaussianBlur` to `Bloom`. Here are the steps to implement this recipe:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方重用了我们之前关于高斯模糊的配方。我们将类名从`GaussianBlur`更改为`Bloom`。以下是实现此配方的步骤：
- en: 'Create a new fragment shader called `Bloom.glsl`. This fragment shader need
    to be compiled and linked within the `SimpleTexture` class. This shader is responsible
    for locating the bright portions of the scene:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的片段着色器，称为`Bloom.glsl`。这个片段着色器需要在`SimpleTexture`类中编译和链接。这个着色器负责定位场景中的明亮部分：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is no change required in the `BlurHorizontal.glsl`. However, in the `BlurVertical.glsl`,
    add the following code. This code is responsible for mixing the blurred bright
    portions of the scene with the original scene (unchanged) preserved in the `RenderTex`
    texture:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlurHorizontal.glsl`中不需要进行任何更改。然而，在`BlurVertical.glsl`中，添加以下代码。这段代码负责将场景中模糊的明亮部分与保存在`RenderTex`纹理中的原始场景（未更改）混合：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create three FBO's in `Bloom::InitModel` with `GenerateSceneFBO()` (using the
    color and depth texture), `GenerateBloomFBO()` (using only the color buffer),
    and `GenerateBlurFBO2()` (using only the color buffer). These functions will create
    three FBO's with the `SceneFbo`, `BloomFbo`, and `BlurFbo` handles respectively.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bloom::InitModel`中使用`GenerateSceneFBO()`（使用颜色和深度纹理）、`GenerateBloomFBO()`（仅使用颜色缓冲区）和`GenerateBlurFBO2()`（仅使用颜色缓冲区）创建三个FBO。这些函数将分别创建具有`SceneFbo`、`BloomFbo`和`BlurFbo`句柄的三个FBO。
- en: Render the bloom recipe under `Bloom::Render()`. In this function, render the
    scene with the perspective projection system, process the textures under the orthographic
    projection system, and store the handle of the default framebuffer.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bloom::Render()`下渲染模糊配方。在这个函数中，使用透视投影系统渲染场景，在正交投影系统下处理纹理，并存储默认帧缓冲区的句柄。
- en: 'Render different phases for the bloom effect using `RenderObj()`, `RenderBloom()`,
    `RenderHorizontalBlur()`, and `RenderVerticalBlur()`. All of these functions accept
    four arguments. The first argument (`BindTexture`) specifies the input color texture/buffer,
    the second argument (`Framebuffer`) specifies the handle of the framebuffer to
    which the scene should be attached, the third argument (`ColorBuf`), and the fourth
    argument (`DepthBuf`) specifies the color and depth buffer to which the scene
    writes. If any of the argument is not required, send `NULL` as an argument:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RenderObj()`、`RenderBloom()`、`RenderHorizontalBlur()`和`RenderVerticalBlur()`渲染模糊效果的各个阶段。所有这些函数都接受四个参数。第一个参数（`BindTexture`）指定输入颜色纹理/缓冲区，第二个参数（`Framebuffer`）指定场景应附加到的帧缓冲区的句柄，第三个参数（`ColorBuf`），以及第四个参数（`DepthBuf`）指定场景写入的颜色和深度缓冲区。如果任何参数不是必需的，则发送`NULL`作为参数：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `RenderObj()` will render the scene to the `SceneFbo` framebuffer in the
    `SceneTexture` and `DepthTexture`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RenderObj()`将场景渲染到`SceneFbo`帧缓冲区中的`SceneTexture`和`DepthTexture`。'
- en: Similarly, the `RenderBloom()` uses `SceneTexture`. Now, apply the `BlurHorizontal.glsl`
    shader to it, which will render the scene to `BlurTexture`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `RenderVerticalBlur()` uses `BlurTexture` and `SceneTexture` as an
    input and applies the `BlurVertical.glsl` shader on it, which will apply the vertical
    blur pass and mix it in the scene texture.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use the `blurFboId2` FBO and reuse the first FBO's texture and pass it
    on to pass 1 (the horizontal blur) using the `RenderHorizontaBlur()` function.
    This will store the processing result of pass 2 in `textureId2`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use the default framebuffer and apply the pass 2 (the vertical blur) to
    the second FBO's texture (`textureId2`).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working principle of the bloom effect is very similar to the previous recipe.
    Instead, a new stage for blooming is added. First, the scene is rendered to a
    nondefault framebuffer called `SceneFBO`, where it's written in the `SceneTexture`.
    The next stage called blooming is also performed on an offline framebuffer (`BloomFBO`).
    In this, the texture from the previous stage is used as an input and applied to
    the bloom fragment shader. The bloom shader converts a color image to luminance,
    which stores the image information in the linear gradient form. This provides
    the brightness information of the image, where the bright portions are detected
    by comparing the gradient value to the required threshold. The brightest portions
    are then written in the `BloomTexture` and provided to the Gaussian blur stage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In this stage, the input stored in the `BloomTexture` from the previous stage
    is processed using the horizontal Gaussian blur pass where it''s stored in `BlurTexture`
    and applied to the vertical pass. During the vertical blur pass, the blurred bright
    portion is mixed with the original scene using `SceneTexture`. This way, the image
    is mixed with the bright scattered glowing light on the scene:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_09_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Detecting the scene edges with the Sobel operator*'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making the scene blur with the Gaussian blur equation*'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Painting the scene like a cartoon shading
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among various different kinds of shaders, the toon shader is well known for
    producing cartoon-shaded scenes. The cartoon shading technique is implemented
    in the fragment shader. The fundamental basis of this shader is the quantization
    of colors. In this, a range of colors are represented by a single type of color.
    Mathematically, color values are constrained from a continuous set of values (in
    floating numbers) to a relatively small discrete color set (represented by integer
    values). In addition to the quantization of color, the edges of the geometry are
    also highlighted using the Sobel operator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a screenshot from the current recipe, where quantization
    can be easily seen in various shades of green color. In conjunction, the Sobel
    operator renders thick black edges:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Painting the scene like a cartoon shading](img/5527OT_09_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is an extension of our edge detection recipe. With very little changes
    in the fragment shader, we can create a scene that looks like a painted cartoon.
    For this recipe, you are advised to thoroughly understand our first recipe in
    this chapter. This recipe will cover the changes we added to the existing edge
    detection's fragment shader for implementing the cartoon shader.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是我们边缘检测配方的扩展。通过在片段着色器中做非常小的改动，我们可以创建出类似绘画卡通的场景。对于这个配方，建议您彻底理解本章中的第一个配方。这个配方将涵盖我们为实施卡通着色器而添加到现有边缘检测片段着色器中的更改。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We reused the `EdgeDetectionFragment.glsl` and renamed it to `ToonShader.glsl`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了`EdgeDetectionFragment.glsl`并将其重命名为`ToonShader.glsl`：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the cartoon shading, each incoming fragment is first passed through the Sobel
    operation to check whether it belongs to an edge or not. If it does, the current
    fragment is rendered with a black edge color; otherwise, it's shaded with the
    cartoon shading effect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡通着色中，每个传入的片段首先通过Sobel操作来检查它是否属于边缘。如果是，当前片段以黑色边缘颜色渲染；否则，它将以卡通着色效果进行着色。
- en: In the cartoon shading effect, each fragment color is multiplied by a `quantizationFactor`
    (which is 2.0 in the present case). This is used in the process of the image quantization.
    In computer graphics, image quantization is a process of limiting a large set
    of colors to fewer ones. In other words, it groups similar colors as one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡通着色效果中，每个片段颜色乘以一个`quantizationFactor`（在本例中为2.0）。这在图像量化过程中被使用。在计算机图形学中，图像量化是将大量颜色限制为更少颜色的过程。换句话说，它将相似的颜色分组为一种。
- en: The obtained color components are added with 0.5 to enhance the chances of producing
    values greater than 1.0\. This is helpful for the next step, where the floating
    point color space is converted to the integer type. During this process, the decimal
    part of the color component is chopped off.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的颜色分量加上0.5以增加产生大于1.0的值的可能性。这对于下一步很有帮助，在这一步中，浮点颜色空间被转换为整数类型。在这个过程中，颜色分量的十进制部分被截断。
- en: Finally, the effect of the `quantizationFactor` multiplication is nullified
    (we applied this at the beginning), by dividing the integer space color components
    by `quantizationFactor`. The resultant value is applied on the fragment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将整数空间颜色分量除以`quantizationFactor`来抵消`quantizationFactor`乘法的效果（我们在开始时应用了这一点）。结果值应用于片段。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Detecting the scene edges with the Sobel operator*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Sobel算子检测场景边缘*'
- en: Generating an embossed scene
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成凸起场景
- en: Embossing is a technique in which the scene appears raised or highlighted with
    some 3D depth. The working logic of the emboss shader is similar to the edge detection
    technique. Here, the detected edges are used to highlight the image based on edge
    angles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 凸起是一种技术，其中场景看起来有凸起或突出，具有一定的3D深度。凸起着色器的逻辑与边缘检测技术类似。在这里，检测到的边缘用于根据边缘角度突出图像。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will reuse any of the previous post screen processing recipe
    implemented in this chapter. This recipe will directly jump to the shader part
    with an assumption that the reader has understood the fundamental logics of the
    post processing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将重用本章中实现的任何先前后处理配方。这个配方将直接跳转到着色器部分，假设读者已经理解了后处理的基本逻辑。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new fragment shader called `EmbossFrag.glsl`, as shown in the following
    code. There are no changes required for the vertex shader:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的片段着色器，命名为`EmbossFrag.glsl`，如下面的代码所示。对于顶点着色器没有需要更改的地方：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'In this recipe, edges are detected by taking the difference between two consecutive
    texels in any arbitrary direction. The difference of these two results in a new
    color intensity, where each component (RGB) are compared among themselves to find
    the greater magnitude component (max). This component is then used to clamp between
    low (0.0) and high (1.0). This operation results in three color intensities: white
    (derived from low), black (derived from high) 1.0, and emboss (derived from the
    max component). The result of the emboss shader is shown in the following image.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，通过取任意方向上两个连续texel之间的差值来检测边缘。这两个结果的差值产生一个新的颜色强度，其中每个分量（RGB）相互比较以找到具有最大幅度的分量（max）。然后使用这个分量在低（0.0）和高（1.0）之间进行clamp操作。这个操作产生了三种颜色强度：白色（来自低），黑色（来自高）1.0，和凸起（来自最大分量）。凸起着色器的结果如下所示。
- en: 'First, the scene is rendered to a FBO where it''s stored in the color buffer.
    This color buffer is then sent to the emboss shader in the `Tex1` variable. The
    `p00` and `p01` are represented as two consecutive texels, which are sampled from
    `Tex1` for the current fragment position. The difference is stored in the diff
    variable. The diff variable is checked to find the maximum magnitude among RGB
    components, which is stored in the max variable. The max value is clamped using
    the `clamp()` function. The result is finally used as an RGB component of the
    current fragment:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，场景被渲染到一个 FBO 中，并在颜色缓冲区中存储。然后，这个颜色缓冲区被发送到 `Tex1` 变量中的浮雕着色器。`p00` 和 `p01` 被表示为两个连续的纹理元素，它们从
    `Tex1` 中采样，用于当前片段的位置。差异被存储在 diff 变量中。diff 变量被检查以找到 RGB 组件中的最大幅度，它被存储在 max 变量中。使用
    `clamp()` 函数将最大值钳位。最终结果被用作当前片段的 RGB 组件：
- en: '![How it works...](img/5527OT_09_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_09_10.jpg)'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The clamping operation we used in this recipe is performed using the `clamp()`
    GLSL function. This function takes three values: original, lower, and higher range
    value. If the original value lies between the minimum and maximum range, it returns
    the original value; otherwise, it returns the minimum range value if the value
    is smaller than the minimum one and vice versa.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用的钳位操作是通过 `clamp()` GLSL 函数执行的。这个函数接受三个值：原始值、下限和上限范围值。如果原始值位于最小和最大范围之间，则返回原始值；否则，如果值小于最小值，则返回最小范围值，反之亦然。
- en: '**Syntax**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Variable | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x` | This specifies the value to constrain |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 这指定了要约束的值 |'
- en: '| `minVal` | This specifies the lower end of the range to constrain `x` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `minVal` | 这指定了约束 `x` 的范围的下限 |'
- en: '| `maxVal` | This specifies the upper end of the range to constrain `x` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `maxVal` | 这指定了约束 `x` 的范围的上限 |'
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Implementing grayscale and CMYK conversions*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现灰度和 CMYK 转换*'
- en: Implementing grayscale and CMYK conversions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现灰度和 CMYK 转换
- en: The grayscale or luminance is an important topic that digital image processing
    is incomplete without discussing its practical implementation. Luminance is widely
    used in various applications of image processing. Edge detection, cartoon shading,
    and emboss effect are examples that we implemented in this chapter, which make
    use of luminance. In this recipe, you will learn how to covert an RGB color space
    to luminance and CMYK.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度或亮度是一个重要的主题，没有讨论其实际实现，数字图像处理就不完整。亮度在图像处理的多种应用中被广泛使用。边缘检测、卡通阴影和浮雕效果是我们在本章中实现的例子，它们都利用了亮度。在本食谱中，你将学习如何将
    RGB 颜色空间转换为亮度和 CMYK。
- en: Numerically, a grayscale is a linear interpolation between black and white,
    depending on the color depth. A depth of 8 bits represent 256 varying shades from
    white to black. However, with four, only 16 shades can be represented. The black
    color is the darkest possible shade, which is the total absence of transmitted
    or reflected light. The lightest possible shade is white, which is the total transmission
    or reflection of light at all visible. Intermediate shades of gray are represented
    by equal levels of three primary colors (red, green, and blue) to transmit light
    or equal amounts of three primary pigments (cyan, magenta, and yellow) for reflected
    light.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从数值上讲，灰度是黑色和白色之间的线性插值，这取决于颜色深度。8 位深度表示从白色到黑色变化的 256 种不同色调。然而，使用 4 位，只能表示 16
    种色调。黑色是可能的最暗色调，这是传输或反射光的总缺失。最亮的可能色调是白色，这是在所有可见光下传输或反射光的总和。中间的灰色色调由三种原色（红色、绿色和蓝色）的相等水平来表示，以传递光，或者由三种原色素（青色、品红色和黄色）的相等量来表示反射光。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The ITU-R BT.709 standard provides the weight of these components as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ITU-R BT.709 标准提供了以下这些组件的权重：
- en: '*RGB luminance value = 0.2125*(Red) + 0.7154*(Green) + 0.0721*(Blue)*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*RGB 亮度值 = 0.2125*(红色) + 0.7154*(绿色) + 0.0721*(蓝色)*'
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe onwards, we will discuss various image processing techniques that
    was implemented in this chapter. For these recipes, we have reused the *Applying
    texture with UV mapping* recipe from [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Textures and Mapping Techniques*. For the current image
    processing recipe, we only need to make changes in the fragment shader. Proceed
    to the next section to understand the changes that need to be made to implement
    grayscale and CMYK conversions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个配方开始，我们将讨论本章中实现的各种图像处理技术。对于这些配方，我们重用了来自[第7章](ch07.html "第7章。纹理和映射技术")的*应用带有UV映射的纹理*配方，*纹理和映射技术*。对于当前的图像处理配方，我们只需要在片段着色器中进行更改。继续下一节，了解需要进行的更改以实现灰度和CMYK转换。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Reuse the simple texture recipe, as mentioned previously, and make the following
    changes in the fragment shader to implement the grayscale and CMYK recipe:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用之前提到的简单纹理配方，并在片段着色器中进行以下更改以实现灰度和CMYK配方：
- en: '**Grayscale recipe**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**灰度配方**:'
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Declare a `luminanceWeight` variable that contains the weight of RGB components
    as per the ITU-R BT.709 standard. Use the incoming texture coordinate and sample
    the corresponding texel from the texture in the `rgb` variable. Take the dot product
    between the luminanceWeight and rgb variable to produce the grayscale image (stored
    in the luminance variable). The grayscale image output of the current recipe is
    shown in the following right hand-side image:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个`luminanceWeight`变量，该变量包含RGB组件的权重，按照ITU-R BT.709标准。使用传入的纹理坐标，并在`rgb`变量中采样相应的texel。计算亮度权重和rgb变量之间的点积，以生成灰度图像（存储在亮度变量中）。当前配方输出的灰度图像显示在以下右侧图像中：
- en: '![How it works...](img/5527OT_09_11.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_09_11.jpg)'
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Images are represented in the RGB color space on color computer monitors. However,
    when these images are published using the standard printing process, these need
    to be converted to the CMYK color space. The RGB model is created by adding color
    components to the black color. This is based on emissive colors. In contrast,
    the CMYK color is transmissive. Here, the colors are created by subtracting color
    components from white. In an RGB to CMYK conversion, the red component changes
    to cyan, green to magenta, blue to yellow, and black. The publishing print press
    uses the CMYK color format, where the RGB space image is converted to four separate
    single color images, which are used to create four separate printing plates to
    the printing process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色计算机显示器上，图像以RGB颜色空间表示。然而，当使用标准印刷过程发布这些图像时，需要将它们转换为CMYK颜色空间。RGB模型是通过向黑色添加颜色成分来创建的。这是基于发射色。相比之下，CMYK颜色是透射的。在这里，颜色是通过从白色中减去颜色成分来创建的。在RGB到CMYK转换中，红色成分变为青色，绿色变为品红色，蓝色变为黄色，黑色变为黑色。出版印刷机使用CMYK颜色格式，其中RGB空间图像被转换为四个单独的单色图像，这些图像用于创建四个单独的印刷版，用于印刷过程。
- en: 'The CMYK color space can be calculated from RGB using the following formula:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下公式从RGB计算出CMYK颜色空间：
- en: '![There''s more...](img/5527OT_09_12.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_09_12.jpg)'
- en: 'However, this simple conversion does not truly match the desired results one
    would expect after conversion. The following approximation from Adobe Photoshop
    produces very satisfactory results. The under color removal (**ucr**) and black
    generation (**bg**) function is given as follows, where *Sk=0.1*, *K0 = 0.3*,
    and *Kmax = 0.9*. These are the constant values used in the formula:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的转换并不能真正达到转换后预期的结果。以下是从Adobe Photoshop中得到的近似值，效果非常令人满意。底色去除（**ucr**）和黑色生成（**bg**）函数如下所示，其中*Sk=0.1*，*K0
    = 0.3*，*Kmax = 0.9*。这些是公式中使用的常数值：
- en: '![There''s more...](img/5527OT_09_13.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_09_13.jpg)'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Under color removal** (**ucr**) is the process of eliminating the overlapped
    yellow, magenta, and cyan color components that would be added to produce a dark
    neutral black color, replacing them with black ink called full black. This results
    in less ink and greater depth in shadows.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**去除底色**（**ucr**）是消除用于产生深中性黑色时叠加的黄色、品红色和青色颜色成分的过程，用全黑墨水来替代它们。这导致墨水用量减少，阴影深度增加。'
- en: '**Black generation** (**bg**) is the process of producing a black channel or
    color. This affects color channels, when color conversation is performed from
    the RGB to CMYK color space.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑色生成**（**bg**）是产生黑色通道或颜色的过程。这会影响颜色通道，当从RGB颜色空间转换为CMYK颜色空间时进行颜色转换。'
- en: 'The following image shows the color version and four separated versions of
    CMYK in grayscale. The grayscale representation of each component shows the amount
    of ink required for each darker values, indicating high consumption of ink:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了CMYK的彩色版本和四个分离的灰度版本。每个组件的灰度表示显示了每个较暗值所需的油墨量，表明油墨消耗量高：
- en: '![There''s more...](img/5527OT_09_14.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_09_14.jpg)'
- en: 'Here is the fragment shader code for the CMYK separation from an RGB color
    space:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是RGB颜色空间到CMYK颜色空间转换的片段着色器代码：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第7章中的*使用UV映射应用纹理*配方，*纹理和映射技术*，第7章
- en: Implementing fisheye with barrel distortion
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桶形畸变实现鱼眼效果
- en: Fisheye is an effect in which a scene looks sphered. As a result, edges in the
    scene look curved and bowed around the center of this virtual sphere. This effect
    makes the scene look like wrapped around a curved surface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 鱼眼是一种效果，其中场景看起来是球形的。因此，场景中的边缘看起来是弯曲的，并围绕这个虚拟球体的中心弯曲。这种效果使场景看起来像被包裹在一个弯曲的表面上。
- en: The barrel distortion technique is used to achieve the present effect, which
    can be applied to fragments or vertices. This recipe will implement the barrel
    distortion on the fragment shader first and then apply it to the vertex shader.
    The difference between the two is this; in the former shader, the geometry does
    not distort. However, texture coordinates are distorted, resulting in a magnifying
    lens effect or a fisheye lens effect. In the latter technique, the geometry is
    displaced and creates different amusing distorted shapes. Note that this is not
    a post processing technique.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 桶形畸变技术被用来实现当前效果，它可以应用于片段或顶点。这个配方首先将在片段着色器上实现桶形畸变，然后将其应用于顶点着色器。两者的区别在于：在前者着色器中，几何形状不会畸变。然而，纹理坐标会畸变，从而产生放大镜效果或鱼眼镜头效果。在后一种技术中，几何形状被位移，创造出不同的有趣畸变形状。请注意，这并不是一种后处理技术。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we can reuse our first recipe and replace the edge detection
    logic with the current barrel distortion fragment shader: `BarrelDistFishEyeFragment.glsl`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们可以重用我们的第一个配方，并用当前的桶形畸变片段着色器`BarrelDistFishEyeFragment.glsl`替换边缘检测逻辑。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Modify the `BarrelDistFishEyeFragment.glsl`, as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`BarrelDistFishEyeFragment.glsl`，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe first renders the scene to a FBO's color texture, which is then
    shared with the `SimpleTexture` class and applied to the quad geometry with texture
    coordinates ranging from (0.0, 0.0) to (1.0, 1.0). The quad vertex and texture
    information are provided to the vertex and fragment shader to process the geometry
    and fragment information. The barrel distortion technique is implemented in the
    fragment shader, where each incoming texture coordinate is temporarily converted
    to the polar coordinate to produce the fisheye effect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方首先将场景渲染到FBO的颜色纹理中，然后与`SimpleTexture`类共享，并应用于纹理坐标从(0.0, 0.0)到(1.0, 1.0)的四边形几何形状。四边形的顶点和纹理信息被提供给顶点和片段着色器以处理几何和片段信息。桶形畸变技术实现在片段着色器中，其中每个传入的纹理坐标临时转换为极坐标以产生鱼眼效果。
- en: Texture coordinates are first translated in the center (0.5, 0.5) and the distance
    of these translated texture coordinates is computed from the center. If the translated
    texture coordinates (`xy`) falls outside the given threshold of 0.35 radius, then
    unaltered texture coordinates (`TexCoord`) are used to fetch the sample from `Tex1`;
    otherwise, this coordinate (`xy`) is applied to the barrel distortion with the
    `BarrelDistortion` function. The following image shows the radius of the red circle.
    The `BarrelDistortion` function first calculates the length of the texture coordinate
    with respect to the center of the logical circle. This obtained length is altered
    using the barrel power, which shrinks or expands the length. The following image
    shows different results obtained from various barrel powers (1.0, 0.5, 0.3, and
    2.0).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标首先在中心（0.5, 0.5）进行转换，并从中心计算这些转换后的纹理坐标的距离。如果转换后的纹理坐标（`xy`）超出了给定的0.35半径阈值，则使用未改变的纹理坐标（`TexCoord`）从`Tex1`获取样本；否则，将此坐标（`xy`）应用于桶形畸变，使用`BarrelDistortion`函数。以下图像显示了红色圆圈的半径。`BarrelDistortion`函数首先计算纹理坐标相对于逻辑圆心的长度。通过桶形功率改变获得的长度，从而缩小或扩大长度。以下图像显示了不同桶形功率（1.0、0.5、0.3和2.0）得到的不同结果。
- en: 'This altered length is then multiplied by the slope of texture coordinates
    along the S (horizontal) and T (vertical) components, which will result in a new
    set of translated texture coordinates. These texture coordinates are retranslated
    into their old origin (bottom, left). Finally, this retranslated texture coordinate
    is used to calculate the sampled texture from the input texture coordinate:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此改变后的长度乘以纹理坐标沿S（水平）和T（垂直）组件的斜率，这将得到一组新的转换后的纹理坐标。这些纹理坐标被重新转换回它们的原始位置（底部，左侧）。最后，使用重新转换的纹理坐标从输入纹理坐标计算采样纹理：
- en: '![How it works...](img/5527OT_09_15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_09_15.jpg)'
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'When the barrel distortion is applied to the geometry, it distorts the physical
    shape of the geometry. The following images show the application of the barrel
    distortion on different meshes. You can explore this recipe using the `BarrelDistortion_Vtx_Shdr`
    source code provided in this chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当桶形畸变应用于几何形状时，它会扭曲几何形状的物理形状。以下图像显示了桶形畸变在不同网格上的应用。您可以使用本章提供的`BarrelDistortion_Vtx_Shdr`源代码来探索此方法：
- en: '![There''s more...](img/5527OT_09_16.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/5527OT_09_16.jpg)'
- en: The working logic of this recipe is similar to the previous one except the fact
    that it's now implemented in the vertex shader. Here, we do not need to translate
    the texture coordinate from the center because, by default, the origin always
    is the center of the Cartesian coordinate system.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的逻辑与之前类似，只是现在它是通过顶点着色器实现的。在这里，我们不需要从中心转换纹理坐标，因为默认情况下，原点始终是笛卡尔坐标系的原点。
- en: 'Use the following code in the vertex shader to apply barrel distortion on the
    vertex shader:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中使用以下代码来应用桶形畸变：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Generating the polka dot pattern* recipe in [Chapter 6](ch06.html
    "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第6章中的*生成圆点图案*配方，*使用着色器工作*，[第6章](ch06.html "第6章。使用着色器")，*使用着色器工作*
- en: Implementing the binocular view with procedural texturing
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过程纹理实现双眼视图
- en: This recipe implements a binocular view effect, where a scene is rendered as
    if it's visualized from the binocular itself. We will implement this effect by
    programing a procedural shader. Alternatively, in another technique, the alpha-mapped
    texture is used instead. In this approach, an alpha-masked texture containing
    a binocular view image is superimposed on top of the scene. This way, only those
    parts of the scene are visible that belong to the nonmasked texture region.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法实现了一个双眼视图效果，其中场景被渲染成好像是从双眼本身可视化的。我们将通过编程过程着色器来实现此效果。或者，在另一种技术中，使用alpha映射纹理代替。在此方法中，一个包含双眼视图图像的alpha掩码纹理被叠加到场景之上。这样，只有属于非掩码纹理区域的场景部分是可见的。
- en: The procedural textured approach is also relatively simpler. Here, the scene
    is programmed in the fragment shader where the binocular view effect is created
    using texture coordinates of the vertices. Texture coordinates are used to create
    a logical circular region on the rendered image. The fragment that belongs outside
    the circumference of this circular region are rendered with an opaque color (say
    black). This opacity reduces as the distance shrinks toward the center point of
    this circular region. The tapped point (the single tap gesture) on the device
    screen is used as a center point of the circular region; this way, the lens can
    be moved around the screen using touch gestures.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化纹理方法也相对简单。在这里，场景是在片段着色器中编程的，其中使用顶点的纹理坐标创建双重视觉效果。纹理坐标用于在渲染的图像上创建一个逻辑圆形区域。属于这个圆形区域外缘的片段将以不透明颜色（例如黑色）渲染。随着距离缩小到这个圆形区域的中心点，这种不透明度会降低。设备屏幕上的触摸点（单次点击手势）用作圆形区域的中心点；这样，可以使用触摸手势在屏幕上移动镜头。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use any of the existing image processing recipes and replace the following
    code in the fragment shader. This fragment shader accepts a few inputs from the
    OpenGL ES program. The image texture is stored in the `Tex1`; the tapped point
    must be provided in the center variable, which will be treated as the center of
    the circle. We also require the `horizontalAspectRatio` and `verticalAspectRatio`
    aspect ratios so that with different screen resolutions, a circle remains as a
    circle and not turned to any elliptical shape. Finally, we need the inner and
    outer radius (`LensInnerRadius`, `LensOuterRadius`) to define the width of the
    circular region. The color (`BorderColor`) will be used for the mask painting:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何现有的图像处理配方，并在片段着色器中替换以下代码。这个片段着色器从OpenGL ES程序接受一些输入。图像纹理存储在`Tex1`中；必须提供触摸点作为中心变量，它将被视为圆的中心。我们还需要`horizontalAspectRatio`和`verticalAspectRatio`纵横比，以便在不同屏幕分辨率下，圆形保持圆形，不会变成任何椭圆形。最后，我们需要内半径和外半径（`LensInnerRadius`，`LensOuterRadius`）来定义圆形区域的宽度。颜色（`BorderColor`）将用于遮罩绘制：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The incoming texture coordinates is subtracted by the center position and are
    translated into new logical coordinates, where transformed texture coordinates
    or positional vectors (dx, dy) are stored with reference to the center point (`center`).
    This coordinate must be multiplied by the `aspectRatio` in the horizontal and
    vertical directions to eliminate any shape distortion due to the difference in
    the horizontal and vertical device screen resolution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将传入的纹理坐标减去中心位置，并转换为新的逻辑坐标，其中变换后的纹理坐标或位置向量（dx，dy）以中心点（`center`）为参考存储。此坐标必须在水平和垂直方向上乘以`aspectRatio`，以消除由于水平和垂直设备屏幕分辨率差异引起的任何形状扭曲。
- en: 'The distance of each positional vector is calculated with the vector length
    formula *P (x, y) = √(x2 + y2)* and fed into the smoothstep GLSL API. The smooth
    step API accepts three arguments (**edge1**, **edge2**, and **x**). The first
    two arguments are two outbound values and the third is the weight. Refer to the
    following left-hand side image to understand its functioning. This API returns
    an interpolated value between two edges, based on the weight provided. The output
    of the smoothstep is used as a weight to feed into another GLSL API called mix.
    The mix API mixes the border color with the current texture using a weighted value
    provided by the smoothstep function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位置向量的距离使用向量长度公式 *P (x, y) = √(x^2 + y^2)* 计算，并输入到平滑步GLSL API中。平滑步API接受三个参数（**edge1**，**edge2**和**x**）。前两个参数是两个外值，第三个是权重。参考以下左侧图像来理解其功能。此API根据提供的权重返回两个边缘之间的插值值。平滑步的输出用作权重，输入到另一个名为mix的GLSL
    API中。mix API使用平滑步函数提供的加权值混合边框颜色与当前纹理：
- en: '![How it works...](img/5527OT_09_17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_09_17.jpg)'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考第7章中关于*使用UV映射应用纹理*的配方，*纹理和映射技术*
- en: Twirling the image
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转图像
- en: Twirling is a very common effect used in animations. When applied to a rendered
    scene or image, it distorts the appearance within the circular region and produces
    a radial circular motion of the texels where these are moved around the center
    of the circular region, producing a whirlpool-like effect.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是一种在动画中非常常见的效果。当应用于渲染的场景或图像时，它扭曲了圆形区域内的外观，并在这些纹理元素围绕圆形区域中心移动时产生径向圆形运动，从而产生漩涡状效果。
- en: 'Programmatically, for a given image, an arbitrary texel is chosen as a center.
    A fixed distance from the center of the circle defines a locus of the circumference.
    All the texels falling under this circumference are being applied to the rotation.
    The rotation of the texels within the circle decreases with the distance from
    the center and diminishes at the circumference edge. The following image shows
    how the twirl effect looks:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序上，对于给定的图像，选择一个任意的纹理元素作为中心。从圆心到固定距离定义了圆的轨迹。所有落在该轨迹下的纹理元素都应用于旋转。圆内的纹理元素旋转随着与中心的距离增加而减小，并在圆周边缘消失。以下图像显示了旋转效果的外观：
- en: '![Twirling the image](img/5527OT_09_18.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![旋转图像](img/5527OT_09_18.jpg)'
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following code in the fragment shader to implement the twirl effect:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中使用以下代码实现旋转效果：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The twirling effect requires a center point around which the whirlpool effect
    is produced, this center point is provided by the OpenGL ES program in the center
    variable. Additionally, we need the size of the image (`imageHeight` and `imageWidth`),
    which is used to control the region of animation within the image boundaries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转效果需要一个中心点，围绕该中心点产生漩涡效果，这个中心点由OpenGL ES程序中的中心变量提供。此外，我们还需要图像的大小（`imageHeight`
    和 `imageWidth`），它用于控制图像边界内的动画区域。
- en: Each incoming texture coordinate is converted to its corresponding texel position
    by multiplying it with the image size and is then translated with respect to the
    center. The translated coordinates represent the position vector, which is used
    to calculating the distance from the center point. If the distance is within a
    given radius threshold, the texels are rotated around the center with an arbitrary
    angle specified in the degree. The angle of rotation increases as the distance
    between the center and the translated coordinate decreases.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传入的纹理坐标通过乘以图像大小转换为相应的纹理元素位置，然后相对于中心进行平移。平移后的坐标代表位置向量，用于计算从中心点的距离。如果距离在给定的半径阈值内，则纹理元素将以在度数中指定的任意角度围绕中心旋转。旋转角度随着中心与平移坐标之间的距离减小而增加。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the binocular view with procedural texturing*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用程序纹理实现双目视图*'
- en: Sphere illusion with textured quadrilateral
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理四边形球体幻觉
- en: This recipe will demonstrate a performance efficient technique, which makes
    use of the procedural texture to produce the illusion of a real 3D object. In
    the Gouraud shading, fragments are painted with light shadings based on the direction
    of the light source and the geometry shape. For instance, in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Light and Materials*, we implemented the diffuse
    light on a spherical model, which contains a very high number of vertices. This
    recipe technique renders the same diffused sphere, but using only four vertices.
    It fakes the light shading in such a way that the difference between the two becomes
    indistinguishable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将演示一种性能高效的技巧，该技巧利用程序纹理来产生真实3D对象的幻觉。在Gouraud着色中，片段根据光源的方向和几何形状进行光照着色。例如，在[第5章](ch05.html
    "第5章。光与材料")中，我们实现了球形模型上的漫反射光，该模型包含非常多的顶点。本食谱技术渲染相同的漫反射球体，但只使用四个顶点。它以这种方式伪造光照着色，使得两者之间的差异难以区分。
- en: The performance is directly proportional to the number of fragments it renders
    to the screen. For example, the surface area covered by a single fullscreen rendering
    sphere is equivalent to several tiny spheres covering up the same surface area
    on the screen.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 性能直接与它渲染到屏幕上的片段数量成正比。例如，单个全屏渲染球体覆盖的表面积相当于在屏幕上覆盖相同表面积的几个小球。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following steps to implement sphere with textured quadrilateral:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来实现具有纹理的四边形球体：
- en: Create a new class called `TextureQuadSphere` derived from the `Model` class.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TextureQuadSphere` 的新类，该类从 `Model` 类派生。
- en: 'Declare the necessary vertex information for the quad, which will have the
    sphere rendered in:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明四边形所需的必要顶点信息，这将渲染成球体：
- en: '[PRE25]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following `TexQuadSphereVertex.glsl` vertex shader:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`TexQuadSphereVertex.glsl`顶点着色器：
- en: '[PRE26]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is no change required in the `TexQuadSphereFragment.glsl`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TexQuadSphereFragment.glsl`中不需要进行任何更改：
- en: '[PRE27]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This technique uses a square geometry with four texture coordinates for each
    vertex. Texture coordinates are shared by the vertex shader in the `TexCoord`
    variable with the fragment shader. Texture coordinates are in the range from 0.0
    to 1.0\. These are subtracted by half dimensions to calculate the positional vector
    (`position`) with respect to the center of the circle. The radius of the circle
    and the arbitrary position vector from the center of the circle is used to calculate
    the elevation at each given position.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用一个具有四个纹理坐标的方形几何体，每个顶点共享纹理坐标。纹理坐标通过`TexCoord`变量在顶点着色器和片段着色器之间共享。纹理坐标的范围从0.0到1.0。这些坐标减去半维度来计算相对于圆心的位置向量（`position`）。圆的半径和从圆心到任意位置向量的任意位置被用来计算给定位置的高度。
- en: This elevation is used with the positional coordinate to produce a normal vector;
    this normal vector provides the angle it made with incidence light rays. The cosine
    of this angle is used on the color intensity to produce the diffuse shading effect
    of light on the logical hemisphere. The incident light ray is calculated with
    the tap coordinates on the fly using the screen resolution and tapped coordinates
    *x* and *y* positions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高度与位置坐标一起用来产生一个法向量；这个法向量提供了它与入射光线的角度。这个角度的余弦值用于颜色强度，以产生光在逻辑半球上的漫反射效果。入射光线使用屏幕分辨率和戳坐标*x*和*y*位置实时计算。
- en: 'The following figure shows the pictorial representation of the previous described
    working logic. P (x, y, 0.0) represents the position vector (`position`), C is
    the center, and Q is the point on the hemisphere which will be calculated using
    *CQ = CP + PQ*, as shown in the following figure:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了之前描述的工作逻辑的图示。P (x, y, 0.0)代表位置向量（`position`），C是中心，Q是半球上的一个点，它将使用*CQ =
    CP + PQ*来计算，如图所示：
- en: '![How it works...](img/5527OT_09_19.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_09_19.jpg)'
- en: See also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Implementing the per-vertex diffuse light component* recipe in
    [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第5章](ch05.html "第5章。光和材料")中关于*实现每个顶点的漫反射光分量*的配方，*光和材料*
