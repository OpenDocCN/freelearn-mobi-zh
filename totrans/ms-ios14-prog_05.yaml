- en: '*Chapter 5*: Immersing Your Users with Animation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：通过动画让用户沉浸其中'
- en: Your app is starting to look really good now, and we've certainly covered a
    lot of ground already in this first few chapters, but UIKit has a lot of amazing
    features we're yet to explore – one of them being animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用现在看起来真的很好，而且我们已经在这几章中覆盖了很多内容，但UIKit还有很多令人惊叹的功能我们尚未探索——其中之一就是动画。
- en: In this chapter, you are going to learn some advanced techniques with UIKit,
    Apple's animation framework built right into UIKit. We'll start off with the basics
    of how the little things can make such a massive difference, and then move forward
    on to some more advanced techniques with `UIViewPropertyAnimator` and how it provides
    more control over your animations than the animations you implemented in previous
    chapters. You'll also learn about UIKit Dynamics. UIKit Dynamics can be used to
    make objects react to their surroundings by applying physics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习一些使用UIKit的高级技术，UIKit是Apple直接集成到UIKit中的动画框架。我们将从了解小事物如何产生巨大差异的基础知识开始，然后继续学习一些更高级的技术，包括`UIViewPropertyAnimator`以及它如何比你在前几章中实现的动画提供更多控制。你还将了解UIKit
    Dynamics。UIKit Dynamics可以通过应用物理来使对象对其周围环境做出反应。
- en: Finally, you'll learn how to implement a custom transition when moving from
    one view controller to the next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何在从一个视图控制器移动到下一个视图控制器时实现自定义过渡。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using `UIView.animate` and `UIViewPropertyAnimator`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UIView.animate`和`UIViewPropertyAnimator`
- en: Vibrant animations using springs in UIKit Dynamics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UIKit Dynamics中的弹簧实现生动的动画
- en: Customizing view controller transitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义视图控制器过渡
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    AppStore.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要从Apple的AppStore下载Xcode版本11.4或更高版本。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for `Xcode` in the App Store and select and download the latest
    version. Launch Xcode and follow any additional installation instructions that
    your system may prompt you with. Once Xcode has fully launched, you're ready to
    go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要运行最新的macOS（Catalina或更高版本）。只需在App Store中搜索`Xcode`，选择并下载最新版本。启动Xcode，并遵循系统可能提示的任何其他安装说明。一旦Xcode完全启动，你就可以开始了。
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Using UIView.animate and UIViewPropertyAnimator
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UIView.animate和UIViewPropertyAnimator
- en: As I said in the intro, we've come a long way so far with our app, but often,
    it's the little things that we can do that make a massive difference; you just
    need to take another look at [*Chapter 2*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046),
    *Working with Dark Mode*, to appreciate that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在简介中所说，我们的应用已经取得了很大的进步，但往往，正是我们可以做的那些小事会产生巨大的差异；你只需再次查看[*第2章*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046)，*使用深色模式*，就能体会到这一点。
- en: In this section, we are going to start by adding some basic animations to our
    app using the standard practice to achieve a simple yet effective result.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先通过使用标准实践添加一些基本动画到我们的应用中，以实现简单而有效的结果。
- en: Once we've done that, we'll look at how we can take this much further by refactoring
    and improving the maintainability of our code base. So, let's get started as we
    add our first animation to our app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些后，我们将探讨如何通过重构和改进代码库的维护性来进一步扩展这一点。因此，让我们开始添加我们的第一个动画到我们的应用中。
- en: Creating our first animation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个动画
- en: 'In their most basic form, animations are simple and easy to use. Here is an
    example of a typical animation that could be performed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们最基本的形式中，动画简单易用。以下是一个典型动画的示例，可以执行：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, what does this mean exactly? Well, the `UIView.animate` function (which
    itself is a closure) is setting the alpha of our cell property to `1.0`. If we
    assume that the alpha for this property was set to `0.0`, our `animate` function
    would, over the duration of `0.8` seconds, change the alpha from `0.0` to `1.0`
    – thus giving us a simple yet extremely effective fade-in effect!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这究竟意味着什么呢？嗯，`UIView.animate`函数（它本身也是一个闭包）正在将我们的cell属性的不透明度设置为`1.0`。如果我们假设这个属性的不透明度被设置为`0.0`，那么在`0.8`秒的动画过程中，`animate`函数将不透明度从`0.0`渐变到`1.0`——从而给我们一个简单但极其有效的淡入效果！
- en: Let's put this into action, continuing with our project from the previous chapter.
    Head on over to our `DetailsViewController.swift` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其付诸实践，继续我们上一章的项目。前往我们的`DetailsViewController.swift`文件。
- en: 'First, let''s set our contact image to have an alpha of `0.0`. We can achieve
    this by extending our outlet property to include a `didSet`. Make the following
    highlighted changes in the view controller:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将联系图片的不透明度设置为`0.0`。我们可以通过扩展我们的outlet属性来包括`didSet`来实现这一点。在视图控制器中做出以下突出显示的更改：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we've simply added a setter and set an additional property on our `UIImageView`
    – in this case, we've set the alpha to be `0`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是添加了一个setter并设置了一个额外的属性在我们的`UIImageView`上——在这种情况下，我们将不透明度设置为`0`。
- en: 'Now, back into the body of our view controller. Add the following to your `viewWillAppear()`
    function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们视图控制器的主体。将以下内容添加到你的`viewWillAppear()`函数中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as we saw in the earlier example, we're simply setting a duration for the
    animation, and inside the closure, we set the alpha value of our property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，我们只是设置动画的持续时间，然后在闭包中设置我们属性的不透明度值。
- en: Go on and run your code in the simulator; you'll see that when `DetailsViewController`
    now loads, you'll get a nice little fade-in animation. With just a slight tweak
    to a property and couple of lines of code, your app has made a massive jump forward!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在模拟器中运行你的代码；你会看到当`DetailsViewController`现在加载时，你会得到一个很棒的淡入动画。只需稍微调整一个属性和几行代码，你的应用就取得了巨大的进步！
- en: Working with multiple animations
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与多个动画一起工作
- en: Let's take this another step further now and add a bounce effect to `UICollectionViewCell`
    when it's tapped.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再进一步，给`tapped`时的`UICollectionViewCell`添加一个弹跳效果。
- en: Head on over to our view controller and locate the `didSelectItemAt:` function.
    Remember back in [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066),
    *Using Lists and Tables*, when we identified how we could grab an instance of
    the currently selected cell, should we want to do anything with it? Well, here's
    our chance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前往我们的视图控制器，找到`didSelectItemAt:`函数。记得在[*第3章*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066)，*使用列表和表格*中，我们确定了如何获取当前选中cell的实例，如果我们想对它做些什么？好吧，这就是我们的机会。
- en: 'Add the following code to the start of the `didSelectItemAt:` cell:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`didSelectItemAt:`cell的开始部分：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike `cellForItem:`, where we make use of the `re-us` identifier in order
    to recycle the use of our cells, here we care only about the selected instance
    – this is the cell we want to use and do something with.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与`cellForItem:`不同，在那里我们使用`re-us`标识符来回收使用我们的cell，这里我们只关心选中的实例——这是我们想要使用并对其做些事情的cell。
- en: 'Next, we''re going to add a big chunk of "initially" potentially confusing
    code, so we''ll break it down first one step at a time. Just underneath the preceding
    code, add the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一大块可能让人困惑的“初始”代码，所以我们会一步一步地分解它。在前面代码的下方，添加以下内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we're extending the `.animate` function we saw earlier, but this time
    you see we've got a parameter for a delay, which we've set to `0` as we want the
    animation to start straight away (but I guess it's nice to know that we could
    delay it if we wanted to).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们扩展了之前看到的`.animate`函数，但这次你看到我们有一个延迟参数，我们将其设置为`0`，因为我们希望动画立即开始（但我猜如果我们想的话，我们也可以延迟它）。
- en: Next, we've now got an `options` parameter, where we can pass in an array of
    animation options available to use through UIKit. Here, we're going to pass in
    `curveEaseOut` (don't worry, we'll cover the different types of animation options
    later in this chapter).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们现在有一个`options`参数，我们可以传递一个包含通过UIKit可用的动画选项的数组。在这里，我们将传递`curveEaseOut`（别担心，我们将在本章后面介绍不同类型的动画选项）。
- en: Finally, we set the transform of our image view by setting `CGAffineTransform`
    to a specific *x* and *y* scale. By setting a transform on the image, we are effectively
    scaling the original size based on a new *x* and *y* value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将 `CGAffineTransform` 设置为特定的 *x* 和 *y* 缩放比例来设置我们的图像视图的变换。通过在图像上设置变换，我们实际上是根据新的
    *x* 和 *y* 值来缩放原始尺寸。
- en: Go ahead, launch the app – what do you see? Hopefully not a great deal – and
    you'll be wondering why not too. That's because we still have our `performSegue`
    call in there that is being called (and performed) before our animation can complete.
    Comment that out for the moment and try again. With any luck, when you tap on
    the cell, you should see the contact image shrink in size (or give a de-pressed
    appearance).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，启动应用 – 你看到了什么？希望没有太多东西 – 你可能会想知道为什么没有。那是因为我们仍然有 `performSegue` 调用在那里，它在动画完成之前被调用（并执行）。暂时注释掉它，然后再次尝试。如果有任何运气，当你点击单元格时，你应该看到联系人图像缩小（或者给出一个按下外观）。
- en: So, before we worry about bringing back our `performSegue` call, let's get the
    animation looking right first. Our new animation block has another trick up its
    sleeve. Within the closure, we can add a completion handler that will get called
    as soon as the animation has finished (I know what you're thinking, but let's
    finish the animation first).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们担心恢复 `performSegue` 调用之前，让我们首先确保动画看起来正确。我们新的动画块中还有一个技巧。在闭包内部，我们可以添加一个完成处理程序，该处理程序将在动画完成后立即被调用（我知道你在想什么，但让我们先完成动画）。
- en: 'Update the code with the following highlighted lines:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下突出显示的行更新代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, all we''ve done here is extend our completion handler for our initial animate
    function by adding `completion: { finished in` and added in another animation
    function.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，我们在这里所做的只是通过添加 `completion: { finished in` 并加入另一个动画函数来扩展我们初始动画函数的完成处理程序。'
- en: Back inside that closure, we reset the transform on our image view by setting
    it to `CGAffineTransform.identity` (a nice easy way to quickly revert any transform
    to its original state).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个闭包内部，我们通过将其设置为 `CGAffineTransform.identity`（一种快速将任何变换恢复到原始状态的好方法）来重置我们的图像视图的变换。
- en: 'Run the app now in the simulator and all is going well; you should be presented
    with a really nice bounce effect. Let''s add the last piece of the puzzle back
    in now by again extending our second animate function to have a completion handler,
    where we will add back in `performSegue`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模拟器中运行应用，一切正常；你应该会看到一个非常好的弹跳效果。现在，让我们再次扩展我们的第二个动画函数，添加一个完成处理程序，以便再次加入 `performSegue`：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run your app again to see your beautiful animation in full bloom, followed by
    an immediate segue to `DetailViewController` – where you will be presented with
    a subtle yet effective fade-in animation of your contact image. Well done, you've
    done great!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的应用，以全貌欣赏你美丽的动画，紧接着立即过渡到 `DetailViewController` – 在那里，你会看到一个微妙而有效的淡入动画，展示你的联系人图像。做得好，你做得非常出色！
- en: In this section, we've learned how to tackle a basic animation in UIKit – we
    advanced a little, looking at how our basic animation could be extended to perform
    a little more complex task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理 UIKit 中的基本动画 – 我们有所进步，探讨了如何将基本动画扩展以执行更复杂的任务。
- en: In the next section, we'll look at how we can simplify this with the use of
    `UIViewPropertyAnimator`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 `UIViewPropertyAnimator` 来简化这个过程。
- en: Refactoring with UIViewPropertyAnimator
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 UIViewPropertyAnimator 进行重构
- en: So, with some basic animation under your belt, we can now dive a little deeper
    into what iOS has to offer. While our previous code was powerful and not that
    many lines of code, it was in turn quite ugly, with completion handlers inside
    completion handlers – spaghetti code like that can become a real nightmare to
    maintain, especially if you need to build out the animation into anything more
    complex.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在掌握了一些基本的动画之后，我们现在可以深入探讨 iOS 提供了哪些功能。虽然我们之前的代码功能强大，代码行数也不多，但它却相当丑陋，包含嵌套的完成处理程序
    – 这样的代码维护起来可能真的会变成一场噩梦，尤其是如果你需要将动画扩展得更加复杂的话。
- en: 'One reason to favor `UIViewPropertyAnimator` over the implementation you just
    saw is readability. Let''s see what the same bounce animation looks like when
    it''s refactored to use `UIViewPropertyAnimator`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用 `UIViewPropertyAnimator` 而不是你刚刚看到的实现的一个原因是可读性。让我们看看当重构为使用 `UIViewPropertyAnimator`
    时，同样的弹跳动画看起来是什么样子：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, at first glance, you'll see that there appear to be a lot more lines of
    code here than previously, and you're not wrong, but it sure does make for better
    reading and maintainability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，乍一看，您可能会觉得这里的代码行数比之前多得多，您并没有错，但这确实使阅读和维护变得更加容易。
- en: 'With the use of `UIViewPropertyAnimator`, it does exactly as its name describes:
    it allows you to assign your animation to a property that you can then execute
    independently within your function.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UIViewPropertyAnimator`，它确实如其名称所描述的那样：它允许您将动画分配给一个属性，然后您可以在函数中独立执行该属性。
- en: The preceding code is no different than a simplified version of the original
    implementation that we broke down.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与我们对原始实现进行分解的简化版本没有区别。
- en: Go ahead and add this to your code and run your app. You'll notice no difference
    at all to the previous version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到您的代码中并运行您的应用程序。您会发现与之前的版本没有任何区别。
- en: The example code uses a version of `UIViewPropertyAnimator` that accepts a timing
    function to make the final bounce animation livelier. If you look at the sample
    code, the first argument passed to the `UIViewPropertyAnimator` initializer is
    the duration of the animation in seconds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码使用了一个接受计时函数的 `UIViewPropertyAnimator` 版本，以使最终的弹跳动画更加生动。如果您查看示例代码，传递给 `UIViewPropertyAnimator`
    初始化器的第一个参数是动画的持续时间（以秒为单位）。
- en: The second argument controls the timing function. A timing function describes
    how an animation should progress over time. For instance, the `easeIn` option
    describes how an animation starts off at a slow pace and speeds up over time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数控制计时函数。计时函数描述了动画应该如何随时间进行。例如，`easeIn` 选项描述了动画如何以缓慢的速度开始，并随着时间的推移而加速。
- en: 'The following diagram describes some of the most commonly used timing functions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表描述了一些最常用的计时函数：
- en: '![Figure 5.1 – Curve timing function scales'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1 – Curve timing function scales]'
- en: '](img/Figure_5.01_B14717.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.01_B14717.jpg]'
- en: Figure 5.1 – Curve timing function scales
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1 – Curve timing function scales]'
- en: In these graphs, the *horizontal* axis represents the animation's progress.
    For each graph, the animation timeline is described from left to right on the
    *x* axis. The animation's progress is visualized on the *y* axis from bottom to
    top. At the bottom-left point, the animation hasn't started yet. At the right
    of the graph, the animation is completely done. The vertical axis represents time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些图表中，*水平* 轴代表动画的进度。对于每个图表，动画时间线从左到右在 *x* 轴上描述。动画的进度从下到上在 *y* 轴上可视化。在左下角，动画尚未开始。在图表的右侧，动画已经完全完成。垂直轴代表时间。
- en: The final argument that is passed to the `UIViewPropertyAnimator` initializer
    is an optional argument for the animation that you wish to execute. This is quite
    similar to the `UIView.animate` way of doing things; the most significant difference
    is that you can add more animations after creating the animator, meaning that
    `nil` can be passed as the argument for the animations and you can add animations
    you wish to execute at a later time. This is quite powerful because you're even
    allowed to add new animations to `UIViewPropertyAnimator` while an animation is
    running!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `UIViewPropertyAnimator` 初始化器的最后一个参数是您希望执行的动画的可选参数。这与 `UIView.animate` 方式执行事情非常相似；最显著的区别是您可以在创建动画器之后添加更多动画，这意味着动画的参数可以是
    `nil`，您可以在稍后添加您希望执行的动画。这非常强大，因为您甚至可以在动画运行时向 `UIViewPropertyAnimator` 添加新的动画！
- en: The second section in the sample code you saw earlier adds completion closures
    to the animators. The completion closures both receive a single argument. The
    received argument describes at what point in the animation the completion closure
    was called. This property will usually have a value of `.end`, which indicates
    that the animation ended at the end position.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您之前看到的示例代码中的第二个部分添加了完成闭包到动画器中。这两个完成闭包都接收一个单一参数。接收到的参数描述了在动画的哪个点调用了完成闭包。这个属性通常具有
    `.end` 的值，这表示动画在结束位置结束。
- en: However, this isn't always true, because you can finish animations halfway through
    the animation if you desire. You could also reverse an animation, meaning that
    the completion position would be `.start`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是正确的，因为如果您愿意，您可以在动画进行到一半时完成动画。您还可以反转动画，这意味着完成位置将是 `.start`。
- en: Once the completion closure is added, and the property animators are fully configured,
    the final step is to start the animation by calling `startAnimation()` on an animator
    object. Once the `startAnimation()` method is called, the animation begins executing
    immediately. If needed, you can make the animation start with a delay by calling
    `startAnimation(afterDelay:)`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了完成闭包，并且属性动画器完全配置好，最后一步是通过在动画器对象上调用`startAnimation()`来开始动画。一旦调用`startAnimation()`方法，动画就会立即开始执行。如果需要，你可以通过调用`startAnimation(afterDelay:)`来使动画延迟开始。
- en: Now you've got a better understanding of how `UIViewPropertyAnimator` works,
    why don't you try and change over our fade that we added in `DetailViewController`?
    For such a simple piece of code like this, `UIViewPropertyAnimator` is probably
    a little overkill, but it might be good just for fun.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了`UIViewPropertyAnimator`的工作原理，为什么不尝试更改我们在`DetailViewController`中添加的淡入淡出效果呢？对于这样简单的一段代码，`UIViewPropertyAnimator`可能有点过度，但仅仅为了乐趣可能也不错。
- en: In the sample project, I'll include both scenarios and comment the other out
    for reference if you get stuck.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，我会包括这两种场景，并在你需要时注释掉另一个以供参考。
- en: In this section, we took a massive leap into the world of animation in iOS development,
    learning the basic way to just drop in an animation and how to build out more
    complex animation with `UIViewPropertyAnimator` for improved code maintainability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们迈出了巨大的一步，进入了iOS开发中的动画世界，学习了如何简单地添加动画以及如何使用`UIViewPropertyAnimator`构建更复杂的动画，以提升代码的可维护性。
- en: In the next section, we'll take a look at how to control an animation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何控制动画。
- en: Understanding and controlling animation progress
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和控制动画进度
- en: One of the best features of `UIViewPropertyAnimator` is that you can use it
    to create animations that can be interrupted, reversed, or interacted with. Many
    of the animations you see in iOS are interactive animations – for instance, swiping
    on a page to go back to the previous page is an interactive transition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewPropertyAnimator`的最好特性之一是你可以用它来创建可以被中断、反转或与之交互的动画。iOS中你看到的许多动画都是交互式动画——例如，在页面上滑动以返回上一页就是一个交互式过渡。'
- en: Swiping between pages on the home screen, opening the control center, or pulling
    down the notification center are all examples of animations that you manipulate
    by interacting with them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在主屏幕上滑动页面、打开控制中心或下拉通知中心都是通过与之交互来操作的动画的例子。
- en: While the concept of interactive animations might sound complicated, `UIViewPropertyAnimator`
    makes it quite simple to implement them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管交互式动画的概念可能听起来很复杂，但`UIViewPropertyAnimator`使得实现它们变得相当简单。
- en: As an example, you'll see how to implement a drawer on the contact detail page
    in our app. First, you'll prepare the view, so the drawer is partially visible
    in the app. Once the view is all set up, you will write the code to perform an
    interactive show-and-hide animation for the drawer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你将看到如何在我们的应用中实现联系人详情页上的抽屉。首先，你将准备视图，以便抽屉在应用中部分可见。一旦视图全部设置好，你将编写代码以执行抽屉的交互式显示和隐藏动画。
- en: 'Let''s start by heading back over to `Main.storyboard` and doing the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回到`Main.storyboard`并执行以下操作开始：
- en: Add a UIView to our canvas via the object library (make sure this sits on top
    of the parent UIStackView, not inside it).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对象库将一个UIView添加到我们的画布上（确保它位于父UIStackView的顶部，而不是内部）。
- en: Set up Auto Layout constraints to make sure that the drawer view's width is
    equal to the main view's width (trialing and leading both set to `0`).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置自动布局约束以确保抽屉视图的宽度等于主视图的宽度（试行和尾行都设置为`0`）。
- en: Make the view `350pt` in height.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图的高度设置为`350pt`。
- en: Then, set the bottom constraint to `-305`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将底部约束设置为`-305`。
- en: 'This should leave the view just visible enough to cover the safe area at the
    bottom of the screen. Next, we need to add a button to our new view:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会让视图刚好可见，足以覆盖屏幕底部的安全区域。接下来，我们需要在我们的新视图中添加一个按钮：
- en: Add the button via the object library.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对象库添加按钮。
- en: Set the top constraint to be `8pt` from the top of the new view (its parent
    view).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶部约束设置为从新视图（其父视图）顶部`8pt`。
- en: Set the leading and trailing to be around `16pts`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将首行和尾行间距设置为大约`16pts`。
- en: Set the label of the button to `Toggle`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的标签设置为`Toggle`。
- en: Also, set the background to **System Secondary Background Color**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，将背景设置为**系统次要背景颜色**。
- en: 'All going well, you should have something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会有类似以下的内容：
- en: '![Figure 5.2 – Detail view with image view'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 带有图像视图的详细视图]'
- en: '](img/Figure_5.02_B14717.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.02 – 图 5.02_B14717.jpg]'
- en: Figure 5.2 – Detail view with image view
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 带有图像视图的详细视图]'
- en: 'Now that we''ve got the layout sorted, let''s hook up the code we need. Our
    drawer functionality should implement the following features:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了布局，让我们连接所需的代码。我们的抽屉功能应实现以下功能：
- en: Toggle the drawer by tapping on the **Toggle** button.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**切换**按钮来切换抽屉。
- en: Toggle the drawer interactively when swiping on the drawer.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在抽屉上滑动时，交互式地切换抽屉。
- en: Allow the user to tap on the **Toggle** button and then swipe the drawer to
    manipulate or reverse the animation.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户点击**切换**按钮，然后滑动抽屉来操作或反转动画。
- en: Behavior such as this is not straightforward; without `UIViewPropertyAnimator`,
    you would have to write a lot of complex code, and you'd still be pretty far from
    your desired results. Let's see what `UIViewPropertyAnimator` does to make implementing
    this effect manageable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为并不简单；没有 `UIViewPropertyAnimator`，你将不得不编写大量的复杂代码，而且你离期望的结果还相当远。让我们看看 `UIViewPropertyAnimator`
    是如何使实现这种效果变得可管理的。
- en: 'To prepare for the implementation of the drawer, add the following properties
    to `DetailsViewController`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备实现抽屉，请将以下属性添加到 `DetailsViewController` 中：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, add an extension to `DetailsViewController` that holds an `@IBAction`
    for the tap action. `@IBAction` is similar to `@IBOutlet`, but it is used to call
    a particular method in response to a specific user action. An extension is used,
    so it''s easy to group the animation code nicely:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为 `DetailsViewController` 添加一个扩展，其中包含一个用于点击操作的 `@IBAction`。`@IBAction` 与
    `@IBOutlet` 类似，但它用于在响应特定用户操作时调用特定方法。使用扩展，可以很好地组织动画代码：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s connect our outlets:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的输出：
- en: Connect our UIView to the `IBOutlet` we just added in.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 UIView 连接到我们刚刚添加的 `IBOutlet`。
- en: Connect your UIButton to the `IBAction` we just created in the extension.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 UIButton 连接到我们在扩展中刚刚创建的 `IBAction`。
- en: When you drag from the action to the button, a menu appears from which you can
    select the action for which `@IBAction` should trigger. To respond to a button
    tap, choose **Touch Up Inside** from this menu.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从操作拖动到按钮时，会出现一个菜单，你可以从中选择要触发 `@IBAction` 的操作。要响应按钮点击，请从该菜单中选择**触摸内部**。
- en: 'Finally, add the following lines to the end of `viewDidLoad()`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下行添加到 `viewDidLoad()` 的末尾：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, add the following method to the extension you created earlier for `@IBAction`.
    This is the method that is called when the user performs a pan gesture on the
    drawer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将以下方法添加到之前创建的扩展中，用于 `@IBAction`。这是当用户在抽屉上执行平移手势时调用的方法：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that all of the placeholders are implemented, let's create a simple first
    version of the open drawer animation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有占位符都已实现，让我们创建一个简单的打开抽屉动画的第一版本。
- en: 'When the user taps on the toggle button, the drawer should open or close depending
    on the drawer''s current state. The following snippet implements such an animation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击切换按钮时，抽屉应根据抽屉的当前状态打开或关闭。以下代码片段实现了这样的动画：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The animation that is passed to the property animator uses the value of `isDrawerOpen`
    to determine whether the animation should open or close the drawer. When the drawer
    is currently open, it should close, and vice versa.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给属性动画器的动画使用 `isDrawerOpen` 的值来确定动画应该打开还是关闭抽屉。当抽屉当前打开时，它应该关闭，反之亦然。
- en: Once the animation finishes, the `isDrawerOpen` variable is updated to reflect
    the new state of the drawer. To determine the current state, the application reads
    the drawer's current transformation. If the drawer is not transformed, its transformation
    will equal `CGAffineTransform.identity` and the drawer is considered closed. Otherwise,
    the drawer is considered open.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦动画完成，`isDrawerOpen` 变量就会更新以反映抽屉的新状态。为了确定当前状态，应用程序读取抽屉的当前转换。如果抽屉没有转换，其转换将等于
    `CGAffineTransform.identity`，则认为抽屉是关闭的。否则，认为抽屉是打开的。
- en: Go ahead and build and run your app now to see it in action. You'll see just
    how well it works.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就构建并运行你的应用程序，看看它是如何工作的。你会看到它工作得有多好。
- en: Interactions with a pan gesture recognizer
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与平移手势识别器的交互
- en: To allow the user to interrupt or start the animation by dragging their finger
    on the screen, the code must check whether an existing property animator is performing
    an animation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户通过在屏幕上拖动手指来中断或开始动画，代码必须检查是否存在正在执行动画的现有属性动画器。
- en: If no animator exists or if the current animator is not running any animations,
    a new instance of the animator should be created. In all other circumstances,
    it's possible to make use of the existing animator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在动画器或者当前动画器没有运行任何动画，应该创建一个新的动画器实例。在所有其他情况下，都可以利用现有的动画器。
- en: Let's refactor the animator creation code from `toggleDrawerTapped()` so that
    it reuses the animator if possible and creates a new animator if needed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构 `toggleDrawerTapped()` 中的动画器创建代码，以便尽可能重用动画器，并在需要时创建新的动画器。
- en: 'Add the following new function, `setUpAnimation()`, to our extension:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下新函数 `setUpAnimation()` 添加到我们的扩展中：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You''ll notice how we''ve just lifted the majority of the code from `IBAction`
    – now we''ll need to update `IBAction` to call this new function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们刚刚从 `IBAction` 中提取了大部分代码——现在我们需要更新 `IBAction` 以调用这个新函数：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the following implementation for `didPanOnDrawer(recognizer: UIPanGestureRecognizer)`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，为 `didPanOnDrawer(recognizer: UIPanGestureRecognizer)` 添加以下实现：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is called for any change that occurs in the pan gesture recognizer.
    When the pan gesture first starts, the animation is configured, and then `pauseAnimation()`
    is called on the animator object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法会在滑动手势识别器发生任何变化时被调用。当滑动手势第一次开始时，动画被配置，然后在对动画器对象调用 `pauseAnimation()`。
- en: This allows us to change the animation progress based on the user's pan behavior.
    Because the user might begin panning in the middle of the animation – for instance,
    after tapping the toggle button first – the current `fractionComplete` value is
    stored in the `drawerPanStart` variable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们根据用户的滑动行为来改变动画进度。因为用户可能在动画进行中开始滑动——例如，在先点击切换按钮之后——当前 `fractionComplete`
    的值将被存储在 `drawerPanStart` 变量中。
- en: The value of `fractionComplete` is a value between `0` and `1` and it's decoupled
    from the time that your animation takes to run. So, imagine that you are using
    an ease-in and ease-out timing parameter to animate a square from an *x* value
    of `0` to an *x* value of `100`. The *x* value of `10` is not at `10%` of the
    time the animation takes to complete.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`fractionComplete` 的值是一个介于 `0` 和 `1` 之间的值，它与你的动画运行时间解耦。所以，想象一下你正在使用一个缓动进入和缓动退出时间参数来动画一个从
    *x* 值为 `0` 到 *x* 值为 `100` 的正方形。*x* 值为 `10` 并不是动画完成所需时间的 `10%`。'
- en: However, `fractionComplete` will be `0.1`, which corresponds to the animation
    being `10%` complete. This is because `UIViewPropertyAnimator` converts the timescale
    for your animation to linear once you pause it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`fractionComplete` 将是 `0.1`，这对应于动画完成 `10%`。这是因为 `UIViewPropertyAnimator`
    在暂停动画后会将你的动画时间尺度转换为线性。
- en: Usually, this is the best behavior for an interactive animation. However, you
    can change this behavior by setting the `scrubsLinearly` property on your animator
    to `false`. If you do this, `fractionComplete` will take any timing parameters
    you've applied into account.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是交互式动画的最佳行为。然而，你可以通过将你的动画器的 `scrubsLinearly` 属性设置为 `false` 来改变这种行为。如果你这样做，`fractionComplete`
    将考虑你应用的所有时间参数。
- en: You can try playing around with this to see what it feels like for the drawer
    animation. Once the initial animation is configured and paused, the user can move
    their finger around.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试玩一下这个，看看抽屉动画的感觉如何。一旦初始动画配置并暂停，用户可以移动手指。
- en: When this happens, the `fractionComplete` property is calculated and set on
    the animator by taking the distance traveled by the user's finger and dividing
    it by the total distance required. Next, the progress made by the animation before
    being interrupted is added to this new value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，通过将用户手指移动的距离除以总距离来计算并设置在动画器上的 `fractionComplete` 属性。然后，将中断前的动画进度添加到这个新值中。
- en: Finally, if the gesture ends, it gets canceled, or anything else, the start
    position is reset. Also, a timing parameter to use for the rest of the animation
    is configured and the animation is set up to continue. Bypassing a `durationFactor`
    value of `0`, the animator knows to use whatever time is left for the animation
    while taking into account its new timing function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果手势结束、被取消，或者发生其他任何情况，起始位置将被重置。同时，配置了一个用于剩余动画的时间参数，并将动画设置为继续进行。跳过 `durationFactor`
    值为 `0`，动画师知道在考虑其新的时间函数的同时，使用剩余的任何时间进行动画。
- en: If the user tapped the toggle button to close the drawer, yet they catch it
    mid-animation and swipe upward, the animation should finish in the upward direction.
    The last couple of lines take care of this logic.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在动画中途点击切换按钮关闭抽屉，然后向上滑动，动画应该向上完成。最后几行处理了这个逻辑。
- en: There is no right or wrong way of creating your perfect animation. Have a play
    around with the various values that feel right for you and your app. In this section,
    we took everything we learned about animations a step further by looking at how
    we can control animations via either an event action such as a UIButton toggle
    or via a user gesture interaction.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完美的动画没有正确或错误的方法。尝试调整您和您的应用感觉合适的各种值。在本节中，我们通过查看如何通过事件动作（如UIButton切换）或用户手势交互来控制动画，将我们关于动画所学的所有内容进一步深化。
- en: In the next section, we'll start to add some real vibrancy to our animation
    by looking at how we can add some spring and bounce to our app!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过查看如何为我们的应用添加一些弹簧和弹跳来为我们的动画增添一些真正的活力！
- en: Adding vibrancy to animations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为动画添加活力
- en: A lot of animations on iOS look bouncy and feel natural. For instance, when
    an object starts moving in the real world, it rarely does so smoothly. Often,
    something moves because something else applied an initial force to it, causing
    it to have a certain momentum. Spring animations help you to apply this sort of
    real-world momentum to your animations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 许多iOS动画看起来有弹跳感，感觉自然。例如，当物体在现实世界中开始移动时，它很少是平滑的。通常，某物移动是因为其他物体对其施加了初始力，使其具有某种动量。弹簧动画帮助您将这种现实世界的动量应用到动画中。
- en: Spring animations are usually configured with an initial speed. This speed is
    the momentum an object should have when it begins moving. All spring animations
    require damping to be set on them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧动画通常配置了初始速度。这个速度是物体开始移动时应该具有的动量。所有弹簧动画都需要设置阻尼。
- en: The value of this property specifies how much an object can overflow its target
    value. A smaller damping value will make your animation feel bouncier because
    it will float around its end value more drastically.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性的值指定了一个对象可以超出其目标值多少。较小的阻尼值会使动画感觉更有弹跳性，因为它会在其结束值周围更剧烈地浮动。
- en: The easiest way to explore spring animations is by slightly refactoring the
    animation you just created for the drawer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 探索弹簧动画的最简单方法是对您为抽屉创建的动画进行轻微重构。
- en: 'Instead of using an `easeOut` animation when a user taps the `setUpAnimation()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`setUpAnimation()`时，不要使用`easeOut`动画：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you implement a spring animation, you use a special initializer for `UIViewPropertyAnimator`.
    Since you can't pass animations to this initializer, you must add them by calling
    `addAnimations(_:)`. Adding spring animations did not require a considerable code
    change, but try running the app and tapping on the toggle button. The drawer will
    now feel more realistic because its animation curve is not as static as it was
    before.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您实现弹簧动画时，您使用`UIViewPropertyAnimator`的特殊初始化器。由于您不能将动画传递给此初始化器，您必须通过调用`addAnimations(_:)`来添加它们。添加弹簧动画不需要大量的代码更改，但尝试运行应用并点击切换按钮。抽屉现在感觉更真实，因为其动画曲线不再像之前那样静态。
- en: Play around with the values for the spring damping and the velocity. If you
    use some extreme values, you'll get interesting results. Keep in mind that the
    damping should be a value between `0` and `1` and that a value closer to `1` will
    make your animation bounce less.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整弹簧阻尼和速度的值。如果您使用一些极端值，您将得到有趣的结果。请记住，阻尼应该是一个介于`0`和`1`之间的值，并且接近`1`的值会使动画的弹跳性更小。
- en: The animation that is executed by the pan recognizer doesn't feel great at this
    point. It's very static and doesn't take into account how fast a user is panning
    on the drawer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由平移识别器执行动画在此阶段感觉并不好。它非常静态，没有考虑到用户在抽屉上平移的速度。
- en: When the user ends their pan gesture, you can set the sprint timing's `initialVelocity`
    value based on the actual pan velocity. This will make the animation feel even
    more realistic because it will now use the actual pan speed as the initial speed
    for animation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户结束他们的平移手势时，您可以根据实际的平移速度设置弹簧时序的`initialVelocity`值。这将使动画感觉更加真实，因为它现在将实际的平移速度作为动画的初始速度。
- en: 'Update the default case statement with the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新默认情况语句：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you've just seen, the use of spring animations can benefit your animations
    and they are not very hard to add to your apps. While they might not always be
    the best solution, their ease of implementation makes spring animations a worthy
    candidate to experiment with to determine whether your animation needs a spring.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用弹簧动画可以改善你的动画，而且它们并不难添加到你的应用中。虽然它们可能并不总是最好的解决方案，但它们的易于实现使得弹簧动画成为实验动画是否需要弹簧的一个值得尝试的候选者。
- en: While the animation you have just implemented is pretty lifelike and realistic,
    your animations might need even more realism. The next section covers UIKit Dynamics,
    which is a special method of animating objects that uses a physics engine and
    can detect collisions between objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现的动画相当逼真和真实，但你的动画可能需要更多的真实性。下一节将介绍UIKit Dynamics，这是一种使用物理引擎并能够检测对象之间碰撞的特殊动画方法。
- en: Adding dynamism with UIKit Dynamics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UIKit Dynamics添加动态效果
- en: Most apps implement simple animations, such as the ones you've seen so far in
    this chapter. However, some animations might need a little more realism – this
    is what UIKit Dynamics is for.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用实现简单的动画，就像你在本章中看到的那样。然而，一些动画可能需要更多的真实性——这就是UIKit Dynamics的作用。
- en: With UIKit Dynamics, you can place one or more views in a scene that uses a
    physics engine to apply certain forces to the views it contains. For instance,
    you can apply gravity to a particular object, causing it to fall off the screen.
    You can even have objects bumping into each other, and if you assign a mass to
    your views, this mass is taken into account when two objects crash into each other.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UIKit Dynamics，你可以在使用物理引擎的场景中放置一个或多个视图，并对其包含的视图施加某些力。例如，你可以给一个特定的对象施加重力，使其从屏幕上掉落。你甚至可以让对象相互碰撞，如果你给你的视图分配一个质量，当两个对象相撞时，这个质量会被考虑进去。
- en: When you apply a certain force to an object with very little mass, it will be
    displaced more than an object with a lot of mass, just like you would expect in
    the real world.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给一个质量非常小的对象施加一定的力时，它会被移动得比质量大的对象更多，就像你在现实世界中预期的那样。
- en: For this, we're going to create another little project away from our current
    app, so we can perform some physics experiments.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在当前应用之外创建另一个小项目，这样我们就可以进行一些物理实验。
- en: 'So, let''s get started by creating a new project in Xcode:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从在Xcode中创建一个新的项目开始：
- en: Create a new project and call it `Dynamics`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并将其命名为`Dynamics`。
- en: In `Main.Storyboard`, configure the preview to **Landscape**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main.Storyboard`中，将预览配置为**横幅**。
- en: Add three UIViews around `100 x 100` in size (don't worry about constraints
    for this project).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个大小约为`100 x 100`的UIView（对于这个项目，不用担心约束）。
- en: Give each UIView a background color (think systems colors from [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066),
    *Using Lists and Tables*).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给每个UIView设置一个背景颜色（想想来自[*第3章*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066)，*使用列表和表格*的颜色）。
- en: 'All going well, it should look something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它应该看起来像这样：
- en: '![Figure 5.3 – Main storyboard with views'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Main storyboard with views'
- en: '](img/Figure_5.03_B14717.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.03_B14717.jpg]'
- en: Figure 5.3 – Main storyboard with views
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 主故事板中的视图
- en: Next, add instances of `@IBOutlet` in `ViewController.swift` for the views you
    just added and connect them to the storyboard in the same way you did before.
    You can name the outlets anything you like, but I'll name mine `ball1`, `ball2`,
    and `ball3` (more on that later).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`ViewController.swift`中为刚刚添加的视图添加`@IBOutlet`实例，并以与之前相同的方式将它们连接到故事板中。你可以将出口命名为任何你喜欢的名字，但我会将我的命名为`ball1`、`ball2`和`ball3`（关于这一点稍后会有更多说明）。
- en: The simplest thing you can implement at this point is to set up a scene that
    contains the three squares and apply some gravity to them. This will cause the
    squares to fall off the screen because they'll start falling once gravity is applied,
    and there is no floor to stop the squares from dropping off the screen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你可以实施的最简单的事情就是设置一个包含三个正方形的场景，并给它们施加一些重力。这将导致正方形从屏幕上掉落，因为一旦施加重力，它们就会开始下落，而且没有地板来阻止正方形掉出屏幕。
- en: 'To set up a scene like the one described here, add the following highlighted
    code to your `ViewController.swift` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个如上所述的场景，请将以下突出显示的代码添加到你的`ViewController.swift`文件中：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you test your app now, you'll notice that your views start falling immediately.
    Setting up a simple scene such as this is easy with UIKit Dynamics.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试你的应用，你会注意到你的视图立即开始下落。使用UIKit Dynamics设置这样一个简单的场景很容易。
- en: The downside of this simple example is that it's not particularly interesting
    to look at. Before you add features to make this sample more interesting, let's
    see what the preceding four lines of code do.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单示例的缺点是它并不特别有趣。在你添加功能使这个示例更有趣之前，让我们看看前面四行代码的作用。
- en: The views in a dynamic scene must be of the `UIDynamicItem` type. A UIView can
    be used as `UIDynamicItem`, so by adding them to a list that has `[UIDynamicItem]`
    works automatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 动态场景中的视图必须是`UIDynamicItem`类型。UIView可以用作`UIDynamicItem`，因此通过将它们添加到具有`[UIDynamicItem]`的列表中，它们会自动工作。
- en: Then, we create an instance of `UIDynamicAnimator` and you tell it the view
    to which it will apply its physics engine. The last step is to configure and apply
    a behavior. This example uses `UIGravityBehavior` but there are several other
    behaviors you can use in your scenes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`UIDynamicAnimator`的实例，并告诉它将应用其物理引擎的视图。最后一步是配置并应用一个行为。这个例子使用`UIGravityBehavior`，但你的场景中还可以使用其他几种行为。
- en: For instance, you can create `UIAttachmentBehavior` to attach an item to another
    item or to some point on the screen.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建`UIAttachmentBehavior`将一个项目附加到另一个项目或屏幕上的某个点上。
- en: 'The following code implements an attachment behavior for every square on the
    screen and attaches it to the top of the screen. This will cause the squares to
    fall for a moment, and then they will bounce and swing a little until they eventually
    come to a standstill. You can add the following code to `viewDidLoad()` to implement
    this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为屏幕上每个方块实现了附加行为，并将其附加到屏幕顶部。这将导致方块暂时下落，然后它们会弹跳并轻微摆动，直到最终静止。您可以将以下代码添加到`viewDidLoad()`中以实现此功能：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every square is set up with a slightly different attachment point in this example.
    Note that the attachment behavior has a `damping` property.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个方块都设置了略微不同的附加点。请注意，附加行为有一个`damping`属性。
- en: This damping is similar to the damping that is used in spring animations. Try
    experimenting with the value for `attachment.damping` to see what it does.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种阻尼与弹簧动画中使用的阻尼类似。尝试调整`attachment.damping`的值，看看它会产生什么效果。
- en: If you run the app now, you'll notice that every square is attached to an invisible
    point on the screen that keeps it from falling. Some things are still missing
    though.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会注意到每个方块都附着在屏幕上的一个看不见的点，防止它们下落。尽管如此，还有一些东西是缺失的。
- en: The squares can now simply cross over each other – how cool would it be if they
    bumped into each other instead?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方块可以简单地相互交叉——如果它们相互碰撞会怎么样，那会多么酷？
- en: 'To do this, add the following line of code to `viewDidLoad()`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请将以下代码行添加到`viewDidLoad()`中：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Are you convinced that UIKit Dynamics is cool yet? I thought so; it's amazing
    how much you can do with just a little bit of code. Let's add some mass to the
    squares and make them more elastic to see whether this has any effect on how the
    squares collide.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你相信UIKit Dynamics很酷吗？我也这么认为；代码如此之少就能做到这么多真是太神奇了。让我们给方块添加一些质量，使它们更具弹性，看看这会对方块碰撞有什么影响。
- en: 'Update your `for` loop with the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的`for`循环：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code should augment what you already have in the loop; it shouldn't
    replace the existing logic.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该增强你已经在循环中拥有的内容；它不应该替换现有的逻辑。
- en: By setting `density` on `UIDynamicItemBehavior`, the engine can derive the mass
    of an item. This will change how the physics engine treats the item when it collides
    with another item.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`UIDynamicItemBehavior`上设置`density`，引擎可以推导出项目的质量。这将改变物理引擎在项目与其他项目碰撞时如何处理该项目。
- en: Again, this is a perfect time for you to go away and have a play with the behaviors
    and physics engine that Apple has provided. Now, a swinging square game might
    not be of interest to anyone – but update each of your ball properties to the
    following and run again…a lot more fun now, right?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是你远离Apple提供的行为和物理引擎去玩耍的绝佳时机。现在，一个摆动方块游戏可能对任何人都没有兴趣——但将你的球属性更新如下并再次运行……现在是不是更有趣了？
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the final section, we will learn everything we need to know about view controller
    transitions, again another way to really make a difference when moving away from
    the default behavior of our app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将学习关于视图控制器转换所需了解的一切，这又是另一种真正改变我们应用程序默认行为的方法。
- en: Customizing view controller transitions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义视图控制器转换
- en: Implementing a custom view controller transition is one of those things that
    can take a little while to get used to. Implementing custom transitions involves
    implementing several objects, and it's not always easy to make sense of how this
    works. This section aims to explain exactly how custom view controller transitions
    work so that you can add one more powerful tool to your developer toolbox.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义视图控制器过渡是那些需要一段时间才能习惯的事情之一。实现自定义过渡涉及实现多个对象，而且并不总是容易理解其工作原理。本节旨在详细解释自定义视图控制器过渡是如何工作的，以便您可以将另一个强大的工具添加到您的开发者工具箱中。
- en: A nicely implemented custom view controller transition will entertain and amaze
    your users. Making your transitions interactive could even ensure that your users
    spend some extra time playing around with your app, which is exactly what you
    want.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实现良好的自定义视图控制器过渡将使您的用户感到愉快并感到惊讶。使您的过渡交互式甚至可以确保您的用户在您的应用中花费更多时间玩耍，这正是您想要的。
- en: We'll continue by working on our Contacts app we started earlier on. Firstly,
    you'll learn how you can implement a custom modal transition. Once you've implemented
    that, you will learn about custom transitions for `UINavigationController` so
    that you can show and hide the contact details page with a custom transition.
    The dismissal of both the modal view controller and the contact detail page will
    be interactive, so users can swipe to go back to where they came from.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续处理我们之前开始的联系人应用。首先，您将了解您如何实现自定义模态转换。一旦实现了这个，您将了解 `UINavigationController`
    的自定义过渡，这样您就可以使用自定义过渡显示和隐藏联系人详情页面。模态视图控制器和联系人详情页面的关闭都将交互式，这样用户可以滑动返回到他们来的地方。
- en: 'In this section, you will work through the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将完成以下步骤：
- en: Implement a custom modal presentation transition.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个自定义的模态显示过渡。
- en: Make the transition interactive.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使过渡交互式。
- en: Implement a custom `UINavigationController` transition.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个自定义的 `UINavigationController` 过渡。
- en: Implementing a custom modal presentation transition
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义模态显示过渡
- en: A lot of applications implement modally presented view controllers. A modally
    presented view controller is typically a view controller that is presented on
    top of the current screen as an overlay. By default, modally presented view controllers
    animate upward from the bottom of the screen and are often used to present forms
    or other temporary content to the user. In this section, you'll take a look at
    the default modal presentation transition and how to customize it to suit your
    own needs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序实现了模态显示的视图控制器。一个模态显示的视图控制器通常是一个覆盖在当前屏幕上的视图控制器。默认情况下，模态显示的视图控制器从屏幕底部向上动画，通常用于向用户展示表单或其他临时内容。在本节中，您将了解默认的模态显示过渡以及如何自定义它以满足您的需求。
- en: 'Let''s start by creating a brand new View Controller. For this, we''ll head
    back to our Contacts app project where we can add this in here (or feel free to
    start a brand-new project):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个全新的视图控制器开始。为此，我们将回到我们的联系人应用项目，我们可以在那里添加这个功能（或者您可以自由地开始一个新的项目）：
- en: Create a new `TransitionViewController` (with a subclass of `UIViewController`).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `TransitionViewController`（`UIViewController` 的子类）。
- en: Add a new View Controller to `Main.Storyboard`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Main.Storyboard` 中添加一个新的视图控制器。
- en: Set the object class for that new View Controller to be `TransitionViewController`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将那个新视图控制器的对象类设置为 `TransitionViewController`。
- en: Once you've done that, we'll add a bar button item to our existing navigation
    so that we can present our modal.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成这些后，我们将在现有的导航中添加一个条形按钮项，以便我们可以展示模态。
- en: Add `BarButtonItem` from our object library to our navigation bar in `rootViewContoller`
    (basically our first view controller).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的对象库中添加 `BarButtonItem` 到 `rootViewContoller` 的导航栏中（基本上是我们的第一个视图控制器）。
- en: Set the button's text to be `Show Modal` (or whatever you want).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的文本设置为 `Show Modal`（或您想要的任何文本）。
- en: Now, press *Ctrl* and drag the bar button item's connector to the new view controller
    we just created.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按 *Ctrl* 并将条形按钮项的连接器拖到我们刚刚创建的新视图控制器上。
- en: When presented with options, choose **Present Modally**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现选项时，选择**以模态方式显示**。
- en: 'All going well, it should look like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它应该看起来像以下这样：
- en: '![Figure 5.4 – Modal action segue'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 模态动作转换'
- en: '](img/Figure_5.04_B14717.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B14717.jpg)'
- en: Figure 5.4 – Modal action segue
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 模态动作转换
- en: Finally, give our new view controller a system orange background color, so it
    will be easier to see the transition later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给我们的新视图控制器一个系统橙色背景色，这样在稍后观察过渡时会更清晰。
- en: If you run your app now, you can click on the **Show Modal** button and you'll
    see an empty view controller pop up from the bottom.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用，你可以点击**显示模态**按钮，你将看到一个空视图控制器从底部弹出。
- en: Until iOS 13, you had to create an interface in order for the user to dismiss
    a modal. Now, unless implicitly set, you can just swipe down to dismiss a modal,
    which is worth bearing in mind when developing apps that go further back than
    iOS 13.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 13之前，你必须创建一个界面，以便用户可以关闭模态。现在，除非隐式设置，否则你可以直接向下滑动来关闭模态，这在开发iOS 13之前的旧应用时值得注意。
- en: Custom view controller transitions use several objects to facilitate the animation.
    The first object you will look at is `transitioningDelegate` for `UIViewController`.
    The `transitioningDelegate` property is responsible for providing an animation
    controller that provides the custom transition.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义视图控制器过渡使用几个对象来简化动画。你首先需要查看的是`UIViewController`的`transitioningDelegate`。`transitioningDelegate`属性负责提供提供自定义过渡的动画控制器。
- en: The animation controller uses a transitioning context object that provides information
    about the view controllers that are involved in the transition. Typically, these
    view controllers will be the current view controller and the view controller that
    is about to be presented.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器使用一个提供有关参与过渡的视图控制器信息的过渡上下文对象。通常，这些视图控制器将是当前视图控制器和即将被展示的视图控制器。
- en: 'A transitioning flow can be described in the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用以下步骤描述过渡流程：
- en: A transition begins. The target view controller is asked for `transitioningDelegate`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个过渡开始了。目标视图控制器被要求提供`transitioningDelegate`。
- en: '`transitioningDelegate` is asked for an animation controller.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transitioningDelegate`被要求提供一个动画控制器。'
- en: The animation controller is asked for the animation duration.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画控制器被要求提供动画持续时间。
- en: The animation controller is told to perform the animation.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画控制器被告知执行动画。
- en: When the animation is complete, the animation controller calls `completeTransition(_:)`
    on the transitioning context to mark the animation as completed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画完成后，动画控制器会在过渡上下文中调用`completeTransition(_:)`来标记动画已完成。
- en: 'If *step 1* or *step 2* return `nil`, or aren''t implemented at all, the default
    animation for the transition is used. The objects involved in a custom transition
    are displayed in the following diagram:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*步骤1*或*步骤2*返回`nil`，或者根本未实现，则使用默认的过渡动画。涉及自定义过渡的对象在以下图中显示：
- en: '![Figure 5.5 – Animation transition flow'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 动画过渡流程]'
- en: '](img/Figure_5.05_B14717.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.05_B14717.jpg]'
- en: Figure 5.5 – Animation transition flow
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.5 – 动画过渡流程
- en: Creating a separate object to control the animation is often a good idea because
    it allows you to reuse a transition and it keeps your code nice and clean. The
    animation controller should be an object that conforms to `UIViewControllerAnimatedTransitioning`.
    This object will take care of animating the presented view onto the screen.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单独的对象来控制动画通常是一个好主意，因为它允许你重用过渡，并保持你的代码整洁。动画控制器应该是一个符合`UIViewControllerAnimatedTransitioning`的对象。此对象将负责将展示的视图动画化到屏幕上。
- en: 'Let''s create the animation controller object next:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建动画控制器对象：
- en: Create a new `CustomAnimator` (using `NSObject` as a subclass).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`CustomAnimator`（使用`NSObject`作为子类）。
- en: 'Add the following extension in order to make the class conform to `UIViewControllerAnimatedTransitioning`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下扩展，以便使类符合`UIViewControllerAnimatedTransitioning`：
- en: '[PRE23]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This makes the new class conform to the protocol that's required to be an animation
    controller. Xcode will show a build error because you haven't implemented all
    the methods to conform to `UIViewControllerAnimatedTransitioning` yet.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使得新类符合成为动画控制器所需的协议。Xcode会显示构建错误，因为你还没有实现所有方法以符合`UIViewControllerAnimatedTransitioning`。
- en: Let's go over the methods one by one so that you end up with a full implementation
    for the animation controller.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些方法，以便你最终为动画控制器获得完整的实现。
- en: 'The first method that must be implemented for the animation controller is `transitionDuration(using:)`.
    The implementation of this method is shown here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 必须为动画控制器实现的第一方法是`transitionDuration(using:)`。此方法的实现如下所示：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method is used to determine the total transition duration in seconds. In
    this case, the implementation is simple – the animation should last *0.6* seconds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于确定总的过渡持续时间（以秒为单位）。在这种情况下，实现很简单——动画应该持续*0.6*秒。
- en: The second method that needs to be implemented is `animateTransition(using:)`.
    Its purpose is to take care of the actual animation for the custom transition.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的第二个方法是 `animateTransition(using:)`。它的目的是处理自定义过渡的实际动画。
- en: This implementation will take the target view controller and its view will be
    animated from the top of the screen downward to its final position. It will also
    do a little bit of scaling, and the opacity of the view will be animated; to do
    this, `UIViewPropertyAnimator` will be used.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将目标视图控制器从屏幕顶部向下动画到其最终位置。它还将进行一些缩放，并动画视图的不透明度；为此，将使用 `UIViewPropertyAnimator`。
- en: 'Add the following implementation to the animator:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 向动画器添加以下实现：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A lot is going on in the preceding code snippet. Let''s go through the code
    step by step to see what''s happening:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段中发生了很多事情。让我们一步一步地分析代码，看看发生了什么：
- en: The target view controller is extracted from the transition context. This allows
    you to use the view controller's view in the animation that you're about to perform.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从过渡上下文中提取目标视图控制器。这允许您在即将执行的动画中使用视图控制器视图。
- en: Obtain the animation's container view. The container view is a regular UIView
    and it is intended to contain all the animated views.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取动画的容器视图。容器视图是一个常规的 UIView，它旨在包含所有动画视图。
- en: Prepare the target view controller's view for the animation. The view is transformed,
    so it's off the screen, and transparency is set to make the view completely transparent.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备目标视图控制器视图以进行动画。视图被转换，因此它离开了屏幕，透明度被设置为使视图完全透明。
- en: Once the view is prepared, it is added to the container view.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦视图准备就绪，它就被添加到容器视图中。
- en: The animations are set up and added to a property animator.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画被设置并添加到属性动画器中。
- en: The completion handler for the property animator is configured, so `completeTransition(_:)`
    is called on the context. The `transitionWasCancelled` variable is used to determine
    whether the animation completed normally.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性动画器的完成处理程序被配置，因此当动画正常完成时，会在上下文中调用 `completeTransition(_:)`。`transitionWasCancelled`
    变量用于确定动画是否正常完成。
- en: Start the property animator so that the animations begin.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动属性动画器，以便动画开始。
- en: Now that the animation controller is complete, the `UIViewControllerTransitioningDelegate`
    protocol should be implemented on `TransitionViewController` so that it can act
    as its own `transitioningDelegate`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动画控制器已完成，应在 `TransitionViewController` 上实现 `UIViewControllerTransitioningDelegate`
    协议，以便它可以充当自己的 `transitioningDelegate`。
- en: 'Open the file and add the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件并添加以下代码：
- en: '[PRE26]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add the following code to `TransitionViewController`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到 `TransitionViewController` 中：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code adds conformance to the `UIViewControllerTransitioningDelegate` protocol
    and assigns the view controller as its own transitioning delegate. The `animationController(forPresented:presenting:source:)`
    method returns the animation controller you created before. The `animationController(forDismissed:)`
    method returns `nil` for now.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了对 `UIViewControllerTransitioningDelegate` 协议的遵守，并将视图控制器指定为其自己的过渡代理。`animationController(forPresented:presenting:source:)`
    方法返回您之前创建的动画控制器。`animationController(forDismissed:)` 方法目前返回 `nil`。
- en: Go ahead and test your custom transition! This is all the code required to create
    a custom display transition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，测试您的自定义过渡！创建自定义显示过渡所需的全部代码都在这里。
- en: In this chapter, we learned loads about how to fine-tune and polish off our
    app. Visual effects play such a big part in any application – so learning about
    animations transitions is an absolute must for any iOS developer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何精细调整和润色我们的应用。视觉效果在任何应用中都扮演着如此重要的角色——因此，了解动画过渡对于任何 iOS 开发者来说都是绝对必须的。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took the solid core of our Contacts app and decorated it
    with animations and vibrancy. We started by learning the basics of animation and
    how a couple of lines of code could make a massive difference. We then took this
    a step further and refactored more complex code to make it not only maintainable
    but also easier to understand.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们用动画和活力装饰了我们的联系人应用的核心。我们首先学习了动画的基础知识以及几行代码如何带来巨大的变化。然后，我们更进一步，重构了更复杂的代码，使其不仅易于维护，而且更容易理解。
- en: UIKit offers much more than just fancy animations. Looking at dynamics, we saw
    how we could apply physics to even a UIView to give us an app with a truly awesome
    experience.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit 提供的不仅仅是花哨的动画。从动态学的角度来看，我们看到了如何将物理应用到 UIView 上，从而为我们的应用带来真正令人惊叹的体验。
- en: Finally, we looked at transitions, something that is very powerful in iOS development,
    yet something we take so easily for granted. We created a custom class that allowed
    us to create our very own modal transition.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了过渡效果，这在 iOS 开发中非常强大，但我们却常常轻易地将其视为理所当然。我们创建了一个自定义类，使我们能够创建我们自己的模态过渡效果。
- en: In the next chapter, we're going to delve a little deeper into the Swift programming
    language and learn all about Swift's type system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 Swift 编程语言，并了解 Swift 的类型系统。
