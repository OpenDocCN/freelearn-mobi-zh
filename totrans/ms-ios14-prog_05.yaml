- en: '*Chapter 5*: Immersing Your Users with Animation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your app is starting to look really good now, and we've certainly covered a
    lot of ground already in this first few chapters, but UIKit has a lot of amazing
    features we're yet to explore – one of them being animations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn some advanced techniques with UIKit,
    Apple's animation framework built right into UIKit. We'll start off with the basics
    of how the little things can make such a massive difference, and then move forward
    on to some more advanced techniques with `UIViewPropertyAnimator` and how it provides
    more control over your animations than the animations you implemented in previous
    chapters. You'll also learn about UIKit Dynamics. UIKit Dynamics can be used to
    make objects react to their surroundings by applying physics.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you'll learn how to implement a custom transition when moving from
    one view controller to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `UIView.animate` and `UIViewPropertyAnimator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vibrant animations using springs in UIKit Dynamics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing view controller transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    AppStore.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for `Xcode` in the App Store and select and download the latest
    version. Launch Xcode and follow any additional installation instructions that
    your system may prompt you with. Once Xcode has fully launched, you're ready to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Using UIView.animate and UIViewPropertyAnimator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I said in the intro, we've come a long way so far with our app, but often,
    it's the little things that we can do that make a massive difference; you just
    need to take another look at [*Chapter 2*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046),
    *Working with Dark Mode*, to appreciate that.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to start by adding some basic animations to our
    app using the standard practice to achieve a simple yet effective result.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've done that, we'll look at how we can take this much further by refactoring
    and improving the maintainability of our code base. So, let's get started as we
    add our first animation to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In their most basic form, animations are simple and easy to use. Here is an
    example of a typical animation that could be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, what does this mean exactly? Well, the `UIView.animate` function (which
    itself is a closure) is setting the alpha of our cell property to `1.0`. If we
    assume that the alpha for this property was set to `0.0`, our `animate` function
    would, over the duration of `0.8` seconds, change the alpha from `0.0` to `1.0`
    – thus giving us a simple yet extremely effective fade-in effect!
  prefs: []
  type: TYPE_NORMAL
- en: Let's put this into action, continuing with our project from the previous chapter.
    Head on over to our `DetailsViewController.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s set our contact image to have an alpha of `0.0`. We can achieve
    this by extending our outlet property to include a `didSet`. Make the following
    highlighted changes in the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've simply added a setter and set an additional property on our `UIImageView`
    – in this case, we've set the alpha to be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back into the body of our view controller. Add the following to your `viewWillAppear()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just as we saw in the earlier example, we're simply setting a duration for the
    animation, and inside the closure, we set the alpha value of our property.
  prefs: []
  type: TYPE_NORMAL
- en: Go on and run your code in the simulator; you'll see that when `DetailsViewController`
    now loads, you'll get a nice little fade-in animation. With just a slight tweak
    to a property and couple of lines of code, your app has made a massive jump forward!
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take this another step further now and add a bounce effect to `UICollectionViewCell`
    when it's tapped.
  prefs: []
  type: TYPE_NORMAL
- en: Head on over to our view controller and locate the `didSelectItemAt:` function.
    Remember back in [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066),
    *Using Lists and Tables*, when we identified how we could grab an instance of
    the currently selected cell, should we want to do anything with it? Well, here's
    our chance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the start of the `didSelectItemAt:` cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `cellForItem:`, where we make use of the `re-us` identifier in order
    to recycle the use of our cells, here we care only about the selected instance
    – this is the cell we want to use and do something with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to add a big chunk of "initially" potentially confusing
    code, so we''ll break it down first one step at a time. Just underneath the preceding
    code, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're extending the `.animate` function we saw earlier, but this time
    you see we've got a parameter for a delay, which we've set to `0` as we want the
    animation to start straight away (but I guess it's nice to know that we could
    delay it if we wanted to).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we've now got an `options` parameter, where we can pass in an array of
    animation options available to use through UIKit. Here, we're going to pass in
    `curveEaseOut` (don't worry, we'll cover the different types of animation options
    later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the transform of our image view by setting `CGAffineTransform`
    to a specific *x* and *y* scale. By setting a transform on the image, we are effectively
    scaling the original size based on a new *x* and *y* value.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead, launch the app – what do you see? Hopefully not a great deal – and
    you'll be wondering why not too. That's because we still have our `performSegue`
    call in there that is being called (and performed) before our animation can complete.
    Comment that out for the moment and try again. With any luck, when you tap on
    the cell, you should see the contact image shrink in size (or give a de-pressed
    appearance).
  prefs: []
  type: TYPE_NORMAL
- en: So, before we worry about bringing back our `performSegue` call, let's get the
    animation looking right first. Our new animation block has another trick up its
    sleeve. Within the closure, we can add a completion handler that will get called
    as soon as the animation has finished (I know what you're thinking, but let's
    finish the animation first).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code with the following highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all we''ve done here is extend our completion handler for our initial animate
    function by adding `completion: { finished in` and added in another animation
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Back inside that closure, we reset the transform on our image view by setting
    it to `CGAffineTransform.identity` (a nice easy way to quickly revert any transform
    to its original state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app now in the simulator and all is going well; you should be presented
    with a really nice bounce effect. Let''s add the last piece of the puzzle back
    in now by again extending our second animate function to have a completion handler,
    where we will add back in `performSegue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run your app again to see your beautiful animation in full bloom, followed by
    an immediate segue to `DetailViewController` – where you will be presented with
    a subtle yet effective fade-in animation of your contact image. Well done, you've
    done great!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to tackle a basic animation in UIKit – we
    advanced a little, looking at how our basic animation could be extended to perform
    a little more complex task.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how we can simplify this with the use of
    `UIViewPropertyAnimator`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring with UIViewPropertyAnimator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, with some basic animation under your belt, we can now dive a little deeper
    into what iOS has to offer. While our previous code was powerful and not that
    many lines of code, it was in turn quite ugly, with completion handlers inside
    completion handlers – spaghetti code like that can become a real nightmare to
    maintain, especially if you need to build out the animation into anything more
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason to favor `UIViewPropertyAnimator` over the implementation you just
    saw is readability. Let''s see what the same bounce animation looks like when
    it''s refactored to use `UIViewPropertyAnimator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, at first glance, you'll see that there appear to be a lot more lines of
    code here than previously, and you're not wrong, but it sure does make for better
    reading and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the use of `UIViewPropertyAnimator`, it does exactly as its name describes:
    it allows you to assign your animation to a property that you can then execute
    independently within your function.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is no different than a simplified version of the original
    implementation that we broke down.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add this to your code and run your app. You'll notice no difference
    at all to the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: The example code uses a version of `UIViewPropertyAnimator` that accepts a timing
    function to make the final bounce animation livelier. If you look at the sample
    code, the first argument passed to the `UIViewPropertyAnimator` initializer is
    the duration of the animation in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument controls the timing function. A timing function describes
    how an animation should progress over time. For instance, the `easeIn` option
    describes how an animation starts off at a slow pace and speeds up over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes some of the most commonly used timing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Curve timing function scales'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Curve timing function scales
  prefs: []
  type: TYPE_NORMAL
- en: In these graphs, the *horizontal* axis represents the animation's progress.
    For each graph, the animation timeline is described from left to right on the
    *x* axis. The animation's progress is visualized on the *y* axis from bottom to
    top. At the bottom-left point, the animation hasn't started yet. At the right
    of the graph, the animation is completely done. The vertical axis represents time.
  prefs: []
  type: TYPE_NORMAL
- en: The final argument that is passed to the `UIViewPropertyAnimator` initializer
    is an optional argument for the animation that you wish to execute. This is quite
    similar to the `UIView.animate` way of doing things; the most significant difference
    is that you can add more animations after creating the animator, meaning that
    `nil` can be passed as the argument for the animations and you can add animations
    you wish to execute at a later time. This is quite powerful because you're even
    allowed to add new animations to `UIViewPropertyAnimator` while an animation is
    running!
  prefs: []
  type: TYPE_NORMAL
- en: The second section in the sample code you saw earlier adds completion closures
    to the animators. The completion closures both receive a single argument. The
    received argument describes at what point in the animation the completion closure
    was called. This property will usually have a value of `.end`, which indicates
    that the animation ended at the end position.
  prefs: []
  type: TYPE_NORMAL
- en: However, this isn't always true, because you can finish animations halfway through
    the animation if you desire. You could also reverse an animation, meaning that
    the completion position would be `.start`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the completion closure is added, and the property animators are fully configured,
    the final step is to start the animation by calling `startAnimation()` on an animator
    object. Once the `startAnimation()` method is called, the animation begins executing
    immediately. If needed, you can make the animation start with a delay by calling
    `startAnimation(afterDelay:)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you've got a better understanding of how `UIViewPropertyAnimator` works,
    why don't you try and change over our fade that we added in `DetailViewController`?
    For such a simple piece of code like this, `UIViewPropertyAnimator` is probably
    a little overkill, but it might be good just for fun.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample project, I'll include both scenarios and comment the other out
    for reference if you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a massive leap into the world of animation in iOS development,
    learning the basic way to just drop in an animation and how to build out more
    complex animation with `UIViewPropertyAnimator` for improved code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at how to control an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and controlling animation progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best features of `UIViewPropertyAnimator` is that you can use it
    to create animations that can be interrupted, reversed, or interacted with. Many
    of the animations you see in iOS are interactive animations – for instance, swiping
    on a page to go back to the previous page is an interactive transition.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping between pages on the home screen, opening the control center, or pulling
    down the notification center are all examples of animations that you manipulate
    by interacting with them.
  prefs: []
  type: TYPE_NORMAL
- en: While the concept of interactive animations might sound complicated, `UIViewPropertyAnimator`
    makes it quite simple to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you'll see how to implement a drawer on the contact detail page
    in our app. First, you'll prepare the view, so the drawer is partially visible
    in the app. Once the view is all set up, you will write the code to perform an
    interactive show-and-hide animation for the drawer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by heading back over to `Main.storyboard` and doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a UIView to our canvas via the object library (make sure this sits on top
    of the parent UIStackView, not inside it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Auto Layout constraints to make sure that the drawer view's width is
    equal to the main view's width (trialing and leading both set to `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the view `350pt` in height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, set the bottom constraint to `-305`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should leave the view just visible enough to cover the safe area at the
    bottom of the screen. Next, we need to add a button to our new view:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the button via the object library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the top constraint to be `8pt` from the top of the new view (its parent
    view).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the leading and trailing to be around `16pts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the label of the button to `Toggle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, set the background to **System Secondary Background Color**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All going well, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Detail view with image view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Detail view with image view
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got the layout sorted, let''s hook up the code we need. Our
    drawer functionality should implement the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Toggle the drawer by tapping on the **Toggle** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle the drawer interactively when swiping on the drawer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the user to tap on the **Toggle** button and then swipe the drawer to
    manipulate or reverse the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavior such as this is not straightforward; without `UIViewPropertyAnimator`,
    you would have to write a lot of complex code, and you'd still be pretty far from
    your desired results. Let's see what `UIViewPropertyAnimator` does to make implementing
    this effect manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare for the implementation of the drawer, add the following properties
    to `DetailsViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add an extension to `DetailsViewController` that holds an `@IBAction`
    for the tap action. `@IBAction` is similar to `@IBOutlet`, but it is used to call
    a particular method in response to a specific user action. An extension is used,
    so it''s easy to group the animation code nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect our outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect our UIView to the `IBOutlet` we just added in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your UIButton to the `IBAction` we just created in the extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you drag from the action to the button, a menu appears from which you can
    select the action for which `@IBAction` should trigger. To respond to a button
    tap, choose **Touch Up Inside** from this menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following lines to the end of `viewDidLoad()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following method to the extension you created earlier for `@IBAction`.
    This is the method that is called when the user performs a pan gesture on the
    drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that all of the placeholders are implemented, let's create a simple first
    version of the open drawer animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user taps on the toggle button, the drawer should open or close depending
    on the drawer''s current state. The following snippet implements such an animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The animation that is passed to the property animator uses the value of `isDrawerOpen`
    to determine whether the animation should open or close the drawer. When the drawer
    is currently open, it should close, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Once the animation finishes, the `isDrawerOpen` variable is updated to reflect
    the new state of the drawer. To determine the current state, the application reads
    the drawer's current transformation. If the drawer is not transformed, its transformation
    will equal `CGAffineTransform.identity` and the drawer is considered closed. Otherwise,
    the drawer is considered open.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and build and run your app now to see it in action. You'll see just
    how well it works.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with a pan gesture recognizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow the user to interrupt or start the animation by dragging their finger
    on the screen, the code must check whether an existing property animator is performing
    an animation.
  prefs: []
  type: TYPE_NORMAL
- en: If no animator exists or if the current animator is not running any animations,
    a new instance of the animator should be created. In all other circumstances,
    it's possible to make use of the existing animator.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refactor the animator creation code from `toggleDrawerTapped()` so that
    it reuses the animator if possible and creates a new animator if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following new function, `setUpAnimation()`, to our extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice how we''ve just lifted the majority of the code from `IBAction`
    – now we''ll need to update `IBAction` to call this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following implementation for `didPanOnDrawer(recognizer: UIPanGestureRecognizer)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is called for any change that occurs in the pan gesture recognizer.
    When the pan gesture first starts, the animation is configured, and then `pauseAnimation()`
    is called on the animator object.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to change the animation progress based on the user's pan behavior.
    Because the user might begin panning in the middle of the animation – for instance,
    after tapping the toggle button first – the current `fractionComplete` value is
    stored in the `drawerPanStart` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `fractionComplete` is a value between `0` and `1` and it's decoupled
    from the time that your animation takes to run. So, imagine that you are using
    an ease-in and ease-out timing parameter to animate a square from an *x* value
    of `0` to an *x* value of `100`. The *x* value of `10` is not at `10%` of the
    time the animation takes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: However, `fractionComplete` will be `0.1`, which corresponds to the animation
    being `10%` complete. This is because `UIViewPropertyAnimator` converts the timescale
    for your animation to linear once you pause it.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this is the best behavior for an interactive animation. However, you
    can change this behavior by setting the `scrubsLinearly` property on your animator
    to `false`. If you do this, `fractionComplete` will take any timing parameters
    you've applied into account.
  prefs: []
  type: TYPE_NORMAL
- en: You can try playing around with this to see what it feels like for the drawer
    animation. Once the initial animation is configured and paused, the user can move
    their finger around.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, the `fractionComplete` property is calculated and set on
    the animator by taking the distance traveled by the user's finger and dividing
    it by the total distance required. Next, the progress made by the animation before
    being interrupted is added to this new value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the gesture ends, it gets canceled, or anything else, the start
    position is reset. Also, a timing parameter to use for the rest of the animation
    is configured and the animation is set up to continue. Bypassing a `durationFactor`
    value of `0`, the animator knows to use whatever time is left for the animation
    while taking into account its new timing function.
  prefs: []
  type: TYPE_NORMAL
- en: If the user tapped the toggle button to close the drawer, yet they catch it
    mid-animation and swipe upward, the animation should finish in the upward direction.
    The last couple of lines take care of this logic.
  prefs: []
  type: TYPE_NORMAL
- en: There is no right or wrong way of creating your perfect animation. Have a play
    around with the various values that feel right for you and your app. In this section,
    we took everything we learned about animations a step further by looking at how
    we can control animations via either an event action such as a UIButton toggle
    or via a user gesture interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll start to add some real vibrancy to our animation
    by looking at how we can add some spring and bounce to our app!
  prefs: []
  type: TYPE_NORMAL
- en: Adding vibrancy to animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of animations on iOS look bouncy and feel natural. For instance, when
    an object starts moving in the real world, it rarely does so smoothly. Often,
    something moves because something else applied an initial force to it, causing
    it to have a certain momentum. Spring animations help you to apply this sort of
    real-world momentum to your animations.
  prefs: []
  type: TYPE_NORMAL
- en: Spring animations are usually configured with an initial speed. This speed is
    the momentum an object should have when it begins moving. All spring animations
    require damping to be set on them.
  prefs: []
  type: TYPE_NORMAL
- en: The value of this property specifies how much an object can overflow its target
    value. A smaller damping value will make your animation feel bouncier because
    it will float around its end value more drastically.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to explore spring animations is by slightly refactoring the
    animation you just created for the drawer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using an `easeOut` animation when a user taps the `setUpAnimation()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you implement a spring animation, you use a special initializer for `UIViewPropertyAnimator`.
    Since you can't pass animations to this initializer, you must add them by calling
    `addAnimations(_:)`. Adding spring animations did not require a considerable code
    change, but try running the app and tapping on the toggle button. The drawer will
    now feel more realistic because its animation curve is not as static as it was
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Play around with the values for the spring damping and the velocity. If you
    use some extreme values, you'll get interesting results. Keep in mind that the
    damping should be a value between `0` and `1` and that a value closer to `1` will
    make your animation bounce less.
  prefs: []
  type: TYPE_NORMAL
- en: The animation that is executed by the pan recognizer doesn't feel great at this
    point. It's very static and doesn't take into account how fast a user is panning
    on the drawer.
  prefs: []
  type: TYPE_NORMAL
- en: When the user ends their pan gesture, you can set the sprint timing's `initialVelocity`
    value based on the actual pan velocity. This will make the animation feel even
    more realistic because it will now use the actual pan speed as the initial speed
    for animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the default case statement with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you've just seen, the use of spring animations can benefit your animations
    and they are not very hard to add to your apps. While they might not always be
    the best solution, their ease of implementation makes spring animations a worthy
    candidate to experiment with to determine whether your animation needs a spring.
  prefs: []
  type: TYPE_NORMAL
- en: While the animation you have just implemented is pretty lifelike and realistic,
    your animations might need even more realism. The next section covers UIKit Dynamics,
    which is a special method of animating objects that uses a physics engine and
    can detect collisions between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamism with UIKit Dynamics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most apps implement simple animations, such as the ones you've seen so far in
    this chapter. However, some animations might need a little more realism – this
    is what UIKit Dynamics is for.
  prefs: []
  type: TYPE_NORMAL
- en: With UIKit Dynamics, you can place one or more views in a scene that uses a
    physics engine to apply certain forces to the views it contains. For instance,
    you can apply gravity to a particular object, causing it to fall off the screen.
    You can even have objects bumping into each other, and if you assign a mass to
    your views, this mass is taken into account when two objects crash into each other.
  prefs: []
  type: TYPE_NORMAL
- en: When you apply a certain force to an object with very little mass, it will be
    displaced more than an object with a lot of mass, just like you would expect in
    the real world.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we're going to create another little project away from our current
    app, so we can perform some physics experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started by creating a new project in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and call it `Dynamics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Main.Storyboard`, configure the preview to **Landscape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three UIViews around `100 x 100` in size (don't worry about constraints
    for this project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give each UIView a background color (think systems colors from [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066),
    *Using Lists and Tables*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All going well, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Main storyboard with views'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Main storyboard with views
  prefs: []
  type: TYPE_NORMAL
- en: Next, add instances of `@IBOutlet` in `ViewController.swift` for the views you
    just added and connect them to the storyboard in the same way you did before.
    You can name the outlets anything you like, but I'll name mine `ball1`, `ball2`,
    and `ball3` (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: The simplest thing you can implement at this point is to set up a scene that
    contains the three squares and apply some gravity to them. This will cause the
    squares to fall off the screen because they'll start falling once gravity is applied,
    and there is no floor to stop the squares from dropping off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a scene like the one described here, add the following highlighted
    code to your `ViewController.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you test your app now, you'll notice that your views start falling immediately.
    Setting up a simple scene such as this is easy with UIKit Dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this simple example is that it's not particularly interesting
    to look at. Before you add features to make this sample more interesting, let's
    see what the preceding four lines of code do.
  prefs: []
  type: TYPE_NORMAL
- en: The views in a dynamic scene must be of the `UIDynamicItem` type. A UIView can
    be used as `UIDynamicItem`, so by adding them to a list that has `[UIDynamicItem]`
    works automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create an instance of `UIDynamicAnimator` and you tell it the view
    to which it will apply its physics engine. The last step is to configure and apply
    a behavior. This example uses `UIGravityBehavior` but there are several other
    behaviors you can use in your scenes.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you can create `UIAttachmentBehavior` to attach an item to another
    item or to some point on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements an attachment behavior for every square on the
    screen and attaches it to the top of the screen. This will cause the squares to
    fall for a moment, and then they will bounce and swing a little until they eventually
    come to a standstill. You can add the following code to `viewDidLoad()` to implement
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every square is set up with a slightly different attachment point in this example.
    Note that the attachment behavior has a `damping` property.
  prefs: []
  type: TYPE_NORMAL
- en: This damping is similar to the damping that is used in spring animations. Try
    experimenting with the value for `attachment.damping` to see what it does.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app now, you'll notice that every square is attached to an invisible
    point on the screen that keeps it from falling. Some things are still missing
    though.
  prefs: []
  type: TYPE_NORMAL
- en: The squares can now simply cross over each other – how cool would it be if they
    bumped into each other instead?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, add the following line of code to `viewDidLoad()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Are you convinced that UIKit Dynamics is cool yet? I thought so; it's amazing
    how much you can do with just a little bit of code. Let's add some mass to the
    squares and make them more elastic to see whether this has any effect on how the
    squares collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `for` loop with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should augment what you already have in the loop; it shouldn't
    replace the existing logic.
  prefs: []
  type: TYPE_NORMAL
- en: By setting `density` on `UIDynamicItemBehavior`, the engine can derive the mass
    of an item. This will change how the physics engine treats the item when it collides
    with another item.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is a perfect time for you to go away and have a play with the behaviors
    and physics engine that Apple has provided. Now, a swinging square game might
    not be of interest to anyone – but update each of your ball properties to the
    following and run again…a lot more fun now, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the final section, we will learn everything we need to know about view controller
    transitions, again another way to really make a difference when moving away from
    the default behavior of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing view controller transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a custom view controller transition is one of those things that
    can take a little while to get used to. Implementing custom transitions involves
    implementing several objects, and it's not always easy to make sense of how this
    works. This section aims to explain exactly how custom view controller transitions
    work so that you can add one more powerful tool to your developer toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: A nicely implemented custom view controller transition will entertain and amaze
    your users. Making your transitions interactive could even ensure that your users
    spend some extra time playing around with your app, which is exactly what you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue by working on our Contacts app we started earlier on. Firstly,
    you'll learn how you can implement a custom modal transition. Once you've implemented
    that, you will learn about custom transitions for `UINavigationController` so
    that you can show and hide the contact details page with a custom transition.
    The dismissal of both the modal view controller and the contact detail page will
    be interactive, so users can swipe to go back to where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will work through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a custom modal presentation transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the transition interactive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a custom `UINavigationController` transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a custom modal presentation transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of applications implement modally presented view controllers. A modally
    presented view controller is typically a view controller that is presented on
    top of the current screen as an overlay. By default, modally presented view controllers
    animate upward from the bottom of the screen and are often used to present forms
    or other temporary content to the user. In this section, you'll take a look at
    the default modal presentation transition and how to customize it to suit your
    own needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a brand new View Controller. For this, we''ll head
    back to our Contacts app project where we can add this in here (or feel free to
    start a brand-new project):'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `TransitionViewController` (with a subclass of `UIViewController`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new View Controller to `Main.Storyboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the object class for that new View Controller to be `TransitionViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done that, we'll add a bar button item to our existing navigation
    so that we can present our modal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add `BarButtonItem` from our object library to our navigation bar in `rootViewContoller`
    (basically our first view controller).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the button's text to be `Show Modal` (or whatever you want).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, press *Ctrl* and drag the bar button item's connector to the new view controller
    we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When presented with options, choose **Present Modally**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All going well, it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Modal action segue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Modal action segue
  prefs: []
  type: TYPE_NORMAL
- en: Finally, give our new view controller a system orange background color, so it
    will be easier to see the transition later.
  prefs: []
  type: TYPE_NORMAL
- en: If you run your app now, you can click on the **Show Modal** button and you'll
    see an empty view controller pop up from the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Until iOS 13, you had to create an interface in order for the user to dismiss
    a modal. Now, unless implicitly set, you can just swipe down to dismiss a modal,
    which is worth bearing in mind when developing apps that go further back than
    iOS 13.
  prefs: []
  type: TYPE_NORMAL
- en: Custom view controller transitions use several objects to facilitate the animation.
    The first object you will look at is `transitioningDelegate` for `UIViewController`.
    The `transitioningDelegate` property is responsible for providing an animation
    controller that provides the custom transition.
  prefs: []
  type: TYPE_NORMAL
- en: The animation controller uses a transitioning context object that provides information
    about the view controllers that are involved in the transition. Typically, these
    view controllers will be the current view controller and the view controller that
    is about to be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'A transitioning flow can be described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A transition begins. The target view controller is asked for `transitioningDelegate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`transitioningDelegate` is asked for an animation controller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animation controller is asked for the animation duration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animation controller is told to perform the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the animation is complete, the animation controller calls `completeTransition(_:)`
    on the transitioning context to mark the animation as completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *step 1* or *step 2* return `nil`, or aren''t implemented at all, the default
    animation for the transition is used. The objects involved in a custom transition
    are displayed in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Animation transition flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Animation transition flow
  prefs: []
  type: TYPE_NORMAL
- en: Creating a separate object to control the animation is often a good idea because
    it allows you to reuse a transition and it keeps your code nice and clean. The
    animation controller should be an object that conforms to `UIViewControllerAnimatedTransitioning`.
    This object will take care of animating the presented view onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the animation controller object next:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `CustomAnimator` (using `NSObject` as a subclass).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following extension in order to make the class conform to `UIViewControllerAnimatedTransitioning`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This makes the new class conform to the protocol that's required to be an animation
    controller. Xcode will show a build error because you haven't implemented all
    the methods to conform to `UIViewControllerAnimatedTransitioning` yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's go over the methods one by one so that you end up with a full implementation
    for the animation controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method that must be implemented for the animation controller is `transitionDuration(using:)`.
    The implementation of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This method is used to determine the total transition duration in seconds. In
    this case, the implementation is simple – the animation should last *0.6* seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The second method that needs to be implemented is `animateTransition(using:)`.
    Its purpose is to take care of the actual animation for the custom transition.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation will take the target view controller and its view will be
    animated from the top of the screen downward to its final position. It will also
    do a little bit of scaling, and the opacity of the view will be animated; to do
    this, `UIViewPropertyAnimator` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following implementation to the animator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is going on in the preceding code snippet. Let''s go through the code
    step by step to see what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The target view controller is extracted from the transition context. This allows
    you to use the view controller's view in the animation that you're about to perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the animation's container view. The container view is a regular UIView
    and it is intended to contain all the animated views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the target view controller's view for the animation. The view is transformed,
    so it's off the screen, and transparency is set to make the view completely transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the view is prepared, it is added to the container view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The animations are set up and added to a property animator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The completion handler for the property animator is configured, so `completeTransition(_:)`
    is called on the context. The `transitionWasCancelled` variable is used to determine
    whether the animation completed normally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the property animator so that the animations begin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the animation controller is complete, the `UIViewControllerTransitioningDelegate`
    protocol should be implemented on `TransitionViewController` so that it can act
    as its own `transitioningDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to `TransitionViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code adds conformance to the `UIViewControllerTransitioningDelegate` protocol
    and assigns the view controller as its own transitioning delegate. The `animationController(forPresented:presenting:source:)`
    method returns the animation controller you created before. The `animationController(forDismissed:)`
    method returns `nil` for now.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and test your custom transition! This is all the code required to create
    a custom display transition.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned loads about how to fine-tune and polish off our
    app. Visual effects play such a big part in any application – so learning about
    animations transitions is an absolute must for any iOS developer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took the solid core of our Contacts app and decorated it
    with animations and vibrancy. We started by learning the basics of animation and
    how a couple of lines of code could make a massive difference. We then took this
    a step further and refactored more complex code to make it not only maintainable
    but also easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: UIKit offers much more than just fancy animations. Looking at dynamics, we saw
    how we could apply physics to even a UIView to give us an app with a truly awesome
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at transitions, something that is very powerful in iOS development,
    yet something we take so easily for granted. We created a custom class that allowed
    us to create our very own modal transition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to delve a little deeper into the Swift programming
    language and learn all about Swift's type system.
  prefs: []
  type: TYPE_NORMAL
