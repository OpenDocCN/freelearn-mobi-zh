- en: Chapter 12. Working with Video and Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 处理视频和音频
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Playing local FLV video
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放本地FLV视频
- en: Playing local H.264 video
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放本地H.264视频
- en: Controlling video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制视频
- en: Embedding audio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入音频
- en: Playing embedded audio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放嵌入音频
- en: Streaming audio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式音频
- en: Controlling audio playback
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制音频播放
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With carriers able to support larger downloads and iOS hardware relentlessly
    marching forward, developers are able to build larger apps. Apple itself acknowledged
    this by doubling its over-the-air download limit, making it possible to include
    more bandwidth-heavy content such as video and high-quality audio.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着载体能够支持更大的下载，iOS硬件不断向前发展，开发者能够构建更大的应用程序。苹果公司本身也承认了这一点，将其空中下载限制翻倍，使得包括更多带宽密集型内容（如视频和高质量音频）成为可能。
- en: On the web, the Flash platform has been a leader in both video and audio playback
    for many years. Adobe AIR brings many of these capabilities to iOS, enabling the
    creation of apps that will engage, inspire, and immerse the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，Flash平台多年来一直是视频和音频播放的领导者。Adobe AIR将这些功能带到了iOS，使得开发者能够创建能够吸引、启发和沉浸用户的app。
- en: This chapter will explore the many options for working with video and sound.
    It will start by guiding you through the steps required to include and play back
    video, before moving onto the handling of embedded and streaming audio.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨处理视频和声音的许多选项。它将首先指导您完成包括和播放视频所需的步骤，然后转向处理嵌入和流式音频。
- en: Playing local FLV video
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放本地FLV视频
- en: Key to the Flash platform's success over the years has been its FLV file format,
    which delivers Sorenson Spark or ON2 VP6 encoded video both locally and over the
    Internet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Flash平台成功的关键是其FLV文件格式，它提供本地和互联网上的Sorenson Spark或ON2 VP6编码视频。
- en: In this recipe, we will see how to load FLV video that has been bundled with
    an AIR for iOS app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何加载与AIR for iOS应用程序捆绑在一起的FLV视频。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use `chapter12\recipe1\recipe.fla` from the book's accompanying code bundle
    as a starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用书中附带代码包中的`chapter12\recipe1\recipe.fla`作为起点。
- en: Also, an FLV video is available from `chapter12\resources\video.flv` and should
    be copied to `chapter12\recipe1\` before proceeding.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个FLV视频可以从`chapter12\resources\video.flv`获取，并且在继续之前应该复制到`chapter12\recipe1\`。
- en: The video is intended to be viewed on a device held in a landscape orientation.
    To accommodate this requirement, the FLA's stage size has been set to 480x320
    pixels rather than the default portrait orientation of 320x480.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 视频旨在在横向放置的设备上观看。为了满足这一要求，FLA的舞台大小已被设置为480x320像素，而不是默认的纵向模式320x480。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is split into two main steps. First we will bundle the FLV video
    with the app, then we will write some ActionScript to play it back.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱分为两个主要步骤。首先我们将FLV视频与应用程序捆绑在一起，然后我们将编写一些ActionScript来播放它。
- en: Bundling the FLV video
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑FLV视频
- en: 'Perform the following steps to bundle the video with the app:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将视频与应用程序捆绑在一起：
- en: Open the AIR for iOS Settings panel by selecting **File** | **AIR for iOS Settings**
    from Flash's drop-down menu.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Flash的下拉菜单中选择**文件** | **AIR for iOS设置**来打开AIR for iOS设置面板。
- en: If it isn't already selected, click on the panel's **General** tab.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选中，请点击面板的**常规**选项卡。
- en: Set the **Rendering** field to **CPU**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**渲染**字段设置为**CPU**。
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select `chapter12\recipe1\video.flv`. The video will
    now be bundled with your IPA file when the FLA is published.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板底部是**包含文件**列表。点击列表上方的**+**符号，并选择`chapter12\recipe1\video.flv`。当FLA发布时，视频现在将与您的IPA文件捆绑在一起。
- en: Click on **OK** to close the AIR for iOS Settings panel.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭AIR for iOS设置面板。
- en: Playing the FLV video
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放FLV视频
- en: With the FLV now included within your FLA, we can turn our attention to the
    ActionScript required to play it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在FLV已经包含在您的FLA中，我们可以将注意力转向播放它所需的ActionScript。
- en: Create a document class and name it `Main`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并命名为`Main`。
- en: 'Add the following import statements to the class:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入语句添加到类中：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a constant to store the name of the FLV video:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个常量来存储FLV视频的名称：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create three member variables required to play back video:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个播放视频所需的成员变量：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within the constructor, load and play back the FLV video:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，加载并播放FLV视频：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will also need to provide callback methods that capture metadata and cue
    point events as the FLV plays. Add the following two empty methods to your document
    class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要提供回调方法来捕获 FLV 播放时的元数据和提示点事件。将以下两个空方法添加到您的文档类中：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save both the class file and your FLA.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类文件和 FLA 文件。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 部署到您的设备上。
- en: When launched, the app will load and play the FLV from the file system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它将从文件系统加载并播放 FLV 文件。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our code loads `video.flv` locally from the device and plays it back to the
    user. All files bundled with an app are copied to its Application directory during
    installation. This is the same folder where the app itself lives, and is where
    the FLV video is stored.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从设备本地加载 `video.flv` 文件，并将其播放给用户。应用程序捆绑的所有文件在安装期间都会复制到其应用程序目录中。这是应用程序本身所在的文件夹，也是
    FLV 视频存储的位置。
- en: Loading and playing the video is a three-stage process that involves the `NetConnection,
    NetStream`, and `Video` classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和播放视频是一个涉及 `NetConnection`、`NetStream` 和 `Video` 类的三阶段过程。
- en: 'First a `NetConnection` object is created and `null` is passed to its `connect()`
    method. This indicates that we won''t be connecting to a Flash Media Server, and
    instead intend to either connect to a file that is stored locally on the device''s
    file system or hosted on a web server. For this recipe, we used the local FLV
    that we bundled with the app:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个 `NetConnection` 对象，并将 `null` 传递给其 `connect()` 方法。这表示我们不会连接到 Flash 媒体服务器，而是打算连接到存储在设备文件系统中的文件或托管在
    Web 服务器上的文件。对于这个示例，我们使用了与应用程序捆绑的本地 FLV 文件：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next a `NetStream` object is created and used to play the actual video. The
    `NetConnection` object is passed to the `NetStream` object''s constructor, allowing
    it to stream the local video from the device:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个 `NetStream` 对象，并用于播放实际的视频。将 `NetConnection` 对象传递给 `NetStream` 对象的构造函数，使其能够从设备流式传输本地视频：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally the `NetStream` object is attached to a `Video` object, allowing the
    video to be displayed to the user:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `NetStream` 对象附加到 `Video` 对象上，允许视频显示给用户：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Video` class inherits from `flash.display.DisplayObject`, meaning it can
    be added to the display list and manipulated in an identical manner to all other
    display objects. Two `DisplayObject` properties that we use are `width` and `height`
    to set the video's size on screen. In order to maximize playback performance,
    ensure the dimensions match that of the FLV perfectly. Scaling an FLV video will
    degrade performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Video` 类继承自 `flash.display.DisplayObject`，这意味着它可以被添加到显示列表中，并以与其他所有显示对象相同的方式进行操作。我们使用的两个
    `DisplayObject` 属性是 `width` 和 `height`，用于设置屏幕上视频的大小。为了最大化播放性能，确保尺寸与 FLV 完全匹配。缩放
    FLV 视频会降低性能。'
- en: Notice that CPU rendering was selected for this recipe. Although the GPU can
    be used, the hardware video decoder isn't capable of decoding arbitrary resolutions,
    which can sometimes lead to the incorrect sizing of your `Video` object. Additionally,
    if you are using Flash Professional CS5 and AIR 2.0, then avoid GPU rendering
    of video altogether.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中选择了 CPU 渲染。虽然可以使用 GPU，但硬件视频解码器无法解码任意分辨率，这有时会导致您的 `Video` 对象尺寸不正确。此外，如果您正在使用
    Flash Professional CS5 和 AIR 2.0，则应完全避免视频的 GPU 渲染。
- en: For more information, perform a search for `flash.net.NetConnection, flash.net.NetStream`,
    and `flash.media.Video` within Adobe Community Help.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '如需更多信息，请在 Adobe Community Help 中搜索 `flash.net.NetConnection`、`flash.net.NetStream`
    和 `flash.media.Video`。 '
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let us go back to the subject of metadata and cue points. We will also touch
    upon a few other considerations before moving on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到元数据和提示点的话题。在继续之前，我们还将涉及一些其他考虑因素。
- en: Metadata and cue point events
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据和提示点事件
- en: As a video plays, its `NetStream` object can be used to capture and process
    cue point and various metadata events including `onMetaData` and `onXMPData`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当视频播放时，可以使用其 `NetStream` 对象来捕获和处理提示点和各种元数据事件，包括 `onMetaData` 和 `onXMPData`。
- en: While this recipe had no need for these events, we still had to write empty
    callback handlers for each. Failing to do so will result in a runtime exception
    being thrown when an event is triggered.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例不需要这些事件，但我们仍然必须为每个事件编写空回调处理程序。如果不这样做，当事件被触发时，将抛出一个运行时异常。
- en: To handle these events, set the `NetStream` object's `client` property to an
    object that contains callback methods for each. The method names must match those
    of the events exactly. For this recipe, we simply set the `client` property to
    `this` and added the handlers to the document class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些事件，将`NetStream`对象的`client`属性设置为包含每个事件的回调方法的对象。方法名称必须与事件名称完全匹配。对于这个菜谱，我们简单地设置`client`属性为`this`，并将处理程序添加到文档类中。
- en: Refer to [http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html](http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html)
    for details regarding how to actually use the data from cue point and metadata
    events.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何实际使用提示点和元数据事件的数据的详细信息，请参阅[http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html](http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html)。
- en: Playing remote FLV video
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放远程FLV视频
- en: In addition to local playback, FLV video can be progressively streamed over
    HTTP from a remote location. Simply pass the video's URL to the `NetStream.play()`
    method to commence playback. You can also determine the status of the `NetStream`
    object's internal playback buffer by listening for it dispatching `NetStatusEvent.NET_STATUS`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '除了本地播放外，FLV视频还可以从远程位置通过HTTP进行渐进式流式传输。只需将视频的URL传递给`NetStream.play()`方法即可开始播放。你还可以通过监听`NetStream`对象内部回放缓冲区的状态来确定`NetStream`对象的状态，方法是监听它分发`NetStatusEvent.NET_STATUS`。 '
- en: You can find more information about available `NetStream` events at [http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html](http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html](http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html)找到有关可用`NetStream`事件的更多信息。
- en: Screen lock
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕锁定
- en: When watching video, the screen will dim after a short period of inactivity
    from the user. Within this recipe's constructor, we prevent this from happening
    by setting `NativeApplication.systemIdleMode` to `SystemIdleMode.KEEP_AWAKE`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当观看视频时，如果用户在一段时间内没有活动，屏幕将会变暗。在这个菜谱的构造函数中，我们通过将`NativeApplication.systemIdleMode`设置为`SystemIdleMode.KEEP_AWAKE`来防止这种情况发生。
- en: While indefinitely preventing the screen from locking is acceptable for demonstration
    purposes, it is unlikely to be suitable for real-world applications. A better
    practice is to disable screen locking during playback of a video, and then re-enable
    it when the video is paused or stopped.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无限期地防止屏幕锁定在演示目的上是可接受的，但可能不适合实际应用。更好的做法是在视频播放期间禁用屏幕锁定，然后在视频暂停或停止时重新启用。
- en: Maximizing playback performance
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大化播放性能
- en: To maximize performance, minimize your display list and try not to overlay other
    graphical elements on top of the video during playback. Also attempt to limit
    the amount of ActionScript being executed during playback. This is especially
    true of older first and second generation hardware where FLV performance can struggle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化性能，最小化你的显示列表，并在播放期间尽量避免在视频上方叠加其他图形元素。还尝试限制在播放期间执行的ActionScript的数量。这对于较老的第一代和第二代硬件尤其如此，因为FLV的性能可能会遇到困难。
- en: If you are using the AIR 3.0 SDK or above, then consider using hardware accelerated
    H.264 video above FLV as its playback performance and video quality is significantly
    better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是AIR 3.0 SDK或更高版本，那么考虑使用硬件加速的H.264视频，因为它的回放性能和视频质量显著更好。
- en: Bundling multiple videos
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*捆绑多个视频*'
- en: Files can be added individually to the **Included files** list, or you can specify
    a folder for inclusion. This is convenient when writing apps that have multiple
    videos as you can simply group the files within a single location. Every file
    within the folder will be bundled with your IPA.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以单独将文件添加到**包含文件**列表中，或者你可以指定一个包含文件夹。当你编写具有多个视频的应用程序时，这很方便，因为你可以在单个位置简单地分组文件。文件夹中的每个文件都将与你的IPA捆绑在一起。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Playing local H.264 video*'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放本地H.264视频*'
- en: '*Controlling video*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制视频*'
- en: '*Preventing screen idle, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*防止屏幕空闲，[第3章](ch03.html "第3章。编写你的第一个应用程序")*'
- en: '*Understanding GPU-Blend mode, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解GPU混合模式，[第6章](ch06.html "第6章。图形和硬件加速")*'
- en: Playing local H.264 video
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放本地H.264视频
- en: AIR for iOS now provides support for the high-quality, low bit-rate H.264 video
    format, enabling best-in-class high-definition playback through the `StageVideo`
    class. By taking advantage of hardware acceleration, H.264 video reduces CPU usage
    and consumes less memory than comparable formats including FLV.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: AIR for iOS现在支持高质量的、低比特率的H.264视频格式，通过`StageVideo`类实现最佳级别的高清播放。通过利用硬件加速，H.264视频比FLV等类似格式减少了CPU使用率，并消耗更少的内存。
- en: In this recipe, we will play back H.264 video that has been bundled locally
    with an app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将播放已与应用程序本地捆绑的H.264视频。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The steps covered here are applicable only to those using AIR 3.0 and above.
    If you are using Flash Professional CS5, then you will be unable to attempt this
    recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所述的步骤仅适用于使用AIR 3.0及以上版本的用户。如果您使用的是Flash Professional CS5，那么您将无法尝试此食谱。
- en: From the chapter's accompanying code bundle, use `chapter12\recipe2\recipe.fla`
    as a starting point.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从章节的配套代码包中，以`chapter12\recipe2\recipe.fla`作为起始点。
- en: An H.264 encoded video is available from `chapter12\resources\video.mp4` and
    should be copied to `chapter12\recipe2\` before proceeding.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从`chapter12\resources\video.mp4`提供的H.264编码视频，在继续之前应将其复制到`chapter12\recipe2\`。
- en: The video is intended to be viewed on a device held in a landscape orientation.
    To accommodate this requirement, the FLA's stage size has been set to 480x320
    pixels rather than the default portrait orientation of 320x480.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该视频旨在在横向持握的设备上观看。为了满足这一要求，FLA的舞台大小已设置为480x320像素，而不是默认的纵向方向320x480。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe is broken into two main steps. First we will bundle the H.264 video
    with the app, before writing some ActionScript to play it back.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱分为两个主要步骤。首先，我们将捆绑H.264视频与应用程序，然后编写一些ActionScript来播放它。
- en: Bundling the H.264 video
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包H.264视频
- en: 'Perform the following steps to bundle the video with the app:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将视频与应用程序捆绑：
- en: Open the AIR for iOS Settings panel by selecting **File** | **AIR for iOS Settings**
    from Flash's drop-down menu.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Flash的下拉菜单中选择**文件** | **AIR for iOS设置**来打开AIR for iOS设置面板。
- en: If it isn't already selected, click on the panel's **General** tab.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该选项尚未选中，请点击面板的**常规**选项卡。
- en: Set the **Rendering** field to **GPU**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**渲染**字段设置为**GPU**。
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select `chapter12\recipe2\video.mp4`. The file will
    now be bundled with your IPA file when the FLA is published.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板底部是**包含的文件**列表。点击列表上方的**+**符号，并选择`chapter12\recipe2\video.mp4`。当FLA发布时，该文件将捆绑到您的IPA文件中。
- en: Click on **OK** to close the AIR for iOS Settings panel.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭AIR for iOS设置面板。
- en: Playing the H.264 video
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放H.264视频
- en: With the video now included within your FLA, we can turn our attention to the
    ActionScript required to play it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视频已包含在您的FLA中，我们可以将注意力转向播放视频所需的ActionScript。
- en: Create a document class and name it `Main`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Add the following import statements to the class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入语句添加到类中：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a constant to store the name of the video:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个常量以存储视频的名称：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create three member variables required to play back video:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个用于播放视频的成员变量：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the constructor, set-up and play back the video:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中设置并播放视频：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will also need to provide a callback method that captures metadata events
    as the video plays. Add the following empty method to your document class:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要提供一个回调方法，以捕获视频播放时的元数据事件。将以下空方法添加到您的文档类中：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save both the class file and your FLA.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类文件和您的FLA。
- en: Note
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The AIR Debug Launcher (ADL) does not currently support H.264 video playback.
    If you attempt to test this recipe using ADL, then you will receive a runtime
    error.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AIR调试启动器（ADL）目前不支持H.264视频播放。如果您尝试使用ADL测试此食谱，则将收到运行时错误。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并将IPA部署到您的设备上。
- en: When launched, the app will load and play the H.264 video from the file system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动时，应用程序将从文件系统加载并播放H.264视频。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our code loads `video.mp4` locally from the device and plays it back to the
    user. All files bundled with an app are copied to its Application directory during
    installation. This is the same folder where the app itself lives and is where
    the H.264 video is stored.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从设备本地加载`video.mp4`并播放给用户。应用程序捆绑的所有文件在安装期间都会复制到其应用程序目录中。这是应用程序本身所在的文件夹，也是H.264视频存储的位置。
- en: Loading and playing the video is a four-step process that involves the `NetConnection,
    NetStream`, and `StageVideo` classes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和播放视频是一个涉及 `NetConnection, NetStream` 和 `StageVideo` 类的四步过程。
- en: 'First a `NetConnection` object is created and `null` is passed to its `connect()`
    method. This indicates that we won''t be connecting to a Flash Media Server, and
    instead intend to either connect to a file that is stored locally on the device''s
    file system or hosted on a web server. For this recipe, we used the local FLV
    that we bundled with the app:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个 `NetConnection` 对象，并将 `null` 传递给其 `connect()` 方法。这表示我们不会连接到 Flash 媒体服务器，而是打算连接到设备文件系统上存储的文件或托管在
    Web 服务器上的文件。对于这个配方，我们使用了与应用程序捆绑的本地 FLV 文件：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next a `NetStream` object is created and will be used to play the actual video.
    The `NetConnection` object is passed to the `NetStream` object''s constructor,
    allowing it to stream the local video from the device:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个 `NetStream` 对象，并将用于播放实际视频。将 `NetConnection` 对象传递给 `NetStream` 对象的构造函数，允许它从设备流式传输本地视频：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `NetStream` object needs to be attached to a `StageVideo` object in order
    for it to be displayed to the user. However, you don''t explicitly create one
    yourself. Instead a `StageVideo` object is obtained from a vector array made available
    by the `Stage` object''s `stageVideos` property. On iOS devices, this vector will
    contain a single `StageVideo` instance capable of rendering video:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将视频显示给用户，`NetStream` 对象需要附加到 `StageVideo` 对象上。然而，你不需要自己显式创建一个。相反，可以从 `Stage`
    对象的 `stageVideos` 属性提供的向量数组中获取一个 `StageVideo` 对象。在 iOS 设备上，这个向量将包含一个能够渲染视频的 `StageVideo`
    实例：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final step is to create a viewport for the video and begin playback. Video
    rendered by the `StageVideo` class is hardware-accelerated and not part of the
    display list. Instead, `StageVideo` instances are rendered behind the display
    list within a rectangular region, which specifies the absolute position and size
    of the video. Once the viewport has been defined, call the `NetStream` object''s
    `play()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为视频创建一个视口并开始播放。由 `StageVideo` 类渲染的视频是硬件加速的，并且不是显示列表的一部分。相反，`StageVideo`
    实例在显示列表后面的一个矩形区域内渲染，该区域指定了视频的绝对位置和大小。一旦定义了视口，就调用 `NetStream` 对象的 `play()` 方法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The video used for this recipe is 400x224 pixels in size, but you may have noticed
    in the code above that the viewport has been assigned a rectangular region of
    480x270\. This scales the video to cover the screen's entire horizontal width
    while still maintaining the video's aspect ratio. Also, the viewport is shifted
    down by 25 pixels to ensure that it is vertically centered on screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此配方的视频大小为 400x224 像素，但你可能已经注意到，在上面的代码中，视口已被分配了一个 480x270 的矩形区域。这会将视频缩放到覆盖屏幕的整个水平宽度，同时仍然保持视频的宽高比。此外，视口向下移动了
    25 像素，以确保它在屏幕上垂直居中。
- en: GPU rendering was selected for this recipe. Decoding H.264 video is computationally
    expensive and requires hardware to ensure acceptable playback performance on iOS
    devices. Although the video is not part of the display list, it does sit behind
    it, meaning display objects such as UI components can be overlaid on top.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，选择了 GPU 渲染。解码 H.264 视频计算成本高，需要硬件来确保在 iOS 设备上播放性能可接受。尽管视频不是显示列表的一部分，但它位于显示列表的后面，这意味着显示对象，如
    UI 组件，可以叠加在顶部。
- en: For more information, perform a search for `flash.net.NetConnection, flash.net.NetStream`,
    and `flash.media.StageVideo` within Adobe Community Help.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请在 Adobe 社区帮助中搜索 `flash.net.NetConnection, flash.net.NetStream` 和 `flash.media.StageVideo`。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let us go back to the subject of metadata. We will also touch upon a few
    other considerations before moving on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到元数据的话题。在继续之前，我们还将讨论一些其他注意事项。
- en: Metadata and cue point events
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据和提示点事件
- en: As a video plays, its `NetStream` object can be used to capture and process
    cue point and various metadata events including `onMetaData, onCuePoint`, and
    `onXMPData`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当视频播放时，可以使用其 `NetStream` 对象捕获和处理提示点和各种元数据事件，包括 `onMetaData, onCuePoint` 和 `onXMPData`。
- en: While this recipe had no need for the `onMetaData` event, we still had to write
    an empty callback handler for it. Failing to do so will result in a runtime exception
    being thrown when the event is triggered.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个配方不需要 `onMetaData` 事件，但我们仍然必须为它编写一个空的回调处理程序。如果不这样做，当事件被触发时，将会抛出一个运行时异常。
- en: To handle this, and other events, set the `NetStream` object's `client` property
    to an object that contains callback methods for each. The method names must match
    those of the events exactly. For this recipe, we simply set the `client` property
    to `this` and added the handlers to the document class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理此类事件和其他事件，将 `NetStream` 对象的 `client` 属性设置为包含每个事件的回调方法的对象。方法名称必须与事件名称完全匹配。对于本菜谱，我们只需将
    `client` 属性设置为 `this` 并将处理程序添加到文档类中。
- en: Refer to [http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html](http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html)
    for details regarding how to actually use the data from cue point and metadata
    events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何实际使用提示点和元数据事件的数据的详细信息，请参阅 [http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html](http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html)。
- en: Playing video captured by the default camera
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放默认相机捕获的视频
- en: 'Video successfully captured using the `CameraUI` class is stored temporarily
    on the device''s file system. Using the `MediaEvent` object dispatched by `CameraUI`,
    it is possible to determine the video''s URL in order to play it back. An example
    is given as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CameraUI` 类成功捕获的视频暂时存储在设备的文件系统中。通过 `CameraUI` 分发的 `MediaEvent` 对象，可以确定视频的
    URL 以便播放。以下是一个示例：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you have the URL, you can simply pass it to your `NetStream` object's `play()`
    method to initiate playback.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 URL，你可以简单地将它传递给 `NetStream` 对象的 `play()` 方法以启动播放。
- en: The `CameraUI` class is covered in the *Capturing with the default camera app*
    recipe from [Chapter 10](ch10.html "Chapter 10. Camera and Microphone Support").
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraUI` 类在 [第 10 章](ch10.html "第 10 章。相机和麦克风支持") 的 *使用默认相机应用捕获* 菜单中有所介绍。'
- en: Determining the video's size
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定视频的大小
- en: You can retrieve the width and height of the encoded video from a `StageVideo`
    object's `videoWidth` and `videoHeight` read-only properties. However, you first
    need to wait for this information to become available by listening for `StageVideoEvent.RENDER_STATE`
    being dispatched from your `StageVideo` instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `StageVideo` 对象的只读属性 `videoWidth` 和 `videoHeight` 中检索编码视频的宽度和高度。但是，首先你需要等待这些信息可用，通过监听从你的
    `StageVideo` 实例分发的 `StageVideoEvent.RENDER_STATE` 事件来实现。
- en: Also, be careful when playing back video captured from the device's camera.
    On iOS, the camera captures video in landscape orientation. If your application
    uses a portrait aspect ratio, then you will need to swap the values of the `videoWidth`
    and `videoHeight` properties when specifying your viewport's dimensions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在播放从设备相机捕获的视频时也要小心。在 iOS 上，相机以横向模式捕获视频。如果你的应用程序使用纵向宽高比，那么在指定视口尺寸时需要交换 `videoWidth`
    和 `videoHeight` 属性的值。
- en: For more information, perform a search for `flash.events.StageVideoEvent` within
    Adobe Community Help.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在 Adobe Community Help 中搜索 `flash.events.StageVideoEvent`。
- en: Playing remote H.264 video
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放远程 H.264 视频
- en: In addition to local playback, H.264 video can be progressively streamed over
    HTTP from a remote location. Simply pass the video's URL to the `NetStream.play()`
    method to commence playback. You can also determine the status of the `NetStream`
    object's internal playback buffer by listening for it dispatching a `NetStatusEvent.NET_STATUS`
    event.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地播放外，H.264 视频还可以从远程位置通过 HTTP 逐步流式传输。只需将视频的 URL 传递给 `NetStream.play()` 方法即可开始播放。你还可以通过监听
    `NetStream` 对象内部播放缓冲区的状态来确定 `NetStream` 对象的状态，该状态通过分发 `NetStatusEvent.NET_STATUS`
    事件来实现。
- en: You can find more information about available `NetStream` events at [http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html](http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html](http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html)
    找到更多关于可用 `NetStream` 事件的信息。
- en: Encoding H.264 video
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码 H.264 视频
- en: H.264 video playback can be computationally expensive. With such a wide range
    of hardware configurations across the range of iOS devices, it is important that
    the correct encoding strategy is employed to guarantee playback on the lowest
    common denominator. Adobe provides some H.264 encoding recommendations at [www.adobe.com/devnet/devices/articles/mobile_video_encoding.html](http://www.adobe.com/devnet/devices/articles/mobile_video_encoding.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: H.264 视频播放可能计算成本较高。由于 iOS 设备种类繁多，硬件配置广泛，因此采用正确的编码策略至关重要，以确保在最低的共同基数上播放。Adobe
    在 [www.adobe.com/devnet/devices/articles/mobile_video_encoding.html](http://www.adobe.com/devnet/devices/articles/mobile_video_encoding.html)
    提供了一些 H.264 编码建议。
- en: You can encode video using the H.264 codec with Adobe Media Encoder, which comes
    with Flash Professional as an optional install. An introduction to Adobe Media
    Encoder can be found on the Adobe Developer Connection website at [www.adobe.com/devnet/flash/quickstart/video_encoder.html](http://www.adobe.com/devnet/flash/quickstart/video_encoder.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Adobe Media Encoder对视频进行编码，该编码器是Flash Professional的可选安装程序，并使用H.264编解码器。Adobe
    Media Encoder的介绍可以在Adobe开发者连接网站上找到，网址为[www.adobe.com/devnet/flash/quickstart/video_encoder.html](http://www.adobe.com/devnet/flash/quickstart/video_encoder.html)。
- en: Bundling multiple videos
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑多个视频
- en: Files can be added individually to the **Included files** list, or you can specify
    a folder for inclusion. This is convenient when writing apps that have multiple
    videos as you can simply group the files within a single location. Every file
    within the folder will be bundled with your IPA.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以单独将文件添加到**包含文件**列表中，或者指定一个文件夹以包含文件。当编写具有多个视频的应用程序时，这很方便，因为您只需将文件分组在单个位置即可。文件夹中的每个文件都将与您的IPA捆绑在一起。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Controlling video*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制视频*'
- en: '*Preventing screen idle, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*防止屏幕空闲，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
- en: '*Understanding GPU-Vector mode, [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration")*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解GPU-Vector模式，[第6章](ch06.html "第6章。图形和硬件加速")*'
- en: Controlling video
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制视频
- en: As well as commencing playback, the `NetStream` class provides additional control
    of video. In this recipe, we will add the ability for the user to pause, resume,
    and restart either an FLV or H.264 video.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开始播放外，`NetStream`类还提供了对视频的额外控制。在本菜谱中，我们将添加用户暂停、恢复和重新启动FLV或H.264视频的能力。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open either `chapter12\recipe3-flv\recipe.fla`
    or `chapter12\recipe3-mp4\recipe.fla` and use it as a starting point. The first
    FLA's document class contains the code written for the *Playing local FLV video*
    recipe, while the second FLA contains the code from the *Playing local H.264 video*
    recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，打开`chapter12\recipe3-flv\recipe.fla`或`chapter12\recipe3-mp4\recipe.fla`，并将其作为起点。第一个FLA的文档类包含为**播放本地FLV视频**菜谱编写的代码，而第二个FLA包含**播放本地H.264视频**菜谱的代码。
- en: Two movie clips have been added to the stage. The first has been given an instance
    name of `blocker`. The second has been named `controls` and sits in front of `blocker`.
    Both movie clips will sit in front of the FLV or H.264 video.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 已将两个电影剪辑添加到舞台。第一个被赋予了实例名称`blocker`。第二个被命名为`controls`，位于`blocker`之前。这两个电影剪辑都将位于FLV或H.264视频之前。
- en: Within the `controls` movie clip are three buttons named `playBtn, restartBtn`,
    and `resumeBtn`. These will be used to play, restart, and un-pause the video respectively.
    Tapping anywhere on the screen during playback will pause the video.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`controls`电影剪辑中包含三个按钮，分别命名为`playBtn`、`restartBtn`和`resumeBtn`。这些按钮将分别用于播放、重新开始和取消暂停视频。在播放过程中，点击屏幕上的任何位置都会暂停视频。
- en: 'The `blocker` movie clip has an alpha transparency of 60% and will be used
    to dim the video when it is currently being paused. During playback, `blocker`
    will be made invisible ensuring that the video isn''t obscured. The following
    screenshot shows the video being dimmed by the `blocker` movie clip:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocker`电影剪辑具有60%的透明度，当视频处于暂停状态时将用于降低视频亮度。在播放过程中，`blocker`将变为不可见，确保视频不被遮挡。以下截图显示了由`blocker`电影剪辑降低亮度的视频：'
- en: '![Getting ready](img/1383_13_01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1383_13_01.jpg)'
- en: Before proceeding, you will also need to copy either an FLV or H.264 video to
    your FLA's root directory. If you are working with FLV video, then copy `chapter12\resources\video.flv`
    to `chapter12\recipe3-flv\`. For H.264 video, copy `chapter12\resources\video.mp4`
    to `chapter12\recipe3-mp4\`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您还需要将FLV或H.264视频复制到FLA的根目录。如果您正在使用FLV视频，则将`chapter12\resources\video.flv`复制到`chapter12\recipe3-flv\`。对于H.264视频，将`chapter12\resources\video.mp4`复制到`chapter12\recipe3-mp4\`。
- en: Okay, let us write the ActionScript required for this recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们编写这个菜谱所需的ActionScript。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the FLA''s document class and make the following changes to it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打开FLA的文档类，并对其进行以下更改：
- en: 'Add two new import statements:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个新的导入语句：
- en: '[PRE18]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Within the constructor, listen for the `NetStream` instance dispatching a `NetStatusEvent.NET_STATUS`
    event:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听`NetStream`实例分发`NetStatusEvent.NET_STATUS`事件：
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, remove the following line of code from the constructor:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从构造函数中删除以下代码行：
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the line above and throughout this recipe, `VIDEO_URL` is a constant containing
    the URL to the local video to be played. It will point to either `video.flv` or
    `video.mp4` depending on whether you are working with FLV or H.264 video.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的行以及整个配方中，`VIDEO_URL` 是一个包含要播放的本地视频 URL 的常量。它将指向 `video.flv` 或 `video.mp4`，具体取决于你是在处理
    FLV 还是 H.264 视频。
- en: We no longer want the video to start playing immediately. Instead we will wait
    for the user to tap the Play button.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再希望视频立即开始播放。相反，我们将等待用户轻触播放按钮。
- en: 'Finally, at the end of the constructor, call a support method that will set
    up the playback controls:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构造函数的末尾，调用一个支持方法来设置播放控件：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now add the actual `setupControls()` method. Add an event listener to each of
    the control buttons and make only the Play button visible initially—we will show
    the other buttons only when the video is paused.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加实际的 `setupControls()` 方法。为每个控制按钮添加一个事件监听器，并最初只显示播放按钮——我们将在视频暂停时显示其他按钮。
- en: '[PRE22]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the Play button is pressed, we will begin playback of the video and hide
    the controls from view. Add the following event handler to do this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下播放按钮时，我们将开始播放视频并隐藏控件。添加以下事件处理程序来完成此操作：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The user will be able to pause the video by tapping anywhere on the screen
    during playback. When paused, the control panel''s Restart and Resume buttons
    will be shown. Add an event handler for this and pause the `NetStream` object''s
    video stream:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以在播放期间通过在屏幕上任何地方轻触来暂停视频。当暂停时，控制面板的重置和恢复按钮将显示。为这个添加一个事件处理程序并暂停 `NetStream`
    对象的视频流：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now add an event handler for the Restart button. This handler will move back
    to the beginning of the `NetStream` object''s video and also hide the controls
    from view:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为重置按钮添加一个事件处理程序。此处理程序将使 `NetStream` 对象的视频回到开始，并隐藏控件：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write a similar handler for the Resume button, un-pausing the `NetStream` object''s
    video stream:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为重置按钮编写一个类似的处理程序，取消暂停 `NetStream` 对象的视频流：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also want to offer the user the chance to watch the video again once it
    has played to completion. Write a handler for the `NetStream` object''s `NET_STATUS`
    event and show the Play button if the video has stopped:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望用户在视频播放完成后有机会再次观看视频。为 `NetStream` 对象的 `NET_STATUS` 事件编写一个处理程序，如果视频已停止则显示播放按钮：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are just about finished. Add the following two support methods to manage
    the visibility of the control buttons and the blocker:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们即将完成。添加以下两个支持方法来管理控制按钮和遮挡器的可见性：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save your document class and move back to the FLA.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的文档类并回到 FLA。
- en: Publish and test the app on your device.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备上发布并测试应用程序。
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following three methods of the `NetStream` class were used to control video
    playback:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个 `NetStream` 类的方法被用来控制视频播放：
- en: '`pause():` Pauses the current video stream'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause():` 暂停当前视频流'
- en: '`resume():` Resumes playback of the paused video stream'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume():` 恢复暂停的视频流的播放'
- en: '`seek():` Moves to a specific point in time within the video stream'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seek():` 移动到视频流中的特定时间点'
- en: The `seek()` method expects a time, measured in seconds, to move to. The time
    is actually an approximation as the `NetStream` object will move to the keyframe
    closest to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek()` 方法期望一个时间，以秒为单位，用于移动到。实际上这是一个近似值，因为 `NetStream` 对象将移动到最接近该时间的键帧。'
- en: It should also be noted that the `play()` method should not be used to resume
    playback. It is used for commencing playback only. Instead call `resume()` to
    continue playback of a paused video.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，不应使用 `play()` 方法来恢复播放。它仅用于开始播放。相反，调用 `resume()` 以继续播放暂停的视频。
- en: The `NetStream` class does not provide a `stop()` method. Within our code example,
    the paused video was restarted from the beginning by seeking to the first keyframe,
    then resuming playback.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetStream` 类不提供 `stop()` 方法。在我们的代码示例中，暂停的视频是通过定位到第一个关键帧然后恢复播放从开始重新启动的。'
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some last words before we leave video and move on to audio.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开视频并转到音频之前，这里有一些最后的话。
- en: NetStream status
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NetStream 状态
- en: 'The `NetStatusEvent` object is dispatched in response to a plethora of useful
    status changes, errors, and warnings. Here are just a few strings that the `info.code`
    property can be queried for:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetStatusEvent` 对象在响应大量有用的状态变化、错误和警告时被触发。以下是一些可以查询 `info.code` 属性的字符串：'
- en: '`NetStream.Play.Start:` Playback has started'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Play.Start:` 播放已开始'
- en: '`NetStream.Play.Stop:` Playback has stopped'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Play.Stop:` 播放已停止'
- en: '`NetStream.Play.StreamNotFound:` The video file cannot be found'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Play.StreamNotFound:` 无法找到视频文件'
- en: '`NetStream.Play.InsufficientBW:` The client does not have sufficient bandwidth
    to play the video at its intended frame rate'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Play.InsufficientBW:` 客户端没有足够的带宽以期望的帧率播放视频'
- en: '`NetStream.Pause.Notify:` The stream has paused'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Pause.Notify:` 流已暂停'
- en: '`NetStream.Unpause.Notify:` The stream has un-paused'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Unpause.Notify:` 流已暂停'
- en: '`NetStream.Buffer.Flush:` Playback has ended and the buffer is now empty'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetStream.Buffer.Flush:` 播放结束，缓冲区现在为空'
- en: 'You can determine the code''s type by examining the `info.level` property,
    which will be set to one of the following strings: `status, error`, or `warning`.
    For a comprehensive list of supported strings, perform a search for `flash.events.NetStatusEvent`
    within Adobe Community Help.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查 `info.level` 属性来确定代码的类型，该属性将被设置为以下字符串之一：`status, error` 或 `warning`。要获取支持字符串的完整列表，请在
    Adobe Community Help 中搜索 `flash.events.NetStatusEvent`。
- en: The `flash.net.NetConnection` object also dispatches `NetStatusEvent` objects,
    which you can listen for.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.net.NetConnection` 对象也会派发 `NetStatusEvent` 对象，您可以监听这些对象。'
- en: Closing the video stream
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭视频流
- en: When you are done with a video and you have no more need for it, call the `NetStream`
    object's `close()` method. This will stop the playback of the video and make the
    stream available for some other use.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成视频并不再需要它时，调用 `NetStream` 对象的 `close()` 方法。这将停止视频播放并使流可用于其他用途。
- en: Embedding audio
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入音频
- en: Sound is an important part of any application and when applied correctly can
    immerse the user within the interactive experience. In order to provide this experience,
    it is important that latency is minimized during playback. For example, there
    should be no delay when playing game sound effects or providing audio feedback
    from a user interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是任何应用程序的重要组成部分，并且当正确应用时，可以沉浸用户于交互体验中。为了提供这种体验，在播放过程中最小化延迟是很重要的。例如，在播放游戏音效或从用户界面提供音频反馈时，不应有延迟。
- en: Flash allows sound files to be embedded directly within the library, providing
    the fastest playback path for your audio. Let us walk through the steps required
    to do this.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Flash 允许将声音文件直接嵌入到库中，为您的音频提供最快的播放路径。让我们一步步了解完成此操作所需的步骤。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to embed sound within an FLA''s library:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FLA 库中嵌入声音的步骤如下：
- en: From Flash Professional, create a new AIR for iOS document by selecting **File**
    | **New** *(Ctrl + N* | *Cmd* + *N)*. From the **New Document** panel, select
    the **AIR for iOS** document type and click on the **OK** button.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash Professional 中，通过选择 **文件** | **新建** *(Ctrl + N* | *Cmd* + *N)* 创建一个新的
    AIR for iOS 文档。从 **新建文档** 面板中选择 **AIR for iOS** 文档类型，然后点击 **确定** 按钮。
- en: Note
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are a Flash Professional CS5 user, then it is known as an **iPhone OS**
    document rather than an **AIR for iOS** document.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您是 Flash Professional CS5 用户，那么它被称为 **iPhone OS** 文档而不是 **AIR for iOS** 文档。
- en: Select **File** | **Import** | **Import to Library** from Flash's drop-down
    menu. A file browser window will appear.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash 的下拉菜单中选择 **文件** | **导入** | **导入到库**。将出现一个文件浏览器窗口。
- en: From the browser window, navigate to and select `chapter12\resources\sound.mp3`.
    Click on the **Open** button. The sound file will be imported and listed within
    the Library panel as **sound.mp3**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器窗口中，导航到并选择 `chapter12\resources\sound.mp3`。点击 **打开** 按钮。声音文件将被导入并在库面板中列出为
    **sound.mp3**。
- en: From the Library panel, right-click on **sound.mp3** and select **Properties**
    from the drop-down menu. The **Sound Properties** panel will open.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库面板中，右键单击 **sound.mp3** 并从下拉菜单中选择 **属性**。将打开 **声音属性** 面板。
- en: From the **Sound Properties** panel, select **ADPCM** from the **Compression**
    drop-down box. Ensure that the **Convert stereo to mono** checkbox is selected;
    set the **Sample rate** to **22kHz** and **ADPCM bits** to **4 bit**. If you are
    using Flash Professional CS5.5, then, as shown in the following screenshot, ensure
    that the panel's **Options** tab is selected first.![How to do it...](img/1383_13_02.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **声音属性** 面板中，从 **压缩** 下拉框中选择 **ADPCM**。确保选中 **将立体声转换为单声道** 复选框；将 **采样率** 设置为
    **22kHz** 和 **ADPCM 位** 为 **4 位**。如果您使用的是 Flash Professional CS5.5，那么，如以下截图所示，请确保首先选中面板的
    **选项** 选项卡。![如何操作...](img/1383_13_02.jpg)
- en: Now check the **Export for ActionScript** checkbox and change the text within
    the **Class** field to `SoundEffect`. If you are using Flash Professional CS5.5,
    then this should be performed from the panel's **ActionScript** tab.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查**导出为ActionScript**复选框，并将**类**字段中的文本更改为`SoundEffect`。如果您使用的是Flash Professional
    CS5.5，则应从面板的**ActionScript**选项卡执行此操作。
- en: Click on the **OK** button to close the panel.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**确定**按钮关闭面板。
- en: 'Depending on your preference settings within Flash Professional, a warning
    panel may appear containing the following text:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您在Flash Professional中的首选项设置，可能会出现包含以下文本的警告面板：
- en: '**A definition for this class could not be found in the classpath, so one will
    be automatically generated in the SWF file upon export.**'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**无法在类路径中找到此类定义，因此将在导出SWF文件时自动生成。**'
- en: This is expected. Click on the **OK** button to continue. The sound file has
    been assigned an ActionScript class name of SoundEffect.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是预期的。单击**确定**按钮继续。声音文件已被分配了一个名为SoundEffect的ActionScript类名。
- en: Save your FLA.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的FLA文件。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Embedding sound files within your library places them directly within the application's
    binary, making them immediately available for playback. However, adding sound
    files this way will increase your application's file size. The larger your application
    becomes, the longer it will take to load and the more memory it will consume.
    Before embedding a sound file, consider carefully whether or not you actually
    need immediate access to it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的库中嵌入声音文件将它们直接放置在应用程序的二进制文件中，使它们立即可用于播放。然而，以这种方式添加声音文件将增加您的应用程序文件大小。您的应用程序越大，加载所需的时间就越长，消耗的内存就越多。在嵌入声音文件之前，请仔细考虑您是否真的需要立即访问它。
- en: 'It is also important that you select the appropriate audio codec for your embedded
    sound. Flash provides two types of codec: compressed and uncompressed. Compressed
    sound, such as MP3, consumes less space than an uncompressed sound, such as ADPCM.
    However, the device needs to decode the audio during playback which can be demanding
    especially if you are attempting to play several compressed sounds at once.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的音频编解码器对于您的嵌入声音也很重要。Flash提供两种类型的编解码器：压缩和非压缩。压缩声音，如MP3，比非压缩声音，如ADPCM，占用更少的空间。然而，设备需要在播放时解码音频，这可能会很耗时，尤其是如果您试图同时播放多个压缩声音。
- en: If you need to simultaneously play multiple sound files and with minimum latency,
    then use an uncompressed codec. Flash provides both ADPCM and RAW for this. Of
    course, using uncompressed audio will increase the memory consumed by your app.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要同时播放多个声音文件并且具有最小延迟，则使用非压缩编解码器。Flash提供ADPCM和RAW用于此目的。当然，使用非压缩音频会增加您的应用程序内存占用。
- en: If you are only playing a single sound at any one time, then opt for MP3\. Doing
    so will reduce your app's memory footprint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一次只播放一个声音，则选择MP3。这样做将减少您的应用程序内存占用。
- en: If you want to access your embedded audio using ActionScript, then you must
    assign a unique class name to each sound within the library. For this recipe,
    we assigned the class name `SoundEffect` to our embedded sound.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用ActionScript访问您的嵌入音频，则必须为库中的每个声音分配一个唯一的类名。在本菜谱中，我们将类名`SoundEffect`分配给了我们的嵌入声音。
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating an AIR for iOS document, [Chapter 2](ch02.html "Chapter 2. Building
    iOS Apps Using Flash")*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建iOS的AIR文档，[第2章](ch02.html "第2章。使用Flash构建iOS应用程序")*'
- en: '*Playing embedded audio*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放嵌入音频*'
- en: Playing embedded audio
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放嵌入音频
- en: ActionScript can be used to play back sound files embedded within an FLA's library.
    The sound must have a unique class name associated with it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用ActionScript播放FLA库中嵌入的声音文件。声音必须有一个与之关联的唯一类名。
- en: In this recipe, we will cover how to play such embedded sounds.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将介绍如何播放此类嵌入声音。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's code bundle, open `chapter12\recipe5\recipe.fla` into Flash
    Professional and use it as a starting point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的代码包中，将`chapter12\recipe5\recipe.fla`打开到Flash Professional中，并将其作为起点使用。
- en: The embedded sound from the *Embedding audio* recipe can be found in the FLA's
    library and has a class name of `SoundEffect` linked to it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 来自“嵌入音频”菜谱的嵌入声音可以在FLA的库中找到，并且有一个名为`SoundEffect`的类名与之关联。
- en: Also, sitting on the stage is a button named `playBtn`. We will play the embedded
    sound whenever this button is pressed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，舞台上还有一个名为`playBtn`的按钮。我们将在此按钮被按下时播放嵌入的声音。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to play the sound associated with the `SoundEffect`
    class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以播放与`SoundEffect`类关联的声音：
- en: Create a document class and name it `Main`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的文档类。
- en: 'Import the `MouseEvent` class and listen for `playBtn` being pressed:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`MouseEvent`类并监听`playBtn`被按下：
- en: '[PRE29]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now add an event handler for the button and within it create an instance of
    the embedded sound''s `SoundEffect` class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为按钮添加一个事件处理程序，并在其中创建嵌入声音的`SoundEffect`类的实例：
- en: '[PRE30]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Staying within the handler, call the `SoundEffect` object''s `play()` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序内部，调用`SoundEffect`对象的`play()`方法：
- en: '[PRE31]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save both your class file and the FLA.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的类文件和FLA文件。
- en: Publish the app and test it on your device. Tap the button to initiate playback
    of the sound. Repeatedly tap the button to initiate several instances of it.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布应用程序并在您的设备上测试它。轻触按钮以启动声音的播放。重复轻触按钮以启动多个实例。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Audio is played using a `flash.media.Sound` object. All embedded sounds that
    are linked for ActionScript usage will inherit from this class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flash.media.Sound`对象播放音频。所有用于ActionScript的链接嵌入声音都将继承自这个类。
- en: To use an embedded sound, simply instantiate it, then call its `play()` method.
    This is just one of many methods and properties that are provided by the `Sound`
    class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用嵌入的声音，只需实例化它，然后调用它的`play()`方法。这只是`Sound`类提供的许多方法和属性之一。
- en: 'In this recipe, we used an embedded sound file that had a class name of `SoundEffect`
    assigned to it. The following two lines of code were all that was needed to play
    it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们使用了一个具有`SoundEffect`类名的嵌入声音文件。以下两行代码就足以播放它：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When `play()` is called, a `SoundChannel` object is created to play back the
    sound. Successive calls to `play()` creates new `SoundChannel` objects which independently
    play their own copy of the sound. You can hear this in action by repeatedly tapping
    the Play button within this recipe's example app.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`play()`时，会创建一个`SoundChannel`对象来播放声音。连续调用`play()`会创建新的`SoundChannel`对象，它们独立地播放自己的声音副本。您可以通过在此菜谱示例应用程序中重复轻触播放按钮来听到这个效果。
- en: Although we had no use for it in this recipe, the `play()` method returns a
    reference to a newly instantiated `SoundChannel` object, which can be used to
    control the sound's playback. This is covered in the *Controlling audio playback*
    recipe in this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个菜谱中我们没有用到它，但`play()`方法返回一个对新实例化的`SoundChannel`对象的引用，该对象可以用来控制声音的播放。这在本章的*控制音频播放*菜谱中有详细说明。
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let us look at a few more options available when playing sound.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在播放声音时可供选择的一些更多选项。
- en: Playback position
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放位置
- en: 'The `play()` method has a number of default parameters, the first of which
    starts playback from a specified position within the sound. The following example
    shows playback being commenced 500 milliseconds from the start:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`play()`方法有几个默认参数，其中第一个参数从声音中的指定位置开始播放。以下示例显示了从开始点500毫秒处开始播放：'
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If omitted, the sound will be played from the beginning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略，声音将从开头播放。
- en: Looping
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'A sound can be looped by passing a value to the `play()` method''s second parameter.
    In the following example, the sound plays at a point 200 milliseconds from the
    start, six times in succession:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将值传递给`play()`方法的第二个参数来循环播放声音。在以下示例中，声音从开始点200毫秒处连续播放六次：
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If omitted, playback will occur only once.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略，播放将只发生一次。
- en: See also
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Embedding audio*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入音频*'
- en: '*Controlling audio playback*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制音频播放*'
- en: Streaming audio
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式音频
- en: When working with large sound files, you may want to keep them outside your
    application's binary in order to minimize its load time and memory consumption.
    The `Sound` class can stream an MP3 file from the web or locally from the device's
    file system, removing the need to embed the audio directly within your FLA.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型声音文件时，您可能希望将它们放在应用程序的二进制文件之外，以减少其加载时间和内存消耗。`Sound`类可以从网络或从设备的文件系统流式传输MP3文件，从而无需直接在FLA中嵌入音频。
- en: In this recipe, we will bundle an MP3 file with an app and progressively play
    it back.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们将MP3文件与应用程序捆绑在一起，并逐步播放它。
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An `.mp3` file has been provided for this recipe. Using either Windows Explorer
    or Finder, copy `chapter12\resources\music.mp3` from the book's accompanying code
    bundle to `chapter12\recipe6\`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为此菜谱提供了一个`.mp3`文件。使用Windows资源管理器或Finder，将`chapter12\resources\music.mp3`从书籍的配套代码包中复制到`chapter12\recipe6\`。
- en: Open `chapter12\recipe6\recipe.fla` within Flash Professional. Sitting in the
    center of the stage is a button named `playBtn`. We will write some ActionScript
    to stream `music.mp3` whenever this button is pressed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash Professional中打开`chapter12\recipe6\recipe.fla`。位于舞台中央的是一个名为`playBtn`的按钮。我们将编写一些ActionScript，以便在按下此按钮时流式传输`music.mp3`。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: This recipe will be split into two parts. First we will bundle an MP3 with the
    app, then we will write the ActionScript required to play it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将分为两部分。首先，我们将与应用程序捆绑一个MP3文件，然后我们将编写播放它所需的ActionScript。
- en: Bundling the MP3 file
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑MP3文件
- en: 'Follow the steps to bundle the `.mp3` file with your app:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`.mp3`文件与应用程序捆绑：
- en: Open the AIR for iOS Settings panel by selecting **File** | **AIR for iOS Settings**
    from Flash's drop-down menu.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Flash的下拉菜单中选择**文件** | **AIR for iOS设置**来打开AIR for iOS设置面板。
- en: If it isn't already selected, click on the panel's **General** tab.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选中，请单击面板的**常规**选项卡。
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select `chapter12\recipe6\music.mp3`. The file will
    now be bundled with your IPA when the FLA is published.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板底部是**包含的文件**列表。在列表上方点击**+**符号，并选择`chapter12\recipe6\music.mp3`。当FLA发布时，该文件将与应用程序捆绑在一起。
- en: Click on **OK** to close the AIR for iOS Settings panel.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭AIR for iOS设置面板。
- en: Playing the MP3 file
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放MP3文件
- en: With the MP3 now included within your FLA, let us turn our attention to the
    ActionScript required to stream it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MP3已包含在您的FLA中，让我们将注意力转向流式传输它所需的ActionScript。
- en: Create a document class and name it `Main`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的文档类。
- en: 'Add the following import statements to the class:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入语句添加到类中：
- en: '[PRE35]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Within the constructor, listen for `playBtn` being pressed:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听`playBtn`被按下：
- en: '[PRE36]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let us add the button''s event handler. Within it, create a `URLRequest`
    object for the local `music.mp3` file:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加按钮的事件处理程序。在其内部，为本地`music.mp3`文件创建一个`URLRequest`对象：
- en: '[PRE37]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, pass the request to a new `Sound` object and call its `play()` method:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将请求传递给一个新的`Sound`对象，并调用其`play()`方法：
- en: '[PRE38]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save both your class file and the FLA.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的类文件和FLA。
- en: Publish the app and test it on your device. Tap the button to initiate streaming
    of the `.mp3` file. Repeatedly tap the button to initiate several instances of
    it.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布应用程序并在您的设备上进行测试。轻触按钮以启动`.mp3`文件的流式传输。重复轻触按钮以启动多个实例。
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In addition to the playback of embedded audio, the `flash.media.Sound` class
    can stream external sound files. The technique employed is identical to progressive
    downloading used when playing FLV or H.264 video and can be used for sound files
    that are either bundled with the app or stored remotely on the web.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了播放嵌入式音频外，`flash.media.Sound`类还可以流式传输外部声音文件。所采用的技术与播放FLV或H.264视频时使用的渐进式下载技术相同，可用于与应用程序捆绑或存储在网络上存储的声音文件。
- en: While Flash supports both compressed and uncompressed embedded audio, only `.mp3`
    files can be directly streamed using the `Sound` class. It is, therefore, advisable
    to keep the number of external files you simultaneously stream to a minimum as
    decoding the audio can be computationally expensive.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flash支持压缩和非压缩嵌入式音频，但只有`.mp3`文件可以使用`Sound`类直接流式传输。因此，建议将同时流式传输的外部文件数量保持在最低，因为解码音频可能计算成本高昂。
- en: 'Playing an `.mp3` file using the `Sound` class is straightforward. First a
    `URLRequest` for the sound file needs to be created:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Sound`类播放`.mp3`文件很简单。首先需要创建一个声音文件的`URLRequest`：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then the request is passed to a new `Sound` instance. The file starts to stream
    when the `Sound` object''s `play()` method is called:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将请求传递给一个新的`Sound`实例。当调用`Sound`对象的`play()`方法时，文件开始流式传输：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once `play()` is called, the `Sound` object can't be used with another `.mp3`
    file. To stream a different file, create a new `Sound` object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`play()`，`Sound`对象就不能与另一个`.mp3`文件一起使用。要流式传输不同的文件，请创建一个新的`Sound`对象。
- en: There's more...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The following details are applicable to sound in general within Flash, but are
    of particular importance when dealing with MP3 files held either locally on the
    device's file system or on the web.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下细节适用于Flash中的一般声音，但在处理存储在设备文件系统或网络上的MP3文件时尤其重要。
- en: Increasing the buffer time
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增加缓冲时间
- en: If the audio data is consumed faster than it is being loaded, then playback
    will be paused until the `Sound` object's internal buffer has filled again.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果音频数据消耗速度超过加载速度，则播放将暂停，直到`Sound`对象的内部缓冲区再次填满。
- en: 'To help prevent buffer under run, you can increase the number of milliseconds
    of data that has gathered before playback begins. Use a `flash.media.SoundLoaderContext`
    object to specify the buffer time and pass it to the `Sound` object''s constructor:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止缓冲区下溢，您可以在播放开始之前增加已收集的数据的毫秒数。使用 `flash.media.SoundLoaderContext` 对象来指定缓冲时间，并将其传递给
    `Sound` 对象的构造函数：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This example specifies that the buffer must contain 9000 milliseconds of audio
    data before playback is to continue. The default is 5000 milliseconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例指定缓冲区必须包含9000毫秒的音频数据，播放才能继续。默认值为5000毫秒。
- en: You can query the `Sound` object's `isBuffering` property to determine if the
    audio is currently paused while more data loads.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查询`Sound`对象的`isBuffering`属性以确定音频是否在加载更多数据时被暂停。
- en: Monitoring load progress
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控加载进度
- en: 'When loading, a `Sound` object dispatches a number of events that can help
    you monitor its progress:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载过程中，`Sound`对象会触发多个事件，可以帮助您监控其进度：
- en: '`Event.COMPLETE:` The sound''s data has been completely loaded'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Event.COMPLETE:` 声音的数据已完全加载'
- en: '`ProgressEvent.PROGRESS:` Dispatched periodically as data is received'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressEvent.PROGRESS:` 随着数据的接收定期触发'
- en: '`IOErrorEvent.IO_ERROR:` The sound file could not be found'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOErrorEvent.IO_ERROR:` 声音文件找不到'
- en: In addition, the `ProgressEvent` class provides the `bytesLoaded` and `bytesTotal`
    properties, which can be used to determine exactly how much of the file has loaded.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ProgressEvent` 类提供了 `bytesLoaded` 和 `bytesTotal` 属性，可以用来确定文件加载了多少。
- en: Sound length
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音长度
- en: The `Sound` class provides a `length` property, which can be used to determine
    the length of the current sound in milliseconds. When working with streaming sound,
    be careful as this property will return the length for only the data that has
    currently loaded. If you want to know the full sound file's duration, then wait
    for the `Sound` object to dispatch `Event.COMPLETE` first.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound` 类提供了一个 `length` 属性，可以用来确定当前声音的长度（以毫秒为单位）。当处理流式声音时，请注意，此属性将仅返回已加载的数据的长度。如果您想了解完整声音文件的持续时间，那么请先等待
    `Sound` 对象触发 `Event.COMPLETE` 事件。'
- en: Sound metadata
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音元数据
- en: MP3 audio can contain metadata in the form of ID3 tags, which contain information
    such as title, artist, album, and track number. If a file contains ID3 metadata,
    then `Event.ID3` will be dispatched from its `Sound` object. You can listen for
    this event, and then use the `Sound` object's `id3` property to read the tags.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: MP3音频可以包含以ID3标签形式存在的元数据，这些标签包含诸如标题、艺术家、专辑和曲目编号等信息。如果一个文件包含ID3元数据，那么其`Sound`对象将触发`Event.ID3`事件。您可以监听此事件，然后使用`Sound`对象的`id3`属性来读取标签。
- en: 'The following code example shows the `id3` property being enumerated in order
    to discover all tags embedded within the sound file:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了如何枚举`id3`属性以发现声音文件中嵌入的所有标签：
- en: '[PRE42]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ID3Info` class can be found in the `flash.media` package.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID3Info` 类可以在 `flash.media` 包中找到。'
- en: Working with raw PCM sound data
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理原始PCM声音数据
- en: Although the `Sound` class primarily allows for the loading and playback of
    external MP3 files, AIR 3.0 provides a new method for working with uncompressed
    PCM sound data. The `loadPCMFromByteArray()` method injects PCM 32-bit floating
    point sound data from a `ByteArray` object into a `Sound` object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Sound`类主要允许加载和播放外部MP3文件，但AIR 3.0提供了一种新的方法来处理未压缩的PCM声音数据。`loadPCMFromByteArray()`方法将来自`ByteArray`对象的PCM
    32位浮点声音数据注入到`Sound`对象中。
- en: Playing audio in the background
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在后台播放音频
- en: 'From AIR 3.0 onwards, you can write multitasking applications that continue
    to play audio while in the background. This is achieved by inserting the `UIBackgroundModes`
    key into your application descriptor file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从 AIR 3.0 开始，您可以编写可以在后台继续播放音频的多任务应用程序。这是通过在您的应用程序描述符文件中插入 `UIBackgroundModes`
    键来实现的：
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Any audio that is currently playing when the app is closed will continue to
    do so.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序关闭时，任何正在播放的音频将继续播放。
- en: See also
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Embedding audio*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入音频*'
- en: '*Controlling audio playback*'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制音频播放*'
- en: '*Editing the application descriptor file, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑应用程序描述符文件，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
- en: Controlling audio playback
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制音频播放
- en: A `SoundChannel` object is created for each sound that is played. Using the
    class' API, you can control the playback of a sound.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个播放的声音创建一个`SoundChannel`对象。使用类的API，你可以控制声音的播放。
- en: In this recipe, we will learn how to pause and resume a sound.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何暂停和恢复声音。
- en: Getting ready
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An `.mp3` file and an FLA have been provided within the book's accompanying
    code bundle.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍附带代码包中提供了一个`.mp3`文件和一个FLA文件。
- en: Open `chapter12\recipe7\recipe.fla` into Flash Professional. Sitting in the
    center of the stage is a button named `playBtn`. In the layer directly below is
    another button named `pauseBtn`. During this recipe, we will write ActionScript
    to toggle between the two, indicating whether or not the MP3 is currently playing.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将`chapter12\recipe7\recipe.fla`打开到Flash Professional中。在舞台中央有一个名为`playBtn`的按钮。在直接位于其下的图层中是另一个名为`pauseBtn`的按钮。在这个食谱中，我们将编写ActionScript在两个按钮之间切换，以指示MP3是否正在播放。
- en: The MP3 we will be using can be found at `chapter12\resources\music.mp3`. Before
    proceeding, copy it to the FLA's root folder at `chapter12\recipe7\`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的MP3文件可以在`chapter12\resources\music.mp3`中找到。在继续之前，将其复制到FLA的根文件夹`chapter12\recipe7\`中。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe is covered in two main steps. First we will bundle the MP3 with
    the app, then we will write the ActionScript required to control its playback.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱分为两个主要步骤。首先，我们将MP3与应用程序捆绑在一起，然后我们将编写用于控制其播放的ActionScript。
- en: Bundling the MP3 file
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑MP3文件
- en: 'Let us start by bundling the `.mp3` file with your app:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先捆绑`.mp3`文件到你的应用程序中：
- en: Open the AIR for iOS Settings panel by selecting **File** | **AIR for iOS Settings**
    from Flash's drop-down menu.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Flash的下拉菜单中选择**文件** | **AIR for iOS设置**来打开AIR for iOS设置面板。
- en: If it isn't already selected, click the panel's **General** tab.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，请点击面板的**常规**选项卡。
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select `chapter12\recipe7\music.mp3`. The file will
    now be bundled with your IPA file when the FLA is published.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板底部是**包含的文件**列表。点击列表上方的**+**符号，并选择`chapter12\recipe7\music.mp3`。当FLA发布时，该文件将捆绑到你的IPA文件中。
- en: Click on **OK** to close the AIR for iOS Settings panel.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭AIR for iOS设置面板。
- en: Controlling playback
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制播放
- en: 'Now that the MP3 file has been included, let us focus on the ActionScript:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MP3文件已经包含在内，让我们专注于ActionScript：
- en: Create a document class and name it `Main`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Import the classes required for this recipe:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入此食谱所需的类：
- en: '[PRE44]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare the following member variables, which we will use to control the sound:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下成员变量，我们将使用它们来控制声音：
- en: '[PRE45]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the constructor, add an event listener to each of the buttons and initially
    hide the Pause button from view:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，为每个按钮添加事件监听器，并最初隐藏暂停按钮：
- en: '[PRE46]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Also notice that the pausePosition member variable has been initialized. Every
    time the MP3 is paused, we will update this variable with the time it was stopped
    at.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`pausePosition`成员变量已经被初始化。每次MP3暂停时，我们将使用停止的时间更新此变量。
- en: When the Play button is pressed, playback of the MP3 should either commence
    for the first time, or continue from where it was previously paused. We will also
    need to listen for the MP3 playing to completion. In addition, the Pause button
    should be shown, allowing the user to stop the MP3 at some point.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下播放按钮时，MP3的播放应从第一次开始，或者从上次暂停的地方继续。我们还需要监听MP3播放完成。此外，应显示暂停按钮，使用户能够在某个点停止MP3。
- en: 'To manage all this, add the following event handler:'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了管理所有这些，添加以下事件处理程序：
- en: '[PRE47]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When pausing playback of the MP3, the current point in time that was reached
    needs to be obtained and stored. Also, the Play button should be made available
    again, allowing the user to resume playback at their convenience. The following
    block of code handles this:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当暂停MP3播放时，需要获取并存储达到的当前时间点。此外，应再次提供播放按钮，使用户能够方便地继续播放。以下代码块处理此操作：
- en: '[PRE48]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add an event handler that is called when the MP3 plays to completion. This
    will reset the `pausePosition` member variable and also make the Play button visible
    again, allowing the user to restart playback of the MP3:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件处理程序，当MP3播放完成时被调用。这将重置`pausePosition`成员变量，并再次使播放按钮可见，使用户能够重新开始MP3的播放：
- en: '[PRE49]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally add the following support method, which is used to toggle between the
    Play and Pause button:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加以下支持方法，用于在播放和暂停按钮之间切换：
- en: '[PRE50]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now save both your class file and the FLA.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存你的类文件和FLA文件。
- en: Publish the app and test it on your device. Toggle playback by pressing the
    Play and Pause buttons.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布应用并在您的设备上测试它。通过按下播放和暂停按钮切换播放。
- en: How it works...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the `Sound.play()` method is called, a `SoundChannel` object is created
    and returned. A `SoundChannel` object is responsible for the playback of a single
    sound. Successive calls to `Sound.play()` will return additional `SoundChannel`
    objects, each playing their own copy of the `Sound` object's data.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Sound.play()` 方法时，会创建并返回一个 `SoundChannel` 对象。`SoundChannel` 对象负责单个声音的播放。连续调用
    `Sound.play()` 将返回额外的 `SoundChannel` 对象，每个对象播放 `Sound` 对象的独立副本。
- en: While a call to `play()` will initially play the sound from start to finish,
    the `SoundChannel` class' API can be used to perform other operations. In this
    recipe, we utilized the class to provide pause and resume functionality to the
    user.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `play()` 调用最初会从头到尾播放声音，但 `SoundChannel` 类的 API 可以用于执行其他操作。在这个菜谱中，我们利用该类为用户提供暂停和恢复功能。
- en: It is not possible to literally pause a sound during playback; the `SoundChannel`
    class only provides a method to stop playback. However, you can store the position
    in time that a sound was stopped at, and then replay the sound from that position
    later.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放过程中，无法真正暂停声音；`SoundChannel` 类仅提供停止播放的方法。然而，您可以存储声音停止时的位置，稍后从该位置重新播放声音。
- en: 'This was achieved by storing the `position` property before stopping the sound.
    The `position` property returns the sound''s position in time, measured in milliseconds:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在停止声音之前存储 `position` 属性来实现的。`position` 属性返回声音的时间位置，以毫秒为单位：
- en: '[PRE51]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Playback is resumed by passing the stored position to `Sound.play()`. Doing
    so plays the MP3 from the specified point in time and returns a new `SoundChannel`
    object representing it:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递存储的位置到 `Sound.play()` 来恢复播放。这样做会从指定的时间点播放 MP3，并返回一个表示它的新的 `SoundChannel`
    对象：
- en: '[PRE52]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that the `pausePosition` member variable was initialized to `0` within
    the constructor. This guaranteed that the first time the Play button was pressed,
    playback of the MP3 would take place from the beginning.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`pausePosition` 成员变量在构造函数中被初始化为 `0`。这保证了第一次按下播放按钮时，MP3 的播放将从开头开始。
- en: When a sound has finished playing, its `SoundChannel` object will dispatch an
    `Event.SOUND_COMPLETE` event.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当声音播放完毕时，其 `SoundChannel` 对象将触发一个 `Event.SOUND_COMPLETE` 事件。
- en: While we used an external MP3 for this recipe, playback of sound embedded within
    the library is also controlled in an identical manner.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个菜谱中使用了外部 MP3，但嵌入到库中的声音播放也是以相同的方式进行控制的。
- en: For more information, perform a search within Adobe Community Help for `flash.media.Sound`
    and `flash.media.SoundChannel`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在 Adobe Community Help 中搜索 `flash.media.Sound` 和 `flash.media.SoundChannel`。
- en: There's more...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is some final information regarding the control of sound.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于声音控制的相关信息。
- en: Volume and panning
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音量和声像
- en: The volume and stereo panning of a sound can also be controlled. To do this,
    create a `flash.media.SoundTransform` object and either pass it to the `SoundChannel`
    object's `play()` method or the object's `soundTransform` property.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 声音的音量和立体声声像也可以进行控制。为此，创建一个 `flash.media.SoundTransform` 对象，并将其传递给 `SoundChannel`
    对象的 `play()` 方法或对象的 `soundTransform` 属性。
- en: 'The `SoundTransform` object''s constructor takes two parameters: the sound''s
    volume and a value specifying its left-to-right panning. The volume ranges from
    `0` (silent) to `1` (full volume), while the panning ranges from `-1` (fully left)
    to `1` (fully right).'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundTransform` 对象的构造函数接受两个参数：声音的音量和指定其左右声像的值。音量范围从 `0`（静音）到 `1`（全音量），而声像范围从
    `-1`（完全左偏）到 `1`（完全右偏）。'
- en: 'Following is an example where the sound is played at full volume and panned
    hard left:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中声音以全音量播放并硬声像左偏：
- en: '[PRE53]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The sound''s volume and panning can be adjusted at any point during playback.
    Simply make a change to your `SoundTransform` object and assign it to the `SoundChannel`
    object''s `soundTransform` property:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放过程中，可以调整声音的音量和声像。只需更改您的 `SoundTransform` 对象并将其分配给 `SoundChannel` 对象的 `soundTransform`
    属性：
- en: '[PRE54]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note the use of the `SoundTransform` object's `pan` and `volume` properties
    to make the required alterations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `SoundTransform` 对象的 `pan` 和 `volume` 属性来进行所需的更改。
- en: When testing stereo panning, be aware that you will need to use headphones as
    the loudspeaker found on iOS devices only delivers monophonic sound.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试立体声声像时，请注意您需要使用耳机，因为 iOS 设备上发现的扬声器仅提供单声道声音。
- en: Global sound
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全球音量
- en: As well as individual sounds, it is possible to control the volume and panning
    globally using the `flash.media.SoundMixer` class. It has its own `soundTransform`
    property, which when set affects all sound being played.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 除了个别声音外，还可以使用`flash.media.SoundMixer`类全局控制音量和声像。它有一个自己的`soundTransform`属性，当设置该属性时，会影响所有正在播放的声音。
- en: See also
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Playing embedded audio*'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放嵌入音频*'
- en: '*Streaming audio*'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流式音频*'
