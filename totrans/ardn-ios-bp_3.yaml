- en: Chapter 3. Wi-Fi Power Plug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Wi-Fi Power Plug is a device through which you can control electrical appliances
    hooked up to it, turning them on and off in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually from your iOS device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically setting timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, you can turn on your irrigation system every day at 6 P.M. for
    30 minutes, but if you see that your grass is turning yellow you can manually
    turn on the system for an additional watering.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, this kind of device is available on the market for a reasonable price
    but building one yourself will allow you to understand how it works and adapt
    it to your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison with the project in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Arduino
    and iOS – Platforms and Integration"), *Arduino and iOS – Platforms and Integration*,
    we are going to use Wi-Fi as the communication protocol. This will allow you to
    access the device even when you are not at home.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wi-Fi power plug requirements: We will briefly set the project requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware: We will describe the hardware and the electronic circuit needed for
    the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arduino code: We will write the code for Arduino to control the external appliance
    and to communicate with the iOS device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iOS code: We will write the code for the iOS device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access your power plug from anywhere in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to go further: More ideas to improve the project and learn more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi power plug requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a device that will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn an electric appliance hooked up to it on and off by receiving a command
    from the iOS device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on and off an electrical appliance on and off at specific times for a predefined
    lasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accompanying iOS application has to manually control the power plug and
    manage the timers.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Arduino
    and iOS – Platforms and Integration"), *Arduino and iOS – Platforms and Integration*,
    we need a Wi-Fi shield ([http://www.arduino.cc/en/Main/ArduinoWiFiShield](http://www.arduino.cc/en/Main/ArduinoWiFiShield))
    and a micro SD card formatted with FAT16 (take a look here for more details: [http://www.arduino.cc/en/Reference/SDCardNotes](http://www.arduino.cc/en/Reference/SDCardNotes)).
    The SD card is used to permanently store the activation times when Arduino is
    powered off, so its size is not so important.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional electronics components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project we need some additional components:'
  prefs: []
  type: TYPE_NORMAL
- en: Optoisolator MOC3041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 330 Ω resistor, 0.5 W
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 330 Ω resistor, 0.25 W
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TRIAC BTA08-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TRIAC is capable of 8 Amperes RMS at 600 V, which is about 1700 watts at
    220 V. You can use another TRIAC model of the same family (for example, BTA16)
    if you have a more powerful external appliance.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows how to mount the circuit on a breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to mount the Wi-Fi shield, and insert a micro SD card into it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This circuit works with the power line (120 V or 220 V). Touching any part with
    power line voltage can be extremely dangerous and can kill you. Even professionals
    with years of experience have been injured or killed, so *please* be extremely
    careful. This means that if you have never worked with power line voltage, you
    need to do that under the control of a skilled person.
  prefs: []
  type: TYPE_NORMAL
- en: '*Again, avoid working with the power line yourself if you have not done it
    before. You are the only one responsible for any damage you may cause to yourself,
    your relatives and your stuff. You have been warned!*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't feel safe handling the power line, you can still enjoy the project
    by replacing the power circuit with just the LED and the resistor.
  prefs: []
  type: TYPE_NORMAL
- en: To power the external appliance we use a TRIAC ([http://bit.ly/1MzmIYs](http://bit.ly/1MzmIYs)),
    which allows you to control an AC load using a small current. Since the power
    plug uses the power line, the voltages around are high (120-220 V) and they can
    burn your Arduino. For that reason, an optoisolator is placed between the low
    voltage circuit (Arduino) and the high voltage circuit (TRIAC) ([http://bit.ly/1TV1JFc](http://bit.ly/1TV1JFc)).
    Basically, it is an LED and a low power TRIAC in the same small package. When
    the LED is on, a small current is generated for photoelectric effect and it polarizes
    the gate of the low power TRIAC switching it. The main point here is that the
    light electrically isolates the LED and the TRIAC.
  prefs: []
  type: TYPE_NORMAL
- en: A transistor and a relay can replace the TRIAC and the optoisolator, but a relay
    is an electromechanical device, which is subject to failures in short time.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the optoisolator LED from Arduino on and off is pretty easy, as it is
    wired to a digital pin (number 8 in our case) and controlled with `digitalWrite(<PIN>,
    HIGH | LOW)`. The external LED in series with the optoisolator has monitoring
    purpose only.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Controlling more appliances**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to control more appliances, you can replicate the power circuit
    (Optoisolator and TRIAC) and wire it to another digital pin. Then you need to
    adapt both the Arduino code and the iOS code.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The full code of this project can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding of the explanations in the next paragraphs, you should
    open the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: The power plug has to activate the external appliance at different times for
    a different lasting and then deactivate it. We are going to call **activation**
    a turn on-turn off cycle. Each activation can be represented by a square wave
    (see the following diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino code](img/image00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each activation starts at its **Start Time**, lasts for a **Length** (during
    which the appliance is on) and repeats exactly after a **Period** of time. A one-off
    activation has a period equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this diagram for understanding the Arduino code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application can manage the `NUMBER_OF_ACTIVATIONS` activations stored in
    the global array `activations`. Each activation is a new type, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To make the code as simple as possible (and to save the flash memory) we save
    the entire array to the SD file, even if not all the activations are set. An activation
    is set if its name is set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Flash memory**'
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory stores the program running on Arduino. Arduino UNO has 32 K of
    flash memory of which 0.5 K is used for the bootloader. The bootloader is a small
    code that allows programming UNO via USB instead of using an external in-circuit
    programmer (for example, an AVR-ISP or STK500).
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the downloaded code, since the setup code is quite simple and
    doesn't require a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are handling time and Arduino does not have a real-time clock, we
    need to get the current time from a Network Time Protocol server on the net ([http://bit.ly/1NyCVM7](http://bit.ly/1NyCVM7));
    this is what the function `askTime` does. The request is sent via UPD ([http://bit.ly/1MzmQHb](http://bit.ly/1MzmQHb))
    and the answer is received on port 2390\. When a data packet is received, it is
    transformed into Unix time with the function `readTime` (see the `loop` function).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unix time**'
  prefs: []
  type: TYPE_NORMAL
- en: Unix time or Posix time is defined as the number of seconds that have elapsed
    since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970 ([http://bit.ly/1E6LP3m](http://bit.ly/1E6LP3m)).
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simplified version of the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Strings in flash memory**'
  prefs: []
  type: TYPE_NORMAL
- en: Usually Arduino stores static strings in RAM. Since RAM is also used for storing
    variables, we can move static strings to flash memory with the F() notation. For
    example, `Serial.println("iOS Device disconnected")`, wastes 23 bytes of RAM for
    storing the string `"iOS Device disconnected"`. Instead, writing `Serial.println(F("iOS
    Device disconnected"))` will let the string be stored in flash.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `server` represents the TCP server listening for connections. If
    a new client is connected and has data available for reading, `available` returns
    an instance of `WiFiClient` (`client`), which can be used for reading data. While
    the client is connected, (function `connected` returns true), we check if data
    is available. The function `available` returns the number of bytes available for
    reading, so while it returns a number greater than 0, we can read data and process
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `millis` returns the number of milliseconds since the board has
    been turned on, with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The function `checkActivations` is called every `ACTIVATION_CHECK_INTERVAL`
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `checkActivations` function checks each activation (which has a name) and
    based on the current time, turns the appliance on or off.
  prefs: []
  type: TYPE_NORMAL
- en: If the current time is between the activation start time and activation start
    time plus the activation length, the appliance has to be powered up.
  prefs: []
  type: TYPE_NORMAL
- en: Please, note that the start time is in seconds since 1 January 1970\. On the
    other hand, the length is in minutes.
  prefs: []
  type: TYPE_NORMAL
- en: If the appliance is turned on and the current time is greater than the start
    time plus the activation length, it has to be turned off. Then the activation
    is scaled of one period in order to be ready for the next activation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `checkActivations` is called every `ACTIVATION_CHECK_INTERVAL` seconds,
    an activation may be delayed by `ACTIVATION_CHECK_INTERVAL` with respect to its
    original time.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can take a look at the commands received from the iOS device (refer to
    the downloaded code).
  prefs: []
  type: TYPE_NORMAL
- en: Each command starts with a byte, which represents the code of the command, and
    is followed by any additional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first byte is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''A''`: Arduino sends all the activations to the iOS devices, using the function
    `sendActivations`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''U''`: It''s followed by one byte that represents the index of the activation
    (idx) to update, and by `sizeof(activation)` bytes, which represent the activation
    to update. Those bytes are copied on the existing activation with `memcpy((uint8_t
    *)&activations[idx], (uint8_t *)&inBuffer[2], sizeof(activation))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''D''`: It''s followed by one byte that represents the index of the activation
    (idx) to delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''S''`: It''s followed by one byte that represents the new state of the appliance
    which is set with `digitalWrite(PHOTOISOLATOR_PIN, HIGH)` or `digitalWrite(PHOTOISOLATOR_PIN,
    LOW)`. If the user forces on the state of the appliance, the program enters in
    manual mode and activations are ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, until the iOS device is connected, Arduino sends its status using
    the function `sendStatus`, the first byte is the operation mode (manual or automatic)
    and the second one is the status of appliance (turned on or off).
  prefs: []
  type: TYPE_NORMAL
- en: The last function we have to look at is `updateActivations`. Let's suppose that
    we have set an activation at 1:00 P.M. which lasts for 1 minute and repeats every
    2 minutes. At 12:59 P.M. we turn off the Arduino and then restart it at 2 P.M.
    Since 2 P.M. > 1:02 P.M. (now > `startTime` + 60 *period) the activation doesn't
    start anymore. `updateActivations` has exactly the purpose to shift in time the
    repeating activation, so that they can be fired properly.
  prefs: []
  type: TYPE_NORMAL
- en: '`updateActivations` is then called from the setup function and when the user
    gets back to automatic operations because during manual operations the activations
    are not checked and properly updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using function `millis` to calculate current time may lead to significant errors
    after few days, so we periodically update time via the NTP Server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The predefined value for `TIME_SYNC_INTERVAL` updates the current time every
    24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the iOS application to manually turn
    on and off the electrical appliance and managing the activations for the automatic
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code of this project can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the explanations in the next paragraphs, you should open
    the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create a new project. We are going to use the template
    Tabbed Application again, because it provides two view controllers. In this project,
    we will also add another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Tabbed Application project exactly as you did in the previous
    chapter and name it `PowerPlug`. Then:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename `FirstViewController` as `PowerPlugViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `SecondViewController` as `WiFiConnectionViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this chapter we are going to use an additional library (`CocoaAsyncSocket`
    see [http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE)), which simplifies the communication
    over a TCP/IP socket. To install the library you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the URL [http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Download ZIP** button (right side of the page). The file `CocoaAsyncSocket-master.zip`
    is downloaded into the `Downloads` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate `GCDAsyncSocket.h` and `GCDAsyncSocket.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag these files and drop them to the Xcode project into the **PowerPlug** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure that this option is set **Copy Items if needed** (see the following
    screenshot) and click **Next**.![Creating the Xcode project](img/image00178.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new view controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now add the additional view controller class and the additional view controller
    graphical container that we need, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `PowerPlug` folder in the left panel and right click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New File…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left pane select **iOS Source** and in the right one select **Cocoa Touch
    Class**, then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Subclass** of the list box, select **UITableViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Class** field enter `ActivationsTableViewController` (refer to the
    next screenshot) and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** on the next window.![Adding a new view controller](img/image00179.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Main.storyboard** in the left panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Utilities panel (**View** | **Utilities** | **Show Utilities**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Utilities panel's search field enter `UIViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the UIViewController to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the just added view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Identity Inspector (**View** | **Utilities** | **Show** **Identity
    inspector**, or click on the icon circled in red in the next picture).![Adding
    a new view controller](img/image00180.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Class** list box, select **ActivationsTableViewController**. View controller's
    class and the GUI are now tied together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have to add the new view controller into the Tab Bar of the main view
    controller. Pressing the *Control* key, drag your mouse pointer from the **Tab
    Bar Controller** to the **ActivationsTableViewController** and then release (see
    the next screenshot).![Adding a new view controller](img/image00181.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the small dialog shown in the next screenshot appears, select **Relationship**
    **Segues** | **view controllers**.![Adding a new view controller](img/image00182.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the new view controller is added to the **Tab Bar** (see next screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new view controller](img/image00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We need the new view control to be the second one in the Tab Bar. To move it,
    you can click and drag it to the desired position.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to change the text in the Tool Bar, respectively to `PowerPlug`,
    `Activations`, and `Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the downloaded code, you find three icons to use with each view controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need to show details of the elements in the table, we need to embed
    the ActivationsTableViewController in a navigation controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **ActivationsTableViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Editor** | **Embed in…** | **Navigation Controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should end up with a structure similar to the one shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new view controller](img/image00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a class for storing the information of each activation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To store information about each activation, we need a class `Activation`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Model View Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically speaking, we are now creating the "Model" of the Model View Controller
    pattern. You can find a brief introduction of the MVC pattern here: [http://apple.co/1hkUDbU](http://apple.co/1hkUDbU)
    and a complete discussion here: [http://apple.co/1EEpNzL](http://apple.co/1EEpNzL).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **PowerPlug** group in the left panel, right-click it and then select
    **New File…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left panel, select **Source** and in the right panel, select **Cocoa
    Touch Class**, then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **NSObject** in the **Subclass** list box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Activation` in **Class Text Field** (see next picture) and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save**.![Adding a class for storing the information of each activation](img/image00185.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Activation.h` file and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The project is now ready for the next steps, and we can start working on the
    view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application user interface for WiFiConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did in the previous project, we start from the view controller, which
    allows us to enter the connection information.
  prefs: []
  type: TYPE_NORMAL
- en: It is made of two labels, two fields to enter the IP address, the IP port assigned
    to the Arduino and a button to update the connection information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following screenshot to design it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for WiFiConnectionViewController](img/image00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since both fields accept only numbers and periods, we can make a properly set
    keyboard to help the user. To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Identity Inspector (**View** | **Utilities** | **Show** **Identity
    inspector**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Numbers and Punctuation** in the **Keyboard Type** list box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, link the user interface components to the code ending with the following
    in `WiFiConnectionViewController.m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to link the `UITextFields` delegate to the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the downloaded code for more details and compare your results with
    the provided application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application user interface for PowerPlugViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller manages the manual operation with the power plug that is
    capable of manually switching on and off the power to the hooked device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final layout of this view controller is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for PowerPlugViewController](img/image00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The component numbered **1** is a `UIImageView` and its purpose is to show if
    the hooked appliance is powered on or off. To add this component, just drag and
    drop it and select the image (`LEDdisabled.png` that you can find in the downloaded
    project) to to be displayed, using the **Attributes Inspector**. The size of the
    image view is 60 × 60, which can be set adding the proper layout constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The component numbered **2** is a switch button (`UISwitch`) to actually switch
    the appliance on and off manually. We can add this component to the container
    like we did with the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component numbered **3** is a button (`UIButton`) to reconnect to Arduino
    in case the connection is lost and the component numbered **4** is a `UIView`,
    which shows if the Arduino is connected or not by the means of its color (light
    gray: disconnected, green: connected).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added the components and the required Auto Layout constraints,
    you can link the components to the code ending with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Designing the application user interface for ActivationsTableViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ActivationsTableViewController view controller shows all the existing activations
    in a table.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to add a class to store information about the cell of each row
    in the table. To add this class, follow the same steps used in the previous chapters
    subclassing from `UITableViewCell` and calling the class `ActivationTableViewCell`
    (see next screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for ActivationsTableViewController](img/image00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `ActivationTableViewCell.h` file, change the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to create the custom cell to show each activation information
    of the power plug, and link it with the ActivationTableViewCell. We are going
    to show only the main steps, but you can refer to the downloaded code for all
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Main.storyboard**, select the **ActivationsTableViewController** and
    then the **Prototypes Cells** in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Identity Inspector and select **ActivationTableViewCell** in the **Class**
    list box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Attribute Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `activationCell` in the **Identifier** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Size Inspector and 66 in the **Row Height** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can enter the labels (UILabel) to show the different information of
    each activation, change colors and font sizes, and add the layout constraints
    ending with a cell prototype like that shown in the next screenshot:![Designing
    the application user interface for ActivationsTableViewController](img/image00189.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have to link the cell components to the class ActivationTableViewCell.
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Editor** | **Show Document Outline** (you can also open this panel using
    the icon circled red in the next screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Activations Table View Controller** **Scene** and expand it (see
    next screenshot).![Designing the application user interface for ActivationsTableViewController](img/image00190.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **activationCell** and right-click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping the *Control* key pressed, drag each property of the class to the related
    graphical component (see the next screenshot).![Designing the application user
    interface for ActivationsTableViewController](img/image00191.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to complete the last step: creating the view controller for entering
    and editing each activation (ActivationViewController).'
  prefs: []
  type: TYPE_NORMAL
- en: We start adding a new class inherited from UIViewController called `ActivationViewController`,
    then we drag and drop a new view controller into the **Main.Storyboard**, and
    we change its class to `ActivationViewController` in the **Identity Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This view controller uses two new components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'UIDatePicker: It allows the user to choose a date. In our case, the date at
    which the activation has to start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UISegmentControl: It allows the user to easily choose the length of activation
    and how often the activation has to be started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final layout of the controller is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for ActivationsTableViewController](img/image00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The component can be dropped into the container as we already have learned,
    and we can set their layout constraints as we did in the other view controllers.
    The components are linked to the code as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to edit activations, we need the ActivationViewController to show
    when the user taps on a row of the table. To do this, we have to create a segue
    from the cell to the view controller with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping *Control* pressed, drag your mouse pointer from the cell to the ActivationViewController
    (see the following screenshot).![Designing the application user interface for
    ActivationsTableViewController](img/image00193.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the black dialog appears, select **show**:![Designing the application user
    interface for ActivationsTableViewController](img/image00194.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find all the details about the ActivationViewController in the downloaded
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This ActivationsTableViewController is finally completed. Let's take a breath
    and sip a cup of coffee before getting into writing the code of our view controllers.
    It has been a long and complex run, and we actually deserve a cup of coffee (or
    tea if you prefer!).
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for the WiFiConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller has the purpose to make sure the user enters the IP address
    and IP port assigned to Arduino in order to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we are going to store this information in a file, instead of
    storing it in User Preferences as we did in the Pet Door Locker.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the update button is tapped, this code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The values of the two fields are stored in an NSMutableDictionary (`connectionInformation`)
    and stored into a file called `writeToFile`. This file is saved into a directory
    `documentsDirectory` that is accessible by the application only.
  prefs: []
  type: TYPE_NORMAL
- en: Before saving the information, we need to check that the IP address is properly
    formatted, and that the port is in the allowed range (see the downloaded code
    for all the details).
  prefs: []
  type: TYPE_NORMAL
- en: Since we set the text field's delegate properties, each time the user is done
    editing the field, one of the following methods is called and we can make the
    keyboard disappear using `resignFirstResponder`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we tap on the text field Period, the keyboard covers it (at least on smaller
    devices like the iPhone). To avoid this issue, we can shift up the entire view,
    using a couple of delegate methods of UITextView. When we tap the field, the `textFieldDidBeginEditing`
    method is called, and when we exit the field or tap return, the `textFieldDidBeginEditing`
    method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `textFieldDidBeginEditing` method we can translate the field, assigning
    a translation transformation to the field with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we end with these two additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each time this view controller is shown, both fields are filled in with the
    existing values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Writing code for AppDelegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, the connection to Arduino and the communication is managed
    into `AppDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we need some properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `socket` property (provided by the library we added) is a channel used for
    sending and receiving data from Arduino. The array `activations` stores all the
    activations the user creates.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app starts or enters in the foreground, it starts a connection with
    Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the connection to Arduino is successful, the delegate method `didConnectToHost`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `readDataWithTimeout` allows you to receive data from the counterpart:
    when data is available, the method `didReadData` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have set a timeout (5 seconds), if no data is received within this
    time interval, the method `socketDidDisconnect` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at each method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just notify the `PowerPlugViewController` instance that the connection
    was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just notify the `PowerPlugViewController` instance that the Arduino
    has disconnected, and we release the activations we were using.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Arduino we can receive two kinds of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**: It starts with character `''S''` and it''s followed by two bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First byte is 1 if the appliance has been turned on manually, 0 otherwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second byte is the status of the appliance: 0 if it''s switched off, 1 if it
    is switched on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activations**: It starts with character `''A''` and it''s followed by `ACTIVATION_SIZE_ON_ARDUINO
    * NUMBER_OF_ACTIVATIONS` bytes which represent activations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages coming from Arduino are received in the following method, and are processed
    following the previous rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If a Status message is received, the `PowerPlugViewController` instance is
    notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If an Activations message is received, each activation is added to `_activations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, the instance of ActivationsViewController is notified that all
    the activations are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: AppDelegate also implements delegate methods for PowerPlugViewController and
    ActivationsViewController view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: For ActivationsViewController, the implemented methods are `getActivations`,
    `updateActivationOfIndex`, and `deleteActivationOfIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `getActivations` is called by the ActivationsViewController when
    it needs to show the list of configured activations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If `_activations` is nil, a message to Arduino is sent which will respond with
    the list of all the activations. The message is very easy: only one byte with
    the value `''A''` (Activations).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The message is actually sent to Arduino calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The method `updateActivationOfIndex` is called by ActivationsViewController
    when an activation has been updated (or added). The method `deleteActivationOfIndex`
    is called by ActivationsViewController when an activation has to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: For the complete implementation of these two methods, look at the downloaded
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Methods implemented for PowerPlugViewController are `sendSwitchCommand` and
    `reconnect`, which are very easy and you can understand them directly from the
    downloaded code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for PowerPlugViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller manages manual operations of the appliance attached to
    the power plug.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to declare the delegate methods and messages to which this view
    controller responds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This view controller is very easy and its methods are quite auto explicative
    and self explanatory. We just need to take a look at `updateStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the `applianceStatus` is true, the appliance is turned on, and we set the
    image `LEDon.png` to the imageView (`_applianceStatus`). This image simulates
    an LED turned on. When the appliance is turned off, the image shown is `LEDoff.png`,
    which simulates an LED being turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for ActivationsTableViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller manages the list of activations, allowing the user to add,
    delete, and update each activation. It is based on the UITableView component,
    which is one of the most used and powerful components of the UIKit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from `ActivationsTableViewController.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should be able to recognize the delegate protocol and messages to
    which the view controller responds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from the implementation of the UITableView delegate methods. The
    first is `numberOfRowsInSection`, which is called from the table when it needs
    to know how many items it has to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn''t require many explanations. The method `cellForRowAtIndexPath` is
    called by the UIViewTable for each row to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Calling the method `[tableView dequeueReusableCellWithIdentifier:@"activationCell"]`
    we get a cell and we fill it with the values of one activation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the previous function returns nil, there is not an available cell, and one
    has to be created with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the downloaded code to see the full method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a row is deleted from the UITableView, the following method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Method `deleteRowsAtIndexPaths` removes the row from the table and the delegate
    method `deleteActivationOfIndex` creates a message that is then sent to Arduino
    for deleting an activation.
  prefs: []
  type: TYPE_NORMAL
- en: When designing the interface we created a segue from the table cell to the ActivationViewController
    in order that when the user taps a table row, the ActivationViewController appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the ActivationViewController is started, the method `prepareForSegue`
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here we set the delegate property of ActivationViewController and we store the
    index of the selected row.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Segue identifier**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `prepareForSegue` is called for each segue that starts from the
    view controller. Usually, different target view controllers require different
    initialization code. In the Interface Builder you can set the **Identifier** of
    each segue, and use these instructions for distinguishing between segues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The ActivationViewController requires two delegate methods, which don''t require
    any explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is `getActivation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We just point out that `[self.tableView reloadData]` forces the table view to
    reload data, starting from calling `numberOfRowsInSection` and then calling `cellForRowAtIndexPath`
    for each row.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for ActivationTableViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This view controller doesn't do much more than getting the user entered values
    and updating the selected activation.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the details, refer to the code provided with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you have completed your application, you can test the system following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Change IP information (IP, gateway, and so on) and network information (SSID,
    pass) in the Arduino sketch to adapt them to your own network configuration. You
    may need to access your router configuration page to get this information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the sketch to Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Arduino console for any error messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the driver circuit to the power line and to an external appliance (a
    lamp can do the job). Please, follow all the required security measures to avoid
    any electric shocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the iOS application on your device or in the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on Configuration and enter the IP address and port you have set in the Arduino
    sketch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the power plug, connect and switch the button on and off. You should
    see the external appliance turning on and off accordingly. Then turn off your
    appliance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on Activations and enter an activation. You should see your appliance automatically
    turning on and then off accordingly with the time and values you have entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not able to get the time from the NTP server, you may try to change
    the address. To find a new address, you can look at the link [http://tf.nist.gov/tf-cgi/servers.cgi](http://tf.nist.gov/tf-cgi/servers.cgi)
    or send a `ping` to the address `time.nist.gov` and use the returning address.
  prefs: []
  type: TYPE_NORMAL
- en: How to access the power plug from anywhere in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics to access your Arduino board from
    outside your home network. In other words, you will be able to use the iOS application
    through the mobile network to access your power plug behind your home router/firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section is provided for reference only because there are so many routers
    available in the market, and there are so many network configurations, that it
    is actually impossible to provide a complete guide. Anyway, with this brief overview
    of the matter, you should be able to configure your own devices.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next picture shows the typical configuration of a domestic network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Port forwarding](img/image00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s suppose that your IP addresses are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Router WAN IP: 82.61.147.56'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Router LAN IP: 192.168.1.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arduino Board IP: 192.168.1.4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, the IP address of the Arduino board on your internal network is not
    visible from the external network, at least unless you don't explicitly configure
    your router. This configuration is called IP port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, this configuration instructs the router to transfer the traffic it
    receives on a specific port to another IP address on a specific port.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, your port forwarding configuration has to be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: (82.61.147.56, 230) --> (192.168.1.4, 230)
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your router configuration page (usually via browser), you should be
    able to get the current IP that your Internet service provider has assigned to
    your router and configure the port forwarding. Read your router manual to learn
    how to set up this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have configured port forwarding, you can access the Arduino board
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP**: 82.61.147.56 (or better, the actual IP address assigned your own router)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: 230'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Pay attention to security!**'
  prefs: []
  type: TYPE_NORMAL
- en: Once you enable the port forwarding, anyone can access it. This means that anyone
    can easily get access to your power plug and control it. We should implement a
    protocol, which authenticates the iOS device, and encrypts all the messages exchanged.
    Unfortunately, Arduino does not have enough processing power and memory for this
    task. If you want to keep communication between an iOS device and Arduino secure,
    you have to set up a Virtual Private Network ([http://bit.ly/1ENoe3o](http://bit.ly/1ENoe3o)).
    There are many routers that provide a VPN, and iOS supports it natively.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic DNS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, each time your router connects to the Internet, it gets a different
    public IP address. So, you need to change the IP address of Arduino Manager each
    time your router is restarted. This is not practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many **Dynamic Domain Name Services** (**DDNS**) are available to dynamically
    associate the same name to your router IP address, even if the address changes.
    Most are available for free, among them: NoIP, yDNS, and FreeDNS.'
  prefs: []
  type: TYPE_NORMAL
- en: Most routers have DDNS client ready to use and easy to configure, otherwise,
    you may need to install simple software on a computer connected to your network.
  prefs: []
  type: TYPE_NORMAL
- en: Please visit the service provider's site to sign up and get installation and
    configuration procedures. Moreover, check your router for DDNS service availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have configured the Dynamic DNS service of your choice and supposing
    that you have chosen a domain like `powerplug.something.com`, you can access the
    Arduino with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP**: `powerplug.something.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: 230'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And you don't need to change them when you reboot your router.
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project we have developed can be improved in many ways, some improvements
    that you can try yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Control more external appliances using more Arduino pins, and more driver circuits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check and report to the user any conflicts between different activations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have built a device that allows you to control an external
    device (a lamp, a washing machine, a coffee kettle, and so on) manually or automatically,
    turning it on and off as you like, and/or at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned to make a power circuit without using a relay and manage it
    from Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: On Arduino, you have learned to write a program that reads and writes on the
    SD card, uses the Wi-Fi shield to communicate to iOS devices and to an external
    service (to get the current time), and manages an external power circuit for controlling
    the external device.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, you have learned how to design the user interface for a medium complex
    application also using the UITableView that is one of the most used components
    to interact with the user. You are now able to understand the MVC pattern and
    take advantage of it in your own programs. Moreover, you have learned to handle
    TCP/IP communication via TCP socket.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about coding Arduino and iOS for controlling a rover
    robot using the hardware features provided by the iOS devices (accelerometer).
  prefs: []
  type: TYPE_NORMAL
