- en: Chapter 3. Wi-Fi Power Plug
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：Wi-Fi电源插头
- en: 'The Wi-Fi Power Plug is a device through which you can control electrical appliances
    hooked up to it, turning them on and off in two ways:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi电源插头是一种设备，通过它可以控制连接到它的电器，以两种方式打开和关闭：
- en: Manually from your iOS device
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的iOS设备手动操作
- en: Automatically setting timers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动设置定时器
- en: For example, you can turn on your irrigation system every day at 6 P.M. for
    30 minutes, but if you see that your grass is turning yellow you can manually
    turn on the system for an additional watering.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在每天下午6点开启你的灌溉系统30分钟，但如果看到你的草坪变黄，你可以手动开启系统进行额外的浇水。
- en: Nowadays, this kind of device is available on the market for a reasonable price
    but building one yourself will allow you to understand how it works and adapt
    it to your own needs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种设备在市场上以合理的价格就可以买到，但自己制作一个将让你了解它是如何工作的，并适应你自己的需求。
- en: In comparison with the project in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Arduino
    and iOS – Platforms and Integration"), *Arduino and iOS – Platforms and Integration*,
    we are going to use Wi-Fi as the communication protocol. This will allow you to
    access the device even when you are not at home.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第1章](part0014.xhtml#aid-DB7S2 "第1章。Arduino和iOS – 平台和集成")中的项目相比，我们将使用Wi-Fi作为通信协议。这将允许你在不在家的时候也能访问设备。
- en: 'The chapter is organized in the following sections:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下部分：
- en: 'Wi-Fi power plug requirements: We will briefly set the project requirements'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi电源插头要求：我们将简要设定项目要求
- en: 'Hardware: We will describe the hardware and the electronic circuit needed for
    the project'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件：我们将描述项目所需的硬件和电子电路
- en: 'Arduino code: We will write the code for Arduino to control the external appliance
    and to communicate with the iOS device'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino代码：我们将为Arduino编写代码以控制外部设备并与iOS设备通信
- en: 'iOS code: We will write the code for the iOS device'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS代码：我们将为iOS设备编写代码
- en: How to access your power plug from anywhere in the world
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从世界任何地方访问你的电源插头
- en: 'How to go further: More ideas to improve the project and learn more'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更进一步：更多改进项目和学习的想法
- en: Wi-Fi power plug requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wi-Fi电源插头要求
- en: 'We are going to build a device that will be able to:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个能够：
- en: Turn an electric appliance hooked up to it on and off by receiving a command
    from the iOS device
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从iOS设备接收命令来打开和关闭连接到它的电器
- en: Turn on and off an electrical appliance on and off at specific times for a predefined
    lasting
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定时间打开和关闭电器，持续预定义的时间
- en: The accompanying iOS application has to manually control the power plug and
    manage the timers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的iOS应用程序需要手动控制电源插头和管理定时器。
- en: Hardware
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'As we mentioned in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Arduino
    and iOS – Platforms and Integration"), *Arduino and iOS – Platforms and Integration*,
    we need a Wi-Fi shield ([http://www.arduino.cc/en/Main/ArduinoWiFiShield](http://www.arduino.cc/en/Main/ArduinoWiFiShield))
    and a micro SD card formatted with FAT16 (take a look here for more details: [http://www.arduino.cc/en/Reference/SDCardNotes](http://www.arduino.cc/en/Reference/SDCardNotes)).
    The SD card is used to permanently store the activation times when Arduino is
    powered off, so its size is not so important.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0014.xhtml#aid-DB7S2 "第1章。Arduino和iOS – 平台和集成")中提到的，*Arduino和iOS
    – 平台和集成*，我们需要一个Wi-Fi屏蔽器([http://www.arduino.cc/en/Main/ArduinoWiFiShield](http://www.arduino.cc/en/Main/ArduinoWiFiShield))和一个格式化为FAT16的微SD卡（更多详情请查看：[http://www.arduino.cc/en/Reference/SDCardNotes](http://www.arduino.cc/en/Reference/SDCardNotes))。SD卡用于在Arduino断电时永久存储激活时间，因此其大小不是那么重要。
- en: Additional electronics components
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的电子组件
- en: 'In this project we need some additional components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们需要一些额外的组件：
- en: Optoisolator MOC3041
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光隔离器MOC3041
- en: 330 Ω resistor, 0.5 W
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 330 Ω电阻，0.5 W
- en: 330 Ω resistor, 0.25 W
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 330 Ω电阻，0.25 W
- en: Red LED
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色LED
- en: TRIAC BTA08-600
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三相可控硅BTA08-600
- en: The TRIAC is capable of 8 Amperes RMS at 600 V, which is about 1700 watts at
    220 V. You can use another TRIAC model of the same family (for example, BTA16)
    if you have a more powerful external appliance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 三相可控硅在600 V下可承受8安培均方根电流，在220 V下大约是1700瓦。如果你有一个更强大的外部设备，你可以使用同一系列的其他三相可控硅型号（例如，BTA16）。
- en: Electronic circuit
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子电路
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片显示了我们需要的项目电子电路的电原理图：
- en: '![Electronic circuit](img/image00175.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00175.jpeg)'
- en: The following picture shows how to mount the circuit on a breadboard.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了如何在面包板上安装电路。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to mount the Wi-Fi shield, and insert a micro SD card into it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记安装Wi-Fi盾牌，并将微型SD卡插入其中。
- en: '![Electronic circuit](img/image00176.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00176.jpeg)'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This circuit works with the power line (120 V or 220 V). Touching any part with
    power line voltage can be extremely dangerous and can kill you. Even professionals
    with years of experience have been injured or killed, so *please* be extremely
    careful. This means that if you have never worked with power line voltage, you
    need to do that under the control of a skilled person.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此电路使用电源线（120 V或220 V）。触摸任何带电源线电压的部分可能极其危险，甚至可能致命。即使是经验丰富的专业人士也可能会受伤或死亡，所以*请*务必非常小心。这意味着如果你从未操作过电源线电压，你需要在一个熟练的人的监督下进行。
- en: '*Again, avoid working with the power line yourself if you have not done it
    before. You are the only one responsible for any damage you may cause to yourself,
    your relatives and your stuff. You have been warned!*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*再次提醒，如果你之前没有这样做过，请避免自己操作电源线。你将是对自己、你的亲属和你的物品可能造成的任何损害的唯一责任人。你已经收到警告！*'
- en: If you don't feel safe handling the power line, you can still enjoy the project
    by replacing the power circuit with just the LED and the resistor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得操作电源线不安全，你仍然可以通过仅使用LED和电阻替换电源电路来享受这个项目。
- en: To power the external appliance we use a TRIAC ([http://bit.ly/1MzmIYs](http://bit.ly/1MzmIYs)),
    which allows you to control an AC load using a small current. Since the power
    plug uses the power line, the voltages around are high (120-220 V) and they can
    burn your Arduino. For that reason, an optoisolator is placed between the low
    voltage circuit (Arduino) and the high voltage circuit (TRIAC) ([http://bit.ly/1TV1JFc](http://bit.ly/1TV1JFc)).
    Basically, it is an LED and a low power TRIAC in the same small package. When
    the LED is on, a small current is generated for photoelectric effect and it polarizes
    the gate of the low power TRIAC switching it. The main point here is that the
    light electrically isolates the LED and the TRIAC.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给外部设备供电，我们使用晶闸管([http://bit.ly/1MzmIYs](http://bit.ly/1MzmIYs))，它允许你使用小电流控制交流负载。由于电源插头使用电源线，周围的电压很高（120-220
    V），并且可能会烧毁Arduino。因此，在低电压电路（Arduino）和高电压电路（晶闸管）之间放置了一个光电隔离器([http://bit.ly/1TV1JFc](http://bit.ly/1TV1JFc))。基本上，它是一个LED和一个低功率晶闸管在同一小封装中。当LED开启时，由于光电效应会产生小电流，并极化低功率晶闸管的栅极，从而切换它。这里的主要点是光电隔离了LED和晶闸管。
- en: A transistor and a relay can replace the TRIAC and the optoisolator, but a relay
    is an electromechanical device, which is subject to failures in short time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管和继电器可以替换晶闸管和光电隔离器，但继电器是一个机电装置，容易在短时间内出现故障。
- en: Turning the optoisolator LED from Arduino on and off is pretty easy, as it is
    wired to a digital pin (number 8 in our case) and controlled with `digitalWrite(<PIN>,
    HIGH | LOW)`. The external LED in series with the optoisolator has monitoring
    purpose only.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开和关闭Arduino上的光电隔离器LED非常简单，因为它连接到一个数字引脚（在我们的例子中是8号引脚），并通过`digitalWrite(<PIN>,
    HIGH | LOW)`进行控制。与光电隔离器串联的外部LED仅用于监控目的。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Controlling more appliances**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制更多设备**'
- en: If you need to control more appliances, you can replicate the power circuit
    (Optoisolator and TRIAC) and wire it to another digital pin. Then you need to
    adapt both the Arduino code and the iOS code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要控制更多设备，你可以复制电源电路（光电隔离器和晶闸管）并将其连接到另一个数字引脚。然后你需要调整Arduino代码和iOS代码。
- en: Arduino code
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino代码
- en: 'The full code of this project can be downloaded from here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的完整代码可以从这里下载：
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
- en: For a better understanding of the explanations in the next paragraphs, you should
    open the downloaded code while reading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，你应该在阅读时打开下载的代码。
- en: The power plug has to activate the external appliance at different times for
    a different lasting and then deactivate it. We are going to call **activation**
    a turn on-turn off cycle. Each activation can be represented by a square wave
    (see the following diagram).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 电源插头需要在不同的时间激活外部设备，然后关闭它。我们将*激活*称为开启-关闭周期。每个激活都可以用一个方波表示（见以下图表）。
- en: '![Arduino code](img/image00177.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino代码](img/image00177.jpeg)'
- en: Each activation starts at its **Start Time**, lasts for a **Length** (during
    which the appliance is on) and repeats exactly after a **Period** of time. A one-off
    activation has a period equal to 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个激活从其**开始时间**开始，持续**长度**（在此期间设备处于开启状态），并在**周期**时间后重复。一次性激活的周期等于0。
- en: We will use this diagram for understanding the Arduino code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此图来理解Arduino代码。
- en: 'The application can manage the `NUMBER_OF_ACTIVATIONS` activations stored in
    the global array `activations`. Each activation is a new type, defined as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以管理存储在全局数组`activations`中的`NUMBER_OF_ACTIVATIONS`个激活。每个激活是一个新类型，定义如下：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To make the code as simple as possible (and to save the flash memory) we save
    the entire array to the SD file, even if not all the activations are set. An activation
    is set if its name is set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码尽可能简单（并且节省闪存空间），我们将整个数组保存到SD文件中，即使不是所有的激活都被设置。如果一个激活被设置，那么它的名称就会被设置。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Flash memory**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**闪存**'
- en: Flash memory stores the program running on Arduino. Arduino UNO has 32 K of
    flash memory of which 0.5 K is used for the bootloader. The bootloader is a small
    code that allows programming UNO via USB instead of using an external in-circuit
    programmer (for example, an AVR-ISP or STK500).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存存储Arduino上运行的程序。Arduino UNO有32K的闪存，其中0.5K用于引导加载程序。引导加载程序是一段小代码，允许通过USB编程UNO，而不是使用外部在电路编程器（例如，AVR-ISP或STK500）。
- en: Setup code
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代码
- en: Please refer to the downloaded code, since the setup code is quite simple and
    doesn't require a detailed explanation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下载的代码，因为设置代码相当简单，不需要详细解释。
- en: Because we are handling time and Arduino does not have a real-time clock, we
    need to get the current time from a Network Time Protocol server on the net ([http://bit.ly/1NyCVM7](http://bit.ly/1NyCVM7));
    this is what the function `askTime` does. The request is sent via UPD ([http://bit.ly/1MzmQHb](http://bit.ly/1MzmQHb))
    and the answer is received on port 2390\. When a data packet is received, it is
    transformed into Unix time with the function `readTime` (see the `loop` function).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要处理时间，而Arduino没有实时时钟，我们需要从网络上的网络时间协议服务器获取当前时间（[http://bit.ly/1NyCVM7](http://bit.ly/1NyCVM7)）；这就是函数`askTime`所做的工作。请求通过UPD（[http://bit.ly/1MzmQHb](http://bit.ly/1MzmQHb)）发送，答案在2390端口接收。当接收到数据包时，它通过`readTime`函数（见`loop`函数）转换为Unix时间。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Unix time**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unix时间**'
- en: Unix time or Posix time is defined as the number of seconds that have elapsed
    since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970 ([http://bit.ly/1E6LP3m](http://bit.ly/1E6LP3m)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Unix时间或Posix时间定义为自1970年1月1日星期四00:00:00协调世界时（UTC）以来经过的秒数（[http://bit.ly/1E6LP3m](http://bit.ly/1E6LP3m)）。
- en: Main program
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: 'Let''s start with a simplified version of the main loop:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简化版的主循环开始：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Strings in flash memory**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**闪存中的字符串**'
- en: Usually Arduino stores static strings in RAM. Since RAM is also used for storing
    variables, we can move static strings to flash memory with the F() notation. For
    example, `Serial.println("iOS Device disconnected")`, wastes 23 bytes of RAM for
    storing the string `"iOS Device disconnected"`. Instead, writing `Serial.println(F("iOS
    Device disconnected"))` will let the string be stored in flash.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常Arduino会将静态字符串存储在RAM中。由于RAM也用于存储变量，我们可以使用F()符号将静态字符串移动到闪存中。例如，`Serial.println("iOS
    Device disconnected")`会浪费23个字节的RAM来存储字符串`"iOS Device disconnected"`。相反，写入`Serial.println(F("iOS
    Device disconnected"))`将使字符串存储在闪存中。
- en: The variable `server` represents the TCP server listening for connections. If
    a new client is connected and has data available for reading, `available` returns
    an instance of `WiFiClient` (`client`), which can be used for reading data. While
    the client is connected, (function `connected` returns true), we check if data
    is available. The function `available` returns the number of bytes available for
    reading, so while it returns a number greater than 0, we can read data and process
    them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`server`代表监听连接的TCP服务器。如果一个新的客户端连接并且有可读数据，`available`将返回一个`WiFiClient`实例（`client`），可以用来读取数据。当客户端连接时，（函数`connected`返回true），我们检查是否有数据可用。函数`available`返回可读字节数，所以当它返回一个大于0的数字时，我们可以读取数据并处理它们。
- en: 'The function `millis` returns the number of milliseconds since the board has
    been turned on, with the following instructions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`millis`返回自板子开启以来经过的毫秒数，以下指令：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function `checkActivations` is called every `ACTIVATION_CHECK_INTERVAL`
    seconds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`checkActivations`每`ACTIVATION_CHECK_INTERVAL`秒被调用一次。
- en: The `checkActivations` function checks each activation (which has a name) and
    based on the current time, turns the appliance on or off.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkActivations`函数检查每个激活（具有名称），并根据当前时间开启或关闭设备。'
- en: If the current time is between the activation start time and activation start
    time plus the activation length, the appliance has to be powered up.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前时间在激活开始时间和激活开始时间加上激活长度之间，设备必须开启。
- en: Please, note that the start time is in seconds since 1 January 1970\. On the
    other hand, the length is in minutes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开始时间是自1970年1月1日起的秒数。另一方面，长度是以分钟为单位的。
- en: If the appliance is turned on and the current time is greater than the start
    time plus the activation length, it has to be turned off. Then the activation
    is scaled of one period in order to be ready for the next activation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备已开启且当前时间大于开始时间加上激活长度，则必须关闭设备。然后激活周期减去一个周期，以便为下一次激活做好准备。
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since `checkActivations` is called every `ACTIVATION_CHECK_INTERVAL` seconds,
    an activation may be delayed by `ACTIVATION_CHECK_INTERVAL` with respect to its
    original time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`checkActivations`每`ACTIVATION_CHECK_INTERVAL`秒调用一次，激活可能会比其原始时间延迟`ACTIVATION_CHECK_INTERVAL`。
- en: Now we can take a look at the commands received from the iOS device (refer to
    the downloaded code).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看从iOS设备接收到的命令（参考下载的代码）。
- en: Each command starts with a byte, which represents the code of the command, and
    is followed by any additional data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令以一个字节开始，表示命令代码，其后跟任何附加数据。
- en: 'If the first byte is:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个字节是：
- en: '`''A''`: Arduino sends all the activations to the iOS devices, using the function
    `sendActivations`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''A''`：Arduino使用`sendActivations`函数将所有激活发送到iOS设备。'
- en: '`''U''`: It''s followed by one byte that represents the index of the activation
    (idx) to update, and by `sizeof(activation)` bytes, which represent the activation
    to update. Those bytes are copied on the existing activation with `memcpy((uint8_t
    *)&activations[idx], (uint8_t *)&inBuffer[2], sizeof(activation))`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''U''`：其后跟一个字节，表示要更新的激活（idx）的索引，以及`sizeof(activation)`字节，表示要更新的激活。这些字节通过`memcpy((uint8_t
    *)&activations[idx], (uint8_t *)&inBuffer[2], sizeof(activation))`复制到现有的激活中。'
- en: '`''D''`: It''s followed by one byte that represents the index of the activation
    (idx) to delete.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''D''`：其后跟一个字节，表示要删除的激活（idx）的索引。'
- en: '`''S''`: It''s followed by one byte that represents the new state of the appliance
    which is set with `digitalWrite(PHOTOISOLATOR_PIN, HIGH)` or `digitalWrite(PHOTOISOLATOR_PIN,
    LOW)`. If the user forces on the state of the appliance, the program enters in
    manual mode and activations are ignored.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''S''`：其后跟一个字节，表示设备的新状态，该状态通过`digitalWrite(PHOTOISOLATOR_PIN, HIGH)`或`digitalWrite(PHOTOISOLATOR_PIN,
    LOW)`设置。如果用户强制设置设备状态，程序进入手动模式，并忽略激活。'
- en: Moreover, until the iOS device is connected, Arduino sends its status using
    the function `sendStatus`, the first byte is the operation mode (manual or automatic)
    and the second one is the status of appliance (turned on or off).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在iOS设备连接之前，Arduino使用`sendStatus`函数发送其状态，第一个字节是操作模式（手动或自动），第二个字节是设备状态（开启或关闭）。
- en: The last function we have to look at is `updateActivations`. Let's suppose that
    we have set an activation at 1:00 P.M. which lasts for 1 minute and repeats every
    2 minutes. At 12:59 P.M. we turn off the Arduino and then restart it at 2 P.M.
    Since 2 P.M. > 1:02 P.M. (now > `startTime` + 60 *period) the activation doesn't
    start anymore. `updateActivations` has exactly the purpose to shift in time the
    repeating activation, so that they can be fired properly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须查看的最后一个函数是`updateActivations`。假设我们设置了一个在下午1点开始的持续1分钟的激活，每2分钟重复一次。在下午12:59，我们关闭Arduino，然后在下午2点重新启动。由于下午2点
    > 下午1:02（现在 > `startTime` + 60 *周期），激活不再启动。`updateActivations`正好具有将重复激活时间移位的目的，以便它们可以正确触发。
- en: '`updateActivations` is then called from the setup function and when the user
    gets back to automatic operations because during manual operations the activations
    are not checked and properly updated.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateActivations`随后从`setup`函数调用，当用户返回到自动操作时，因为手动操作期间不会检查和正确更新激活。'
- en: 'Using function `millis` to calculate current time may lead to significant errors
    after few days, so we periodically update time via the NTP Server with:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`millis`函数计算当前时间可能在几天后导致显著的误差，因此我们通过NTP服务器定期更新时间：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The predefined value for `TIME_SYNC_INTERVAL` updates the current time every
    24 hours.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME_SYNC_INTERVAL`的预定义值每24小时更新当前时间。'
- en: iOS code
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS代码
- en: In this chapter, we are going to look at the iOS application to manually turn
    on and off the electrical appliance and managing the activations for the automatic
    operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看iOS应用程序，手动打开和关闭电器，并管理自动操作的激活。
- en: 'The full code of this project can be downloaded from here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的完整代码可以从这里下载：
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
- en: To better understand the explanations in the next paragraphs, you should open
    the downloaded code while reading.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，您应该在阅读时打开下载的代码。
- en: Creating the Xcode project
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Xcode项目
- en: The first step is to create a new project. We are going to use the template
    Tabbed Application again, because it provides two view controllers. In this project,
    we will also add another one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的项目。我们将再次使用模板Tabbed Application，因为它提供了两个视图控制器。在这个项目中，我们还将添加另一个。
- en: 'Let''s create a new Tabbed Application project exactly as you did in the previous
    chapter and name it `PowerPlug`. Then:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Tabbed Application项目，就像上一章中做的那样，并将其命名为`PowerPlug`。然后：
- en: Rename `FirstViewController` as `PowerPlugViewController`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FirstViewController`重命名为`PowerPlugViewController`。
- en: Rename `SecondViewController` as `WiFiConnectionViewController`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SecondViewController`重命名为`WiFiConnectionViewController`。
- en: 'In this chapter we are going to use an additional library (`CocoaAsyncSocket`
    see [http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE)), which simplifies the communication
    over a TCP/IP socket. To install the library you can follow these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个额外的库（`CocoaAsyncSocket`，见[http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE)），它简化了通过TCP/IP套接字进行通信。要安装库，您可以按照以下步骤操作：
- en: Open the URL [http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开URL [http://bit.ly/1NGHDHE](http://bit.ly/1NGHDHE)。
- en: Click on the **Download ZIP** button (right side of the page). The file `CocoaAsyncSocket-master.zip`
    is downloaded into the `Downloads` folder.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右侧的**下载ZIP**按钮。文件`CocoaAsyncSocket-master.zip`将被下载到`下载`文件夹中。
- en: Unzip the downloaded file.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的文件。
- en: Locate `GCDAsyncSocket.h` and `GCDAsyncSocket.m`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位`GCDAsyncSocket.h`和`GCDAsyncSocket.m`。
- en: Drag these files and drop them to the Xcode project into the **PowerPlug** group.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些文件拖动并放到Xcode项目中**PowerPlug**组中。
- en: Be sure that this option is set **Copy Items if needed** (see the following
    screenshot) and click **Next**.![Creating the Xcode project](img/image00178.jpeg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保此选项设置为**如果需要则复制项目**（见以下截图）并点击**下一步**。![创建Xcode项目](img/image00178.jpeg)
- en: Adding a new view controller
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的视图控制器
- en: 'We now add the additional view controller class and the additional view controller
    graphical container that we need, using the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加所需的额外视图控制器类和额外的视图控制器图形容器，按照以下步骤进行：
- en: Select the `PowerPlug` folder in the left panel and right click on it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择`PowerPlug`文件夹，然后右键点击它。
- en: Select **New File…**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建文件…**。
- en: In the left pane select **iOS Source** and in the right one select **Cocoa Touch
    Class**, then click on **Next**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择**iOS源**，在右侧面板中选择**Cocoa Touch类**，然后点击**下一步**。
- en: In the **Subclass** of the list box, select **UITableViewController**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表框的**子类**中，选择**UITableViewController**。
- en: In the **Class** field enter `ActivationsTableViewController` (refer to the
    next screenshot) and click on **Next**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`ActivationsTableViewController`（参考下一张截图）并点击**下一步**。
- en: Click on **Save** on the next window.![Adding a new view controller](img/image00179.jpeg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中点击**保存**。![创建Xcode项目](img/image00179.jpeg)
- en: Select **Main.storyboard** in the left panel.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择**Main.storyboard**。
- en: Open the Utilities panel (**View** | **Utilities** | **Show Utilities**).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开实用工具面板（**视图** | **实用工具** | **显示实用工具**）。
- en: In the Utilities panel's search field enter `UIViewController`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实用工具面板的搜索字段中输入`UIViewController`。
- en: Drag the UIViewController to the storyboard.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UIViewController拖动到故事板中。
- en: Select the just added view controller.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择刚刚添加的视图控制器。
- en: Open the Identity Inspector (**View** | **Utilities** | **Show** **Identity
    inspector**, or click on the icon circled in red in the next picture).![Adding
    a new view controller](img/image00180.jpeg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开身份检查器（**视图** | **实用工具** | **显示** **身份检查器**，或在下一张图片中点击红色圆圈图标）。![添加新的视图控制器](img/image00180.jpeg)
- en: In the **Class** list box, select **ActivationsTableViewController**. View controller's
    class and the GUI are now tied together.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**列表框中，选择**ActivationsTableViewController**。现在视图控制器类和GUI已经绑定在一起。
- en: We now have to add the new view controller into the Tab Bar of the main view
    controller. Pressing the *Control* key, drag your mouse pointer from the **Tab
    Bar Controller** to the **ActivationsTableViewController** and then release (see
    the next screenshot).![Adding a new view controller](img/image00181.jpeg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须将新的视图控制器添加到主视图控制器的标签栏中。按下*控制*键，将鼠标指针从**标签栏控制器**拖动到**ActivationsTableViewController**，然后释放（见下一张截图）。![添加新的视图控制器](img/image00181.jpeg)
- en: When the small dialog shown in the next screenshot appears, select **Relationship**
    **Segues** | **view controllers**.![Adding a new view controller](img/image00182.jpeg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现下一张截图所示的小对话框时，选择**关系** **切换** | **视图控制器**。![添加新的视图控制器](img/image00182.jpeg)
- en: Now the new view controller is added to the **Tab Bar** (see next screenshot).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在新的视图控制器已添加到**标签栏**（见下一张截图）。
- en: '![Adding a new view controller](img/image00183.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![添加新的视图控制器](img/image00183.jpeg)'
- en: We need the new view control to be the second one in the Tab Bar. To move it,
    you can click and drag it to the desired position.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要新的视图控制器在标签栏中是第二个。要移动它，您可以单击并拖动它到所需的位置。
- en: Don't forget to change the text in the Tool Bar, respectively to `PowerPlug`,
    `Activations`, and `Configuration`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更改工具栏中的文本，分别改为`PowerPlug`、`Activations`和`Configuration`。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the downloaded code, you find three icons to use with each view controller.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载的代码中，您会发现每个视图控制器可以使用三个图标。
- en: 'Since we need to show details of the elements in the table, we need to embed
    the ActivationsTableViewController in a navigation controller:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要显示表格中元素的具体信息，我们需要在导航控制器中嵌入ActivationsTableViewController：
- en: Select **ActivationsTableViewController**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**ActivationsTableViewController**。
- en: Select **Editor** | **Embed in…** | **Navigation Controller**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**编辑器** | **嵌入在…** | **导航控制器**。
- en: 'You should end up with a structure similar to the one shown in the next screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结构应该类似于下一张截图所示：
- en: '![Adding a new view controller](img/image00184.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![添加新的视图控制器](img/image00184.jpeg)'
- en: Adding a class for storing the information of each activation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为存储每个激活的信息添加类
- en: To store information about each activation, we need a class `Activation`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储每个激活的信息，我们需要一个名为`Activation`的类。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Model View Controller**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**'
- en: 'Technically speaking, we are now creating the "Model" of the Model View Controller
    pattern. You can find a brief introduction of the MVC pattern here: [http://apple.co/1hkUDbU](http://apple.co/1hkUDbU)
    and a complete discussion here: [http://apple.co/1EEpNzL](http://apple.co/1EEpNzL).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度讲，我们现在正在创建模型-视图-控制器模式的“模型”。您可以在以下位置找到MVC模式的简要介绍：[http://apple.co/1hkUDbU](http://apple.co/1hkUDbU)
    和完整的讨论：[http://apple.co/1EEpNzL](http://apple.co/1EEpNzL)。
- en: 'To create the class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类：
- en: Select the **PowerPlug** group in the left panel, right-click it and then select
    **New File…**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择**PowerPlug**组，右键单击它，然后选择**新建文件…**。
- en: In the left panel, select **Source** and in the right panel, select **Cocoa
    Touch Class**, then click on **Next**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择**源**，在右侧面板中选择**Cocoa Touch 类**，然后点击**下一步**。
- en: Select **NSObject** in the **Subclass** list box.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**子类**列表框中选择**NSObject**。
- en: Enter `Activation` in **Class Text Field** (see next picture) and click **Next**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类文本字段**中输入`Activation`（见下一图）并点击**下一步**。
- en: Click on **Save**.![Adding a class for storing the information of each activation](img/image00185.jpeg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**。![为存储每个激活的信息添加类](img/image00185.jpeg)
- en: 'Open the `Activation.h` file and enter the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Activation.h`文件并输入以下代码：
- en: '[PRE5]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The project is now ready for the next steps, and we can start working on the
    view controllers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已准备好进行下一步，我们可以开始处理视图控制器。
- en: Designing the application user interface for WiFiConnectionViewController
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计WiFiConnectionViewController的应用程序用户界面
- en: As we did in the previous project, we start from the view controller, which
    allows us to enter the connection information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个项目中做的那样，我们从视图控制器开始，这允许我们输入连接信息。
- en: It is made of two labels, two fields to enter the IP address, the IP port assigned
    to the Arduino and a button to update the connection information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它由两个标签、两个输入IP地址的字段、分配给Arduino的IP端口和一个更新连接信息的按钮组成。
- en: 'Please refer to the following screenshot to design it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图来设计它：
- en: '![Designing the application user interface for WiFiConnectionViewController](img/image00186.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![为WiFiConnectionViewController设计应用程序用户界面](img/image00186.jpeg)'
- en: 'Since both fields accept only numbers and periods, we can make a properly set
    keyboard to help the user. To do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个字段只接受数字和句点，我们可以设置一个合适的键盘来帮助用户。为此：
- en: Select a field.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个字段。
- en: Open the Identity Inspector (**View** | **Utilities** | **Show** **Identity
    inspector**).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开身份检查器（**视图** | **实用工具** | **显示** **身份检查器**）。
- en: Select **Numbers and Punctuation** in the **Keyboard Type** list box.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**键盘类型**列表框中选择**数字和标点**。
- en: 'Now, link the user interface components to the code ending with the following
    in `WiFiConnectionViewController.m`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`WiFiConnectionViewController.m`中将用户界面组件链接到以下代码：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't forget to link the `UITextFields` delegate to the view controller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`UITextFields`代理链接到视图控制器。
- en: Refer to the downloaded code for more details and compare your results with
    the provided application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下载的代码以获取更多详细信息，并将您的结果与提供的应用程序进行比较。
- en: Designing the application user interface for PowerPlugViewController
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PowerPlugViewController设计应用程序用户界面
- en: This view controller manages the manual operation with the power plug that is
    capable of manually switching on and off the power to the hooked device.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器管理与电源插头的手动操作，该插头能够手动开关连接设备的电源。
- en: 'The final layout of this view controller is shown in the next screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器的最终布局如图所示：
- en: '![Designing the application user interface for PowerPlugViewController](img/image00187.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![为PowerPlugViewController设计应用程序用户界面](img/image00187.jpeg)'
- en: The component numbered **1** is a `UIImageView` and its purpose is to show if
    the hooked appliance is powered on or off. To add this component, just drag and
    drop it and select the image (`LEDdisabled.png` that you can find in the downloaded
    project) to to be displayed, using the **Attributes Inspector**. The size of the
    image view is 60 × 60, which can be set adding the proper layout constraints.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编号为**1**的组件是一个`UIImageView`，其目的是显示连接的电器是开启还是关闭。要添加此组件，只需拖放并选择要显示的图像（在下载的项目中可以找到的`LEDdisabled.png`），使用**属性检查器**。图像视图的大小为60
    × 60，可以通过添加适当的布局约束来设置。
- en: The component numbered **2** is a switch button (`UISwitch`) to actually switch
    the appliance on and off manually. We can add this component to the container
    like we did with the others.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编号为**2**的组件是一个开关按钮（`UISwitch`），用于手动开关电器。我们可以像处理其他组件一样将此组件添加到容器中。
- en: 'The component numbered **3** is a button (`UIButton`) to reconnect to Arduino
    in case the connection is lost and the component numbered **4** is a `UIView`,
    which shows if the Arduino is connected or not by the means of its color (light
    gray: disconnected, green: connected).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编号为**3**的组件是一个按钮（`UIButton`），用于在连接丢失时重新连接到Arduino；编号为**4**的组件是一个`UIView`，通过其颜色（浅灰色：未连接，绿色：已连接）显示Arduino是否已连接。
- en: 'Once you have added the components and the required Auto Layout constraints,
    you can link the components to the code ending with:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了组件和所需的自动布局约束，您可以将组件链接到以下代码：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Designing the application user interface for ActivationsTableViewController
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为ActivationsTableViewController设计应用程序用户界面
- en: The ActivationsTableViewController view controller shows all the existing activations
    in a table.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ActivationsTableViewController视图控制器以表格形式显示所有现有的激活。
- en: First, we have to add a class to store information about the cell of each row
    in the table. To add this class, follow the same steps used in the previous chapters
    subclassing from `UITableViewCell` and calling the class `ActivationTableViewCell`
    (see next screenshot).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须添加一个类来存储表格中每一行单元格的信息。要添加此类，请遵循前几章中用于从`UITableViewCell`派生并调用类`ActivationTableViewCell`的相同步骤（见下一张截图）。
- en: '![Designing the application user interface for ActivationsTableViewController](img/image00188.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![为ActivationsTableViewController设计应用程序用户界面](img/image00188.jpeg)'
- en: 'In the `ActivationTableViewCell.h` file, change the code as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ActivationTableViewCell.h`文件中，按照以下方式更改代码：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now ready to create the custom cell to show each activation information
    of the power plug, and link it with the ActivationTableViewCell. We are going
    to show only the main steps, but you can refer to the downloaded code for all
    the details.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个自定义单元格来显示电源插头的每个激活信息，并将其与ActivationTableViewCell链接。我们将只展示主要步骤，但您可以参考下载的代码以获取所有详细信息。
- en: In the **Main.storyboard**, select the **ActivationsTableViewController** and
    then the **Prototypes Cells** in it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Main.storyboard**中，选择**ActivationsTableViewController**，然后选择其中的**原型单元格**。
- en: Open the Identity Inspector and select **ActivationTableViewCell** in the **Class**
    list box.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开身份检查器，并在**类**列表框中选择**激活单元格视图控制器**。
- en: Select the Attribute Inspector.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择属性检查器。
- en: Enter `activationCell` in the **Identifier** field.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**标识符**字段中输入`activationCell`。
- en: Select the Size Inspector and 66 in the **Row Height** field.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择大小检查器，并在**行高**字段中选择66。
- en: Now you can enter the labels (UILabel) to show the different information of
    each activation, change colors and font sizes, and add the layout constraints
    ending with a cell prototype like that shown in the next screenshot:![Designing
    the application user interface for ActivationsTableViewController](img/image00189.jpeg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以输入标签（UILabel）以显示每个激活的不同信息，更改颜色和字体大小，并添加以单元格原型结束的布局约束，如下一个屏幕截图所示：![为ActivationsTableViewController设计应用程序用户界面](img/image00189.jpeg)
- en: We now have to link the cell components to the class ActivationTableViewCell.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将单元格组件链接到类ActivationTableViewCell。
- en: Go to **Editor** | **Show Document Outline** (you can also open this panel using
    the icon circled red in the next screenshot).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑器** | **显示文档大纲**（您也可以使用下一个屏幕截图中圈红的图标打开此面板）。
- en: Locate the **Activations Table View Controller** **Scene** and expand it (see
    next screenshot).![Designing the application user interface for ActivationsTableViewController](img/image00190.jpeg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**激活表格视图控制器** **场景**并展开它（见下一个屏幕截图）。![为ActivationsTableViewController设计应用程序用户界面](img/image00190.jpeg)
- en: Select the **activationCell** and right-click on it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**激活单元**并右键点击它。
- en: Keeping the *Control* key pressed, drag each property of the class to the related
    graphical component (see the next screenshot).![Designing the application user
    interface for ActivationsTableViewController](img/image00191.jpeg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*控制*键，将类的每个属性拖到相关的图形组件上（见下一个屏幕截图）。![为ActivationsTableViewController设计应用程序用户界面](img/image00191.jpeg)
- en: 'We need to complete the last step: creating the view controller for entering
    and editing each activation (ActivationViewController).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成最后一步：创建输入和编辑每个激活的视图控制器（ActivationViewController）。
- en: We start adding a new class inherited from UIViewController called `ActivationViewController`,
    then we drag and drop a new view controller into the **Main.Storyboard**, and
    we change its class to `ActivationViewController` in the **Identity Inspector**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始添加一个从UIViewController继承的新类，称为`ActivationViewController`，然后我们将新的视图控制器拖放到**Main.Storyboard**中，并在**身份检查器**中将它的类更改为`ActivationViewController`。
- en: 'This view controller uses two new components:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器使用了两个新的组件：
- en: 'UIDatePicker: It allows the user to choose a date. In our case, the date at
    which the activation has to start.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIDatePicker：它允许用户选择一个日期。在我们的情况下，是激活必须开始的日期。
- en: 'UISegmentControl: It allows the user to easily choose the length of activation
    and how often the activation has to be started.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UISegmentControl：它允许用户轻松选择激活的长度以及激活必须启动的频率。
- en: 'The final layout of the controller is shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的最终布局如下截图所示：
- en: '![Designing the application user interface for ActivationsTableViewController](img/image00192.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![为ActivationsTableViewController设计应用程序用户界面](img/image00192.jpeg)'
- en: 'The component can be dropped into the container as we already have learned,
    and we can set their layout constraints as we did in the other view controllers.
    The components are linked to the code as usual:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以像我们已经学过的那样拖入容器中，我们可以设置它们的布局约束，就像在其他视图控制器中做的那样。组件通常与代码链接：
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to edit activations, we need the ActivationViewController to show
    when the user taps on a row of the table. To do this, we have to create a segue
    from the cell to the view controller with the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编辑激活，我们需要在用户点击表格的行时显示ActivationViewController。为此，我们必须从单元格创建一个 segue 到具有以下步骤的视图控制器：
- en: Keeping *Control* pressed, drag your mouse pointer from the cell to the ActivationViewController
    (see the following screenshot).![Designing the application user interface for
    ActivationsTableViewController](img/image00193.jpeg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*控制*键，将鼠标指针从单元格拖到ActivationViewController（见下一个屏幕截图）。![为ActivationsTableViewController设计应用程序用户界面](img/image00193.jpeg)
- en: When the black dialog appears, select **show**:![Designing the application user
    interface for ActivationsTableViewController](img/image00194.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现黑色对话框时，选择**显示**：![为ActivationsTableViewController设计应用程序用户界面](img/image00194.jpeg)
- en: You can find all the details about the ActivationViewController in the downloaded
    code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下载的代码中找到有关ActivationViewController的所有详细信息。
- en: This ActivationsTableViewController is finally completed. Let's take a breath
    and sip a cup of coffee before getting into writing the code of our view controllers.
    It has been a long and complex run, and we actually deserve a cup of coffee (or
    tea if you prefer!).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ActivationsTableViewController 最后完成了。在我们开始编写视图控制器的代码之前，让我们先喘口气，喝杯咖啡。这是一段漫长而复杂的过程，我们实际上应该喝杯咖啡（或者如果你更喜欢的话，喝茶！）。
- en: Writing code for the WiFiConnectionViewController
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 WiFiConnectionViewController 编写代码
- en: This view controller has the purpose to make sure the user enters the IP address
    and IP port assigned to Arduino in order to connect to it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器的作用是确保用户输入分配给 Arduino 的 IP 地址和 IP 端口以连接到它。
- en: In this project, we are going to store this information in a file, instead of
    storing it in User Preferences as we did in the Pet Door Locker.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将把信息存储在文件中，而不是像我们在 Pet Door Locker 中做的那样存储在用户偏好设置中。
- en: 'When the update button is tapped, this code is executed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击更新按钮时，执行以下代码：
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The values of the two fields are stored in an NSMutableDictionary (`connectionInformation`)
    and stored into a file called `writeToFile`. This file is saved into a directory
    `documentsDirectory` that is accessible by the application only.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字段的值存储在 `NSMutableDictionary` (`connectionInformation`) 中，并存储在一个名为 `writeToFile`
    的文件中。此文件保存在名为 `documentsDirectory` 的目录中，该目录仅对应用程序可访问。
- en: Before saving the information, we need to check that the IP address is properly
    formatted, and that the port is in the allowed range (see the downloaded code
    for all the details).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存信息之前，我们需要检查 IP 地址是否格式正确，端口是否在允许的范围内（有关所有详细信息，请参阅下载的代码）。
- en: Since we set the text field's delegate properties, each time the user is done
    editing the field, one of the following methods is called and we can make the
    keyboard disappear using `resignFirstResponder`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了文本字段的代理属性，每次用户完成字段的编辑时，以下方法之一将被调用，我们可以使用 `resignFirstResponder` 来隐藏键盘。
- en: '[PRE11]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we tap on the text field Period, the keyboard covers it (at least on smaller
    devices like the iPhone). To avoid this issue, we can shift up the entire view,
    using a couple of delegate methods of UITextView. When we tap the field, the `textFieldDidBeginEditing`
    method is called, and when we exit the field or tap return, the `textFieldDidBeginEditing`
    method is called.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击文本字段 Period 时，键盘会覆盖它（至少在像 iPhone 这样的较小设备上）。为了避免这个问题，我们可以使用几个 UITextView
    的代理方法将整个视图向上移动。当我们点击字段时，会调用 `textFieldDidBeginEditing` 方法，当我们退出字段或点击回车时，也会调用 `textFieldDidBeginEditing`
    方法。
- en: 'In the `textFieldDidBeginEditing` method we can translate the field, assigning
    a translation transformation to the field with:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `textFieldDidBeginEditing` 方法中，我们可以翻译字段，通过将转换变换分配给字段来实现：
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we end with these two additional methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们以这两个附加方法结束：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each time this view controller is shown, both fields are filled in with the
    existing values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每次显示此视图控制器时，两个字段都会用现有值填充。
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Writing code for AppDelegate
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 AppDelegate 编写代码
- en: In this project, the connection to Arduino and the communication is managed
    into `AppDelegate`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，Arduino 的连接和通信由 `AppDelegate` 管理。
- en: 'For this purpose, we need some properties:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们需要一些属性：
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `socket` property (provided by the library we added) is a channel used for
    sending and receiving data from Arduino. The array `activations` stores all the
    activations the user creates.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket` 属性（由我们添加的库提供）是一个用于从 Arduino 发送和接收数据的通道。数组 `activations` 存储了用户创建的所有激活。'
- en: 'When the app starts or enters in the foreground, it starts a connection with
    Arduino:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动或进入前台时，它开始与 Arduino 建立连接：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the connection to Arduino is successful, the delegate method `didConnectToHost`
    is called.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 Arduino 的连接成功，将调用代理方法 `didConnectToHost`。
- en: 'The method `readDataWithTimeout` allows you to receive data from the counterpart:
    when data is available, the method `didReadData` is called.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`readDataWithTimeout` 方法允许您从对端接收数据：当有数据可用时，调用 `didReadData` 方法。'
- en: Since we have set a timeout (5 seconds), if no data is received within this
    time interval, the method `socketDidDisconnect` is called.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了超时（5秒），如果在这么长时间内没有接收到数据，则调用 `socketDidDisconnect` 方法。
- en: Let's take a look at each method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个方法。
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we just notify the `PowerPlugViewController` instance that the connection
    was successful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是通知 `PowerPlugViewController` 实例连接已成功。
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we just notify the `PowerPlugViewController` instance that the Arduino
    has disconnected, and we release the activations we were using.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是通知 `PowerPlugViewController` 实例 Arduino 已断开连接，并且我们释放了我们正在使用的激活。
- en: 'From Arduino we can receive two kinds of messages:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Arduino 我们可以接收两种类型的消息：
- en: '**Status**: It starts with character `''S''` and it''s followed by two bytes:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：它以字符 `''S''` 开头，后面跟着两个字节：'
- en: First byte is 1 if the appliance has been turned on manually, 0 otherwise
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字节为 1 如果电器是手动开启的，否则为 0
- en: 'Second byte is the status of the appliance: 0 if it''s switched off, 1 if it
    is switched on'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个字节是电器的状态：如果关闭则为 0，如果开启则为 1
- en: '**Activations**: It starts with character `''A''` and it''s followed by `ACTIVATION_SIZE_ON_ARDUINO
    * NUMBER_OF_ACTIVATIONS` bytes which represent activations'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活**：它以字符 `''A''` 开头，后面跟着 `ACTIVATION_SIZE_ON_ARDUINO * NUMBER_OF_ACTIVATIONS`
    个字节，这些字节代表激活'
- en: Messages coming from Arduino are received in the following method, and are processed
    following the previous rules.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中接收来自 Arduino 的消息，并按照之前的规则进行处理。
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If a Status message is received, the `PowerPlugViewController` instance is
    notified:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到状态消息，`PowerPlugViewController` 实例会被通知：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If an Activations message is received, each activation is added to `_activations`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到激活消息，每个激活都会添加到 `_activations` 中：
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the end, the instance of ActivationsViewController is notified that all
    the activations are available:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ActivationsViewController 的实例会被通知所有激活都可用：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: AppDelegate also implements delegate methods for PowerPlugViewController and
    ActivationsViewController view controllers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: AppDelegate 也实现了 PowerPlugViewController 和 ActivationsViewController 视图控制器的代理方法。
- en: For ActivationsViewController, the implemented methods are `getActivations`,
    `updateActivationOfIndex`, and `deleteActivationOfIndex`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ActivationsViewController，实现的方法是 `getActivations`、`updateActivationOfIndex`
    和 `deleteActivationOfIndex`。
- en: The method `getActivations` is called by the ActivationsViewController when
    it needs to show the list of configured activations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ActivationsViewController 需要显示配置的激活列表时，会调用 `getActivations` 方法。
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If `_activations` is nil, a message to Arduino is sent which will respond with
    the list of all the activations. The message is very easy: only one byte with
    the value `''A''` (Activations).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `_activations` 为空，则向 Arduino 发送一条消息，它将响应所有激活的列表。消息非常简单：只有一个字节，值为 `'A'`（激活）。
- en: 'The message is actually sent to Arduino calling:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 消息实际上是通过调用 Arduino 发送的：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The method `updateActivationOfIndex` is called by ActivationsViewController
    when an activation has been updated (or added). The method `deleteActivationOfIndex`
    is called by ActivationsViewController when an activation has to be deleted.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活被更新（或添加）时，ActivationsViewController 会调用 `updateActivationOfIndex` 方法。当需要删除激活时，ActivationsViewController
    会调用 `deleteActivationOfIndex` 方法。
- en: For the complete implementation of these two methods, look at the downloaded
    code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个方法的完整实现，请查看下载的代码。
- en: Methods implemented for PowerPlugViewController are `sendSwitchCommand` and
    `reconnect`, which are very easy and you can understand them directly from the
    downloaded code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为 PowerPlugViewController 实现的方法是 `sendSwitchCommand` 和 `reconnect`，它们非常简单，你可以直接从下载的代码中理解它们。
- en: Writing code for PowerPlugViewController
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 PowerPlugViewController 的代码
- en: This view controller manages manual operations of the appliance attached to
    the power plug.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器管理连接到电源插座的电器的手动操作。
- en: First, we need to declare the delegate methods and messages to which this view
    controller responds.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明这个视图控制器响应的代理方法和消息。
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This view controller is very easy and its methods are quite auto explicative
    and self explanatory. We just need to take a look at `updateStatus`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器非常简单，其方法相当自解释和直观。我们只需要看看 `updateStatus` 方法：
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the `applianceStatus` is true, the appliance is turned on, and we set the
    image `LEDon.png` to the imageView (`_applianceStatus`). This image simulates
    an LED turned on. When the appliance is turned off, the image shown is `LEDoff.png`,
    which simulates an LED being turned off.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `applianceStatus` 为真时，电器被开启，我们将图像 `LEDon.png` 设置到 imageView (`_applianceStatus`)
    中。这个图像模拟了一个开启的 LED。当电器关闭时，显示的图像是 `LEDoff.png`，模拟了一个关闭的 LED。
- en: Writing code for ActivationsTableViewController
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 ActivationsTableViewController 的代码
- en: This view controller manages the list of activations, allowing the user to add,
    delete, and update each activation. It is based on the UITableView component,
    which is one of the most used and powerful components of the UIKit.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器管理激活列表，允许用户添加、删除和更新每个激活。它基于UITableView组件，这是UIKit中最常用且功能强大的组件之一。
- en: 'Let''s start from `ActivationsTableViewController.h`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ActivationsTableViewController.h`开始：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By now, you should be able to recognize the delegate protocol and messages to
    which the view controller responds.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够识别出视图控制器响应的代理协议和消息。
- en: 'Let''s start from the implementation of the UITableView delegate methods. The
    first is `numberOfRowsInSection`, which is called from the table when it needs
    to know how many items it has to show:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从UITableView代理方法的实现开始。第一个是`numberOfRowsInSection`，当表格需要知道它需要显示多少项时会被调用：
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It doesn''t require many explanations. The method `cellForRowAtIndexPath` is
    called by the UIViewTable for each row to be shown:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要很多解释。`cellForRowAtIndexPath`方法由UIViewTable为每个要显示的行调用：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Calling the method `[tableView dequeueReusableCellWithIdentifier:@"activationCell"]`
    we get a cell and we fill it with the values of one activation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法`[tableView dequeueReusableCellWithIdentifier:@"activationCell"]`我们得到一个单元格，并填充一个激活的值。
- en: 'If the previous function returns nil, there is not an available cell, and one
    has to be created with:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一个函数返回nil，则没有可用的单元格，必须创建一个：
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Take a look at the downloaded code to see the full method implementation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下载的代码以查看完整的方法实现。
- en: 'When a row is deleted from the UITableView, the following method is called:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当从UITableView中删除一行时，会调用以下方法：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Method `deleteRowsAtIndexPaths` removes the row from the table and the delegate
    method `deleteActivationOfIndex` creates a message that is then sent to Arduino
    for deleting an activation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`deleteRowsAtIndexPaths`从表中删除行，而代理方法`deleteActivationOfIndex`创建一个消息，然后发送到Arduino以删除一个激活。
- en: When designing the interface we created a segue from the table cell to the ActivationViewController
    in order that when the user taps a table row, the ActivationViewController appears.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计界面时，我们从一个表格单元格到ActivationViewController创建了一个转场，以便当用户点击表格行时，ActivationViewController会出现。
- en: 'Before the ActivationViewController is started, the method `prepareForSegue`
    is called:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动ActivationViewController之前，会调用`prepareForSegue`方法：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we set the delegate property of ActivationViewController and we store the
    index of the selected row.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置ActivationViewController的代理属性，并存储所选行的索引。
- en: Tip
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Segue identifier**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**转场标识符**'
- en: 'The method `prepareForSegue` is called for each segue that starts from the
    view controller. Usually, different target view controllers require different
    initialization code. In the Interface Builder you can set the **Identifier** of
    each segue, and use these instructions for distinguishing between segues:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从视图控制器开始的每个转场，都会调用`prepareForSegue`方法。通常，不同的目标视图控制器需要不同的初始化代码。在Interface Builder中，您可以设置每个转场的**标识符**，并使用这些说明来区分转场：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The ActivationViewController requires two delegate methods, which don''t require
    any explanation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ActivationViewController需要两个代理方法，这些方法不需要任何解释：
- en: 'The first is `getActivation`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是`getActivation`：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second is `update`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`update`：
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We just point out that `[self.tableView reloadData]` forces the table view to
    reload data, starting from calling `numberOfRowsInSection` and then calling `cellForRowAtIndexPath`
    for each row.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是指出，`[self.tableView reloadData]`强制表格视图重新加载数据，从调用`numberOfRowsInSection`开始，然后为每一行调用`cellForRowAtIndexPath`。
- en: Writing code for ActivationTableViewController
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为ActivationTableViewController编写代码
- en: This view controller doesn't do much more than getting the user entered values
    and updating the selected activation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图控制器除了获取用户输入的值和更新所选激活外，没有做更多的事情。
- en: To understand the details, refer to the code provided with the book.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解详细信息，请参阅书中提供的代码。
- en: Testing and tuning
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和调整
- en: 'When you have completed your application, you can test the system following
    these steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成应用程序后，您可以按照以下步骤测试系统：
- en: Change IP information (IP, gateway, and so on) and network information (SSID,
    pass) in the Arduino sketch to adapt them to your own network configuration. You
    may need to access your router configuration page to get this information.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Arduino草图中将IP信息（IP、网关等）和网络信息（SSID、密码）更改以适应您自己的网络配置。您可能需要访问路由器配置页面以获取此信息。
- en: Upload the sketch to Arduino.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将草图上传到Arduino。
- en: Check the Arduino console for any error messages.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Arduino控制台是否有任何错误信息。
- en: Connect the driver circuit to the power line and to an external appliance (a
    lamp can do the job). Please, follow all the required security measures to avoid
    any electric shocks.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将驱动电路连接到电源线和外部设备（一盏灯就可以完成这项工作）。请遵循所有必要的安全措施，以避免任何电击。
- en: Run the iOS application on your device or in the simulator.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备或模拟器上运行iOS应用程序。
- en: Tap on Configuration and enter the IP address and port you have set in the Arduino
    sketch.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击配置并输入你在Arduino草图设置的IP地址和端口。
- en: Tap on the power plug, connect and switch the button on and off. You should
    see the external appliance turning on and off accordingly. Then turn off your
    appliance.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击电源插座，连接并开关按钮。你应该看到外部设备相应地打开和关闭。然后关闭你的设备。
- en: Tap on Activations and enter an activation. You should see your appliance automatically
    turning on and then off accordingly with the time and values you have entered.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击激活并输入一个激活码。你应该看到你的设备会根据你输入的时间和值自动打开和关闭。
- en: If you are not able to get the time from the NTP server, you may try to change
    the address. To find a new address, you can look at the link [http://tf.nist.gov/tf-cgi/servers.cgi](http://tf.nist.gov/tf-cgi/servers.cgi)
    or send a `ping` to the address `time.nist.gov` and use the returning address.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法从NTP服务器获取时间，你可以尝试更改地址。要找到新的地址，你可以查看链接[http://tf.nist.gov/tf-cgi/servers.cgi](http://tf.nist.gov/tf-cgi/servers.cgi)或向地址`time.nist.gov`发送`ping`并使用返回的地址。
- en: How to access the power plug from anywhere in the world
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从世界任何地方访问电源插座
- en: In this section, you will learn the basics to access your Arduino board from
    outside your home network. In other words, you will be able to use the iOS application
    through the mobile network to access your power plug behind your home router/firewall.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何从家庭网络外部访问你的Arduino板的基础知识。换句话说，你将能够通过移动网络使用iOS应用程序访问你家庭路由器/防火墙后面的电源插座。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This section is provided for reference only because there are so many routers
    available in the market, and there are so many network configurations, that it
    is actually impossible to provide a complete guide. Anyway, with this brief overview
    of the matter, you should be able to configure your own devices.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅提供参考，因为市场上有很多路由器，网络配置也很多，实际上不可能提供完整的指南。无论如何，通过这个简要概述，你应该能够配置自己的设备。
- en: Port forwarding
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口转发
- en: The next picture shows the typical configuration of a domestic network.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图片显示了典型家庭网络的配置。
- en: '![Port forwarding](img/image00195.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![端口转发](img/image00195.jpeg)'
- en: 'Let''s suppose that your IP addresses are:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的IP地址如下：
- en: 'Router WAN IP: 82.61.147.56'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器WAN IP：82.61.147.56
- en: 'Router LAN IP: 192.168.1.1'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器LAN IP：192.168.1.1
- en: 'Arduino Board IP: 192.168.1.4'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino板IP：192.168.1.4
- en: Typically, the IP address of the Arduino board on your internal network is not
    visible from the external network, at least unless you don't explicitly configure
    your router. This configuration is called IP port forwarding.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的Arduino板在内部网络中的IP地址对外部网络不可见，至少除非你明确配置你的路由器。这种配置称为IP端口转发。
- en: Basically, this configuration instructs the router to transfer the traffic it
    receives on a specific port to another IP address on a specific port.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，此配置指示路由器将它在特定端口接收到的流量转发到另一个IP地址上的特定端口。
- en: 'That said, your port forwarding configuration has to be something like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你的端口转发配置必须类似于以下这样：
- en: (82.61.147.56, 230) --> (192.168.1.4, 230)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: (82.61.147.56, 230) --> (192.168.1.4, 230)
- en: Accessing your router configuration page (usually via browser), you should be
    able to get the current IP that your Internet service provider has assigned to
    your router and configure the port forwarding. Read your router manual to learn
    how to set up this configuration.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 访问你的路由器配置页面（通常通过浏览器），你应该能够获取到你的互联网服务提供商分配给你的路由器的当前IP地址并配置端口转发。阅读你的路由器手册以了解如何设置此配置。
- en: 'Once you have configured port forwarding, you can access the Arduino board
    using:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了端口转发，你可以使用以下方式访问Arduino板：
- en: '**IP**: 82.61.147.56 (or better, the actual IP address assigned your own router)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP**：82.61.147.56（或者更好的是，分配给你自己路由器的实际IP地址）'
- en: '**Port**: 230'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：230'
- en: Tip
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Pay attention to security!**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意安全！**'
- en: Once you enable the port forwarding, anyone can access it. This means that anyone
    can easily get access to your power plug and control it. We should implement a
    protocol, which authenticates the iOS device, and encrypts all the messages exchanged.
    Unfortunately, Arduino does not have enough processing power and memory for this
    task. If you want to keep communication between an iOS device and Arduino secure,
    you have to set up a Virtual Private Network ([http://bit.ly/1ENoe3o](http://bit.ly/1ENoe3o)).
    There are many routers that provide a VPN, and iOS supports it natively.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启用了端口转发，任何人都可以访问它。这意味着任何人都可以轻松地访问你的电源插座并控制它。我们应该实现一个协议，该协议验证iOS设备，并加密所有交换的消息。不幸的是，Arduino没有足够的处理能力和内存来完成这项任务。如果你想保持iOS设备和Arduino之间的通信安全，你必须设置一个虚拟专用网络（[http://bit.ly/1ENoe3o](http://bit.ly/1ENoe3o)）。有许多路由器提供VPN，iOS原生支持它。
- en: Dynamic DNS
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态DNS
- en: Typically, each time your router connects to the Internet, it gets a different
    public IP address. So, you need to change the IP address of Arduino Manager each
    time your router is restarted. This is not practical.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每次你的路由器连接到互联网时，它都会获得一个不同的公共IP地址。因此，每次你的路由器重启时，你都需要更改Arduino Manager的IP地址。这并不实用。
- en: 'Many **Dynamic Domain Name Services** (**DDNS**) are available to dynamically
    associate the same name to your router IP address, even if the address changes.
    Most are available for free, among them: NoIP, yDNS, and FreeDNS.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 许多**动态域名服务**（**DDNS**）可以将相同的名称动态地关联到你的路由器IP地址，即使地址发生变化。大多数都是免费的，其中包括：NoIP、yDNS和FreeDNS。
- en: Most routers have DDNS client ready to use and easy to configure, otherwise,
    you may need to install simple software on a computer connected to your network.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数路由器都配备了可用的DDNS客户端，易于配置；否则，你可能需要在连接到你的网络的计算机上安装简单的软件。
- en: Please visit the service provider's site to sign up and get installation and
    configuration procedures. Moreover, check your router for DDNS service availability.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问服务提供商的网站进行注册，获取安装和配置步骤。此外，检查你的路由器以确定DDNS服务的可用性。
- en: 'Once you have configured the Dynamic DNS service of your choice and supposing
    that you have chosen a domain like `powerplug.something.com`, you can access the
    Arduino with:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了你选择的动态DNS服务，假设你选择了一个像`powerplug.something.com`这样的域名，你可以通过以下方式访问Arduino：
- en: '**IP**: `powerplug.something.com`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP**: `powerplug.something.com`'
- en: '**Port**: 230'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 230'
- en: And you don't need to change them when you reboot your router.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你不需要在重启路由器时更改它们。
- en: How to go further
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何更进一步
- en: 'The project we have developed can be improved in many ways, some improvements
    that you can try yourself:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的项目可以通过许多方式改进，以下是一些你可以尝试的改进：
- en: Control more external appliances using more Arduino pins, and more driver circuits.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更多的Arduino引脚和更多的驱动电路控制更多的外部设备。
- en: Check and report to the user any conflicts between different activations.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查并向用户报告不同激活之间的任何冲突。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have built a device that allows you to control an external
    device (a lamp, a washing machine, a coffee kettle, and so on) manually or automatically,
    turning it on and off as you like, and/or at a specific time.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个设备，允许你手动或自动控制外部设备（如灯、洗衣机、咖啡壶等），按你的喜好开启和关闭，或指定时间开启和关闭。
- en: You have learned to make a power circuit without using a relay and manage it
    from Arduino.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了不使用继电器制作电源电路，并从Arduino管理它。
- en: On Arduino, you have learned to write a program that reads and writes on the
    SD card, uses the Wi-Fi shield to communicate to iOS devices and to an external
    service (to get the current time), and manages an external power circuit for controlling
    the external device.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino上，你已经学会了编写程序，读取和写入SD卡，使用Wi-Fi盾牌与iOS设备和外部服务（获取当前时间）进行通信，以及管理外部电源电路以控制外部设备。
- en: On iOS, you have learned how to design the user interface for a medium complex
    application also using the UITableView that is one of the most used components
    to interact with the user. You are now able to understand the MVC pattern and
    take advantage of it in your own programs. Moreover, you have learned to handle
    TCP/IP communication via TCP socket.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，你已经学会了如何使用UITableView设计一个中等复杂的应用程序的用户界面，它是与用户交互最常用的组件之一。你现在能够理解MVC模式并利用它在自己的程序中。此外，你已经学会了通过TCP套接字处理TCP/IP通信。
- en: The next chapter will be about coding Arduino and iOS for controlling a rover
    robot using the hardware features provided by the iOS devices (accelerometer).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何使用iOS设备提供的硬件特性（加速度计）来控制漫游机器人，编写Arduino和iOS代码。
