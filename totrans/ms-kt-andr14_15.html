<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor157" class="calibre3 pcalibre pcalibre1"/>12</h1>
<h1 id="_idParaDest-140" class="calibre6"><a id="_idTextAnchor158" class="calibre3 pcalibre pcalibre1"/>Testing Your App</h1>
<p class="calibre4">Testing Android apps is a crucial aspect of the development process, ensuring that our application functions as intended and meets user expectations. It helps us identify and fix bugs before they reach production and ensure that our app is stable and performs well. This chapter will equip you with the skills to write tests for the different layers of our app that we’ve created so far.</p>
<p class="calibre4">In this chapter, we will learn how to add tests for the different layers in our <strong class="bold">MVVM</strong> (<strong class="bold">Model-View-ViewModel</strong>) architecture. We will learn the importance of adding tests to our apps and how to add unit tests, integration tests, and instrumentation tests.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Importance of testing</li>
<li class="calibre15">Testing the network and database layers</li>
<li class="calibre15">Testing our <strong class="source-inline1">ViewModels</strong></li>
<li class="calibre15">Adding UI tests to our composables</li>
</ul>
<h1 id="_idParaDest-141" class="calibre6"><a id="_idTextAnchor159" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve</a>.</p>
<h1 id="_idParaDest-142" class="calibre6"><a id="_idTextAnchor160" class="calibre3 pcalibre pcalibre1"/>Importance of testing</h1>
<p class="calibre4">Writing tests is a<a id="_idIndexMarker596" class="calibre3 pcalibre pcalibre1"/> crucial aspect of app development. It has the following benefits:</p>
<ul class="calibre16">
<li class="calibre15">It helps us to <strong class="bold">identify and fix bugs</strong> before they reach production. When we write tests for our code, we can see issues at an early stage and quickly fix them before they reach our users, which is normally very costly.</li>
<li class="calibre15"><strong class="bold">Ensures code quality</strong>. When we write tests, we are forced to write code that can be tested. This means that we write code that is modular and loosely coupled. This makes our code base more maintainable and easier to work with. When we find a piece of code that is hard to test, it is a sign that the code is not well written and needs to be refactored.</li>
<li class="calibre15">Writing tests results in <strong class="bold">improved documentation and code understanding</strong>. When we write tests, we are forced to think about how our code works and how it should be used. This makes it easier for other developers to understand our code. While tests can serve as a form of documentation, they should not replace proper code documentation.</li>
<li class="calibre15">Tests help us to <strong class="bold">refactor our code with confidence</strong>. When we have tests in place, we can refactor our code and be sure that we have not broken the existing features in our app that were working well before the refactoring. This is because we can run our tests and see whether they pass or fail.</li>
<li class="calibre15">Tests help us <strong class="bold">test regression</strong>, especially adding new features or modifying existing ones. Tests ensure that the existing functionality still works as before, and nothing has been broken.</li>
</ul>
<p class="calibre4">These are just to mention a few. There are many more benefits of writing tests, and the best way to realize them is to start writing tests for your code. One important thing to note is that we can also add tests to our <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines to ensure<a id="_idIndexMarker597" class="calibre3 pcalibre pcalibre1"/> that our tests run automatically when we push our code to our repositories. This also ensures that as we collaborate with other people on our projects, we can be sure that our code is always in a good state and we can always deploy our code to production with confidence.</p>
<p class="calibre4">In Android, we have a concept called the <strong class="bold">testing pyramid</strong> that helps us to understand the several types of tests that we can write for our <a id="_idIndexMarker598" class="calibre3 pcalibre pcalibre1"/>applications and how they relate to each other. The testing <a id="_idIndexMarker599" class="calibre3 pcalibre pcalibre1"/>pyramid is divided into three layers, as shown in the following figure:</p>
<div><div><img alt="Figure 12.1 – Testing pyramid" src="img/B19779_12_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Testing pyramid</p>
<p class="calibre4">As shown in the preceding diagram, we have three layers of tests:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Unit tests</strong>: These tests sit at the bottom of the pyramid. These are tests that test a single unit of code in isolation. Unit tests are intended to test the smallest testable parts of an application – typically, methods and functions. They are the fastest to run and are the most reliable. They are also the easiest to write and maintain. Unit tests run on your local machine only. These tests are compiled to run locally on the <strong class="bold">Java Virtual Machine </strong>(<strong class="bold">JVM</strong>) to minimize execution time. For tests that depend on your own dependencies, we use mock objects to provide the external dependencies. <strong class="bold">MockK</strong> and <strong class="bold">Mockito</strong> are popular frameworks for mocking dependencies.</li>
<li class="calibre15"><strong class="bold">Integration tests</strong>: These tests<a id="_idIndexMarker600" class="calibre3 pcalibre pcalibre1"/> sit in the<a id="_idIndexMarker601" class="calibre3 pcalibre pcalibre1"/> middle of the pyramid. They<a id="_idIndexMarker602" class="calibre3 pcalibre pcalibre1"/> test how different units of code <a id="_idIndexMarker603" class="calibre3 pcalibre pcalibre1"/>work together. They are slower to run than<a id="_idIndexMarker604" class="calibre3 pcalibre pcalibre1"/> unit tests. They are also hard to write as they require multiple components and dependencies to work and maintain. <strong class="bold">Roboletric</strong> is a popular framework for writing integration tests.</li>
<li class="calibre15"><strong class="bold">UI tests</strong>: These tests sit at the top of the <a id="_idIndexMarker605" class="calibre3 pcalibre pcalibre1"/>pyramid. They test how the different components of our app work <a id="_idIndexMarker606" class="calibre3 pcalibre pcalibre1"/>together. They are the slowest to run since they run on a real device or emulator and are the least reliable. They are also the <a id="_idIndexMarker607" class="calibre3 pcalibre pcalibre1"/>most expensive to write and maintain. There are several frameworks for writing UI tests, including <strong class="bold">Espresso</strong>, <strong class="bold">UI Automator</strong>, and <strong class="bold">Appium</strong>.</li>
</ul>
<p class="calibre4">The testing pyramid presents a way to distribute the tests that we write on our code base. The ideal distribution percentages are <strong class="bold">70% for unit tests</strong>, <strong class="bold">20% for integration tests</strong>, and <strong class="bold">10% for UI tests</strong>. Notice as we go up the pyramid that the number of tests reduces. This is because as we go up the pyramid, the tests become more expensive to write and maintain. This is why<a id="_idIndexMarker608" class="calibre3 pcalibre pcalibre1"/> we should strive to write more unit tests than integration tests and more integration tests than UI tests.</p>
<p class="calibre4">Over the next few sections, we will write the tests for the different layers we have discussed. Let us start by testing our database and network layers in our app.</p>
<h1 id="_idParaDest-143" class="calibre6"><a id="_idTextAnchor161" class="calibre3 pcalibre pcalibre1"/>Testing the network and database layers</h1>
<p class="calibre4">In this section, we are going to learn how to write tests for our network and database layers step by step.</p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor162" class="calibre3 pcalibre pcalibre1"/>Testing the network layer</h2>
<p class="calibre4">To test our network layer, we will write <a id="_idIndexMarker609" class="calibre3 pcalibre pcalibre1"/>unit tests. However, since we are using Retrofit to make our network requests, we will use <code>MockWebServer</code> to mock our network requests. The <code>MockWebServer </code>is a library that allows us to mock our network requests. Let us start by setting up the test dependencies in our version catalog:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="source-inline1">libs.version.toml</strong> file and add the following versions in the versions section:<pre class="source-code">
mockWebServer = "5.0.0-alpha.2"
coroutinesTest = "1.7.3"
truth = "1.1.5"</pre><p class="calibre4">We are setting up the versions for <code>mockWebServer</code>, <code>coroutinesTest</code>, and <code>truth</code>.</p></li> <li class="calibre15">Next, in the<a id="_idIndexMarker610" class="calibre3 pcalibre pcalibre1"/> libraries section, add the following:<pre class="source-code">
test-mock-webserver = { module = "com.squareup.okhttp3:mockwebserver", version.ref = "mockWebServer" }
test-coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-test", version.ref = "coroutinesTest" }
test-truth = { module = "com.google.truth:truth", version.ref = "truth" }</pre><p class="calibre4">Here, we are adding the dependencies for these libraries.</p></li> <li class="calibre15">Next, we will create a bundle so that it is easy to add all test dependencies at once. In the bundle section, add the following:<pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth"]</pre></li> <li class="calibre15">Click on the <strong class="bold">Sync Now</strong> button at the top to add the dependencies.</li>
<li class="calibre15">Lastly, let us head over to the app-level <strong class="source-inline1">build.gradle.kts</strong> file and add the following:<pre class="source-code">
testImplementation(libs.bundles.test)</pre><p class="calibre4">This will add the test bundle to our test directory.</p></li> <li class="calibre15">Click on the <strong class="bold">Sync Now</strong> button to add the dependencies to our app.</li>
</ol>
<p class="calibre4">Before we start writing our tests, we need to do several setup tasks. First, we need to create a JSON response for the request that our test will use:</p>
<ol class="calibre14">
<li class="calibre15">To do this, right-click on the <strong class="source-inline1">app</strong> directory, select <strong class="bold">New</strong>, and at the bottom of the pop-up dialog, select <strong class="bold">Folder</strong>.</li>
<li class="calibre15">From the options presented, select <strong class="bold">Java Resources Folder</strong>. This should create a new folder <a id="_idIndexMarker611" class="calibre3 pcalibre pcalibre1"/>named <strong class="source-inline1">resources</strong>, as shown in the following figure:</li>
</ol>
<div><div><img alt="Figure 12.2 – The resources folder" src="img/B19779_12_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The resources folder</p>
<ol class="calibre14">
<li value="3" class="calibre15">Inside this folder, let us create a new JSON file called <strong class="source-inline1">catsresponse.json</strong> and add the following JSON:<pre class="source-code">
[
  {
    "_id": "eLjLV4oegWGFv9MH",
    "mimetype": "image/png",
    "size": 39927,
    "tags": [
      "cute",
      "pyret"
    ]
  },
  {
    "_id": "PA2gYEbMCzaiDrWv",
    "mimetype": "image/jpeg",
    "size": 59064,
    "tags": [
      "cute",
      "best",
      "siberian",
      "fluffy"
    ]
  },
  {
    "_id": "8PKU6iXscrogXrHm",
    "mimetype": "image/jpeg",
    "size": 60129,
    "tags": [
      "cute",
      "fat",
      "ragdoll",
      "beautiful",
      "sleeping"
    ]
  }
]</pre><p class="calibre4">Our app uses the Cat as a<a id="_idIndexMarker612" class="calibre3 pcalibre pcalibre1"/> Service API, which returns a list of cats per the filter you have applied. The API returns this list of cats in a JSON response, as shown previously. When testing, especially with mocked data, the structure and data types of the JSON response should match those of the real API to ensure our tests are correct.</p></li> <li class="calibre15">Now that we have our response ready, we have to create a class that utilizes this response along with our test class in the <strong class="source-inline1">com.packt.chaptertwelve (test)</strong> directory shown in the following figure:</li>
</ol>
<div><div><img alt="Figure 12.3 – Test directory" src="img/B19779_12_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Test directory</p>
<ol class="calibre14">
<li value="5" class="calibre15">Inside the <strong class="source-inline1">com.packt.chaptertwelve (test)</strong> directory, let us create a new Kotlin file called <strong class="source-inline1">MockRequestDispatcher.kt</strong> and add the following code:<pre class="source-code">
import com.google.common.io.Resources
import okhttp3.mockwebserver.Dispatcher
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.RecordedRequest
import java.io.File
import java.net.HttpURLConnection
class MockRequestDispatcher : Dispatcher() {
    override fun dispatch(request: RecordedRequest): MockResponse {
        return when (request.path) {
            "/cats?tag=cute" -&gt; {
                MockResponse()
                    .setResponseCode(HttpURLConnection.HTTP_OK)
                    .setBody(getJson("catsresponse.json"))
            }
            else -&gt; throw IllegalArgumentException("Unknown Request Path ${request.path}")
        }
    }
    private fun getJson(path: String): String {
        val uri = Resources.getResource(path)
        val file = File(uri.path)
        return String(file.readBytes())
    }
}</pre><p class="calibre4">Here is a breakdown <a id="_idIndexMarker613" class="calibre3 pcalibre pcalibre1"/>of the preceding code:</p><ul class="calibre17"><li class="calibre15">We have created a class called <strong class="source-inline1">MockRequestDispatcher</strong> that extends <strong class="source-inline1">Dispatcher</strong>. This class will be used to mock our network requests.</li><li class="calibre15">We override the <strong class="source-inline1">dispatch</strong> function, which takes <strong class="source-inline1">RecordedRequest</strong> and returns <strong class="source-inline1">MockResponse</strong>. This function is called when a request is made to the server.</li><li class="calibre15">We check the path of the request, and if it matches the path of our request, we return <strong class="source-inline1">MockResponse</strong> with a response code of <strong class="source-inline1">200</strong> and a body of the <strong class="source-inline1">Json</strong> response that we created earlier. For now, we have only mocked a successful response, but it’s important to handle all the different HTTP response codes and error cases to properly mimic real-world scenarios.</li><li class="calibre15">If the path does not match, we throw <strong class="source-inline1">IllegalArgumentException</strong>.</li><li class="calibre15">Lastly, we create a <strong class="source-inline1">getJson</strong> function that takes a path and returns a <strong class="source-inline1">String</strong> instance type. This function is used to read the <strong class="source-inline1">Json</strong> response from the file that we created earlier.</li></ul><p class="calibre4">We can add as many paths as we want to this class. Since our project only has one path, this is all we need.</p></li> <li class="calibre15">Next, let us create our test class. Let us create a new Kotlin file called <strong class="source-inline1">CatsAPITest.kt</strong> and add the following code:<pre class="source-code">
class CatsAPITest {
    private lateinit var mockWebServer: MockWebServer
    private lateinit var catsAPI: CatsAPI
    @Before
    fun setup() {
        // Setup MockWebServer
        mockWebServer = MockWebServer()
        mockWebServer.dispatcher = MockRequestDispatcher()
        mockWebServer.start()
        // Setup Retrofit
        val json = Json {
            ignoreUnknownKeys = true
            isLenient = true
        }
        val retrofit = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .addConverterFactory(
                json.asConverterFactory(
                    contentType = "application/json".toMediaType()
                )
            )
            .build()
        catsAPI = retrofit.create(CatsAPI::class.java)
    }
    @Test
    fun `fetchCats() returns a list of cats`() = runTest {
        val response = catsAPI.fetchCats("cute")
        assert(response.isSuccessful)
    }
    @After
    @Throws(IOException::class)
    fun tearDown() {
        mockWebServer.shutdown()
    }
}</pre><p class="calibre4">Here is a breakdown of the preceding code:</p><ul class="calibre17"><li class="calibre15">We have created a class called <strong class="source-inline1">CatsAPITest</strong>. This class will be used to test our network layer.</li><li class="calibre15">We have created two variables: <strong class="source-inline1">mockWebServer</strong> and <strong class="source-inline1">catsAPI</strong>. The <strong class="source-inline1">mockWebServer</strong> variable will be used to mock our network requests. The <strong class="source-inline1">catsAPI</strong> variable will be <a id="_idIndexMarker614" class="calibre3 pcalibre pcalibre1"/>used to make our network reques<a id="_idTextAnchor163" class="calibre3 pcalibre pcalibre1"/>ts.</li><li class="calibre15">We have the <strong class="source-inline1">setup()</strong> function, which is annotated with the <strong class="source-inline1">@Before</strong> annotation. This means that this function will run before our tests run. In this function, we have done the following:<ul class="calibre17"><li class="calibre15">We have created a <strong class="source-inline1">MockWebServer</strong> instance and assigned it to the <strong class="source-inline1">mockWebServer</strong> variable. We then set the dispatcher of <strong class="source-inline1">mockWebServer</strong> to an instance of <strong class="source-inline1">MockRequestDispatcher</strong>. This is the class that we created earlier. We then start<a id="_idTextAnchor164" class="calibre3 pcalibre pcalibre1"/> <strong class="source-inline1">mockWebServer</strong>.</li><li class="calibre15">We have created a Retrofit instance and added the <strong class="source-inline1">kotlinx-serialization-converter</strong> factory. We then assign the <strong class="source-inline1">catsAPI</strong> variable to an instance of <strong class="source-inline1">CatsAPI</strong>.</li></ul></li><li class="calibre15">We have our test function, which is annotated with the <strong class="source-inline1">@Test</strong> annotation. This means that this function will be run as a test. In this function, we do the following:<ul class="calibre17"><li class="calibre15">We wrap the test in the <strong class="source-inline1">runTest()</strong> function. This is because we want to test suspending functions. <strong class="source-inline1">runTest</strong> is a coroutine test builder designed for testing coroutines. It is part of the <strong class="source-inline1">kotlinx-coroutines-test</strong> library that we added earlier.</li><li class="calibre15">We make a network <a id="_idIndexMarker615" class="calibre3 pcalibre pcalibre1"/>request to <strong class="source-inline1">mockWebServer</strong> using the <strong class="source-inline1">catsAPI</strong> instance that we created earlier. We then assert that the response is successful.</li><li class="calibre15">We have the <strong class="source-inline1">tearDown()</strong> function, which is annotated with the <strong class="source-inline1">@After</strong> annotation. This means that this function will run after our tests run. This function is used to shut down our <strong class="source-inline1">mockWebServer</strong> instance.</li></ul></li></ul></li> <li class="calibre15">Press the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <strong class="bold">Run</strong> window:</li>
</ol>
<div><div><img alt="Figure 12.4 – Test passing" src="img/B19779_12_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Test passing</p>
<p class="calibre4">As seen in the preceding figure, our test runs successfully. This means that our network layer is working as expected. We <a id="_idIndexMarker616" class="calibre3 pcalibre pcalibre1"/>can now move on to testing our database layer.</p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor165" class="calibre3 pcalibre pcalibre1"/>Testing the database layer</h2>
<p class="calibre4">We are using <code>androidTest</code> directory shown in the following figure:</p>
<div><div><img alt="Figure 12.5 – Android test directory" src="img/B19779_12_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Android test directory</p>
<p class="calibre4">Let us create a new file called <code>CatsDaoTest.kt</code> and add the following code:</p>
<pre class="source-code">
@RunWith(AndroidJUnit4::class)
class CatDaoTest {
    private lateinit var database: CatDatabase
    private lateinit var catDao: CatDao
    @Before
    fun createDatabase() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            CatDatabase::class.java
        ).allowMainThreadQueries().build()
        catDao = database.catDao()
    }
    @After
    fun closeDatabase() {
        database.close()
    }
}</pre> <p class="calibre4">Here is a breakdown of the preceding code:</p>
<ul class="calibre16">
<li class="calibre15">We have created two variables: <strong class="source-inline1">database</strong> and <strong class="source-inline1">catDao</strong>. The <strong class="source-inline1">database</strong> variable will be used to create an instance of our database. The <strong class="source-inline1">catDao</strong> variable will be <a id="_idIndexMarker619" class="calibre3 pcalibre pcalibre1"/>used to create an instance of our <strong class="source-inline1">CatDao</strong> interface.</li>
<li class="calibre15">We have the <strong class="source-inline1">createDatabase()</strong> function, which is annotated with the <strong class="source-inline1">@Before</strong> annotation. This means that this function will run before our tests run. Inside the function, we create an instance of our database and assign it to the <strong class="source-inline1">database</strong> variable. We are using the in-memory database.</li>
<li class="calibre15">We have the <strong class="source-inline1">closeDatabase()</strong> function, which is annotated with the <strong class="source-inline1">@After</strong> annotation. This means that this function will run after our tests run. This function is used to close our database.</li>
</ul>
<p class="calibre4">With this done, we can now start <a id="_idIndexMarker620" class="calibre3 pcalibre pcalibre1"/>writing our tests:</p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="source-inline1">CatsDaoTest</strong> class, add the following test function:<pre class="source-code">
@Test
fun testInsertAndReadCat() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Then the cat is in the database
    val cats = catDao.getCats()
    assert(cats.first().contains(cat))
}</pre><p class="calibre4">In this test, we have created a <code>CatEntity</code> object with the details of a cat. We then inserted the details of the cat into the database. Lastly, we assert that the details of the cat are in the database.</p></li> <li class="calibre15">Click on the green <em class="italic">run</em> icon<a id="_idIndexMarker621" class="calibre3 pcalibre pcalibre1"/> next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</li>
</ol>
<div><div><img alt="Figure 12.6 – Test to insert and read from the database" src="img/B19779_12_06.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Test to insert and read from the database</p>
<p class="calibre4">Our test runs successfully. This means that our database layer is working as expected. Let us add another test that tests adding a cat to the favorites.</p>
<ol class="calibre14">
<li value="3" class="calibre15">Still inside the <strong class="source-inline1">CatsDaoTest</strong> class, let us add the following test function:<pre class="source-code">
@Test
fun testAddCatToFavorites() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Favorite the cat
    catDao.update(cat.copy(isFavorite = true))
    // Assert that the cat is in the favorite list
    val favoriteCats = catDao.getFavoriteCats()
    assert(favoriteCats.first().contains(cat.copy(isFavorite = true)))
}</pre><p class="calibre4">In this test, we have created a <code>CatEntity</code> object with the details of a cat. We then insert the cat into the<a id="_idIndexMarker622" class="calibre3 pcalibre pcalibre1"/> database. We then update the <code>CatEntity</code> object, passing <code>isFavorite</code> as <code>true</code>. Lastly, we assert that the cat is on the favorite list.</p></li> <li class="calibre15">Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</li>
</ol>
<div><div><img alt="Figure 12.7 – Favoriting a cat test" src="img/B19779_12_07.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Favoriting a cat test</p>
<p class="calibre4">Our tests run successfully. This <a id="_idIndexMarker623" class="calibre3 pcalibre pcalibre1"/>means that our functionality for adding cats to favorites is working properly.</p>
<p class="calibre4">We have seen how to test our network and database layers. Next, let us test our ViewModel layer.</p>
<h1 id="_idParaDest-146" class="calibre6"><a id="_idTextAnchor166" class="calibre3 pcalibre pcalibre1"/>Testing our ViewModels</h1>
<p class="calibre4">Our <code>ViewModel</code> class fetches data<a id="_idIndexMarker624" class="calibre3 pcalibre pcalibre1"/> from the repository and exposes it to the UI. To test our <code>ViewModel</code>, we will write unit tests. Let us start by setting up the test dependencies in our version catalog:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="source-inline1">libs.version.toml</strong> file and add the following versions in the versions section:<pre class="source-code">
mockk = "1.13.3"</pre></li> <li class="calibre15">Next, in the libraries section, add the following:<pre class="source-code">
test-mockk = { module = "io.mockk:mockk", version.ref = "mockk" }</pre></li> <li class="calibre15">Add the <strong class="source-inline1">test-mockk</strong> dependency to the <strong class="source-inline1">test</strong> bundle. Our updated <strong class="source-inline1">test</strong> bundle should now look like this:<pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth", "test-mockk"]</pre></li> <li class="calibre15">Click on the <strong class="bold">Sync Now</strong> button at the top to add the dependencies. Adding <strong class="source-inline1">mockk</strong> allows us to mock our dependencies.</li>
<li class="calibre15">We are now ready to create our test class. Create a new Kotlin file called <strong class="source-inline1">CatsViewModelTest.kt</strong> inside<a id="_idIndexMarker625" class="calibre3 pcalibre pcalibre1"/> the test directory and add the following code:<pre class="source-code">
class PetsViewModelTest {
    private val petsRepository = mockk&lt;PetsRepository&gt;(relaxed = true)
    private lateinit var petsViewModel: PetsViewModel
    @Before
    fun setup() {
        Dispatchers.setMain(Dispatchers.Unconfined)
        petsViewModel = PetsViewModel(petsRepository)
    }
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
}</pre><p class="calibre4">Here is a breakdown of the preceding code:</p><ul class="calibre17"><li class="calibre15">We have created two variables: <strong class="source-inline1">petsRepository</strong> and <strong class="source-inline1">petsViewModel</strong>. The <strong class="source-inline1">petsRepository</strong> variable will be used to mock our <strong class="source-inline1">PetsRepository</strong> interface. We used <strong class="source-inline1">mockk&lt;PetsRepository&gt;</strong> to provide a mock instance of <strong class="source-inline1">PetsRepository</strong>. The <strong class="source-inline1">petsViewModel</strong> variable will be used to create an instance of <strong class="source-inline1">Pets<a id="_idTextAnchor167" class="calibre3 pcalibre pcalibre1"/>ViewModel</strong>.</li><li class="calibre15">We have the <strong class="source-inline1">setup()</strong> function, which is annotated with the <strong class="source-inline1">@Before</strong> annotation. This means that this function will run before our tests run. We set the main dispatcher to <strong class="source-inline1">Dispatchers.Unconfined</strong>. This is because we are using coroutines in our ViewModel. We then assign the <strong class="source-inline1">petsViewModel</strong> property to an instance of <strong class="source-inline1">PetsViewModel</strong>.</li><li class="calibre15">We have the <strong class="source-inline1">tearDown()</strong> function, which is annotated with the <strong class="source-inline1">@After</strong> annotation. This means<a id="_idIndexMarker626" class="calibre3 pcalibre pcalibre1"/> that this function will run after our tests run. This function is used to reset the main dispatcher.</li></ul></li> </ol>
<p class="calibre4">With this, we are ready to write our test. Below the <code>tearDown()</code> function, add the following test function:</p>
<pre class="source-code">
@Test
fun testGetPets() = runTest {
    val cats = listOf(
        Cat(
            id = "1",
            owner = "John Doe",
            tags = listOf("cute", "fluffy"),
            createdAt = "2021-07-01T00:00:00.000Z",
            updatedAt = "2021-07-01T00:00:00.000Z",
            isFavorite = false
        )
    )
    // Given
    coEvery { petsRepository.getPets() } returns flowOf(cats)
    // When
    petsViewModel.getPets()
    coVerify { petsRepository.getPets() }
    // Then
    val uiState = petsViewModel.petsUIState.value
    assertEquals(cats, uiState.pets)
}</pre> <p class="calibre4">In this test function, we have created a list of cats. We then mock the <code>getPets()</code> function of <code>PetsRepository</code> to return a flow of cats. It returns a flow of cats since our <code>getPets()</code> function in <code>PetsRepository</code> returns <code>Flow&lt;List&lt;Cat&gt;&gt;</code>; this way, we mock the correct behavior of this function. We then call the <code>getPets()</code> function of <code>PetsViewModel</code>. We<a id="_idIndexMarker627" class="calibre3 pcalibre pcalibre1"/> then assert that the <code>getPets()</code> function of <code>PetsRepository</code> is called. Lastly, we assert that the list of cats that we created is the same as the list of cats that we get from <code>PetsViewModel</code>. Remember to remove the private marker in our <code>PetsViewModel</code> class in case you get an error when trying to access the <code>getPets()</code> function. Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</p>
<div><div><img alt="Figure 12.8 – PetsViewModelTest" src="img/B19779_12_08.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.8 – PetsViewModelTest</p>
<p class="calibre4">Our test runs successfully. This means that our <code>ViewModel</code> layer is working as expected. We can now move on to testing our UI layer. In the next section, we will learn how to write UI tests in Jetpack Compose.</p>
<h1 id="_idParaDest-147" class="calibre6"><a id="_idTextAnchor168" class="calibre3 pcalibre pcalibre1"/>Adding UI tests to our composables</h1>
<p class="calibre4">Writing UI tests has been made easier for us. Jetpack Compose <a id="_idIndexMarker628" class="calibre3 pcalibre pcalibre1"/>provides a set of testing APIs to find elements, verify their attributes, and <a id="_idIndexMarker629" class="calibre3 pcalibre pcalibre1"/>perform actions on these elements. Jetpack<a id="_idIndexMarker630" class="calibre3 pcalibre pcalibre1"/> Compose uses <code>PetListItem</code> composable.</p>
<p class="calibre4">Let us head over to the <code>PetListItem.kt</code> file. We need to add a <code>testTags</code> modifier to our composable. This is because we are using tags to identify our composables. In the <code>PetListItem</code> composable, modify the composable contents to be as follows:</p>
<pre class="source-code">
ElevatedCard(
    modifier = Modifier
        .fillMaxWidth()
        .padding(6.dp)
        .testTag("PetListItemCard"),
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 10.dp)
            .testTag("PetListItemColumn")
            .clickable {
                onPetClicked(cat)
            }
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        Row(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
            Icon(
                modifier = Modifier
                    .testTag("PetListItemFavoriteIcon")
                    .clickable {
                        onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                    },
                imageVector = if (cat.isFavorite) {
                    Icons.Default.Favorite
                } else {
                    Icons.Default.FavoriteBorder
                },
                contentDescription = "Favorite",
                tint = if (cat.isFavorite) {
                    Color.Red
                } else {
                    Color.Gray
                }
            )
        }
    }
}</pre> <p class="calibre4">Notice we have added the <code>testTag()</code> modifier to our components. With this, we are able to use the Finders APIs in Jetpack Compose to<a id="_idIndexMarker632" class="calibre3 pcalibre pcalibre1"/> find our composables. Once we use the finders, we can<a id="_idIndexMarker633" class="calibre3 pcalibre pcalibre1"/> perform actions and assert on our composables. Let us now create a new file in our <code>androidTest</code> directory called <code>PetListItemTest.kt</code> and add the following code:</p>
<pre class="source-code">
class PetListItemTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    @Test
    fun testPetListItem() {
        with(composeTestRule) {
            setContent {
                PetListItem(
                    cat = Cat(
                        id = "1",
                        owner = "John Doe",
                        tags = listOf("cute", "fluffy"),
                        createdAt = "2021-07-01T00:00:00.000Z",
                        updatedAt = "2021-07-01T00:00:00.000Z",
                        isFavorite = false
                    ),
                    onPetClicked = { },
                    onFavoriteClicked = {})
            }
            // Assertions using tags
            onNodeWithTag("PetListItemCard").assertExists()
            onNodeWithTag("PetListItemColumn").assertExists()
            onNodeWithTag("PetListItemFavoriteIcon").assertExists()
            // Assertions using text
            onNodeWithText("fluffy").assertIsDisplayed()
            onNodeWithContentDescription("Favorite").assertIsDisplayed()
            onNodeWithContentDescription("Cute cat").assertIsDisplayed()
            // Actions
            onNodeWithTag("PetListItemFavoriteIcon").performClick()
        }
    }
}</pre> <p class="calibre4">Here is a <a id="_idIndexMarker634" class="calibre3 pcalibre pcalibre1"/>breakdown of the <a id="_idIndexMarker635" class="calibre3 pcalibre pcalibre1"/>preceding code:</p>
<ul class="calibre16">
<li class="calibre15">We have created a class called <strong class="source-inline1">PetListItemTest</strong>. We will use this class to test our <strong class="source-inline1">PetListItem</strong> composable. Inside this class, we have created a rule called <strong class="source-inline1">composeTestRule</strong>. This rule will be used to create our com<a id="_idTextAnchor171" class="calibre3 pcalibre pcalibre1"/>posables. Through this rule, we can set Compose <a id="_idIndexMarker636" class="calibre3 pcalibre pcalibre1"/>content or access our activity.</li>
<li class="calibre15">We have the <strong class="source-inline1">testPetListItem()</strong> function, which is annotated with the <strong class="source-inline1">@Test</strong> annotation. Several<a id="_idIndexMarker637" class="calibre3 pcalibre pcalibre1"/> things are happeni<a id="_idTextAnchor172" class="calibre3 pcalibre pcalibre1"/>ng in this function:<ul class="calibre17"><li class="calibre15">We have used the <strong class="source-inline1">with</strong> scoping function to be able to use <strong class="source-inline1">composeTestRule</strong>. We then set the content of our composable. In this case, it is the <strong class="source-inline1">PetListItem</strong> composable that we want to test. We pass a <strong class="source-inline1">cat</strong> object to our composable.</li><li class="calibre15">We are using the <strong class="source-inline1">onNodeWithTag()</strong> function to find our composables. We then use the <strong class="source-inline1">assertExists()</strong> function to assert that the composables exist. This will find our composables using the tags that we added earlier.</li><li class="calibre15">We are using the <strong class="source-inline1">onNodeWithText()</strong> function to find our composables. We then use the <strong class="source-inline1">assertIsDisplayed()</strong> function to assert that the composables exist. We have also used the <strong class="source-inline1">onNodeWithContentDescription()</strong> function to find our composables. These two functions help us find composables whose text or content description matches the text or content description that we pass to the function.</li><li class="calibre15">Lastly, we are using the <strong class="source-inline1">performClick()</strong> function to perform an action on our composables. In this case, we are performing a click action on our <strong class="source-inline1">PetListItemFavoriteIcon</strong> composable.</li></ul></li>
</ul>
<p class="calibre4">Click on the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <strong class="bold">Run</strong> window:</p>
<div><div><img alt="Figure 12.9 – Jetpack Compose UI tests" src="img/B19779_12_09.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Jetpack Compose UI tests</p>
<p class="calibre4">Our test runs successfully. Additionally, the test is also run on the device that we are working on. We are also able to see the <a id="_idIndexMarker638" class="calibre3 pcalibre pcalibre1"/>components being displayed and actions being performed.</p>
<p class="calibre4">We have seen how to write <a id="_idIndexMarker639" class="calibre3 pcalibre pcalibre1"/>UI tests in Jetpack Compose. To learn more about testing in Jetpack Compose, check out the official documentation (<a href="https://developer.android.com/jetpack/compose/testing" class="calibre3 pcalibre pcalibre1">https://developer.android.com/jetpack/compose/testing</a>). With the knowledge that we have gained in this chapter, we can add more tests to the different layers of our app. You can try adding more tests to test your knowledge.</p>
<h1 id="_idParaDest-148" class="calibre6"><a id="_idTextAnchor173" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we have learned how to add tests for the different layers in our MVVM architecture. We have learned about the importance of adding tests to our apps and how to add unit tests, integration tests, and instrumentation tests.</p>
<p class="calibre4">In the next chapter, we will learn step-by-step how to publish a new app in the Google Play Store. We will walk through how to create a signed app bundle and the things required for us to publish our first app to the Play Store. Additionally, we will learn about some of the Google Play Store policies and how to always stay compliant to avoid our apps from being removed or accounts from being banned.</p>
</div>
</body></html>