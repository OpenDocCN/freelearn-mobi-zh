<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Working with Local and Remote Data Sources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Local and Remote Data Sources</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading data from remote XML through HTTPClient</li><li class="listitem" style="list-style-type: disc">Displaying data using a TableView</li><li class="listitem" style="list-style-type: disc">Enhancing your TableView with custom rows</li><li class="listitem" style="list-style-type: disc">Filtering your TableView with the SearchBar control</li><li class="listitem" style="list-style-type: disc">Speeding up your remote data access using JSON and Yahoo! YQL</li><li class="listitem" style="list-style-type: disc">Creating an SQLite database</li><li class="listitem" style="list-style-type: disc">Saving data locally using an SQLite database</li><li class="listitem" style="list-style-type: disc">Retrieving data from an SQLite database</li><li class="listitem" style="list-style-type: disc">Creating a "pull and release" refresh mechanism</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>Fully understanding the methods available to you in Titanium Studio when it comes to reading, parsing, and saving data, is fundamental to the success of the apps you will build. Titanium provides you with all of the tools that you will need to make everything from simple XML calls over HTTP, implementing JSON for improved network speeds, to complex applications running a localized relational database (SQLite) for offline storage requirements.<a id="id59" class="indexterm"/>
</p><p>In this chapter we will not only cover the fundamental methods of implementing remote data access over HTTP, but also how to store and present that data effectively using TableViews, TableRows, and other customized user interfaces.</p><div class="section" title="Pre-requisites"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Pre-requisites</h2></div></div></div><p>You should have a basic understanding of both the XML and JSON data formats, which are widely-used standardized methods of transporting data across the Web. Additionally, you should also understand what<span class="strong"><strong> SQL</strong></span> (<span class="strong"><strong>Structured Query Language</strong></span>) is and how to create basic SQL statements such as CREATE, SELECT, DELETE, and INSERT. There is a great beginners introduction to SQL at<a class="ulink" href="http://sqlzoo.net"> http://sqlzoo.net</a> if you need to refer to tutorials on how to perform common types of database queries.<a id="id60" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Reading data from remote XML through HTTPClient"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Reading data from remote XML through HTTPClient</h1></div></div></div><p>The ability to consume and display feed data from the Internet, through RSS feeds or alternate APIs, is the cornerstone of many mobile applications. More importantly, many services that you may wish to integrate into your app will probably require you to do this at some point or another, such as Twitter or Wikipedia, so it is vital to understand and be able to implement remote data feeds and XML. Our first recipe for this chapter introduces some new functionality within Titanium to help address this need.<a id="id61" class="indexterm"/>
</p><p>If you are intending to follow the entire chapter and build the MyRecipes app, then pay careful attention to the first<span class="emphasis"><em> Getting Ready</em></span> section for this recipe, as it will guide you through setting up the project.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>Getting ready</h2></div></div></div><p>To prepare for this recipe, open up Titanium Studio and log in if you have not already done so. If you need to register a new account, you can do so for free directly from within the application. Once you are logged in, click on<span class="strong"><strong> New Project</strong></span>, and the details window for creating a new project will appear. Enter<span class="strong"><strong> MyRecipes</strong></span> as the name of the app, and fill in the rest of the details with your own information.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"/>Note</h3><p>Pay attention to the app identifier, which is written normally in reverse domain notation (that is<code class="literal"> com.packtpub.myrecipes</code>). This identifier cannot be easily changed after the project is created and you will need to match it<span class="emphasis"><em> exactly</em></span> when creating provisioning profiles for distributing your apps later on.</p></div><p>Complete source code for this entire chapter can be found in the<code class="literal"> /Chapter 2/RecipeFinder</code> folder, while source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 1</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>How to do it...</h2></div></div></div><p>Now our project shell is set up, so let's get down to business! First, open your<code class="literal"> app.js</code> file, and two more JavaScript files called<code class="literal"> recipes.js</code> and<code class="literal"> favorites.js</code>. In your<code class="literal"> app.js</code>, reference<code class="literal"> recipes.js</code> and<code class="literal"> favorites.js</code> to<code class="literal"> win1</code> and<code class="literal"> win2</code> respectively, and give each window a meaningful title (for example, "Recipes"). We'll also change the tab icons from their defaults to the two icons 'fork-and-knife.png' and 'heart.png' respectively. Both of these icons are available in the accompanying source files.<a id="id62" class="indexterm"/>
</p><p>Open the<code class="literal"> recipes.js</code> file in your IDE. This is the file that will hold our code for retrieving and displaying recipes from a RSS feed. Type in the following code at the top of your<code class="literal"> recipes.js</code> file. This code will create an<code class="literal"> HTTPClient</code> and read in the feed XML from the recipes website.<a id="id63" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var win = Titanium.UI.currentWindow;
//declare the http client object
var xhr = Titanium.Network.createHTTPClient();
//this method will process the remote data
xhr.onload = function() {
Ti.API.info(this.responseText);
};
//this method will fire if there's an error in accessing the //remote data
xhr.onerror = function() {
//log the error to our Titanium Studio console
Ti.API.error(this.status + ' - ' + this.statusText);
};
//open up the recipes xml feed
xhr.open('GET', 'http://www.cuisine.com.au/feed/all-recipes');
//finally, execute the call to the remote feed
xhr.send();
</pre></div><p>Try running the emulator now for either Android or iPhone. You should have two tabs appear on the screen as shown next, and, after a few seconds, a stack of XML data printed out to your Titanium Studio console log.<a id="id64" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_02_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>How it works…</h2></div></div></div><p>If you are already familiar with JavaScript for the web, this should make a lot of sense to you. Here we are creating an<code class="literal"> HTTPClient</code> using the<code class="literal"> Titanium.Network</code> namespace, and opening a<code class="literal"> GET</code> connection on the URL of the feed from the recipes website, using an object called<code class="literal"> xhr</code>.<a id="id65" class="indexterm"/>
</p><p>By implementing the<code class="literal"> onload</code> event listener, we can capture the XML data that has been retrieved by the<code class="literal"> xhr</code> object. In the source code you will note that we have used<code class="literal"> Ti.API.info()</code> to echo information to the Titanium Studio screen, which is a great way to debug and follow events in your app. If your connection and<code class="literal"> GET</code> request was successful, you should see a large XML string outputted in the Titanium Studio info log. The final piece of the recipe is small but very important—calling the<code class="literal"> xhr</code> object's<code class="literal"> send()</code> method. This kicks off the<code class="literal"> GET</code> request. Without it, your app would never load any data. It is important to note that you will not receive any errors or warnings if you forget to implement<code class="literal"> xhr.send()</code>. If your app is not receiving any data, this is the first place to check.<a id="id66" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"/>Note</h3><p>If you are having trouble parsing your XML, always check if it is valid first! Opening up the XML feed in your browser will normally provide you with enough information to determine whether your feed is valid, or if it has broken elements.</p></div></div></div>
<div class="section" title="Displaying data using a TableView"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Displaying data using a TableView</h1></div></div></div><p>TableViews are the most used components in the entire iPhone and Android SDKs, almost all of the native apps on your device will utilize tables in some shape or form. They are used to display large lists of data in an effective manner, allowing for scrolling lists that can be customized visually, searched upon, or drilled to expose child views. With so many available properties and options, it's easy to get lost in the functionality and ability of these components. Luckily for us, Titanium makes it easy to implement TableViews into your application. In this recipe, we will implement a TableView and use our XML data feed from the previous recipe to populate it with a list of recipes.<a id="id67" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 2</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>How to do it...</h2></div></div></div><p>Once we have connected our app to a data feed and we're retrieving XML data via the XHR object, we need to be able to manipulate that data and display it into a TableView component. Firstly, create an array object called<code class="literal"> data</code> at the top of your<code class="literal"> recipes.js</code> file. This array will hold all of the information for our TableView in a global context:<a id="id68" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var data = []; //empty data array
</pre></div><p>We are now going to disseminate the XML and read in the required elements to our<code class="literal"> data</code> array object, before finally creating a TableView and assigning its<code class="literal"> data</code> property to our<code class="literal"> data object:</code>
</p><div class="informalexample"><pre class="programlisting">//declare the http client object
var xhr = Titanium.Network.createHTTPClient();
//create the table view
var tblRecipes = Titanium.UI.createTableView({
height: 366,
width: 320,
top: 0,
left: 0
});
win.add(tblRecipes);
//this method will process the remote data
xhr.onload = function() {
var xml = this.responseXML;
//get the item nodelist from our response xml object
var items = xml.documentElement.getElementsByTagName("item");
//loop each item in the xml
for (var i = 0; i &lt; items.length; i++) {
//create a table row
var row = Titanium.UI.createTableViewRow({
title:
items.item(i).getElementsByTagName("title").item(0).text
});
//add the table row to our data[] object
data.push(row);
} //end for loop
//finally, set the data property of the tableView to our //data[] object
tblRecipes.data = data;
};
</pre></div><p>The following screenshot shows the Table view with the titles of our recipes from the XML feed:<a id="id69" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_02_02.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>How it works...</h2></div></div></div><p>The first thing you will notice is that we are using the<code class="literal"> Ti.XML</code> namespace to assign the list of elements to a new object called<code class="literal"> items</code>. This allows us to use a<code class="literal"> for</code> loop construct in order to loop through the items and assign each individual item to the<code class="literal"> data</code> array object we created and gave a global scope.<a id="id70" class="indexterm"/>
</p><p>From there we are creating our TableView by implementing the<code class="literal"> Titanium.UI.createTableView()</code> function. You should notice almost immediately that many of our regular properties are also used by tables, including width, height, and positioning. However, a TableView has one extra and important property data. The data property accepts an array of data, the values of which can either be used dynamically (as we have done here with the title property) or can be assigned to sub-component children of a TableRow. As you begin to build more complex applications you will learn to fully understand just how flexible table-based layouts can be.<a id="id71" class="indexterm"/>
</p></div></div>
<div class="section" title="Enhancing your TableViews with custom rows"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Enhancing your TableViews with custom rows</h1></div></div></div><p>So far we have created a TableView, which while being totally usable and showing the names of our recipes from the XML feed, is a bit bland. To customize our table we will need to create and add custom TableRow objects to an array of rows, which we can then assign to our TableView object. Each of these TableRow objects is essentially a type of View, to which we can add any number of components, such as Labels, ImageViews, and Buttons.<a id="id72" class="indexterm"/>
</p><p>Next, we will create our TableRow objects and add to each one of them the name of the recipe from our XML feed, a short description, and a thumbnail image (which we will get from the<code class="literal"> images</code> folder in our<code class="literal"> Resources</code> directory) to each one of them. If you do not already have an images directory, create one now and copy the images from the source code for this recipe, which can be found in the<code class="literal"> /Chapter 2/Recipe 3</code> folder.<a id="id73" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>How to do it...</h2></div></div></div><p>Open your<code class="literal"> recipe.js</code> file and type in the following code. If you have been following along with the previous recipe, then the following code will extend what you have already written:</p><div class="informalexample"><pre class="programlisting">var data = []; //empty data array
//declare the http client object
var xhr = Titanium.Network.createHTTPClient();
var tblRecipes = Titanium.UI.createTableView({
height: 366,
width: 320,
top: 0,
left: 0,
rowHeight: 70
});
win.add(tblRecipes);
//this method will process the remote data
xhr.onload = function() {
var xml = this.responseXML;
//get the item nodelist from our response xml object
var items = xml.documentElement.getElementsByTagName("item");
//loop each item in the xml
for (var i = 0; i &lt; items.length; i++) {
//create a table row
var row = Titanium.UI.createTableViewRow({
hasChild: true,
className: 'recipe-row'
});
//title label
var titleLabel = Titanium.UI.createLabel({
text:
items.item(i).getElementsByTagName("title").item(0).text,
font: {fontSize: 14, fontWeight: 'bold'},
left: 70,
top: 5,
height: 20,
width: 210
});
row.add(titleLabel);
//description label
var descriptionLabel = Titanium.UI.createLabel({
text:
items.item(i).getElementsByTagName("description").item(0).text,
font: {fontSize: 10, fontWeight: 'normal'},
left: 70,
top: 25,
height: 40,
width: 200
});
if(descriptionLabel.text == '') {
descriptionLabel.text = 'No description is available.';
}
row.add(descriptionLabel);
//add our little icon to the left of the row
var iconImage = Titanium.UI.createImageView({
image: 'images/foodicon.jpg',
width: 50,
height: 50,
left: 10,
top: 10
});
row.add(iconImage);
//add the table row to our data[] object
data.push(row);
}
//finally, set the data property of the tableView to our
//data[] object
tblRecipes.data = data;
};
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>How it works...</h2></div></div></div><p>One thing that should be immediately obvious is that a<span class="strong"><strong> TableRow</strong></span> object can contain any number of components which you can define and add in the standard way (see<a class="link" href="ch01.html" title="Chapter 1. Building Apps using Native UI Components"> Chapter 1</a>,<span class="emphasis"><em> Building Apps Using Native UI Components</em></span>, for examples of implementing different UI components).<a id="id74" class="indexterm"/>
</p><p>What is the<code class="literal"> className</code> property used for then? When rows are rendered on your device it all happens on request, that is, only those rows which are visible are actually rendered by the OS, which can be seen in the following screenshots. The reasons for this are two-fold. First, to conserve memory, of which most devices have precious little in comparison to desktop computers. Second, to help speed up your application by only performing those CPU tasks which are absolutely necessary.</p><p>For a few rows, the memory usage without using a<code class="literal"> className</code> will not be too high, but for many rows, depending on how many and what interface components you are using within the row, your app will load very slowly or may even crash.</p><div class="mediaobject"><img src="graphics/3968EXP_02_03.jpg" alt="How it works..."/></div></div></div>
<div class="section" title="Filtering the TableView using a SearchBar component"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Filtering the TableView using a SearchBar component</h1></div></div></div><p>So what happens when your user wants to search all data in your TableView? By far the easiest way is to use the<span class="strong"><strong> SearchBar</strong></span> component. This is a standard control that consists of a searchable text field with an optional cancel button, and attaches to the top of your table view using the table view's<code class="literal"> searchBar</code> property.<a id="id75" class="indexterm"/>
</p><p>In this next recipe, we will implement a search bar into our<span class="strong"><strong> MyRecipes</strong></span> app that filters our recipes based on the<code class="literal"> title</code> property.<a id="id76" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 4</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>How to do it...</h2></div></div></div><p>First of all, create a<code class="literal"> searchBar</code> component before your<code class="literal"> tableView</code> is defined, and then create the event listener's for the<code class="literal"> searchBar</code>.<a id="id77" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//define our search bar which will attach
//to our table view
var searchBar = Titanium.UI.createSearchBar({
showCancel:true,
height:43,
top:0
});
//print out the searchbar value whenever it changes
searchBar.addEventListener('change', function(e){
//search the tableview as user types
Ti.API.info('user searching for: ' + e.value);
});
//when the return key is hit, remove focus from
//our searchBar
searchBar.addEventListener('return', function(e){
searchBar.blur();
});
//when the cancel button is tapped, remove focus
//from our searchBar
searchBar.addEventListener('cancel', function(e){
searchBar.blur();
});
</pre></div><p>Now set the search property of our tableView to our searchBar component, and then set the<code class="literal"> filterAttribute</code> of our tableView to<code class="literal">'filter'</code>. We will define this custom property called<code class="literal">'filter'</code> within each of our row objects.</p><div class="informalexample"><pre class="programlisting">//define our table view
var tblRecipes = Titanium.UI.createTableView({
height: 366,
width: 320,
top: 0,
left: 0,
rowHeight: 70,
search: searchBar,
filterAttribute:'filter' //here is the search filter which
//appears in TableViewRow
});
win.add(tblRecipes);
</pre></div><p>Now, inside each row that you define when looping through our xml data, add a custom property called<code class="literal">'filter'</code> and set it's value to the title text from the XML feed:<a id="id78" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//this method will process the remote data
xhr.onload = function() {
var xml = this.responseXML;
//get the item nodelist from our response xml object
var items = xml.documentElement.getElementsByTagName("item");
//loop each item in the xml
for (var i = 0; i &lt; items.length; i++) {
//create a table row
var row = Titanium.UI.createTableViewRow({
hasChild: true,
className: 'recipe-row',
filter: items.item(i).getElementsByTagName("title").item(0).text //this is the data we want to search on (title)
});
</pre></div><p>That's it! Run your project and you should now have a search bar attached to your table view as shown in the following screenshot. Tap it and type in any part of a recipe's title to see the results filtered in your table.</p><div class="mediaobject"><img src="graphics/3968EXP_02_04.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>How it works...</h2></div></div></div><p>In the first block of code, we are simply defining our<span class="strong"><strong> SearchBar</strong></span> object like any other UI component, before attaching it to the<code class="literal"> searchBar</code> property of our TableView in the second block of code. The event listeners for the<code class="literal"> searchBar</code> simply ensure that when the user taps either one of the '<span class="strong"><strong>Search</strong></span>' or '<span class="strong"><strong>Cancel</strong></span>' buttons, the focus on the text input is lost and the keyboard will therefore become hidden.<a id="id79" class="indexterm"/>
</p><p>The final block of code defines just what data we are searching for, in this case, our<code class="literal"> filter</code> property has been set to the title of the recipes. This property needs to be added to each row that we define before it is bound to our TableView.</p></div></div>
<div class="section" title="Speeding up your remote data access using JSON and Yahoo! YQL"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec06"/>Speeding up your remote data access using JSON and Yahoo! YQL</h1></div></div></div><p>If you are already familiar with using JavaScript heavily for the web, particularly when using popular libraries such as jQuery or Prototype, then you may already be aware of the benefits of using JSON instead of XML. The JSON data format is much less verbose than XML, meaning the file size is smaller and data transfer much faster. This is particularly important when a user on a mobile device may be limited in data speed due to network access and bandwidth.<a id="id80" class="indexterm"/>
</p><p>If you have never seen Yahoo's YQL console, or heard of the YQL language web service, it is essentially a free web service that allows developers and applications to query, filter, and combine separate data sources from across the Internet.</p><p>In this recipe, we are going to use the Yahoo! YQL console and web service to obtain data from our recipes data feed and transform that data into a JSON object, which we will then bind to our TableView.<a id="id81" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 5</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>How to do it...</h2></div></div></div><p>First of all, go to Yahoo's YQL console page by opening up<a class="ulink" href="http://developer.yahoo.com/yql/console"> http://developer.yahoo.com/yql/console</a> in your browser. On the right-hand side of the browser window you should notice a section called '<span class="strong"><strong>Data Tables</strong></span>'. Select '<span class="strong"><strong>data</strong></span>' and then '<span class="strong"><strong>feed</strong></span>' from the data tables list. Your SQL statement should automatically change to a simple data feed from the Yahoo! News Network. Now, replace the URL value in the YQL statement to our recipe's feed, which is<a class="ulink" href="http://www.cuisine.com.au/feed/all-recipes"> http://www.cuisine.com.au/feed/all-recipes</a>, select '<span class="strong"><strong>JSON</strong></span>' instead of<span class="strong"><strong> XML</strong></span> from the radio buttons below, and click on '<span class="strong"><strong>Test</strong></span>' as shown in the following screenshot. You should see a formatted set of data return in the results window in JSON format!</p><div class="mediaobject"><img src="graphics/3968EXP_02_05.jpg" alt="How to do it..."/></div><p>To use this data we need to copy and paste the full REST query from the YQL console. This is right at the bottom of the browser and is a single-line textbox. Copy and paste the entire URL into your<code class="literal"> xhr.open()</code> method, replacing the existing recipes feed URL.<a id="id82" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"/>Tip</h3><p>Make sure when you paste the string in, it hasn't broken due to any apostrophes. If it has, you will need to escape any apostrophe characters by replacing<span class="strong"><strong>'</strong></span> with<span class="strong"><strong> \'</strong></span>. You may also want to remove the<code class="literal">&amp;callback=cbfunc</code> parameter from the URL as it can sometimes cause the JSON to stop parsing.</p></div><p>Now, back in the<code class="literal"> xhr.onload()</code> function, let's replace all of the XML parsing code with code to parse our data in JSON format instead:<a id="id83" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//this method will process the remote data
xhr.onload = function() {
//create a json object using the JSON.PARSE function
var jsonObject = JSON.parse(this.responseText);
//print out how many items we have to the console
Ti.API.info(jsonObject.query.results.item.length);
//loop each item in the json object
for(var i = 0; i &lt; jsonObject.query.results.item.length; i++) {
//create a table row
var row = Titanium.UI.createTableViewRow({
hasChild: true,
className: 'recipe-row',
backgroundColor: '#fff',
filter: jsonObject.query.results.item[i].title
//this is the data we want to search on (title)
});
//title label
var titleLabel = Titanium.UI.createLabel({
text: jsonObject.query.results.item[i].title,
font: {fontSize: 14, fontWeight: 'bold'},
left: 70,
top: 5,
height: 20,
width: 210,
color: '#000'
});
row.add(titleLabel);
//description label
var descriptionLabel = Titanium.UI.createLabel({
text: jsonObject.query.results.item[i].description,
font: {fontSize: 10, fontWeight: 'normal'},
left: 70,
top: 25,
height: 40,
width: 200,
color: '#000'
});
if(descriptionLabel.text == '') {
descriptionLabel.text = 'No description is
available.';
}
row.add(descriptionLabel);
//add our little icon to the left of the row
var iconImage = Titanium.UI.createImageView({
image: 'images/foodicon.jpg',
width: 50,
height: 50,
left: 10,
top: 10
});
row.add(iconImage);
//add the table row to our data[] object
data.push(row);
}
//finally, set the data property of the tableView
//to our data[] object
tblRecipes.data = data;
};
//this method will fire if there's an error in accessing
//the remote data
xhr.onerror = function() {
//log the error to our Titanium Studio console
Ti.API.error(this.status + ' - ' + this.statusText);
};
//open up the recipes xml feed
xhr.open('GET', 'http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20feed%20where%20url%3D%22http%3A%2F%2Fwww.cuisine.com.au%2Ffeed%2Fall-recipes%22&amp;format=json&amp;diagnostics=false');
//finally, execute the call to the remote feed
xhr.send();
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>How it works...</h2></div></div></div><p>As you can see in this recipe, accessing the YQL web service is simply a matter of passing an HTTP GET query to the YQL service URL, using a YQL statement as a URL parameter. When it processes a query, the Yahoo! YQL service obtains and transforms the requested data and returns in your specified format (in our case, JSON).<a id="id84" class="indexterm"/>
</p><p>Accessing the properties of the JSON data object is also different, and arguably much simpler, as compared to XML. In JSON we use simple dot notation to navigate the data tree hierarchy and select the property we want to use. If you already understand the array syntax in PHP, Javascript, and a number of other C-Style languages, this should be pretty familiar to you!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>There's more...</h2></div></div></div><p>Throughout this chapter we have only been using a single RSS feed source, but what if you have multiple RSS feeds that you wish to read in simultaneously?</p><div class="section" title="Combining multiple RSS feeds…"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Combining multiple RSS feeds…</h3></div></div></div><p>The answer to the previous question is to use Yahoo! Pipes—a free service provided by Yahoo! that let's you create a "pipe" consisting of one or more RSS, JSON, or data feeds which can be filtered and sorted before allowing you to output the data to a single feed. Give it a try by signing up for free at<a class="ulink" href="http://pipes.yahoo.com"> http://pipes.yahoo.com</a>.<a id="id85" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Creating an SQLite database"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Creating an SQLite database</h1></div></div></div><p>There are many reasons why SQLite has become the relational database of choice for mobile handsets—it is scalable, fast, written in native C, and very portable, and has the added bonus of an exceptionally small footprint. We need local databases on our devices in order to store data when devices are offline, or even to store data that is only required locally (high scores in a game, for instance).<a id="id86" class="indexterm"/>
</p><p>Additionally, the caching of remote data can help speed up data access times in our applications—particularly important when mobile devices may have limited connectivity and bandwidth.</p><p>There are two ways to create SQLite databases in your application, one—create the database in code using SQL and two—copy and attach an existing database to your app via the 'install' method. In this recipe we will explain how to create a database via SQL statements.<a id="id87" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 1/Recipe 6</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>How to do it...</h2></div></div></div><p>Create a new JavaScript file called<code class="literal"> database.js</code>, and type in the following code at the top of your new file:</p><div class="informalexample"><pre class="programlisting">//create the database object
var db = Titanium.Database.open('mydb');
db.execute('CREATE TABLE IF NOT EXISTS favorites (ID INTEGER PRIMARY KEY AUTOINCREMENT, TITLE TEXT, LINK TEXT, DESCRIPTION TEXT)');
</pre></div><p>Now add the following line to the top of each Window that we need to reference our database functions from. Do this to both your<code class="literal"> recipes.js</code> and<code class="literal"> favorites.js</code> files.</p><div class="informalexample"><pre class="programlisting">Ti.include('database.js');
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>How it works...</h2></div></div></div><p>One of the great things about SQLite is the simplicity of its creation. In the previous example code, you can see we are not even performing a "create database" query anywhere. Simply attempting to open a database that does not exist, in this case<code class="literal"> mydb</code>, tells the SQLite engine to create it automatically!<a id="id88" class="indexterm"/>
</p><p>From there we can create our SQL table using standard SQL syntax. In our case, we have created a table with an ID that is both the primary key and an auto-incrementing number, a title, link, and description. The latter three fields match the data being returned from our recipes data source. In the next recipe we can use this table to locally store our recipe data.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>There's more...</h2></div></div></div><p>Let's take a look at attaching a pre-populated database file.</p><div class="section" title="Attaching a pre-populated database file…"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Attaching a pre-populated database file…</h3></div></div></div><p>Should you wish to create your database separately and attach it to your application at runtime, there is a method called<code class="literal"> Titanium.Database.install().Implementing</code> this method is very easy, as it just accepts two parameters—the database file and the database name. As an example:<a id="id89" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Var db = Titanium.Database.install('data.db', 'packtData');
</pre></div><p>There are also numerous free SQLite applications for creating and managing SQLite databases. The open source<span class="strong"><strong> SQLite Database Browser</strong></span> tool is freely available from<a class="ulink" href="http://sqlitebrowser.sourceforge.net"> http://sqlitebrowser.sourceforge.net</a> and runs on Windows, Linux, and Mac OS X.<a id="id90" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Saving data locally using an SQLite database"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Saving data locally using an SQLite database</h1></div></div></div><p>Saving and updating data to your SQLite database is just a matter of creating a function for each CRUD operation you need, and forming the SQL statement before executing it against the local database (our '<code class="literal">db</code>' object).<a id="id91" class="indexterm"/>
</p><p>In this recipe, we will edit the<code class="literal"> database.js</code> file to contain two new functions, one for inserting a record in our favorites table and one for deleting a record. We will also capture the click events on our Table Rows to allow the user to view the record in a detailed sub-window, and add a button for creating the favorite.<a id="id92" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 7</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>How to do it...</h2></div></div></div><p>Open your JavaScript file called<code class="literal"> database.js</code>, and type in the following code at the top of your new file, after your table creation script:<a id="id93" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">function insertFavorite(title, description, link) {
var sql = "INSERT INTO favorites (title, description, link) VALUES (";
sql = sql + "'" + title.replace("'", "''") + "', ";
sql = sql + "'" + description.replace("'", "''") + "', ";
sql = sql + "'" + link.replace("'", "''") + "')";
db.execute(sql);
return db.lastInsertRowId;
}
function deleteFavorite(id) {
var sql = "DELETE FROM favorites WHERE id = " + id;
db.execute(sql);
}
</pre></div><p>Then, back in our<code class="literal"> recipes.js</code> file, we are going to capture the click event of the<code class="literal"> tblRecipes</code> TableView in order to get the tapped row's data and save it to our<code class="literal"> favorites</code> table in SQLite:</p><div class="informalexample"><pre class="programlisting">//create a new window and pass through data from the
//tapped row
tblRecipes.addEventListener('click', function(e){
var selectedRow = e.rowData; //row index clicked
var detailWindow = Titanium.UI.createWindow({
title: selectedRow._title,
_description: selectedRow._description,
_link: selectedRow._link,
backgroundColor: '#fff',
id: 0
});
//add the favorite button
var favButton = Titanium.UI.createButton({
title: 'Add Favorite',
left: 10,
top: 10,
width: 140,
height: 30,
added: 0
});
favButton.addEventListener('click',function(e){
if (favButton.added == 0) {
var newId = insertFavorite(detailWindow.title, detailWindow._description, detailWindow._link);
Ti.API.info('Newly created favorite id = ' + newId);
detailWindow.id = newId;
alert('This recipe has been added as a favorite!');
favButton.added = 1;
favButton.title = 'Remove Favorite';
}
else {
deleteFavorite(detailWindow.id);
Ti.API.info('Deleted ' + affectedRows + ' favorite records. (id ' + detailWindow.id + ')');
detailWindow.id = 0;
alert('This recipe has been removed from favorites!');
favButton.added = 0;
favButton.title = 'Add Favorite';
}
});
detailWindow.add(favButton);
//let's also add a button to open a link in safari
var linkButton = Titanium.UI.createButton({
title: 'View In Safari',
right: 10,
top: 10,
width: 140,
height: 30,
added: 0
});
//this event listener will open the link in safari
linkButton.addEventListener('click',function(e){
Ti.Platform.openURL(detailWindow._link);
});
detailWindow.add(linkButton);
//finally, add the full description so we can read the
//whole recipe
var lblDescription = Titanium.UI.createLabel({
text: detailWindow._description,
left: 10,
top: 50,
width: 300,
height: 'auto',
color: '#000'
});
detailWindow.add(lblDescription);
//open the detail window
Titanium.UI.currentTab.open(detailWindow);
});
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>How it works...</h2></div></div></div><p>First, we are creating functions that will accept the parameters to insert a favorite record, creating an SQL statement, and then executing that SQL query statement against our SQLite database. This is just a basic SQL query, although take note that just as you would with a desktop application or website, any input parameters should be escaped properly to avoid SQL injection! We're using a simple mechanism to do this in our recipe by simply replacing any occurrences of the apostrophe characters with a double apostrophe.<a id="id94" class="indexterm"/>
</p><p>The second half of our code defines a new Window and adds to it a couple of buttons and a label for displaying the full text of our recipe. You should refer to<a class="link" href="ch01.html" title="Chapter 1. Building Apps using Native UI Components"> Chapter 1</a>,<span class="emphasis"><em> Building Apps Using Native UI Components</em></span>, for more details on opening Windows, and adding and customizing UI components to them. One final point of interest, and a method we haven't come across before, is<code class="literal"> Ti.Platform.openURL().</code> This method simply takes a valid URL and launches the Safari browser (or Android browser) on your phone. In our recipe, we're passing the "link" property from our data so the user can view the recipe in full from it's original website.<a id="id95" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>There's more...</h2></div></div></div><p>Android users can always press their back button on the device to return to the app after the browser is launched, but it's worth noting that iPhone users would need to close Safari and re-launch the application from their home screen after the link button has been pressed. To avoid this, you could create another sub-window containing a WebView component, opening this through the<code class="literal"> Titanium.UI.currentTab.open()</code> method, just as we did for our detail view in this recipe.<a id="id96" class="indexterm"/>
</p><p>The following screenshots show the detail view window for our recipe, before and after we insert a favorite record into the SQLite database table.</p><p>
<span class="emphasis"><em>For an iPhone:</em></span>
</p><div class="mediaobject"><img src="graphics/3968EXP_02_06.jpg" alt="There's more..."/></div><p>
<span class="emphasis"><em>For an Android phone:</em></span>
</p><div class="mediaobject"><img src="graphics/3968EXP_02_07.jpg" alt="There's more..."/></div></div></div>
<div class="section" title="Retrieving data from an SQLite database"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Retrieving data from an SQLite database</h1></div></div></div><p>The ability to create a table and insert data into it is not of much use if we don't know how to retrieve that data and present it in some useful way to the user! We'll now introduce the concept of a<span class="strong"><strong> resultSet</strong></span> (or recordSet if you prefer) in SQLite and how to retrieve data via this resultSet object that can be collected and returned to an array format suitable for usage within a TableView.<a id="id97" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 8</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>How to do it...</h2></div></div></div><p>In your<code class="literal"> database.js</code> file, add the following function:</p><div class="informalexample"><pre class="programlisting">function getFavorites() {
var sql = "SELECT * FROM favorites ORDER BY title ASC";
var results = [];
var resultSet = db.execute(sql);
while (resultSet.isValidRow()) {
results.push({
id: resultSet.fieldByName('id'),
title: resultSet.fieldByName('title'),
description: resultSet.fieldByName('description'),
link: resultSet.fieldByName('link')
});
//iterates to the next record
resultSet.next();
}
//you must close the resultset
resultSet.close();
//finally, return our array of records!
return results;
}
</pre></div><p>Now, open the<code class="literal"> favorites.js</code> file for the first time, and type in the following code. Much of this code should be pretty familiar to you by now, including defining and adding a TableView to our Window, plus including the<code class="literal"> database.js</code> file through our<code class="literal"> Ti.include()</code> method.<a id="id98" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Ti.include('database.js');
var win = Titanium.UI.currentWindow;
var data = []; //empty data array
var tblFavorites = Titanium.UI.createTableView({
height: 366,
width: 320,
top: 0,
left: 0
});
win.add(tblFavorites);
function loadFavorites(){
data = []; //set our data object to empty
data = getFavorites();
tblFavorites.data = data;
}
//the focus event listener will ensure that the list
//is refreshed whenever the tab is changed
win.addEventListener('focus', loadFavorites);
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>How it works...</h2></div></div></div><p>The first block of code is really just an extension of our previous recipe. But instead of creating or removing records, we are selecting them into a database recordset called "resultSet", and then looping through this resultSet object adding the data we require from each record into our<code class="literal"> results</code> array.<a id="id99" class="indexterm"/>
</p><p>The<code class="literal"> results</code> array can then be added to our TableView's data property just like any other data source such as you obtained at the start of the chapter from an external XML feed. One thing to note is that you must<span class="emphasis"><em> always</em></span> iterate to the new record in the resultSet using<code class="literal"> resultSet.next()</code>, and when finished,<span class="emphasis"><em> always close</em></span> the resultSet using<code class="literal"> resultSet.close()</code>. A failure to do either of these actions can cause your application to record invalid data, leak memory badly, and in the worst case, fatally crash!<a id="id100" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_02_08.jpg" alt="How it works..."/></div><p>The previous screenshot shows the TableView in our<span class="strong"><strong> Favorites</strong></span> tab displaying the records we have added as 'favorites' to our local SQLite database.<a id="id101" class="indexterm"/>
</p></div></div>
<div class="section" title="Creating a &quot;pull and release&quot; refresh mechanism"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Creating a "pull and release" refresh mechanism</h1></div></div></div><p>What happens if you want the user to be able to refresh the feed data in our table? You could create a regular button, or possibly check for new data at arbitrary time intervals. Alternatively, you could implement a cool 'pull and release' refresh mechanism made very popular by Twitter applications such as Tweetie and Twitter for Android.<a id="id102" class="indexterm"/>
</p><p>In the final recipe for our<span class="strong"><strong> Recipe Finder</strong></span> app, we will implement the very same type of refresh mechanism for our recipes feed, using the table view's<code class="literal"> headerPullView</code> property.<a id="id103" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 2/Recipe 9</code> folder, while the complete source code for this entire chapter can be found in the<code class="literal"> /Chapter 2/RecipeFinder</code> folder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How to do it...</h2></div></div></div><p>Open your<code class="literal"> recipes.js</code> file and type in the following code under the "<code class="literal">Ti.include</code>" statements. This is where will be creating the pull view and adding our user interface components to it, before creating the event listeners that will perform the data request.<a id="id104" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//this variable defines whether the user is currently pulling
//the refresh mechanism or not
var pulling = false;
//defines whether we're currently fetching data or not
var reloading = false;
//let's create our 'pull to refresh' view
var tableHeader = Ti.UI.createView({
backgroundImage: 'images/header.png',
width:320,
height:81
});
var arrowImage = Ti.UI.createView({
backgroundImage:"images/arrow-down.png",
width: 40,
height: 40,
bottom: 20,
left:20
});
var statusLabel = Ti.UI.createLabel({
text:"Pull to refresh...",
left:85,
width:200,
bottom:28,
height:"auto",
color:"#000",
textAlign:"center",
font:{fontSize:20,fontWeight:"bold"},
shadowColor:"#999",
shadowOffset:{x:0,y:1}
});
var actInd = Titanium.UI.createActivityIndicator({
left:20,
bottom:20,
width: 40,
height: 40
});
tableHeader.add(actInd);
tableHeader.add(arrowImage);
tableHeader.add(statusLabel);
//define our table view
var tblRecipes = Titanium.UI.createTableView({
height: 366,
width: 320,
top: 0,
left: 0,
rowHeight: 70,
search: searchBar,
filterAttribute:'filter' //here is the search filter which
//appears in TableViewRow
});
//add the header pull view
tblRecipes.headerPullView = tableHeader;
tblRecipes.addEventListener('scroll',function(e)
{
var offset = e.contentOffset.y;
if (offset &lt;= -80.0 &amp;&amp; !pulling)
{
pulling = true;
arrowImage.backgroundImage = 'images/arrow-up.png';
statusLabel.text = "Release to refresh...";
}
else if (pulling &amp;&amp; offset &gt; -80.0 &amp;&amp; offset &lt; 0)
{
pulling = false;
arrowImage.backgroundImage = 'images/arrow-down.png';
statusLabel.text = "Pull to refresh...";
}
});
tblRecipes.addEventListener('scrollEnd',function(e)
{
if (pulling &amp;&amp; !reloading &amp;&amp; e.contentOffset.y &lt;= -80.0)
{
reloading = true;
pulling = false;
arrowImage.hide();
actInd.show();
statusLabel.text = "Reloading recipes...";
tblRecipes.setContentInsets({top:80},{animated:true});
//null out the existing recipe data
tblRecipes.data = null;
data = [];
//open up the recipes xml feed
xhr.open('GET', 'http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20feed%20where%20url%3D%22http%3A%2F%2Fwww.cuisine.com.au%2Ffeed%2Fall-recipes%22&amp;format=json&amp;diagnostics=false');
//and fetch it again
xhr.send();
}
});
</pre></div><p>Finally, in your<code class="literal"> xhr.open()</code> method, we will do a check to see if this is the first time we're loading data or whether this is a reload call made by our "pull and release" mechanism. If it's the latter, we'll hide the header pull view and reset the contents of it back to its original state.<a id="id105" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//check to see if we are refreshing the data via our
//pull and release mechanism
if(reloading == true){
//when done, reset the header to its original style
tblRecipes.setContentInsets({top:0},{animated:true});
reloading = false;
statusLabel.text = "Pull to refresh...";
actInd.hide();
arrowImage.backgroundImage = 'images/arrow-down.png';
arrowImage.show();
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How it works...</h2></div></div></div><p>What we are doing here can really be broken up into two main components. First, we're creating a header view using standard UI components. Second, we're using events to know when our header view has been 'pulled' down far enough so that we can perform a refresh on our recipes data from the XML/JSON feed.<a id="id106" class="indexterm"/>
</p><p>We know how far the header view has been pulled down via the<code class="literal"> contentOffset</code> property of our TableView. In this case, we are executing the refresh of the data when the content offset hits 80px, which is the height of both the header view and also the height of the TableView's data rows from the top of the screen.<a id="id107" class="indexterm"/>
</p><p>Finally, the two variables called<code class="literal"> pulling</code> and<code class="literal"> reloading</code> are used in conjunction so we can determine the series of steps in our "pull and release" refresh mechanism programmatically:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">When the TableView is being pulled down by the user, using a tap and hold gesture (<code class="literal">pulling = true</code>)</li><li class="listitem">When the TableView has finished pulling but has not yet started to reload the data from our remote data source (<code class="literal">pulling = true</code> and<code class="literal"> reloading = false</code>)</li><li class="listitem">When our pulling has completed but we are waiting for the data to finish being returned from our remote data source (<code class="literal">pulling = false</code> and<code class="literal"> reloading = true</code>)</li><li class="listitem">Finally, when our remote data source has finished streaming the required data and the header pull view can be closed, and the scrolling offset of our table can return to normal (<code class="literal">pulling = false</code> and<code class="literal"> reloading = false</code>)</li></ol></div></div></div></body></html>