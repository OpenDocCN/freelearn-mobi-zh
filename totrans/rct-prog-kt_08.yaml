- en: Testing RxKotlin Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered more than 60% of the book and have learned a lot of concepts.
    From the first chapter, starting with concepts of reactive programming till the
    previous chapter about concurrent execution and parallelism. But we cannot complete
    the application development without introducing a few tests. It is probably the
    most crucial point in the process of application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to testing. As Kotlin itself is relatively new, our
    first objective would be to learn testing in Kotlin. We will then proceed with
    testing in RxKotlin. The following are the topics we are going to cover in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing and its importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin and JUnit, Kotlin-test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tools in RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestObserver` and `TestSubscriber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing and its importance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While testing is absolute necessary in application development, many novice
    developers get away with a few basic questions regarding testing. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing? and why is it a developer's job?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is unit testing so important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, do we need to write unit tests for each section of our programs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start this chapter by answering these basic questions. If you would
    like to rather start with testing using RxKotlin directly, you can skip the first
    few sections in this chapter and start from *Testing tools in RxKotlin*. Though
    I would encourage you to read the chapter throughout, even if you have previous
    experience in testing with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining unit testing. Unit testing is a level of software testing
    where  the individual smallest testable components of a software (aka application),
    called **units** are tested. The purpose is to validate that each unit of the
    software performs as it was supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests can be done manually, but they are often automated. The sole purpose
    of automated unit testing is to reduce human error and eliminate any extra bugs/errors
    caused by them. To explain let''s first remember the proverb:'
  prefs: []
  type: TYPE_NORMAL
- en: To err is human
  prefs: []
  type: TYPE_NORMAL
- en: So, if we do the unit tests manually, the chances of additional errors or bugs
    will rise. Automated unit tests can eliminate this risk as they include minimal
    human effort.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to document the tests we've performed, and we need to perform
    the same tests again with new ones with each incremental build of our product.
    Automated unit tests eliminate that extra effort, as you would be required to
    write the test once and then you can run them any time in the future. Also, automated
    unit tests also reduce documentation efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it a developer's job? Who would write the code for automated testing
    other than the developers?
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is not possible for developers to give understanding to tester after
    completing each small units of an application. Even you may have completed some
    module, which is not yet on the GUI, so the tester or anyone else than you may
    not even be able to reach that unit to test. Also, it may not have any direct
    impact or relation with the UI/UX, it may be a small internal code part.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, a developer better understands his code and he knows well what
    exactly he wants from that bunch of code. So the developer is the best person
    to write unit tests on that module.
  prefs: []
  type: TYPE_NORMAL
- en: Why is unit testing so important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a real-life example. Think of an engineer, creating a new motor or
    device. The engineer will test the functionality after completing each unit of
    that motor, rather than testing the whole motor at the end (though he / she will
    test the whole motor at the end, but will also test it repeatedly and incrementally
    while building it). The main reason behind this behavior is that if he / she doesn't
    do that, at the end it would take a lot effort to identify the exact problems
    (if any). While testing incrementally will allow you to fix any problem right
    away as soon as it arises. The same applies for software (applications) as well.
  prefs: []
  type: TYPE_NORMAL
- en: You should perform unit tests periodically and repeatedly as you develop each
    module of your application the more you test the better is the out product. And
    yes, **we should write unit tests for each and every functional section of our
    applications**.
  prefs: []
  type: TYPE_NORMAL
- en: By **functional section** we mean each section that performs any small operation
    and/or function. We can skip testing a POJO class with just getters and setters,
    but we must test the code which uses that POJO class to accomplish something.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we've understood the importance of testing, let's start by writing JUnit
    tests in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Writing JUnit tests in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've any experience with Java development, you've heard of or most probably
    worked with JUnit. It is a testing framework, for Java (as well as Kotlin).
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically unit tests are created in a separate source folder than real source
    codes, to keep it separated. The standard Maven/Gradle convention uses `src/main`
    for real codes (Java/Kotlin files or classes) and `src/test` for test classes.
    The following screenshot shows the structure for the project we''re using in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1411a8e-1204-4043-b8f0-e45b8c0e3546.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before beginning to write test cases we''ve to add the following Gradle dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've added a dependency to Mockito as well, which we are going to cover soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have got everything ready, let''s write our first test case. Please
    refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Have a close look at the preceding program. Each JUnit test case should be defined
    as a function inside a class. The class that contains the JUnit test functions
    should only be used for testing purposes and should not serve any other purpose.
    The `test` function should be annotated with the `@Test` annotation, as we did
    in comment `(1)`. This annotation helps JUnit to detect and execute the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, give a cautious look at the line containing comment `(2)`. The function
    name is `` `my first test`() ``. Yes, it contains space within the function name.
    That is probably the best thing you can get while writing test cases in Kotlin.
    Kotlin allows you to have functions that have names without spaces, while they
    aren't good practice while writing codes, they are quite a life saver while writing
    tests; as you don't need to call the `test` functions elsewhere, they actually
    serve as readable test names.
  prefs: []
  type: TYPE_NORMAL
- en: In comment `(3)`, we wrote the actual test. The `assertEquals` test checks for
    equality between `expected` and `actual` values. The first parameter in this test
    is the expected value, and the second one is the actual one, which should be equal
    to the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the test, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c3bbc91-307a-4ae7-b942-b154be390075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we modify the program and pass `2+3` instead of `1+2` as the actual parameter,
    then the test would fail and give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8089b0b9-8a7b-4f73-8b6d-edaac8af77b2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also pass a failure message, that would be shown in case of failure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The message would be shown in the error report if the test fails. Have a look
    at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5bb218e-b0ed-4a1b-b1fc-67c9a0f6aacb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier section, we learned how to write test cases, but did we test
    our code? No. We did the tests with some oblivious values. And we know that is
    not the purpose of tests. Tests are there to make sure that our functions, classes,
    and code blocks are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We should write the tests on top of our existing code (unless we are following
    **Test-driven development** (**TDD**)).
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development is a development methodology where tests are written
    first, and then the actual source code is written that would pass the test cases.
    Test-driven development is hugely popular among developers and architects and
    many companies follow TDD as their development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a small Kotlin file that contains a few methods for calculations,
    we would perform tests on top of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, following class is with the test cases, go through the code carefully,
    and then we will describe it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the package declarations. Both files share the same package name,
    we deliberately did this, so that we would not have to import the functions.
  prefs: []
  type: TYPE_NORMAL
- en: We used the simplest functions in the source code so that you can understand
    the code easily. Also notice that we wrote each test case separately, just like
    a function, we can obviously call multiple test functions within a test case,
    though. Confused? Let's elaborate, when you're testing multiple aspects of a single
    function or property you can (and should) group them all inside a test function
    (a function with an `@Test` annotation). Generally, compilers display test results
    as they encounter test functions, irrespective of how many tests each test function
    performs. So rest assured that your tests will be performed if you group them
    inside a single test function, they will however be shown as a single test. However
    when you're writing tests for separate functions or properties you would obviously
    want a separate report for all of them, in that case you should write them separately
    just like the earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the output now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b4f905-d6d2-405b-b7fe-863d5ea03638.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But in each of the earlier examples, we used only `assertEquals`; seeing this,
    you may have a question, is `assertEquals` the only test function available? The
    answer is a big no. We''ve plenty of test functions available with Kotlin. The
    following are a few test cases with oblivious values, just to have an idea about
    the most useful test functions in Kotlin. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before inspecting the test cases here, let''s have a look at the following
    test output screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c134e7e5-4609-4fb6-afe2-41b6282adaba.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's try to understand the code. We will start with the `` `expected block
    evaluation`() `` test. The `expect` test function takes the expected value as
    the first parameter and a block (lambda) as the second parameter, executes the
    lambda, and checks the return value against the expected value for equality.
  prefs: []
  type: TYPE_NORMAL
- en: The second test case was `` `assert illegal value`() ``, in that test case we
    are using the `assertNotEquals()` test method. This test method does the exact
    opposite than the `assertEquals()`. It fails the test if both parameters are equal.
    The `assertNotEquals()` is especially useful when you've a function that should
    return any value except a particular one.
  prefs: []
  type: TYPE_NORMAL
- en: In the `` `assert true boolean value`() `` and `` `assert true boolean value`()
    `` test cases we used `assertTrue()` and `assertFalse()` respectively. Both test
    methods takes a `Boolean` value as parameter. As the name suggests, `assertTrue()`
    expects the value to be `true`, while `assertFalse()` expects to be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The next two test cases are for nulls. The first one `` `assert that passed
    value is null`() `` uses `assertNull()`, which expects the passed value to contain
    `null`. The second one uses `assertNotNull()` in complete opposite way, expects
    the value would not be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we got some hands-on idea on writing test cases, let's get started with
    testing in **RxKotlin**.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, as you've some hands-on testing in Kotlin and have some idea about RxKotlin
    as well, you may be wondering how to implement test cases in RxKotlin? It is true
    that testing in RxKotlin may not seem straightforward; the reason is that ReactiveX
    defines behavior rather than states, and most testing frameworks, including JUnit
    and kotlin—test are good for testing states.
  prefs: []
  type: TYPE_NORMAL
- en: To the aid of developers, RxKotlin comes with a set of tools for testing, which
    you can use with your favorite testing frameworks. In this book, we will cover
    testing in RxKotlin with JUnit and Kotlin-test.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to remember the code blocks from previous chapters, where we used `delay`
    to make the main thread wait whenever we used an `Observable` or `Flowable` that
    operates on a different thread. A perfect example of this scenario is when we
    used `Observable.interval` as a factory method or when we used the `subscribeOn`
    operator. To get you refreshed, following is such a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we switched to `Schedulers.computation` for the subscription.
    Now let''s see, how we can test this Observable and check that we received exactly
    `10` emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the testing result first before digging into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01b50387-015c-466c-9a1f-781ddeeee7c0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a few things that need explanations in this code. The first one is
    `AtomicInteger`. `AtomicInteger` is a wrapper around integer in Java, that allows
    an `Int` value to be updated atomically. Though `AtomicInteger` extends `Number`
    to allow uniform access by tools and utilities that deal with numerically-based
    classes, it cannot be used as a replacement of `Integer`. We used `AtomicInteger`
    in this code to ensure atomicity, as the subscription was running in the `computationScheduler`
    (thus in multiple threads).
  prefs: []
  type: TYPE_NORMAL
- en: The line, that demands our attention is where we put comment `(2)`. We used
    `blockingSubscribe` instead of just `subscribe`. When we subscribe to a producer
    with the `subscribe` operator and the subscription is not in the current thread,
    the current thread doesn't wait for the subscription to complete and moves to
    the next line instantly. That's why we used delay to make the current thread wait.
    Using `delay` inside `tests` is troublesome. While `blockingSubscribe` blocks
    the current running thread until the subscription finishes up (even if the subscription
    occurs in a separate thread), that is useful while writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `blockingSubscribe` is useful in testing, it cannot always serve your
    purpose. You might need to test the first, last or all the values of the producer.
    For that purpose you would need the data in its pure imperative nature.
  prefs: []
  type: TYPE_NORMAL
- en: The set of yet uncovered operators in RxKotlin is at your helm in that scenario.
    The blocking operators serve as an immediate accessible bridge between the reactive
    world and the imperative world. They block the current thread and make it wait
    for the results to be emitted, but returns them in a non-reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: The only similarity between `blockingSubscribe` and blocking operators are that
    both block the declaring thread even if the reactive operations are performed
    in a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: Other than this one, there are no more similarities. The `blockingSubscribe`
    treats the data as reactive and doesn't return anything. It rather pushes them
    to the subscriber (or lambda) specified. Whereas blocking operators will return
    the data in a non-reactive nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains the blocking operators we are going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blockingFirst()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockingGet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockingLast()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockingIterable()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockingForEach()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though we should avoid using them in production as they encourage anti-patterns
    and reduce the benefits of reactive programming, however we can surely use them
    for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the first emitted item – blockingFirst()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first blocking operator we are going discuss is the `blockingFirst` operator.
    This operator blocks the calling thread until the first item is emitted and returns
    it. The following is an ideal test case for `blockingFirst()`, where we are performing
    a sorting operation on Observable and we are testing it by checking if the first
    emitted item is the smallest. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The test result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0690a3d8-3775-42db-85db-ec9f998ee39f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the program, we created an unsorted list of integers from `1` to `10` and
    created an Observable with the list, so the smallest item from that Observable
    should be `1`. We obtained the first item and made the thread to wait till we
    get it with the help of the `blockingFirst()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Then used the `assertEquals` testing function to assert that the first emitted
    item is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the only item from single or maybe - blockingGet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're working with `single` or `maybe`, you just can't use any other blocking
    operator other than `blockingGet()`. The reason is quite simple, both monads can
    contain only one item.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create two new test cases by modifying the last test case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first test case, we used `observable.first()` with a default value, this
    operator returns a `Single`; on the second operator, we used `observable.firstElement()`
    this operator returns a `Maybe`. Then we used `blockingGet` in both test cases
    to get the first element as an `Int` and execute the test function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, following screenshot is the test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67e4d586-4e0d-4a4f-ac14-5a24bec75669.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting the last Item - blockingLast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have `blockingFirst`, so it''s quite obvious that we would have `blockingLast`.
    As expected, it gets you the last emitted item while blocking the thread until
    the source emits it. The following is the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we are expecting the last emitted item, we are checking equality with `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the screenshot of the testing result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2f3e782-614c-4c5a-b022-7b33a5d0e0f6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting all emissions as iterable - blockingIterable operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we fetched the first emitted item, we fetched the last emitted item, but
    what if we want all the items emitted for testing? The `blockingIterable` operator
    gets you with the same. The `blockingIterable` operator works in an interesting
    way, it passes an emission to the `Iterable`, then the `Iterable` will keep blocking
    the iterating thread until the next emission is available. This operator queues
    up unconsumed values until the `Iterator` can consume them, and this can cause
    `OutOfMemory` exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So following is an example, where we are obtaining the complete list and then
    we are checking if the emissions were sorted by converting the returned `Iterable`
    to `List` and checking equality with the source `list` after sorting. Please refer
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the emissions were sorted, the `iterable`, when converted to `list`, should
    be equal to `list.sorted()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the screenshot of the test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cab01c7-85d6-47f1-a568-5e47dbd1967a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looping through all emissions - blockingForEach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to loop through all the emissions then `blockingForEach` is probably
    a better solution. It's better than `blockingIterable` as it will not queue up
    the emissions. Rather will it block the calling thread and wait for each emission
    to be processed before allowing the thread to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we created an `Observable` from a list of `Int`.
    Then applied a filter for even numbers only and then within the `blockingForEach`
    we are testing whether all the received numbers are even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a5582fe-8504-46df-a0e2-dec7180b0fd2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We covered the most useful blocking operators up until now. They are useful
    for simple assertions and can effectively block the code so that we can perform
    our testing operations.
  prefs: []
  type: TYPE_NORMAL
- en: However, using blocking code does no good in production. While it seems that
    using blocking code for testing is ok, but it is actually not. It can do significant
    harm to keep you from the benefits of testing. How? Just think of multiple Observables/Flowables
    are emitting concurrently for your application, if you put them on the blocking
    code their complete behavior may change and as a result you'll be deprived from
    the benefits of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the way out? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing TestObserver and TestSubscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you read through this chapter, you may have developed an idea that the only
    way we can perform tests are through blocking the code, either by using `blockingSubscribe`
    or by using blocking operators. *But this is not the case*. In fact, there are
    more comprehensive ways to reactive code, or rather we can say that we can test
    reactive code reactively.
  prefs: []
  type: TYPE_NORMAL
- en: To say it more precisely, in a Subscriber we have `onError` and `onComplete`
    that demands testing along with `onNext`, which is not always possible with just
    blocking. Yes some sort of blocking is necessary, but it cannot alone do all the
    things and it also needs to be managed reactively.
  prefs: []
  type: TYPE_NORMAL
- en: So, here are your two superheroes to make the developers life easy—`TestObserver`
    and `TestSubscriber`. As with `Subscriber` and `Observer`, you can use `TestSubscriber`
    with `Flowables` and `TestObserver` with `Observables`, everything except that
    is similar between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So we did perform the same set of tests with `TestObserver` and `TestSubscriber`.
    The test result is obviously passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43522289-c0d2-4ebd-8fda-a106f134cf6d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now understand the test cases. On comment `(1)`, we are subscribing to
    the Observable/Flowable. On comment `(2)`, we are checking if the Subscription
    was successful and was only one with the help of the `assertSubscribed()` test.
    On comment `(3)`, we are blocking the thread until the Observable/Flowable completes
    its execution with the `awaitTerminalEvent()` method. This terminal event can
    be `onComplete` or `onError` as well. On comments `(4)` and `(5)`, we are checking
    whether the `Observable` and/or `Flowable` has completed successfully without
    any errors, `assertNoErrors()` will test whether the Subscription hasn't received
    any errors and `assertComplete()` will test whether the producer has completed
    successfully . On comment `(6)`, we are testing that the total received emission
    count was `20` (there were 20 items in the list), `assertValuesCount()` helps
    us with this objective. On comment `(6)`, with the help of `assertValues()` we
    are testing the expected and actual values of each of the emissions in its order.
  prefs: []
  type: TYPE_NORMAL
- en: So it was cool, right? The next thing I'm going to show is probably cooler.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TestScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of an Observable/Flowable created with the `Observable.interval()` / `Flowable.interval()`
    factory method. If you have given a long interval (say five minutes) in them and
    have tested at least say 100 emissions then it would take a long time for testing
    to complete (500 minutes = 8.3 hours, that is, a complete man-hour just to test
    a single producer). Now if you have more producers like that with a larger interval
    and more emissions to test then it would probably take the whole lifetime to test,
    when would you ship the product then?
  prefs: []
  type: TYPE_NORMAL
- en: '`TestScheduler` is here to save your life. They can effectively simulate time
    with time-driven producers so that we can do assertions by fast-forwarding it
    by a specific amount.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the following is the respective implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, here we created an `Observable` with `Observable.interval` with a `5` minute
    interval and `TestScheduler` as its `Scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(1)`, it should not receive any emissions (as there are still `5` minutes
    before it should receive its first emission) and we are testing it with `assertValuesCount(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: We then fast-forwarded the time by `100` minutes on comment `(2)`, and tested
    whether we received `20` emissions on comment `(3)`. `TestScheduler` provides
    us with the `advanceTimeBy` method, which takes a timespan and unit as parameters
    and simulates that for us.
  prefs: []
  type: TYPE_NORMAL
- en: We then fast-forwarded time by another `400` minutes and tested if we received
    a total of 100 emissions on comment `(4)` and comment `(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: As you would expect, the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in this chapter, we learned about testing in Kotlin. We started with the
    benefits of testing and then moved on to testing in Kotlin, using JUnit and Kotlin-test.
  prefs: []
  type: TYPE_NORMAL
- en: As we got some hands-on testing experience in Kotlin, we gradually moved to
    testing in RxKotlin, we learned a few technique to test RxKotlin and learnt about
    the super-convenient testing tools that RxKotlin provides for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we have built a strong base of knowledge in RxKotlin, in the next chapter—[Chapter
    9](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml),
  prefs: []
  type: TYPE_NORMAL
- en: '*Resource Management and Extending RxKotlin* we are going to discuss some advanced
    topics. We will discuss managing resources—how to free allocated memory and prevent
    memory leaks. We will also learn to create our own custom operators, which can
    be chained in the RxKotlin logic just like those predefined operators.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what are you waiting for? Get started on [Chapter 9](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml), *Resource
    Management and Extending RxKotlin,* right now, and from now on don't forget to
    test every code you write.
  prefs: []
  type: TYPE_NORMAL
