- en: Chapter 8. Shoot, Scroll, Shoot Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a game using tile maps and an on-screen
    joystick. We will explore how to use **Tiled**, the free tile map editor, as well
    as how to implement SneakyJoystick. As a stretch, we will also use some advanced
    pathfinding code to make slightly smarter enemies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tiled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SneakyJoystick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt Controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating our game layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semi-smart enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be building a top-down scrolling shooter. It sounds
    simple, but we will be making it a little more challenging with on-screen joystick
    control, enemy AI, and some more sophisticated layer designs. Traditionally, this
    type of game is military-themed, with soldiers running around shooting each other.
    For our game, we have decided it is fruits versus vegetables battling in the desert.
    We don't really have a good backstory to explain this. However, if millions of
    mobile gamers accept that birds and pigs are mortal enemies, then you can certainly
    invent an equally improbable storyline to explain this odd pairing.
  prefs: []
  type: TYPE_NORMAL
- en: Design review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design of this game is based on a decent sized tile map, 50 tiles wide
    and 50 tiles high. Our basic tile size (non-Retina) is 32 x 32 pixels. We will
    implement the tile map as a single scrolling layer, keeping our hero centered
    on the screen (except near the edges, but we''ll get to that). The goal of the
    hero is to pick up three goal "signposts" scattered around the map. There will
    also be health power-ups on the map to restore the hero''s health. We want to
    have two types of enemies. The first will move in a straight path toward the hero.
    The second type will be a little smarter. When they run into an impassable wall,
    we will use an `A* Pathfinding` algorithm to find a way around the wall, and then
    revert to the same straight line toward the hero logic. The player will be able
    to control the hero using either an on-screen joystick or tilt controls. With
    either method, there will be a fire button on-screen to shoot. We will break out
    our game into three layers for easier management: the map layer, the Heads-Up
    Display (HUD) layer, and the control layer. This will keep our code cleaner, and
    avoid the problem of having our controls scroll off-screen when the tile map moves.
    Shall we get started?'
  prefs: []
  type: TYPE_NORMAL
- en: Tiled – a primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tiled is an open source tile map editor available at [http://mapeditor.org](http://mapeditor.org).
    It is available for Mac, Windows, and Linux. As Tiled is an open source program,
    you can also download the source code if you want to see what is "under the hood".
    We are using Tiled version 0.8.1, which is the current version at the same time
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first load Tiled, you will create a new map. Go to **File** | **New**
    from the menu. In the **New Map** dialog box, configure your map like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tiled – a primer](img/9007_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For our game, we will be building our map using non-Retina assets and will later
    "fake" a Retina sizing. Normally, you would be building the Retina version first,
    and then "shrink" the map for the non-Retina version. The same techniques work
    both ways, so we will leave it to you to decide. Anyway, most of these settings
    are self-explanatory, except perhaps the "Orientation". **Orthogonal** is a term
    most people are not familiar with. Basically, it means normal square grid, aligned
    to the x and y axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now be presented with a blank grid of squares. We need to have some
    tiles to use, so we use the menu option **Map** | **NewTileset…**, and are presented
    with the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tiled – a primer](img/9007_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For our game, we will be using the tile map file `tmw_desert_spacing.png` that
    is bundled with the Tiled download under the folder `examples`. (This image is
    also included in the cocos2D downloadable as well, under `Resources/TileMaps`.)
  prefs: []
  type: TYPE_NORMAL
- en: We select this as our image in the dialog box, and then we need to adjust the
    parameters at the bottom of the window. Our tiles are 32 x 32, so we set those
    values for the **Tile width** and **Tile height**. If you look at the tile image,
    you will see that the tiles are not exactly touching. There are black boundaries
    that enforce the grid so you can see which tile is which easily. Because of this,
    we need to set the **Margin** to `1` and the **Spacing** to `1`. You will know
    these settings are correct because in the **Tilesets** window (by default in the
    lower-right pane), you will see the tiles arranged nicely without any traces of
    the black gridlines between them. Tiled shows the tiles with white separators,
    which is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw your map, you simply select the tile you want to use from the **Tilesets**
    pane, and draw on the grid. (If the **Tilesets** pane is not visible, you can
    turn it on under the **View** | **Tilesets** in the menu.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the strengths of Tiled is that you can define multiple layers on a map.
    These layers are visible in the **Layers** pane, which is normally at the top
    left of the display. We start by drawing our basic ground layer, so we rename
    the default layer from **Tile Layer 1** to `ground`. Before we go any further,
    let''s see part of our ground layer that we have drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the ground](img/9007_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we drew our ground layer, we avoided drawing anything that would be picked
    up from the map. In our game, we will be able to pick up health and our goals.
    The reason we avoid drawing those on the ground layer is that when we pick them
    up, the image will be removed from the map. If we had the pickups on the ground
    layer, we would have a blank spot in the map after we picked them up. Instead,
    we create a new layer, name it `pickups`, and draw the items we want to be picked
    up. The following screenshot shows the same area of the map, with the ground layer
    turned off, and only the pickups layer visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the ground](img/9007_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the goal marker (the signpost) will be inside the building, and
    the health (flowery cactus thing) will be near the top-left corner. Simply adding
    the graphics is not enough. We need to be able to add triggers to the map to be
    able to easily interpret the map. We will handle this by building what we refer
    to as "logic layers" into the map. These will not be seen by the user, but will
    be used to trigger events in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Logic layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To identify where tiles should have some logic associated with them, we need
    a new tileset. We have built another tileset called `tile_markers.png` that we
    need to load. This tileset is simply three semi-transparent boxes of different
    colors. When you load this, it is important to change the spacing and margin to
    0 (we didn't use any grid lines in this PNG file.) Also, since we have transparency
    saved in the image file, make sure the **Use transparent color** box is *not*
    checked. If it is, then any transparency in the loaded image will be discarded,
    and our nicely transparent tiles will be opaque.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the tileset is loaded, select it from the **Tilesets** pane. You will
    see three tiles: blue, green, and red. Right-click (or *Ctrl* + click) on the
    blue tile and select **Tile Properties…**. Double-click on **<new property>**
    and name it `Goal`. Under **Value**, enter `Yes`. Then click on **OK** to store
    the property. This will identify the blue tile as a goal tile. Repeat the same
    process for the green tile, except name it `Health` with a value of `Yes`. Finally,
    the red tile should be set with the property `Blocked` with a value of `Yes`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our logic tiles defined, we need to build something with them.
    Create a new layer, named **triggers**. With the **triggers** layer selected,
    draw blue tiles on the positions of the goal markers, and draw green layers on
    our health cacti. Because the tiles have partial transparency, you can see the
    ground tile through the colored tile.
  prefs: []
  type: TYPE_NORMAL
- en: Our next logic layer we need is to define the walls and other impassable tiles.
    We create a new layer, named `walls`. (Make sure you are drawing on the correct
    layer; the layer currently active will be highlighting in the **Layers** pane.)
    Using the red tile, we draw over all walls and rocks in the tile map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same area of the map now looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logic layers](img/9007_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spawn layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only one more layer to complete the tile map. We now add an **Object
    Layer** to the map. Objects are features on the map that do not necessarily correspond
    to tiles. We will be using this layer to identify spawn points for both the hero
    and the enemies. Let''s create an object layer, and name it `spawns`. With the
    spawn layer selected, you will see that different options in the toolbar are selected.
    Select the **Insert Object** button from the toolbar. The following screenshot
    shows how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawn layer](img/9007_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now click on the map to create an object near the opening in the walls on the
    left side of the map. It will display as a grey square. Now you can right-click
    (or *Ctrl* + click) on the box to get a menu. Select **Object Properties**. In
    the window, name this "playerSpawn". This will be the location where the hero
    will be created. You will notice that there are both x and y coordinates, as well
    as width and height. For our use, we will not be using the width and height. The
    x and y coordinates look a little odd. That is because these are tile coordinates.
    Tile coordinates are similar to the coordinates we are used to in cocos2d, except
    the (0, 0) coordinate corresponds to the top-left corner, not the bottom-left.
    When we use these, we will have to do some translation on these coordinates, but
    we will deal with that later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to make a few more objects on the tile map, preferably keeping
    most of them farther away from the hero's spawn point. For each of these, we will
    name them with incremental names `EnemySpawn1`, `EnemySpawn2`, and so on. For
    our game, we have chosen to have 11 enemy spawn points to add some variety. Once
    these are all created, let's save the map as `desert_map.tmx`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TMX format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will go ahead and add our `.tmx` file and our two PNG files to our
    project. If you select the `.tmx` file in Xcode, you can read and edit it directly
    in the Xcode editor. Go ahead and look at the `desert_map.tmx`. It is a plain
    XML file, so it is fairly easy to understand most of the parameters. For now,
    look at the top of the file where the `<tileset>` tags are. You need to make sure
    there isn''t a file path attached to the source value. The first few lines of
    the file should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding TMX format](img/9007_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you can see that all of the parameters we put in Tiled for the map and
    the tilesets is all represented in easily readable and *changeable* text. This
    is important for creating the Retina version of this map.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HD map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said earlier, the usual direction is to create the HD version of everything
    first, and downscale it to the SD resolution. Because we started with a tile set
    that was in non-Retina resolution, we opted to build that version first, and then
    upscale everything.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is take both of our tile set PNG images and convert
    them into HD sized assets. We did this by using Photoshop, and resized them to
    200 percent, and then saved them as -hd files. When doing the resizing (regardless
    of the tool), make sure that it is not doing any clever antialiasing or anything
    like that. By allowing Photoshop to use its **Resample Image** option, it will
    leave strange edges on all the tiles, where it feathers out the black separator
    lines into the tiles themselves. We just need a straight doubling of the pixels
    for this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now comes the easier part of making an HD map. Copy the `desert_map.tmx` as
    a new file, `desert_map-hd.tmx`. Add all three of these -hd files into Xcode as
    well, and edit the new TMX file. Since we have just doubled all of the tile sizes,
    we need to edit the sizes in the TMX file. In the `<map>` section, change the
    `tilewidth` and `tileheight` properties to `64`, since that is our HD tile size.
    Make the same changes to the parameters for both `<tileset>` sections. We also
    need to change the `spacing` and `margin` on the desert tileset to `2` and `2`.
    Finally, the width and height for both `<image>` sections need to be doubled from
    their former values.
  prefs: []
  type: TYPE_NORMAL
- en: As a final step, we need to change the image source values to reflect the –hd
    filenames. These should be `tmw_desert_spacing-hd.png` and `tile_markers-hd.png`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one set of values that will not be correct – the object positions.
    Since these are not tile-based, they will look a little odd if you reload the
    new –hd tilemap into Tiled. You could compensate for this in code, but our preference
    is to reload the –hd tilemap into Tiled, and manually move these around. That
    is the approach we used for this game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the tilemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've spent considerable time without really building the project, so
    now let's turn our attention to our Xcode project. The first thing we need to
    do is load the tilemap into the layer. We will need to persist the tilemap, so
    first let's look at the header to see our variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.h` (partial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here you see that we keep the tilemap, as well as individual variables for each
    layer. We also introduce a few `NSInteger` variables to store the values of several
    important numbers, as a shorthand to avoid repeatedly writing a relatively long
    bit of code. Let's look at the relevant sections of the `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m` (partial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That is all it takes to load the tilemap on a layer. You will notice we set
    the visible attributes for both the triggers and walls to `NO`. For debugging,
    you can easily set these to `YES`, and the map will look more like it does in
    Tiled, with the colored overlays on the trigger tiles. You will also notice we
    only add the `_tileMap` to self, and not the layers within the tilemap. This is
    because the TMX handling classes of cocos2d are built to assume the tilemap should
    be kept together and used together. Finally, we load the `spawns` object group
    a little differently, because object layers are stored a little differently in
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: There is a second set of initializations that we do to make it easier to write
    the code later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the "shorthand" variables that we identified in the header
    file. This allows us to write shorter lines of code when referencing any of these
    values. Because the tiles are represented in pixel sizes only, we divide them
    by the `CC_CONTENT_SCALE_FACTOR()` to ensure that we are dealing with the sizes
    in points, not pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a world to live in, we need to add our hero. We have broken
    out our hero into a separate class, but first let's look at how we figure out
    where the hero will spawn. As you may recall, we have the location **playerSpawn**
    marked on the map. Now, we need to translate that location into game coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here you see that we create an `NSMutableDictionary` from the `playerSpawn`.
    The data is stored in this way inside the TMX map, because the format does allow
    us to add other properties to the objects (in our case, we care only about the
    coordinates). We extract the x and y coordinates for the `playerSpawn` object,
    but then we alter the coordinates by dividing them by the `CC_CONTENT_SCALE_FACTOR()`.
    Why? Remember that the TMX file format produced by Tiled is not a cocos2d-specific
    format, so everything is represented as pixels. We divide the coordinates by the
    `CC_CONTENT_SCALE_FACTOR()`, which will give us the correct location in points.
    We then call the constructor for our `TDHero` class, and add the hero to the layer.
    We also store a reference to the hero in the `hero` variable. Now let's see how
    the `TDHero` is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHero.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The hero keeps a reference to the `TDPlayfieldLayer` (using a forward declaration
    to avoid an import loop), and we keep a reference to the sprite. You will notice
    that we have `TDHero` as a subclass of `CCNode`, not `CCSprite`. We do this to
    keep the class more uniform with the `TDEnemy` class we will look at later. By
    having the `CCSprite` as a variable inside a `CCNode` subclass, it makes it easier
    to use a single class with different graphics. By keeping these two classes more
    uniform, it makes it easier to remember how to code the collision and movement
    classes. Now let''s look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a convenience constructor, and the `init` method. We keep a reference
    to the parent layer, build a sprite, set its opening position, and add the sprite
    to the parent layer. Yes, we already added the hero (of `TDHero` class) to the
    parent layer. That is a "handle" on the `CCNode` that we need to keep to avoid
    having it autorelease. But that does not add the sprite to the layer, so we add
    that separately. We want our hero to be able to rotate in the direction he is
    heading, so we will add a rotation method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly standard rotation method that is often used in sample projects.
    It calculates the angle between the sprite and the target coordinate passed to
    it. The calculation results in radians, converts that to degrees, and sets the
    new rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our hero also needs to be able to shoot. Let''s take a look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHero.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that we will also have a `TDBullet` class as a factory for new bullets.
    We will take a closer look at bullets later in the chapter. For now, you see that
    we set the bullet to be at the same position and rotation as the hero, and we
    set an `isEnemy` flag, so we can make friendly-fire impossible. We send the bullet
    to the parent layer to be added, and we play a sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Focus on the hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we were to go forward with the code thus far, we have a slight problem.
    The hero is nowhere on the screen, as we see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Focus on the hero](img/9007_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We need a way to focus the view on the hero, but at the same time we need to
    make sure that we never see any area outside the map. Ray Wenderlich posted a
    wonderfully compact method of doing this in one of his tutorials at [http://www.raywenderlich.com](http://www.raywenderlich.com).
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first `x` and `y` assignments get the `MAX` value of either middle of the
    screen, or the passed position. Then it takes that result and selects the `MIN`
    of that value or the right edge of the map minus half a screen. This paired calculation
    will give you the coordinates of the hero, unless he is near the edge of the screen,
    in which case it will give the coordinates of a point that is exactly half a screen
    away from the nearest edge. We then subtract the center of the screen size from
    the actual position on the map, and we end up with a screen coordinate perfect
    for the layer's position. You will notice that this actually works by repositioning
    the layer itself. Here we use it only for following the hero, but if you wanted
    to call the player's attention to some other feature of the map (show them the
    goal, for example) you can use this same method by passing it a different coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the hero with SneakyJoystick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need a way to control our hero. For our game, we will be using two different
    control methods, joystick and tilt. We will look at the joystick control first.
  prefs: []
  type: TYPE_NORMAL
- en: Our joystick control will use the `SneakyJoystick` class, available at [https://github.com/sneakyness/SneakyInput](https://github.com/sneakyness/SneakyInput).
    `SneakyInput`/`SneakyJoystick`. This is probably the most commonly used joystick
    class in the cocos2d community. It has a lot of features (such as skinning the
    joystick with better graphics), which we will not be using in this project, but
    which are definitely worth exploring in the projects you will create.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new layer to handle the controls, `TDControlLayer`. In some projects,
    it doesn't make a big difference how you organize your objects on layers. When
    you are using a scrolling tilemap, however, separation of your layers is essential.
    If you don't put your controls on a separate layer, as soon as you scroll the
    tilemap, the controls will scroll off-screen. By keeping them as a separate layer
    (that is *not* a child of the tilemap's layer), the controls will be fixed in
    the screen positioning you want, regardless of any map scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Most of this method is concerned with the building of the images used for the
    sprite. We are using a simple example with colored circles to represent the base
    of the joystick and the thumb. (The "thumb" is the movable part of the joystick,
    adopting the term from scrollbar controls). We build the joystick, and add it
    to the layer.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a fire button in our game, so we will use the `SneakyButton` class
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The setup of the `SneakyButton` is very similar to the `SneakyJoystick`, except
    instead of the base and thumb images, we set up the alternate images for the button
    press.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built the controls, let's see how to use them. We schedule
    an `update` method on this layer, and the `update` handles parsing the controls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is all of the `update` method, except for the tilt control section, which
    we will get to in a few moments. We handle a couple of standard cases first (`preventTouches`
    and `isGameOver`), and then we check the joystick. If the `stickPosition` is equal
    to `CGPointZero`, it means the stick is centered, so we don't actually have any
    movement requested. If they are not equal, then we need to send the message to
    the hero to move. We do this by sending a call to the playfield layer (`pf` is
    a reference to it), and pass some parameters to it. (The method call is a fairly
    standard one when using `SneakyJoystick`. That is why the terminology in the method
    call is a little different from the other code.) We then check to see if the button
    has its `active` property set. If it does, then we need to shoot. We again pass
    that call to the playfield layer to set a Boolean variable, `heroShooting`. This
    class does not have any direct connections to the `TDHero` class. The call routing
    is done by way of the playfield layer, which acts as liaison between the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tilt controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The addition of tilt controls to our game is almost trivial. Since the tilt
    control will only be replacing the joystick, we will still need the button to
    be used, so it makes sense for these two control methods to be housed in the same
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With these two simple methods, we have most of the code we need to make the
    tilt controls functional. In the `addTiltControl` method, we turn on the accelerometer
    and set its delegate to this class. That delegate uses a callback, which is the
    second method listed in the preceding code. At the frequency specified, the `accelerometer:didAccelerate:`
    method will be called. On each call, we store a modified version of the acceleration
    values in our `accelX` and `accelY` variables. Because our game is in landscape
    and the accelerometer reports only in portrait-based values, we reverse the `x`
    and `y` values. We multiply them by `7` to provide a larger change value. Testing
    found `7` to be a good multiplier value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a small bit of code to add into our update method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m` (`update` method, under `Tilt Code here`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we could have easily taken the same approach as with the joystick and passed
    everything to the playfield layer, but we wanted to show an alternate approach
    with this control. There is no difference in the performance of having the code
    here or in the playfield layer (as all called methods are in `pf` anyway). The
    code itself calculates a new position for the hero by adding the `accelX` and
    `accelY` values to the coordinates. It then calls to rotate the hero, and then
    move the hero.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up the control section, let's look at the constructor and the `init`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDControlLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be creating the control layer with two parameters: the playfield layer,
    and a Boolean value to indicate if we want tilt controls or not. Based on the
    `isTilt` value, we either create the joystick or we start with tilt. That''s all
    it takes to implement both control mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we turn our attention to the `TDPlayfieldLayer` class to see how we fully
    interpret the control methods that were called in the control layer. We''ll start
    with the joystick control:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a `scaledVelocity` variable, which is the data from the
    joystick times `200`, to give a larger value than the joystick's reading. We then
    apply this to the hero's position. You will notice we multiply the `scaledVelocity`
    by the delta time. We do this to allow for variable update time, so the movement
    is not jerky, if there is any lag. We then tell the hero to rotate toward the
    new position, and set the hero's position to the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at an abbreviated version of the `setHeroPos` method. We will
    revisit this later to add some more logic to it. For now, it is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For now, the `setHeroPos` method simply sets the hero's position and then centers
    the view on the hero. Nothing fancy, but it gets the job done. At this point,
    we have used a couple of small pass-through methods that we should mention.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, we want the playfield to be the central point of contact,
    so these two methods provide easy data pass-throughs that can be called from other
    classes. Both of these classes were used in the control layer, but they really
    do nothing special except reduce the number of classes that are directly connected
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Building the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a third layer that we need to build, the heads-up display (HUD) layer.
    This is a mostly trivial layer to implement, but it must be its own layer, for
    the same reasons we discussed with the controls. If this were on the main layer,
    the HUD would scroll off-screen whenever we moved away from the first view.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHUDLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By now this should be simple code to read. We create three labels that are
    the fixed names of the stats presented: kills, health, and goals. We then create
    three counter labels for the corresponding values. This handles the initial construction
    of the layer, but we need to be able to update the values easily, so we create
    three helper methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHUDLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now we have three methods that allow us to easily change the values of the counter
    labels as needed. As you probably figured out, we will be calling these directly
    from the playfield layer. There is nothing fancy here, just code that works. You
    could always embellish this by adding some animation when the values change, or
    some other graphic flair. Since this code is self contained in its own layer,
    you can expand this without any changes to the playfield layer.
  prefs: []
  type: TYPE_NORMAL
- en: Scene construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have three layers for our game, and some layers need to know about the
    others. Nothing can be a child of the playfield layer, due to the scrolling issue.
    This is exactly the type of situation that causes us to prefer the separation
    of scene and layer files, unlike the common template format (a scene method embedded
    in the `CCLayer` class). If we were to do that, in which class would you include
    the scene method, since there is really not one parent layer? (Some would argue
    that the HUD should be the master layer, with others as children of it. Technically,
    that works too. We're not fans of that structure, however). Our solution is in
    the construction of the `TDPlayfieldScene` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldScene.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to build all three layers in the correct order, with all being
    children of the scene. This way, none of the layers are children of each other.
    The playfield layer can be initialized with a reference to the HUD layer, and
    the controls can be initialized with a reference to the playfield layer. Everything
    works, and it is easily readable. This construction also makes it trivial to determine
    the hierarchy of the scenes and layers. The following screenshot shows what our
    game looks like with all layers included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene construction](img/9007_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tile helper methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the challenges in using tile maps is that we have at least two different
    coordinate positions that can be used to refer to a position on the map: pixels
    on the tilemap, and the tile coordinates. The tile coordinates relate to each
    individual tile, so the top left tile is (0,0) and the bottom right is (49,49)
    for our 50 by 50 map. What we need are some helper methods to easily convert between
    the two.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are finally making use of the shorthand variables we saw in the `init`
    method. As a refresher, the variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tmw` = tilemap width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmh` = tilemap height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tw` = tile width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th` = tile height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So the `x` value is the position divided by the tile width. For the `y` value,
    the calculation is a little longer, because the origin point of the tile map is
    top left instead of bottom left. By multiplying the tilemap height times the tile
    height we have the total map height. From that we subtract the position, and then
    divide the result by the tile height. This gives us the reversed `y` positioning
    that we need. The final `CGPoint` from this method is the tile coordinate for
    the given position.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method reverses the same calculation that we just saw. One callout on this
    method is the last bit of each formula. The "core" of the formulas will result
    in the edge of the tile being converted. By adding half the tile width (or subtracting
    half of the tile height), the end result is the center of the tile, which is what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Tile self-identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some methods to perform what we refer to as self-identification. This
    is where we can "ask" each tile about any special properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first of these methods is the `isValidTileCoord` method, so we can check
    to see if a tile coordinate being passed is even on the map. A simple check on
    the lower bounds (zero) and the upper bounds (tilemap width, tilemap height) will
    allow us to return a Boolean value to identify if this is a valid tile.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `isValidTileCoord:` method to determine if the tile is
    valid. If it is not, then we can treat it as though it is a wall and return `YES`.
    Otherwise, we get the tile's GID for the specified tile coordinate in the walls
    layer. ( **GID** is a **Global Identifier** used by the tilemap.) We then poll
    the tilemap to get any properties related to that tile. We return the value for
    the key `Blocked`. If you recall when we built the map in Tiled, we gave the red
    tile a property of `Blocked`, with a value of `Yes`. Here is where we get the
    benefit of that tilemap. With this simple check, we can "ask" the map if there
    is a wall, and get a definitive answer. How easy is that?
  prefs: []
  type: TYPE_NORMAL
- en: We follow the same basic logic to identify both goal markers and health powerups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is virtually identical between these methods. If you
    were so inclined, you could extrapolate a base method that could do both, but
    we prefer explicit method calls in this case, mostly because we only have two
    types of triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Smarter hero walking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the code that we have covered so far, our hero will walk around without
    any awareness of the special tiles that we have placed, so he will walk right
    through walls. We need to fix this. Now that we have added methods to make it
    fairly simple to determine where our special triggers are, we can revisit the
    `setHeroPos` method, which we started earlier. This is a complete replacement
    of the earlier method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We begin the method by converting the new hero position to a tile coordinate.
    We then check to see if this is actually a wall. If the desired coordinate is
    a blocked tile, then the method will return without moving the hero. This will
    effectively prevent the hero from walking on any of the blocked tiles. We then
    check for health powerups or goal markers, using our helper methods. If we have
    picked up a goal or health, we remove the corresponding tile from both the `_triggers`
    and the `_pickups` layers. Removing it from the `_pickups` layer will take away
    the visible tile, and removing it from the `_triggers` layer will prevent us from
    triggering the same event the next time the player passes over this tile. In both
    cases, we call out to the appropriate handling method to take action on the item
    that was picked up. After this new code, we see the same hero positioning and
    viewpoint centering code we saw earlier. Let's look at the item pickup handler
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We decided that the hero should have a 40 point boost to his health when he
    picks up one of the odd cactus things. We update the `heroHealth` variable, and
    update the HUD by calling out to the `hudLayer` for the `changeHealthTo`: method
    we saw earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For the goal, we adjust the `heroGoalsRemaining` variable and change the HUD
    in a similar fashion. However, since the goals are the point of the game, we check
    to see if all the goals have been reached (picked up). If so, we set the `isGameOver`
    and `preventTouches` to `YES`, which will end the game when the next `update`
    loop runs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All this running around and hitting walls is fine and good, but we need to be
    able to shoot, don't we? As you may recall from our discussion of the `TDControlLayer`
    class, you will recall that when the button is pressed we simply set the Boolean
    variable `heroShooting` to `YES`. We handle this value in the `TDPlayfieldLayer`
    update method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have left a few blanks here to fill in later, but this is the structure of
    the entire `update` method. When the `heroShooting` variable is `YES`, we evaluate
    the `currHeroShootSpeed` variable. If it is greater than zero, we subtract the
    delta time from it. If it has reached zero, we call the hero's `shoot` method.
    We then reset the `currHeroShootSpeed` to the value of the `shootSpeed` variable.
    This is set in the `init` method, and is set to a value of `0.2` to avoid ridiculous
    machine-gunning of bullets. This means you can only shoot a maximum of once every
    0.2 seconds. That's still fast enough, isn't it? If the hero is not shooting (that
    is, not pressing the shoot button), then we reset the `currHeroShootSpeed` variable
    to `0`. This allows the hero to shoot immediately when they press the button without
    having this "cooldown" timer delaying their shot.
  prefs: []
  type: TYPE_NORMAL
- en: TDBullet class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to shoot, we need to know what we're shooting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDBullet.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the convenience method `bulletFactoryForLayer` to build the bullet.
    Because the `TDBullet` is a `CCSprite` subclass, we can use a call to `super initWithSpriteFrameName`
    to build the sprite. We keep a reference to the parent layer, and we set the `totalMoveDist`
    variable to be our limit of how far the bullet can travel before it expires. The
    variable `thisMoveDist` is used to determine how far on each update the bullet
    should travel. Most of the work of this class is done in the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDBullet.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We begin this method by checking to make sure this bullet is not dead. It is
    possible to call `update` on a bullet in the process of being discarded, so this
    will prevent us from trying to move an object as it is being dereferenced. We
    then go through a bit of code that takes the current rotation and calculates a
    target in that direction that is `thisMoveDist` away from the current position.
    We subtract this from the `totalMoveDist` value, so we can keep track of how far
    the bullet has left to move. If the `totalMoveDist` variable reaches zero, then
    we call to the `parentLayer` object to remove the bullet. If it is not zero, we
    convert the bullet's current position to a tile coordinate using the method in
    the `parentLayer`. We then check to see if the tile is a wall. If it is, the bullet
    is removed, because we do not want the bullets to go through the walls.
  prefs: []
  type: TYPE_NORMAL
- en: We also have two bullet-handling methods in the playfield layer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you recall from our review of the `TDHero` class, when the `shoot` method
    is called, it builds a bullet and then passes that bullet to the `addBullet` method
    of the layer stored in the `parentLayer` variable. Here you can see what that
    does. It adds it to the layer, and then adds the bullet to the `bulletArray` array.
    When we need to remove a bullet, we first set the bullet's `isDead` property to
    `YES`, and then remove the bullet from the array and the layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final bit of the bullet movement code that we need is in the `update` method
    of the `TDPlayfieldLayer`. We need to add a couple of lines there:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Move The Bullets`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is nicely compact code, just as we like it. Here we iterate through all
    the bullets in the `bulletArray`, and call each one's `update` method, with the
    current delta. We iterate using a traditional `for` loop instead of fast enumeration
    (that is `for (TDBullet *aBullet in bulletArray)`) because we may be calling for
    some bullets to die in this loop. Mutating the array while using fast enumeration
    will cause a crash. Don't believe us? Try it and you'll see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Building the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have a world to run around in and bullets to shoot, but nobody to stop
    us from reaching our goals. We need to add some enemies to spice it up. As we
    go through the enemy handling code, keep in mind how we set up the hero. You will
    see a lot of similarities, and we could have compressed them into a single base
    class, but opted not to do so for clarity's sake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the constructors for the `TDEnemy` class. We keep a reference to
    the `parentLayer`, set the `maxShootSpeed` variable, and we call out to the `buildEnemySpriteAtPos`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Why did we break this method out separately, instead of embedding these two
    lines in the `init` method? We did this to make subclassing of the `TDEnemy` class
    easier. Because we have kept this separate, we can override this method without
    needing to override the `init` method in any subclasses of the `TDEnemy`. This
    allows us to not repeat the boilerplate `init` method for both enemy classes,
    when the only difference is the sprite used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This rotation method works the same way that the rotation method in the hero
    class operates. It determines the angle toward the specified target, and rotates
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using some basic movement code. The enemy will determine the most
    direct path toward the hero, and try to move there. Just as we did with the hero
    and bullets, the enemies are unable to pass through walls. We don't have any special
    handling for the enemy to do something different when they hit a wall, so they
    will continue to try to move into a wall for as long as it is between the hero
    and the enemy. Not too smart, but this is supposed to be your basic enemy grunt.
    Not too bright.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method is virtually identical to the hero's `shoot` method, with two exceptions.
    The first is that we set the `isEnemy` variable to `YES`, to identify that this
    is a bullet fired by an enemy unit. The second is that we set the bullet's color
    to red. The sprite we are using is blue, so this gives the enemy a "bad guys shoot
    red" effect. Everything else in this method is identical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDEnemy.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the enemy's `update` method, we move toward the hero's position on each update.
    We also check to see if the distance from the enemy to the hero is less than `250`
    points. If it is, then the enemy will try to shoot. Since he is already rotated
    toward the hero, he will always shoot directly at the hero.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the bullets, we need to make a small addition to the main layer's
    `update` method to make the enemies move.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Move The Enemies`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is virtually identical to the movement code for the bullets. For each update,
    we instruct each enemy to move himself.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know how the enemy class is constructed, and how to make them move, so
    next we need to add them to the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you recall when we built the tilemap, we designated objects on the map named
    `EnemySpawn1`, `EnemySpawn2`, and so on. Now we can finally use those spawn points.
    We don't like the idea of enemies always spawning at the same spot, so we randomly
    pick a number between `1` and `11` using `arc4random()`. We use this to build
    a string that corresponds to an object name on our `spawns` layer of the tilemap.
    We can't use these values directly, because of the points versus pixels issue,
    so we divide the `x` and `y` coordinates by the `CC_CONTENT_SCALE_FACTOR()` to
    get the correct positioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you see we have defined two types of enemy: `kEnemyEasy` and `kEnemyHard`.
    We use the same basic constructor for both, but the hard enemy will use the `TDEnemySmart`
    class instead (we''ll get to that later).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to be able to build enemies of both types in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We simply step through two `for` loops to add the specified number of enemies
    for each type. The numbers are arbitrarily chosen, and you can adjust them as
    you see fit to provide a hard enough challenge for you.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have everything we need, except for a way to make bullets hit
    the hero and enemies. What fun is shooting if you can't hit anything?
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, all the bullets in the game are stored in a single array, `bulletArray`.
    We iterate through that array and first check to see if a bullet hit the hero.
    We use `CGRectIntersectsRect` to see if there is any overlap of the `boundingBox`
    objects of the bullet and the hero. We also check the bullet's `isEnemy` property
    to make sure it is an enemy bullet. (Remember, we don't want any friendly-fire!)
    If the bullet is touching the hero and an enemy fired it, we register the collision.
    We call the `heroGetsHit` method, add the bullet to the `bulletsToDelete` array,
    and remove the bullet from the layer. Why didn't we use the `removeBullet` method
    that we saw earlier? We can't use that because we would be removing the bullet
    from the array while iterating through it, which would cause a mutation (leading
    to a crash). Because we need to remove the bullets after the iteration is done,
    we use the `bulletsToDelete` array instead.
  prefs: []
  type: TYPE_NORMAL
- en: If the hero was not hit by a bullet, we then iterate through all enemies in
    the `enemyArray`. We do a similar check of each `boundingBox` and make sure it
    is not an enemy-fired bullet. If the enemy is hit, we call the `enemyGetsHit`
    method, and pass it a reference to the enemy that was hit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we remove all bullets from the `bulletsToDelete` array (when the other
    loops are done) so we can remove them safely.
  prefs: []
  type: TYPE_NORMAL
- en: We trigger the collision check in the update method, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Check collisions`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We check for collisions at the end of every update, so we can always be using
    the current state of the game field.
  prefs: []
  type: TYPE_NORMAL
- en: Everybody gets hit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will look at the methods that were called when the hero or an enemy
    gets hit by a bullet. First, we will look at the hero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our hero is pretty tough, so a single bullet isn't enough to kill him. Instead,
    we subtract `20` from his health and update the HUD. If his health has reached
    zero, he is dead. We set the `isGameOver` variable to `YES` so it will be handled
    at the end of the update loop. This is why collisions are handled after the movement,
    and game over is checked for after the collision handler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When an enemy gets hit, they die immediately. We could have given them a health
    level like the hero, but who wants really strong enemies? We remove the enemy
    from the layer and remove it from the `enemyArray`. Because we want to track our
    hero's kill count, we increment his kills and call to the `hudLayer` to update
    the display. We then play a death sound, and spawn a new enemy. As it is written,
    we will only spawn easy enemies when any enemy dies. This could be modified, if
    you prefer to do something like randomly picking a new enemy type. We decided
    that the hard enemies were the commanders, and you can't as easily replace a commander
    as a grunt.
  prefs: []
  type: TYPE_NORMAL
- en: Game over, man
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen where we set game over conditions, so let's look at the actual
    game over method. It's pretty basic, but it serves its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do at game over is to unschedule the update so the enemies
    stop moving. As you may recall, when we have been setting the `isGameOver` variable,
    we have also been setting `preventTouches` to `YES`. That flag will stop any input
    from being accepted (as we saw in the `update` method of the `TDControlLayer`
    class), so here we just need to stop everything else from moving. If the hero
    is out of health, he died. Otherwise, they must have won, since the only two ways
    for the game to end are dying or collecting all of the goals. We call out the
    `hudLayer` to the `showGameOver` method, and then we set up a `3.0` second delay
    before the `preventTouches` is reset to `NO`. Once `preventTouches` is reset to
    `NO` from within the `CCCallBlock` action, then the `TDControlLayer` will accept
    the next touch to send the player back to the menu.
  prefs: []
  type: TYPE_NORMAL
- en: You might be asking why we put the game over message in the `hudLayer` class.
    This is for convenience, since we really don't want to display user messages on
    the same layer as the tilemap. We could have created another layer for just the
    game over message, but that seemed like extra code that wasn't really needed.
    So we put it in the `hudLayer` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `TDHUDLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We display the message that was passed as the contents of a label, which we
    center on the screen. Obviously, this is pretty simple and barebones, but it serves
    its purpose. Feel free to dress it up and make it more sensational, if you so
    desire. For now, this is what you see when you die:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game over, man](img/9007_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Smarter enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a fully functional game at this point, except for fleshing out the smarter
    enemies. After quite a bit of experimentation, we have found several things that
    don't work to improve the enemies, and a couple of things we can do to make them
    better. We tried using an enemy that used `A* Pathfinding`, which is considered
    the "gold standard" of pathfinding algorithms. However, this was not a great answer
    for the enemies, as they would stop and pause to recalculate a new route, which
    would often take a second or two, depending on how far away from the hero they
    were. If you had a couple of these enemies in the game at the same time, the entire
    system would freeze for a second or two. Not good.
  prefs: []
  type: TYPE_NORMAL
- en: After trying some different approaches (and different `A*` implementations),
    we have settled on a hybrid enemy pathfinding. Most of the time it works like
    a standard enemy. The difference is when it hits a wall, it changes to use `A*
    Pathfinding` to negotiate a route to the hero around the wall. As soon as it reaches
    that destination, it reverts to the standard movement code.
  prefs: []
  type: TYPE_NORMAL
- en: Code not covered here
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have decided that, far from being experts at `A* Pathfinding`, we will be
    using the `A*` code written by Johann Fradj, and published in a tutorial at [http://www.raywenderlich.com](http://www.raywenderlich.com).
    We have included it in this project with the permission of both Johann Fradj and
    Ray Wenderlich. (Thanks to you both!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of covering this code method by method, I will instead refer you to
    his tutorial, from which this code was taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial](http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: He explains it better than we can, and it is a very good explanation. Instead
    of quoting his code in detail here, we will instead explain our modifications
    to his code, and our rationale for doing so. (We might miss some minor modifications,
    but we'll try to cover the major ones.)
  prefs: []
  type: TYPE_NORMAL
- en: The first major modification we made is to rename the class `ShortestPathStep`
    to `AStarNode`. This is because it is a shorter name, and it was originally being
    overlaid on an earlier code base. Really, it was mostly because we wanted a shorter
    name that felt like a better description to us.
  prefs: []
  type: TYPE_NORMAL
- en: Our entrance to the `A*` code is in the `moveTowardWithPathfinding` method in
    the `TDEnemySmart` class. We perform our `rotateToTarget` at the beginning of
    this class, so we are always pointed in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: The other major change we made to the code is to insert the Boolean variable
    `isUsingPathfinding` to control when the `A*` code would recursively call itself.
    Because we wanted to revert to simple pathfinding after an obstacle was passed,
    we turn off the `isUsingPathfinding` in each of the `if` statements in the `popStepAndAnimate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We urge you to read Johann's wonderful tutorial (as well as a related *Introduction
    To A* Pathfinding* that is linked to from that tutorial) to learn more about how
    `A* Pathfinding` works, as well as consulting the source code bundle for this
    chapter to see how our `TDEnemySmart` class is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of material that is familiar yet new here. We have leveraged
    quite a few community resources for this project. We built our tile map with Tiled.
    We used SneakyJoystick rather than build our own joystick and button classes.
    We have dipped our toe in the `A*` waters with the help of Johann Fradj. We kept
    our layers separated into functional units so we could keep our code cleaner and
    more performant. Not to mention we had the opportunity to ponder why an orange
    would be the mortal enemy of lettuce.
  prefs: []
  type: TYPE_NORMAL
- en: This game is very basic on purpose. Once you master the concepts we covered
    here, it is easy to leverage this project to power a much bigger (and more sensible,
    perhaps) game. One of the great things about creating a game with tilemaps is
    that there is a lot of directly reusable code from game to game. For instance,
    the `isValidTile`, `isWall`, and so on methods are easily adaptable to any tilemap-based
    project. Reusability of code is key to writing code faster.
  prefs: []
  type: TYPE_NORMAL
- en: As we have probably made clear, we are big fans of open source tools and projects,
    both to use for our own development, but also to learn from those with much more
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to take a deep breath before we take on the final project of this
    book: An endless runner.'
  prefs: []
  type: TYPE_NORMAL
