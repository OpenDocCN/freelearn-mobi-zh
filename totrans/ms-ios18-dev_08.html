<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor274"/><st c="0">8</st></h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor275"/><st c="2">Connecting and Fetching Data from the Network</st></h1>
			<p><st c="47">Finding an app that isn’t connected to a server is extremely difficult. </st><st c="120">Most apps don’t operate alone—they need to authenticate their users, fetch information, and allow their users to perform actions that eventually will be synced back to </st><span class="No-Break"><st c="288">the server.</st></span></p>
			<p><st c="299">Due to this, it is important to understand how networking works—not how HTTP works in general, but how iOS apps work with the server efficiently </st><span class="No-Break"><st c="445">and simply.</st></span></p>
			<p><st c="456">In this chapter, we will cover the </st><span class="No-Break"><st c="492">following topics:</st></span></p>
			<ul>
				<li><st c="509">Understanding </st><span class="No-Break"><st c="524">mobile networking</st></span></li>
				<li><st c="541">Handling HTTP requests, including </st><span class="No-Break"><st c="576">their responses</st></span></li>
				<li><st c="591">Integrating network calls within </st><span class="No-Break"><st c="625">app flows</st></span></li>
				<li><st c="634">Exploring how Combine works </st><span class="No-Break"><st c="663">with networking</st></span></li>
			</ul>
			<p><st c="678">Let’s start understanding how the network fits into our </st><span class="No-Break"><st c="735">app architecture.</st></span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor276"/><st c="752">Technical requirements</st></h1>
			<p><st c="775">For this chapter, you must download Xcode version 15.0 or above from Apple’s App Store. </st><st c="864">Search for Xcode in the App Store and select and download the latest version. </st><st c="942">Launch Xcode and follow any additional installation instructions that your system may prompt you with. </st><st c="1045">Once Xcode has fully launched, you’re ready </st><span class="No-Break"><st c="1089">to go.</st></span></p>
			<p><st c="1095">You’ll need to run the latest version of macOS (Ventura </st><span class="No-Break"><st c="1152">or above).</st></span></p>
			<p><st c="1162">You can also download the sample code from the following GitHub </st><span class="No-Break"><st c="1227">link: </st></span><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%208"><span class="No-Break"><st c="1233">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%208</st></span></a></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor277"/><st c="1318">Understanding mobile networking</st></h1>
			<p><st c="1350">Working with the network</st><a id="_idIndexMarker397"/><st c="1375"> is a crucial part of developing apps for iOS. </st><st c="1422">Understanding how the network fits into our app architecture is essential, but what does it mean? </st><st c="1520">Watching simple tutorials about performing a </st><strong class="source-inline"><st c="1565">URLSession</st></strong><st c="1575"> request is fine, but real-world apps don’t work </st><span class="No-Break"><st c="1624">that way.</st></span></p>
			<p><st c="1633">Before we dive any deeper, let’s recap what a basic app architecture </st><span class="No-Break"><st c="1703">looks like:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1714">UI layer</st></strong><st c="1723">: This is responsible for presenting</st><a id="_idIndexMarker398"/><st c="1760"> UI to the user, including responding to user inputs. </st><st c="1814">The UI layer consists of the SwiftUI/UIKit views and </st><span class="No-Break"><st c="1867">view models.</st></span></li>
				<li><strong class="bold"><st c="1879">Business logic</st></strong><st c="1894">: This is responsible for manipulating data</st><a id="_idIndexMarker399"/><st c="1938"> while managing the basic </st><span class="No-Break"><st c="1964">application logic.</st></span></li>
				<li><strong class="bold"><st c="1982">Data layer</st></strong><st c="1993">: This is responsible for storing</st><a id="_idIndexMarker400"/><st c="2027"> and retrieving data entities related to the </st><span class="No-Break"><st c="2072">business logic.</st></span></li>
			</ul>
			<p><st c="2087">I guess I’m not surprising you here with this three-layer architecture, as most mobile apps work in a </st><span class="No-Break"><st c="2190">similar architecture.</st></span></p>
			<p><st c="2211">When we begin to understand where the network job fits, we will have to look at the data layer and, in some specific cases, the business logic layer (for example, when working with analytics or third-party libraries). </st><st c="2430">However, why do we need to look at the layers? </st><st c="2477">To understand why our network activity is relevant for the data layer, let’s go over our main </st><span class="No-Break"><st c="2571">network goals:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="2585">Syncing information</st></strong><st c="2605"> to and from </st><span class="No-Break"><st c="2618">our backend</st></span></li>
				<li><span class="No-Break"><st c="2629">Handling </st></span><span class="No-Break"><strong class="bold"><st c="2639">authentication</st></strong></span></li>
				<li><st c="2653">Logical activity that requires </st><span class="No-Break"><st c="2685">a server</st></span></li>
			</ul>
			<p><st c="2693">In most apps, networking is needed to sync data with our backend. </st><st c="2760">The data layer functions as the primary repository of truth for entities. </st><st c="2834">Attempting to access entities directly from the network in other layers will undermine </st><span class="No-Break"><st c="2921">this principle.</st></span></p>
			<p><span class="No-Break"><em class="italic"><st c="2936">Figure 8</st></em></span><em class="italic"><st c="2945">.1</st></em><st c="2947"> shows a basic app architecture and the </st><span class="No-Break"><st c="2987">network location:</st></span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B21795_08_1.jpg" alt="Figure 8.1: Basic app architecture"/><st c="3004"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3053">Figure 8.1: Basic app architecture</st></p>
			<p><st c="3087">In </st><span class="No-Break"><em class="italic"><st c="3091">Figure 8</st></em></span><em class="italic"><st c="3099">.1</st></em><st c="3101">, we can see that the network</st><a id="_idIndexMarker401"/><st c="3130"> is one of the components that build up the data layer. </st><st c="3186">The basic idea of most apps is for the network to become a data source and fill the app’s </st><span class="No-Break"><st c="3276">data store.</st></span></p>
			<p><st c="3287">For example, in a music app, the network layer might reach out to the backend, fetch albums and songs, and store</st><a id="_idIndexMarker402"/><st c="3400"> them in local storage such as </st><strong class="bold"><st c="3431">Core Data</st></strong><st c="3440">. The network layer is also built upon different components to </st><span class="No-Break"><st c="3503">function correctly.</st></span></p>
			<p><st c="3522">We can think of network operations as a factory production line. </st><st c="3588">We request a piece of information and take care of the returned data package, transferring it through several stages until we properly store it in our local store or </st><span class="No-Break"><st c="3754">present it.</st></span></p>
			<p><st c="3765">Before we review the stages a data package can undergo, let’s try to build a network request together. </st><st c="3869">We’ll start by reviewing the basic HTTP </st><span class="No-Break"><st c="3909">request methods.</st></span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor278"/><st c="3925">Handling an HTTP request</st></h1>
			<p><st c="3950">An HTTP request is a message</st><a id="_idIndexMarker403"/><st c="3979"> the client sends to a server to request information and perform an action. </st><st c="4055">The server processes that request and returns a response to the client. </st><st c="4127">Clients indeed perform HTTP requests asynchronously to leave the main thread free. </st><st c="4210">However, the connection between the client and server is </st><strong class="bold"><st c="4267">synchronous</st></strong><st c="4278"> as the client waits for the server’s response to complete the </st><span class="No-Break"><st c="4341">request operation.</st></span></p>
			<p><st c="4359">The primary HTTP request component is the request method, which indicates the request’s main goal. </st><st c="4459">Let’s go over some of the basic HTTP </st><span class="No-Break"><st c="4496">methods now.</st></span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor279"/><st c="4508">Basic HTTP request methods</st></h2>
			<p><st c="4535">The REST API is based</st><a id="_idIndexMarker404"/><st c="4557"> on the idea of a request-response style, and it’s a one-directional communication with our backend. </st><st c="4658">The REST API has eight methods to use when communicating with the backend. </st><st c="4733">However, in most cases, we will use the following </st><span class="No-Break"><st c="4783">four methods:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="4796">GET</st></strong><st c="4800">: This is used to retrieve information</st><a id="_idIndexMarker405"/><st c="4839"> only from the server. </st><st c="4862">It should be a safe call, meaning that performing a </st><strong class="source-inline"><st c="4914">GET</st></strong><st c="4917"> request shouldn’t affect the </st><span class="No-Break"><st c="4947">backend data.</st></span></li>
				<li><strong class="source-inline"><st c="4960">POST</st></strong><st c="4965">: The </st><strong class="source-inline"><st c="4972">POST</st></strong><st c="4976"> method is often used to submit</st><a id="_idIndexMarker406"/><st c="5007"> data to the backend. </st><st c="5029">In many cases, the </st><strong class="source-inline"><st c="5048">POST</st></strong><st c="5052"> method performs changes in the backend data store or changes a </st><span class="No-Break"><st c="5116">user state.</st></span></li>
				<li><strong class="source-inline"><st c="5127">PUT</st></strong><st c="5131">: We use </st><strong class="source-inline"><st c="5141">PUT</st></strong><st c="5144"> to create or update</st><a id="_idIndexMarker407"/><st c="5164"> objects. </st><st c="5174">Unlike the </st><strong class="source-inline"><st c="5185">POST</st></strong><st c="5189"> method, </st><strong class="source-inline"><st c="5198">PUT</st></strong><st c="5201"> is considered idempotent. </st><st c="5228">We can send multiple identical </st><strong class="source-inline"><st c="5259">PUT</st></strong><st c="5262"> requests and expect the same effect as sending </st><span class="No-Break"><st c="5310">one request.</st></span></li>
				<li><strong class="source-inline"><st c="5322">DELETE</st></strong><st c="5329">: As the name states, we use </st><strong class="source-inline"><st c="5359">DELETE</st></strong><st c="5365"> to delete</st><a id="_idIndexMarker408"/><st c="5375"> objects. </st><st c="5385">Obviously, we can use </st><strong class="source-inline"><st c="5407">POST</st></strong><st c="5411"> to do that, but with </st><strong class="source-inline"><st c="5433">DELETE</st></strong><st c="5439">, we are aligned with </st><span class="No-Break"><st c="5461">the standards.</st></span></li>
			</ul>
			<p><st c="5475">It is worth mentioning that, technically, we can even use </st><strong class="source-inline"><st c="5534">GET</st></strong><st c="5537"> to make changes to the server. </st><st c="5569">However, the proper method ensures predictability and reliability and is aligned with the </st><span class="No-Break"><st c="5659">REST principles.</st></span></p>
			<p><st c="5675">To perform a basic HTTP request, we should first be familiar with the </st><span class="No-Break"><strong class="source-inline"><st c="5746">URLSession</st></strong></span><span class="No-Break"><st c="5756"> class.</st></span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor280"/><st c="5763">Working with URLSession</st></h2>
			<p><st c="5787">We can use a class</st><a id="_idIndexMarker409"/><st c="5806"> called </st><strong class="source-inline"><st c="5814">URLSession</st></strong><st c="5824"> to perform and manage</st><a id="_idIndexMarker410"/><st c="5846"> network requests. </st><strong class="source-inline"><st c="5865">URLSession</st></strong><st c="5875"> is part</st><a id="_idIndexMarker411"/><st c="5883"> of what Apple calls the </st><strong class="bold"><st c="5908">URL Loading System</st></strong><st c="5926">, which in turn</st><a id="_idIndexMarker412"/><st c="5941"> is part of the </st><span class="No-Break"><strong class="bold"><st c="5957">Foundation</st></strong></span><span class="No-Break"><st c="5967"> framework.</st></span></p>
			<p><st c="5978">The </st><strong class="source-inline"><st c="5983">URLSession</st></strong><st c="5993"> class is responsible for coordinating different URL requests in our app. </st><st c="6067">Let’s see how to perform a basic </st><strong class="source-inline"><st c="6100">GET</st></strong><st c="6103"> response </st><span class="No-Break"><st c="6113">using </st></span><span class="No-Break"><strong class="source-inline"><st c="6119">URLSession</st></strong></span><span class="No-Break"><st c="6129">:</st></span></p>
			<pre class="source-code"><st c="6131">
let urlString =
  "https://jsonplaceholder.typicode.com/posts"
if let url = URL(string: urlString) {
    var request = </st><strong class="bold"><st c="6245">URLRequest</st></strong><st c="6255">(url: url)
    request.httpMethod = "GET"
</st><strong class="bold"><st c="6294">    let session = URLSession(configuration: .default)</st></strong><st c="6343">
    let task = session.dataTask(with: request) { (data,
      response, error) in
      }
    task.resume()
}</st></pre>			<p><st c="6433">This code example creates an object called </st><strong class="source-inline"><st c="6477">URLRequest</st></strong><st c="6487"> based on a particular URL. </st><st c="6515">The </st><strong class="source-inline"><st c="6519">URLRequest</st></strong><st c="6529"> class encapsulates the information we need to perform a specific URL request. </st><st c="6608">It usually consists of the </st><span class="No-Break"><st c="6635">following information:</st></span></p>
			<ul>
				<li><st c="6657">The request </st><span class="No-Break"><st c="6670">base URL</st></span></li>
				<li><st c="6678">The request method – </st><strong class="source-inline"><st c="6700">GET</st></strong><st c="6703">, </st><strong class="source-inline"><st c="6705">POST</st></strong><st c="6709">, </st><strong class="source-inline"><st c="6711">PUT</st></strong><st c="6714">, </st><span class="No-Break"><st c="6716">or </st></span><span class="No-Break"><strong class="source-inline"><st c="6719">DELETE</st></strong></span></li>
				<li><st c="6725">The request </st><span class="No-Break"><st c="6738">HTTP headers</st></span></li>
			</ul>
			<p><st c="6750">Notice that the </st><strong class="source-inline"><st c="6767">URLRequest</st></strong><st c="6777"> structure</st><a id="_idIndexMarker413"/><st c="6787"> doesn’t perform the actual HTTP request</st><a id="_idIndexMarker414"/><st c="6827"> or contain its response information. </st><st c="6865">The </st><strong class="source-inline"><st c="6869">URLSession</st></strong><st c="6879"> class is responsible for conducting and managing the different </st><span class="No-Break"><st c="6943">HTTP requests.</st></span></p>
			<p><st c="6957">There are two ways</st><a id="_idIndexMarker415"/><st c="6976"> to initialize a </st><span class="No-Break"><strong class="source-inline"><st c="6993">URLSession</st></strong></span><span class="No-Break"><st c="7003"> instance:</st></span></p>
			<ul>
				<li><st c="7013">We can call the static </st><strong class="source-inline"><st c="7037">shared</st></strong><st c="7043"> property</st><a id="_idIndexMarker416"/><st c="7052"> and use it as a </st><strong class="bold"><st c="7069">singleton</st></strong><st c="7078">. We do that if we want to simplify our implementation without needing to customize how we handle requests or have different requirements for different areas in </st><span class="No-Break"><st c="7239">the app:</st></span><pre class="source-code"><st c="7247">
let session = URLSession.shared</st></pre></li>				<li><st c="7279">If we need more flexibility, we can create an instance of </st><strong class="source-inline"><st c="7338">URLSession</st></strong><st c="7348"> (like in the last code example) and initialize it with our </st><span class="No-Break"><st c="7408">own configuration.</st></span></li>
			</ul>
			<p><st c="7426">A configuration object allows us to fine-tune our requests better. </st><st c="7494">For example, we can define each request as containing additional headers, setting the timeout and caching, or even cookie </st><span class="No-Break"><st c="7616">acceptance policies.</st></span></p>
			<p><st c="7636">Here’s a code example for setting up a </st><strong class="source-inline"><st c="7676">URLSession</st></strong><st c="7686"> class with a specific timeout duration and </st><span class="No-Break"><st c="7730">no caching:</st></span></p>
			<pre class="source-code"><st c="7741">
    let configuration = URLSessionConfiguration.default
    configuration.timeoutIntervalForRequest = 10
    configuration.requestCachePolicy =
      .reloadIgnoringLocalCacheData
    let session = </st><strong class="bold"><st c="7918">URLSession(configuration: configuration)</st></strong></pre>			<p><st c="7958">In this code example, we created a configuration object, set its </st><strong class="source-inline"><st c="8024">timeoutIntervalForRequest</st></strong><st c="8049"> value to </st><strong class="source-inline"><st c="8059">10</st></strong><st c="8061">, and defined the cache policy to </st><span class="No-Break"><st c="8095">be ignored.</st></span></p>
			<p><st c="8106">When we work</st><a id="_idIndexMarker417"/><st c="8119"> with a shared </st><strong class="source-inline"><st c="8134">URLSession</st></strong><st c="8144"> object, there’s no way to customize</st><a id="_idIndexMarker418"/><st c="8180"> its configuration, and it will use the </st><span class="No-Break"><st c="8220">default one.</st></span></p>
			<p><st c="8232">Now that we know how to perform a basic </st><strong class="source-inline"><st c="8273">GET</st></strong><st c="8276"> or </st><strong class="source-inline"><st c="8280">POST</st></strong><st c="8284"> request, let’s see what we can do with </st><span class="No-Break"><st c="8324">the response.</st></span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor281"/><st c="8337">Handling the response</st></h2>
			<p><st c="8359">The request response</st><a id="_idIndexMarker419"/><st c="8380"> is handled</st><a id="_idIndexMarker420"/><st c="8391"> using three stages: error handling, serialization, and data storage. </st><st c="8461">We need to handle each one of the stages carefully and even consider having a dedicated class or function to simplify the process and separate </st><span class="No-Break"><st c="8604">the concerns.</st></span></p>
			<p><st c="8617">As mentioned, the first stage is error handling. </st><st c="8667">Let’s discuss it, as it is a crucial part </st><span class="No-Break"><st c="8709">of networking.</st></span></p>
			<h3><st c="8723">Implementing error handling</st></h3>
			<p><st c="8751">I believe error handling</st><a id="_idIndexMarker421"/><st c="8776"> wouldn’t get a whole section</st><a id="_idIndexMarker422"/><st c="8805"> in many frameworks. </st><st c="8826">It is usually a straightforward topic: we perform a task, something goes wrong, and we receive </st><span class="No-Break"><st c="8921">an error.</st></span></p>
			<p><st c="8930">However, with networking, we are working in a volatile environment where many things have the potential to fail </st><span class="No-Break"><st c="9043">the process.</st></span></p>
			<p><st c="9055">Here’s a partial list of things that can </st><span class="No-Break"><st c="9097">go wrong:</st></span></p>
			<ul>
				<li><st c="9106">There is </st><span class="No-Break"><st c="9116">no network</st></span></li>
				<li><st c="9126">There’s a network, but the device cannot reach </st><span class="No-Break"><st c="9174">the internet</st></span></li>
				<li><st c="9186">The device can reach the internet but with a very </st><span class="No-Break"><st c="9237">slow connection</st></span></li>
				<li><st c="9252">We have a stable connection, but the request cannot reach </st><span class="No-Break"><st c="9311">the backend</st></span></li>
				<li><st c="9322">The request found the backend, but it </st><span class="No-Break"><st c="9361">didn’t respond</st></span></li>
			</ul>
			<p><st c="9375">The error list can go on and on, ranging from network issues to security to </st><span class="No-Break"><st c="9452">server errors.</st></span></p>
			<p><st c="9466">To simplify the idea, we can divide the errors into two main groups: network-related issues and </st><span class="No-Break"><st c="9563">server-side problems.</st></span></p>
			<p><st c="9584">To understand the difference between network and server-related issues, let’s have another look at how we created a </st><span class="No-Break"><st c="9701">data task:</st></span></p>
			<pre class="source-code"><st c="9711">
let task = session.dataTask(with: request) { (data,
  response, error)</st></pre>			<p><st c="9780">We can see that the data task response</st><a id="_idIndexMarker423"/><st c="9819"> contains three</st><a id="_idIndexMarker424"/><st c="9834"> parameters – </st><strong class="source-inline"><st c="9848">data</st></strong><st c="9852">, </st><strong class="source-inline"><st c="9854">response</st></strong><st c="9862">, </st><span class="No-Break"><st c="9864">and </st></span><span class="No-Break"><strong class="source-inline"><st c="9868">error</st></strong></span><span class="No-Break"><st c="9873">.</st></span></p>
			<p><st c="9874">Network-related errors are part of the </st><strong class="source-inline"><st c="9914">error</st></strong><st c="9919"> object, and server-related errors are mostly part of the </st><strong class="source-inline"><st c="9977">response</st></strong><st c="9985"> object and sometimes even part of the </st><span class="No-Break"><strong class="source-inline"><st c="10024">data</st></strong></span><span class="No-Break"><st c="10028"> object.</st></span></p>
			<p><st c="10036">To handle a network error, we should look </st><span class="No-Break"><st c="10079">into </st></span><span class="No-Break"><strong class="source-inline"><st c="10084">URLError</st></strong></span><span class="No-Break"><st c="10092">:</st></span></p>
			<pre class="source-code"><st c="10094">
if let error = error as? </st><st c="10120">URLError {
    switch error.code {
    case .cannotFindHost:
        // notify the user.
    </st><st c="10193">default:
        print("Error: \(error)")
    }
    return
}</st></pre>			<p><st c="10237">In this code example, we performed a switch statement to understand our network error. </st><st c="10325">In this case, we decided to handle one use case of </st><strong class="source-inline"><st c="10376">cannotFindHost</st></strong><st c="10390">. However, there are at least 20 different error codes we can handle. </st><st c="10460">To read the full and updated list, we should look at Apple documentation </st><span class="No-Break"><st c="10533">at </st></span><a href="https://developer.apple.com/documentation/foundation/urlerror"><span class="No-Break"><st c="10536">https://developer.apple.com/documentation/foundation/urlerror</st></span></a><span class="No-Break"><st c="10597">.</st></span></p>
			<p><st c="10598">Unlike network-related errors, server-related errors are more complex. </st><st c="10670">First, we are dependent on another partner—our server. </st><st c="10725">How the server implements its error-handling logic significantly influences how we handle it in </st><span class="No-Break"><st c="10821">our app.</st></span></p>
			<p><st c="10829">Let’s understand that by examining the </st><span class="No-Break"><st c="10869">server response:</st></span></p>
			<pre class="source-code"><st c="10885">
if let httpResponse = response as? </st><st c="10921">HTTPURLResponse {
            switch httpResponse.statusCode {
            case 200..&lt;300:
                print("Success:
                  \(httpResponse.statusCode)")
            case 400..&lt;500:
                print("Client Error:
                  \(httpResponse.statusCode)")
            case 500..&lt;600:
                print("Server Error:
                  \(httpResponse.statusCode)")
            default:
                print("Other Status Code:
                  \(httpResponse.statusCode)")
            }
        } else {
            print("Invalid HTTP Response")
        }</st></pre>			<p><st c="11272">We first cast the response</st><a id="_idIndexMarker425"/><st c="11299"> into the </st><strong class="source-inline"><st c="11309">HTTPURLResponse</st></strong><st c="11324"> type, representing</st><a id="_idIndexMarker426"/><st c="11343"> a general </st><span class="No-Break"><st c="11354">URL response.</st></span></p>
			<p><st c="11367">The response includes a status code, which the server sends back to us. </st><st c="11440">In most cases, the code will be part of the following </st><span class="No-Break"><st c="11494">three groups:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="11507">200..299</st></strong><st c="11516">: The server successfully responded to </st><span class="No-Break"><st c="11556">our request</st></span></li>
				<li><strong class="source-inline"><st c="11567">400..499</st></strong><st c="11576">: The server returns an error due to a bad </st><span class="No-Break"><st c="11620">client request</st></span></li>
				<li><strong class="source-inline"><st c="11634">500..599</st></strong><st c="11643">: The server returned an error due to an internal </st><span class="No-Break"><st c="11694">server error</st></span></li>
			</ul>
			<p><st c="11706">In short, there are three cases – everything went well, it is the client’s fault, or it is the </st><span class="No-Break"><st c="11802">server’s fault.</st></span></p>
			<p><st c="11817">However, in real life, things</st><a id="_idIndexMarker427"/><st c="11847"> are more complex. </st><st c="11866">Sometimes, the server</st><a id="_idIndexMarker428"/><st c="11887"> returns a response code of </st><strong class="source-inline"><st c="11915">200</st></strong><st c="11918"> (success) but includes an error in the response data. </st><st c="11973">There is nothing wrong with doing that – the server can choose how to handle problems. </st><st c="12060">It’s our responsibility to parse the </st><span class="No-Break"><st c="12097">response correctly.</st></span></p>
			<p><st c="12116">If we need to parse the response ourselves to extract the error, it is better to create a function that receives the data, response, and error parameters and throws an error in case it </st><span class="No-Break"><st c="12302">finds one:</st></span></p>
			<pre class="source-code"><st c="12312">
func handleResponse(data: Data?, response: URLResponse?, error: Error?) throws {
    if let error = error {
        throw error
    }
    guard let httpResponse = response as? </st><st c="12469">HTTPURLResponse
      else {
        throw NetworkingError.invalidResponse
    }
    switch httpResponse.statusCode {
    case 200..&lt;300:
        if let responseData = data {
            if let errorData = try?
              </st><st c="12634">JSONDecoder().decode(ErrorResponse.self,
              from: responseData) {
                throw NetworkingError.dataError
            }
        }
    case 400..&lt;500:
        throw NetworkingError.clientError(statusCode:
          httpResponse.statusCode)
    case 500..&lt;600:
        throw NetworkingError.serverError(statusCode:
          httpResponse.statusCode)
    default:
        throw NetworkingError.otherError
    }
}</st></pre>			<p><st c="12952">This long </st><strong class="source-inline"><st c="12963">handleResponse</st></strong><st c="12977"> function</st><a id="_idIndexMarker429"/><st c="12986"> does precisely</st><a id="_idIndexMarker430"/><st c="13001"> what we’ve discussed. </st><st c="13024">In case of a successful response, it checks the error object, the response code, and the </st><span class="No-Break"><st c="13113">data itself.</st></span></p>
			<p><st c="13125">To use that function, we need to call it within the </st><span class="No-Break"><st c="13178">response closure:</st></span></p>
			<pre class="source-code"><st c="13195">
let task = session.dataTask(with: request) { (data,
  response, error) in
    do {
        try handleResponse(data: data, response: response,
          error: error)
    } catch let error {
        print("Error: \(error)")
    }
}</st></pre>			<p><st c="13386">The great thing about the </st><strong class="source-inline"><st c="13413">handleResponse</st></strong><st c="13427"> function is that we can ensure that we can continue handling the response data after the </st><strong class="source-inline"><st c="13517">try</st></strong><st c="13520"> statement because we have dealt with </st><span class="No-Break"><st c="13558">any error.</st></span></p>
			<p><st c="13568">If you look again</st><a id="_idIndexMarker431"/><st c="13586"> at the </st><strong class="source-inline"><st c="13594">handleResponse</st></strong><st c="13608"> function, you’ll see that we decode</st><a id="_idIndexMarker432"/><st c="13644"> the response to look for </st><span class="No-Break"><st c="13670">an error.</st></span></p>
			<p><st c="13679">Deserializing the response is a major step in handling a network response. </st><st c="13755">Let’s discuss it a little </st><span class="No-Break"><st c="13781">bit further.</st></span></p>
			<h3><st c="13793">Deserializing a network response</st></h3>
			<p><st c="13826">In most apps, the response</st><a id="_idIndexMarker433"/><st c="13853"> we get from the server is based on JSON data</st><a id="_idIndexMarker434"/><st c="13898"> structure. </st><st c="13910">JSON is an industry standard for delivering network responses along </st><span class="No-Break"><st c="13978">with XML.</st></span></p>
			<p><st c="13987">Swift has built-in support for parsing JSON structures into Swift structures, using tools such as the </st><strong class="source-inline"><st c="14090">Codable</st></strong><st c="14097"> protocol and </st><span class="No-Break"><strong class="source-inline"><st c="14111">JSONDecoder</st></strong></span><span class="No-Break"><st c="14122"> classes.</st></span></p>
			<p><st c="14131">In theory, it sounds perfect—all we need to do is decode our response to a data model. </st><st c="14219">However, there are more factors we need </st><span class="No-Break"><st c="14259">to consider:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="14271">Supporting general responses</st></strong><st c="14300">: Not all responses are data models. </st><st c="14338">There are network responses that include general messages. </st><st c="14397">For one, in our </st><strong class="source-inline"><st c="14413">handleResponse</st></strong><st c="14427"> function example, we saw a response that may have contained an error message. </st><st c="14506">This means that when we think about our data models, general network responses should be </st><span class="No-Break"><st c="14595">among them.</st></span></li>
				<li><strong class="bold"><st c="14606">Assuming there’s always an object array</st></strong><st c="14646">: Decoding a single object is straightforward, but in many cases, we also need to handle decoding an array of objects. </st><st c="14766">That sounds trivial, but supporting both formats can be a hassle. </st><st c="14832">To simplify the decoding process, it is better to always support an array of objects, which is a decision that we need to coordinate with our </st><span class="No-Break"><st c="14974">backend developers.</st></span></li>
				<li><strong class="bold"><st c="14993">Mixed structures</st></strong><st c="15010">: A response can contain different model types and even nested data structures. </st><st c="15091">This is not always trivial, so our data structures must be more dynamic and modular to support </st><span class="No-Break"><st c="15186">various responses.</st></span></li>
				<li><strong class="bold"><st c="15204">Model transformations</st></strong><st c="15226">: Our local app models are structured to be efficient and convenient to use with the business logic and UI layers. </st><st c="15342">However, who said that the backend response structure is aligned with what is suitable for our app? </st><st c="15442">This means we must transform the response data model to our local </st><span class="No-Break"><st c="15508">data model.</st></span></li>
			</ul>
			<p><st c="15519">Deserializing data models</st><a id="_idIndexMarker435"/><st c="15545"> is indeed a complex task, and trying to match our data models</st><a id="_idIndexMarker436"/><st c="15607"> to the response structure we receive from our backend is only sometimes the best idea. </st><st c="15695">Remember that our data models must suit our app needs and not necessarily follow the </st><span class="No-Break"><st c="15780">backend methodology.</st></span></p>
			<p><st c="15800">Let’s take a simple JSON received from </st><span class="No-Break"><st c="15840">the server:</st></span></p>
			<pre class="source-code"><st c="15851">
{
 "id": 1,
 "name": "John Doe",
 "email": "john@example.com"
 }</st></pre>			<p><st c="15912">That’s a contact structure. </st><st c="15941">However, we want to use different names in our app so we can use the </st><strong class="source-inline"><st c="16010">CodingKey</st></strong><st c="16019"> protocol to ensure we perform the </st><span class="No-Break"><st c="16054">transformation correctly:</st></span></p>
			<pre class="source-code"><st c="16079">
struct Contact: Codable {
    let id: Int
    let fullName: String
    let userEmail: String
    // Define custom coding keys to match JSON keys
    private enum CodingKeys: String, CodingKey {
        case id
        case fullName = "name"
        case userEmail = "email"
    }
}</st></pre>			<p><st c="16313">Decoding the server response using the </st><strong class="source-inline"><st c="16353">Contact</st></strong><st c="16360"> structure now becomes </st><span class="No-Break"><st c="16383">much simpler:</st></span></p>
			<pre class="source-code"><st c="16396">
let errorData = try? </st><st c="16418">JSONDecoder().decode(Contact.self,
  from: responseData)</st></pre>			<p><st c="16472">In this example, we map the </st><strong class="source-inline"><st c="16501">name</st></strong><st c="16505"> value to </st><strong class="source-inline"><st c="16515">fullName</st></strong><st c="16523"> and </st><strong class="source-inline"><st c="16528">email</st></strong><st c="16533"> to </st><strong class="source-inline"><st c="16537">userEmail</st></strong><st c="16546">. We decode it using the </st><strong class="source-inline"><st c="16571">JSONDecoder</st></strong><st c="16582"> class. </st><st c="16590">Understanding the </st><strong class="source-inline"><st c="16608">CodingKey</st></strong><st c="16617"> protocol is a crucial key to decoding </st><span class="No-Break"><st c="16656">server responses.</st></span></p>
			<p><st c="16673">There are cases where the whole structure</st><a id="_idIndexMarker437"/><st c="16715"> of the server response</st><a id="_idIndexMarker438"/><st c="16738"> is entirely different than our data models, and in those cases, we need to create a dedicated structure to parse the response. </st><st c="16866">However, sometimes, we can still use our data model as part of the structure. </st><st c="16944">Let’s look at the </st><span class="No-Break"><st c="16962">following example:</st></span></p>
			<pre class="source-code"><st c="16980">
struct ServerResponse: Codable {
    let responseID: String
    let timestamp: String
    let orgID: String
    let contact: Contact
}
let jsonString = """
{
   "responseID": "12345",
   "timestamp": "2024-03-25T12:00:00Z",
   "orgID": "5678",
   "contact": {
       "id": 1,
       "fullName": "John Doe",
       "userEmail": "john@example.com"
   }
}
"""
let jsonData = jsonString.data(using: .utf8)!
</st><st c="17332">let response = try
  JSONDecoder().decode(ServerResponse.self, from: jsonData)</st></pre>			<p><st c="17408">In this code example, the server returns additional information besides the contact object. </st><st c="17501">So, we can create a dedicated data structure for the response—</st><strong class="source-inline"><st c="17563">ServerResponse</st></strong><st c="17578"> (in this case). </st><st c="17595">In addition to general information, the </st><strong class="source-inline"><st c="17635">ServerResponse</st></strong><st c="17649"> struct contains the </st><strong class="source-inline"><st c="17670">Contact</st></strong><st c="17677"> struct. </st><st c="17686">So, we can see a modular approach here—we can parse our server response</st><a id="_idIndexMarker439"/><st c="17757"> using </st><strong class="source-inline"><st c="17764">Codable</st></strong><st c="17771"> and still use our data model objects</st><a id="_idIndexMarker440"/><st c="17808"> to receive </st><span class="No-Break"><st c="17820">the information.</st></span></p>
			<p><st c="17836">The next step is to store our data model in our </st><span class="No-Break"><st c="17885">data store.</st></span></p>
			<h3><st c="17896">Building a data store</st></h3>
			<p><st c="17918">A disclaimer: not every network</st><a id="_idIndexMarker441"/><st c="17950"> call requires</st><a id="_idIndexMarker442"/><st c="17964"> us to store the results in a data store. </st><st c="18006">For instance, authentication and logic calls have different goals. </st><st c="18073">However, this chapter will focus mainly on data-related calls responsible for building our local </st><span class="No-Break"><st c="18170">data store.</st></span></p>
			<p><st c="18181">That leads us to our next point: what is the role of the </st><span class="No-Break"><st c="18239">data store?</st></span></p>
			<p><st c="18250">So, a data store is a structured mechanism for managing and storing data that serves the application’s main business logic </st><span class="No-Break"><st c="18374">and UI.</st></span></p>
			<p><st c="18381">Unlike many online examples, the application business logic usually doesn’t work directly with the network responses – these need to be adjusted and saved in our store, which acts as the UI </st><span class="No-Break"><st c="18572">data source.</st></span></p>
			<p><st c="18584">Let’s look at </st><span class="No-Break"><em class="italic"><st c="18599">Figure 8</st></em></span><span class="No-Break"><em class="italic"><st c="18607">.2</st></em></span><span class="No-Break"><st c="18609">:</st></span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B21795_08_2.jpg" alt="Figure 8.2: Working with the datastore"/><st c="18611"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18682">Figure 8.2: Working with the datastore</st></p>
			<p><span class="No-Break"><em class="italic"><st c="18720">Figure 8</st></em></span><em class="italic"><st c="18729">.2</st></em><st c="18731"> shows how the data layer works directly with the data store, as the network layer fills the data store with </st><span class="No-Break"><st c="18840">more information.</st></span></p>
			<p><st c="18857">The data store</st><a id="_idIndexMarker443"/><st c="18872"> doesn’t have to be persistent—that’s an engineering </st><a id="_idIndexMarker444"/><st c="18925">decision. </st><st c="18935">However, in most cases, it is a structured store. </st><st c="18985">A structured store has pre-defined models, relations between entities, and often even query capabilities. </st><st c="19091">These characteristics distinguish the data store from simply caching the </st><span class="No-Break"><st c="19164">network responses.</st></span></p>
			<p><st c="19182">To follow the separation of concerns principle, it is better to have dedicated classes to handle each step of </st><span class="No-Break"><st c="19293">the process.</st></span></p>
			<p><st c="19305">First, we’ll create a </st><span class="No-Break"><strong class="source-inline"><st c="19328">DataStore</st></strong></span><span class="No-Break"><st c="19337"> class:</st></span></p>
			<pre class="source-code"><st c="19344">
class DataStore {
    private var contacts: [Contact] = []
    func updateContacts(with newContacts: [Contact]) {
        contacts = newContacts
    }
    func getAllContacts() -&gt; [Contact] {
        return contacts
    }
}</st></pre>			<p><st c="19532">The </st><strong class="source-inline"><st c="19537">DataStore</st></strong><st c="19546"> class not only stores the data but also has methods that help store and </st><span class="No-Break"><st c="19619">retrieve entities.</st></span></p>
			<p><st c="19637">Assuming we already have a network</st><a id="_idIndexMarker445"/><st c="19672"> handler from the previous</st><a id="_idIndexMarker446"/><st c="19698"> examples, we are now going to create a sync class that coordinates the process of fetching the data and </st><span class="No-Break"><st c="19803">storing it:</st></span></p>
			<pre class="source-code"><st c="19814">
class SyncManager {
    private let dataStore: DataStore
    init(dataStore: DataStore) {
        self.dataStore = dataStore
    }
    func syncData() {
        NetworkHandler.fetchData { result in
            switch result {
            case .success(let data):
                do {
                    let contacts = try JSONDecoder().decode([Contact].self, from: data)
                    self.dataStore.updateContacts(with: contacts)
                    print("Data synced successfully")
                } catch {
                    print("Error decoding data:", error)
                }
            case .failure(let error):
                print("Error fetching data:", error)
            }
        }
    }
}</st></pre>			<p><st c="20294">The </st><strong class="source-inline"><st c="20299">SyncManager</st></strong><st c="20310"> class uses the </st><strong class="source-inline"><st c="20326">NetworkHandler</st></strong><st c="20340"> class to fetch the information from our backend, parses the results into </st><strong class="source-inline"><st c="20414">Contact</st></strong><st c="20421"> entities, and stores them in our data store. </st><st c="20467">Using this design</st><a id="_idIndexMarker447"/><st c="20484"> pattern, we can easily replace the data store implementation</st><a id="_idIndexMarker448"/><st c="20545"> to be persistent without modifying the </st><span class="No-Break"><st c="20585">other classes.</st></span></p>
			<p><st c="20599">Now that we have a data store, let’s try to understand how to make our app </st><span class="No-Break"><st c="20675">more efficient.</st></span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor282"/><st c="20690">Integrating network calls within app flows</st></h1>
			<p><st c="20733">We already know how to perform</st><a id="_idIndexMarker449"/><st c="20764"> a network call, parse</st><a id="_idIndexMarker450"/><st c="20786"> it to data objects, and create a data store. </st><st c="20832">We also know how to handle errors, and we learned that it’s important to separate the concerns into different classes </st><span class="No-Break"><st c="20950">and components.</st></span></p>
			<p><st c="20965">However, it feels like a technical discussion. </st><st c="21013">Performing a URL connection in iOS is one of the most basic tasks. </st><st c="21080">Let’s try to upgrade our discussion and </st><span class="No-Break"><st c="21120">discuss methodology.</st></span></p>
			<p><st c="21140">First, we should think of streaming data from the network as an atomic task in our app’s data synchronization mechanism. </st><st c="21262">It’s up to us to decide when to call our server for more data. </st><st c="21325">From our discussions, it looks like we need to contact the server just before we want to display the information, but it doesn’t have to be </st><span class="No-Break"><st c="21465">like that.</st></span></p>
			<p><st c="21475">Let’s discuss the different strategies we can use when working with our backend. </st><st c="21557">We’ll start with the </st><strong class="bold"><st c="21578">just-in-time</st></strong> <span class="No-Break"><st c="21590">fetching technique.</st></span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor283"/><st c="21610">Just-in-time fetching</st></h2>
			<p><st c="21632">The just-in-time fetching technique</st><a id="_idIndexMarker451"/><st c="21668"> is very common and also the simplest one. </st><st c="21711">With it, we don’t present anything on the screen before we get a response from the server. </st><st c="21802">Instead, we show a loader indicating that we are </st><span class="No-Break"><st c="21851">fetching data.</st></span></p>
			<p><st c="21865">In just-in-time fetching, we don’t preserve the information in a data store; instead, we store the information in the view state or the view model. </st><st c="22014">Here’s a simple example of </st><span class="No-Break"><st c="22041">just-in-time fetching:</st></span></p>
			<pre class="source-code"><st c="22063">
import SwiftUI
struct ContactsView: View {
    @State private var contacts: [Contact] = []
    @State private var isLoading = false
    var body: some View {
        NavigationView {
            List(contacts) { contact in
                VStack(alignment: .leading) {
                    Text(contact.name).font(.headline)
                    Text(contact.phoneNumber).font(.subheadline)
                }
            }
            .navigationTitle("Contacts")
            .onAppear {
                fetchContacts()
            }
            .overlay {
                if isLoading {
                    ProgressView("Loading...")
                }
            }
        }
    }
    private func fetchContacts() {
        isLoading = true
        NetworkHandler().fetchData { fetchedContacts in
            contacts = fetchedContacts
            isLoading = false
        }
    }
}</st></pre>			<p><st c="22635">In this code example, we have a list that is based on the state variable of contacts. </st><st c="22722">When the view appears, we call the </st><strong class="source-inline"><st c="22757">fetchContacts</st></strong><st c="22770"> method to fetch the list of contacts and, in the meantime, show a </st><span class="No-Break"><st c="22837">loading message.</st></span></p>
			<p><st c="22853">Besides its simplicity, the just-in-time technique is great for apps that must ensure that the data they display is up to date, such as financial apps or live sports scores. </st><st c="23028">The downside here is that we provide a poor user experience</st><a id="_idIndexMarker452"/><st c="23087"> and depend on the </st><span class="No-Break"><st c="23106">network state.</st></span></p>
			<p><st c="23120">If possible, we should pick a slightly better technique, often called </st><span class="No-Break"><strong class="bold"><st c="23191">read-through cache</st></strong></span><span class="No-Break"><st c="23209">.</st></span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor284"/><st c="23210">Read-through cache</st></h2>
			<p><st c="23229">The read-through cache technique</st><a id="_idIndexMarker453"/><st c="23262"> is also a popular way to present data to the user, even though most developers are unaware of </st><span class="No-Break"><st c="23357">its name.</st></span></p>
			<p><st c="23366">Using the read-through cache approach, we display our local data to the user while going to our backend to refresh </st><span class="No-Break"><st c="23482">our data.</st></span></p>
			<p><st c="23491">Let’s see a code example </st><span class="No-Break"><st c="23517">for that:</st></span></p>
			<pre class="source-code"><st c="23526">
import SwiftUI
struct ContactsView: View {
    @State private var contacts: [Contact] = []
    var body: some View {
        NavigationView {
            List(contacts) { contact in
                VStack(alignment: .leading) {
                    Text(contact.name).font(.headline)
                    Text(contact.phoneNumber).font(.subheadline)
                }
            }
            .navigationTitle("Contacts")
            .onAppear {
                loadContacts()
            }
        }
    }
    private func loadContacts() {
        contacts = loadFromCache()
        NetworkHandler().fetchData { fetchedContacts in
            contacts = fetchedContacts
            saveToCache(contacts: fetchedContacts)
        }
    }
}</st></pre>			<p><st c="24033">In this code example, we load the contacts from the cache (or from the local store) when the screen appears and then go to the network to refresh our data set. </st><st c="24194">The read-through cache technique is great when quick access to data is crucial because it is not up-to-date, for example, in news or </st><span class="No-Break"><st c="24327">e-commerce apps.</st></span></p>
			<p><st c="24343">You’ve probably noticed that both the just-in-time and read-through cache techniques require us to load the page information fully from the backend, regardless of the amount of information </st><span class="No-Break"><st c="24533">we have.</st></span></p>
			<p><st c="24541">Now, what if we know upfront</st><a id="_idIndexMarker454"/><st c="24570"> that we have a huge number of records to fetch, so big that it can even cause our request to time out? </st><st c="24674">In this case, we can choose the </st><strong class="bold"><st c="24706">incremental </st></strong><span class="No-Break"><strong class="bold"><st c="24718">loading</st></strong></span><span class="No-Break"><st c="24725"> technique.</st></span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor285"/><st c="24736">Incremental loading</st></h2>
			<p><st c="24756">There are cases wherein</st><a id="_idIndexMarker455"/><st c="24780"> we can expect to fetch a vast number of records. </st><st c="24830">A social feed, for instance, can have an infinite number of posts. </st><st c="24897">Well, it’s not really infinite, but we can relate to that number </st><span class="No-Break"><st c="24962">as infinity.</st></span></p>
			<p><st c="24974">When the number is too big to fetch in one request, we can use </st><span class="No-Break"><st c="25038">incremental loading.</st></span></p>
			<p><st c="25058">With incremental loading, we fetch a set of records each time with each request and store the last record index for the </st><span class="No-Break"><st c="25179">next time.</st></span></p>
			<p><st c="25189">Here’s an example of </st><span class="No-Break"><st c="25211">incremental loading:</st></span></p>
			<pre class="source-code"><st c="25231">
class IncrementalLoader {
    var currentPage = 1
    let itemsPerPage = 10
    var contacts = [Contact]()
    func loadNextPage() {
        guard let url = URL(string:
"https://api.example.com/contacts?page=\(currentPage)&amp;limit=\(itemsPerPage)") else {
            print("Invalid URL")
            return
        }
        let task = URLSession.shared.dataTask(with: url) { [weak self] (data, response, error) in
            guard let self = self else { return }
            do {
                let newContacts = try JSONDecoder().decode([Contact].self, from: data)
                DispatchQueue.main.async {
                    self.contacts.append(contentsOf: newContacts)
                    print("Fetched Contacts: \(newContacts)")
                    self.currentPage += 1
                }
            } catch {
                print("Error decoding JSON: \(error)")
            }
        }
        task.resume()
    }
}</st></pre>			<p><st c="25905">In this example, we have a class named </st><strong class="source-inline"><st c="25945">IncrementalLoading</st></strong><st c="25963">, which is responsible for loading the next set of records with the function named </st><strong class="source-inline"><st c="26046">loadNextPage</st></strong><st c="26058">. Incremental loading is also called </st><strong class="bold"><st c="26095">pagination loading</st></strong><st c="26113"> because it mimics the concept</st><a id="_idIndexMarker456"/><st c="26143"> of paging through a book. </st><st c="26170">In our </st><strong class="source-inline"><st c="26177">IncrementalLoading</st></strong><st c="26195"> example, we have an index that points to the last record index fetched, and a variable named </st><strong class="source-inline"><st c="26289">itemsPerPage</st></strong><st c="26301"> that defines how many items to fetch on </st><span class="No-Break"><st c="26342">each page.</st></span></p>
			<p><st c="26352">While incremental loading solves handling a large amount of data, there are several factors</st><a id="_idIndexMarker457"/><st c="26444"> we need </st><span class="No-Break"><st c="26453">to consider:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="26465">Complexity</st></strong><st c="26476">: Incremental loading is considered a relatively complex design pattern, mainly because we build our data collection in stages according to user interaction. </st><st c="26635">For example, one classic way to implement incremental loading is by having a SwiftUI </st><strong class="source-inline"><st c="26720">List</st></strong><st c="26724"> view or a UIKit </st><strong class="source-inline"><st c="26741">TableView</st></strong><st c="26750"> view. </st><st c="26757">In these cases, we would like to fetch the next set of records when the user reaches the bottom of the list. </st><st c="26866">However, things can become complex when we allow the user to edit or delete records since that can affect the </st><span class="No-Break"><st c="26976">index variable.</st></span></li>
				<li><strong class="bold"><st c="26991">Memory consumption</st></strong><st c="27010">: It’s true that incremental loading is optimized to handle a significant amount of information. </st><st c="27108">However, we are still talking about storing a large amount of information in our memory. </st><st c="27197">While the user is paging through our data, our local data store can become bigger, mainly if it contains rich media such as images and videos. </st><st c="27340">It is essential to have a mechanism that can release records in case of high </st><span class="No-Break"><st c="27417">memory usage.</st></span></li>
				<li><strong class="bold"><st c="27430">Contextual relevance</st></strong><st c="27451">: We need to remember that our chosen design pattern needs to support a specific product need. </st><st c="27547">Incremental loading is relevant in cases wherein we don’t need all the data at once. </st><st c="27632">Social feeds or search results are great examples of data that can be browsed chunk by chunk. </st><st c="27726">However, in cases where the user requires immediate access to all the data, such as in data analysis, incremental loading</st><a id="_idIndexMarker458"/><st c="27847"> might not </st><span class="No-Break"><st c="27858">be suitable.</st></span></li>
			</ul>
			<p><st c="27870">Considering the different factors mentioned, we understand that, similar to many design patterns in computer science, incremental loading presents a tradeoff between different aspects such as performance, complexity, experience, and more. </st><st c="28110">It’s up to us to choose the right design pattern that fits </st><span class="No-Break"><st c="28169">our needs.</st></span></p>
			<p><st c="28179">The three design patterns we discussed now require different endpoints for different types of data and other screens, which sounds logical. </st><st c="28320">However, there’s another way to handle data that changes over time and still provides an amazing experience to the user – </st><span class="No-Break"><st c="28442">delta updates.</st></span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor286"/><st c="28456">Full data sync with delta updates</st></h2>
			<p><st c="28490">Before we discuss full data sync with the delta updates method, let’s talk about problems that we have with</st><a id="_idIndexMarker459"/> <span class="No-Break"><st c="28598">multiple endpoints:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="28618">Efficient network calls</st></strong><st c="28642">: The need to request the same data repeatedly, even if nothing has changed, seems inefficient. </st><st c="28739">We can use the cache to present previous results, but that only solves performance issues. </st><st c="28830">We still need to perform the same request to understand whether there </st><span class="No-Break"><st c="28900">are updates.</st></span></li>
				<li><strong class="bold"><st c="28912">Incomplete database</st></strong><st c="28932">: Each endpoint retrieves different data and sometimes different entities. </st><st c="29008">We know that in many cases, the entities are related (such as to-one and to-many relationships), and having multiple endpoints to fetch them probably means our data won’t be complete. </st><st c="29192">That seems acceptable – we’re focused on a mobile app and not a server. </st><st c="29264">However, having an incomplete data store can result in a poor experience. </st><st c="29338">Users may encounter updated information on one screen, navigate to another, and view outdated data while waiting for the screen to refresh from the server. </st><st c="29494">If both screens contain related data, it can result in a </st><span class="No-Break"><st c="29551">poor experience.</st></span></li>
				<li><strong class="bold"><st c="29567">App performance</st></strong><st c="29583">: We often believe that performance is only about CPU and Swift code efficiency. </st><st c="29665">However, our devices are strong enough to handle most tasks without a hiccup. </st><st c="29743">In contrast, network requests</st><a id="_idIndexMarker460"/><st c="29772"> cause users to wait even if they have the latest hardware. </st><st c="29832">Having a network call on each screen greatly impacts the </st><span class="No-Break"><st c="29889">user experience.</st></span></li>
			</ul>
			<p><st c="29905">Delta updates</st><a id="_idIndexMarker461"/><st c="29919"> are a solution that can handle some of the problems we described with endpoints in the previous section. </st><st c="30025">With delta updates, we fetch all the information at the app’s initial launch and, from this point, retrieve only </st><span class="No-Break"><st c="30138">the changes.</st></span></p>
			<p><st c="30150">We do that by storing a bookmark representing our data’s last updated timestamp. </st><st c="30232">When we ask the server, “Do you have any updates for me?”, we send this bookmark, get the new changes (if any), receive a new bookmark, and </st><span class="No-Break"><st c="30372">store it.</st></span></p>
			<p><st c="30381">Here’s a code example for contacts</st><a id="_idIndexMarker462"/><st c="30416"> delta sync. </st><st c="30429">We start with the </st><span class="No-Break"><strong class="source-inline"><st c="30447">syncContacts</st></strong></span><span class="No-Break"><st c="30459"> function:</st></span></p>
			<pre class="source-code"><st c="30469">
class ContactsSyncManager {
    let userDefaults = UserDefaults.standard
    let lastUpdatedKey = "lastUpdatedTime"
    let syncEndpoint = URL(string:
      "https://example.com/api/sync/contacts")!
    </st><st c="30651">func syncContacts() {
        var request = URLRequest(url: syncEndpoint)
        request.httpMethod = "POST"
        request.addValue("application/json",
          forHTTPHeaderField: "Content-Type")
        let lastUpdatedTime = userDefaults.double(forKey:
          lastUpdatedKey)
        let requestBody = ["lastUpdatedTime":
          lastUpdatedTime]
        request.httpBody = try?
          </st><st c="30963">JSONSerialization.data(withJSONObject:
          requestBody)
        URLSession.shared.dataTask(with: request) { [weak
          self] data, response, error in
            self?.processDeltaUpdates(response: response)
        }.resume()
    }</st></pre>			<p><st c="31154">The code example does exactly</st><a id="_idIndexMarker463"/><st c="31184"> what we described earlier—it saves a bookmark called </st><strong class="source-inline"><st c="31238">lastUpdatedDate</st></strong><st c="31253">. Initially, we fetch all the data and save the new </st><strong class="source-inline"><st c="31305">lastUpdatedDate</st></strong><st c="31320"> value we get from the server. </st><st c="31351">The next time we perform the sync operation, we get only the changes. </st><st c="31421">Now, let’s implement the </st><span class="No-Break"><strong class="source-inline"><st c="31446">processDeltaUpdates</st></strong></span><span class="No-Break"><st c="31465"> function:</st></span></p>
			<pre class="source-code"><st c="31475">
    private func processDeltaUpdates(response:
      ContactsDeltaUpdateResponse) {
        // Here you can handle the new, deleted, and updated contacts as needed
        print("New Contacts:
          \(response.newContacts.count)")
        print("Deleted Contacts:
          \(response.deletedContacts.count)")
        print("Updated Contacts:
          \(response.updatedContacts.count)")
        userDefaults.set(response.lastUpdated, forKey:
          lastUpdatedKey)
    }
}</st></pre>			<p><st c="31863">The </st><strong class="source-inline"><st c="31868">processDeltaUpdates</st></strong><st c="31887"> function receives a response that contains only the changes that have occurred in the server since the </st><span class="No-Break"><st c="31991">last sync.</st></span></p>
			<p><st c="32001">That’s why the response</st><a id="_idIndexMarker464"/><st c="32025"> is structured into three groups: deleted, new, and updated. </st><st c="32086">With each one, we need to handle the </st><span class="No-Break"><st c="32123">data differently.</st></span></p>
			<p><st c="32140">Some critical notes we need to consider</st><a id="_idIndexMarker465"/><st c="32180"> here are </st><span class="No-Break"><st c="32190">as follows:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="32201">Extremally large data sets</st></strong><st c="32228">: The delta updates pattern is not relevant for very large data sets. </st><st c="32299">For example, a social app feed can have millions of records, and fetching all of them from the start is impossible. </st><st c="32415">For that issue, we can </st><span class="No-Break"><st c="32438">use pagination.</st></span></li>
				<li><strong class="bold"><st c="32453">The initial loading can be long</st></strong><st c="32485">: Since we fetch all the data at the beginning, we need to deliver a corresponding </st><span class="No-Break"><st c="32569">user experience.</st></span></li>
				<li><strong class="bold"><st c="32585">Deleted items</st></strong><st c="32599">: Syncing deleted items is always a crucial topic. </st><st c="32651">We need to actively delete items that no longer exist, so the response from the server should contain items we need </st><span class="No-Break"><st c="32767">to delete.</st></span></li>
				<li><strong class="bold"><st c="32777">Sync triggers</st></strong><st c="32791">: Since we perform the sync operation at the beginning, it looks like it’s the only time we should do that. </st><st c="32900">However, there are more occasions when we need to refresh our data. </st><st c="32968">For example, when we perform data changes such as calling the server to add a new item or receiving a push notification, we should think about the different cases when something can change in our server during the app runtime</st><a id="_idIndexMarker466"/><st c="33193"> and try to refresh </st><span class="No-Break"><st c="33213">our data.</st></span></li>
			</ul>
			<p><st c="33222">It’s important to understand that none of the solutions are perfect. </st><st c="33292">Sometimes, it is a good idea to combine different approaches—for example, use delta sync in general, but maybe use pagination for a </st><span class="No-Break"><st c="33424">specific screen.</st></span></p>
			<p><st c="33440">We should consider the different approaches as a toolbox with several tools, each suitable for various problems or </st><span class="No-Break"><st c="33556">data structures.</st></span></p>
			<p><st c="33572">Now that we understand how to handle requests and use different patterns to incorporate the calls in our app flows, let’s see another way to handle networking </st><span class="No-Break"><st c="33732">in iOS.</st></span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor287"/><st c="33739">Exploring Networking and Combine</st></h1>
			<p><st c="33772">Networking is a great place</st><a id="_idIndexMarker467"/><st c="33800"> to start if you</st><a id="_idIndexMarker468"/><st c="33816"> haven’t worked with Combine. </st><st c="33846">Combine is a framework that declaratively handles a stream of values over time while supporting </st><span class="No-Break"><st c="33942">asynchronous operations.</st></span></p>
			<p><st c="33966">Based on that description, it looks like Combine was made for </st><span class="No-Break"><st c="34029">networking operations!</st></span></p>
			<p><st c="34051">In this chapter, we are not going to discuss what Combine is – for that, we’ve got </st><a href="B21795_11.xhtml#_idTextAnchor346"><span class="No-Break"><em class="italic"><st c="34135">Chapter 11</st></em></span></a><st c="34145">. However, we are going to discuss it now because Combine is a great way to solve many networking </st><span class="No-Break"><st c="34243">operations problems.</st></span></p>
			<p><st c="34263">Since Combine is built upon publishers and operators, it is simple to create new publishers that stream data from </st><span class="No-Break"><st c="34378">the network.</st></span></p>
			<p><st c="34390">Let’s try to request the list of contacts from previous examples using a Combine stream. </st><st c="34480">We’ll start with creating a publisher that performs data fetching from the network and publish a list </st><span class="No-Break"><st c="34582">of contacts:</st></span></p>
			<pre class="source-code"><st c="34594">
class ContactRequest {
    func fetchData() -&gt; AnyPublisher&lt;[Contact], Error&gt; {
        let url = URL(string:
          "https://api.example.com/contacts")!
        </st><st c="34730">return URLSession.shared.dataTaskPublisher(for:
          url)
            .map { $0.data }
            .decode(type: [Contact].self, decoder:
              JSONDecoder())
            .eraseToAnyPublisher()
    }
}</st></pre>			<p><st c="34880">The publisher utilizes</st><a id="_idIndexMarker469"/><st c="34903"> URLSession’s </st><strong class="source-inline"><st c="34917">dataTaskPublisher</st></strong><st c="34934"> method</st><a id="_idIndexMarker470"/><st c="34941"> to execute the network request and publish the retrieved data. </st><st c="35005">We then extract the data using the map operation and decode it into a list of </st><strong class="source-inline"><st c="35083">Contact</st></strong><st c="35090"> items. </st><st c="35098">If something goes wrong, the publisher will report an Error. </st><st c="35159">We wrap this function in a class named </st><strong class="source-inline"><st c="35198">ContactRequest</st></strong><st c="35212"> to </st><span class="No-Break"><st c="35216">maintain separation.</st></span></p>
			<p><st c="35236">Now, let’s create a small </st><strong class="source-inline"><st c="35263">DataStore</st></strong><st c="35272"> class so we can store the results and </st><span class="No-Break"><st c="35311">publish them:</st></span></p>
			<pre class="source-code"><st c="35324">
class DataStore {
    @Published var contacts: [Contact] = []
}</st></pre>			<p><st c="35384">The </st><strong class="source-inline"><st c="35389">@Published</st></strong><st c="35399"> property wrapper creates a publisher for contacts so that we can observe the </st><span class="No-Break"><st c="35477">changes easily.</st></span></p>
			<p><st c="35492">Now, we can use the </st><strong class="source-inline"><st c="35513">fetchData()</st></strong><st c="35524"> function</st><a id="_idIndexMarker471"/><st c="35533"> to read the results</st><a id="_idIndexMarker472"/><st c="35553"> and </st><span class="No-Break"><st c="35558">store them:</st></span></p>
			<pre class="source-code"><st c="35569">
class ContactsSync {
    let contactRequest = ContactRequest()
    let dataStore = DataStore()
    func syncContacts() {
        </st><strong class="bold"><st c="35679">contactRequest.fetchData()</st></strong><st c="35705">
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print("Data fetch completed
                      successfully")
                case .failure(let error):
                    print("Error fetching data: \(error)")
                }
            }, receiveValue: { [weak self] contacts in
</st><strong class="bold"><st c="35935">                self?.dataStore.contacts = contacts</st></strong><st c="35970">
            })
            .store(in: &amp;cancellables)
    }
    private var cancellables = Set&lt;AnyCancellable&gt;()
}
let contactsSync = ContactsSync()
contactsSync.syncContacts()</st></pre>			<p><st c="36114">The </st><strong class="source-inline"><st c="36119">ContactsSync</st></strong><st c="36131"> job is to fetch</st><a id="_idIndexMarker473"/><st c="36147"> contacts using the </st><strong class="source-inline"><st c="36167">ContactRequest</st></strong><st c="36181"> class and to store</st><a id="_idIndexMarker474"/><st c="36200"> them in the data store using the </st><span class="No-Break"><strong class="source-inline"><st c="36234">DataStore</st></strong></span><span class="No-Break"><st c="36243"> class.</st></span></p>
			<p><st c="36250">The Combine example has</st><a id="_idIndexMarker475"/> <span class="No-Break"><st c="36274">several advantages:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="36294">Clear and consistent interface</st></strong><st c="36325">: The publisher interface is consistent and known. </st><st c="36377">It is always built from data/void and an optional error. </st><st c="36434">New developers don’t need to learn and understand how to </st><span class="No-Break"><st c="36491">read/use it.</st></span></li>
				<li><strong class="bold"><st c="36503">Built-in error handling</st></strong><st c="36527">: Not only do we have a consistent interface that also contains errors, but also, when one of the stages encounters an error, it interrupts the flow and channels it downstream. </st><st c="36705">We have already seen that error handling is a critical topic in networking in </st><span class="No-Break"><st c="36783">many cases.</st></span></li>
				<li><strong class="bold"><st c="36794">Asynchronous operations support</st></strong><st c="36826">: We often think that a network operation contains one asynchronous operation: the request itself. </st><st c="36926">However, many steps in the stream can be asynchronous – including preparing the request by reading local data, processing the response, and storing the data at the end of the stream. </st><st c="37109">Combine streams are perfect for performing all those </st><span class="No-Break"><st c="37162">steps asynchronously.</st></span></li>
				<li><strong class="bold"><st c="37183">Modularity</st></strong><st c="37194">: The capability of building</st><a id="_idIndexMarker476"/><st c="37223"> a modular code is reserved not only for the Combine framework, but the custom publishers and the different operators make Combine streams a joyful framework to implement when dealing with networking. </st><st c="37424">Remember that we said that networking is like a production line (under the </st><em class="italic"><st c="37499">Understanding mobile networking</st></em><st c="37530"> section)? </st><st c="37541">So, Combine makes it easier to insert more steps into the stream; some of them are even built into </st><span class="No-Break"><st c="37640">the framework.</st></span></li>
			</ul>
			<p><st c="37654">Adding reactive methods</st><a id="_idIndexMarker477"/><st c="37678"> to our code doesn’t mean we need to discard all the design patterns and principles we discussed when we covered networking—it’s just another</st><a id="_idIndexMarker478"/><st c="37819"> way to </st><span class="No-Break"><st c="37827">implement them.</st></span></p>
			<p><st c="37842">For example, let’s try to implement the delta updates design pattern using the </st><span class="No-Break"><st c="37922">Combine framework:</st></span></p>
			<pre class="source-code"><st c="37940">
        URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output in
                guard let response = output.response as?
                  </st><st c="38052">HTTPURLResponse, response.statusCode ==
                  200 else {
                    throw URLError(.badServerResponse)
                  }
                return output.data
            }
            .decode(type: ContactsDeltaUpdateResponse.self,
              decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print("Error during sync:
                      \(error.localizedDescription)")
                }
            }, receiveValue: { [weak self] response in
                self?.processDeltaUpdates(response:
                  response)
            })
            .store(in: &amp;cancellables)</st></pre>			<p><st c="38552">Looking at the code</st><a id="_idIndexMarker479"/><st c="38572"> example, we can</st><a id="_idIndexMarker480"/><st c="38588"> see that it looks pretty much like the previous Combine code—that’s part of the idea of consistent interface and modular code. </st><st c="38716">We perform the request, check the response code, decode it, change it to the main thread, and process the </st><span class="No-Break"><st c="38822">response data.</st></span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor288"/><st c="38836">Summary</st></h1>
			<p><st c="38844">Connecting to our backend and retrieving data is a basic task in most mobile apps. </st><st c="38928">Doing so lets us present valuable and interesting information to </st><span class="No-Break"><st c="38993">our users.</st></span></p>
			<p><st c="39003">Performing a simple request is easy – however, there are many other factors to bear in mind, and doing that properly is crucial to having an </st><span class="No-Break"><st c="39145">efficient app.</st></span></p>
			<p><st c="39159">This chapter reviewed the different network components, such as the request itself, error handling, and data storage. </st><st c="39278">We also discussed our different design patterns to work with our backend. </st><st c="39352">We ended up incorporating Combine into our flows. </st><st c="39402">We should now be perfectly able to set up a fantastic network infrastructure for </st><span class="No-Break"><st c="39483">our app.</st></span></p>
			<p><st c="39491">Now, let’s flip to the other side of our architecture, the UI, and discuss a library that can enrich our app easily – </st><span class="No-Break"><strong class="bold"><st c="39610">Charts</st></strong></span><span class="No-Break"><st c="39616">!</st></span></p>
		</div>
	<div id="charCountTotal" value="39617"/></body></html>