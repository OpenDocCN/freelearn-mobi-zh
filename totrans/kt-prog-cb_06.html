<html><head></head><body><div><h1 class="header-title">Collections Framework</h1>
                
            
            
                
<p class="mce-root">The following recipes will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">How to merge two collections</li>
</ul>
<ul>
<li style="font-weight: 400">Splitting original collection into pair of collections</li>
</ul>
<ul>
<li style="font-weight: 400">Sorting a list by specified comparator</li>
</ul>
<ul>
<li style="font-weight: 400">Sorting in descending order</li>
</ul>
<ul>
<li style="font-weight: 400">Parsing a JSON response using Gson</li>
</ul>
<ul>
<li style="font-weight: 400">How to filter and map using lambda expressions</li>
</ul>
<ul>
<li style="font-weight: 400">How to sort a list of objects and keep null objects at the end</li>
</ul>
<ul>
<li style="font-weight: 400">How to implement a lazy list in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">How to pad a string in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">How to flatten an array or map</li>
</ul>
<ul>
<li style="font-weight: 400">How to sort collection by multiple fields in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">How to use limit in Kotlin list</li>
</ul>
<ul>
<li style="font-weight: 400">How to create a 2D array in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">How to skip the first N entries in Kotlin</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Collections framework is useful when we want to process items in a collection. If you have worked with Java, you are probably familiar with collections framework. The most common use of collections framework are maps, sets, lists, and so on. Kotlin too has its collection framework, but it's much better than Java's collection framework because, in Kotlin, we can leverage the functional programming approach to make our code more concise and easy to work with. So, let's dive into the recipes related to Kotlin's collection framework.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to merge two collections</h1>
                
            
            
                
<p>In this recipe, we will see how to merge two or more collections into one. However, before we move ahead, we need to understand the difference between mutable and immutable types. An immutable type object is an object that cannot be changed. For example, if we define an immutable list, we won't be able to add other objects to it. With that in mind, let's start the recipe!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for coding. You can use whichever IDE you like as long as it is able to compile and run Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>You can create a list in Kotlin with the <kbd>listOf</kbd> method. However, the list returned by this method is an immutable list, so we need to create a mutable list in order to add objects to it. Let's check out the mentioned steps:</p>
<ol>
<li>Let's create two lists, <kbd>listA</kbd> and <kbd>listB</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">var listA= mutableListOf&lt;String&gt;("a","a","b")<br/>var listB= mutableListOf&lt;String&gt;("a","c")</pre>
<p>If the type declaration is inferred from the objects inside the <kbd>listOf/mutableListOf</kbd> method, we won't need to declare the type declaration explicitly. So, the preceding code will be rewritten as <kbd>mutableListOf("a","a","b")</kbd>.</p>
<ol start="2">
<li>Now, we will try to add the contents of <kbd>listA</kbd> in <kbd>listB</kbd>. For that purpose, we will require the <kbd>addAll()</kbd> method:</li>
</ol>
<div><pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val listA= mutableListOf&lt;String&gt;("a","a","b")<br/>    val listB= mutableListOf&lt;String&gt;("a","c")<br/>    listB.addAll(listA)<br/>    println(listB)<br/>}</pre></div>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong>[a, c, a, a, b]</strong></pre>
<ol start="3">
<li>Another way to merge two lists is using <kbd>union</kbd>. This returns the unique elements of the combined collection:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val listA= mutableListOf&lt;String&gt;("a","a","b")<br/>    val listB= mutableListOf&lt;String&gt;("a","c")<br/>    val listC=listB.union(listA)<br/>    println(listC)<br/>}</pre>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px"><strong>[a, c, b]</strong></pre>
<ol start="4">
<li>Similarly, mutable sets can be merged too, the only difference is that <kbd>addAll</kbd> in a set will be similar to what we will receive with the <kbd>union</kbd> method; since it's a set, only a unique value is allowed:</li>
</ol>
<pre style="padding-left: 60px">val setA= mutableSetOf&lt;String&gt;("a","b","c")<br/>val setB= mutableSetOf&lt;String&gt;("a","b","c","d")<br/>setB.addAll(setA)<br/>println(setB)<br/>println(setB.union(setA))</pre>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px"><strong>[a, b, c, d]</strong><br/><strong>[a, b, c, d]</strong></pre>
<p>If you want to merge two maps, you will need the <kbd>putAll()</kbd> method, as <kbd>addAll</kbd> and <kbd>union</kbd> are not present for the <kbd>map</kbd>:</p>
<pre>val mapA= mutableMapOf&lt;String,Int&gt;("a" to 1, "b" to 2)<br/>val mapB= mutableMapOf&lt;String,Int&gt;("a" to 2, "d" to 4)<br/>mapA.putAll(mapB)<br/>println(mapA)</pre>
<p>Here's the output:</p>
<pre><strong>{a=2, b=2, d=4}</strong></pre>
<p>Notice that key <kbd>a</kbd> was defined in both the maps, but the one that comes later (in this case, <kbd>mapB</kbd>) wins.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Splitting original collection into pair of collections</h1>
                
            
            
                
<p>There are times when you wish that you could just split a list into sublists without going into the <kbd>for</kbd> and <kbd>while</kbd> loops. Kotlin provides you with a function just for this occasion. In this recipe, we will see how to split a list based on some criteria.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Kotlin provides a <kbd>partition</kbd> function. According to the documentation of the partition function it does the following:</p>
<p>Splits the original array into a pair of lists, where the first list contains elements for which predicate yielded true, while the second list contains elements for which predicate yielded false.</p>
<p>Let's understand it more clearly by going through this example:</p>
<ol>
<li>In this example, we will create a list of numbers, and we want to split this list into two sublists: one having odd numbers and the other having even numbers:</li>
</ol>
<div><pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val listA= listOf(1,2,3,4,5,6)<br/>    val pair=listA.partition {<br/>        it%2==0<br/>    }<br/>    println(pair)<br/>}</pre></div>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px"><strong>([2, 4, 6], [1, 3, 5])</strong></pre>
<ol start="2">
<li>As you can see in the preceding example, we need to put the condition in the predicate inside the <kbd>partition</kbd> block. The returned object is a <kbd>Pair</kbd> object, holding the two sublists.</li>
<li>The <kbd>partition</kbd> function also works with the <kbd>set</kbd> collection in a similar way:</li>
</ol>
<div><pre style="padding-left: 60px">val setA= setOf(1,2,3,4,5,6)<br/>val pair=setA.partition {<br/>    it%2==0<br/>}<br/>println(pair)<br/><br/></pre></div>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong>([2, 4, 6], [1, 3, 5])</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Let's take a look at the implementation of the <kbd>partition</kbd> function in Kotlin:</p>
<pre>public inline fun &lt;T&gt; Iterable&lt;T&gt;.partition(predicate: (T) -&gt; Boolean): Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt; {<br/>    val first = ArrayList&lt;T&gt;()<br/>    val second = ArrayList&lt;T&gt;()<br/>    for (element in this) {<br/>        if (predicate(element)) {<br/>            first.add(element)<br/>        } else {<br/>            second.add(element)<br/>        }<br/>    }<br/>    return Pair(first, second)<br/>}</pre>
<p>As you can see, the <kbd>partition</kbd> function is just an abstraction, that saves you from writing long for loops, but internally it does it the same old way.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>The <kbd>partition</kbd> function works in a similar way with arrays as well. Here are its different usages. Each of them works similarly, just producing lists of different types:</p>
<pre class="signature language-kotlin">// Produces two lists<br/>inline fun &lt;T&gt; Array&lt;out T&gt;.partition(
    predicate: (T) -&gt; Boolean
): Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Byte and produces two lists of Byte<br/>inline fun ByteArray.partition(
    predicate: (Byte) -&gt; Boolean
): Pair&lt;List&lt;Byte&gt;, List&lt;Byte&gt;&gt;<br/><br/></pre>
<pre class="signature language-kotlin">// Breaks original list of Short and produces two lists of Short<br/>inline fun ShortArray.partition(
    predicate: (Short) -&gt; Boolean
): Pair&lt;List&lt;Short&gt;, List&lt;Short&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Int and produces two lists of Int<br/>inline fun IntArray.partition(
    predicate: (Int) -&gt; Boolean
): Pair&lt;List&lt;Int&gt;, List&lt;Int&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Long and produces two lists of Long<br/>inline fun LongArray.partition(
    predicate: (Long) -&gt; Boolean
): Pair&lt;List&lt;Long&gt;, List&lt;Long&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Float and produces two lists of Float<br/>inline fun FloatArray.partition(
    predicate: (Float) -&gt; Boolean
): Pair&lt;List&lt;Float&gt;, List&lt;Float&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Double and produces two lists of Double<br/>inline fun DoubleArray.partition(
    predicate: (Double) -&gt; Boolean
): Pair&lt;List&lt;Double&gt;, List&lt;Double&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Boolean and produces two lists of Boolean<br/>inline fun BooleanArray.partition(
    predicate: (Boolean) -&gt; Boolean
): Pair&lt;List&lt;Boolean&gt;, List&lt;Boolean&gt;&gt;</pre>
<pre class="signature language-kotlin">// Breaks original list of Char and produces two lists of Char<br/>inline fun CharArray.partition(
    predicate: (Char) -&gt; Boolean
): Pair&lt;List&lt;Char&gt;, List&lt;Char&gt;&gt;</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Sorting a list by specified comparator</h1>
                
            
            
                
<p>Sorting a list is one of the most common operations done on the list. When we try to sort a list of custom objects, we need to specify the comparator. Let's see how we can sort a list by the specified comparator.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following examples, we will try to sort objects based on certain properties. This will give us an idea of how to sort based on the specified comparator:</p>
<ol>
<li>Let's create a <kbd>Person</kbd> class with age property. We will be sorting a list of person objects based on age:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val p1=Person(91)<br/>    val p2=Person(10)<br/>    val p3=Person(78)<br/>    val listOfPerson= listOf(p1,p2,p3)<br/>    var sortedListOfPerson=listOfPerson.sortedBy {<br/>        it.age<br/>    }<br/>}<br/>class Person(var age:Int)</pre>
<ol start="2">
<li>To sort a list based on the specified comparator, we need to use the <kbd>sortedBy</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val p1=Person(91)<br/>    val p2=Person(10)<br/>    val p3=Person(78)<br/>    val listOfPerson= listOf(p1,p2,p3)<br/>    var sortedListOfPerson=listOfPerson.sortedBy {<br/>        it.age<br/>    }<br/>}<br/>class Person(var age:Int)<br/></pre>
<ol start="3">
<li>Kotlin also provides a <kbd>sortedWith</kbd> method, where you can specify your own implementation of comparator:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;)<br/>{<br/>  val p1=Person(91)<br/>  val p2=Person(10)<br/>  val p3=Person(78)<br/>  val listOfPerson= listOf(p1,p2,p3)<br/>  var sortedListOfPerson=listOfPerson<br/>  <strong>.sortedWith&lt;Person&gt;(object:Comparator&lt;Person&gt;</strong>{<br/>      override fun compare(p0: Person, p1: Person):Int {<br/>        if(p0.age&gt;p1.age){<br/>              return 1<br/>          }<br/>          if(p0.age==p1.age){<br/>              return 0<br/>          }<br/>          return -1<br/>      }<br/>  })<br/>}<br/>class Person(var age:Int)</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The <kbd>sortedBy</kbd> function is syntactic sugar provided by Kotlin. Internally, it's calling the <kbd>sortedWith</kbd> method that takes in a comparator.</p>
<p>Now, let's see the implementation of the <kbd>sortBy</kbd> function:</p>
<pre>public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.sortedBy(crossinline selector: (T) -&gt; R?): List&lt;T&gt; {<br/>    return sortedWith(compareBy(selector))<br/>}</pre>
<p>The <kbd>sortBy</kbd> function calls the <kbd>sortedWith</kbd> method inside it, which is as following<em>:<br/></em></p>
<pre>public fun &lt;T&gt; Iterable&lt;T&gt;.sortedWith(comparator: Comparator&lt;in T&gt;): List&lt;T&gt; {<br/>    if (this is Collection) {<br/>       if (size &lt;= 1) return this.toList()<br/>       @Suppress("UNCHECKED_CAST")<br/>       return (toTypedArray&lt;Any?&gt;() as Array&lt;T&gt;).apply { sortWith(comparator) }.asList()<br/>    }<br/>    return toMutableList().apply { sortWith(comparator) }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Sorting in descending order</h1>
                
            
            
                
<p>In the last recipe, we saw how to sort a list with a specified comparator. We provide the comparator, and it sorts it accordingly. Interestingly, Kotlin also provides a method to sort items of a list in descending order. In this recipe, we will see how to sort a collection of primitive objects as well as custom objects in descending order. So let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>We will now see how to sort in descending order using some examples:</p>
<ol>
<li>First, we will try to sort a simple list of integers:</li>
</ol>
<pre style="padding-left: 60px">val listOfInt= listOf(1,2,3,4,5)<br/>var sortedList=listOfInt.sortedDescending()<br/>sortedList.forEach {<br/>    print("${it} ")<br/>}</pre>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px"><strong>5 4 3 2 1</strong></pre>
<ol start="2">
<li>Now, let's use our list of <kbd>Person</kbd> from the preceding recipe. To sort it in descending order, this is what we will do:</li>
</ol>
<pre style="padding-left: 60px">val p1=Person(91)<br/>val p2=Person(10)<br/>val p3=Person(78)<br/>val listOfPerson= listOf&lt;Person&gt;(p1,p2,p3)<br/>val sortedListOfPerson=listOfPerson.sortedByDescending {<br/>    it.age<br/>}<br/>sortedListOfPerson.forEach {<br/>    print("${it.age} ")<br/>}</pre>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong>91 78 10</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The <kbd>sortedByDescending</kbd> works a bit like <kbd>sortedBy</kbd>. Internally, both use the <kbd>sortedWith</kbd> function:</p>
<pre>public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.sortedByDescending(crossinline selector: (T) -&gt; R?): List&lt;T&gt; {<br/>    return sortedWith(compareByDescending(selector))<br/>}</pre>
<p>The following is the implementation of <kbd>compareByDescending</kbd>:</p>
<pre>@kotlin.internal.InlineOnly<br/>public inline fun &lt;T&gt; compareByDescending(crossinline selector: (T) -&gt; Comparable&lt;*&gt;?): Comparator&lt;T&gt; =<br/>        Comparator { a, b -&gt; compareValuesBy(b, a, selector) }</pre>
<p>Note that just the order of variables is reversed to produce the descending order.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing a JSON response using Gson</h1>
                
            
            
                
<p>In this recipe, we will learn how to parse JSON. JSON is the most widely used data type for API responses. We will be using Gson, an open source library by Google. It's fast, and it scales very well even with a huge response.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio for this purpose, and JSONObject is provided by Android SDK. We will be using Gson for JSON parsing. You can add it to your project by adding the following lines to your <kbd>build.gradle</kbd> file:</p>
<pre>compile 'com.google.code.gson:gson:2.8.0'</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's follow these steps to parse JSON data using Gson. For example, we will use a raw string here to keep things simple:</p>
<ol>
<li>First, we will create dummy JSON data using a raw string, as follows:</li>
</ol>
<pre style="padding-left: 60px">val jsonStr="""<br/>    {<br/>     "name": "Aanand Shekhar",<br/>     "age": 21,<br/>     "isAwesome": true<br/>    }<br/>""".trimIndent()</pre>
<ol start="2">
<li>Next, we will create a data class to hold this data. Here's how our data class looks:</li>
</ol>
<pre style="padding-left: 60px">data class Information(val name:String,val age:Int, val isAwesome:Boolean)</pre>
<ol start="3">
<li>Finally, we will use <kbd>Gson</kbd> to parse the JSON string:</li>
</ol>
<pre style="padding-left: 60px">val information:Information= Gson().fromJson&lt;Information&gt;(jsonStr,Information::class.java)</pre>
<p>Now you can use it just like a Kotlin object.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>You can create the data class automatically using some Android Studio plugins. One of the most widely used plugins is <strong>RoboPOJOGenerator</strong> ( <a href="https://github.com/robohorse/RoboPOJOGenerator">https://github.com/robohorse/RoboPOJOGenerator</a> ).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to filter and map using lambda expressions</h1>
                
            
            
                
<p>In this recipe, we will learn how to transform a list using a <kbd>map</kbd> function in Kotlin, and how to filter the list with whichever criteria we like. We will be using lambda functions, which provide a great way to do functional programming. So let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>First, let's see how to use the <strong>filter</strong> function on a list. The filter function returns a list containing all elements matching the given predicate. We will create a list of numbers and filter the list based on even or odd.</p>
<p>The <kbd>filter</kbd> method is good for an immutable collection as it doesn't modify the original collection but returns a new one. In the filter method, we need to implement the predicate. The predicate, like the condition, is based on the list that is filtered.</p>
<p>For example, we know that even items will follow <kbd>it%2==0</kbd>. So the corresponding filter method will look like this:</p>
<pre>val listOfNumbers=listOf(1,2,3,4,5,6,7,8,9)<br/>var evenList=listOfNumbers.filter {<br/>    it%2==0<br/>}<br/>println(evenList)<br/><br/>//Output: <strong>[2, 4, 6, 8]</strong></pre>
<p>Another variant of the filter function is <kbd>filterNot</kbd>, which, as the name suggests, returns a list containing all elements not matching the given predicate.</p>
<p>Another cool lambda function is <kbd>map</kbd>. It transforms the list and returns a new one:</p>
<pre>val listOfNumbers=listOf(1,2,3,4,5,6,7,8,9)<br/>var transformedList=listOfNumbers.map {<br/>    it*2<br/>}<br/>println(transformedList)<br/><br/>//Output: <strong>[2, 4, 6, 8, 10, 12, 14, 16, 18]</strong></pre>
<p>A variant of the <kbd>map</kbd> function is <kbd>mapIndexed</kbd>. It provides the index along with the item in its construct:</p>
<pre>val listOfNumbers=listOf(1,2,3,4,5)<br/>val map=listOfNumbers.mapIndexed { index, it<br/>    -&gt; it*index}<br/>println(map)<br/><br/>//Output: <strong>[0, 2, 6, 12, 20]</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to sort a list of objects and keep null objects at the end</h1>
                
            
            
                
<p>We have already seen how to sort a list based on a specified parameter using a comparator. However, so far, we have worked with lists having non-null values. In this recipe, we will see how to sort a list of objects, which have the null property (on which we are sorting). So let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's follow these steps to sort a list, while keeping null objects at the end:</p>
<ol>
<li>Let's create a <kbd>Person</kbd> class having an age property that can be null:</li>
</ol>
<pre style="padding-left: 60px">class Person(var age:Int?)</pre>
<ol start="2">
<li>Now, let's create a list of <kbd>Person</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">val listOfPersons=listOf(Person(10), Person(20), Person(2), Person(null))</pre>
<ol start="3">
<li>Finally, we want to sort them in ascending order, while keeping the null items at the end:</li>
</ol>
<pre style="padding-left: 60px">val sortedList=listOfPersons.sortedWith(compareBy(nullsLast&lt;Int&gt;(),{it.age}))<br/>sortedList.forEach {<br/>    print(" ${it.age} ")<br/>}<br/><br/></pre>
<p style="padding-left: 60px">The output is as follows:</p>
<pre style="padding-left: 60px"><strong>2 10 20 null</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>We have used the <kbd>sortedWith</kbd> method. According to documentation, <kbd>sortedWith</kbd> does this:</p>
<p>Returns a sequence that yields elements of this sequence sorted according to the specified comparator.</p>
<p>Apart from that, we've made use of the <kbd>kotlin.comparisons</kbd> package, which provides us two main functions used in the preceding solution:</p>
<ul>
<li><kbd>public inline fun &lt;T: Comparable&lt;T&gt;&gt; nullsLast()</kbd>: This method provides a comparator of nullable comparable values considering null value greater than any other value. That's how we can get the null items at the end, because they are considered bigger than any other values.</li>
<li><kbd>compareBy(comparator: Comparator&lt;in K&gt;, crossinline selector: (T) -&gt; K)</kbd>: This function accepts a comparator (such as <kbd>nullsLast()</kbd>) and a function that provides values for the comparator, and then combines them into a new comparator.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">How to implement a lazy list in Kotlin</h1>
                
            
            
                
<p>If the value of an element or expression is not evaluated when it's defined, but rather when it is first accessed, it is said to be <strong>lazily evaluated</strong>. There are many situations where it comes in handy. For example, you might have a list A and you want to create a filtered list from it, let's call it list B. If you do something like the following, the filter operation will be performed during the declaration of B:</p>
<pre>val A= listOf(1,2,3,4)<br/>var B=A.filter {<br/>    it%2==0<br/>}</pre>
<p>This forces the program to initialize B as soon as it is defined. While this may not be a big deal for a small list, it can cause latency with bigger objects. Also, we can delay the object creation until we first need it. In this recipe, we will learn how we can implement a lazy list.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To create a lazy list, we need to convert the list into a sequence. A sequence represents lazily evaluated collections. Let's understand it with an example:</p>
<ol>
<li>In the given example, let's first filter a list based on elements being odd or even:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val A= listOf(1,2,3,4)<br/>    var B=A.filter {<br/>        println("checking ${it}")<br/>        it%2==0<br/>    }<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px"><strong>checking 1</strong><br/><strong>checking 2</strong><br/><strong>checking 3</strong><br/><strong>checking 4</strong></pre>
<p style="padding-left: 60px">In the preceding example, the filter function was evaluated only when the object was defined.</p>
<ol start="2">
<li>Now, let's convert the list into a sequence. Converting the list to a sequence is just one step away; you can convert any list to a sequence using the <kbd>.asSequence()</kbd> method, or by <kbd>Sequence{ createIterator() }</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val A= listOf(1,2,3,4).asSequence()<br/>    var B=A.filter {<br/>        println("checking ${it}")<br/>        it%2==0<br/>    }<br/>}</pre>
<ol start="3">
<li>If you run the preceding code, you won't see any output in the console, because the object hasn't been created yet. It will be created when list B is first accessed:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val A= listOf(1,2,3,4).asSequence()<br/>    var B=A.filter {<br/>        println("checking ${it}")<br/>        it%2==0<br/>    }<br/>    B.forEach {<br/>        println("printing ${it}")<br/>    }<br/>}<br/><br/>//Output:<strong>checking 1</strong><br/><strong>         checking 2</strong><br/><strong>         printing 2</strong><br/><strong>         checking 3</strong><br/><strong>         checking 4</strong><br/><strong>         printing 4</strong></pre>
<p>The <kbd>filter</kbd> function was evaluated when the items were accessed. This is called <strong>lazy evaluation</strong>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Sequences in Kotlin are potentially unbounded and are used when the length of the list is not known in advance (much like Streams in Java 8). Since it can be infinite, lazy evaluation is needed for this type of structure. Consider this example:</p>
<pre>val seq= generateSequence(1){it*2}<br/>seq.take(10).forEach {<br/>    print(" ${it} ")<br/>}</pre>
<p>Here, <kbd>generateSequence</kbd> generates a sequence of infinite numbers, but when we call <kbd>take(10)</kbd>, only 10 items are evaluated and printed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to pad a string in Kotlin</h1>
                
            
            
                
<p>Sometimes, to keep up with the length of the string, we pad the string with some characters. In many communication protocols, keeping the standard length of the payload is vital.  Kotlin makes it very easy to pad the string with any character and length. Let's see how to use it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In this recipe, we will use the <kbd>kotlin.stdlib</kbd> library of Kotlin. Specifically, we will be working with the <kbd>padStart</kbd> and <kbd>padEnd</kbd> functions. Let's now follow the given steps to understand how to use these functions:</p>
<ol>
<li>Let's see an example of the <kbd>padStart</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val string="abcdef"<br/>    val pad=string.padStart(10,'-')<br/>    println(pad)<br/>}</pre>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px"><strong> ----abcdef</strong></pre>
<ol start="2">
<li class="mce-root">Next, we look at an example of <kbd>padEnd</kbd>:<em><br/></em></li>
</ol>
<pre style="padding-left: 60px">val string="abcdef"<br/>val pad=string.padEnd(10,'-')<br/>println(pad)</pre>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong> abcdef----</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The padding functions are needed to expand the string to a certain length using the character provided with the function. So, if the length of the padded string is less than the string itself, it will just return the same string.</p>
<p>Another key thing to note is that by default, the padding character is a space character. This is the implementation of the <kbd>padStart</kbd> function:</p>
<pre>public fun String.padStart(length: Int, padChar: Char = ' '): String<br/>        = (this as CharSequence).padStart(length, padChar).toString()</pre>
<p>As you can see, the default value for <kbd>padChar</kbd> is a space character, and it is called on a String object.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to flatten an array or map</h1>
                
            
            
                
<p>In the previous few recipes of this chapter, we learned how to create multidimension arrays. In this recipe, we will see how we can convert them to a 1D list, or <em>flatten</em> it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>We will be using the <kbd>.flatten</kbd> method of the <kbd>kotlin.stdlib</kbd> library. It takes in an array or collection and returns a single list of all elements from all collections/arrays in the given collection/array.</p>
<p>For example, with an array of arrays:</p>
<p><kbd>[[1,2,3],[1,2,3],[1,2,3]] -&gt; [1,2,3,1,2,3,1,2,3]</kbd></p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val a= arrayOf(arrayOf(1,2,3),arrayOf(1,2,3),arrayOf(1,2,3))<br/>    a.flatten().forEach { print(" ${it} ") }<br/>}<br/><br/>//Output: <strong> 1 2 3 1 2 3 1 2 3</strong> </pre>
<p class="mce-root">For example, with a list of lists:</p>
<p><kbd>[[1,2,3],[1,2,3],[1,2,3]] -&gt; [1,2,3,1,2,3,1,2,3]</kbd></p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val a= listOf(listOf(1,2,3),listOf(1,2,3),listOf(1,2,3))<br/>    a.flatten().forEach { print(" ${it} ") }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Let's take a look at the implementation of the <kbd>flatten()</kbd> function:</p>
<pre>public fun &lt;T&gt; Iterable&lt;Iterable&lt;T&gt;&gt;.flatten(): List&lt;T&gt; {<br/>    val result = ArrayList&lt;T&gt;()<br/>    for (element in this) {<br/>        result.addAll(element)<br/>    }<br/>    return result<br/>}</pre>
<p class="mce-root">As you can see, it's just adding the items from iterables (array or lists) in a new list and returning that list.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to sort collection by multiple fields in Kotlin</h1>
                
            
            
                
<p>In this recipe, we will learn how to sort a collection by multiple fields in Kotlin. This often comes in handy when we want to give precedence to an object over another object when both have equal value on a specific property. For example, we might have a list of <kbd>Student</kbd> objects and want to arrange them in ascending order of age, but if two students have the same age, we will order them based on their GPA. In this recipe, we will see how to handle use cases like this. So let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's follow these steps to sort based on multiple fields of an object:</p>
<ol>
<li>First, let's create the <kbd>Student</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class Student(val age:Int, val GPA: Double)</pre>
<ol start="2">
<li>Then, create a list of <kbd>Student</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">val studentA=Student(11,2.0)<br/>val studentB=Student(11,2.1)<br/>val studentC=Student(11,1.3)<br/>val studentD=Student(12,1.3)<br/>val studentsList=listOf&lt;Student&gt;(studentA,studentB,studentC,studentD)</pre>
<ol start="3">
<li>To sort it on multiple fields, we simply need to do this:</li>
</ol>
<pre style="padding-left: 60px">val sortedList=studentsList.sortedWith(compareBy({it.age},{it.GPA}))</pre>
<ol start="4">
<li>If we print it now, we will get the following output:</li>
</ol>
<pre style="padding-left: 60px">sortedList.forEach {<br/>    println("age: ${it.age}, GPA: ${it.GPA} ")<br/>}<br/><br/>//Output: <strong>age: 11, GPA: 1.3 </strong><br/><strong>          age: 11, GPA: 2.0 </strong><br/><strong>          age: 11, GPA: 2.1 </strong><br/><strong>          age: 12, GPA: 1.3</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>We have used the <kbd>sortedWith</kbd> function, which takes in a comparator. The comparator is provided by the <kbd>compareBy</kbd> function. The <kbd>compareBy</kbd> has an overload that takes multiple functions:</p>
<pre>public fun &lt;T&gt; compareBy(vararg selectors: (T) -&gt; Comparable&lt;*&gt;?):Comparator&lt;T&gt;</pre>
<p>As you can see in the preceding code, <kbd>vararg</kbd> allows us to take multiple functions in its construct and returns a comparator, which feeds the <kbd>sortedWith</kbd> function.</p>
<p>Note that sorting with multiple fields works like sort by field 1, then by field 2, then by field 3, and so on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to use limit in Kotlin list</h1>
                
            
            
                
<p>In this recipe, we will learn how to take specific items from the list. We will use the <kbd>kotlin.stdlib</kbd> library for this purpose.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>We will be using the <kbd>take</kbd> function and its variants for limiting the items in the list.</p>
<p><kbd>take(n)</kbd>: Returns a list of the first n items:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf(1,2,3,4,5)<br/>    val limitedList=list.take(3)<br/>    println(limitedList)<br/>}<br/><br/>//Output:<strong> [1,2,3]</strong></pre>
<p><kbd>takeLast(n)</kbd>: Returns a list containing the last [n] elements:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf(1,2,3,4,5)<br/>    val limitedList=list.takeLast(3)<br/>    println(limitedList)<br/>}<br/><br/>//Output:<strong> [3,4,5]</strong></pre>
<p><kbd>takeWhile{ predicate }</kbd>: Returns a list containing the first elements satisfying the given [predicate]:</p>
<pre>val list= listOf(1,2,3,4,5)<br/>val limitedList=list.takeWhile { it&lt;3 }<br/>println(limitedList)<br/><br/>//Output: <strong>[1,2]</strong></pre>
<p><kbd>takeLastWhile{predicate}</kbd>: Works a bit like <kbd>takeWhile</kbd>, except that it evaluates the list from the end.</p>
<p><kbd>takeIf { predicate }</kbd>: Returns <kbd>`this`</kbd> value if it satisfies the given [predicate], or <kbd>`null`</kbd> if it doesn't:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf(1,2,3,4,5)<br/>    var limitedList=list.takeIf { it .contains(1) }<br/>    println(limitedList)<br/>}<br/><br/>//Output: <strong>[1,2,3,4,5]</strong></pre>
<p>Note that the <kbd>it</kbd> inside the <kbd>takeIf</kbd> lambda represents the list itself, and not just an element of list.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to create a 2D array in Kotlin</h1>
                
            
            
                
<p>2D arrays are useful for data representation in certain situations such as board games, images, and so on. In Java, we can represent a 2D array by doing the following:</p>
<pre>int[][] data = new int[size][size];</pre>
<p class="mce-root">Since Kotlin brings new syntax, let's see how to work with a 2D array in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's now follow the given steps to create a 2D array in Kotlin:</p>
<ol>
<li>We can create a simple 2D array in Kotlin using this syntax:</li>
</ol>
<pre style="padding-left: 60px">val array = Array(n, {IntArray(n)})</pre>
<p style="padding-left: 60px">Here, <kbd>n</kbd> represents the dimension of the array. Here, we have used the <kbd>Array</kbd> class of Kotlin, which represents an array (specifically, a Java array when targeting the JVM platform). We have initialized the <kbd>Array</kbd> object by passing the size and initializer:</p>
<pre style="padding-left: 60px">public inline constructor(size: Int, init: (Int) -&gt; T)</pre>
<ol start="2">
<li>Our dimension is <kbd>n</kbd>, and as an initializer, we are passing a 1D array, which then gives a structure of a 2D array. If you want to initialize the 2D array with a specific value, you need to pass it in the initializer. Consider this example:</li>
</ol>
<pre style="padding-left: 60px">Array&lt;IntArray&gt;(10,{IntArray(10,{-1})})</pre>
<ol start="3">
<li>The preceding 2D array will be initialized by all <kbd>-1</kbd>.</li>
<li>We can also use the <kbd>arrayOf</kbd> construct to create a 2D array by passing two 1D arrays:</li>
</ol>
<pre style="padding-left: 60px">val even: IntArray = intArrayOf(2, 4, 6)<br/>val odd: IntArray = intArrayOf(1, 3, 5)<br/><br/>val lala: Array&lt;IntArray&gt; = arrayOf(even, odd)<br/>lala.forEach {<br/>    it.forEach {<br/>        print(" ${it} ")<br/>    }<br/>    println()<br/>}<br/><br/>//Output:<strong> 2 4 6 </strong><br/><strong>          1 3 5</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>You can also create your own function by extending Kotlin's code. For example, creating a method, as follows:</p>
<pre>inline fun &lt;reified inside&gt; array2d(sizeOuter: Int, sizeInner: Int, noinline innerInit: (Int)-&gt;inside): Array&lt;Array&lt;inside&gt;&gt;<br/>       = Array(sizeOuter) { Array&lt;inside&gt;(sizeInner, innerInit) }</pre>
<p>This can enable you to create a 2D array quite easily, just by doing the following:</p>
<pre>array2d(10,10,{0})</pre>
<p>You can also create a list of lists in a similar fashion. Here's an example of a list of lists:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val a= listOf(listOf(1,2,3), listOf(4,5,6), listOf(7,8,9))<br/>    a.forEach {<br/>        print(" ${it} ")<br/>    }<br/>}<br/><br/></pre>
<p>This is its output:</p>
<pre><strong>[1, 2, 3] [4, 5, 6] [7, 8, 9]</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to skip the first "n" entries in Kotlin</h1>
                
            
            
                
<p>In this recipe, we will learn how to drop entries in a collection. First, we will see how to drop the first <em>n</em> items, then we will see how to drop the last <em>n</em> items, and finally, we will see how to use a predicate while dropping the elements from the collection.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free to use any IDE that can do the same task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn to skip the first <em>n</em> entries of a Kotlin list:</p>
<ol>
<li>First, let's see how to drop the first <em>n</em> items in a collection. We will be using a list, but it also works with an array. Also, we will be using <kbd>kotlin.stdlib</kbd>, which contains the functions required in this recipe. The function to use here is <kbd>drop</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9)<br/>    var droppedList=list.drop(2)<br/>    droppedList.forEach {<br/>        print(" ${it} ")<br/>    }<br/>}<br/><br/>//Output: <strong>3 4 5 6 7 8 9</strong> </pre>
<ol start="2">
<li>To skip the last <em>n</em> items in the collection, you need to use the <kbd>dropLast</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9)<br/>    var droppedList=list.dropLast(2)<br/>    droppedList.forEach {<br/>        print(" ${it} ")<br/>    }<br/>}<br/><br/>//Output: <strong> 1 2 3 4 5 6 7</strong> </pre>
<ol start="3">
<li>This lambda function drops the item while the predicate returns true:</li>
</ol>
<pre style="padding-left: 60px">val list= listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9,1,2,3)<br/>val droppedList=list.dropWhile { it&lt;3 }<br/>droppedList.forEach {<br/>    print(" ${it} ")<br/>}<br/><br/>//Output: <strong> 3 4 5 6 7 8 9 1 2 3</strong> </pre>
<ol start="4">
<li>This function drops the items at the end while the condition is satisfied.</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val list= listOf&lt;Int&amp;gt;(1,2,3,4,5,6,7,8,9,3,1,2)<br/>    val droppedList=list.dropLastWhile { it&lt;3 }<br/>    droppedList.forEach {<br/>        print(" ${it} ")<br/>    }<br/>}<br/><br/>//Output:<strong>  1 2 3 4 5 6 7 8 9 3</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The <kbd>drop</kbd> function returns a new list by skipping the first n items. Internally, it just uses the usual <kbd>for</kbd> loops and performs some checks on whether the input is an array or a list.</p>
<p class="mce-root"/>


            

            
        
    </div>



  </body></html>