- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Libraries Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库管理
- en: So far, we have discussed the code *we write* – Swift, UIKit, and SwiftUI. But
    modern developers’ work doesn’t simply amount to writing code. Knowing how to
    integrate code can be a productivity multiplier, greatly enhancing our efficiency
    and allowing us to accomplish more in less time than simply knowing how to code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 *我们编写的代码* - Swift、UIKit 和 SwiftUI。但现代开发者的工作并不仅仅是编写代码。了解如何集成代码可以是一个生产力倍增器，大大提高我们的效率，并使我们能够在更短的时间内完成更多的工作，而不仅仅是知道如何编码。
- en: '*CocoaPods* and the *Swift Package Manager* are the leading solutions we have
    today for managing third-party and local dependencies. It is essential for any
    iOS developer to understand these tools thoroughly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**CocoaPods** 和 *Swift 包管理器* 是我们今天管理第三方和本地依赖项的主要解决方案。对于任何 iOS 开发者来说，彻底理解这些工具是至关重要的。'
- en: 'This chapter covers CocoaPods and the Swift Package Manager in terms of the
    following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从以下主题的角度涵盖了 CocoaPods 和 Swift 包管理器：
- en: Learning *how CocoaPods is built*, including different components such as **Podfile**
    and **Podspec** files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 *CocoaPods 的构建方式*，包括如 **Podfile** 和 **Podspec** 文件等不同组件
- en: Going over *CocoaPods’ best practices* and use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述 *CocoaPods 的最佳实践* 和用例
- en: Covering the Swift Package Manager *creation process*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖 Swift 包管理器的 *创建过程*
- en: Learning the Swift Package Manager’s *common commands*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Swift 包管理器的 *常用命令*
- en: Learning how to *use a Swift Package* in our projects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在我们的项目中 *使用 Swift 包*
- en: Going over the *different advantages* the Swift Package Manager has compared
    to CocoaPods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 Swift 包管理器与 CocoaPods 的 *不同优势*
- en: '*Organizing our projects* with the Swift Package Manager'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swift 包管理器 *组织我们的项目*
- en: This is a “simple” chapter, yet it is a crucial topic in today’s iOS development
    world. Let’s start with CocoaPods as our first dependency manager.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个“简单”的章节，然而，在当今的 iOS 开发世界中，它是一个至关重要的主题。让我们从 CocoaPods 作为我们的第一个依赖管理器开始。
- en: Mastering CocoaPods
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通 CocoaPods
- en: '**CocoaPods** is one of the most popular dependency managers for iOS developers
    and has been maintained for many years as an open source project.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**CocoaPods** 是 iOS 开发者中最受欢迎的依赖管理器之一，并且作为一个开源项目已经维护了多年。'
- en: CocoaPods is often the first choice for many library developers and has a massive
    collection of frameworks that can be easily integrated with iOS projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CocoaPods 经常是许多库开发者的首选，并且拥有大量可以轻松集成到 iOS 项目中的框架。
- en: Besides having a vast collection of frameworks, CocoaPods supports integration
    with local frameworks. It can help us modularize our project to different libraries
    and make it more flexible and organized.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有大量的框架之外，CocoaPods 还支持与本地框架的集成。它可以帮助我们将项目模块化到不同的库中，使其更加灵活和有序。
- en: Let’s see how CocoaPods works and how it is built.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CocoaPods 的工作原理以及它是如何构建的。
- en: Learning how CocoaPods is built
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何构建 CocoaPods
- en: When we use CocoaPods to manage dependencies in our Xcode project, CocoaPods
    creates a new workspace, which includes both our project and any dependencies
    we specified in our `Podfile` file. CocoaPods creates this workspace automatically
    when we run the `pod` `install` command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 CocoaPods 在 Xcode 项目中管理依赖项时，CocoaPods 会创建一个新的工作区，该工作区包括我们的项目以及我们在 `Podfile`
    文件中指定的任何依赖项。当我们运行 `pod install` 命令时，CocoaPods 会自动创建此工作区。
- en: Xcode Workspace
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 工作区
- en: In Xcode, a workspace is a container for one or more Xcode projects and any
    other files and resources needed to build our app. Workspaces are used to organize
    and manage the different components of our app and make it easier to develop and
    test our code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，工作区是一个用于存放一个或多个 Xcode 项目以及构建我们的应用程序所需的任何其他文件和资源的容器。工作区用于组织和管理我们应用程序的不同组件，使开发测试我们的代码更加容易。
- en: Using a workspace in CocoaPods has several benefits. It simplifies dependency
    management by including the project and its dependencies in the same workspace,
    simplifies integration, and follows the separation of concern principle by keeping
    the dependencies up to date, regardless of our main project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CocoaPods 中使用工作区有几个好处。它通过将项目和其依赖项包含在同一个工作区中来简化依赖项管理，简化集成，并通过保持依赖项更新来遵循关注点分离原则，无论我们的主项目如何。
- en: Besides the workspace, CocoaPods comprises several different components, each
    of which plays a role in managing dependencies for iOS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工作区之外，CocoaPods 还包含几个不同的组件，每个组件都在管理 iOS 的依赖项中扮演着角色。
- en: Here are some of the key components of CocoaPods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 CocoaPods 的一些关键组件。
- en: Podfile
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Podfile
- en: '`Podfile` is a file that specifies which dependencies are required for our
    project. It uses a simple Ruby syntax to declare each pod’s name and version number,
    as well as any options or configurations needed. `Podfile` is typically located
    in a project’s root directory.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podfile` 是一个文件，它指定了我们项目所需的依赖项。它使用简单的 Ruby 语法声明每个 pod 的名称和版本号，以及任何需要的选项或配置。`Podfile`
    通常位于项目的根目录中。'
- en: 'Here’s an example of a `Podfile` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `Podfile` 文件的例子：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s understand how the file is built:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解文件是如何构建的：
- en: The platform to target is iOS 16.0
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要针对的平台是 iOS 16.0
- en: The target of **Podfile** is an Xcode project called **MyApp**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podfile** 的目标是名为 **MyApp** 的 Xcode 项目。'
- en: The **use_frameworks!** directive tells CocoaPods to build the dependencies
    as **dynamic frameworks**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**use_frameworks!** 指令告诉 CocoaPods 将依赖项构建为 **动态框架**。'
- en: The pod directives specify the two dependencies for the project, **Alamofire**
    and **SwiftyJSON**, along with their version requirements
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pod 指令指定了项目的两个依赖项，**Alamofire** 和 **SwiftyJSON**，以及它们的版本要求。
- en: The `~>` operator is an **optimistic operator**, which is used to specify a
    version for the pod and allows it to be updated to the next major version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`~>` 操作符是一个 **乐观操作符**，用于指定 pod 的版本，并允许它更新到下一个主要版本。'
- en: 'For example, look at the following row:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下行：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, CocoaPods will install and update the `Alamofire` pod up to version
    6.0 (not including 6.0 itself). This allows us to enjoy hotfixes and minor versions
    without breaking backward compatibility.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，CocoaPods 将安装和更新 `Alamofire` pod 到版本 6.0（不包括 6.0 本身）。这允许我们享受热修复和次要版本，而不会破坏向后兼容性。
- en: '`Podfile` is our project configuration file for all our dependencies and must
    be maintained carefully.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podfile` 是我们所有依赖项的项目配置文件，必须仔细维护。'
- en: Podfile.lock
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Podfile.lock
- en: '`Podfile.lock` is a file that stores information about the specific versions
    of the dependencies installed in our project. It ensures that the same dependencies’
    versions are installed on every machine, which helps prevent version conflicts
    and other issues.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podfile.lock` 是一个文件，它存储了我们项目中安装的依赖项的具体版本信息。它确保在每台机器上安装相同的依赖项版本，这有助于防止版本冲突和其他问题。'
- en: 'Here’s how it looks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: CocoaPods automatically generates `Podfile.lock` when we run `pod update` or
    `pod install`, and we shouldn’t update it manually, as it can cause conflicts
    and issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `pod update` 或 `pod install` 时，CocoaPods 会自动生成 `Podfile.lock`，我们不应该手动更新它，因为它可能导致冲突和问题。
- en: The Pods directory
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pods 目录
- en: The `Pods` directory is a directory that contains all the dependencies installed
    by CocoaPods for our project. It includes each pod’s source code, headers, and
    compiled binaries.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pods` 目录是一个包含 CocoaPods 为我们的项目安装的所有依赖项的目录。它包括每个 pod 的源代码、头文件和编译的二进制文件。'
- en: Podspec
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Podspec
- en: A `Podspec` is a file that describes a single pod, including its name, version,
    source code location, dependencies, and other metadata. Podspecs are published
    to the CocoaPods repository and used by CocoaPods to download and install a pod.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podspec` 是一个文件，它描述了一个单独的 pod，包括其名称、版本、源代码位置、依赖项和其他元数据。Podspecs 发布到 CocoaPods
    仓库，并由 CocoaPods 用于下载和安装 pod。'
- en: 'Let’s see an example of a podspec file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 podspec 文件的例子：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The podspec file is written in Ruby, a dynamic and object-oriented programming
    language. In fact, the `Podfile` file is also written in Ruby, as it is considered
    a convenient and popular way to write configuration files for frameworks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: podspec 文件是用 Ruby 编写的，Ruby 是一种动态的面向对象的编程语言。实际上，`Podfile` 文件也是用 Ruby 编写的，因为它被认为是编写框架配置文件的方便且流行的方式。
- en: The podspec file, in this example, describes a library named `MyLibrary` with
    a version of `1.0.0`. We can also see a summary, a description, and other general
    details, such as the home page, license, and author.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，podspec 文件描述了一个名为 `MyLibrary` 的库，版本为 `1.0.0`。我们还可以看到摘要、描述和其他一般细节，例如主页、许可证和作者。
- en: In the source and source files, we can see where the Git repository is located
    (in this case, in GitHub) and what files are included in the pod in the **wildcard
    pattern**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件和源代码中，我们可以看到 Git 仓库的位置（在这个例子中，在 GitHub 上）以及 pod 中包含的文件在 **通配符模式** 下的位置。
- en: The wildcard pattern
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式
- en: In Podfile, a wildcard pattern can be used to define directories where the pods
    should be installed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podfile 中，可以使用通配符模式来定义 pod 应该安装的目录。
- en: 'The wildcard pattern (“*****”) represents any character to match any file or
    directory. For example, if we want to specify all directories that start with
    “M,” we can use the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式（“*****”）代表任何字符以匹配任何文件或目录。例如，如果我们想指定所有以“M”开头的目录，我们可以使用以下命令：
- en: '**Pod "MyPod", :path => "****M*"**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pod "MyPod", :path => "****M*"**'
- en: The wildcard pattern is not a Podfile-only pattern – it is used in many Unix-like
    command-line tools and terminals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式不是Podfile特有的模式——它在许多类Unix命令行工具和终端中都有使用。
- en: Finally, we add the dependencies our pod requires so that CocoaPods will know
    to manage its dependencies tree accordingly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了pod所需的依赖项，这样CocoaPods就会知道相应地管理其依赖关系树。
- en: 'It is important to note that we can easily use a podspec file to create a local
    library and integrate it with our project. Here’s a podspec file example for a
    local library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们可以轻松地使用一个podspec文件来创建一个本地库并将其集成到我们的项目中。以下是一个本地库的podspec文件示例：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Apart from modifying our `source` and `source_files` attributes, we can also
    see that we now have a `pod_target_xcconfig` attribute to specify the path to
    the source code for the module in our project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了修改我们的`source`和`source_files`属性外，我们还可以看到我们现在有一个`pod_target_xcconfig`属性来指定项目中模块的源代码路径。
- en: '`Podfile`, in this case, will look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podfile`在这种情况下将看起来像这样：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `Podfile`, we direct `MyFramework` to its local path, where the source file
    exists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Podfile`中，我们指导`MyFramework`到其本地路径，其中存在源文件。
- en: Pod command-line tool
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod命令行工具
- en: The pod command-line tool is the primary interface for working with CocoaPods.
    It provides a command set that allows us to install, update, and manage dependencies
    for our project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: pod命令行工具是处理CocoaPods的主要接口。它提供了一套命令，允许我们安装、更新和管理项目的依赖项。
- en: 'These are some commonly used commands we can use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以使用的一些常用命令：
- en: '**pod install**: This command installs the dependencies specified in **Podfile**
    and generates an Xcode workspace, containing our project and the installed dependencies.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pod install**：这个命令安装**Podfile**中指定的依赖项并生成一个Xcode工作空间，其中包含我们的项目和已安装的依赖项。'
- en: '**pod update**: This command updates the dependencies specified in **Podfile**
    to their latest versions and installs them. We can select a specific pod or a
    list of pods to update.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pod update**：这个命令将**Podfile**中指定的依赖项更新到最新版本并安装。我们可以选择更新特定的库或一系列库。'
- en: '**pod lib create**: This command generates a new CocoaPods library template.
    We can use it to quickly set up a new pod’s directory structure, files, and configuration.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pod lib create**：这个命令生成一个新的CocoaPods库模板。我们可以用它快速设置新pod的目录结构、文件和配置。'
- en: '**pod search**: This command searches the CocoaPods repository for pods that
    match a given query. We can search for pods by name, description, author, or other
    criteria.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pod search**：这个命令在CocoaPods仓库中搜索与给定查询匹配的库。我们可以通过名称、描述、作者或其他标准来搜索库。'
- en: Like many development tools, CocoaPods is based on command-line tools, configuration
    files, and a terminal, so “terminal-phobia” is not recommended in the case of
    CocoaPods!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多开发工具一样，CocoaPods基于命令行工具、配置文件和终端，因此在CocoaPods的情况下不建议有“终端恐惧症”。
- en: We discussed five different CocoaPods components for managing and understanding
    CocoaPods. If you have never used CocoaPods before or didn’t create your pod,
    it’s a good idea to create a new project and play with it, followed by reading
    the CocoaPods documentation, which is clear and straightforward. I promise you
    that things will be much easier to understand after an hour.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了五个不同的CocoaPods组件，用于管理和理解CocoaPods。如果你以前从未使用过CocoaPods或者没有创建过你的pod，创建一个新的项目并尝试使用它是一个好主意，然后阅读CocoaPods文档，它清晰且直接。我保证，一个小时后你会更容易理解。
- en: Now, let’s jump into two questions about CocoaPods that we may encounter in
    an interview.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳入两个可能在面试中遇到的问题，关于CocoaPods的。
- en: “What best practices do you follow when working with CocoaPods, and why are
    they important?”
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你在使用CocoaPods时遵循哪些最佳实践，为什么它们很重要？”
- en: '*Why is this* *question important?*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: CocoaPods, or any other dependencies manager for that matter, is an essential
    part of a project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CocoaPods或任何其他依赖关系管理器都是项目的一个基本组成部分。
- en: 'In a way, we can even say *it’s the vulnerable part of our project* for a few
    reasons:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们甚至可以说这是我们的项目中的**脆弱部分**，原因有几个：
- en: '**It’s not code we have written ourselves**: CocoaPods integrates thousands
    of lines of code that other developers wrote into our project. We have little
    control over the security, performance, and stability effect of adding code someone
    else writes. However, it will have probably gone through many fixes and testing
    cycles.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这不是我们自己编写的代码**：CocoaPods将其他开发者编写的数千行代码集成到我们的项目中。我们对添加他人编写的代码对安全性、性能和稳定性产生的影响几乎没有控制权。然而，这些代码可能已经经过多次修复和测试周期。'
- en: '**There’s a potential for dependencies conflicts**: A poorly structured **Podfile**
    can cause conflicts between different versions of dependencies and may harm a
    project’s stability.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存在依赖项冲突的潜在风险**：一个结构不良的**Podfile**可能导致不同版本的依赖项之间发生冲突，并可能损害项目的稳定性。'
- en: '**Outdated frameworks can cause security breaches**: Developers often lock
    frameworks to specific versions to keep their project stability high. This can
    lead to obsolete code with security and stability issues.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过时的框架可能导致安全漏洞**：开发者经常锁定框架到特定版本以保持项目稳定性高。这可能导致具有安全和稳定性问题的过时代码。'
- en: Because of the reasons I just described, a well-structured `Podfile` tremendously
    affects our project quality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我刚才提到的这些原因，一个结构良好的`Podfile`极大地影响我们的项目质量。
- en: '*What is* *the answer?*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'We can follow a few best practices when working with CocoaPods:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用CocoaPods时，可以遵循一些最佳实践：
- en: '**Keeping our frameworks up to date**: We need to ensure we get the latest
    bug fixes and features to keep our project stable. The **~>** operator I mentioned
    earlier is recommended to get the latest hotfixes and minor versions.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持我们的框架更新**：我们需要确保我们获得最新的错误修复和功能，以保持项目稳定。我之前提到的`~>`运算符建议用于获取最新的热修复和次要版本。'
- en: '**Understanding semantic versioning**: Keeping frameworks up to date is essential.
    However, we should understand how semantic versioning works. We want to ensure
    backward compatibility and avoid breaking changes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解语义版本控制**：保持框架更新至关重要。然而，我们应该了解语义版本控制是如何工作的。我们希望确保向后兼容性并避免破坏性更改。'
- en: '**Keeping dependencies at a minimum**: We should only include frameworks that
    we really need in our project and remove those that the Apple SDK can replace.
    Keeping our project light and simple is vital, avoiding potential issues such
    as conflicts and crashes.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持依赖项的最小化**：我们应该只包含我们真正需要的框架，并移除那些Apple SDK可以替换的框架。保持我们的项目轻量级和简单至关重要，避免潜在的冲突和崩溃问题。'
- en: '**Keeping our Podfile organized and readable**: We should treat our **Podfile**
    as part of our code base. Grouping dependencies in a logical way can provide us
    with flexibility and clarity. Another best practice here is to add comments next
    to each pod and explain why we added each pod. Pods can live in our app for years,
    and the comments we add can help us in the future.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持Podfile的整洁和可读性**：我们应该将我们的**Podfile**视为代码库的一部分。以逻辑方式分组依赖项可以为我们提供灵活性和清晰度。在此处的一个最佳实践是在每个库旁边添加注释并解释我们为什么添加每个库。库可能在我们应用中存在多年，我们添加的注释可以帮助我们在未来。'
- en: '**Implementing the adapter pattern**: While the adapter pattern is not unique
    to CocoaPods, it is an excellent pattern for integrating a pod into our project
    seamlessly. Often, the pod’s interface does not naturally align with our existing
    code base. By introducing a class that acts as an interface between our code base
    and the library, we can effectively connect these two components. Additionally,
    the adapter can assist in decoupling our code base from the pod and reducing dependencies.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现适配器模式**：虽然适配器模式并非CocoaPods独有，但它是一个将库无缝集成到我们项目中的优秀模式。通常，库的接口与我们的现有代码库并不自然地匹配。通过引入一个充当我们的代码库和库之间接口的类，我们可以有效地连接这两个组件。此外，适配器还可以帮助我们解耦代码库和库，减少依赖。'
- en: We must remember something important – pods are part of our code. We should
    take care of our third-party frameworks with the same attention that we manage
    our project code base with, as they tremendously affect how our project performs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住一个重要的事情——库是我们代码的一部分。我们应该像管理我们的项目代码库一样关注第三方框架，因为它们极大地影响我们项目的性能。
- en: “What is the difference between pod update and pod install?”
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “pod update和pod install有什么区别？”
- en: '*Why is this* *question important?*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个* *问题为什么重要？*'
- en: In the previous question, we talked about best practices for managing CocoaPods.
    One crucial aspect we covered was managing pods to prevent them from causing any
    issues or breaking our code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，我们讨论了管理 CocoaPods 的最佳实践。我们讨论的一个关键方面是管理 pods，以防止它们引起任何问题或破坏我们的代码。
- en: Both the `pod update` and `pod install` commands help us to decide our strategy
    to update our pods, implementing a careful and responsible way to keep our third-party
    libraries up to date.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod update` 和 `pod install` 命令都帮助我们决定更新 pods 的策略，实现一种谨慎和负责任的方式来保持第三方库的更新。'
- en: '*What is* *the answer?*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: '`pod install` and `pod update` are commands used in the CocoaPods dependency
    manager for iOS projects. The main difference between them is how they handle
    dependency resolution.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod install` 和 `pod update` 是在 iOS 项目的 CocoaPods 依赖管理器中使用的命令。它们之间的主要区别在于它们处理依赖解析的方式。'
- en: '`pod install` installs the dependencies specified in `Podfile.lock` and ensures
    that a pod won’t receive unintended updates.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod install` 安装 `Podfile.lock` 中指定的依赖项，并确保 pod 不会收到意外的更新。'
- en: On the other hand, `pod update` updates the current pods to the latest minor
    version and, ultimately, updates `Podfile.lock` to the new version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`pod update` 将当前 pods 更新到最新的次要版本，并最终将 `Podfile.lock` 更新到新版本。
- en: One thing to note is that if there is no `Podfile.lock`, *both commands* *behave
    similarly*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，如果没有 `Podfile.lock`，*这两个命令* *表现相似*。
- en: The difference between the commands in day-to-day work is critical. `Podfile.lock`
    helps us control our framework’s updates and keeps our pods in a specific version,
    as long as we use `pod install`, whereas `pod update` can bypass what’s written
    in `Podfile.lock`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中，这两个命令之间的区别至关重要。`Podfile.lock` 帮助我们控制框架的更新，并保持 pods 在特定版本，只要我们使用 `pod
    install`，而 `pod update` 可以绕过 `Podfile.lock` 中写的内容。
- en: I advise including `Podfile.lock` in a project’s code base when discussing best
    practices. This is particularly crucial when collaborating with a team, as `Podfile.lock`
    guarantees that all team members use identical framework versions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在讨论最佳实践时将 `Podfile.lock` 包含在项目的代码库中。这在与团队协作时尤其重要，因为 `Podfile.lock` 确保所有团队成员使用相同的框架版本。
- en: To summarize this section, by now, we should understand how CocoaPods works
    and how to use it to link third-party libraries and maintain a stable and robust
    project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节，到现在为止，我们应该了解 CocoaPods 的工作原理以及如何使用它来链接第三方库并维护一个稳定和健壮的项目。
- en: As an essential tool to manage dependencies in iOS projects, CocoaPods should
    be treated with the utmost importance. This applies to any dependency manager,
    including the Swift Package Manager, which we will now review.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理 iOS 项目依赖项的基本工具，CocoaPods 应该被给予极高的重视。这适用于任何依赖管理器，包括我们将要审查的 Swift 包管理器。
- en: Learning about the Swift Package Manager
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Swift 包管理器
- en: CocoaPods and Carthage have played a significant part over the years in managing
    dependencies in iOS projects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，CocoaPods 和 Carthage 在管理 iOS 项目的依赖项方面发挥了重要作用。
- en: While CocoaPods and Carthage are terrific tools, every platform needs to have
    its in-house dependency manager, and Apple indeed developed a native dependency
    manager called the **Swift Package** **Manager** (**SPM**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CocoaPods 和 Carthage 是出色的工具，但每个平台都需要有自己的内部依赖管理器，苹果确实开发了一个名为 **Swift 包管理器**（**SPM**）的本地依赖管理器。
- en: So, what is the SPM?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，SPM 是什么？
- en: The SPM is a dependency manager built right into Xcode and allows developers
    to easily create, manage, and share Swift packages, which are self-contained units
    of code that can be used in different projects. A package can contain one or more
    targets, each of which is a module that can be imported and used by other packages
    or projects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SPM 是一个直接集成到 Xcode 中的依赖管理器，允许开发者轻松创建、管理和共享 Swift 包，这些是包含在代码中的自包含单元，可以在不同的项目中使用。一个包可以包含一个或多个目标，每个目标都是一个模块，可以被其他包或项目导入和使用。
- en: Let’s start creating a Swift package from scratch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始创建一个 Swift 包。
- en: Creating a Swift package
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Swift 包
- en: 'Creating a new Swift package is simple. There are two ways to do it – using
    the *terminal* and *Xcode*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Swift 包很简单。有两种方法可以做到这一点——使用 *终端* 和 *Xcode*：
- en: '**Using the terminal**: Open the **Terminal** app, go to the project folder
    (or any other folder), and type the following command:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用终端**：打开 **终端** 应用，进入项目文件夹（或任何其他文件夹），并输入以下命令：'
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will create a new folder with the relevant subfolders and files
    to set up a basic and empty Swift package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个包含相关子文件夹和文件的新的文件夹，以设置一个基本且空的 Swift 包。
- en: '**Creating a Swift package with Xcode**: If you don’t want to use the Terminal
    to create a Swift package, the other option is to use Xcode.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Xcode 创建 Swift 包**: 如果您不想使用终端来创建 Swift 包，另一个选项是使用 Xcode。'
- en: 'Let’s go over the steps required to create a new Swift package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾创建新的 Swift 包所需的步骤：
- en: Open Xcode and select **File** | **New** | **Package** from the menu bar.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode 并从菜单栏选择 **文件** | **新建** | **包**。
- en: In the **Create a new Swift Package** dialog, enter the package details, such
    as the package name, organization, and type. You can choose between a library
    or executable package and specify the package’s platforms and products.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **创建新的 Swift 包** 对话框中，输入包详细信息，例如包名、组织机构和类型。您可以选择库或可执行包，并指定包的平台和产品。
- en: Click **Create** to create the new Swift package. Xcode will generate a basic
    project structure with a **Sources** directory and a **Package.swift** manifest
    file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 以创建新的 Swift 包。Xcode 将生成一个包含 **Sources** 目录和 **Package.swift** 清单文件的基本项目结构。
- en: Both options are simple and intuitive and take a few seconds to complete. Now,
    let’s understand what we created.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项都很简单直观，只需几秒钟即可完成。现在，让我们了解我们创建了什么。
- en: Going over the package manifest and folders
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查包清单和文件夹
- en: 'The Swift package is built from three components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 包由三个组件组成：
- en: '**The** **Sources** **directory**: This directory contains the Swift source
    files for our package. By default, it includes a single subdirectory with the
    same name as the package, and a single source file with the same name as the directory.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源** **目录**: 此目录包含我们包的 Swift 源文件。默认情况下，它包括一个与包同名的子目录和一个与目录同名的单个源文件。'
- en: '**The** **Tests** **directory**: This directory contains the test files for
    our code. By default, it includes a single subdirectory, with a single test file
    with the same name as the directory.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试** **目录**: 此目录包含我们代码的测试文件。默认情况下，它包括一个单个子目录，一个与目录同名的单个测试文件。'
- en: '**Package.swift**: This file is the package manifest file. It contains information
    about the package, such as its name, version, and dependencies, and is used by
    the SPM to build and manage the package.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Package.swift**: 此文件是包清单文件。它包含有关包的信息，例如其名称、版本和依赖项，并由 SPM 用于构建和管理包。'
- en: In the *Mastering CocoaPods* section, we discussed CocoaPods and mentioned the
    `podspec` file. In the SPM, `package.swift` serves a similar purpose to the `podspec`
    file in CocoaPods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *精通 CocoaPods* 部分，我们讨论了 CocoaPods 并提到了 `podspec` 文件。在 SPM 中，`package.swift`
    文件与 CocoaPods 中的 `podspec` 文件具有类似的作用。
- en: 'Here’s a short example of standard `package.swift` file content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个标准 `package.swift` 文件内容的简短示例：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that the `package.swift` file is written in, well… *Swift*. Therefore,
    reading it should be simple for iOS developers. Let’s understand what it says.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `package.swift` 文件是用，嗯…… *Swift* 编写的。因此，对于 iOS 开发者来说阅读它应该是简单的。让我们了解它说了什么。
- en: This `Package.swift` file specifies the details of a Swift package named `"MyPackage"`.
    The package targets multiple platforms – macOS, iOS, watchOS, and tvOS. It provides
    a single library product with the same name as the package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Package.swift` 文件指定了名为 `"MyPackage"` 的 Swift 包的详细信息。该包针对多个平台 - macOS、iOS、watchOS
    和 tvOS。它提供了一个与包同名的单个库产品。
- en: The package depends on the `Alamofire` package, specified as a dependency with
    a minimum version of `5.0.0`. The package also contains two targets, one for the
    package itself and one for its tests. The package target depends on the `Alamofire`
    package, and the test target depends on the `MyPackage` target.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该包依赖于 `Alamofire` 包，指定为具有最小版本 `5.0.0` 的依赖项。该包还包含两个目标，一个用于包本身，另一个用于其测试。包目标依赖于
    `Alamofire` 包，而测试目标依赖于 `MyPackage` 目标。
- en: When the SPM installs our package, it also establishes the dependencies we define
    inside the `package.swift` file, just the way it works with CocoaPods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SPM 安装我们的包时，它也会建立我们在 `package.swift` 文件中定义的依赖项，就像它与 CocoaPods 一样工作。
- en: Another interesting thing we should know is why it is called a “package” and
    not a “library.” The reason is that a Swift package can contain *multiple libraries*
    (under “products”) and various targets, and it is crucial to understand that hierarchy
    to create a flexible package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们应该了解的有趣的事情是为什么它被称为“包”而不是“库”。原因是 Swift 包可以包含 *多个库*（在“产品”下）和不同的目标，理解这个层次结构对于创建灵活的包至关重要。
- en: How do we build and test the package? Let’s see.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何构建和测试包？让我们看看。
- en: Swift package common commands
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift 包常见命令
- en: While it is possible to use the SPM from within Xcode, having a good understanding
    of the primary terminal commands is still essential. This is because user interfaces
    tend to change more frequently, while command-line tools remain more consistent
    over time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在 Xcode 中使用 SPM，但了解主要的终端命令仍然至关重要。这是因为用户界面倾向于更频繁地变化，而命令行工具则随着时间的推移保持更一致。
- en: However, a more significant reason is that terminal commands provide us with
    the ability to *integrate them into scripts and CI machines*, making them powerful
    and effective.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个更重要的原因是，终端命令为我们提供了将它们集成到脚本和 CI 机器中的能力，使它们变得强大而有效。
- en: 'Here is the list of commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是命令列表：
- en: '**swift package init**: We saw this command earlier when we discussed Swift
    package creation. It initializes a new and empty Swift package in the current
    directory.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**swift package init**：我们之前在讨论 Swift 包创建时看到了这个命令。它将在当前目录中初始化一个新的空 Swift 包。'
- en: '**swift package update**: This updates the package’s dependencies to their
    latest compatible versions. It’s similar to **pod update** in CocoaPods.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**swift package update**：这会将包的依赖项更新到最新兼容版本。它与 CocoaPods 中的 **pod update** 类似。'
- en: '**swift build**: This builds the package and its dependencies, generating a
    binary or library product.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**swift build**：这将构建包及其依赖项，生成二进制或库产品。'
- en: '**swift test**: This runs the package’s unit tests, building the package if
    necessary.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**swift test**：如果需要，这将运行包的单元测试，并构建包。'
- en: '**swift package clean**: This deletes the build artifacts for the package,
    including the build directory.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**swift package clean**：这将删除包的构建工件，包括构建目录。'
- en: In the context of an interview, think of this command list as a “features list.”
    This list should show us how to operate and maintain a Swift package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试的背景下，将这个命令列表视为一个“功能列表”。这个列表应该显示我们如何操作和维护一个 Swift 包。
- en: Using a Swift package
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Swift 包
- en: Using a Swift package library is like any other library we add to our project.
    Everything we know about access levels also applies in this case.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift 包库就像我们添加到项目中的任何其他库一样。我们关于访问级别的所有知识也适用于这种情况。
- en: For example, an app can access only *public* and *open* functions, classes,
    and properties, while the *internal* level is reserved for the library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用只能访问*公共*和*开放*的功能、类和属性，而*内部*级别则保留给库。
- en: 'Also, to use a library, we need to import it into our code. Here’s an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使用库，我们需要将其导入到我们的代码中。以下是一个示例：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we first import the `MyPackage` module into our code using
    the `import` statement. Then, we create an instance of the `MyClass` class and
    call its `myMethod` function. In this case, `MyClass` is part of `MyPackage`.
    This example is relevant for the app and the package when working with its dependencies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用 `import` 语句将 `MyPackage` 模块导入到我们的代码中。然后，我们创建 `MyClass` 类的一个实例并调用其
    `myMethod` 函数。在这种情况下，`MyClass` 是 `MyPackage` 的一部分。这个例子适用于处理依赖项时的应用和包。
- en: Generally speaking, using the SPM is pretty simple and straightforward. Apple
    did a great job integrating it within Xcode while maintaining its ability to perform
    everything in terminal commands.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，使用 SPM 非常简单直接。苹果在保持其能够在终端命令中执行一切功能的同时，出色地将它集成到 Xcode 中。
- en: The goal here was to briefly explain the SPM before we move on to the next interview
    questions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是简要解释 SPM，然后我们再继续下一个面试问题。
- en: “What are the advantages and disadvantages of using the SPM compared to CocoaPods?”
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “与 CocoaPods 相比，使用 SPM 的优缺点是什么？”
- en: '*Why is this* *question important?*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这个问题很重要**？'
- en: Both tools are excellent to manage dependencies in iOS, but just like any other
    tool, they have their strengths and weaknesses.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具都非常适合管理 iOS 中的依赖项，但就像任何其他工具一样，它们都有其优点和缺点。
- en: Understanding the practical differences between the tools is perhaps even more
    important than using them, as the latter is straightforward and technical. Choosing
    the right tool significantly impacts our app’s maintenance and stability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些工具的实际差异可能甚至比使用它们更重要，因为后者是直接和技术的。选择正确的工具对我们的应用维护和稳定性有重大影响。
- en: '*What is* *the answer?*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案是什么**？'
- en: Like any cons and pros, the answer depends on a project’s needs and requirements.
    However, there are some known differences between CocoaPods and the SPM.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何利弊一样，答案取决于项目的需求和需求。然而，CocoaPods 和 SPM 之间有一些已知的不同之处。
- en: 'These are the *SPM''s advantages*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 *SPM 的优点*：
- en: A *built-in* tool for Swift projects, so no need for third-party dependencies
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 项目的内置工具，因此无需第三方依赖
- en: A simple and *easy-to-use* syntax
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单且 *易于使用* 的语法
- en: '*Integration with Swift and Xcode*, including support to generate Xcode projects'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与 Swift 和 Xcode 集成*，包括生成 Xcode 项目的支持'
- en: '*Automatic dependency resolution* and caching'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动依赖解析* 和缓存'
- en: '*Faster* build times for more minor projects'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更快的* 构建时间，适用于更小的项目'
- en: 'These are the *SPM''s disadvantages*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 *SPM 的缺点*：
- en: Limited support for binary dependencies
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对二进制依赖的支持有限
- en: No support for Objective-C or mixed-language projects
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持 Objective-C 或混合语言项目
- en: Limited customization options for build settings
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建设置的定制选项有限
- en: This list suggests that the advantages and disadvantages of the SPM are inverse
    to the ones mentioned earlier in the *Mastering* *CocoaPods* section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表表明，SPM 的优缺点与之前在 *掌握 CocoaPods* 部分中提到的相反。
- en: On one hand, CocoaPods is more used and flexible than the SPM. On the other
    hand, it is more complex and slow and performs as a foreign citizen in Apple’s
    development ecosystem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，CocoaPods 比 SPM 更常用且更灵活。另一方面，它更复杂、更慢，在 Apple 的开发生态系统中表现得像一个外来者。
- en: Before you start the interview, you should try each of the solutions to understand
    how they feel and what is possible.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始面试之前，你应该尝试每个解决方案，以了解它们的感觉和可能性。
- en: “What are some best practices for organizing and structuring Swift packages
    to optimize build times and minimize dependency conflicts?”
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “有哪些最佳实践可以用来组织和结构化 Swift 包以优化构建时间和最小化依赖冲突？”
- en: '*Why is this* *question important?*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question is beyond technical. As we already saw, the technical part of
    handling Swift packages is simple, even for junior developers. However, organizing
    a project for packages effectively and efficiently is the real challenge.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题超出了技术范畴。正如我们之前看到的，处理 Swift 包的技术部分很简单，即使是初级开发者也能轻松应对。然而，有效地组织和高效地管理项目以适应包，才是真正的挑战。
- en: The abundance of articles and research on code modularity and organization demonstrates
    the importance of this question. Most of them do not even mention the SPM.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码模块化和组织的大量文章和研究证明了这个问题的重要性。其中大部分甚至没有提到 SPM。
- en: Following even a tiny portion of the best practices here can significantly impact
    our project.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 即使遵循这里提到的最佳实践的很小一部分，也能显著影响我们的项目。
- en: '*What is* *the answer?*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are some best practices for organizing our code to optimize build times
    and decouple our dependencies:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些最佳实践可以用来组织我们的代码以优化构建时间和解耦我们的依赖：
- en: '**Keeping packages small**: Large packages with many dependencies can slow
    down build times and increase the risk of conflicts. To minimize these issues,
    keeping packages small and modular is a good practice. This makes it easier to
    manage dependencies and reduces the risk of conflicts.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持包小**：包含许多依赖的大型包可能会减慢构建时间并增加冲突的风险。为了最小化这些问题，保持包小和模块化是一个好的实践。这使得管理依赖变得更容易，并减少了冲突的风险。'
- en: '**Minimizing dependencies**: To reduce the risk of conflicts and improve build
    times, it’s a good practice to minimize dependencies wherever possible. This can
    be achieved by using only the essential dependencies for the package and avoiding
    unnecessary or duplicate dependencies.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化依赖**：为了减少冲突的风险并提高构建时间，尽可能最小化依赖是一个好的实践。这可以通过仅使用包的必需依赖项并避免不必要的或重复的依赖项来实现。'
- en: '**Using semantic versioning**: We can use semantic versioning to manage version
    numbers for a package and its dependencies. By using semantic versioning, we can
    communicate changes and compatibility requirements to other developers and users
    of the package.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用语义版本控制**：我们可以使用语义版本控制来管理包及其依赖的版本号。通过使用语义版本控制，我们可以向其他开发者和包的用户传达更改和兼容性要求。'
- en: '**Using** **incremental builds**: The SPM supports incremental builds, which
    means that only the necessary parts of the package are rebuilt when changes are
    made. This can help to improve build times and reduce unnecessary recompilation.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用增量构建**：SPM 支持增量构建，这意味着只有当进行更改时，才会重新构建包的必要部分。这有助于提高构建时间并减少不必要的重新编译。'
- en: We can say that the best practices described here can be used to modularize
    any project or even any class. A flat hierarchy, minimum dependencies, and small
    libraries are all great tips for managing libraries in our projects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，这里描述的最佳实践可以用来模块化任何项目，甚至任何类。扁平的层次结构、最小化依赖和小的库都是我们在项目中管理库的好建议。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Dependency managers are like double-edged swords. Both the SPM and CocoaPods
    can be time savers and great add-ons for our projects regarding modularity and
    separation. Conversely, they can have a devastating effect on our app's stability
    and architecture's simplicity if not handled correctly. That’s why it’s a topic
    we must master as iOS developers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理器就像双刃剑。无论是 SPM 还是 CocoaPods，它们都可以在模块化和分离方面为我们节省时间，成为我们项目的优秀补充。然而，如果处理不当，它们也可能对我们的应用程序的稳定性和架构的简洁性产生破坏性的影响。这就是为什么作为
    iOS 开发者，我们必须掌握这个话题。
- en: In this chapter, we learned the basics of CocoaPods and the SPM, including the
    best practices and their pros and cons. By now, we should have everything covered
    when asked about the most common third-party dependency managers for iOS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 CocoaPods 和 SPM 的基础知识，包括最佳实践及其优缺点。到目前为止，当我们被问到关于 iOS 最常见的第三方依赖管理器时，我们应该已经涵盖了所有内容。
- en: In a way, our next chapter is linked to what we have discussed in this chapter.
    We will slowly move away from the standard Swift and UIKit topics into the world
    of design and architecture.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们的下一章与本章所讨论的内容紧密相连。我们将逐渐从标准的 Swift 和 UIKit 主题转向设计和架构的世界。
- en: Our next chapter will be exciting!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一章将会非常精彩！
