- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed the code *we write* – Swift, UIKit, and SwiftUI. But
    modern developers’ work doesn’t simply amount to writing code. Knowing how to
    integrate code can be a productivity multiplier, greatly enhancing our efficiency
    and allowing us to accomplish more in less time than simply knowing how to code.
  prefs: []
  type: TYPE_NORMAL
- en: '*CocoaPods* and the *Swift Package Manager* are the leading solutions we have
    today for managing third-party and local dependencies. It is essential for any
    iOS developer to understand these tools thoroughly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers CocoaPods and the Swift Package Manager in terms of the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning *how CocoaPods is built*, including different components such as **Podfile**
    and **Podspec** files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going over *CocoaPods’ best practices* and use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the Swift Package Manager *creation process*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Swift Package Manager’s *common commands*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to *use a Swift Package* in our projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going over the *different advantages* the Swift Package Manager has compared
    to CocoaPods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Organizing our projects* with the Swift Package Manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a “simple” chapter, yet it is a crucial topic in today’s iOS development
    world. Let’s start with CocoaPods as our first dependency manager.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering CocoaPods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CocoaPods** is one of the most popular dependency managers for iOS developers
    and has been maintained for many years as an open source project.'
  prefs: []
  type: TYPE_NORMAL
- en: CocoaPods is often the first choice for many library developers and has a massive
    collection of frameworks that can be easily integrated with iOS projects.
  prefs: []
  type: TYPE_NORMAL
- en: Besides having a vast collection of frameworks, CocoaPods supports integration
    with local frameworks. It can help us modularize our project to different libraries
    and make it more flexible and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how CocoaPods works and how it is built.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how CocoaPods is built
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use CocoaPods to manage dependencies in our Xcode project, CocoaPods
    creates a new workspace, which includes both our project and any dependencies
    we specified in our `Podfile` file. CocoaPods creates this workspace automatically
    when we run the `pod` `install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode Workspace
  prefs: []
  type: TYPE_NORMAL
- en: In Xcode, a workspace is a container for one or more Xcode projects and any
    other files and resources needed to build our app. Workspaces are used to organize
    and manage the different components of our app and make it easier to develop and
    test our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using a workspace in CocoaPods has several benefits. It simplifies dependency
    management by including the project and its dependencies in the same workspace,
    simplifies integration, and follows the separation of concern principle by keeping
    the dependencies up to date, regardless of our main project.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the workspace, CocoaPods comprises several different components, each
    of which plays a role in managing dependencies for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some of the key components of CocoaPods.
  prefs: []
  type: TYPE_NORMAL
- en: Podfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Podfile` is a file that specifies which dependencies are required for our
    project. It uses a simple Ruby syntax to declare each pod’s name and version number,
    as well as any options or configurations needed. `Podfile` is typically located
    in a project’s root directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a `Podfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s understand how the file is built:'
  prefs: []
  type: TYPE_NORMAL
- en: The platform to target is iOS 16.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target of **Podfile** is an Xcode project called **MyApp**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **use_frameworks!** directive tells CocoaPods to build the dependencies
    as **dynamic frameworks**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pod directives specify the two dependencies for the project, **Alamofire**
    and **SwiftyJSON**, along with their version requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `~>` operator is an **optimistic operator**, which is used to specify a
    version for the pod and allows it to be updated to the next major version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, CocoaPods will install and update the `Alamofire` pod up to version
    6.0 (not including 6.0 itself). This allows us to enjoy hotfixes and minor versions
    without breaking backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '`Podfile` is our project configuration file for all our dependencies and must
    be maintained carefully.'
  prefs: []
  type: TYPE_NORMAL
- en: Podfile.lock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Podfile.lock` is a file that stores information about the specific versions
    of the dependencies installed in our project. It ensures that the same dependencies’
    versions are installed on every machine, which helps prevent version conflicts
    and other issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: CocoaPods automatically generates `Podfile.lock` when we run `pod update` or
    `pod install`, and we shouldn’t update it manually, as it can cause conflicts
    and issues.
  prefs: []
  type: TYPE_NORMAL
- en: The Pods directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Pods` directory is a directory that contains all the dependencies installed
    by CocoaPods for our project. It includes each pod’s source code, headers, and
    compiled binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Podspec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Podspec` is a file that describes a single pod, including its name, version,
    source code location, dependencies, and other metadata. Podspecs are published
    to the CocoaPods repository and used by CocoaPods to download and install a pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a podspec file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The podspec file is written in Ruby, a dynamic and object-oriented programming
    language. In fact, the `Podfile` file is also written in Ruby, as it is considered
    a convenient and popular way to write configuration files for frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The podspec file, in this example, describes a library named `MyLibrary` with
    a version of `1.0.0`. We can also see a summary, a description, and other general
    details, such as the home page, license, and author.
  prefs: []
  type: TYPE_NORMAL
- en: In the source and source files, we can see where the Git repository is located
    (in this case, in GitHub) and what files are included in the pod in the **wildcard
    pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard pattern
  prefs: []
  type: TYPE_NORMAL
- en: In Podfile, a wildcard pattern can be used to define directories where the pods
    should be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wildcard pattern (“*****”) represents any character to match any file or
    directory. For example, if we want to specify all directories that start with
    “M,” we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pod "MyPod", :path => "****M*"**'
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard pattern is not a Podfile-only pattern – it is used in many Unix-like
    command-line tools and terminals.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the dependencies our pod requires so that CocoaPods will know
    to manage its dependencies tree accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that we can easily use a podspec file to create a local
    library and integrate it with our project. Here’s a podspec file example for a
    local library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Apart from modifying our `source` and `source_files` attributes, we can also
    see that we now have a `pod_target_xcconfig` attribute to specify the path to
    the source code for the module in our project.
  prefs: []
  type: TYPE_NORMAL
- en: '`Podfile`, in this case, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In `Podfile`, we direct `MyFramework` to its local path, where the source file
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: Pod command-line tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pod command-line tool is the primary interface for working with CocoaPods.
    It provides a command set that allows us to install, update, and manage dependencies
    for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some commonly used commands we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pod install**: This command installs the dependencies specified in **Podfile**
    and generates an Xcode workspace, containing our project and the installed dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pod update**: This command updates the dependencies specified in **Podfile**
    to their latest versions and installs them. We can select a specific pod or a
    list of pods to update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pod lib create**: This command generates a new CocoaPods library template.
    We can use it to quickly set up a new pod’s directory structure, files, and configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pod search**: This command searches the CocoaPods repository for pods that
    match a given query. We can search for pods by name, description, author, or other
    criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like many development tools, CocoaPods is based on command-line tools, configuration
    files, and a terminal, so “terminal-phobia” is not recommended in the case of
    CocoaPods!
  prefs: []
  type: TYPE_NORMAL
- en: We discussed five different CocoaPods components for managing and understanding
    CocoaPods. If you have never used CocoaPods before or didn’t create your pod,
    it’s a good idea to create a new project and play with it, followed by reading
    the CocoaPods documentation, which is clear and straightforward. I promise you
    that things will be much easier to understand after an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s jump into two questions about CocoaPods that we may encounter in
    an interview.
  prefs: []
  type: TYPE_NORMAL
- en: “What best practices do you follow when working with CocoaPods, and why are
    they important?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: CocoaPods, or any other dependencies manager for that matter, is an essential
    part of a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, we can even say *it’s the vulnerable part of our project* for a few
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It’s not code we have written ourselves**: CocoaPods integrates thousands
    of lines of code that other developers wrote into our project. We have little
    control over the security, performance, and stability effect of adding code someone
    else writes. However, it will have probably gone through many fixes and testing
    cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There’s a potential for dependencies conflicts**: A poorly structured **Podfile**
    can cause conflicts between different versions of dependencies and may harm a
    project’s stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outdated frameworks can cause security breaches**: Developers often lock
    frameworks to specific versions to keep their project stability high. This can
    lead to obsolete code with security and stability issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the reasons I just described, a well-structured `Podfile` tremendously
    affects our project quality.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow a few best practices when working with CocoaPods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keeping our frameworks up to date**: We need to ensure we get the latest
    bug fixes and features to keep our project stable. The **~>** operator I mentioned
    earlier is recommended to get the latest hotfixes and minor versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding semantic versioning**: Keeping frameworks up to date is essential.
    However, we should understand how semantic versioning works. We want to ensure
    backward compatibility and avoid breaking changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping dependencies at a minimum**: We should only include frameworks that
    we really need in our project and remove those that the Apple SDK can replace.
    Keeping our project light and simple is vital, avoiding potential issues such
    as conflicts and crashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping our Podfile organized and readable**: We should treat our **Podfile**
    as part of our code base. Grouping dependencies in a logical way can provide us
    with flexibility and clarity. Another best practice here is to add comments next
    to each pod and explain why we added each pod. Pods can live in our app for years,
    and the comments we add can help us in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the adapter pattern**: While the adapter pattern is not unique
    to CocoaPods, it is an excellent pattern for integrating a pod into our project
    seamlessly. Often, the pod’s interface does not naturally align with our existing
    code base. By introducing a class that acts as an interface between our code base
    and the library, we can effectively connect these two components. Additionally,
    the adapter can assist in decoupling our code base from the pod and reducing dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must remember something important – pods are part of our code. We should
    take care of our third-party frameworks with the same attention that we manage
    our project code base with, as they tremendously affect how our project performs.
  prefs: []
  type: TYPE_NORMAL
- en: “What is the difference between pod update and pod install?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous question, we talked about best practices for managing CocoaPods.
    One crucial aspect we covered was managing pods to prevent them from causing any
    issues or breaking our code.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `pod update` and `pod install` commands help us to decide our strategy
    to update our pods, implementing a careful and responsible way to keep our third-party
    libraries up to date.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`pod install` and `pod update` are commands used in the CocoaPods dependency
    manager for iOS projects. The main difference between them is how they handle
    dependency resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pod install` installs the dependencies specified in `Podfile.lock` and ensures
    that a pod won’t receive unintended updates.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `pod update` updates the current pods to the latest minor
    version and, ultimately, updates `Podfile.lock` to the new version.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that if there is no `Podfile.lock`, *both commands* *behave
    similarly*.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the commands in day-to-day work is critical. `Podfile.lock`
    helps us control our framework’s updates and keeps our pods in a specific version,
    as long as we use `pod install`, whereas `pod update` can bypass what’s written
    in `Podfile.lock`.
  prefs: []
  type: TYPE_NORMAL
- en: I advise including `Podfile.lock` in a project’s code base when discussing best
    practices. This is particularly crucial when collaborating with a team, as `Podfile.lock`
    guarantees that all team members use identical framework versions.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this section, by now, we should understand how CocoaPods works
    and how to use it to link third-party libraries and maintain a stable and robust
    project.
  prefs: []
  type: TYPE_NORMAL
- en: As an essential tool to manage dependencies in iOS projects, CocoaPods should
    be treated with the utmost importance. This applies to any dependency manager,
    including the Swift Package Manager, which we will now review.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the Swift Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CocoaPods and Carthage have played a significant part over the years in managing
    dependencies in iOS projects.
  prefs: []
  type: TYPE_NORMAL
- en: While CocoaPods and Carthage are terrific tools, every platform needs to have
    its in-house dependency manager, and Apple indeed developed a native dependency
    manager called the **Swift Package** **Manager** (**SPM**).
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the SPM?
  prefs: []
  type: TYPE_NORMAL
- en: The SPM is a dependency manager built right into Xcode and allows developers
    to easily create, manage, and share Swift packages, which are self-contained units
    of code that can be used in different projects. A package can contain one or more
    targets, each of which is a module that can be imported and used by other packages
    or projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start creating a Swift package from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Swift package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new Swift package is simple. There are two ways to do it – using
    the *terminal* and *Xcode*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the terminal**: Open the **Terminal** app, go to the project folder
    (or any other folder), and type the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will create a new folder with the relevant subfolders and files
    to set up a basic and empty Swift package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Swift package with Xcode**: If you don’t want to use the Terminal
    to create a Swift package, the other option is to use Xcode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go over the steps required to create a new Swift package:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Xcode and select **File** | **New** | **Package** from the menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create a new Swift Package** dialog, enter the package details, such
    as the package name, organization, and type. You can choose between a library
    or executable package and specify the package’s platforms and products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** to create the new Swift package. Xcode will generate a basic
    project structure with a **Sources** directory and a **Package.swift** manifest
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both options are simple and intuitive and take a few seconds to complete. Now,
    let’s understand what we created.
  prefs: []
  type: TYPE_NORMAL
- en: Going over the package manifest and folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Swift package is built from three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **Sources** **directory**: This directory contains the Swift source
    files for our package. By default, it includes a single subdirectory with the
    same name as the package, and a single source file with the same name as the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** **Tests** **directory**: This directory contains the test files for
    our code. By default, it includes a single subdirectory, with a single test file
    with the same name as the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package.swift**: This file is the package manifest file. It contains information
    about the package, such as its name, version, and dependencies, and is used by
    the SPM to build and manage the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Mastering CocoaPods* section, we discussed CocoaPods and mentioned the
    `podspec` file. In the SPM, `package.swift` serves a similar purpose to the `podspec`
    file in CocoaPods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a short example of standard `package.swift` file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `package.swift` file is written in, well… *Swift*. Therefore,
    reading it should be simple for iOS developers. Let’s understand what it says.
  prefs: []
  type: TYPE_NORMAL
- en: This `Package.swift` file specifies the details of a Swift package named `"MyPackage"`.
    The package targets multiple platforms – macOS, iOS, watchOS, and tvOS. It provides
    a single library product with the same name as the package.
  prefs: []
  type: TYPE_NORMAL
- en: The package depends on the `Alamofire` package, specified as a dependency with
    a minimum version of `5.0.0`. The package also contains two targets, one for the
    package itself and one for its tests. The package target depends on the `Alamofire`
    package, and the test target depends on the `MyPackage` target.
  prefs: []
  type: TYPE_NORMAL
- en: When the SPM installs our package, it also establishes the dependencies we define
    inside the `package.swift` file, just the way it works with CocoaPods.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing we should know is why it is called a “package” and
    not a “library.” The reason is that a Swift package can contain *multiple libraries*
    (under “products”) and various targets, and it is crucial to understand that hierarchy
    to create a flexible package.
  prefs: []
  type: TYPE_NORMAL
- en: How do we build and test the package? Let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: Swift package common commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is possible to use the SPM from within Xcode, having a good understanding
    of the primary terminal commands is still essential. This is because user interfaces
    tend to change more frequently, while command-line tools remain more consistent
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: However, a more significant reason is that terminal commands provide us with
    the ability to *integrate them into scripts and CI machines*, making them powerful
    and effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**swift package init**: We saw this command earlier when we discussed Swift
    package creation. It initializes a new and empty Swift package in the current
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**swift package update**: This updates the package’s dependencies to their
    latest compatible versions. It’s similar to **pod update** in CocoaPods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**swift build**: This builds the package and its dependencies, generating a
    binary or library product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**swift test**: This runs the package’s unit tests, building the package if
    necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**swift package clean**: This deletes the build artifacts for the package,
    including the build directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of an interview, think of this command list as a “features list.”
    This list should show us how to operate and maintain a Swift package.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Swift package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a Swift package library is like any other library we add to our project.
    Everything we know about access levels also applies in this case.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an app can access only *public* and *open* functions, classes,
    and properties, while the *internal* level is reserved for the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, to use a library, we need to import it into our code. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first import the `MyPackage` module into our code using
    the `import` statement. Then, we create an instance of the `MyClass` class and
    call its `myMethod` function. In this case, `MyClass` is part of `MyPackage`.
    This example is relevant for the app and the package when working with its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, using the SPM is pretty simple and straightforward. Apple
    did a great job integrating it within Xcode while maintaining its ability to perform
    everything in terminal commands.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here was to briefly explain the SPM before we move on to the next interview
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: “What are the advantages and disadvantages of using the SPM compared to CocoaPods?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Both tools are excellent to manage dependencies in iOS, but just like any other
    tool, they have their strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the practical differences between the tools is perhaps even more
    important than using them, as the latter is straightforward and technical. Choosing
    the right tool significantly impacts our app’s maintenance and stability.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Like any cons and pros, the answer depends on a project’s needs and requirements.
    However, there are some known differences between CocoaPods and the SPM.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the *SPM''s advantages*:'
  prefs: []
  type: TYPE_NORMAL
- en: A *built-in* tool for Swift projects, so no need for third-party dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple and *easy-to-use* syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integration with Swift and Xcode*, including support to generate Xcode projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automatic dependency resolution* and caching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Faster* build times for more minor projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the *SPM''s disadvantages*:'
  prefs: []
  type: TYPE_NORMAL
- en: Limited support for binary dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No support for Objective-C or mixed-language projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited customization options for build settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list suggests that the advantages and disadvantages of the SPM are inverse
    to the ones mentioned earlier in the *Mastering* *CocoaPods* section.
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, CocoaPods is more used and flexible than the SPM. On the other
    hand, it is more complex and slow and performs as a foreign citizen in Apple’s
    development ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start the interview, you should try each of the solutions to understand
    how they feel and what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: “What are some best practices for organizing and structuring Swift packages
    to optimize build times and minimize dependency conflicts?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This question is beyond technical. As we already saw, the technical part of
    handling Swift packages is simple, even for junior developers. However, organizing
    a project for packages effectively and efficiently is the real challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The abundance of articles and research on code modularity and organization demonstrates
    the importance of this question. Most of them do not even mention the SPM.
  prefs: []
  type: TYPE_NORMAL
- en: Following even a tiny portion of the best practices here can significantly impact
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some best practices for organizing our code to optimize build times
    and decouple our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keeping packages small**: Large packages with many dependencies can slow
    down build times and increase the risk of conflicts. To minimize these issues,
    keeping packages small and modular is a good practice. This makes it easier to
    manage dependencies and reduces the risk of conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimizing dependencies**: To reduce the risk of conflicts and improve build
    times, it’s a good practice to minimize dependencies wherever possible. This can
    be achieved by using only the essential dependencies for the package and avoiding
    unnecessary or duplicate dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using semantic versioning**: We can use semantic versioning to manage version
    numbers for a package and its dependencies. By using semantic versioning, we can
    communicate changes and compatibility requirements to other developers and users
    of the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using** **incremental builds**: The SPM supports incremental builds, which
    means that only the necessary parts of the package are rebuilt when changes are
    made. This can help to improve build times and reduce unnecessary recompilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can say that the best practices described here can be used to modularize
    any project or even any class. A flat hierarchy, minimum dependencies, and small
    libraries are all great tips for managing libraries in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency managers are like double-edged swords. Both the SPM and CocoaPods
    can be time savers and great add-ons for our projects regarding modularity and
    separation. Conversely, they can have a devastating effect on our app's stability
    and architecture's simplicity if not handled correctly. That’s why it’s a topic
    we must master as iOS developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of CocoaPods and the SPM, including the
    best practices and their pros and cons. By now, we should have everything covered
    when asked about the most common third-party dependency managers for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, our next chapter is linked to what we have discussed in this chapter.
    We will slowly move away from the standard Swift and UIKit topics into the world
    of design and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter will be exciting!
  prefs: []
  type: TYPE_NORMAL
