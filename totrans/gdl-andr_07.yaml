- en: Chapter 7. Creating Tasks and Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 创建任务和插件
- en: So far, we have been manipulating properties for our Gradle builds and learning
    how to run tasks. In this chapter, we will get a deeper understanding of those
    properties, and start creating our own tasks. Once we know how to write our own
    tasks, we can go even further, and look at how to make our own plugins that can
    be reused in several projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在操作Gradle构建的属性，并学习如何运行任务。在本章中，我们将更深入地了解这些属性，并开始创建自己的任务。一旦我们知道了如何编写自己的任务，我们就可以更进一步，看看如何创建可以在多个项目中重用的自定义插件。
- en: Before we look at how to create custom tasks, we need to learn a few important
    Groovy concepts. This is because having a basic understanding of how Groovy works
    makes it a lot easier to get started with custom tasks and plugins. Knowing Groovy
    also helps to understand how Gradle works, and why the build configuration files
    look the way they do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何创建自定义任务之前，我们需要学习一些重要的Groovy概念。这是因为对Groovy工作方式的基本理解使得开始创建自定义任务和插件变得容易得多。了解Groovy还有助于理解Gradle是如何工作的，以及为什么构建配置文件看起来是这个样子。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding Groovy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Groovy
- en: Getting started with tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用任务
- en: Hooking into the Android plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成到Android插件中
- en: Creating your own plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的插件
- en: Understanding Groovy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Groovy
- en: As most Android developers are proficient Java developers, it is interesting
    to look at how Groovy works compared to Java. Groovy is quite easy to read if
    you are a Java developer, but writing your own Groovy code would be a hard task
    without a small introduction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数Android开发者都是熟练的Java开发者，因此观察Groovy与Java相比的工作方式很有趣。如果你是Java开发者，Groovy的阅读起来相当简单，但如果没有一点介绍，编写自己的Groovy代码将是一项艰巨的任务。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A good way to experiment with Groovy is to use the Groovy Console. This application
    comes with the Groovy SDK and makes it easy to try out Groovy statements while
    getting an immediate response. The Groovy Console is also able to handle pure
    Java code, which makes it easy to compare Java and Groovy code. You can download
    the Groovy SDK, including the Groovy Console, from the Groovy website at [http://groovy-lang.org/download.html](http://groovy-lang.org/download.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Groovy进行实验的一个好方法是使用Groovy控制台。这个应用程序包含在Groovy SDK中，使得尝试Groovy语句并获得即时响应变得容易。Groovy控制台还能够处理纯Java代码，这使得比较Java和Groovy代码变得容易。您可以从Groovy网站[http://groovy-lang.org/download.html](http://groovy-lang.org/download.html)下载Groovy
    SDK，包括Groovy控制台。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Groovy is derived from Java and runs on the Java Virtual Machine. Its goal is
    to be a simpler, more straightforward language that can be used either as a scripting
    language or as a full-blown programming language. Throughout this section, we
    will compare Groovy with Java to make it easier to grasp how Groovy works and
    to clearly see the difference between both languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy是从Java衍生出来的，并在Java虚拟机上运行。它的目标是成为一个更简单、更直接的编程语言，既可以作为脚本语言使用，也可以作为完整的编程语言使用。在本节中，我们将比较Groovy和Java，以便更容易理解Groovy的工作方式，并清楚地看到两种语言之间的区别。
- en: 'In Java, printing a string to the screen looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，将字符串打印到屏幕上的样子如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Groovy, you can accomplish the same with this line of code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，你可以用这一行代码完成相同的事情：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will immediately notice a few key differences:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即注意到几个关键的区别：
- en: No `System.out` namespace
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用`System.out`命名空间
- en: No parentheses around method parameters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数周围没有括号
- en: No semicolons at the end of a line
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行尾没有分号
- en: 'The example also uses single quotes around a string. You can use either single
    quotes or double quotes for strings, but they have different usages. Double-quoted
    string can also include interpolated expressions. Interpolation is the process
    of evaluating a string that contains placeholders, and replacing those placeholders
    with their values. These placeholder expressions can be variables, or even methods.
    Placeholder expressions that contain a method or multiple variables need to be
    surrounded by curly brackets and prefixed by `$`. Placeholder expressions that
    contain a single variable can just be prefixed with `$`. Here are some examples
    of string interpolation in Groovy:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例还使用了字符串的单引号。你可以为字符串使用单引号或双引号，但它们有不同的用法。双引号字符串还可以包含插值表达式。插值是评估包含占位符的字符串的过程，并用它们的值替换这些占位符。这些占位符表达式可以是变量，甚至是方法。包含方法或多个变量的占位符表达式需要用花括号包围并以前缀`$`开头。只包含单个变量的占位符表达式只需以前缀`$`开头。以下是一些Groovy中字符串插值的示例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `greeting` variable contains the string "Hello, Andy" and `name_size` is
    "Your name is 4 characters long.".
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting`变量包含字符串"Hello, Andy"，而`name_size`是"您的名字长度为4个字符。"。'
- en: 'String interpolation allows you to execute code dynamically as well. This example
    is valid code that prints the current date:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值允许您动态执行代码。以下是一个有效的代码示例，它会打印当前日期：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This looks very strange when you are used to Java, but it is normal syntax and
    behavior in dynamic programming languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您习惯于Java时，这看起来非常奇怪，但在动态编程语言中，这是一种正常的语法和行为。
- en: Classes and members
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和成员
- en: 'Creating a class in Groovy looks a lot like creating a class in Java. Here
    is an example of a simple class containing one member:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中创建类的方式与在Java中创建类的方式非常相似。以下是一个包含一个成员的简单类的示例：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that neither the class nor the member has explicit access modifiers.
    The default access modifiers in Groovy are different from in Java. Classes themselves
    are public, just like methods, while class members are private.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类和成员都没有显式的访问修饰符。Groovy中的默认访问修饰符与Java不同。类本身是公开的，就像方法一样，而类成员是私有的。
- en: 'To use `MyGroovyClass`, make a new instance of it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`MyGroovyClass`，请创建其新实例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use the keyword `def` to create new variables. Once you have a new instance
    of a class, you can manipulate its members. Accessors are added automatically
    by Groovy. You can still override them, as we did with `getGreeting()` in the
    definition of `MyGroovyClass`. If you specify nothing, you will still be able
    to use both a getter and a setter for every member in your class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`def`关键字创建新变量。一旦您有一个类的实例，您就可以操作其成员。Groovy会自动添加访问器。您仍然可以像我们在`MyGroovyClass`的定义中使用`getGreeting()`那样覆盖它们。如果您不指定任何内容，您仍然可以在类中的每个成员上使用getter和setter。
- en: 'If you try to call a member directly, you will, in fact, call the getter. This
    means you do not need to type `instance.getGreeting()`, you can just use the shorter
    `instance.greeting` instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试直接调用成员，实际上会调用getter。这意味着您不需要键入`instance.getGreeting()`，您可以直接使用更短的`instance.greeting`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both lines in the preceding code sample print out the exact same thing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例中的两行打印出完全相同的内容。
- en: Methods
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: Just like with variables, you do not need to define a specific return type for
    your methods. You are free to do so anyway, even if it is just for the sake of
    clarity. Another difference between Java and Groovy methods is that in Groovy,
    the last line of a method is always returned by default, even without using the
    `return` keyword.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量一样，您不需要为您的函数定义特定的返回类型。您仍然可以这样做，即使只是为了清晰起见。Java和Groovy方法之间的另一个区别是，在Groovy中，方法的最后一行默认返回，即使没有使用`return`关键字。
- en: 'To demonstrate the differences between Java and Groovy, consider this Java
    example of a method that returns the square of a number:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Java和Groovy之间的差异，考虑以下Java示例，该方法返回一个数字的平方：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You need to specify that the method is publicly accessible, what the return
    type is, and what the type of the parameter is. At the end of the method, you
    need to return a value of the return type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指定该方法是否公开可访问，返回类型是什么，以及参数的类型。在方法末尾，您需要返回一个与返回类型相对应的值。
- en: 'The same method definition looks like this in Groovy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，相同的方法定义看起来像这样：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Neither the return type, nor the parameter type is explicitly defined. The `def`
    keyword is used instead of an explicit type, and the method implicitly returns
    a value without using the `return` keyword. However, using the `return` keyword
    is still recommended for clarity. When you call the method, you do not need parentheses
    or semicolon.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型和参数类型都没有明确定义。使用`def`关键字代替显式类型，并且方法隐式返回一个值，而不使用`return`关键字。然而，为了清晰起见，仍然建议使用`return`关键字。当您调用方法时，不需要括号或分号。
- en: 'There is also another, even shorter, way to define new methods in Groovy. The
    same `square` method can also look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，还有另一种定义新方法的更简短的方法。相同的`square`方法也可以这样表示：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is not a regular method, but a closure. The concept of closures does not
    exist in the same way in Java, but it plays a significant role in Groovy and in
    Gradle especially.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个普通的方法，而是一个闭包。闭包的概念在Java中并不以相同的方式存在，但在Groovy和Gradle中起着重要作用。
- en: Closures
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are anonymous blocks of code that can accept parameters and can return
    a value. They can be assigned to variables and can be passed as parameters to
    methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是接受参数并可以返回值的匿名代码块。它们可以被分配给变量，也可以作为参数传递给方法。
- en: 'You can define a closure simply by adding a block of code between curly brackets,
    as you saw in the previous example. If you want to be a bit more explicit, you
    can add the type to your definition, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在花括号之间添加一个代码块来定义一个闭包，就像你在前面的例子中看到的那样。如果你想更明确一些，你可以在定义中添加类型，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding the `Closure` type makes it clear to everyone working with the code that
    a closure is being defined. The preceding example also introduces the concept
    of an implicit untyped argument named `it`. If you do not explicitly add a parameter
    to a closure, Groovy will add one automatically. This parameter is always called
    `it`, and you can use it in all closures. If the caller does not specify any parameters,
    `it` is null. This can make your code a bit more concise, but it is only useful
    if the closure takes just one single parameter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `Closure` 类型可以让所有与代码工作的人清楚地知道正在定义一个闭包。前面的例子还介绍了名为 `it` 的隐式无类型参数的概念。如果你没有显式地向闭包添加参数，Groovy
    会自动添加一个。这个参数始终被称为 `it`，你可以在所有闭包中使用它。如果调用者没有指定任何参数，`it` 是 null。这可以使你的代码更加简洁，但只有在闭包只接受一个单一参数时才有用。
- en: In the context of Gradle, we work with closures all the time. In this book,
    we have been referring to closures as blocks so far. This means that, for example,
    the `android` block and the `dependencies` block are closures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 的上下文中，我们一直在使用闭包。在这本书中，我们一直把闭包称为块。这意味着，例如，`android` 块和 `dependencies`
    块都是闭包。
- en: Collections
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'There are two important collection types when using Groovy in a Gradle context:
    lists and maps.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Groovy 的 Gradle 上下文中，有两个重要的集合类型：列表和映射。
- en: 'Creating a new list in Groovy is easy. There is no need for special initializers;
    you can simply create a list like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中创建一个新的列表非常简单。不需要特殊的初始化器；你可以简单地创建一个列表，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Iterating over a list is also extremely easy. You can use the `each` method
    to iterate over every element in a list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表也非常容易。你可以使用 `each` 方法遍历列表中的每个元素：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `each` method enables you to access each element in the list. You can make
    this code even shorter by using the `it` variable that was mentioned earlier:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`each` 方法允许你访问列表中的每个元素。你可以通过使用前面提到的 `it` 变量来使这段代码更短。 '
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another type of collection that is important in the context of Gradle is `Map`.
    Maps are used in several Gradle settings and methods. A map is, simply put, a
    list that contains key-value pairs. You can define a map like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 的上下文中，另一种重要的集合类型是 `Map`。映射在多个 Gradle 设置和方法中使用。简单来说，映射是一个包含键值对的列表。你可以这样定义一个映射：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To access specific items in a map, use the `get` method or square brackets:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问映射中的特定项，请使用 `get` 方法或方括号：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Groovy has a shortcut for this functionality as well. You can use dot notation
    for map elements, using the key to retrieve the value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 也为此功能提供了一个快捷方式。你可以使用点符号来表示映射元素，使用键来检索值：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Groovy in Gradle
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Groovy 在 Gradle 中
- en: 'Now that you know the basics of Groovy, it is an interesting exercise to go
    back, look at a Gradle build file, and read it. Notice that it has become easier
    to understand why the syntax for configuration looks the way it does. For example,
    look at the line where the Android plugin is applied to the build:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Groovy 的基础知识，回顾一个 Gradle 构建文件并阅读它是一个有趣的练习。注意，配置的语法为什么是这样的已经变得更容易理解了。例如，看看应用
    Android 插件的那一行：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This piece of code is full of Groovy shortcuts. If you write it out without
    any of the shortcuts, it looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码充满了 Groovy 快捷方式。如果你不使用任何快捷方式来写它，它看起来像这样：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rewriting the line without Groovy shortcuts makes it clear that `apply()` is
    a method of the `Project` class, which is the basic building block of every Gradle
    build. The `apply()` method takes one parameter, which is a `Map` with a key `plugin`
    and value `com.android.application`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 Groovy 快捷方式重写这一行，可以清楚地看出 `apply()` 是 `Project` 类的一个方法，这是每个 Gradle 构建的基本构建块。`apply()`
    方法接受一个参数，它是一个包含键 `plugin` 和值 `com.android.application` 的 `Map`。
- en: 'Another example is the `dependencies` block. Previously, we defined dependencies
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是 `dependencies` 块。之前，我们是这样定义依赖项的：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now know that this block is a closure, passed to the `dependencies()` method
    on a `Project` object. This closure is passed to a `DependencyHandler`, which
    contains the `add()` method. That method accepts three parameters: a string defining
    the configuration, an object defining the dependency notation, and a closure that
    contains properties specifically for this dependency. When you write this out
    in full, it looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道这个块是一个闭包，它被传递给`Project`对象上的`dependencies()`方法。这个闭包被传递给一个`DependencyHandler`，它包含`add()`方法。该方法接受三个参数：一个定义配置的字符串，一个定义依赖项表示法的对象，以及一个包含特定于此依赖项的属性的闭包。当你完整地写出来时，它看起来像这样：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The build configuration files we have been looking at so far should start making
    a lot more sense, now that you know what it looks like behind the curtains.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前一直在看的构建配置文件，现在你应该已经对它们有了更多的了解，因为你已经知道了幕后的样子。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to know more about the way Gradle makes use of Groovy under the
    hood, you can use the official documentation for `Project` as a starting point.
    You can find it at [http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Gradle在底层如何使用Groovy的信息，你可以将`Project`的官方文档作为起点。你可以在这里找到它：[http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html)。
- en: Getting started with tasks
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用任务
- en: Custom Gradle tasks can significantly improve the daily life of a developer.
    Tasks can manipulate the existing build process, add new build steps, or influence
    the outputs of a build. You can perform simple tasks, such as renaming a generated
    APK, by hooking into the Android plugin for Gradle. Tasks also enable you to run
    more complex code, so you can generate images for several densities before your
    app is packaged, for instance. Once you know how to create your own tasks, you
    will find yourself empowered to change every aspect of your build process. This
    is especially true when you learn how to hook into the Android plugin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义Gradle任务可以显著提高开发者的日常工作效率。任务可以操作现有的构建过程，添加新的构建步骤，或影响构建的输出。你可以执行简单的任务，例如通过挂钩到Gradle的Android插件来重命名生成的APK。任务还允许你运行更复杂的代码，例如在应用打包之前为多个密度生成图像。一旦你知道如何创建自己的任务，你就会发现自己能够改变构建过程的每一个方面。这尤其在你学习了如何挂钩到Android插件时更为明显。
- en: Defining tasks
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义任务
- en: 'Tasks belong to a `Project` object, and each task implements the `Task` interface.
    The easiest way to define a new task is by executing the `task` method with the
    name of the task as its parameter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 任务属于一个`Project`对象，并且每个任务都实现了`Task`接口。定义一个新任务的最简单方法是通过执行`task`方法，并将任务名称作为其参数：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This creates the task, but it will not do anything when you execute it. To
    create a task that is somewhat useful, you need to add some actions to it. A common
    beginner''s mistake is to create tasks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建任务，但当你执行它时，它不会做任何事情。要创建一个稍微有用一些的任务，你需要向它添加一些动作。一个常见的初学者错误是创建像这样的任务：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you execute this task, you see this output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此任务时，你会看到以下输出：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From the output, you might get the impression that this works, but, in fact,
    "Hello, world!" was printed out before the task was even executed. To understand
    what is going on here, we need to get back to the basics. In [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Gradle and Android Studio"), *Getting Started
    with Gradle and Android Studio*, we talked about the lifecycle of a Gradle build.
    There are three phases in any Gradle build: the initialization phase, the configuration
    phase, and the execution phase. When you add code to a task in the same way as
    in the previous example, you are actually setting up the configuration of the
    task. Even if you were to execute a different task, the "Hello, world!" message
    would still show up.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可能会得到这样的印象，这好像是在工作，但实际上，“Hello, world!”在任务执行之前就已经打印出来了。为了理解这里发生了什么，我们需要回到基础。在[第1章](ch01.html
    "第1章. 开始使用Gradle和Android Studio")中，我们讨论了Gradle构建的生命周期。任何Gradle构建都有三个阶段：初始化阶段、配置阶段和执行阶段。当你以与上一个示例相同的方式向任务添加代码时，你实际上是在设置任务的配置。即使你要执行不同的任务，"Hello,
    world!"消息仍然会显示出来。
- en: 'If you want to add actions to a task for the execution phase, use this notation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在任务的执行阶段添加动作，请使用以下标记：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only difference here is the `<<` before the closure. This tells Gradle that
    the code is meant for the execution phase, and not the configuration phase.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是闭包前的 `<<`。这告诉 Gradle 代码是用于执行阶段，而不是配置阶段。
- en: 'To demonstrate the difference, consider this build file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示差异，考虑以下构建文件：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We define the task `hello`, which prints to the screen when it is executed.
    We also define code for the configuration phase of the `hello` task, which prints
    `Configuration` to the screen. Even though the configuration block is defined
    after the actual task code definition, it will still be executed first. This is
    the output of the preceding example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `hello` 的任务，当它执行时会在屏幕上打印。我们还定义了 `hello` 任务的配置阶段代码，它会在屏幕上打印 `Configuration`。尽管配置块是在实际任务代码定义之后定义的，但它仍然会首先执行。这是前面示例的输出：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Accidental use of the configuration phase resulting in failing tasks is a common
    mistake. Keep that in mind when you start creating your own tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置阶段的不当使用而导致任务失败是一个常见的错误。当你开始创建自己的任务时，请记住这一点。
- en: 'Because Groovy has so many shortcuts, there are several ways to define tasks
    in Gradle:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Groovy 有很多快捷方式，Gradle 中定义任务有几种方式：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first two blocks are just two different ways to achieve the same thing
    with Groovy. You can use parentheses, but you do not need to. You do not need
    single quotes around the parameter either. In these two blocks, we call the `task()`
    method, which takes in two parameters: a string for the name of the task, and
    a closure. The `task()` method is a part of Gradle''s `Project` class.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个块只是使用 Groovy 实现相同功能的不同方式。你可以使用括号，但不是必须的。参数周围也不需要单引号。在这两个块中，我们调用 `task()`
    方法，它接受两个参数：一个用于任务名称的字符串和一个闭包。`task()` 方法是 Gradle 的 `Project` 类的一部分。
- en: The last block does not use the `task()` method. Instead, it makes use of an
    object named `tasks`, which is an instance of `TaskContainer`, and is present
    in every `Project` object. This class provides a `create()` method that takes
    a `Map` and a closure as parameters and returns a `Task`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个块没有使用 `task()` 方法。相反，它使用了一个名为 `tasks` 的对象，这是一个 `TaskContainer` 的实例，并且存在于每个
    `Project` 对象中。这个类提供了一个 `create()` 方法，它接受一个 `Map` 和一个闭包作为参数，并返回一个 `Task`。
- en: It is convenient to write the short form, and most online examples and tutorials
    will use them. However, writing the longer form can be useful while learning.
    This way, Gradle will seem a lot less like magic, and it will become a lot easier
    to understand what is going on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 写简短的形式很方便，大多数在线示例和教程都会使用它们。然而，在学习的初期，写较长的形式可能很有用。这样，Gradle 似乎就不会那么像魔法一样，而且理解正在发生的事情会容易得多。
- en: Anatomy of a task
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务结构
- en: The `Task` interface is the basis of all tasks and defines a collection of properties
    and methods. All of these are implemented by a class named `DefaultTask`. This
    is the standard task type implementation, and when you create a new task, it is
    based on `DefaultTask`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 接口是所有任务的基础，定义了一系列属性和方法。所有这些都被一个名为 `DefaultTask` 的类实现。这是标准的任务类型实现，当你创建一个新的任务时，它基于
    `DefaultTask`。'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically speaking, `DefaultTask` is not really the class that implements
    all the methods in the `Task` interface. Gradle has an internal type named `AbstractTask`,
    that contains the implementation for all the methods. Because `AbstractTask` is
    internal, we cannot override it. Thus, we focus on `DefaultTask`, which derives
    from `AbstractTask`, and which can be overridden.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，`DefaultTask` 并不是实现 `Task` 接口中所有方法的类。Gradle 有一个内部类型名为 `AbstractTask`，它包含了所有方法的实现。因为
    `AbstractTask` 是内部的，所以我们不能覆盖它。因此，我们关注 `DefaultTask`，它继承自 `AbstractTask`，并且可以被覆盖。
- en: Every `Task` contains a collection of `Action` objects. When a task is executed,
    all of these actions are executed in a sequential order. To add actions to a task,
    you can use the methods `doFirst()` and `doLast()`. These methods both take a
    closure as a parameter, and then wrap it into an `Action` object for you.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Task` 都包含一个 `Action` 对象的集合。当任务执行时，所有这些动作都会按顺序执行。要向任务添加动作，你可以使用 `doFirst()`
    和 `doLast()` 方法。这两个方法都接受一个闭包作为参数，然后为你将其包装成一个 `Action` 对象。
- en: You always need to use either `doFirst()` or `doLast()` to add code to a task
    if you want that code to be a part of the execution phase. The left-shift operator
    (`<<`) we used previously to define tasks is a shortcut for the `doFirst()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是需要使用 `doFirst()` 或 `doLast()` 来添加代码到任务中，如果你想这段代码成为执行阶段的一部分。我们之前用来定义任务的左移运算符
    (`<<`) 是 `doFirst()` 方法的快捷方式。
- en: 'Here is an example of the use of `doFirst()` and `doLast()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`doFirst()`和`doLast()`使用的一个示例：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you execute the `hello` task, this is the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行`hello`任务时，这是输出结果：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Even though the line of code that prints "Goodbye" is defined before the line
    of code that prints "Hello", they end up in the correct order when the task is
    executed. You can even use `doFirst()` and `doLast()` multiple times, as shown
    in this example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即使打印"Goodbye"的代码行定义在打印"Hello"的代码行之前，但在任务执行时它们会以正确的顺序出现。你甚至可以使用`doFirst()`和`doLast()`多次，如本示例所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Executing this task will return the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此任务将返回以下输出：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how `doFirst()` always adds an action to the very beginning of a task,
    and `doLast()` adds an action to the very end. This means you need to be careful
    when you use these methods, especially when the order is important.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`doFirst()`总是将操作添加到任务的开始部分，而`doLast()`则将操作添加到任务的末尾。这意味着在使用这些方法时，特别是当顺序很重要时，你需要格外小心。
- en: 'When it comes to ordering tasks, you can use the `mustRunAfter()` method. This
    method allows you to influence how Gradle constructs the dependency graph. When
    you use `mustRunAfter()`, you specify that if two tasks are executed, one must
    always be executed before the other:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务排序方面，你可以使用`mustRunAfter()`方法。此方法允许你影响Gradle构建依赖图的方式。当你使用`mustRunAfter()`时，你指定如果两个任务被执行，其中一个必须始终在另一个之前执行：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running both `task1` and `task2` will always result in the execution of `task1`
    before `task2`, regardless of the order you specify:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行`task1`和`task2`将始终导致`task1`在`task2`之前执行，无论你指定的顺序如何：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `mustRunAfter()` method does not add a dependency between the tasks; it
    is still possible to execute `task2` without executing `task1`. If you need one
    task to depend on another, use the `dependsOn()` method instead. The difference
    between `mustRunAfter()` and `dependsOn()` is best explained with an example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`mustRunAfter()`方法不会在任务之间添加依赖关系；仍然可以在不执行`task1`的情况下执行`task2`。如果你需要一个任务依赖于另一个任务，请使用`dependsOn()`方法。`mustRunAfter()`和`dependsOn()`之间的区别最好通过一个示例来解释：'
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is what it looks like when you try to execute `task2` without executing
    `task1`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当你尝试在不执行`task1`的情况下执行`task2`时的样子：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using `mustRunAfter()`, `task1` is always executed before `task2` when you run
    them both, but both can still be executed independently. With `dependsOn()`, the
    execution of `task2` always triggers `task1` as well, even if it is not explicitly
    mentioned. This is an important distinction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mustRunAfter()`，当你同时运行`task1`和`task2`时，`task1`总是先于`task2`执行，但它们仍然可以独立执行。使用`dependsOn()`，`task2`的执行总是触发`task1`，即使它没有被明确提及。这是一个重要的区别。
- en: Using a task to simplify the release process
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务简化发布过程
- en: 'Before you can release an Android app to the Google Play store, you need to
    sign it with a certificate. To do this, you need to create your own keystore,
    which contains a set of private keys. When you have your keystore and a private
    key for the application, you can define the signing configuration in Gradle, like
    this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够将Android应用程序发布到Google Play商店之前，你需要使用证书对其进行签名。为此，你需要创建自己的密钥库，其中包含一组私钥。当你拥有密钥库和应用程序的私钥时，你可以在Gradle中定义签名配置，如下所示：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The downside of this approach is that your keystore passwords are stored in
    plaintext in the repository. If you are working on an open source project, this
    is a definite no-go; anyone with access to both the keystore file and the keystore
    passwords would be able to publish apps using your identity. In order to prevent
    this, you could create a task that asks for the release passwords every time you
    assemble the release package. This is a little cumbersome though, and it makes
    it impossible for your build server to automatically generate release builds.
    A good solution to store the keystore passwords is to create a configuration file
    that is not included in the repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你的密钥库密码以纯文本形式存储在仓库中。如果你正在从事开源项目，这绝对是不允许的；任何能够访问密钥库文件和密钥库密码的人都可以使用你的身份发布应用程序。为了防止这种情况，你可以在每次构建发布包时创建一个任务来请求发布密码。但这会稍微有些繁琐，并且使得你的构建服务器无法自动生成发布构建。存储密钥库密码的一个好方法是创建一个不包括在仓库中的配置文件。
- en: 'Start by creating a file named `private.properties` in the root of the project,
    and add this line to it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目的根目录下创建一个名为`private.properties`的文件，并将其添加到该文件中：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We assume that the passwords for both the keystore and the key itself are the
    same. If you have two different passwords, it is easy to add a second property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设密钥库和密钥本身的密码是相同的。如果你有两个不同的密码，很容易添加第二个属性。
- en: 'Once that is set up, you can define a new task named `getReleasePassword`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你可以定义一个名为`getReleasePassword`的新任务：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This task will look for a file named `private.properties` in the root of the
    project. If this file exists, the task will load all properties from its content.
    The `properties.load()` method looks for key-value pairs, such as the `release.password`
    we defined in the properties file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务将在项目的根目录中查找名为`private.properties`的文件。如果此文件存在，任务将加载其内容中的所有属性。`properties.load()`方法查找键值对，例如在属性文件中定义的`release.password`。
- en: 'To make sure anyone can run the script without the private properties files,
    or to handle the case where the properties file exists, but the password property
    is not present, add a fallback. If the password is still empty, ask for the password
    in the console:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保任何人都可以在没有私有属性文件的情况下运行脚本，或者处理属性文件存在但密码属性不存在的情况，请添加一个回退。如果密码仍然为空，请在控制台中请求密码：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Checking if a string is not null or empty is a very concise process with Groovy.
    The question mark in `password?.trim()` does a null check and will prevent the
    `trim()` method from being called if it turns out `password` is null. We do not
    need to explicitly check for null or empty, because both null and empty strings
    are equal to false in the context of an if-clause.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Groovy检查一个字符串是否不为空或空是一个非常简洁的过程。`password?.trim()`中的问号执行空检查，如果`password`为空，则不会调用`trim()`方法。我们不需要显式检查空或空字符串，因为在if子句的上下文中，null和空字符串都等于false。
- en: The use of `new String()` is necessary because `System.readPassword()` returns
    an array of characters, which needs to be converted to a string explicitly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new String()`是必要的，因为`System.readPassword()`返回一个字符数组，需要显式地将其转换为字符串。
- en: 'Once we have the keystore passwords, we can configure the signing configuration
    for the release build:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了密钥库密码，我们可以配置发布构建的签名配置：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have finished our task, we need to make sure it is executed when
    performing a release build. To do this, add these lines to the `build.gradle`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了任务，我们需要确保在执行发布构建时任务能够被执行。为此，请将这些行添加到`build.gradle`文件中：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code hooks into Gradle and the Android plugin by adding a closure that
    needs to be run when the tasks are being added to the dependency graph. The password
    is not required until the `packageRelease` task is executed, so we make sure that
    `packageRelease` depends on our `getReleasePassword` task. The reason we cannot
    just use `packageRelease.dependsOn()` is that the Android plugin for Gradle generates
    the packaging tasks dynamically, based on the build variants. This means that
    the `packageRelease` task does not exist until the Android plugin has discovered
    all of the build variants. The discovery process is kicked off before every single
    build.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过添加一个需要在任务被添加到依赖图时运行的闭包来集成到Gradle和Android插件中。密码不是必需的，直到执行`packageRelease`任务。因此，我们确保`packageRelease`依赖于我们的`getReleasePassword`任务。我们不能直接使用`packageRelease.dependsOn()`的原因是，Gradle的Android插件根据构建变体动态生成打包任务。这意味着`packageRelease`任务在Android插件发现所有构建变体之前不存在。这个过程在每次构建之前启动。
- en: 'After adding the task and the build hook, this is the result of executing `gradlew
    assembleRelease`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加任务和构建钩子后，执行`gradlew assembleRelease`的结果如下：
- en: '![Using a task to simplify the release process](img/B01061_07_01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务简化发布过程](img/B01061_07_01.jpg)'
- en: As you can see in the preceding screenshot, the `private.properties` file was
    not available, so the task asked for the password in the console. In this case,
    we also added a message explaining how to create the properties file and add the
    password property to make future builds easier. Once our task picked up the keystore
    password, Gradle was able to package our app and finish the build.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`private.properties`文件不可用，因此任务在控制台中请求密码。在这种情况下，我们还添加了一条消息，解释如何创建属性文件并将密码属性添加到其中，以便使未来的构建更容易。一旦我们的任务获取了密钥库密码，Gradle就能够打包我们的应用程序并完成构建。
- en: To get this task to work, it was essential to hook into Gradle and the Android
    plugin. This is a powerful concept, so we will explore this in detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个任务能够工作，集成到Gradle和Android插件中是至关重要的。这是一个强大的概念，因此我们将详细探讨这一点。
- en: Hooking into the Android plugin
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到Android插件中
- en: When developing for Android, most tasks we want to influence are related to
    the Android plugin. It is possible to augment the behavior of tasks by hooking
    into the build process. In the previous example, we already saw how to add a dependency
    on a custom task to include a new task in the regular build process. In this section,
    we will look at some possibilities for Android-specific build hooks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Android 开发时，我们想要影响的大多数任务都与 Android 插件相关。通过挂钩到构建过程，可以增强任务的行为。在前面的例子中，我们已经看到了如何添加一个自定义任务的依赖项，以便将其包含在常规构建过程中。在本节中，我们将探讨一些针对
    Android 特定的构建钩子的可能性。
- en: 'One way to hook into the Android plugin is to manipulate the build variants.
    Doing this is quite straightforward; you just need the following code snippet
    to iterate over all the build variants of an app:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将钩子连接到 Android 插件的一种方法是通过操作构建变体。这样做相当直接；你只需要以下代码片段来遍历应用的所有构建变体：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To get the collection of build variants, you can use the `applicationVariants`
    object. Once you have a reference to a build variant, you can access and manipulate
    its properties, such as name, description, and so on. If you want to use the same
    logic for an Android library, use `libraryVariants` instead of `applicationVariants`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取构建变体的集合，你可以使用 `applicationVariants` 对象。一旦你有一个构建变体的引用，你可以访问并操作其属性，例如名称、描述等。如果你想要为
    Android 库使用相同的逻辑，请使用 `libraryVariants` 而不是 `applicationVariants`。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we iterate over the build variants with `all()` instead of the `each()`
    method that we mentioned earlier. This is necessary because `each()` is triggered
    in the evaluation phase before the build variants have been created by the Android
    plugin. The `all()` method, on the other hand, is triggered every time a new item
    is added to the collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `all()` 方法而不是之前提到的 `each()` 方法来遍历构建变体。这是必要的，因为 `each()` 方法在构建变体由 Android
    插件创建之前的评估阶段被触发。另一方面，`all()` 方法每次向集合中添加新项目时都会被触发。
- en: This hook can be used to change the name of the APK before it is saved, to add
    the version number to the filename. This makes it easy to maintain an archive
    of APKs without manually editing file names. In the next section, we will see
    how to accomplish that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子可用于在 APK 保存之前更改其名称，将版本号添加到文件名中。这使得在没有手动编辑文件名的情况下维护 APK 存档变得容易。在下一节中，我们将看到如何实现这一点。
- en: Automatically renaming APKs
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动重命名 APKs
- en: 'A common use case for manipulating the build process is to rename APKs to include
    the version number after they are packaged. You can do this by iterating over
    the build variants of the app, and changing the `outputFile` property of its outputs,
    as demonstrated in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作构建过程的一个常见用例是将打包后的 APKs 重命名为包含版本号。你可以通过遍历应用的不同构建变体来实现这一点，并更改其输出的 `outputFile`
    属性，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Every build variant has a collection of outputs. The output of an Android app
    is just an APK. The output objects each have a property of the type `File` named
    `outputFile`. Once you know the path of the output, you can manipulate it. In
    this example, we add the version name of the variant to the file name. This will
    result in an APK named `app-debug-1.0.apk` instead of `app-debug.apk`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构建变体都有一个输出集合。Android 应用的输出只是一个 APK。每个输出对象都有一个名为 `outputFile` 的 `File` 类型属性。一旦你知道输出路径，你就可以对其进行操作。在这个例子中，我们将变体的版本名称添加到文件名中。这将导致一个名为
    `app-debug-1.0.apk` 的 APK，而不是 `app-debug.apk`。
- en: Combining the power of build hooks for the Android plugin with the simplicity
    of Gradle tasks opens up a world of possibilities. In the next section, we will
    see how to create a task for every build variant of an app.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Android 插件的构建钩子与 Gradle 任务的简单性相结合，打开了一个无限可能的世界。在下一节中，我们将看到如何为应用的所有构建变体创建任务。
- en: Dynamically creating new tasks
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态创建新任务
- en: Because of the way that Gradle works and tasks are constructed, we can easily
    create our own tasks in the configuration phase, based on the Android build variants.
    To demonstrate this powerful concept, we will create a task to not just install,
    but also run any build variant of an Android app. The `install` task is a part
    of the Android plugin, but if you install an app from the command-line interface
    using the `installDebug` task, you will still need to start it manually when the
    installation is complete. The task we will create in this section will eliminate
    that last step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Gradle 的工作方式和任务的构建方式，我们可以在配置阶段轻松创建自己的任务，基于 Android 构建变体。为了演示这个强大的概念，我们将创建一个任务，不仅安装，还可以运行
    Android 应用程序的任何构建变体。`install` 任务是 Android 插件的一部分，但如果您使用 `installDebug` 任务从命令行界面安装应用程序，那么在安装完成后，您仍然需要手动启动它。本节中我们将创建的任务将消除最后一步。
- en: 'Start by hooking into the `applicationVariants` property that we used earlier:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过连接到我们之前使用的 `applicationVariants` 属性开始：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For every variant, we check if it has a valid `install` task. This needs to
    be present because the new `run` task we are creating will depend on the `install`
    task. Once we have verified that the `install` task is present, we create a new
    task, and name it based on the variant's name. We also make our new task dependent
    on `variant.install`. This will trigger the `install` task before our task is
    executed. Inside the `tasks.create()` closure, start by adding a description,
    which is displayed when you execute `gradlew tasks`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个变体，我们检查它是否有一个有效的 `install` 任务。这是因为我们正在创建的新 `run` 任务将依赖于 `install` 任务。一旦我们验证了
    `install` 任务的存在，我们就创建一个新的任务，并根据变体的名称命名它。我们还使我们的新任务依赖于 `variant.install`。这将触发在执行我们的任务之前执行
    `install` 任务。在 `tasks.create()` 闭包内部，首先添加一个描述，当您执行 `gradlew tasks` 时会显示。
- en: 'Besides adding the description, we also need to add the actual task action.
    In this example, we want to launch the app. You can launch an app on a connected
    device or emulator with the **Android Debug Tool** (**ADB**):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加描述外，我们还需要添加实际的任务操作。在这个例子中，我们想要启动应用程序。您可以使用 **Android 调试工具**（**ADB**）在连接的设备或模拟器上启动应用程序：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Gradle has a method called `exec()` that makes it possible to execute a command-line
    process. To make `exec()` work, we need to provide an executable that is present
    in the `PATH` environment variable. We also need to pass all the parameters with
    the `args` property, which takes a list of strings. Here is what that looks like:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 有一个名为 `exec()` 的方法，它使得执行命令行进程成为可能。为了让 `exec()` 工作，我们需要提供一个存在于 `PATH`
    环境变量中的可执行文件。我们还需要通过 `args` 属性传递所有参数，该属性接受一个字符串列表。下面是这个样子的：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To get the full package name, use the application ID of the build variant,
    which includes a suffix, if provided. There is one issue with suffixes in this
    case, though. Even if we add a suffix, the classpath to the activity is still
    the same. For example, consider this configuration:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的包名，请使用包含后缀（如果提供）的构建变体的应用程序 ID。不过，在这种情况下，后缀有一个问题。即使我们添加了后缀，活动的类路径仍然是相同的。例如，考虑以下配置：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The package name is `com.gradleforandroid.debug`, but the activity''s path
    is still `com.gradleforandroid.Activity`. To make sure we get the right class
    to the activity, strip the suffix from the application ID:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 包名是 `com.gradleforandroid.debug`，但活动的路径仍然是 `com.gradleforandroid.Activity`。为了确保我们得到正确的类到活动，从应用程序
    ID 中移除后缀：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we create a variable named `classpath`, based on the application ID.
    Then we find the suffix, provided by the `buildType.applicationIdSuffix` property.
    In Groovy, it is possible to subtract a string from another string, using the
    minus operator. These changes make sure running the app after installation does
    not fail when suffixes are used.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `classpath` 的变量，基于应用程序 ID。然后我们找到由 `buildType.applicationIdSuffix`
    属性提供的后缀。在 Groovy 中，可以使用减号运算符从一个字符串中减去另一个字符串。这些更改确保在安装后运行应用程序时，使用后缀不会失败。
- en: Creating your own plugins
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的插件
- en: If you have a collection of Gradle tasks that you want to reuse in several projects,
    it makes sense to extract these tasks into a custom plugin. This makes it possible
    to reuse build logic yourself, and to share it with others.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一系列 Gradle 任务想要在多个项目中重用，将这些任务提取到一个自定义插件中是有意义的。这使得您可以自己重用构建逻辑，并与他人共享。
- en: Plugins can be written in Groovy, but also in other languages that make use
    of the JVM, such as Java and Scala. In fact, big parts of the Android plugin for
    Gradle are written in Java in combination with Groovy.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以用 Groovy 编写，也可以用其他利用 JVM 的语言编写，例如 Java 和 Scala。实际上，Gradle 的 Android 插件的大部分代码是用
    Java 和 Groovy 结合编写的。
- en: Creating a simple plugin
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的插件
- en: To extract build logic that is already stored in your build configuration file,
    you can create a plugin within the `build.gradle` file. This is the easiest way
    to get started with custom plugins.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取已存储在构建配置文件中的构建逻辑，您可以在 `build.gradle` 文件中创建一个插件。这是开始使用自定义插件的最简单方法。
- en: 'To create a plugin, create a new class that implements the `Plugin` interface.
    We will use the code we wrote previously in this chapter, which dynamically creates
    `run` tasks. Our plugin class looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个插件，创建一个新的类来实现 `Plugin` 接口。我们将使用本章之前编写的代码，该代码动态创建 `run` 任务。我们的插件类看起来像这样：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Plugin` interface defines an `apply()` method. Gradle calls this method
    when the plugin is used in a build file. The project is passed as a parameter
    so that the plugin can configure the project or use its methods and properties.
    In the preceding example, we cannot call properties from the Android plugin directly.
    Instead, we need to access the project object first. Note that this requires the
    Android plugin to be applied to the project before our custom plugin is applied.
    Otherwise, `project.android` will cause an exception.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plugin` 接口定义了一个 `apply()` 方法。当插件在构建文件中使用时，Gradle 会调用此方法。项目作为参数传递，以便插件可以配置项目或使用其方法和属性。在前面的示例中，我们不能直接调用
    Android 插件中的属性。相反，我们需要首先访问项目对象。请注意，这要求在应用我们的自定义插件之前，必须先应用 Android 插件。否则，`project.android`
    将引发异常。'
- en: 'The code for the task is the same as it was earlier, except for one method
    call: instead of calling `exec()`, we now need to call `project.exec()`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的代码与之前相同，除了一个方法调用：我们不再调用 `exec()`，而是现在需要调用 `project.exec()`。
- en: 'To make sure the plugin is applied to our build configuration, add this line
    to `build.gradle`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保插件应用于我们的构建配置，将此行添加到 `build.gradle`：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Distributing plugins
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发插件
- en: In order to distribute a plugin and share it with others, you need to move it
    into a standalone module (or project). A standalone plugin has its own build file
    to configure dependencies and means of distribution. This module produces a JAR
    file, containing the plugin classes and properties. You can use this JAR file
    to apply the plugin in several modules and projects, and to share it with others.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发插件并与他人共享，您需要将其移动到一个独立的模块（或项目）中。一个独立的插件有自己的构建文件来配置依赖项和分发方式。此模块生成一个 JAR 文件，其中包含插件类和属性。您可以使用此
    JAR 文件在多个模块和项目中应用插件，并与他人共享。
- en: 'As with any Gradle project, create a `build.gradle` file to configure the build:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Gradle 项目一样，创建一个 `build.gradle` 文件来配置构建：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we are writing the plugin in Groovy, we need to apply the Groovy plugin.
    The Groovy plugin extends on the Java plugin, and enables us to build and package
    Groovy classes. Both Groovy and plain Java are supported, so you can mix them
    if you like. You can even go so far as to extend a Java class using Groovy, or
    the other way around. This makes it easy to get started, even if you do not feel
    confident using Groovy for everything.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是用 Groovy 编写插件的，我们需要应用 Groovy 插件。Groovy 插件扩展了 Java 插件，并使我们能够构建和打包 Groovy
    类。Groovy 和纯 Java 都受支持，因此如果您喜欢，可以混合使用。您甚至可以使用 Groovy 扩展 Java 类，或者相反。这使得即使您不自信使用
    Groovy 做所有事情，也能轻松开始。
- en: 'Our build configuration file contains two dependencies: `gradleApi()` and `localGroovy()`.
    The Gradle API is required to access Gradle namespaces from our custom plugin,
    and `localGroovy()` is a distribution of the Groovy SDK that comes with the Gradle
    installation. Gradle provides these dependencies by default for our convenience.
    If Gradle did not provide these dependencies out of the box, we would have to
    download and reference them manually.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建配置文件包含两个依赖项：`gradleApi()` 和 `localGroovy()`。Gradle API 是从我们的自定义插件访问 Gradle
    命名空间所必需的，而 `localGroovy()` 是与 Gradle 安装一起提供的 Groovy SDK 的分发。Gradle 默认为我们提供了这些依赖项，以便于使用。如果
    Gradle 没有提供这些依赖项，我们就必须手动下载并引用它们。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you plan to distribute your plugin publically, make sure to specify the
    group and version information in the build configuration file, like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划公开分发您的插件，请确保在构建配置文件中指定组和版本信息，如下所示：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To get started with the code in our standalone module, we first need to make
    sure to use the correct directory structure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用我们独立模块中的代码，我们首先需要确保使用正确的目录结构：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As with any other Gradle module, we need to provide a `src/main` directory.
    Because this is a Groovy project, the subdirectory of `main` is called `groovy`
    instead of `java`. There is another subdirectory of `main` called `resources`,
    which we will use to specify our plugin's properties.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他Gradle模块一样，我们需要提供一个`src/main`目录。因为这是一个Groovy项目，所以`main`的子目录被称为`groovy`而不是`java`。还有一个名为`resources`的`main`子目录，我们将用它来指定插件的属性。
- en: 'We create a file called `RunPlugin.groovy` in the package directory, where
    we define the class for our plugin:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在包目录中创建一个名为`RunPlugin.groovy`的文件，在其中我们定义了插件对应的类：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In order for Gradle to be able to find the plugin, we need to provide a properties
    file. Add this properties file to the `src/main/resources/META-INF/gradle-plugins/`
    directory. The name of the file needs to match the ID of our plugin. For the `RunPlugin`,
    the file is named `com.gradleforandroid.run.properties`, and this is its content:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Gradle能够找到插件，我们需要提供一个属性文件。将此属性文件添加到`src/main/resources/META-INF/gradle-plugins/`目录中。文件名需要与我们的插件ID匹配。对于`RunPlugin`，文件名为`com.gradleforandroid.run.properties`，以下是其内容：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The only thing that the properties file contains is the package and name of
    the class that implements the `Plugin` interface.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件中只包含实现`Plugin`接口的类的包和名称。
- en: 'When the plugin and the properties file are ready, we can build the plugin
    using the `gradlew assemble` command. This creates a JAR file in the build output
    directory. If you want to push the plugin to a Maven repository instead, you first
    need to apply the Maven plugin:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件和属性文件准备就绪后，我们可以使用`gradlew assemble`命令来构建插件。这将在构建输出目录中创建一个JAR文件。如果你想要将插件推送到Maven仓库，首先需要应用Maven插件：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, you need to configure the `uploadArchives` task, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要配置`uploadArchives`任务，如下所示：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `uploadArchives` task is a predefined task. Once you configure a repository
    on the task, you can execute it to publish your plugin. We will not cover how
    to set up a Maven repository in this book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`uploadArchives`任务是一个预定义的任务。一旦你在任务中配置了仓库，你就可以执行它来发布你的插件。本书不会涵盖如何设置Maven仓库。'
- en: If you want to make your plugin publically available, consider publishing it
    to Gradleware's plugin portal ([https://plugins.gradle.org](https://plugins.gradle.org)).
    The plugin portal has a great collection of Gradle plugins (not just specific
    to Android development) and is the place to go when you want to extend Gradle's
    default behavior. You can find information on how to publish a plugin in the documentation
    at [https://plugins.gradle.org/docs/submit](https://plugins.gradle.org/docs/submit).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使你的插件公开可用，考虑将其发布到Gradleware的插件门户([https://plugins.gradle.org](https://plugins.gradle.org))。插件门户拥有大量的Gradle插件（不仅限于Android开发），当你想要扩展Gradle的默认行为时，这里是必去之地。你可以在[https://plugins.gradle.org/docs/submit](https://plugins.gradle.org/docs/submit)的文档中找到有关如何发布插件的信息。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Writing tests for custom plugins is not covered in this book, but is highly
    recommended if you plan to make your plugins publically available. You can find
    more information on writing tests for plugins in the Gradle user guide at [https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1](https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖为自定义插件编写测试，但如果你计划使你的插件公开可用，则强烈建议这样做。你可以在Gradle用户指南[https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1](https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1)中找到有关为插件编写测试的更多信息。
- en: Using a custom plugin
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义插件
- en: To use a plugin, we need to add it as a dependency to the `buildscript` block.
    First, we need to configure a new repository. The configuration of the repository
    depends on the way that the plugin is distributed. Second, we need to configure
    the classpath of the plugin in the `dependencies` block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用插件，我们需要将其添加到`buildscript`块中作为依赖项。首先，我们需要配置一个新的仓库。仓库的配置取决于插件是如何分发的。其次，我们需要在`dependencies`块中配置插件的类路径。
- en: 'If we want to include the JAR file that we created in the earlier example,
    we can define a `flatDir` repository:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要包含在早期示例中创建的JAR文件，我们可以定义一个`flatDir`仓库：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we had uploaded the plugin to a Maven or Ivy repository, this would look
    a little different. We covered dependency management already in [Chapter 3](ch03.html
    "Chapter 3. Managing Dependencies"), *Managing Dependencies*, so we will not repeat
    the different options here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将插件上传到 Maven 或 Ivy 仓库，这会有所不同。我们已经在 [第 3 章](ch03.html "第 3 章。管理依赖") 中介绍了依赖管理，即
    *管理依赖*，因此我们在此不会重复不同的选项。
- en: 'After we set up the dependency, we need to apply the plugin:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置依赖之后，我们需要应用插件：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When using the `apply()` method, Gradle creates an instance of the plugin class,
    and executes the plugin's own `apply()` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `apply()` 方法时，Gradle 会创建插件类的实例，并执行插件自己的 `apply()` 方法。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered how Groovy is different from Java, and how Groovy
    is used in Gradle. We saw how to create our own tasks and how to hook into the
    Android plugin, giving us a lot of power to manipulate the build process or dynamically
    add our own tasks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了 Groovy 与 Java 的不同之处，以及 Groovy 在 Gradle 中的使用方法。我们看到了如何创建自己的任务，以及如何挂钩到
    Android 插件，这给了我们很多操作构建过程或动态添加自己任务的权力。
- en: In the last part of the chapter, we looked at creating plugins and ensured that
    we can reuse them in several projects by creating a standalone plugin. There is
    much more to learn about plugins, but unfortunately, we cannot cover it all in
    this book. Luckily, the Gradle user guide has a thorough description of all the
    possibilities at [https://gradle.org/docs/current/userguide/custom_plugins.html](https://gradle.org/docs/current/userguide/custom_plugins.html).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们探讨了创建插件，并确保通过创建独立插件可以在多个项目中重用。关于插件还有很多东西要学习，但不幸的是，我们无法在这本书中涵盖所有内容。幸运的是，Gradle
    用户指南在 [https://gradle.org/docs/current/userguide/custom_plugins.html](https://gradle.org/docs/current/userguide/custom_plugins.html)
    中对所有可能性进行了详尽的描述。
- en: In the next chapter, we will talk about the importance of continuous integration
    (CI). With a good CI system in place, we can build, test, and deploy apps and
    libraries with one click. Continuous integration is thus an important part of
    build automation in general.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论持续集成（CI）的重要性。有了良好的持续集成系统，我们可以通过一键操作来构建、测试和部署应用程序和库。因此，持续集成是构建自动化的一般重要部分。
