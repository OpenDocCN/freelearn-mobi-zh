- en: Chapter 7. Creating Tasks and Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been manipulating properties for our Gradle builds and learning
    how to run tasks. In this chapter, we will get a deeper understanding of those
    properties, and start creating our own tasks. Once we know how to write our own
    tasks, we can go even further, and look at how to make our own plugins that can
    be reused in several projects.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at how to create custom tasks, we need to learn a few important
    Groovy concepts. This is because having a basic understanding of how Groovy works
    makes it a lot easier to get started with custom tasks and plugins. Knowing Groovy
    also helps to understand how Gradle works, and why the build configuration files
    look the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Groovy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking into the Android plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Groovy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As most Android developers are proficient Java developers, it is interesting
    to look at how Groovy works compared to Java. Groovy is quite easy to read if
    you are a Java developer, but writing your own Groovy code would be a hard task
    without a small introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good way to experiment with Groovy is to use the Groovy Console. This application
    comes with the Groovy SDK and makes it easy to try out Groovy statements while
    getting an immediate response. The Groovy Console is also able to handle pure
    Java code, which makes it easy to compare Java and Groovy code. You can download
    the Groovy SDK, including the Groovy Console, from the Groovy website at [http://groovy-lang.org/download.html](http://groovy-lang.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Groovy is derived from Java and runs on the Java Virtual Machine. Its goal is
    to be a simpler, more straightforward language that can be used either as a scripting
    language or as a full-blown programming language. Throughout this section, we
    will compare Groovy with Java to make it easier to grasp how Groovy works and
    to clearly see the difference between both languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, printing a string to the screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Groovy, you can accomplish the same with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will immediately notice a few key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: No `System.out` namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No parentheses around method parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No semicolons at the end of a line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example also uses single quotes around a string. You can use either single
    quotes or double quotes for strings, but they have different usages. Double-quoted
    string can also include interpolated expressions. Interpolation is the process
    of evaluating a string that contains placeholders, and replacing those placeholders
    with their values. These placeholder expressions can be variables, or even methods.
    Placeholder expressions that contain a method or multiple variables need to be
    surrounded by curly brackets and prefixed by `$`. Placeholder expressions that
    contain a single variable can just be prefixed with `$`. Here are some examples
    of string interpolation in Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `greeting` variable contains the string "Hello, Andy" and `name_size` is
    "Your name is 4 characters long.".
  prefs: []
  type: TYPE_NORMAL
- en: 'String interpolation allows you to execute code dynamically as well. This example
    is valid code that prints the current date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This looks very strange when you are used to Java, but it is normal syntax and
    behavior in dynamic programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a class in Groovy looks a lot like creating a class in Java. Here
    is an example of a simple class containing one member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that neither the class nor the member has explicit access modifiers.
    The default access modifiers in Groovy are different from in Java. Classes themselves
    are public, just like methods, while class members are private.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `MyGroovyClass`, make a new instance of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use the keyword `def` to create new variables. Once you have a new instance
    of a class, you can manipulate its members. Accessors are added automatically
    by Groovy. You can still override them, as we did with `getGreeting()` in the
    definition of `MyGroovyClass`. If you specify nothing, you will still be able
    to use both a getter and a setter for every member in your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to call a member directly, you will, in fact, call the getter. This
    means you do not need to type `instance.getGreeting()`, you can just use the shorter
    `instance.greeting` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both lines in the preceding code sample print out the exact same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with variables, you do not need to define a specific return type for
    your methods. You are free to do so anyway, even if it is just for the sake of
    clarity. Another difference between Java and Groovy methods is that in Groovy,
    the last line of a method is always returned by default, even without using the
    `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the differences between Java and Groovy, consider this Java
    example of a method that returns the square of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You need to specify that the method is publicly accessible, what the return
    type is, and what the type of the parameter is. At the end of the method, you
    need to return a value of the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same method definition looks like this in Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Neither the return type, nor the parameter type is explicitly defined. The `def`
    keyword is used instead of an explicit type, and the method implicitly returns
    a value without using the `return` keyword. However, using the `return` keyword
    is still recommended for clarity. When you call the method, you do not need parentheses
    or semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another, even shorter, way to define new methods in Groovy. The
    same `square` method can also look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is not a regular method, but a closure. The concept of closures does not
    exist in the same way in Java, but it plays a significant role in Groovy and in
    Gradle especially.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures are anonymous blocks of code that can accept parameters and can return
    a value. They can be assigned to variables and can be passed as parameters to
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a closure simply by adding a block of code between curly brackets,
    as you saw in the previous example. If you want to be a bit more explicit, you
    can add the type to your definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `Closure` type makes it clear to everyone working with the code that
    a closure is being defined. The preceding example also introduces the concept
    of an implicit untyped argument named `it`. If you do not explicitly add a parameter
    to a closure, Groovy will add one automatically. This parameter is always called
    `it`, and you can use it in all closures. If the caller does not specify any parameters,
    `it` is null. This can make your code a bit more concise, but it is only useful
    if the closure takes just one single parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Gradle, we work with closures all the time. In this book,
    we have been referring to closures as blocks so far. This means that, for example,
    the `android` block and the `dependencies` block are closures.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two important collection types when using Groovy in a Gradle context:
    lists and maps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new list in Groovy is easy. There is no need for special initializers;
    you can simply create a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating over a list is also extremely easy. You can use the `each` method
    to iterate over every element in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `each` method enables you to access each element in the list. You can make
    this code even shorter by using the `it` variable that was mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another type of collection that is important in the context of Gradle is `Map`.
    Maps are used in several Gradle settings and methods. A map is, simply put, a
    list that contains key-value pairs. You can define a map like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To access specific items in a map, use the `get` method or square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Groovy has a shortcut for this functionality as well. You can use dot notation
    for map elements, using the key to retrieve the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Groovy in Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know the basics of Groovy, it is an interesting exercise to go
    back, look at a Gradle build file, and read it. Notice that it has become easier
    to understand why the syntax for configuration looks the way it does. For example,
    look at the line where the Android plugin is applied to the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code is full of Groovy shortcuts. If you write it out without
    any of the shortcuts, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting the line without Groovy shortcuts makes it clear that `apply()` is
    a method of the `Project` class, which is the basic building block of every Gradle
    build. The `apply()` method takes one parameter, which is a `Map` with a key `plugin`
    and value `com.android.application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is the `dependencies` block. Previously, we defined dependencies
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now know that this block is a closure, passed to the `dependencies()` method
    on a `Project` object. This closure is passed to a `DependencyHandler`, which
    contains the `add()` method. That method accepts three parameters: a string defining
    the configuration, an object defining the dependency notation, and a closure that
    contains properties specifically for this dependency. When you write this out
    in full, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The build configuration files we have been looking at so far should start making
    a lot more sense, now that you know what it looks like behind the curtains.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to know more about the way Gradle makes use of Groovy under the
    hood, you can use the official documentation for `Project` as a starting point.
    You can find it at [http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Gradle tasks can significantly improve the daily life of a developer.
    Tasks can manipulate the existing build process, add new build steps, or influence
    the outputs of a build. You can perform simple tasks, such as renaming a generated
    APK, by hooking into the Android plugin for Gradle. Tasks also enable you to run
    more complex code, so you can generate images for several densities before your
    app is packaged, for instance. Once you know how to create your own tasks, you
    will find yourself empowered to change every aspect of your build process. This
    is especially true when you learn how to hook into the Android plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Defining tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tasks belong to a `Project` object, and each task implements the `Task` interface.
    The easiest way to define a new task is by executing the `task` method with the
    name of the task as its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the task, but it will not do anything when you execute it. To
    create a task that is somewhat useful, you need to add some actions to it. A common
    beginner''s mistake is to create tasks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this task, you see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, you might get the impression that this works, but, in fact,
    "Hello, world!" was printed out before the task was even executed. To understand
    what is going on here, we need to get back to the basics. In [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Gradle and Android Studio"), *Getting Started
    with Gradle and Android Studio*, we talked about the lifecycle of a Gradle build.
    There are three phases in any Gradle build: the initialization phase, the configuration
    phase, and the execution phase. When you add code to a task in the same way as
    in the previous example, you are actually setting up the configuration of the
    task. Even if you were to execute a different task, the "Hello, world!" message
    would still show up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add actions to a task for the execution phase, use this notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is the `<<` before the closure. This tells Gradle that
    the code is meant for the execution phase, and not the configuration phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the difference, consider this build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the task `hello`, which prints to the screen when it is executed.
    We also define code for the configuration phase of the `hello` task, which prints
    `Configuration` to the screen. Even though the configuration block is defined
    after the actual task code definition, it will still be executed first. This is
    the output of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accidental use of the configuration phase resulting in failing tasks is a common
    mistake. Keep that in mind when you start creating your own tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Groovy has so many shortcuts, there are several ways to define tasks
    in Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two blocks are just two different ways to achieve the same thing
    with Groovy. You can use parentheses, but you do not need to. You do not need
    single quotes around the parameter either. In these two blocks, we call the `task()`
    method, which takes in two parameters: a string for the name of the task, and
    a closure. The `task()` method is a part of Gradle''s `Project` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The last block does not use the `task()` method. Instead, it makes use of an
    object named `tasks`, which is an instance of `TaskContainer`, and is present
    in every `Project` object. This class provides a `create()` method that takes
    a `Map` and a closure as parameters and returns a `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: It is convenient to write the short form, and most online examples and tutorials
    will use them. However, writing the longer form can be useful while learning.
    This way, Gradle will seem a lot less like magic, and it will become a lot easier
    to understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Task` interface is the basis of all tasks and defines a collection of properties
    and methods. All of these are implemented by a class named `DefaultTask`. This
    is the standard task type implementation, and when you create a new task, it is
    based on `DefaultTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically speaking, `DefaultTask` is not really the class that implements
    all the methods in the `Task` interface. Gradle has an internal type named `AbstractTask`,
    that contains the implementation for all the methods. Because `AbstractTask` is
    internal, we cannot override it. Thus, we focus on `DefaultTask`, which derives
    from `AbstractTask`, and which can be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Every `Task` contains a collection of `Action` objects. When a task is executed,
    all of these actions are executed in a sequential order. To add actions to a task,
    you can use the methods `doFirst()` and `doLast()`. These methods both take a
    closure as a parameter, and then wrap it into an `Action` object for you.
  prefs: []
  type: TYPE_NORMAL
- en: You always need to use either `doFirst()` or `doLast()` to add code to a task
    if you want that code to be a part of the execution phase. The left-shift operator
    (`<<`) we used previously to define tasks is a shortcut for the `doFirst()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the use of `doFirst()` and `doLast()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the `hello` task, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the line of code that prints "Goodbye" is defined before the line
    of code that prints "Hello", they end up in the correct order when the task is
    executed. You can even use `doFirst()` and `doLast()` multiple times, as shown
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this task will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `doFirst()` always adds an action to the very beginning of a task,
    and `doLast()` adds an action to the very end. This means you need to be careful
    when you use these methods, especially when the order is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to ordering tasks, you can use the `mustRunAfter()` method. This
    method allows you to influence how Gradle constructs the dependency graph. When
    you use `mustRunAfter()`, you specify that if two tasks are executed, one must
    always be executed before the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running both `task1` and `task2` will always result in the execution of `task1`
    before `task2`, regardless of the order you specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mustRunAfter()` method does not add a dependency between the tasks; it
    is still possible to execute `task2` without executing `task1`. If you need one
    task to depend on another, use the `dependsOn()` method instead. The difference
    between `mustRunAfter()` and `dependsOn()` is best explained with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it looks like when you try to execute `task2` without executing
    `task1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using `mustRunAfter()`, `task1` is always executed before `task2` when you run
    them both, but both can still be executed independently. With `dependsOn()`, the
    execution of `task2` always triggers `task1` as well, even if it is not explicitly
    mentioned. This is an important distinction.
  prefs: []
  type: TYPE_NORMAL
- en: Using a task to simplify the release process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can release an Android app to the Google Play store, you need to
    sign it with a certificate. To do this, you need to create your own keystore,
    which contains a set of private keys. When you have your keystore and a private
    key for the application, you can define the signing configuration in Gradle, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is that your keystore passwords are stored in
    plaintext in the repository. If you are working on an open source project, this
    is a definite no-go; anyone with access to both the keystore file and the keystore
    passwords would be able to publish apps using your identity. In order to prevent
    this, you could create a task that asks for the release passwords every time you
    assemble the release package. This is a little cumbersome though, and it makes
    it impossible for your build server to automatically generate release builds.
    A good solution to store the keystore passwords is to create a configuration file
    that is not included in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a file named `private.properties` in the root of the project,
    and add this line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We assume that the passwords for both the keystore and the key itself are the
    same. If you have two different passwords, it is easy to add a second property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that is set up, you can define a new task named `getReleasePassword`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This task will look for a file named `private.properties` in the root of the
    project. If this file exists, the task will load all properties from its content.
    The `properties.load()` method looks for key-value pairs, such as the `release.password`
    we defined in the properties file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure anyone can run the script without the private properties files,
    or to handle the case where the properties file exists, but the password property
    is not present, add a fallback. If the password is still empty, ask for the password
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Checking if a string is not null or empty is a very concise process with Groovy.
    The question mark in `password?.trim()` does a null check and will prevent the
    `trim()` method from being called if it turns out `password` is null. We do not
    need to explicitly check for null or empty, because both null and empty strings
    are equal to false in the context of an if-clause.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `new String()` is necessary because `System.readPassword()` returns
    an array of characters, which needs to be converted to a string explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the keystore passwords, we can configure the signing configuration
    for the release build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have finished our task, we need to make sure it is executed when
    performing a release build. To do this, add these lines to the `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code hooks into Gradle and the Android plugin by adding a closure that
    needs to be run when the tasks are being added to the dependency graph. The password
    is not required until the `packageRelease` task is executed, so we make sure that
    `packageRelease` depends on our `getReleasePassword` task. The reason we cannot
    just use `packageRelease.dependsOn()` is that the Android plugin for Gradle generates
    the packaging tasks dynamically, based on the build variants. This means that
    the `packageRelease` task does not exist until the Android plugin has discovered
    all of the build variants. The discovery process is kicked off before every single
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the task and the build hook, this is the result of executing `gradlew
    assembleRelease`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a task to simplify the release process](img/B01061_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the `private.properties` file was
    not available, so the task asked for the password in the console. In this case,
    we also added a message explaining how to create the properties file and add the
    password property to make future builds easier. Once our task picked up the keystore
    password, Gradle was able to package our app and finish the build.
  prefs: []
  type: TYPE_NORMAL
- en: To get this task to work, it was essential to hook into Gradle and the Android
    plugin. This is a powerful concept, so we will explore this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into the Android plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing for Android, most tasks we want to influence are related to
    the Android plugin. It is possible to augment the behavior of tasks by hooking
    into the build process. In the previous example, we already saw how to add a dependency
    on a custom task to include a new task in the regular build process. In this section,
    we will look at some possibilities for Android-specific build hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to hook into the Android plugin is to manipulate the build variants.
    Doing this is quite straightforward; you just need the following code snippet
    to iterate over all the build variants of an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To get the collection of build variants, you can use the `applicationVariants`
    object. Once you have a reference to a build variant, you can access and manipulate
    its properties, such as name, description, and so on. If you want to use the same
    logic for an Android library, use `libraryVariants` instead of `applicationVariants`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we iterate over the build variants with `all()` instead of the `each()`
    method that we mentioned earlier. This is necessary because `each()` is triggered
    in the evaluation phase before the build variants have been created by the Android
    plugin. The `all()` method, on the other hand, is triggered every time a new item
    is added to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: This hook can be used to change the name of the APK before it is saved, to add
    the version number to the filename. This makes it easy to maintain an archive
    of APKs without manually editing file names. In the next section, we will see
    how to accomplish that.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically renaming APKs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common use case for manipulating the build process is to rename APKs to include
    the version number after they are packaged. You can do this by iterating over
    the build variants of the app, and changing the `outputFile` property of its outputs,
    as demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Every build variant has a collection of outputs. The output of an Android app
    is just an APK. The output objects each have a property of the type `File` named
    `outputFile`. Once you know the path of the output, you can manipulate it. In
    this example, we add the version name of the variant to the file name. This will
    result in an APK named `app-debug-1.0.apk` instead of `app-debug.apk`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the power of build hooks for the Android plugin with the simplicity
    of Gradle tasks opens up a world of possibilities. In the next section, we will
    see how to create a task for every build variant of an app.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically creating new tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of the way that Gradle works and tasks are constructed, we can easily
    create our own tasks in the configuration phase, based on the Android build variants.
    To demonstrate this powerful concept, we will create a task to not just install,
    but also run any build variant of an Android app. The `install` task is a part
    of the Android plugin, but if you install an app from the command-line interface
    using the `installDebug` task, you will still need to start it manually when the
    installation is complete. The task we will create in this section will eliminate
    that last step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by hooking into the `applicationVariants` property that we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For every variant, we check if it has a valid `install` task. This needs to
    be present because the new `run` task we are creating will depend on the `install`
    task. Once we have verified that the `install` task is present, we create a new
    task, and name it based on the variant's name. We also make our new task dependent
    on `variant.install`. This will trigger the `install` task before our task is
    executed. Inside the `tasks.create()` closure, start by adding a description,
    which is displayed when you execute `gradlew tasks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides adding the description, we also need to add the actual task action.
    In this example, we want to launch the app. You can launch an app on a connected
    device or emulator with the **Android Debug Tool** (**ADB**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle has a method called `exec()` that makes it possible to execute a command-line
    process. To make `exec()` work, we need to provide an executable that is present
    in the `PATH` environment variable. We also need to pass all the parameters with
    the `args` property, which takes a list of strings. Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the full package name, use the application ID of the build variant,
    which includes a suffix, if provided. There is one issue with suffixes in this
    case, though. Even if we add a suffix, the classpath to the activity is still
    the same. For example, consider this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The package name is `com.gradleforandroid.debug`, but the activity''s path
    is still `com.gradleforandroid.Activity`. To make sure we get the right class
    to the activity, strip the suffix from the application ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a variable named `classpath`, based on the application ID.
    Then we find the suffix, provided by the `buildType.applicationIdSuffix` property.
    In Groovy, it is possible to subtract a string from another string, using the
    minus operator. These changes make sure running the app after installation does
    not fail when suffixes are used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a collection of Gradle tasks that you want to reuse in several projects,
    it makes sense to extract these tasks into a custom plugin. This makes it possible
    to reuse build logic yourself, and to share it with others.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins can be written in Groovy, but also in other languages that make use
    of the JVM, such as Java and Scala. In fact, big parts of the Android plugin for
    Gradle are written in Java in combination with Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To extract build logic that is already stored in your build configuration file,
    you can create a plugin within the `build.gradle` file. This is the easiest way
    to get started with custom plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a plugin, create a new class that implements the `Plugin` interface.
    We will use the code we wrote previously in this chapter, which dynamically creates
    `run` tasks. Our plugin class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `Plugin` interface defines an `apply()` method. Gradle calls this method
    when the plugin is used in a build file. The project is passed as a parameter
    so that the plugin can configure the project or use its methods and properties.
    In the preceding example, we cannot call properties from the Android plugin directly.
    Instead, we need to access the project object first. Note that this requires the
    Android plugin to be applied to the project before our custom plugin is applied.
    Otherwise, `project.android` will cause an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the task is the same as it was earlier, except for one method
    call: instead of calling `exec()`, we now need to call `project.exec()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the plugin is applied to our build configuration, add this line
    to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Distributing plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to distribute a plugin and share it with others, you need to move it
    into a standalone module (or project). A standalone plugin has its own build file
    to configure dependencies and means of distribution. This module produces a JAR
    file, containing the plugin classes and properties. You can use this JAR file
    to apply the plugin in several modules and projects, and to share it with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any Gradle project, create a `build.gradle` file to configure the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since we are writing the plugin in Groovy, we need to apply the Groovy plugin.
    The Groovy plugin extends on the Java plugin, and enables us to build and package
    Groovy classes. Both Groovy and plain Java are supported, so you can mix them
    if you like. You can even go so far as to extend a Java class using Groovy, or
    the other way around. This makes it easy to get started, even if you do not feel
    confident using Groovy for everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our build configuration file contains two dependencies: `gradleApi()` and `localGroovy()`.
    The Gradle API is required to access Gradle namespaces from our custom plugin,
    and `localGroovy()` is a distribution of the Groovy SDK that comes with the Gradle
    installation. Gradle provides these dependencies by default for our convenience.
    If Gradle did not provide these dependencies out of the box, we would have to
    download and reference them manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you plan to distribute your plugin publically, make sure to specify the
    group and version information in the build configuration file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started with the code in our standalone module, we first need to make
    sure to use the correct directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As with any other Gradle module, we need to provide a `src/main` directory.
    Because this is a Groovy project, the subdirectory of `main` is called `groovy`
    instead of `java`. There is another subdirectory of `main` called `resources`,
    which we will use to specify our plugin's properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a file called `RunPlugin.groovy` in the package directory, where
    we define the class for our plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for Gradle to be able to find the plugin, we need to provide a properties
    file. Add this properties file to the `src/main/resources/META-INF/gradle-plugins/`
    directory. The name of the file needs to match the ID of our plugin. For the `RunPlugin`,
    the file is named `com.gradleforandroid.run.properties`, and this is its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that the properties file contains is the package and name of
    the class that implements the `Plugin` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the plugin and the properties file are ready, we can build the plugin
    using the `gradlew assemble` command. This creates a JAR file in the build output
    directory. If you want to push the plugin to a Maven repository instead, you first
    need to apply the Maven plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to configure the `uploadArchives` task, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `uploadArchives` task is a predefined task. Once you configure a repository
    on the task, you can execute it to publish your plugin. We will not cover how
    to set up a Maven repository in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make your plugin publically available, consider publishing it
    to Gradleware's plugin portal ([https://plugins.gradle.org](https://plugins.gradle.org)).
    The plugin portal has a great collection of Gradle plugins (not just specific
    to Android development) and is the place to go when you want to extend Gradle's
    default behavior. You can find information on how to publish a plugin in the documentation
    at [https://plugins.gradle.org/docs/submit](https://plugins.gradle.org/docs/submit).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing tests for custom plugins is not covered in this book, but is highly
    recommended if you plan to make your plugins publically available. You can find
    more information on writing tests for plugins in the Gradle user guide at [https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1](https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1).
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use a plugin, we need to add it as a dependency to the `buildscript` block.
    First, we need to configure a new repository. The configuration of the repository
    depends on the way that the plugin is distributed. Second, we need to configure
    the classpath of the plugin in the `dependencies` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to include the JAR file that we created in the earlier example,
    we can define a `flatDir` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If we had uploaded the plugin to a Maven or Ivy repository, this would look
    a little different. We covered dependency management already in [Chapter 3](ch03.html
    "Chapter 3. Managing Dependencies"), *Managing Dependencies*, so we will not repeat
    the different options here.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we set up the dependency, we need to apply the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When using the `apply()` method, Gradle creates an instance of the plugin class,
    and executes the plugin's own `apply()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how Groovy is different from Java, and how Groovy
    is used in Gradle. We saw how to create our own tasks and how to hook into the
    Android plugin, giving us a lot of power to manipulate the build process or dynamically
    add our own tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we looked at creating plugins and ensured that
    we can reuse them in several projects by creating a standalone plugin. There is
    much more to learn about plugins, but unfortunately, we cannot cover it all in
    this book. Luckily, the Gradle user guide has a thorough description of all the
    possibilities at [https://gradle.org/docs/current/userguide/custom_plugins.html](https://gradle.org/docs/current/userguide/custom_plugins.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the importance of continuous integration
    (CI). With a good CI system in place, we can build, test, and deploy apps and
    libraries with one click. Continuous integration is thus an important part of
    build automation in general.
  prefs: []
  type: TYPE_NORMAL
