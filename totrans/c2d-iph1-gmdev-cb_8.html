<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Tips, Tools, and Ports"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Tips, Tools, and Ports</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction</li><li class="listitem" style="list-style-type: disc">Accessing the Cocos2d-iPhone testbed</li><li class="listitem" style="list-style-type: disc">Packing textures using Zwoptex</li><li class="listitem" style="list-style-type: disc">Creating levels using Tiled</li><li class="listitem" style="list-style-type: disc">Creating levels using JSONWorldBuilder</li><li class="listitem" style="list-style-type: disc">Creating scenes with CocosBuilder</li><li class="listitem" style="list-style-type: disc">Using Cocos2d-X</li><li class="listitem" style="list-style-type: disc">Using Cocos3d</li><li class="listitem" style="list-style-type: disc">Releasing your app</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Introduction</h1></div></div></div><p>In this chapter we will conclude by covering a few tools commonly used to augment Cocos2d game development. We will also introduce Cocos2d spin-off projects and walk you through the process of releasing an app on Apple's App Store.</p></div></div>
<div class="section" title="Accessing the Cocos2d-iPhone testbed"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Accessing the Cocos2d-iPhone testbed</h1></div></div></div><p>The<span class="strong"><strong> Cocos2d-iPhone testbed</strong></span> is a suite of examples created to test bugs, display features, and instruct programmers with useful examples. In this recipe we will introduce this very useful tool.<a id="id536" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_01.jpg" alt="Accessing the Cocos2d-iPhone testbed"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec01"/>Getting ready</h2></div></div></div><p>First, we must download the Cocos2d source from<a class="ulink" href="http://www.cocos2d-iphone.org/download"> http://www.cocos2d-iphone.org/download</a>. After unzipping the main source package, double-click on the<code class="literal"> cocos2d.xcworkspace</code> file.<a id="id537" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec02"/>How to do it...</h2></div></div></div><p>From the<span class="strong"><strong> Scheme selection</strong></span> menu in XCode you can now select which piece of the testbed you would like to run. These tests include everything—drawing, physics, sound, networking, and more.<a id="id538" class="indexterm"/>
</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec03"/>How it works...</h2></div></div></div><p>Inside the<code class="literal"> tests</code> folder in the<code class="literal"> cocos2d-ios</code> target you will find the source files for each individual test. Here you can play around with the demos to get ideas for your own games.
</p><div class="section" title="Box2D testbed"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec01"/>
<span class="strong"><strong>Box2D testbed</strong></span>
</h3></div></div></div><p>Due to the scope of the Cocos2d-iPhone framework, many other testbeds are included within the Cocos2d-iPhone testbed. By building the<code class="literal"> Box2dTestBed</code> scheme we can run a version of the official Box2D testbed tailored for Cocos2d.<a id="id539" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Packing textures using Zwoptex"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Packing textures using Zwoptex</h1></div></div></div><p>Creating sprite sheets by hand can be a tedious process. To solve this problem, we use<span class="strong"><strong> Zwoptex Texture Packer</strong></span> to pack individual sprites into the smallest area possible. In this recipe, we walk through this process.<a id="id540" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_02.jpg" alt="Packing textures using Zwoptex"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Getting ready</h2></div></div></div><p>First we must download and install the Zwoptex application. Go to<a class="ulink" href="http://zwoptexapp.com/"> http://zwoptexapp.com/</a> and click on the<span class="strong"><strong> Download</strong></span> link. Drag the application to your<code class="literal"> Applications</code> folder.<a id="id541" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec05"/>How to do it...</h2></div></div></div><p>Once you've started Zwoptex, click<span class="strong"><strong> File | New</strong></span>. You should see a blank canvas. Here are some attributes of the canvas:<a id="id542" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Canvas size:<p>As you can see inside Zwoptex, the width and height of the Canvas can only go up to 2048 pixels. Also, they can only be a power of 2. On the iPhone 3G and older devices, uncompressed textures can have a maximum size of 1024x1024. On newer devices that support OpenGL ES 2.0, starting with the iPhone 3GS, uncompressed textures can be up to 2048x2048 pixels. Textures are only loaded into memory in powers of 2. Taking all of this into account, Zwoptex limits the canvas sizes you can use.
</p></li><li class="listitem" style="list-style-type: disc">Importing sprites:<p>Sprites are imported onto the canvas by simply dragging individual files from your Finder onto the canvas. These will be positioned on top of each other. They will also be outlined with a red box.
<a id="id543" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Applying a layout:<p>After adjusting any settings under the Layout heading we can click the Apply button. This will re-arrange the sprites to fit the canvas size. If all the sprites do not fit, some will still have that red box surrounding them. This indicates an overlap.
<a id="id544" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Publishing:<p>Once our sprites are properly arranged in a sheet and our Zwoptex file is saved, we can publish our sheet. This creates a PLIST file and a PNG file. By adding these to our XCode Cocos2d project, we can now use them in our app.
</p></li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec06"/>How it works...</h2></div></div></div><p>Zwoptex uses offsets and other positioning tricks designed to squeeze as many sprites into a sheet as possible.</p></div><div class="section" title="See also..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec07"/>See also...</h2></div></div></div><p>A popular alternative to Zwoptex is<span class="strong"><strong> TexturePacker</strong></span>. It can be downloaded from<a class="ulink" href="http://www.texturepacker.com/"> http://www.texturepacker.com/</a>.<a id="id545" class="indexterm"/>
</p></div></div>
<div class="section" title="Creating levels using Tiled"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Creating levels using Tiled</h1></div></div></div><p>One of the most important weapons in the game developer's arsenal is the<span class="strong"><strong> level editor</strong></span>. In this recipe we will create a level using the<span class="emphasis"><em> Tiled</em></span> level editor. We will then create a simple top-down world using this level.<a id="id546" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_03.jpg" alt="Creating levels using Tiled"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec08"/>Getting ready</h2></div></div></div><p>Please refer to the project<code class="literal"> RecipeCollection03</code> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec09"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id547" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//Interface
@interface Ch8_Tiled : GameArea2D {
CCTMXTiledMap *tileMap;
}
@end
//Implementation
@implementation Ch8_Tiled
-(CCLayer*) runRecipe {
//Load TMX tilemap file
tileMap = [CCTMXTiledMap tiledMapWithTMXFile:@"tilemap.tmx"];
//Set game area size based on tilemap size
[self setGameAreaSize];
//Superclass initialization and message
[super runRecipe];
[self showMessage:@"Use the DPad to move the actor around."];
//Add tile map
[gameNode addChild:tileMap z:0];
/* Re-order layers according to their Y value. This creates isometric depth. */
//Our layers
CCTMXLayer *collidableLayer = [tileMap layerNamed:@"Collidable"];
CCTMXLayer *ground = [tileMap layerNamed:@"Ground"];
CCTMXLayer *wall = [tileMap layerNamed:@"Wall"];
//Gather all the layers into a container
float mw = tileMap.mapSize.width; float mh = tileMap.mapSize.height;
float tw = tileMap.tileSize.width; float th = tileMap.tileSize.height;
NSMutableDictionary *layersToReorder = [[[NSMutableDictionary alloc] init] autorelease];
for( CCTMXLayer* child in [tileMap children] ) {
//Skip tiles marked "Collidable", "Ground" and "Wall"
if(child == ground){ continue; }
else if(child == wall){ continue; }
else if(child == collidableLayer){ continue; }
//Gather all the layers
for(float x=0; x&lt;mw; x+=1){
for(float y=mh-1; y&gt;=0; y-=1){
CCSprite *childTile = [child tileAt:ccp(x,y)];
CCSprite *collideTile = [collidableLayer tileAt:ccp(x,y)];
if(childTile &amp;&amp; collideTile){
[layersToReorder setObject:[NSNumber numberWithFloat:y] forKey:[child layerName]];
x=mw; y=-1;
}
}
}
}
//Re-order gathered layers
for(id key in layersToReorder){
NSString *str = (NSString*)key;
[tileMap reorderChild:[tileMap layerNamed:str] z:[[layersToReorder objectForKey:key] floatValue]];
}
//Set the ground to z=0
[tileMap reorderChild:ground z:0];
//Add Box2D boxes to represent all layers marked "Collidable"
for(float x=0; x&lt;mw; x+=1){
for(float y=0; y&lt;mh; y+=1){
if([collidableLayer tileAt:ccp(x,y)]){
[self addBoxAtPoint:ccp(x*tw, mh*th - y*th) size:ccp(tw/2,th/2)];
}
}
}
//Remove the "Collidable" layer art as it's only an indicator for the level editor
[tileMap removeChild:collidableLayer cleanup:YES];
return self;
}
-(void) step: (ccTime) dt {
[super step:dt];
/* CODE OMITTED */
//Re-order the actor
float mh = tileMap.mapSize.height;
float th = tileMap.tileSize.height;
CGPoint p = [actor.sprite position];
float z = -(p.y/th) + mh;
[tileMap reorderChild:actor.sprite z:z ];
}
-(void) setGameAreaSize {
//Set gameAreaSize based on tileMap size
gameAreaSize = ccp((tileMap.mapSize.width * tileMap.tileSize.width)/PTM_RATIO,(tileMap.mapSize.height * tileMap.tileSize.height)/PTM_RATIO); //Box2d units
}
-(void) addActor {
//Get spawn point from tile object named "SpawnPoint"
if(!spawnPoint){
CCTMXObjectGroup *objects = [tileMap objectGroupNamed:@"Objects"];
NSAssert(objects != nil, @"'Objects' object group not found");
NSMutableDictionary *sp = [objects objectNamed:@"SpawnPoint"];
NSAssert(sp != nil, @"SpawnPoint object not found");
int x = [[sp valueForKey:@"x"] intValue];
int y = [[sp valueForKey:@"y"] intValue];
spawnPoint = [Vector3D x:x y:y z:0];
}
//Add actor
/* CODE OMITTED */
[tileMap addChild:actor.sprite z:[[tileMap layerNamed:@"0"] vertexZ]];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec10"/>How it works...</h2></div></div></div><p>This recipe loads a TMX<code class="literal"> tilemap</code> created using the<span class="strong"><strong> Tiled</strong></span> application. It then creates a 2.5D game world using information from the<code class="literal"> tilemap</code>. This is done as follows:<a id="id548" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Installing Tiled:<p>First we must download and install the <code class="literal">Tiled</code> application. Go to <a class="ulink" href="http://www.mapeditor.org/">http://www.mapeditor.org/</a> and click on the <span class="strong"><strong>Tiled Qt 0.7.0 for Mac OS X</strong></span> link. Drag the application to your <code class="literal">Applications</code> folder.
</p></li><li class="listitem"> Creating a new level:<p>Open up Tiled and click <span class="strong"><strong>File | New</strong></span> to create a new level.
</p></li><li class="listitem"> Choosing a perspective:<p>As you might be able to see from the screenshots of <code class="literal">Tiled</code> on the website, there are two types of perspectives that can be chosen. When you first click <span class="strong"><strong>File | New</strong></span> in the <span class="strong"><strong>Tiled</strong></span> menu, you will have to make the choice between <span class="strong"><strong>Orthagonal</strong></span> and <span class="strong"><strong>Isometric perspectives</strong></span>. Each perspective creates a different visual style and world object layout. In our example, we chose <span class="strong"><strong>Orthagonal</strong></span> as it's a little more straightforward.
</p></li><li class="listitem"> Map size:<p>The map size is measured in tiles. For our map we chose the size of 50x50.
<a id="id549" class="indexterm"/>
</p></li><li class="listitem"> Tile size:<p>In <code class="literal">Tiled</code>, the tile size can be variable. In this example we have chosen the default size of 32x32 pixels. This means we can keep our art assets nice and small.
</p></li><li class="listitem"> Creating a<code class="literal"> tileset:</code><p>The primary resource used in <code class="literal">Tiled</code> is the <code class="literal">tileset</code>. This is a sprite sheet created according to the tile size chosen in Tiled. To create this sprite sheet, open up Zwoptex, create a new file, and set <code class="literal">Padding</code> to 0px. Then, drag 32x32 pixel images onto the sprite sheet. This PNG file is the tileset file. Instead of using a corresponding PLIST file to manage sprite information, <code class="literal">Tiled</code> simply uses position information to match a sprite to a tile. For this recipe our <code class="literal">tileset</code> looks like the following:
<a id="id550" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_04.jpg" alt="How it works..."/></div><p>So, make sure your tileset is correct before loading it into your level. Finally, click <span class="strong"><strong>Map | New Tileset</strong></span>. Name your tileset and specify your PNG sprite sheet.
</p></li><li class="listitem"> Tile layers:<p>Tiled supports the creation of multiple overlapping layers. Typically, these layers are used to place graphical elements over one another. In addition to this, layers can specify information. In our level, red colored areas can be considered "collidable". This will be processed programmatically.
</p><p><span class="strong"><strong>Object layers:</strong></span>
</p><p>In addition to tiles, <span class="strong"><strong>Objects </strong></span>can be placed to indicate non-tile based data like item locations. In our level, we've placed a "spawn point" object to indicate where the player should spawn. For an example usage of this please refer to the <code class="literal">tilemap.tmx</code> file located in the <code class="literal">Resources/Tilemaps</code> folder of <code class="literal">RecipeCollection03, CCTMXTiledMap</code>.
<a id="id551" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Once our map is complete we will run the following code snippet to load<code class="literal"> tilemap</code> assets into the game:<div class="informalexample"><pre class="programlisting">CCTMXTiledMap *tileMap = [CCTMXTiledMap tiledMapWithTMXFile:@"tilemap.tmx"];
[gameNode addChild:tileMap z:0];
</pre></div><p>A <code class="literal">CCTMXTiledMap</code> object contains references to each tile as a <code class="literal">CCSprite</code> object as well as a number of structures to organize these files.
<a id="id552" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">CCTMXTileLayer<p>To access a tile layer we use the following code:
</p><div class="informalexample"><pre class="programlisting">CCTMXLayer *collidableLayer = [tileMap layerNamed:@"Collidable"];
</pre></div><p>To loop through all <code class="literal">CCTMXLayer </code>objects, we can also use the following lines:
</p><div class="informalexample"><pre class="programlisting">for( CCTMXLayer* child in [tileMap children] ) {
//Do Something
}
</pre></div></li><li class="listitem" style="list-style-type: disc">Accessing a tile's sprite involves calling the<code class="literal"> tileAt</code> method:<a id="id553" class="indexterm"/><div class="informalexample"><pre class="programlisting">float x = 0; float y = 0;
CCSprite *tileSprite = [collidableLayer tileAt:ccp(x,y)];
</pre></div></li></ul></div><p>These sprites are created lazily when <code class="literal">tileAt</code> is called. For more information, please refer to the Cocos2d-iPhone API reference page for <code class="literal">CCTMXTiledMap</code>.
</p></li><li class="listitem"> Re-ordering tiles:<p>For the purposes of our example, we loop through all tile sprites and re-order them to create the proper perspective illusion. This simply involves calling the <code class="literal">reorderChild</code> method on <code class="literal">tileMap</code> based on each tile's Y position.
<a id="id554" class="indexterm"/>
</p></li><li class="listitem"> Adding Box2D geometry:<p>To create physical level geometry we process the "Collidable" layer and create a properly sized box object for each tile we find:
<a id="id555" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">for(float x=0; x&lt;mw; x+=1){
for(float y=0; y&lt;mh; y+=1){
if([collidableLayer tileAt:ccp(x,y)]){
[self addBoxAtPoint:ccp(x*tw, mh*th - y*th) size:ccp(tw/2,th/2)];
}
}
}
</pre></div><p>Using this special <code class="literal">collidableLayer</code> allows the level art to line up exactly where we want things to be collidable. This creates the illusion that the base of each tree is collidable while the branches are not.
</p></li><li class="listitem"> Processing level objects:<p>Level objects are processed using the <code class="literal">CCTMXObjectGroup</code> class:
<a id="id556" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CCTMXObjectGroup *objects = [tileMap objectGroupNamed:@"Objects"];
</pre></div></li><li class="listitem"> Next, we process our<code class="literal"> SpawnPoint</code> object:<a id="id557" class="indexterm"/><div class="informalexample"><pre class="programlisting">NSMutableDictionary *sp = [objects objectNamed:@"SpawnPoint"];
int x = [[sp valueForKey:@"x"] intValue];
int y = [[sp valueForKey:@"y"] intValue];
spawnPoint = [Vector3D x:x y:y z:0];
</pre></div><p>We can now spawn the player at this point on the map.
</p></li></ol></div></div><div class="section" title="See also..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec11"/>See also...</h2></div></div></div><p>For more information about using<code class="literal"> Tiled</code> please refer to the<code class="literal"> Tiled</code> wiki located at<a class="ulink" href="http://github.com/bjorn/tiled/wiki"> http://github.com/bjorn/tiled/wiki</a>.
</p></div></div>
<div class="section" title="Creating levels using JSONWorldBuilder"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Creating levels using JSONWorldBuilder</h1></div></div></div><p>Creating a game level using tiles is a technique that works well for many games. In this recipe, however, we will create a level in a more non-linear fashion using the<span class="strong"><strong> JSONWorldBuilder</strong></span> level editor.<a id="id558" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_05.jpg" alt="Creating levels using JSONWorldBuilder"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec12"/>Getting ready</h2></div></div></div><p>Please refer to the project<code class="literal"> RecipeCollection03</code> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec13"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "ActualPath.h"
#import "CJSONDeserializer.h"
//Interface
@interface Ch8_JSONWorldBuilder : GameArea2D
{
NSDictionary *mapData;
CGPoint canvasSize;
NSMutableArray *lineVerticesA;
NSMutableArray *lineVerticesB;
NSMutableArray *points;
}
@end
//Implementation
@implementation Ch8_JSONWorldBuilder
-(CCLayer*) runRecipe {
//Load our map file
[self loadMap:@"world.json"];
return self;
}
/* Called after the map has been loaded into a container but before assets have been loaded */
-(void) finishInit {
//Superclass initialization and message
[super runRecipe];
/* CODE OMITTED */
//Init line/point containers
lineVerticesA = [[NSMutableArray alloc] init];
lineVerticesB = [[NSMutableArray alloc] init];
points = [[NSMutableArray alloc] init];
}
/* Our load map method */
-(void) loadMap:(NSString*)mapStr {
/* CODE OMITTED */
//Add all sprite frames for listed plist files
NSArray *plistFiles = [mapData objectForKey:@"plistFiles"];
for (id plistFile in plistFiles) {
[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:plistFile];
}
//List of PNG files is also available
NSArray *pngFiles = [mapData objectForKey:@"pngFiles"];
//Pre process data
[self preProcessMapData];
//Process map nodes
NSDictionary *mapNodes = [mapData objectForKey:@"mapNodes"];
for (id mapNodeKey in mapNodes) {
NSDictionary *mapNode = [mapNodes objectForKey:mapNodeKey];
NSString *nodeType = [mapNode objectForKey:@"type"];
//Process node types
if([nodeType isEqualToString:@"sprite"]){
[self processSprite:mapNode];
}else if([nodeType isEqualToString:@"tiledSprite"]){
[self processTiledSprite:mapNode];
}else if([nodeType isEqualToString:@"line"]){
[self processLine:mapNode];
}else if([nodeType isEqualToString:@"point"]){
[self processPoint:mapNode];
}
}
}
-(void) preProcessMapData {
//Set canvasSize and gameAreaSize from map file
canvasSize = ccp( [[mapData objectForKey:@"canvasWidth"] floatValue], [[mapData objectForKey:@"canvasHeight"] floatValue] );
gameAreaSize = ccp( canvasSize.x/PTM_RATIO, canvasSize.y/PTM_RATIO );
//Finish map initialization
[self finishInit];
}
/* Process a sprite node. This represents a single sprite onscreen */
-(void) processSprite:(NSDictionary*)mapNode {
//Get node information
NSString *texture = [mapNode objectForKey:@"selectedSpriteY"];
float originX = [[mapNode objectForKey:@"originX"] floatValue];
/* CODE OMITTED */
//Get metadata
NSDictionary *metaPairs = [mapNode objectForKey:@"meta"];
for (id metaKey in metaPairs) {
NSString* metaValue = [metaPairs objectForKey:metaKey];
//Check for key "tag"
if([metaKey isEqualToString:@"tag"]){
tag = ((int)[metaValue dataUsingEncoding:NSUTF8StringEncoding]);
}
}
/* CODE OMITTED */
//Finally, add the sprite
[gameNode addChild:sprite z:zIndex-24995 tag:tag];
}
/* Process a tiled sprite. */
-(void) processTiledSprite:(NSDictionary*)mapNode {
//Get node information
NSString *texture = [mapNode objectForKey:@"selectedSpriteY"];
NSMutableDictionary *frames = [[[NSMutableDictionary alloc] init] autorelease];
float originX = [[mapNode objectForKey:@"originX"] floatValue];
/* CODE OMITTED */
//Get metadata
NSDictionary *metaPairs = [mapNode objectForKey:@"meta"];
for (id metaKey in metaPairs) {
NSString* metaValue = [metaPairs objectForKey:metaKey];
//Check for key "tag" or key "frame" (for animation)
if([metaKey isEqualToString:@"tag"]){
tag = ((int)[metaValue dataUsingEncoding:NSUTF8StringEncoding]);
}else if ([metaKey rangeOfString:@"frame"].location != NSNotFound){
[frames setObject:metaValue forKey:metaKey];
}
}
//Get any masks to be applied to this tiled sprite
NSArray *masks = [mapNode objectForKey:@"masks"];
//OpenGL texture parameters
ccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};
//If a mask exists, apply it
if([masks count] &gt; 0){
/* CODE OMITTED */
//Create TexturedPolygon object
TexturedPolygon *tp = [TexturedPolygon createWithFile:texture withVertices:vertices withTriangles:triangles];
[tp.texture setTexParameters:&amp;params];
//Set position
float x = originX - (canvasSize.x/2);
float y = canvasSize.y - originY - (canvasSize.y/2);
tp.position = ccp( x, y-height );
/* CODE OMITTED */
//Finally, add the node
[gameNode addChild:tp z:zIndex-24995];
}else if([frames count] &gt; 0){
/* If we have a non-masked tiled animated sprite */
/* CODE OMITTED */
}else{
//Use a regular Sprite
CCSprite *sprite = [CCSprite spriteWithFile:texture rect:CGRectMake(0,0,width,height)];
[sprite.texture setTexParameters:&amp;params];
//Set position
float x = originX - (canvasSize.x/2);
float y = canvasSize.y - originY - (canvasSize.y/2);
sprite.position = ccp( x+width/2, y-height/2 );
//Add the node
[gameNode addChild:sprite z:zIndex-24999];
}
}
/* Process a line */
-(void) processLine:(NSDictionary*)mapNode{
//Get line information
NSArray *drawnLines = [mapNode objectForKey:@"drawnLines"];
/* CODE OMITTED */
//Add information to our line containers
[lineVerticesA addObject:[NSValue valueWithCGPoint:ccp(fromX, canvasSize.y-fromY)]];
[lineVerticesB addObject:[NSValue valueWithCGPoint:ccp(toX, canvasSize.y-toY)]];
}
/* Process a point */
-(void) processPoint:(NSDictionary*)mapNode{
//Get point information
float originX = [[mapNode objectForKey:@"originX"] floatValue];
float originY = [[mapNode objectForKey:@"originY"] floatValue];
originY = canvasSize.y - originY;
//If metadata is appropriate, add point to container
/* CODE OMITTED */
}
-(void) cleanRecipe {
[lineVerticesA release];
[lineVerticesB release];
[points release];
[super cleanRecipe];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>How it works...</h2></div></div></div><p>This recipe loads a JSON level file created by JSONWorldBuilder:<a id="id559" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Installing JSONWorldBuilder:<a id="id560" class="indexterm"/><p>First, we must download and install the JSONWorldBuilder application. The source for JSONWorldBuilder can be found at <code class="literal">http://github.com/n8dogg/JSONWorldBuilder</code>. To download the latest <code class="literal">build</code> click on <span class="strong"><strong>Downloads</strong></span>, download the source archive, unzip it, and finally look in the builds folder. Here you will find an archive containing the latest JSONWorldBuilder application. Drag the application to your <code class="literal">Applications</code> folder.
</p></li><li class="listitem"> Creating a new level:<p>Opening JSONWorldBuilder automatically creates a new level. To clear the level you are currently working on, choose <span class="strong"><strong>File | New Map</strong></span>.
</p></li><li class="listitem"> Specifying a resources folder:<p>JSONWorldBuilder is designed to work with PNG image files as well as PNG/PLIST combinations. When you specify a resource folder we are telling the editor where these resources live. Click <span class="strong"><strong>Resources | Specify Resource</strong></span> folder. This will bring up a prompt. Once you specify a folder the Sprites window will fill with sprites. Click on a sprite sheet name to hide/show individual sprites:
<a id="id561" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_06.jpg" alt="How it works..."/></div><p>Clicking on an individual sprite will select it for use in the editor.
<a id="id562" class="indexterm"/>
</p></li><li class="listitem"> Sprite Stamp:<p>Once a sprite is selected in the <span class="strong"><strong>Sprites</strong></span> window, click the <span class="strong"><strong>Sprite Stamp</strong></span> tool on the left menu. Now, by clicking the canvas you can stamp that sprite repeatedly onto the canvas.
<a id="id563" class="indexterm"/>
</p></li><li class="listitem"> Sprite Selector:<p>To move the sprites that you've just stamped around, click on the <span class="strong"><strong>Sprite Selector</strong></span> tool. Now, click and drag a sprite on the canvas to move it.
<a id="id564" class="indexterm"/>
</p></li><li class="listitem"> Draw Tiled Sprite:<p>To draw a tiled sprite, click the <span class="strong"><strong>Draw Tiled Sprite</strong></span> tool. Now click and drag your mouse to create a rectangular tiled area with the selected texture. In the editor you can use both sprite sheets or single image files as tiled textures. However, keep in mind that the <code class="literal">TexturedPolygon </code>class we've been using requires a single image file to work properly.
<a id="id565" class="indexterm"/>
</p></li><li class="listitem"> Draw Mask:<p>Now, that we have a tiled sprite on the canvas, we can mask it. This means we will cut it into a shape. Select the tiled sprite you've placed on the canvas using the <span class="strong"><strong>Sprite</strong></span> tool. Now select the <span class="strong"><strong>Draw Mask</strong></span> tool. Click once on or around the tiled sprite to start the mask creation process. This involves creating a polygon with successive mouse clicks, finally ending where you initially clicked to complete the polygon.
<a id="id566" class="indexterm"/>
</p></li><li class="listitem"> Lines, Points, and Polygons:<p>Spatial information can be added to your map using lines, points, and polygons. These are created using the <span class="strong"><strong>Create Line, Create Point</strong></span>, and <span class="strong"><strong>Create Polygon</strong></span> tools respectively. Also, note that you need to click and drag to create a line.
<a id="id567" class="indexterm"/>
</p></li><li class="listitem"> Shape Selector:<p>The <span class="strong"><strong>Shape Selector</strong></span> tool will allow you to select and reposition shapes on the canvas.
<a id="id568" class="indexterm"/>
</p></li><li class="listitem"> Move Camera, Zooming, and Canvas Resize:<p>The <span class="strong"><strong>Move Camera</strong></span> tool allows us to pan the position of the camera. In the <span class="strong"><strong>Nav</strong></span> window on the right you can click the + or - buttons to zoom the camera. You can also resize the canvas.
<a id="id569" class="indexterm"/>
</p></li><li class="listitem"> Map Object window:<p>Inside the <span class="strong"><strong>Map Object</strong></span> window you can specify information like object position and tiled object size. Here, you can also add meta tags in the form of a key/value dictionary, flip images on the X and/or X axis, and re-arrange objects on the Z axis.
<a id="id570" class="indexterm"/>
</p></li><li class="listitem"> Loading our map:<p>Once we have our map created we can go ahead and load it in Cocos2d. We use <code class="literal">CJSONDeserializer</code> to go through our map file and process data. After processing some initial information the loadMap method calls four different methods depending on map node types:
<a id="id571" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">-(void) processSprite:(NSDictionary*)mapNode;
-(void) processTiledSprite:(NSDictionary*)mapNode;
-(void) processLine:(NSDictionary*)mapNode;
-(void) processPoint:(NSDictionary*)mapNode;
</pre></div><p>Each method processes the appropriate node, and attaches sprite information to the <code class="literal">gameNode</code> object or drawing information to the <code class="literal">drawLayer</code>. Metadata is also handled in these methods, though it could be handled in the <code class="literal">loadMap</code> method as well.
</p></li></ol></div></div></div>
<div class="section" title="Creating scenes with CocosBuilder"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Creating scenes with CocosBuilder</h1></div></div></div><p>Levels are not the only things that can be built using a<span class="strong"><strong> WYSIWYG</strong></span> editor. In this recipe we will craft a simple menu scene using<span class="strong"><strong> CocosBuilder</strong></span>.<a id="id572" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_07.jpg" alt="Creating scenes with CocosBuilder"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>Getting ready</h2></div></div></div><p>Please refer to the project<code class="literal"> RecipeCollection03</code> for full working code of this recipe.<a id="id573" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec16"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "CCBReader.h"
//Implementation
@implementation Ch8_CocosBuilder
-(CCLayer*) runRecipe {
//Add button to push CocosBuilder scene
[CCMenuItemFont setFontSize:32];
CCMenuItemFont *pushItem = [CCMenuItemFont itemFromString:@"Push CocosBuilder Scene" target:self selector:@selector(pushScene)];
CCMenu *pushMenu = [CCMenu menuWithItems:pushItem, nil];
pushMenu.position = ccp(240,160);
[self addChild:pushMenu];
return self;
}
/* Push scene callback */
-(void) pushScene {
CCScene* scene = [CCBReader sceneWithNodeGraphFromFile:@"scene.ccb" owner:self];
[[CCDirector sharedDirector] pushScene:scene];
}
/* Callback called from CocosBuilder scene */
-(void) back {
[[CCDirector sharedDirector] popScene];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec17"/>How it works...</h2></div></div></div><p>This recipe loads a CocosBuilder CCB scene along with its associated assets:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Installing CocosBuilder:<a id="id574" class="indexterm"/><p>First, we must download and install the <span class="strong"><strong>CocosBuilder</strong></span> application. Go to <code class="literal">http://cocosbuilder.com/?page_id=11</code> and click on the <span class="strong"><strong>Download CocosBuilder Application</strong></span> link. Drag the application to your <code class="literal">Applications</code> folder.
</p></li><li class="listitem"> Starting out:<p>CocosBuilder allows us to create a hierarchical layout of objects derived from CCNode. Available node types include <code class="literal">CCLayer, CCSprite, CCMenu</code>, and <code class="literal">CCParticleSystem</code>. The file assets for these nodes are expected to be in the same folder as the CCB file itself. So, before creating a new CCB file, we must create a folder and fill it with assets we'd like to use. When this is finished click <span class="strong"><strong>File | New</strong></span>. Choose <span class="strong"><strong>CCNode</strong></span> for the <span class="strong"><strong>root object type</strong></span>. Save this file into the folder you created. If you would like to add more assets later, simple copy them into the folder and click <span class="strong"><strong>Object | Reload Assets</strong></span> .
<a id="id575" class="indexterm"/>
</p></li><li class="listitem"> Adding objects:<p>To add an object as a child of the root <code class="literal">CCNode</code> object, click on the root node and then click <span class="strong"><strong>Object | Add Object as Child</strong></span>. Then click the object type you would like to add.
</p></li><li class="listitem"> Adding a CCSprite object:<p>In our example, we've added three <code class="literal">CCSprite</code> objects. Sprite objects are always added without a corresponding texture file. After adding a black sprite, choose your sprite file/sheet and corresponding sprite name on the right under the <span class="strong"><strong>CCSprite</strong></span> heading.
</p></li><li class="listitem"> Adding a<code class="literal"> CCMenuItemImage</code> with callback:<p>We also add a <code class="literal">CCMenu</code> object and a child <code class="literal">CCMenuItemImage</code>. On the <code class="literal">CCMenuItemImage</code> object we specify a callback. The method back will be called on the "Owner" object.
</p></li><li class="listitem"> Loading our scene:<p>Inside of Cocos2d we use the following lines to load the scene file, set the scene's "owner", and to finally push the scene:
</p><div class="informalexample"><pre class="programlisting">CCScene* scene = [CCBReader sceneWithNodeGraphFromFile:@"scene.ccb" owner:self];
[[CCDirector sharedDirector] pushScene:scene];
</pre></div><p>Clicking on the <span class="strong"><strong>Back</strong></span> button in the scene calls the back method in our recipe file and the scene is then popped. Using these tools you can quickly mock up game menus and other stand-alone scenes.
<a id="id576" class="indexterm"/>
</p></li></ol></div></div></div>
<div class="section" title="Using Cocos2d-X"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Using Cocos2d-X</h1></div></div></div><p>Cocos2d is not limited to iOS development.<span class="strong"><strong> Cocos2d-X</strong></span> is a<span class="strong"><strong> C++</strong></span> port of Cocos2d-iPhone. Using Cocos2d-X we can develop games for many platforms including Mac, PC, Linux, Android, and more. In this recipe, we will install Cocos2d-X XCode templates, create a simple Cocos2d-X application, and introduce the Cocos2d-X testbed.<a id="id577" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_08.jpg" alt="Using Cocos2d-X"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec18"/>Getting ready</h2></div></div></div><p>Please refer to the project<code class="literal"> Ch8_Cocos2d-X</code> for full working code of this recipe.<a id="id578" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec19"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#include "HelloWorldScene.h"
#include "SimpleAudioEngine.h"
using namespace cocos2d;
using namespace CocosDenshion;
CCScene* HelloWorld::scene()
{
//'scene' is an autorelease object
CCScene *scene = CCScene::node();
//'layer' is an autorelease object
HelloWorld *layer = HelloWorld::node();
//Add layer as a child to scene
scene-&gt;addChild(layer);
return scene;
}
// on "init" you need to initialize your instance
bool HelloWorld::init()
{
//Super initialization
if ( !CCLayer::init() )
{
return false;
}
//Add a menu item with "X" image, which is clicked to quit the program. You may modify it.
//Add a "close" icon to exit the progress. it's an autorelease object
CCMenuItemImage *pCloseItem = CCMenuItemImage::itemFromNormalImage("CloseNormal.png", "CloseSelected.png", this, menu_selector(HelloWorld::menuCloseCallback) );
pCloseItem-&gt;setPosition( ccp(CCDirector::sharedDirector()-&gt;getWinSize().width - 20, 20) );
//Create menu, it's an autorelease object
CCMenu* pMenu = CCMenu::menuWithItems(pCloseItem, NULL);
pMenu-&gt;setPosition( CCPointZero );
this-&gt;addChild(pMenu, 1);
//Add a label shows "Hello World"
// create and initialize a label
CCLabelTTF* pLabel = CCLabelTTF::labelWithString("Hello World", "Thonburi", 34);
//Ask director the window size
CCSize size = CCDirector::sharedDirector()-&gt;getWinSize();
//Position the label on the center of the screen
pLabel-&gt;setPosition( ccp(size.width / 2, size.height - 20) );
//Add the label as a child to this layer
this-&gt;addChild(pLabel, 1);
//Add "HelloWorld" splash screen"
CCSprite* pSprite = CCSprite::spriteWithFile("HelloWorld.png");
//Position the sprite on the center of the screen
pSprite-&gt;setPosition( ccp(size.width/2, size.height/2) );
//Add the sprite as a child to this layer
this-&gt;addChild(pSprite, 0);
return true;
}
void HelloWorld::menuCloseCallback(CCObject* pSender)
{
CCDirector::sharedDirector()-&gt;end();
#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
exit(0);
#endif
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec20"/>How it works...</h2></div></div></div><p>This recipe shows us a basic example of Cocos2d-X in action, which is done as follows:<a id="id579" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Installing Cocos2d-X XCode templates:<a id="id580" class="indexterm"/><p>First, we must download the latest version of Cocos2d-X and install the XCode template. Go to <a class="ulink" href="http://www.cocos2d-x.org/projects/cocos2d-x/wiki/Download">http://www.cocos2d-x.org/projects/cocos2d-x/wiki/Download</a> and download the latest source package. After unzipping the package you'll find tools to create projects for multiple development environments. To install the XCode templates, open the <span class="strong"><strong>Terminal</strong></span>, navigate to the Cocos2d-X folder, and run the following command:
</p><div class="informalexample"><pre class="programlisting">sudo sh install-templates-xcode.sh
</pre></div><p>This will install the templates.
</p></li><li class="listitem"> Creating a Cocos2d-X project:<p>To create a project with the newly installed XCode template click <span class="strong"><strong>File | New | New</strong></span> Project. Under iOS you should see <code class="literal">cocos2d-x</code>. Under this there are a few templates for Box2D, Chipmunk, and Lua integration. Choose one of these.
</p></li><li class="listitem"> Using Cocos2d-X:<p>As you can see in the preceding code, <code class="literal">Cocos2d-X</code> is a full port of Cocos2d-iPhone to C++. For more information about <code class="literal">Cocos2d-X</code>, please consult the <span class="strong"><strong>Cocos2d-X | Doxygen</strong></span> documentation located at <code class="literal">http://www.cocos2d-x.org/embedded/cocos2d-x/classes.html.</code>
</p></li><li class="listitem"> The Cocos2d-X testbed:<p>Inside the tests folder you will find a number of test projects for different operating systems. In the <code class="literal">test.ios</code> folder open the project <code class="literal">test.xcodeproj</code>. This is a thorough port of the Cocos2d testbed with the addition of a simple menu system to make navigation between the examples much easier.
<a id="id581" class="indexterm"/>
</p></li></ol></div></div></div>
<div class="section" title="Using Cocos3d"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Using Cocos3d</h1></div></div></div><p>Cocos2d is such a versatile framework that it has even been ported and extended into a<span class="strong"><strong> 3D game engine</strong></span> appropriately titled<span class="strong"><strong> Cocos3d</strong></span>. In this recipe we will install Cocos3d XCode templates, create a sample Cocos3d application, and introduce the Cocos3d<code class="literal"> demo mash-up</code> project.<a id="id582" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_09.jpg" alt="Using Cocos3d"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec21"/>Getting ready</h2></div></div></div><p>Please refer to the project<code class="literal"> Ch8_Cocos3d</code> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec22"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id583" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">#import "Ch8_Cocos3dWorld.h"
#import "CC3PODResourceNode.h"
#import "CC3ActionInterval.h"
#import "CC3MeshNode.h"
#import "CC3Camera.h"
#import "CC3Light.h"
@implementation Ch8_Cocos3dWorld
-(void) dealloc {
[super dealloc];
}
-(void) initializeWorld {
//Create the camera, place it back a bit, and add it to the world
CC3Camera* cam = [CC3Camera nodeWithName: @"Camera"];
cam.location = cc3v( 0.0, 0.0, 6.0 );
[self addChild: cam];
//Create a light, place it back and to the left at a specific position (not just directional lighting), and add it to the world
CC3Light* lamp = [CC3Light nodeWithName: @"Lamp"];
lamp.location = cc3v( -2.0, 0.0, 0.0 );
lamp.isDirectionalOnly = NO;
[cam addChild: lamp];
//This is the simplest way to load a POD resource file and add the nodes to the CC3World, if no customized resource subclass is needed.
[self addContentFromPODResourceFile: @"hello-world.pod"];
//Create OpenGL ES buffers for the vertex arrays to keep things fast and efficient, and to save memory, release the vertex data in main memory because it is now redundant.
[self createGLBuffers];
[self releaseRedundantData];
//That's it! The model world is now constructed and is good to go.
//But to add some dynamism, we'll animate the 'hello, world' message using a couple of cocos2d actions...
//Fetch the 'hello, world' 3D text object that was loaded from the POD file and start it rotating
CC3MeshNode* helloTxt = (CC3MeshNode*)[self getNodeNamed: @"Hello"];
CCActionInterval* partialRot = [CC3RotateBy actionWithDuration: 1.0 rotateBy: cc3v(0.0, 30.0, 0.0)];
[helloTxt runAction: [CCRepeatForever actionWithAction: partialRot]];
//To make things a bit more appealing, set up a repeating up/down cycle to change the color of the text from the original red to blue, and back again.
GLfloat tintTime = 8.0f;
ccColor3B startColor = helloTxt.color;
ccColor3B endColor = { 50, 0, 200 };
CCActionInterval* tintDown = [CCTintTo actionWithDuration: tintTime red: endColor.r green: endColor.g blue: endColor.b];
CCActionInterval* tintUp = [CCTintTo actionWithDuration: tintTime red: startColor.r green: startColor.g blue: startColor.b];
CCActionInterval* tintCycle = [CCSequence actionOne: tintDown two: tintUp];
[helloTxt runAction: [CCRepeatForever actionWithAction: tintCycle]];
}
/* This template method is invoked periodically whenever the 3D nodes are to be updated. */
-(void) updateBeforeTransform: (CC3NodeUpdatingVisitor*) visitor {}
/* This template method is invoked periodically whenever the 3D nodes are to be updated. */
-(void) updateAfterTransform: (CC3NodeUpdatingVisitor*) visitor {}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec23"/>How it works...</h2></div></div></div><p>This recipe shows us a basic example of Cocos3d in action.<a id="id584" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Installing Cocos3d XCode templates:<a id="id585" class="indexterm"/><p>First, we must download the latest version of Cocos3d and install the XCode template. Go to <code class="literal">http://brenwill.com/cocos3d/</code>. On the right hand side you should see the latest Cocos3d source package. Download and unzip the package. To install the XCode templates, open the Terminal, navigate to the recently unzipped Cocos3d folder, and run the following command:
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>sudo sh install-cocos3d.sh</strong></span>
</pre></div><p>This will install the templates.
</p></li><li class="listitem"> Creating a Cocos3d project:<p>To create a project with the newly installed XCode template click <span class="strong"><strong>File | New | New Project</strong></span>. Under iOS you should see cocos3d. Under this choose <span class="strong"><strong>cocos3d Application</strong></span>.
</p></li><li class="listitem"> Using Cocos3d:<p>In the simple example we created we see a 3D font rendering that reads <span class="strong"><strong>"hello, world"</strong></span>. This 3D model is a PowerVR POD file created in either Maya or 3DS Max and exported using PVRGeoPOD. For more information about Cocos3d, please consult the Cocos3d documentation located (as of this writing) at <code class="literal">http://brenwill.com/docs/cocos3d/0.6.0-sp/api/</code>.
</p></li><li class="listitem"> CC3DemoMashUp:<p>Inside the source package you will find the XCode workspace file <code class="literal">cocos3d.xcworkspace</code>. Open this and you will find the <code class="literal">CC3DemoMashUp</code> target. The mash-up contains a number of advanced examples using mesh models, cameras, lights, bump mapping, animation, and more.
</p></li></ol></div></div></div>
<div class="section" title="Releasing your app"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec09"/>Releasing your app</h1></div></div></div><p>When you are finally finished creating your app it's time to release it on Apple's App Store. In this recipe we will go through this process.<a id="id586" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_09_10.jpg" alt="Releasing your app"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec24"/>Getting ready</h2></div></div></div><p>The scope of this recipe is rather large. Because of this we will provide a rough process outline along with supporting documentation, to help you publish your app to the App Store. These steps are mainly based on the guide in the<span class="strong"><strong> Distribution</strong></span> section of the<span class="strong"><strong> iOS Provisioning Portal</strong></span>. You need a valid<span class="strong"><strong> iOS Developer account</strong></span> to access this guide. Another great guide can be found here (with a valid iOS Developer account):<a class="ulink" href="http://adcdownload.apple.com/ios/ios_developer_program_user_guide/"> http://adcdownload.apple.com/ios/ios_developer_program_user_guide/ ios_developer_program_user_guide__standard_program_v2.7__final_9110.pdf</a>.<a id="id587" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec25"/>How to do it...</h2></div></div></div><p>Once your application is complete, it's time to start preparing your app for the App Store:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> iOS Provisioning Portal:<p>The iOS Provisioning Portal is where development certificates and provisioning profiles are created and/or managed, often in conjunction with XCode. The portal can be found by going to <code class="literal">http://developer.apple.com/ios/manage/overview/index.action</code> or by going to <code class="literal">http://developer.apple.com/devcenter/ios/index.action</code> and clicking on iOS <span class="strong"><strong>Provisioning Portal</strong></span>. Once you are there, go to the <span class="strong"><strong>App IDs</strong></span> section of the portal.
</p></li><li class="listitem"> Creating an explicit App ID:<p>Up until this point you may have been provisioning your app onto a device using an <span class="strong"><strong>App ID</strong></span> with an asterisk as the ID suffix. This wildcard allows easy ad hoc publishing of any app onto a registered device. However, if we want to publish our app to the App Store and have features like <code class="literal">Push Notification</code> enabled, we need to create an explicit App ID. Click <span class="strong"><strong>New App ID</strong></span> and instead of entering a * under <span class="strong"><strong>App ID Suffix</strong></span>, enter a proper reverse-domain name style string. An example of this would be <code class="literal">com.domainname.appname</code>. This is your <span class="strong"><strong>Bundle ID</strong></span>. Once this is finished, go to the <span class="strong"><strong>Distribution</strong></span> section of the iOS Provisioning Portal.
</p></li><li class="listitem"> Obtaining your distribution certificate:<p>This is where you must begin to follow the on-screen instructions carefully. Click <span class="strong"><strong>Obtaining your iOS Distribution Certificate</strong></span> to show the first set of instructions. Here, you will be told to generate a <span class="strong"><strong>Certificate Signing Request</strong></span> using the <span class="strong"><strong>Keychain Access</strong></span> app on your Mac. This request will then be submitted online. Once approved you can then download and install your distribution certificate.
<a id="id588" class="indexterm"/>
</p></li><li class="listitem"> Creating a Distribution Provisioning Profile:<p>Next, we must create a new "provisioning profile" specifically for distribution on the App Store. This is handled under the <span class="strong"><strong>Provisioning</strong></span> tab in the iOS Provisioning Portal. Remember that this profile will not allow you to push your app onto a device directly. For that, look into <span class="strong"><strong>Ad Hoc Distribution</strong></span>.
<a id="id589" class="indexterm"/>
</p></li><li class="listitem"> Building your app for distribution:<p>Once your <span class="strong"><strong>Distribution Provisioning Profile</strong></span> is installed you must create a new <span class="strong"><strong>Build Configuration</strong></span> for distribution in XCode. This configuration specifies the necessary certificate and provisioning profile as well as the specific <span class="strong"><strong>Bundle ID</strong></span> created earlier. This step also takes you through setting up your Entitlements.plist file. Finally, you build your application and zip it up for transport.
</p></li><li class="listitem"> Adding your application in iTunes Connect:<p>As we've discussed previously, <span class="strong"><strong>iTunes Connect</strong></span> is a set of tools that help developers publish their apps and manage app information. You can log into iTunes Connect by going to <a class="ulink" href="http://itunesconnect.apple.com/.">http://itunesconnect.apple.com/.</a> Once you've logged into iTunes Connect you need to click on <span class="strong"><strong>Manage Your Applications</strong></span>. Then, click <span class="strong"><strong>Add New App</strong></span> in the top-left to begin adding a new application. Follow the on-screen instructions. This will include uploading an app icon, images, and description. When you are finished, go back to the <span class="strong"><strong>Manage Your Apps </strong></span>page and select the app you just created. Finally, click <span class="strong"><strong>Ready to Upload Binary</strong></span> and fill out any more necessary information. Your app should now show the <span class="strong"><strong>Waiting for Upload</strong></span> state.
<a id="id590" class="indexterm"/>
</p></li><li class="listitem"> Using Application Loader:<p>Now it is time to upload your application using <span class="strong"><strong>Application Loader</strong></span>. Application Loader is a separate Mac application designed to handle the uploading of apps. Application Loader can be downloaded at <a class="ulink" href="http://itunesconnect.apple.com/apploader/ApplicationLoader_1.3.dmg">http://itunesconnect.apple.com/apploader/ApplicationLoader_1.3.dmg</a>http://itunesconnect.apple.com/apploader/ApplicationLoader_1.3.dmg. Once you've installed Application Loader, open it up and begin uploading the application we zipped up previously. For more information about using Application Loader, please consult the documentation found here: <a class="ulink" href="https://itunesconnect.apple.com/docs/UsingApplicationLoader.pdf">https://itunesconnect.apple.com/docs/UsingApplicationLoader.pdf</a>.
<a id="id591" class="indexterm"/>
</p></li><li class="listitem"> The App Store Approval Process:<p>Once your app has been uploaded it gets placed in a queue to await approval from Apple. This process can take upwards of one week, so be patient. Once your app has been approved, you will see a small green light and the app state will say <span class="strong"><strong>Ready for Sale</strong></span>. Give Apple another 24-48 hours and your app should be on the App Store! For more information about the App Store review guidelines, please refer to this page: <a class="ulink" href="http://developer.apple.com/appstore/guidelines.html">http://developer.apple.com/appstore/guidelines.html</a>.
<a id="id592" class="indexterm"/>
</p></li></ol></div></div></div></body></html>