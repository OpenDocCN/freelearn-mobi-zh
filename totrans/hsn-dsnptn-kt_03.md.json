["```kt\nYay! Very useful\n```", "```kt\nclass HappyMap<K, V>: HashMap<K, V>() {\n    override fun put(key: K, value: V): V? {\n        return super.put(key, value).apply {\n            this?.let {\n                println(\"Yay! $key\")\n            }\n        }\n    }\n}\n```", "```kt\nfun main(args : Array<String>) {\n    val happy = HappyMap<String, String>()\n    happy[\"one\"] = \"one\"\n    happy[\"two\"] = \"two\"\n    happy[\"two\"] = \"three\"\n}\n```", "```kt\nYay! two\n```", "```kt\nSystem.out.println(1 + 1); // 2\nSystem.out.println(\"1\" + \"1\") // 11\n```", "```kt\nList<String> a = Arrays.asList(\"a\");\nList<String> b = Collections.singletonList(\"b\"); // Same for one argument\nList<String> c = a + b;\n```", "```kt\nval a = listOf(\"a\")\nval b = listOf(\"b\")\nprintln(a + b)\n```", "```kt\ndata class Json(val j: String)\nval j1 = Json(\"\"\"{\"a\": \"b\"}\"\"\")\nval j2 = Json(\"\"\"{\"c\": \"d\"}\"\"\")\nprintln(j1 + j2) // Compilation error!\n```", "```kt\noperator fun Json.plus(j2: Json): Json {\n   // Code comes here\n}\n```", "```kt\nval jsonFields = this.j.split(\":\") + j2.j.split(\":\")\nval s = (jsonFields).joinToString(\":\")\nreturn Json (\"\"\"{$s}\"\"\")\n```", "```kt\nprintln(j1 + j2)\n```", "```kt\n{{\"a\": \"b\"}:{\"c\": \"d\"}}\n```", "```kt\nclass SadMap<K, V>: HashMap<K, V>() {\n    override fun remove(key: K): V? {\n        println(\"Okay...\")\n        return super.remove(key)\n    }\n}\n```", "```kt\nOkay...\n```", "```kt\nclass HappyMap<K, V>(private val map: MutableMap<K, V> =                                        mutableMapOf()) : \n      MutableMap<K, V> by map {\n\n    override fun put(key: K, value: V): V? {\n        return map.put(key, value).apply {\n            this?.let { println(\"Yay! $key\") }\n        }\n    }\n}\n```", "```kt\nclass HappyMap<K, V>(...\n```", "```kt\n... (private val map: MutableMap<K, V> ...\n```", "```kt\n... = mutableMapOf()) ...\n```", "```kt\n... : MutableMap<K, V> ...\n```", "```kt\n... by map\n```", "```kt\nval sadHappy = SadMap(HappyMap<String, String>())\nsadHappy[\"one\"] = \"one\"\nsadHappy[\"two\"] = \"two\"\n\n```", "```kt\nsadHappy[\"two\"] = \"three\"\nsadHappy[\"a\"] = \"b\"\nsadHappy.remove(\"a\")\n```", "```kt\nYay! two // Because it delegates to HappyMap\nOkay...  // Because it is a SadMap\n```", "```kt\nval superSad = SadMap(HappyMap<String, String>())\n```", "```kt\nprintln(sadHappy is SadMap<*, *>) // True\n```", "```kt\nprintln(sadHappy is MutableMap<*, *>) // True\n```", "```kt\nprintln(sadHappy is HappyMap<*, *>) // False\n```", "```kt\ninterface UsbTypeC\ninterface UsbMini\n\ninterface EUPlug\ninterface USPlug\n```", "```kt\n// Power outlet exposes USPlug interface\nfun powerOutlet() : USPlug {\n    return object : USPlug {}\n}\n\n```", "```kt\nfun cellPhone(chargeCable: UsbTypeC) {\n\n}\n```", "```kt\n// Charger accepts EUPlug interface and exposes UsbMini interface\nfun charger(plug: EUPlug) : UsbMini {\n    return object : UsbMini {}\n}\n```", "```kt\nType mismatch: required EUPlug, found USPlug: charger(powerOutlet())\n\nType mismatch: required UsbTypeC, found UsbMini: cellPhone(charger(powerOutlet()))\n```", "```kt\nfun USPlug.toEUPlug() : EUPlug {\n    return object : EUPlug {\n        // Do something to convert \n    }\n}\n```", "```kt\nfun UsbMini.toUsbTypeC() : UsbTypeC {\n    return object : UsbTypeC {\n        // Do something to convert\n    }\n}\n```", "```kt\ncellPhone(\n    charger(\n        powerOutlet().toEUPlug()\n    ).toUsbTypeC()\n)\n```", "```kt\nval l = listOf(\"a\", \"b\", \"c\")\n\nfun <T> streamProcessing(stream: Stream<T>) { \n    // Do something with stream\n}\n```", "```kt\nstreamProcessing(l) // Doesn't compile\n```", "```kt\nstreamProcessing(l.stream()) // Adapted successfully\n```", "```kt\nfun <T> collectionProcessing(c: Collection<T>) {\n    for (e in c) {\n        println(e)\n    }\n}\n\nval s = Stream.generate { 42 }\ncollectionProcessing(s.toList())\n```", "```kt\ninterface Infantry {\n    fun move(x: Long, y: Long)\n\n    fun attack(x: Long, y: Long)\n}\n```", "```kt\nopen class Rifleman : Infantry {\n    override fun attack(x: Long, y: Long) {\n        // Shoot\n    }\n\n    override fun move(x: Long, y: Long) {\n        // Move at its own pace\n    }\n}\n\nopen class Grenadier : Infantry {\n    override fun attack(x: Long, y: Long) {\n        // Throw grenades\n    }\n\n    override fun move(x: Long, y: Long) {\n        // Moves slowly, grenades are heavy\n    }\n}\n```", "```kt\nclass UpgradedRifleman : Rifleman() {\n    override fun attack(x: Long, y: Long) {\n        // Shoot twice as much\n    }\n}\n\nclass UpgradedGrenadier : Grenadier() {\n    override fun attack(x: Long, y: Long) {\n        // Throw pack of grenades\n    }\n}\n```", "```kt\nclass LightRifleman : Rifleman() {\n    override fun move(x: Long, y: Long) {\n        // Running with rifle\n    }\n}\n\nclass LightGrenadier : Grenadier() {\n    override fun move(x: Long, y: Long) {\n        // I've been to gym, pack of grenades is no problem\n    }\n}\n```", "```kt\ninterface Infantry {\n    // As before, move() and attack() functions\n\n    fun shout() // Here comes the change\n}\n```", "```kt\nInfantry --> Rifleman  --> Upgraded Rifleman                                                                           --> Light Rifleman             \n         --> Grenadier --> Upgraded Grenadier       \n                       --> Light Grenadier\n```", "```kt\nclass Soldier(private val weapon: Weapon,\n              private val legs: Legs) : Infantry {\n    override fun attack(x: Long, y: Long) {\n        // Find target\n        // Shoot\n        weapon.causeDamage()\n    }\n\n    override fun move(x: Long, y: Long) {\n        // Compute direction\n        // Move at its own pace\n        legs.move()\n    }\n}\n```", "```kt\ninterface Weapon {\n    fun causeDamage(): PointsOfDamage\n}\n\ninterface Legs {\n    fun move(): Meters\n}\n```", "```kt\ntypealias PointsOfDamage = Long\ntypealias Meters = Int\n```", "```kt\nclass Grenade : Weapon {\n    override fun causeDamage() = GRENADE_DAMAGE\n}\n\nclass GrenadePack : Weapon {\n    override fun causeDamage() = GRENADE_DAMAGE * 3\n}\n\nclass Rifle : Weapon {\n    override fun causeDamage() = RIFLE_DAMAGE\n}\n\n```", "```kt\nclass MachineGun : Weapon {\n    override fun causeDamage() = RIFLE_DAMAGE * 2\n}\n```", "```kt\nclass RegularLegs : Legs {\n    override fun move() = REGULAR_SPEED\n}\n\nclass AthleticLegs : Legs {\n    override fun move() = REGULAR_SPEED * 2\n}\n```", "```kt\nconst val GRENADE_DAMAGE : PointsOfDamage = 5L\nconst val RIFLE_DAMAGE = 3L\nconst val REGULAR_SPEED : Meters = 1\n```", "```kt\nval rifleman = Soldier(Rifle(), RegularLegs())\nval grenadier = Soldier(Grenade(), RegularLegs())\nval upgradedGrenadier = Soldier(GrenadePack(), RegularLegs())\nval upgradedRifleman = Soldier(MachineGun(), RegularLegs())\nval lightRifleman = Soldier(Rifle(), AthleticLegs())\nval lightGrenadier = Soldier(Grenade(), AthleticLegs())\n```", "```kt\nInfantry --> Soldier\n\nWeapon --> Rifle\n       --> MachineGun\n       --> Grenade\n       --> GrenadePack \n\nLegs --> RegularLegs\n     --> AthleticLegs\n```", "```kt\ninterface InfantryUnit\n\nclass Rifleman : InfantryUnit\n\nclass Sniper : InfantryUnit\n```", "```kt\nclass Squad(val infantryUnits: MutableList<InfantryUnit> =         mutableListOf())\n```", "```kt\nval miller = Rifleman()\nval caparzo = Rifleman()\nval jackson = Sniper()\n\nval squad = Squad()\n\nsquad.infantryUnits.add(miller)\nsquad.infantryUnits.add(caparzo)\nsquad.infantryUnits.add(jackson)\n\nprintln(squad.infantryUnits.size) // Prints 3\n```", "```kt\nval squad = Squad(miller, caparzo, jackson)\n```", "```kt\nclass Squad(val infantryUnits: MutableList<InfantryUnit> = mutableListOf()) {\n    constructor(first: InfantryUnit) : this(mutableListOf()) {\n        this.infantryUnits.add(first)\n    }\n\n    constructor(first: InfantryUnit, \n                second: InfantryUnit) : this(first) {\n        this.infantryUnits.add(second)\n    }\n\n    constructor(first: InfantryUnit, \n                second: InfantryUnit, \n                third: InfantryUnit) : \n        this(first, second) {\n        this.infantryUnits.add(third)\n    }\n}\n```", "```kt\n    constructor(first: InfantryUnit) : this(mutableListOf()) {\n    }                                     ⇑\n                                          ⇑\n    constructor(first: InfantryUnit,      ⇑ // Delegating\n                second: InfantryUnit) : this(first) {    \n    }\n```", "```kt\nclass Squad(val infantryUnits: MutableList<InfantryUnit> =     mutableListOf()) {\n\n    constructor(vararg units: InfantryUnit) : this(mutableListOf()) {\n        for (u in units) {\n            this.infantryUnits.add(u)\n        }\n    }\n}\n```", "```kt\nfun bulletsLeft(): Long {\n    // Do your job\n}\n```", "```kt\nclass Bullet\n```", "```kt\nclass Magazine(capacity: Int) {\n    private val bullets = List(capacity) { Bullet() }\n}\n```", "```kt\ninterface CanCountBullets {\n    fun bulletsLeft(): Int\n}\n```", "```kt\ninterface InfantryUnit : CanCountBullets\n\nclass Squad(...) : CanCountBullets {\n    ...\n}\n\nclass Magazine(...): CanCountBullets {\n    ...\n}\n```", "```kt\nclass Magazine(...): CanCountBullets {\n    ...\n    override fun bulletsLeft() = bullets.size\n}\n```", "```kt\nclass Sniper(initalBullets: Int = 50) : InfantryUnit {\n    private val bullets = List(initalBullets) { Bullet () }\n    override fun bulletsLeft() = bullets.size\n}\n```", "```kt\nclass Rifleman(initialMagazines: Int = 3) : InfantryUnit {\n    private val magazines = List<Magazine>(initialMagazines) {\n        Magazine(5)\n    }\n\n    override fun bulletsLeft(): Int {\n        return magazines.sumBy { it.bulletsLeft() }\n    }\n}\n```", "```kt\noverride fun bulletsLeft(): Int {\n    return infantryUnits.sumBy { it.bulletsLeft() }\n}\n```", "```kt\ninterface GameWorld\n```", "```kt\nfun loadGame(file: File) GameWorld\n```", "```kt\nclass TansanianSnail\n```", "```kt\nenum class Direction {\n   LEFT,\n   RIGHT\n}\n```", "```kt\nclass TansanianSnail() {\n   val directionFacing = Direction.LEFT\n\n   val sprites = listOf(java.io.File(\"snail-left.jpg\"), \n                        java.io.File(\"snail-right.jpg\"))\n}\n```", "```kt\n    fun TansanianSnail.getCurrentSprite() : java.io.File {\n        return when (directionFacing) {\n            Direction.LEFT -> sprites[0]\n            Direction.RIGHT -> sprites[1]\n        }\n    }\n```", "```kt\n      _____\n  \\|_\\___  \\\n  /________/    <-- With a bit of imagination you'll see it's a snail\n```", "```kt\n---------------------------------------------------------------------\n     _____ |    _____ |    _____ |    _____ |    _____ |    _____        \n _|_/___∂ \\|\\|_/___∂ \\|\\/_/___∂ \\|\\|_/___∂ \\|\\|_/___∂ \\|\\|_/___∂ \\\n /____\\___/| \\___\\___/|/____\\___/|/____\\___/|/____\\___/|/____\\___/\n---------------------------------------------------------------------\nleft-3      left-2     left-1     right-1    right-2    right-3      \n```", "```kt\n    val sprites = List(8) { i ->\n              java.io.File(when {\n                        i == 0 -> \"snail-left.jpg\"\n                        i == 1 -> \"snail-right.jpg\"\n                        i in 2..4 -> \"snail-move-left-${i-1}.jpg\"\n                        else -> \"snail-move-right${(4-i)}.jpg\"\n                    })\n            }\n```", "```kt\nval sprites = List(8) { i ->\n    java.io.File(when {\n        i == 0 -> \"snail-left.jpg\"\n        i == 1 -> \"snail-right.jpg\"\n        i in 2..4 -> \"snail-move-left-${i-1}.jpg\"\n        else -> \"snail-move-right${(4-i)}.jpg\"\n    })\n}\n```", "```kt\nfun TansanianSnail.getCurrentSprite(sprites: List<java.io.File>) :     java.io.File { ... }\n```", "```kt\nsprites = null\n```", "```kt\nsprites.clear()\n```", "```kt\nsprites.clear()\nsprites[0] = File(\"garbage\")\nsprites[0] = null\n```", "```kt\ndata class CatImage(private val thumbnailUrl: String, \n                    private val url: String) {\n    val image: java.io.File by lazy {\n        // Actual fetch goes here\n    }\n}\n```"]