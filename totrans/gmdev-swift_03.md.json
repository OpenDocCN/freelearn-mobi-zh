["```swift\nimport SpriteKit\n\nprotocol GameSprite {\n    var textureAtlas: SKTextureAtlas { get set }\n    func spawn(parentNode: SKNode, position: CGPoint, size: \n        CGSize)\n    func onTap()\n}\n```", "```swift\nimport SpriteKit\n\n// Create the new class Bee, inheriting from SKSpriteNode\n// and adopting the GameSprite protocol:\nclass Bee: SKSpriteNode, GameSprite {\n    // We will store our texture atlas and bee animations as\n    // class wide properties.\n    var textureAtlas:SKTextureAtlas = \n        SKTextureAtlas(named:\"bee.atlas\")\n    var flyAnimation = SKAction()\n\n    // The spawn function will be used to place the bee into\n    // the world. Note how we set a default value for the size\n    // parameter, since we already know the size of a bee\n    func spawn(parentNode:SKNode, position: CGPoint, size: CGSize \n        = CGSize(width: 28, height: 24)) {\n        parentNode.addChild(self)\n        createAnimations()\n        self.size = size\n        self.position = position\n        self.runAction(flyAnimation)\n    }\n\n    // Our bee only implements one texture based animation.\n    // But some classes may be more complicated,\n    // So we break out the animation building into this function:\n    func createAnimations() {\n        let flyFrames:[SKTexture] = \n            [textureAtlas.textureNamed(\"bee.png\"), \n            textureAtlas.textureNamed(\"bee_fly.png\")]\n        let flyAction = SKAction.animateWithTextures(flyFrames, \n            timePerFrame: 0.14)\n        flyAnimation = SKAction.repeatActionForever(flyAction)\n    }\n\n    // onTap is not wired up yet, but we have to implement this\n    // function to adhere to our protocol.\n    // We will explore touch events in the next chapter.\n    func onTap() {}\n}\n```", "```swift\n// Create three new instances of the Bee class:\nlet bee2 = Bee()\nlet bee3 = Bee()\nlet bee4 = Bee()\n// Use our spawn function to place the bees into the world:\nbee2.spawn(world, position: CGPoint(x: 325, y: 325))\nbee3.spawn(world, position: CGPoint(x: 200, y: 325))\nbee4.spawn(world, position: CGPoint(x: 50, y: 200))\n```", "```swift\nimport SpriteKit\n\n// A new class, inheriting from SKSpriteNode and\n// adhering to the GameSprite protocol.\nclass Ground: SKSpriteNode, GameSprite {\n    var textureAtlas:SKTextureAtlas = \n        SKTextureAtlas(named:\"ground.atlas\")\n    // Create an optional property named groundTexture to store \n    // the current ground texture:\n    var groundTexture:SKTexture?\n\n    func spawn(parentNode:SKNode, position:CGPoint, size:CGSize) {\n        parentNode.addChild(self)\n        self.size = size\n        self.position = position\n        // This is one of those unique situations where we use\n        // non-default anchor point. By positioning the ground by\n        // its top left corner, we can place it just slightly\n        // above the bottom of the screen, on any of screen size.\n        self.anchorPoint = CGPointMake(0, 1)\n\n        // Default to the ice texture:\n        if groundTexture == nil {\n            groundTexture = textureAtlas.textureNamed(\"ice-\n                tile.png\");\n        }\n\n        // We will create child nodes to repeat the texture.\n        createChildren()\n    }\n\n    // Build child nodes to repeat the ground texture\n    func createChildren() {\n        // First, make sure we have a groundTexture value:\n        if let texture = groundTexture {\n            var tileCount:CGFloat = 0\n            let textureSize = texture.size()\n            // We will size the tiles at half the size\n            // of their texture for retina sharpness:\n            let tileSize = CGSize(width: textureSize.width / 2, \n                height: textureSize.height / 2)\n\n            // Build nodes until we cover the entire Ground width\n            while tileCount * tileSize.width < self.size.width {\n                let tileNode = SKSpriteNode(texture: texture)\n                tileNode.size = tileSize\n                tileNode.position.x = tileCount * tileSize.width\n                // Position child nodes by their upper left corner\n                tileNode.anchorPoint = CGPoint(x: 0, y: 1)\n                // Add the child texture to the ground node:\n                self.addChild(tileNode)\n\n                tileCount++\n            }\n        }\n    }\n\n    // Implement onTap to adhere to the protocol:\n    func onTap() {}\n}\n```", "```swift\n    let world = SKNode()\n    let ground = Ground()\n\n    ```", "```swift\n    // size and position the ground based on the screen size.\n    // Position X: Negative one screen width.\n    // Position Y: 100 above the bottom (remember the ground's top\n    // left anchor point).\n    let groundPosition = CGPoint(x: -self.size.width, y: 100)\n    // Width: 3x the width of the screen.\n    // Height: 0\\. Our child nodes will provide the height.\n    let groundSize = CGSize(width: self.size.width * 3, height: 0)\n    // Spawn the ground!\n    ground.spawn(world, position: groundPosition, size: groundSize)\n    ```", "```swift\nimport SpriteKit\n\nclass Player : SKSpriteNode, GameSprite {\n    var textureAtlas:SKTextureAtlas = \n        SKTextureAtlas(named:\"pierre.atlas\")\n    // Pierre has multiple animations. Right now we will\n    // create an animation for flying up, and one for going down:\n    var flyAnimation = SKAction()\n    var soarAnimation = SKAction()\n\n    func spawn(parentNode:SKNode, position: CGPoint,\n        size:CGSize = CGSize(width: 64, height: 64)) {\n        parentNode.addChild(self)\n        createAnimations()\n        self.size = size\n        self.position = position\n        // If we run an action with a key, \"flapAnimation\",\n        // we can later reference that key to remove the action.\n        self.runAction(flyAnimation, withKey: \"flapAnimation\")\n    }\n\n    func createAnimations() {\n        let rotateUpAction = SKAction.rotateToAngle(0, duration: \n            0.475)\n        rotateUpAction.timingMode = .EaseOut\n        let rotateDownAction = SKAction.rotateToAngle(-1, \n            duration: 0.8)\n        rotateDownAction.timingMode = .EaseIn\n\n        // Create the flying animation:\n        let flyFrames:[SKTexture] = [\n            textureAtlas.textureNamed(\"pierre-flying-1.png\"),\n            textureAtlas.textureNamed(\"pierre-flying-2.png\"),\n            textureAtlas.textureNamed(\"pierre-flying-3.png\"),\n            textureAtlas.textureNamed(\"pierre-flying-4.png\"),\n            textureAtlas.textureNamed(\"pierre-flying-3.png\"),\n            textureAtlas.textureNamed(\"pierre-flying-2.png\")\n        ]\n        let flyAction = SKAction.animateWithTextures(flyFrames, \n            timePerFrame: 0.03)\n        // Group together the flying animation frames with a \n        // rotation up:\n        flyAnimation = SKAction.group([\n            SKAction.repeatActionForever(flyAction),\n            rotateUpAction\n        ])\n\n        // Create the soaring animation, just one frame for now:\n        let soarFrames:[SKTexture] = \n            [textureAtlas.textureNamed(\"pierre-flying-1.png\")]\n        let soarAction = SKAction.animateWithTextures(soarFrames, \n            timePerFrame: 1)\n        // Group the soaring animation with the rotation down:\n        soarAnimation = SKAction.group([\n            SKAction.repeatActionForever(soarAction),\n            rotateDownAction\n        ])\n    }\n\n    func onTap() {}\n}\n```", "```swift\n    player.spawn(world, position: CGPoint(x: 150, y: 250))\n    ```", "```swift\nclass GameScene: SKScene {\n    let world = SKNode()\n    let player = Player()\n    let ground = Ground()\n\n    override func didMoveToView(view: SKView) {\n        // Set a sky-blue background color:\n        self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: \n            0.95, alpha: 1.0)\n\n        // Add the world node as a child of the scene:\n        self.addChild(world)\n\n        // Spawn our physics bees:\n        let bee2 = Bee()\n        let bee3 = Bee()\n        let bee4 = Bee()\n        bee2.spawn(world, position: CGPoint(x: 325, y: 325))\n        bee3.spawn(world, position: CGPoint(x: 200, y: 325))\n        bee4.spawn(world, position: CGPoint(x: 50, y: 200))\n\n        // Spawn the ground:\n        let groundPosition = CGPoint(x: -self.size.width, y: 30)\n        let groundSize = CGSize(width: self.size.width * 3, \n            height: 0)\n        ground.spawn(world, position: groundPosition, size: \n            groundSize)\n\n        // Spawn the player:\n        player.spawn(world, position: CGPoint(x: 150, y: 250))\n    }\n\n    override func didSimulatePhysics() {\n        let worldXPos = -(player.position.x * world.xScale – \n            (self.size.width / 2))\n        let worldYPos = -(player.position.y * world.yScale – \n            (self.size.height / 2))\n        world.position = CGPoint(x: worldXPos, y: worldYPos)\n    }\n}\n```", "```swift\n// Attach a physics body, shaped like a circle\n// and sized roughly to our bee.\nself.physicsBody = SKPhysicsBody(circleOfRadius: size.width / 2)\n```", "```swift\n// Draw an edge physics body along the top of the ground node.\n// Note: physics body positions are relative to their nodes.\n// The top left of the node is X: 0, Y: 0, given our anchor point.\n// The top right of the node is X: size.width, Y: 0\nlet pointTopRight = CGPoint(x: size.width, y: 0)\nself.physicsBody = SKPhysicsBody(edgeFromPoint: CGPointZero, \n    toPoint: pointTopRight)\n```", "```swift\nself.physicsBody?.affectedByGravity = false\n```", "```swift\nbee2.physicsBody?.applyImpulse(CGVector(dx: -3, dy: 0))\n```", "```swift\nbee2.physicsBody?.mass = 0.2\n```", "```swift\nbee2.physicsBody?.applyImpulse(CGVector(dx: -15, dy: 0))\n```"]