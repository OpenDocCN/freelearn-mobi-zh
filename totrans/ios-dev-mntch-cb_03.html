<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. User Interface: View Controllers</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading a view with a view controller</li><li class="listitem" style="list-style-type: disc">Navigating through different view controllers</li><li class="listitem" style="list-style-type: disc">Providing controllers in tabs</li><li class="listitem" style="list-style-type: disc">Creating a table controller</li><li class="listitem" style="list-style-type: disc">Modal view controllers</li><li class="listitem" style="list-style-type: disc">Creating a custom view controller</li><li class="listitem" style="list-style-type: disc">Using view controllers efficiently</li><li class="listitem" style="list-style-type: disc">Combining different view controllers</li><li class="listitem" style="list-style-type: disc">iPad view controllers</li><li class="listitem" style="list-style-type: disc">Creating a user interface for different devices</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Introduction</h1></div></div></div><p>So far, we have discussed views and how to use them. In most cases of real-world application scenarios, views alone are not enough. Apple provides another base class, the<code class="literal"> UIViewController</code>, which is responsible for managing views. A view controller can respond to device notifications, such as when the device rotates, or can provide different ways for displaying and dismissing multiple views or even other view controllers.<a id="id255" class="indexterm"/>
</p><p>We will also see how to use the most common view controllers to create applications that manage multiple views.</p><p>These view controllers are:<a id="id257" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UIViewController:</code> This is the base class of all view controllers<a id="id258" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UINavigationController:</code> This is the view controller that provides various ways of navigating through different view controllers<a id="id259" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITabBarController:</code> This is a view controller that displays multiple view controllers in a tab-like interface<a id="id260" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITableViewController:</code> This is a view controller that is used to display data in a list form<a id="id261" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>iPad-specific view controllers:</strong> These are view controllers that only apply to the iPad device<a id="id262" class="indexterm"/></li></ul></div><p>Furthermore, we will discuss combining different controllers, how to create custom controllers and use them, and we will create an application that can be deployed in both the iPhone and iPad.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Loading a view with a view controller</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UIViewController</code> class to manage views.<a id="id263" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> ViewControllerApp</code>.<a id="id264" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a new file to the project.</li><li class="listitem"> Right-click on the project in the<strong> Solution</strong> pad and select<strong> Add | New File</strong>.</li><li class="listitem"> In the dialog box that will appear, select<strong> iPhone View</strong> with<strong> Controller</strong> from the<strong> MonoTouch</strong> section. Name it<code class="literal"> MainViewController</code>, and click on the<strong> New</strong> button. MonoDevelop will create a new<code class="literal"> XIB</code> file and will automatically open the<code class="literal"> MainViewController.cs</code> source file. This file contains a class that overrides the<code class="literal"> UIViewController</code>, and we can implement any code related to our view controller in it.</li><li class="listitem"> Open the<code class="literal"> MainViewController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UILabel</code> on the view.</li><li class="listitem"> Create and connect an outlet for it inside the<code class="literal"> MainViewController</code> class, and name it<code class="literal"> myLabel</code>.<a id="id265" class="indexterm"/></li><li class="listitem"> Enter the text<code class="literal"> View in controller!</code> in the label.</li><li class="listitem"> Save the<code class="literal"> XIB</code> document.</li><li class="listitem"> Back in MonoDevelop, enter the following code in the<code class="literal"> FinishedLaunching()</code> method:<a id="id266" class="indexterm"/><div><pre class="programlisting">MainViewController mainController = new MainViewController ();
window.RootViewController = mainController;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.<a id="id267" class="indexterm"/></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>How it works...</h2></div></div></div><p>When we add a new<strong> iPhone View with Controller</strong> file in a project, in this case<code class="literal"> MainViewController</code>, MonoDevelop basically creates and adds three files:<a id="id268" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><code class="literal"> MainViewController.xib:</code> This is the XIB file that contains the controller.</li><li class="listitem"><code class="literal"> MainViewController.cs:</code> This is the C# source file that implements the class of our controller.</li><li class="listitem"><code class="literal"> MainViewController.designer.cs:</code> This is the auto-generated source file that reflects the changes we make to the controller in Interface Builder.</li></ol></div><p>Notice that we do not need to add an outlet for the view, since this is taken care of by MonoDevelop. We initialize the controller through its class:</p><div><pre class="programlisting">MainViewController mainController = new MainViewController ();
</pre></div><p>Then, we display its view through the controller's<code class="literal"> View</code> by setting it as the<code class="literal"> RootViewController</code> of our application's window:</p><div><pre class="programlisting">window.RootViewController = mainController;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>There's more...</h2></div></div></div><p>The project we have just created only shows how we can add a controller with a view. Notice that we created the outlet for the label inside the<code class="literal"> MainViewController</code> class, which acts as the file's owner object in the<code class="literal"> XIB</code> file. To provide some functionality for the<code class="literal"> MainViewController</code>, add the following method in the<code class="literal"> MainViewController</code> class in the<code class="literal"> MainViewController.cs</code> file:</p><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad();
this.myLabel.Text = "View loaded!";
}
</pre></div><p>This method overrides the<code class="literal"> UIViewController.ViewDidLoad()</code> method, which is executed when the controller loads its view.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>UIViewController methods to override</h3></div></div></div><p>The methods that the<code class="literal"> UIViewController</code> class contains are the ones that we override to use its features. Some of these methods are:<a id="id269" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidUnload():</code> It is called when the view is unloaded<a id="id270" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewWillAppear():</code> It is called when the view is about to appear on the screen<a id="id271" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidAppear():</code> It is called when the view has been displayed<a id="id272" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewWillDisappear():</code> It is called when the view is about to disappear, for example, when another controller is about to be displayed<code class="literal"> ViewDidDisappear():</code> It is called when the view has disappeared<a id="id273" class="indexterm"/></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Navigating through different view controllers</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>,Development Tools:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating an iPhone project with MonoDevelop</em></li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with outlets</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Navigating through different view controllers</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UINavigationController</code> class to navigate among multiple view controllers.<a id="id274" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UINavigationController</code> is a controller that provides a hierarchical navigation functionality with multiple view controllers. Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> NavigationControllerApp</code>.<a id="id275" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec07"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add three new<strong> iPhone View with Controller</strong> files in the project, and name them<code class="literal"> RootViewController, ViewController1</code>, and<code class="literal"> ViewController2</code>.<a id="id276" class="indexterm"/></li><li class="listitem"> Add the following field in the<code class="literal"> AppDelegate</code> class:<a id="id277" class="indexterm"/><div><pre class="programlisting">UINavigationController navController;
</pre></div></li><li class="listitem"> In the same class, add the following code in the<code class="literal"> FinishedLaunching</code> method, above the<code class="literal"> window.MakeKeyAndVisible()</code>; line:<a id="id278" class="indexterm"/><div><pre class="programlisting">RootViewController rootController = new RootViewController();
this.navController = new UINavigationController(rootController);
window.RootViewController = this.navController;
</pre></div></li><li class="listitem"> Open the<code class="literal"> RootViewController.xib</code> file in Interface Builder, and add two buttons with their corresponding outlets. Set their titles to<code class="literal"> First View</code> and<code class="literal"> Second View</code> respectively.<a id="id279" class="indexterm"/></li><li class="listitem"> Save the document.</li><li class="listitem"> Open both the<code class="literal"> ViewController1.xib</code> and<code class="literal"> ViewController2.xib</code>, and add a button in each one with the title<code class="literal"> Pop to root</code>. Do not forget to connect the buttons with outlets and save the documents.</li><li class="listitem"> Enter the following code in the<code class="literal"> RootViewController</code> class:<div><pre class="programlisting">public override void ViewDidLoad (){
this.buttonFirstView.TouchUpInside += delegate {
ViewController1 cont1 = new ViewController1 ();
cont1.Title = "Controller #1";
this.NavigationController.PushViewController (cont1, true);
};
this.buttonSecondView.TouchUpInside += delegate {
ViewController2 cont2 = new ViewController2 ();
cont2.Title = "Controller #2";
this.NavigationController.PushViewController (cont2, true);
};
}
</pre></div></li><li class="listitem"> In both<code class="literal"> ViewController1</code> and<code class="literal"> ViewController2</code> classes, enter the following:<div><pre class="programlisting">public override void ViewDidLoad (){
this.buttonPop.TouchUpInside += delegate {
this.NavigationController.PopToRootViewController (true);
};
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. Tap on each of the buttons to see and navigate through the available views.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec08"/>How it works...</h2></div></div></div><p>The<code class="literal"> UINavigationController</code> preserves a stack of controllers. The<code class="literal"> UIViewController</code> class has a property named<code class="literal"> NavigationController</code>. In normal situations, this property returns null. But, if the controller is pushed into a navigation controller's stack, it returns the instance of the navigation controller it is being pushed in. So this way, at any point in the hierarchy of controllers, access to the navigation controller is provided. To display a controller, we call the<code class="literal"> UINavigationController.PushViewController(UIViewController, bool)</code> method:<a id="id280" class="indexterm"/>
</p><div><pre class="programlisting">this.NavigationController.PushViewController (cont1, true);
</pre></div><p>Notice that the<code class="literal"> RootViewController</code> is the topmost or root controller in the navigation stack. A navigation controller must have at least one view controller that will act as its root controller. We set it when we create the instance of the UINavigationController class:</p><div><pre class="programlisting">this.navController = new UINavigationController(rootController);
</pre></div><p>To return to the root controller, we call the<code class="literal"> PopToRootViewController(bool)</code> method inside the current controller:<a id="id281" class="indexterm"/>
</p><div><pre class="programlisting">this.NavigationController.PopToRootViewController (true);
</pre></div><p>The<code class="literal"> bool</code> parameters in both the methods are used for transitioning between controllers with animation.<a id="id282" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec09"/>There's more...</h2></div></div></div><p>In this simple example, we provided backward navigation to the root controller with buttons. Notice that there is an arrow-shaped button at the top bar. That bar is called the<strong> navigation</strong> bar, and is of the type<code class="literal"> UINavigationBar</code>. The arrow-shaped button is called the<strong> back</strong> button and is of the type<code class="literal"> UIBarButtonItem</code>. The back button, when it exists, always navigates to the previous controller in the navigation stack.<a id="id283" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Managing navigation bar buttons</h3></div></div></div><p>To change, add, and hide the buttons of the navigation bar, we can use the following methods of our currently displayed view controller's<code class="literal"> NavigationItem</code> property:<a id="id284" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SetLeftBarButtonItem:</code> It adds a custom button on the left of the navigation bar, replacing the default<strong> Back</strong> button<a id="id285" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">SetRightBarButtonItem:</code> It adds a custom button on the right side of the navigation bar<a id="id286" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">SetHidesBackButton:</code> It sets the visibility of the default<strong> Back</strong> button<a id="id287" class="indexterm"/></li></ul></div><p>To remove or hide the custom left or right buttons on the navigation bar, call the appropriate methods, passing<code class="literal"> null</code> instead of a<code class="literal"> UIBarButtonItem</code> object.<a id="id288" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Modal view controllers</em></li><li class="listitem" style="list-style-type: disc"><em>Using view controllers efficiently</em></li><li class="listitem" style="list-style-type: disc"><em>Combining different view controllers</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch11.html" title="Chapter 11. Graphics and Animation">Chapter 11</a>,Graphics and Animation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Pushing view controllers with animation</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Providing controllers in tabs</h1></div></div></div><p>In this recipe, we will learn how to display multiple view controllers in a tabbed interface.<a id="id289" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UITabBarController</code> provides a way of displaying different view controllers on the same hierarchy level divided into a tab-like interface. Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> TabControllerApp</code>.<a id="id290" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>How to do it...</h2></div></div></div><p>Add two<strong> iPhone View with Controller</strong> files to the project. Name them<code class="literal"> MainController</code> and<code class="literal"> SettingsController</code>.</p><div><ol class="orderedlist"><li class="listitem"> Open both controllers in Interface Builder, and set different background colors for their views and save the documents.</li><li class="listitem"> Add the following field in the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">UITabBarController tabController;
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> FinishedLaunching()</code> method, above the<code class="literal"> window.MakeKeyAndVisible()</code>; line:<a id="id291" class="indexterm"/><div><pre class="programlisting">MainController mainController = new MainController();
SettingsController settingsController = new SettingsController();
mainController.TabBarItem.Title = "Main";
settingsController.TabBarItem.Title = "Settings";
this.tabController = new UITabBarController();
this.tabController.SetViewControllers(new UIViewController[] {
mainController,
settingsController
} , false);
window.RootViewController = this.tabController;
this.tabController.ViewControllerSelected += delegate(object sender, UITabBarSelectionEventArgs e) {
Console.WriteLine("Selected {0} controller.", e.ViewController.TabBarItem.Title);
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on each of the tabs at the bottom of the screen, and see their respective views shown. The console output is displayed in the<strong> Application Output</strong> pad in MonoDevelop. The following screenshot shows the screen of the simulator, with the<strong> Settings</strong> tab selected:<a id="id292" class="indexterm"/></li></ol></div><div><img src="img/1468EXP_03_01 .jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>How it works...</h2></div></div></div><p>The<code class="literal"> UITabBarController</code> displays one tab for each of the controllers it manages. That tab is of the type<code class="literal"> UITabBarItem,</code> and it can accept both text and images. The<code class="literal"> UITabBarController</code> class holds information about the controllers it contains. We can determine which controller was selected by the user through the<code class="literal"> ViewControllerSelected</code> event:<a id="id293" class="indexterm"/>
</p><div><pre class="programlisting">this.tabBarController.ViewControllerSelected += new EventHandler&lt;UITabBarSelectionEventArgs&gt; (delegate(object sender, UITabBarSelectionEventArgs e) {
</pre></div><p>The<code class="literal"> UITabBarSelectionEventArgs</code> object holds an instance of the selected controller in the property<code class="literal"> ViewController</code>. By accessing the<code class="literal"> UIViewController.TabBarItem</code> property, we can determine which controller was selected:<a id="id294" class="indexterm"/>
</p><div><pre class="programlisting">Console.WriteLine ("Controller {0} selected.", e.ViewController.TabBarItem.Title);
</pre></div><p>In this example, we output its<code class="literal"> Title</code> property.</p><div><h3 class="title"><a id="note26"/>Note</h3><p>Just like the<code class="literal"> UIViewController</code> class'<code class="literal"> NavigationController</code> property, where it returns the instance of the<code class="literal"> UINavigationController</code> it is part of, the<code class="literal"> TabBarItem</code> property will hold an instance only when the controller is part of a<code class="literal"> UITabBarController</code>. In other cases it will return<code class="literal"> null</code>.</p></div><p>When we initialize the tab controller, we set the controllers it will contain through the<code class="literal"> SetViewControllers</code> method, passing an array of view controller objects:<a id="id295" class="indexterm"/>
</p><div><pre class="programlisting">this.tabController.SetViewControllers(new UIViewController[] {
mainController,
settingsController
});
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>There's more...</h2></div></div></div><p>The controller can accept as many controllers as we want, but if we add six or more, four will be displayed with their tabs, while a fifth predefined<strong> More</strong> tab will represent all the remaining controllers. That is to keep the interface easily accessible by the user, by keeping the tabs to a specific size suitable for human fingers. When we add more than six controllers in a tab bar controller interface, by default the object provides an<strong> Edit</strong> button on top in the<strong> More</strong> tab, which allows the user to rearrange the order of controllers. If we want to exclude some controllers from this functionality, we have to remove it from the<code class="literal"> CustomizableViewControllers</code> array.<a id="id296" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Useful UITabBarController properties</h3></div></div></div><p>Some more useful properties of the<code class="literal"> UITabBarController</code> class are as follows:<a id="id297" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ViewControllers:</code> It returns an array containing all the controllers that the tab controller holds<a id="id298" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">SelectedIndex:</code> It returns the zero-based index of the selected tab<a id="id299" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">SelectedViewController:</code> It returns the currently selected controller<a id="id300" class="indexterm"/></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Important note on tab bar interfaces</h3></div></div></div><p>Although we can add whatever type of controllers we want in a<code class="literal"> UITabBarController</code>, we must not add a<code class="literal"> UITabBarController</code> in another controller, such as a<code class="literal"> UINavigationController</code>. We can, however, add a<code class="literal"> UINavigationController</code> in a<code class="literal"> UITabBarController</code>. This is because the tab bar interface is provided for implementing different controllers as different application modes and not hierarchical screens.<a id="id301" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using view controllers efficiently</em></li><li class="listitem" style="list-style-type: disc"><em>Combining different view controllers</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Creating a table controller</h1></div></div></div><p>In this recipe, we will learn how to create and add a<code class="literal"> UITableViewController</code> to a project.<a id="id302" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UITableViewController</code> is used to display a<code class="literal"> UITableView</code>. A<code class="literal"> UITableView</code> provides an interface for displaying data in a list form. Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> TableControllerApp</code>.<a id="id303" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add an<strong> iPhone View Controller</strong> to the project, and name it<code class="literal"> TableController</code>.</li><li class="listitem"> Add the following code in the<code class="literal"> FinishedLaunching</code> method of the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">TableController tableController = new TableController();
window.RootViewController = tableController;
</pre></div></li><li class="listitem"> Change the inheritance of the<code class="literal"> TableController</code> class from<code class="literal"> UIViewController</code> to<code class="literal"> UITableViewController:</code><div><pre class="programlisting">public partial class TableController : UITableViewController
</pre></div></li><li class="listitem"> Open the<code class="literal"> TableController.xib</code> in Interface Builder, and delete its view by selecting it and pressing backspace.<a id="id304" class="indexterm"/></li><li class="listitem"> Drag-and-drop a<code class="literal"> UITableView</code> in its place.</li><li class="listitem"> Right-click on the<code class="literal"> UITableView</code> to show the outlet panel.</li><li class="listitem"> Click-and-drag from the<strong> New Referencing Outlet</strong> to the<strong> File's Owner</strong> object, as shown in the following screenshot:<div><img src="img/1468EXP_03_02.jpg" alt="How to do it..."/></div></li><li class="listitem"> Select view from the small panel that will appear on the<strong> File's Owner</strong> object when you release the button. This connects the<code class="literal"> UITableView</code> we have just added to the<code class="literal"> view</code> outlet of the<strong> File's Owner</strong> object.</li><li class="listitem"> Save the document.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>How it works...</h2></div></div></div><p>When we add a<code class="literal"> UITableView</code> in an Interface Builder document, its view is displayed with some predefined data. The data only appears at design time and not at runtime.<a id="id305" class="indexterm"/>
</p><p>The<code class="literal"> UITableViewController</code> contains a view of the type<code class="literal"> UITableView</code>. This view is responsible for displaying the data and can be customized in many ways.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>There's more...</h2></div></div></div><p>Apart from the<code class="literal"> View</code> property, we can access the view of the<code class="literal"> UITableViewController</code> through its<code class="literal"> TableView</code> property. Both properties return the same object.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>UITableViewController-specific property</h3></div></div></div><p>The<code class="literal"> UITableViewController</code> has one more property:<code class="literal"> ClearsSelectionOnViewWillAppear</code>. When it is set to<code class="literal"> true</code>, the controller will clear the selected row automatically whenever the view appears.<a id="id306" class="indexterm"/>
</p><p>How to populate data with a<code class="literal"> UITableView</code> is discussed thoroughly in<a class="link" href="ch05.html" title="Chapter 5. Displaying Data"> Chapter 5</a>,Displaying Data.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Modal view controllers</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch05.html" title="Chapter 5. Displaying Data">Chapter 5</a>,Displaying Data:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Modal view controllers</h1></div></div></div><p>In this recipe, we will discuss how to display view controllers modally.<a id="id307" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Getting ready</h2></div></div></div><p>A<strong> Modal view controller</strong> is any controller that is presented above other views or controllers. The concept is similar to displaying a<strong> WinForm</strong> as a dialog, which takes control of the interface and does not allow access to other windows of the application, unless it is dismissed. Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> ModalControllerApp</code>.<a id="id308" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add two views with controllers to the project, and name them<code class="literal"> MainController</code> and<code class="literal"> ModalController</code>.</li><li class="listitem"> Open the<code class="literal"> MainController.xib</code> file in Interface Builder, and add a button on its view with the title<code class="literal"> Present</code>.</li><li class="listitem"> Create and connect the appropriate outlet for the button. Save the document and open the<code class="literal"> ModalController.xib</code> file.</li><li class="listitem"> Add a button on its view with the title<code class="literal"> Dismiss</code>, and create the appropriate outlet for it. Set its view's background color to something other than white.</li><li class="listitem"> Save the document and enter the following code in the<code class="literal"> MainController</code> class:<a id="id309" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
this.buttonPresent.TouchUpInside += delegate {
ModalController modal = new ModalController ();
this.PresentModalViewController (modal, true);
};
}
</pre></div></li><li class="listitem"> Similarly, override the<code class="literal"> ViewDidLoad()</code> method in the<code class="literal"> ModalController</code> class, and enter the following code in it:<a id="id310" class="indexterm"/><div><pre class="programlisting">this.buttonDismiss.TouchUpInside += delegate {
this.DismissModalViewControllerAnimated (true);
};
</pre></div></li><li class="listitem"> Finally, add code to display the main controller in the<code class="literal"> FinishedLaunching()</code> method:<div><pre class="programlisting">MainController mainController = new MainController ();
window.RootViewController = mainController;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on the<strong> Present</strong> button and watch the modal controller present itself on top of the main controller.</li><li class="listitem"> Tap on the<strong> Dismiss</strong> button to hide it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>How it works...</h2></div></div></div><p>Each controller object has two methods that handle presenting and dismissing controllers modally. In our example, we call the<code class="literal"> PresentModalViewController (UIViewController, bool)</code> method to present a controller:<a id="id311" class="indexterm"/>
</p><div><pre class="programlisting">this.buttonPresent.TouchUpInside += delegate {
ModalController modal = new ModalController ();
this.PresentModalViewController (modal, true);
};
</pre></div><p>Its first parameter represents the controller we want to display modally, and the second parameter determines if we want the presentation to be animated. To dismiss the controller, we call its<code class="literal"> DismissModalViewControllerAnimated(bool)</code> method:<a id="id312" class="indexterm"/>
</p><div><pre class="programlisting">this.DismissModalViewControllerAnimated (true);
</pre></div><p>It accepts only one parameter that toggles the animation for the dismissal.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>There's more...</h2></div></div></div><p>We can define the type of animation for a modal view controller presentation with the controller's<code class="literal"> ModalTransitionStyle</code> property. Enter the following line of code before presenting the modal controller:<a id="id313" class="indexterm"/>
</p><div><pre class="programlisting">modal.ModalTransitionStyle = UIModalTransitionStyle.FlipHorizontal;
</pre></div><p>The main controller will flip to present the modal controller, giving the impression it is attached behind it.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Accessing a modal controller</h3></div></div></div><p>Each controller that presents another controller modally provides access to its "child" controller through the<code class="literal"> ModalController</code> property. If you need to access this property, make sure to do it before the<code class="literal"> DismissModalViewControllerAnimated()</code> method is called.<a id="id314" class="indexterm"/>
</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec01"/>How many modal controllers?</h4></div></div></div><p>In theory, we can present an unlimited number of modal controllers. Of course, there are two restrictions on this:<a id="id315" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><strong> Memory is not unlimited:</strong> View controllers consume memory, so the more view controllers we present, the worse performance we get.</li><li class="listitem"><strong> Bad user experience:</strong> Presenting many controllers modally discomforts the user with repetition.</li></ol></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Navigating through different view controllers</em></li><li class="listitem" style="list-style-type: disc"><em>Providing controllers in tabs</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch11.html" title="Chapter 11. Graphics and Animation">Chapter 11</a>,Graphics and Animation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Pushing view controllers with animation</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec08"/>Creating a custom view controller</h1></div></div></div><p>In this recipe, we will learn how to create a subclass of<code class="literal"> UIViewController</code> and use it to derive view controllers contained in an<code class="literal"> XIB</code> file.<a id="id316" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Getting ready</h2></div></div></div><p>In this task, we will see how to create a custom view controller that will act as a base controller, providing common functionality among its inheritors. The functionality we will add to our base controller to share with its inheritor classes will be to output the current touch position in the<strong> Application Output</strong> pad in MonoDevelop. Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> CustomControllerApp</code>.<a id="id317" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a new empty C# class in the project, and name it BaseController.</li><li class="listitem"> Enter the following code in the BaseController.cs file:<a id="id318" class="indexterm"/><div><pre class="programlisting">using System;
using System.Drawing;
using MonoTouch.Foundation;
using MonoTouch.UIKit;
public class BaseController : UIViewController{
//Constructors
public BaseController (string nibName, NSBundle bundle) : base(nibName, bundle){}
public override void TouchesMoved (NSSet touches, UIEvent evt){
base.TouchesMoved (touches, evt);
// Capture the position of touches
UITouch touch = (UITouch)touches.AnyObject;
PointF locationInView = touch.LocationInView (this.View);
Console.WriteLine ("Touch position: {0}", locationInView);
}
}
</pre></div></li><li class="listitem"> Now, add an<strong> iPhone View with Controller</strong> file to the project, and name it<code class="literal"> DerivedController</code>.</li><li class="listitem"> Change the class it inherits from<code class="literal"> UIViewController</code> to<code class="literal"> BaseController</code> in its class definition:<code class="literal"> public partial class DerivedController : BaseController</code>.</li><li class="listitem"> Finally, add the derived controller's view to the main window:<div><pre class="programlisting">DerivedController derivedController = new DerivedController();
window. RootViewController = derivedController;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Click-and-drag the mouse pointer on the white surface, and watch MonoDevelop's<strong> Application Output</strong> pad displaying the current position of the pointer on the simulator's screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>How it works...</h2></div></div></div><p>What we have done here is create a base controller class that can be used in multiple MonoTouch projects. The functionality we have added to this controller is to respond to user touches. Any controller that inherits it will inherit the same functionality. The code we have added to create the<code class="literal"> BaseController</code> class is fairly simple. The constructor we implemented is merely a copy of the constructors that MonoDevelop creates in the class implementations when we add new view controllers in a project. There is only one slight modification:<a id="id319" class="indexterm"/>
</p><div><pre class="programlisting">public BaseController (string nibName, NSBundle bundle) : base(nibName, bundle){}
</pre></div><p>This is the base constructor that will get called when we initialize the<code class="literal"> DerivedController</code> class with the<code class="literal"> new</code> keyword through our derived object's<code class="literal"> DerivedController()</code> constructor.<a id="id320" class="indexterm"/>
</p><div><pre class="programlisting">derivedController = new DerivedController();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>There's more...</h2></div></div></div><p>The derived controller can also be added to another<code class="literal"> XIB</code> file and used directly in code through outlets.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Subclassing view controllers from XIBs</h3></div></div></div><p>If we would like to create a base controller that derives from a controller contained in an<code class="literal"> XIB</code> file, the process is similar.<a id="id321" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Loading a view with a controller</em></li><li class="listitem" style="list-style-type: disc"><em>Using view controllers efficiently</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>,User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Using view controllers efficiently</h1></div></div></div><p>In this recipe, we will learn about the basic guidelines on efficient view controller usage.<a id="id322" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Getting ready</h2></div></div></div><p>Open the project<code class="literal"> TabControllerApp</code> we created in the recipe<em> Providing controllers in tabs</em> earlier in this chapter.<a id="id323" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> MainController.xib</code> file in Interface Builder, and add a<code class="literal"> UIButton</code> and a<code class="literal"> UILabel</code>. Connect them with outlets.</li><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private Dictionary&lt;int, string&gt; cacheList;
private Dictionary&lt;int, string&gt; cacheList;
public override void DidReceiveMemoryWarning (){
// Releases the view if it doesn't have a superview.
base.DidReceiveMemoryWarning ();
Console.WriteLine("Will clear cache in DidReceiveMemoryWarning...");
// Release any cached data, images, and so on that aren't in use.
this.cacheList.Clear();
}
public override void ViewDidLoad (){
base.ViewDidLoad ();
//any additional setup after loading the view, typically from a nib.
this.cacheList = new Dictionary&lt;int, string&gt;() {
{ 0, "One" },
{ 1, "Two" },
{ 2, "Three" }
} ;
this.btnShowData.TouchUpInside += ButtonShowData_TouchUpInside;
}
public override void ViewDidUnload (){
base.ViewDidUnload ();
// Release any retained subviews of the main view.
// e.g. myOutlet = null;
this.lblOutput = null;
this.btnShowData.TouchUpInside -= ButtonShowData_TouchUpInside;
this.btnShowData = null;
}
private void ButtonShowData_TouchUpInside (object sender, EventArgs e){
foreach (KeyValuePair&lt;int, string&gt; eachItem in this.cacheList){
this.lblOutput.Text += string.Format("Key: {0} - Value: {1}", eachItem.Key, eachItem.Value);
}//end foreach
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on the button in the<strong> Main</strong> tab to display the contents of our list.</li><li class="listitem"> Switch to the<strong> Settings</strong> tab.</li><li class="listitem"> Click<strong> Hardware | Simulate Memory Warning</strong> in the menu bar of the simulator.</li><li class="listitem"> Watch the output in the<strong> Application Output</strong> of MainDevelop, and switch back to the<strong> Main</strong> tab.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>How it works...</h2></div></div></div><p>This project does not provide any useful functionality. Its main purpose is to show how to use view controllers properly.<a id="id324" class="indexterm"/>
</p><p>When iOS needs more memory to perform various operations, it issues memory warnings. When a memory warning occurs, all UI objects that are handled by a controller and are not in use are purged from memory to free up more memory.</p><p>The simulator provides a way for developers to recreate such a scenario, with the<strong> Hardware | Simulate Memory Warning</strong> action we selected from the menu bar.</p><p>Since we were in the<strong> Settings</strong> tab, the contents of the<code class="literal"> MainController</code> were purged from memory. Inside the<code class="literal"> DidReceiveMemoryWarning</code> method, we clean up any non-UI objects, which otherwise would remain in memory:<a id="id325" class="indexterm"/>
</p><div><pre class="programlisting">this.cacheList.Clear();
</pre></div><p>Next, in the<code class="literal"> ViewDidUnload</code> method, we only need to release any UI objects that are retained by outlets. Note that this is where we unhook any handlers from events these objects might hold:<a id="id326" class="indexterm"/>
</p><div><pre class="programlisting">this.lblOutput = null;
this.btnShowData.TouchUpInside -= ButtonShowData_TouchUpInside;
this.btnShowData = null;
</pre></div><p>When we select the<strong> Main</strong> tab again, the<code class="literal"> ViewDidLoad</code> method will be called once more, after the view of the controller and all views and outlets it contains are loaded.<a id="id327" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>There's more...</h2></div></div></div><p>When a memory warning occurs, instances of objects not related directly with the UI will remain in memory. In rare cases when there is not enough memory for specific tasks, the operating system might terminate our application if it occupies much of the available memory. To prevent such situations, we need to be careful to clean up all the objects and resources that are not needed, freeing up more memory for iOS.</p><div><h3 class="title"><a id="note27"/>Note</h3><p>Never access a controller's view inside the<code class="literal"> ViewDidUnload</code> method:</p><div><pre class="programlisting">public override ViewDidUnload()
{
base.ViewDidUnload();
this.View = null; // Never do this.
}
</pre></div><p>That is because even when we request the return value of a view controller's<code class="literal"> View</code> property, it causes the view to be loaded again, which in most cases will mean that no memory will be released.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Providing controllers in tabs</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>,Development Tools:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Interface builder</em></li></ul></div><p>
<a class="link" href="ch04.html" title="Chapter 4. Data Management">Chapter 4</a>,</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating files</em></li><li class="listitem" style="list-style-type: disc"><em>Creating an SQLite database</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec10"/>Combining different view controllers</h1></div></div></div><p>In this recipe, we will learn how to display a<code class="literal"> UINavigationController</code> within a<code class="literal"> UITabBarController</code>.<a id="id328" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Getting ready</h2></div></div></div><p>Create a new iPhone empty project in MonoDevelop, and name it<code class="literal"> CombinedControllerApp</code>.<a id="id329" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>How to do it...</h2></div></div></div><p>These are the steps to create this project:</p><div><ol class="orderedlist"><li class="listitem"> Add three iPhone View Controller files to the project, and name them<code class="literal"> MainController, SettingsController</code>, and<code class="literal"> AfterMainController</code>.<a id="id330" class="indexterm"/></li><li class="listitem"> Add a<code class="literal"> UIButton</code> on the view of<code class="literal"> MainController</code> in Interface Builder, and save the document.</li><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.Title = "Main";
this.buttonPush.TouchUpInside += delegate {
this.NavigationController.PushViewController(new AfterMainController(), true);
};
}
</pre></div></li><li class="listitem"> Add the following fields in the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">UINavigationController navController;
UITabBarController tabController;
</pre></div></li><li class="listitem"> Add the following code in the<code class="literal"> FinishedLaunching</code> method of the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">MainController mainController = new MainController();
SettingsController settingsController = new SettingsController();
this.tabController = new UITabBarController();
this.navController = new UINavigationController(mainController);
this.tabController.SetViewControllers(new UIViewController[] {
this.navController,
settingsController
} , false);
navController.TabBarItem.Title = "Main";
settingsController.TabBarItem.Title = "Settings";
window.RootViewController = this.tabController;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. Tap the button in the<code class="literal"> MainController</code> to push the<code class="literal"> AfterMainController</code> in the navigation stack, and then switch between the<strong> Main</strong> and<strong> Settings</strong> tabs.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>How it works...</h2></div></div></div><p>The complete solution can be found in the<code class="literal"> CombinedControllerApp</code> folder. What we have managed to do with this project is to provide a user interface with three different screens, which is not confusing for the user.<a id="id331" class="indexterm"/>
</p><p>The tab bar contains two system-defined items, each representing a different view controller. We implemented the first item in the tab bar controller with a navigation controller. This way, we can provide more screens that are related with a specific part of our application (<strong>Main</strong> plus<strong> AfterMain)</strong>, leaving another part of our application directly accessible at any time <strong>(Settings)</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>There's more...</h2></div></div></div><p>The way this project combines three different controllers (a<code class="literal"> UITabBarController</code>, a<code class="literal"> UINavigationController</code>, and a<code class="literal"> UIViewController)</code> is perfectly acceptable. We could even replace the second tab item with another navigation controller to provide even more screens for another section of the application, or even add another tab item.</p><p>However, as stated in the<em> Providing controllers in tabs</em> recipe in this chapter, it would not be acceptable if we added a<code class="literal"> UITabBarController</code> inside a<code class="literal"> UINavigationController</code>. If we want to provide tab-like behavior inside a navigation controller, we should use its<code class="literal"> UIToolbar</code> to do so.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Navigating through different view controllers</em></li><li class="listitem" style="list-style-type: disc"><em>Providing controllers in tabs</em></li><li class="listitem" style="list-style-type: disc"><em>Creating a user interface for different devices</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec11"/>iPad view controllers</h1></div></div></div><p>In this recipe, we will discuss the controllers that are only available to the iPad.<a id="id332" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Getting ready</h2></div></div></div><p>Create a new iPad empty project, and name it<code class="literal"> iPadControllerApp</code>.<a id="id333" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add two iPad views with controllers to the project, and name them<code class="literal"> FirstController</code> and<code class="literal"> SecondController</code>. Set different colors for their background views. In<code class="literal"> SecondController</code>, also add a<code class="literal"> UIToolbar</code> on the top of its view, and connect it to an outlet.<a id="id334" class="indexterm"/></li><li class="listitem"> Add the following fields in the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">UISplitViewController splitController;
FirstController firstController;
SecondController secondController;
</pre></div><div><h3 class="title">Note</h3><p>The<code class="literal"> UISplitViewController</code> class is available only to the iPad.</p></div></li><li class="listitem"> Add the following code in the<code class="literal"> FinishedLaunching</code> method:<div><pre class="programlisting">this.firstController = new FirstController();
this.secondController = new SecondController();
this.splitController = new UISplitViewController();
this.splitController.ViewControllers = new UIViewController[] {
this.firstController,
this.secondController
} ;
this.splitController.Delegate = new SplitControllerDelegate(this.secondController);
window.RootViewController = this.splitController;
</pre></div></li><li class="listitem"> Add the following nested class in<code class="literal"> AppDelegate:</code><div><pre class="programlisting">private class SplitControllerDelegate : UISplitViewControllerDelegate{
public SplitControllerDelegate (SecondController controller){
this.parentController = controller;
}//end ctor
private SecondController parentController;
public override void WillHideViewController ( UISplitViewController svc, UIViewController aViewController, UIBarButtonItem barButtonItem, UIPopoverController pc){
barButtonItem.Title = "First";
this.parentController.SecToolbar.SetItems (new UIBarButtonItem[] { barButtonItem }, true);
}
public override void WillShowViewController ( UISplitViewController svc, UIViewController aViewController, UIBarButtonItem button){
this.parentController.SecToolbar.SetItems (new UIBarButtonItem[0], true);
}
}
</pre></div></li><li class="listitem"> Add a property in the<code class="literal"> SecondController</code> class, which returns the toolbar outlet that we created in<em> step 1:</em><a id="id335" class="indexterm"/><div><pre class="programlisting">public UIToolbar SecToolbar{
get { return this.secToolbar; }
}
</pre></div></li><li class="listitem"> Finally, compile and run the application in the simulator. Tap on the button in the toolbar to make the<code class="literal"> FirstController</code> appear. The result should be similar to the following screenshot:</li></ol></div><div><img src="img/1468EXP_03_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>How it works...</h2></div></div></div><p>The complete solution can be found in the<code class="literal"> iPadControllerApp</code> folder. There are two iPad-specific controllers:<code class="literal"> UISplitViewController</code> and<code class="literal"> UIPopoverController</code>. Both of them are being used here, although the<code class="literal"> UIPopoverController</code> is not used directly.<a id="id336" class="indexterm"/>
</p><p>The<code class="literal"> UISplitViewController</code> helps to take full advantage of the iPad's larger screen. It provides a way of displaying two different views simultaneously on the same screen area. It does this by displaying one controller in full-screen in portrait orientation and the other controller smaller, in a popover. A<strong> popover</strong> is basically a view, which is displayed on top of other controllers (and their views), much like a modal view controller.<a id="id337" class="indexterm"/>
</p><p>To provide access to both controllers in our project to the user, we have implemented a class that inherits from<code class="literal"> UISpliViewControllerDelegate</code> and assigned it to our split controller inside the<code class="literal"> FinishedLaunching()</code> method. The<code class="literal"> Delegate</code> object we created overrides two methods. In the first method, we assign a button to the toolbar:<a id="id338" class="indexterm"/>
</p><div><pre class="programlisting">public override void WillHideViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem barButtonItem, UIPopoverController pc){
barButtonItem.Title = "First";
this.parentController.SecToolbar.SetItems (new UIBarButtonItem[] { barButtonItem }, true);
}
</pre></div><p>The<code class="literal"> WillHideViewController()</code> method is executed whenever the<code class="literal"> UISplitViewController</code> changes orientation from landscape to portrait, and its smaller controller is about to be hidden. So, to display it, we provide a button on the full-screen controller's toolbar. When we tap on that button, the other controller will appear in a popover. When the orientation changes from portrait to landscape, the smaller controller appears besides the larger controller, without the need for a popover. So, we no longer need the button on the toolbar, hence we override the<code class="literal"> WillShowViewController</code> to remove the button from the toolbar. We do this by assigning an empty<code class="literal"> UIBarButtonItem[]</code> array:<a id="id339" class="indexterm"/>
</p><div><pre class="programlisting">public override void WillShowViewController (UISplitViewController svc, UIViewController aViewController, UIBarButtonItem button){
this.parentController.SecToolbar.SetItems (new UIBarButtonItem[0], true);
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>There's more...</h2></div></div></div><p>When the device rotates, the interface does not respond automatically. To instruct the view controller to rotate its views, we override the<code class="literal"> ShouldAutorotateToInterface Orientation(UIInterfaceOrientation)</code> method<strong> in both the controllers of the split view controller:</strong>
<a id="id340" class="indexterm"/>
</p><div><pre class="programlisting">public bool ShouldAutorotateToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation){
return true;
}
</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>iPad-specific controller usage</h3></div></div></div><p>Although all other controllers are available to both the iPhone and the iPad, these two controllers cannot be used on the iPhone. An exception will occur in this case.<a id="id341" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a user interface for different devices</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch09.html" title="Chapter 9. Interacting with Device Hardware">Chapter 9</a>, Interacting with Device Hardware:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Rotating the device</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec12"/>Creating a user interface for different devices</h1></div></div></div><p>In this recipe, we will learn how to create an application that will support both the iPhone and the iPad.<a id="id342" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Getting ready</h2></div></div></div><p>Create a new Universal empty project in MonoDevelop, and name it<code class="literal"> UniversalApp</code>.<a id="id343" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a new<strong> iPhone View Controller</strong> to the project, and name it<code class="literal"> MainController</code>.</li><li class="listitem"> Open it in Interface Builder, and add a label and an outlet for it on the view.</li><li class="listitem"> Enter the text<code class="literal"> Running on an iPhone!</code> in the label.</li><li class="listitem"> Change the background of the view to a color other than white. Do the same for the label, and save the document.</li><li class="listitem"> Add the following code in the<code class="literal"> MainViewController</code> class:<a id="id344" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
if (UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Pad){
this.View.Frame = new RectangleF (0f, 0f, 768f, 1024f);
this.labelMessage.Text = "Running on an iPad!";
}
}
</pre></div></li><li class="listitem"> Add the following code in the<code class="literal"> FinishedLaunching()</code> in the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">MainController mainController = new MainController();
window.RootViewController = mainController;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Read the message of the label, stating that it is running on an iPhone. Terminate the execution in MonoDevelop, and click on<strong> Run | Run With | iPad Simulator x.x</strong> (where<strong> x.x</strong> is the corresponding iOS version installed on the system, here<strong> 5.0)</strong> on the menu bar.<div><img src="img/1468EXP_03_04.jpg" alt="How to do it..."/></div></li><li class="listitem"> Read the message stating that the application is running on an iPad!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>How it works...</h2></div></div></div><p>When we create a universal project in MonoDevelop, the basic difference lies in the application settings file <code class="literal">(Info.plist)
</code>, where the application is declared to support both the iPhone and the iPad.</p><p>The fact that we have added an<strong> iPhone View with Controller</strong> does not prevent us from using the same controller for both devices. Remember, all controllers are available for all devices, except for the ones discussed in the previous recipe.</p><p>Inside the<code class="literal"> ViewDidLoad</code> method, we check which device the application is running on, by checking the<code class="literal"> UserInterfaceIdiom</code> property of the<code class="literal"> UIDevice.CurrentDevice</code> static property, and provide a frame for the view that is sized to the iPad screen's dimensions {768, 1024}.<a id="id345" class="indexterm"/>
</p><div><pre class="programlisting">if (UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Pad)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>There's more...</h2></div></div></div><p>This takes care of sizing the views contained in a project according to which device the application is running on. But, it does not guarantee that all the controls will be sized and positioned correctly. To avoid cluttered user interfaces, we have to make sure to adjust the<code class="literal"> Autosizing</code> property of our controls and views so that they will be resized and positioned correctly on different screens.<a id="id346" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using view controllers efficiently</em></li><li class="listitem" style="list-style-type: disc"><em>iPad view controllers</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>
, Development Tools:
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating an iPhone project with MonoDevelop</em></li><li class="listitem" style="list-style-type: disc"><em>Interface builder</em></li></ul></div></div></div></body></html>