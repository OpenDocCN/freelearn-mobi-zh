<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Implementing Tetris Logic and Functionality</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Tetris Logic and Functionality</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In the previous chapter, we embarked on the development of the classic game <em>Tetris</em>. We determined the layout requirements of our application and implemented the layout elements we identified. In the process, we created two activities for the application: <kbd>MainActivity</kbd> and <kbd>GameActivity</kbd>. We also implemented the basic characteristics and behaviors of the views, but nothing pertaining to the core gameplay of the app was done. In this chapter, we are going to implement this gameplay. Over the course of this chapter, you will learn about the following topics:</span></p>
<ul>
<li class="li1"><span class="s1">Exception handling</span></li>
<li class="li1"><span class="s1">The Model-View-Presenter pattern</span></li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the Tetris gameplay</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As we are concerned with implementing gameplay, the activity that we will focus on developing further in this chapter is <kbd>GameActivity</kbd>. The following screenshot shows the final product of all the development done in this chapter:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/e6aba391-1b5b-4a5f-afb3-2d658b51b417.jpg" style="width:19.75em;height:35.33em;"/></div>
<div>
<p class="p1"><span class="s1">Now that we have an idea of what the final game is going to look like, let's get going with its development.</span></p>
</div>
<div>
<p class="p1"><span class="s1">Under the section <em>Understanding Tetris</em> in <a href="kt-prog-ex_ch02.html">Chapter 2</a>,&#160;<em>Building an Android Application – Tetris</em> we got to understand that Tetris is a puzzle-matching game that makes use of tiles. These tiles combine to form bigger shapes called tetrominoes. As a reminder, a tetromino is a geometric shape composed of four squares connected orthogonally.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modeling a tetromino</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As tetrominoes are very crucial to the gameplay of Tetris, we must properly model these elements programmatically. In order to do this, let's think of every tetromino piece as a building block. Building blocks have a set of features that they possess. These features can be categorized into characteristics and behaviors.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Characteristics of a block</h1>
                </header>
            
            <article>
                
<p>The following are some characteristics that a block possesses:</p>
<ul class="ol1">
<li class="li1"><span class="s1"><strong>Shape</strong>: A block has a fixed shape that cannot be changed.</span></li>
<li class="li1"><span class="s1"><strong>Dimensions</strong>: A block possesses dimensional characteristics. These characteristics are height and width.</span></li>
<li class="li1"><span class="s1"><strong>Color</strong>: A block always possesses a color. The color a block possesses is fixed and is maintained throughout the course of its existence.</span></li>
<li class="li1"><span class="s1"><strong>Spatial characteristic</strong>: A block takes up a fixed amount of space.</span></li>
<li class="li1"><span class="s1"><strong>Positional characteristic</strong>: At any given point in time, a block has a position that exists in along two axes, – <em>X</em> and <em>Y</em>.</span></li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Behaviors of a block</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The main behavior of a block is its ability to experience distinct motions. These motions are translational motion and rotational motion. Translational motion is a type of motion in which a body shifts from one point in space to another. In Tetris, a block can experience leftward, rightward, and downward translational motions. Rotational motion is a type of motion that exists in rigid bodies and follows a curved path. In other words, rotational motion involves the rotation of an object in free space. All blocks in Tetris can be rotated.</span></p>
<p class="p1"><span class="s1">Now that we understand the basic characteristics and behaviors of a block, you may be wondering how we can translate them to be relevant to tetrominoes. The truth is no translation of these characteristic features is necessary. All characteristics of a block apply to a tetromino. The only two things to keep in mind are:</span></p>
<ul>
<li class="li1"><span class="s1">Tetrominoes are made up of four tiles</span></li>
<li class="li1"><span class="s1">All tiles in a tetromino are orthogonally arranged</span></li>
</ul>
<p class="p1"><span class="s1">Having said that, let's get to translating these characteristics into programmatic models. We will start with modeling shape.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modeling block shape</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The approach used to modeling shape varies depending on numerous variables, such as the kind of shape that must be measured and in what spacial dimension the shape is to be modeled. Modeling three-dimensional shapes—all things being equal—is more difficult than modeling two-dimensional shapes. Lucky for us, tetrominoes are two-dimensional in nature. Before we start modeling our shapes programmatically, it is important we know the exact shapes we are attempting to model. There are seven fundamental tetromino pieces that exist in Tetris. These pieces are the O, I, T<span>, L, J, S and Z tetrominos.&#160;</span></span><span class="s1">The following image shows the fundamental tetromino shapes that exist in Tetris:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/6c708a0f-28ff-409d-afa6-0cb42c2882e2.jpg" style="width:23.75em;height:19.83em;"/></div>
<p>All preceding shapes take up space within the confines of their edges. The area of space covered by a shape can be seen as an outline or a frame. This is similar to how a picture is held within a frame. We need to model this frame that will contain individual shapes. As the shapes being held within the frame are two-dimensional in nature, we will utilize a two-dimensional byte array to hold frame-specific information. A byte is a digital unit of information that generally consists of eight bits. A bit is a binary digit. It is the smallest unit of data in a computer and has a value of either 1 or 0.</p>
<p>The idea is to model the frame of a shape with a two-dimensional array by representing areas covered by the frame with a byte value of 1 and those not covered by it with a value of 0.&#160;Take the following frame, for example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/72cbf058-414b-432d-ae4c-4c861b69d2aa.jpg" style="width:10.75em;height:8.08em;"/></div>
<p class="p1"><span class="s1">Instead of visualizing it as a whole shape, we can visualize it as a two-dimensional array of bytes possessing two rows and three columns:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/cf833d5a-b988-4f3e-985e-eb02c07a211c.jpg" style="width:11.17em;height:8.17em;"/></div>
<p class="p1"><span class="s1">A byte value of 1 is assigned to cells in the array that make up the frame's shape. On the other hand, a byte value of 0 is assigned to cells that are not part of the frame's shape. Modeling this with a class is fairly easy. Firstly, we will need a function that generates the required byte array structure we will use for storing frame bytes. Create a new package within your source package and give it the name <kbd>helpers</kbd>. Within this package, create a&#160;<kbd>HelperFunctions.kt</kbd>&#160;file. This file will contain all helper functions used in the course of the development of this app. Open <kbd>HelperFunctions.kt</kbd> and type the following code into the file:</span></p>
<pre><span>package </span>com.mydomain.tetris.helpers<br/><br/><span>fun </span>array2dOfByte(sizeOuter: Int, <span>sizeInner</span>: Int): Array&lt;ByteArray&gt;<br/>        = Array(sizeOuter) <span>{ </span>ByteArray(<span>sizeInner</span>) <span>}</span></pre>
<p class="p1"><span class="s1">The preceding code defines a&#160;<kbd>array2dOfByte()</kbd>&#160;function, which takes two arguments. The first argument is the desired row number of the array to be generated and the second is the desired column number of the generated byte array. The&#160;<kbd>array2dOFByte()</kbd>&#160;method generates and returns a new array with the specified properties. Now that we have our byte array generating helper function set up, let's go ahead and create the <kbd>Frame</kbd> class. Create a new package within your source package and give it the name <kbd>models</kbd>. All object models will be packaged within this created package. Within the <kbd>models</kbd> package, create a <kbd>Frame</kbd> class in the&#160;<kbd>Frame.kt</kbd>&#160;file and type the following code into the file:</span></p>
<pre><span>package </span>com.mydomain.tetris.models<br/><br/><span>import </span>com.mydomain.tetris.helpers.array2dOfByte<br/><br/><span>class </span>Frame(<span>private val </span><span>width</span>: Int) {<br/>  <span>val </span><span>data</span>: ArrayList&lt;ByteArray&gt; = ArrayList()<br/><br/>  <span>fun </span>addRow(byteStr: String): Frame {<br/>    <span>val </span>row = ByteArray(byteStr.<span>length</span>)<br/><br/>    <span>for </span>(index <span>in </span>byteStr.<span>indices</span>) {<br/>      row[index] = <span>"</span><span>${</span>byteStr[index]<span>}</span><span>"</span>.<span>toByte</span>()<br/>    }<br/>    <span>data</span>.add(row)<br/>    <span>return this<br/></span><span>  </span>}<br/><br/>  <span>fun </span>as2dByteArray(): Array&lt;ByteArray&gt; {<br/>    <span>val </span>bytes = <span>array2dOfByte</span>(<span>data</span>.<span>size</span>, <span>width</span>)<br/>    <span>return </span><span>data</span>.toArray(bytes)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>Frame</kbd> class has two properties: <kbd>width</kbd> and <kbd>data</kbd>. Width is an integer property that holds the desired width of the frame to be generated (the number of columns in the frame's byte array).&#160;</span><span class="s1">The data property holds an array list of elements in the <kbd>ByteArray</kbd> value space. We declare two distinct functions, <kbd>addRow()</kbd> and <kbd>get()</kbd>. <kbd>addRow()</kbd> takes a string, converts each individual character of the string into a byte representation, and adds the byte representation into a byte array, after which it adds the byte array to the data list. <kbd>get()</kbd> converts the data array list into a byte array and returns the array.</span></p>
<p class="p1"><span class="s1">Having modeled a suitable frame to hold our block, we can go ahead and model the distinct shapes of possible tetrominoes in the game. In order to do this, we will make use of an <kbd>enum</kbd> class.<span class="Apple-converted-space">&#160;</span> Create a <kbd>Shape.kt</kbd> file in the models package before proceeding. We will start by modeling the following simple tetromino shape:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/18286cf8-7f71-4e2f-9bf2-7288fa033d5b.jpg" style="width:4.33em;height:10.83em;"/></div>
<div>
<p class="p1"><span class="s1">Applying the concept of envisioning frames as a two-dimensional array of bytes, we can envision the frame of the preceding shape as a two-dimensional array of bytes with four rows and a single column with each cell filled with the byte value of <kbd>1</kbd>. With this in mind, let's model the shape. In <kbd>Shape.kt</kbd>, create a <kbd>Shape</kbd> enum class, as shown in the following code:</span></p>
</div>
<pre class="p1"><span class="s1">enum class Shape(val frameCount: Int, val startPosition: Int) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>Tetromino(2, 2) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>override fun getFrame(frameNumber: Int): Frame {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>return when (frameNumber) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>0 -&gt; Frame(4).addRow("1111")<br/></span><span class="s1"><span class="Apple-converted-space">        </span>1 -&gt; Frame(1)<br/></span><span class="s1"><span class="Apple-converted-space">                     </span>.addRow("1")<br/></span><span class="s1"><span class="Apple-converted-space">                     </span>.addRow("1")<br/></span><span class="s1"><span class="Apple-converted-space">                     </span>.addRow("1")<br/></span><span class="s1"><span class="Apple-converted-space">                     </span>.addRow("1")<br/></span><span class="s1"><span class="Apple-converted-space">        </span>else -&gt; throw IllegalArgumentException("$frameNumber is an invalid <br/>                                                frame number.")<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>};<br/></span><span class="s1"><span class="Apple-converted-space">  </span>abstract fun getFrame(frameNumber: Int): Frame<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">An <kbd>enum</kbd> class is declared by placing the <kbd>enum</kbd> keyword before the <kbd>class</kbd> keyword. The primary constructor of the preceding&#160;<kbd>Shape</kbd> enum class takes two arguments. The first argument is <kbd>frameCount</kbd>, which is an integer variable that specifies the number of possible frames a shape can be in. The second argument is <kbd>startPosition</kbd>, which specifies the intended start position of the shape along the <em>X</em> axis within the gameplay field. Further down the <kbd>enum</kbd> class file, a <kbd>getFrame()</kbd> function is declared. There's a notable difference between this function and the functions we have declared until now. <kbd>getFrame()</kbd> has been declared with the abstract keyword. An abstract function possesses no implementation (thus no body) and is used to abstract a behavior that must be implemented by an extending class. Let's scrutinize the following lines of code within the <kbd>enum</kbd> class:</span></p>
<pre><span>Tetromino</span>(<span>2</span>, <span>2</span>) {<br/>  <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>    <span>return when </span>(frameNumber) {<br/>      <span>0 </span>-&gt; Frame(<span>4</span>).addRow(<span>"1111"</span>)<br/>      <span>1 </span>-&gt; Frame(<span>1</span>)<br/>                   .addRow(<span>"1"</span>)<br/>                   .addRow(<span>"1"</span>)<br/>                   .addRow(<span>"1"</span>)<br/>                   .addRow(<span>"1"</span>)<br/>      <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is an invalid<br/>                                              frame number."</span>)<br/>    }<br/>  }<br/>};</pre>
<p class="p1"><span class="s1">In the preceding code block, an instance of the <kbd>enum</kbd> that provides an implementation of the declared abstract function is being created. The instance's identifier is <kbd>Tetromino</kbd>. We passed the integer value <kbd>2</kbd> as the argument for both the <kbd>frameCount</kbd> and <kbd>startPosition</kbd> properties of the&#160;<kbd>Tetromino</kbd>'s constructor. In addition, <kbd>Tetromino</kbd><span class="Apple-converted-space">&#160;</span>provides an implementation for the <kbd>getFrame()</kbd> function in its corresponding block by overriding the <kbd>getFrame()</kbd> function declared in <kbd>Shape</kbd>. Functions are overriden with the <kbd>override</kbd> keyword. The implementation of <kbd>getFrame()</kbd> in <kbd>Tetromino</kbd> takes a&#160;<kbd>frameNumber</kbd>&#160;integer. This frame number determines the frame of <kbd>Tetromino</kbd> that will be returned. You may be asking at this point why <kbd>Tetromino</kbd> possesses more than one frame. This is simply a result of the possibility of rotation of a tetromino. The single-column tetromino we previously looked at can be rotated either leftwards or rightwards to take the form shown in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5004bafa-4a1f-4859-9f68-379817672dfe.jpg" style="width:11.50em;height:4.67em;"/></div>
<p><span>When <kbd>frameNumber</kbd> passed to <kbd>getFrame()</kbd> is <kbd>0</kbd>, <kbd>getFrame()</kbd> returns a <kbd>Frame</kbd> object that models the frame for the <kbd>Tetromino</kbd> in its horizontal state, as shown earlier. When <kbd>frameNumber</kbd> is <kbd>1</kbd>, it returns a frame object modeling the shape in its vertical state.&#160;</span></p>
<p class="p1"><span class="s1">In the case that <kbd>frameNumber</kbd> is neither <kbd>0</kbd> nor <kbd>1</kbd>, an <kbd>IllegalArgumentException</kbd> is thrown by the function.</span></p>
<div class="packt_infobox">
<p class="p1"><span class="s1">It is important to note that along with being an object, <kbd>Tetromino</kbd> is a constant. Generally, <kbd>enum</kbd> classes are used to create constants. An <kbd>enum</kbd> class is a perfect choice for modeling our tetromino shapes because we have a fixed set of shapes that we need to implement.</span></p>
</div>
<p>Having understood how the <kbd>Shape</kbd> enum class works, we can model the rest of the possible tetromino shapes as shown in the following code block:</p>
<pre><span>enum class </span>Shape(<span>val </span><span>frameCount</span>: Int, <span>val </span><span>startPosition</span>: Int) {</pre>
<p>Let's create a tetromino shape with one frame and a start position of 1. The tetromino modeled here is the square or 'O' shaped tetromino.</p>
<pre><span>Tetromino1</span>(<span>1</span>, <span>1</span>) {<br/>    <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>      <span>return </span>Frame(<span>2</span>)<br/>             .addRow(<span>"11"</span>)<br/>             .addRow(<span>"11"</span>)<br/>    }<br/>  },</pre>
<p><span>Let's create&#160;a&#160;</span>tetromino shape with two frames and a start position of 1. The tetromino modeled here is the 'Z' shaped tetromino.</p>
<pre>  <span>Tetromino2</span>(<span>2</span>, <span>1</span>) {<br/>    <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>      <span>return when </span>(frameNumber) {<br/>        <span>0 </span>-&gt; Frame(<span>3</span>)<br/>                   .addRow(<span>"110"</span>)<br/>                   .addRow(<span>"011"</span>)<br/>        <span>1 </span>-&gt; Frame(<span>2</span>)<br/>                   .addRow(<span>"01"</span>)<br/>                   .addRow(<span>"11"</span>)<br/>                   .addRow(<span>"10"</span>)<br/>        <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is an invalid <br/>                                                frame number."</span>)<br/>        }<br/>      }<br/>    },<br/>  </pre>
<p><span>Let's create&#160;a&#160;</span>tetromino shape with two frames&#160;and a start position of <kbd>1</kbd>. The tetromino modeled here is the 'S' shaped tetromino.</p>
<pre>    <span>Tetromino3</span>(<span>2</span>, <span>1</span>) {<br/>      <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>        <span>return when </span>(frameNumber) {<br/>          <span>0 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"011"</span>)<br/>                     .addRow(<span>"110"</span>)<br/>          <span>1 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"10"</span>)<br/>                     .addRow(<span>"11"</span>)<br/>                     .addRow(<span>"01"</span>)<br/>          <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is <br/>                                       an invalid frame number."</span>)<br/>        }<br/>      }<br/>    },</pre>
<p><span>Let's create a&#160;</span>tetromino shape with two frames and a start position of 2. The tetromino modeled here is the 'I' shaped tetromino.</p>
<pre>    <span>Tetromino4</span>(<span>2</span>, <span>2</span>) {<br/>      <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>        <span>return when </span>(frameNumber) {<br/>          <span>0 </span>-&gt; Frame(<span>4</span>).addRow(<span>"1111"</span>)<br/>          <span>1 </span>-&gt; Frame(<span>1</span>)<br/>                       .addRow(<span>"1"</span>)<br/>                       .addRow(<span>"1"</span>)<br/>                       .addRow(<span>"1"</span>)<br/>                       .addRow(<span>"1"</span>)<br/>          <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is an <br/>                                       invalid frame number."</span>)<br/>        }<br/>      }<br/>    },<br/>   </pre>
<p><span>Let's create a&#160;</span>tetromino shape with four frames and a start position of 1. The tetromino modeled here is the 'T' shaped tetromino.</p>
<pre>    <span>Tetromino5</span>(<span>4</span>, <span>1</span>) {<br/>      <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>        <span>return when </span>(frameNumber) {<br/>          <span>0 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"010"</span>)<br/>                     .addRow(<span>"111"</span>)<br/>          <span>1 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"10"</span>)<br/>                     .addRow(<span>"11"</span>)<br/>                     .addRow(<span>"10"</span>)<br/>          <span>2 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"111"</span>)<br/>                     .addRow(<span>"010"</span>)<br/>          <span>3 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"01"</span>)<br/>                     .addRow(<span>"11"</span>)<br/>                     .addRow(<span>"01"</span>)<br/>          <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is an <br/>                                       invalid frame number."</span>)<br/>        }<br/>      }<br/>    },</pre>
<p><span>Let's create a&#160;</span>tetromino shape with four frames and a start position of 1.&#160;The tetromino modeled here is the 'J' shaped tetromino.</p>
<pre>    <span>Tetromino6</span>(<span>4</span>, <span>1</span>) {<br/>      <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>        <span>return when </span>(frameNumber) {<br/>          <span>0 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"100"</span>)<br/>                     .addRow(<span>"111"</span>)<br/>          <span>1 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"11"</span>)<br/>                     .addRow(<span>"10"</span>)<br/>                     .addRow(<span>"10"</span>)<br/>          <span>2 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"111"</span>)<br/>                     .addRow(<span>"001"</span>)<br/>          <span>3 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"01"</span>)<br/>                     .addRow(<span>"01"</span>)<br/>                     .addRow(<span>"11"</span>)<br/>          <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is <br/>                                       an invalid frame number."</span>)<br/>        }<br/>      }<br/>    },</pre>
<p><span>Let's create a&#160;</span>tetromino shape with four frames&#160;and a start position of 1. The tetromino modeled here is the 'L' shaped tetromino.</p>
<pre>    <span>Tetromino7</span>(<span>4</span>, <span>1</span>) {<br/>      <span>override fun </span>getFrame(frameNumber: Int): Frame {<br/>        <span>return when </span>(frameNumber) {<br/>          <span>0 </span>-&gt;  Frame(<span>3</span>)<br/>                     .addRow(<span>"001"</span>)<br/>                     .addRow(<span>"111"</span>)<br/>          <span>1 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"10"</span>)<br/>                     .addRow(<span>"10"</span>)<br/>                     .addRow(<span>"11"</span>)<br/>          <span>2 </span>-&gt; Frame(<span>3</span>)<br/>                     .addRow(<span>"111"</span>)<br/>                     .addRow(<span>"100"</span>)<br/>          <span>3 </span>-&gt; Frame(<span>2</span>)<br/>                     .addRow(<span>"11"</span>)<br/>                     .addRow(<span>"01"</span>)<br/>                     .addRow(<span>"01"</span>)<br/>          <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"</span><span>$</span>frameNumber<span> is <br/>                                       an invalid frame number."</span>)<br/>        }<br/>      }<br/>    };<br/><br/>    <span>abstract fun </span>getFrame(frameNumber: Int): Frame<br/>}</pre>
<p class="p1"><span class="s1">Having modeled both the block frame and shape, the next thing we must model programmatically is the block itself. We will use this as an opportunity to demonstrate Kotlin's seamless interoperability with Java by implementing the model with Java. Create a new Java class in the <kbd>models</kbd> directory (<span class="packt_screen">models</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Java Class</span>) with the name <kbd>Block</kbd>. We will start the modeling process by adding instance variables that represent the characteristics of a block. Consider the following code:</span></p>
<pre class="p1"><span class="s1">package com.mydomain.tetris.models;<br/></span><span class="s1">import android.graphics.Color;<br/></span><span class="s1">import android.graphics.Point;<br/><br/></span><span class="s1">public class Block {<br/>  </span><span class="s1">private int shapeIndex;<br/>  </span><span class="s1">private int frameNumber;<br/>  </span><span class="s1">private BlockColor color;<br/>  </span><span class="s1">private Point position;<br/><br/>  </span><span class="s1">public enum BlockColor {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>PINK(Color.rgb(255, 105, 180), (byte) 2),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>GREEN(Color.rgb(0, 128, 0), (byte) 3),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>ORANGE(Color.rgb(255, 140, 0), (byte) 4),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>YELLOW(Color.rgb(255, 255, 0), (byte) 5),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>CYAN(Color.rgb(0, 255, 255), (byte) 6);<br/></span><span class="s1"><span class="Apple-converted-space">       <br/>    </span>BlockColor(int rgbValue, byte value) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.rgbValue = rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.byteValue = value;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final int rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final byte byteValue;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">In the preceding code block, we add four instance variables: <kbd>shapeIndex</kbd>, <kbd>frameNumber</kbd>, <kbd>color</kbd>, and <kbd>position</kbd>. <kbd>shapeIndex</kbd> will hold the index of the shape of the block, <kbd>frameNumber</kbd> will keep track of the number of frames the block's shape has, <kbd>color</kbd> will hold the color characteristic of the block, and <kbd>position</kbd> will be used to keep track of the block's current spatial position in the gaming field.</span></p>
<p class="p1"><span class="s1">An <kbd>enum</kbd> template, <kbd>BlockColor</kbd>, is added within the <kbd>Block</kbd> class. This <kbd>enum</kbd> creates a constant set of <kbd>BlockColor</kbd> instances, with each possessing&#160;<kbd>rgbValue</kbd> and <kbd>byteValue</kbd> properties. <kbd>rgbValue</kbd> is an integer that uniquely identifies an RGB color specified with the <kbd>Color.rgb()</kbd> method. <kbd>Color</kbd> is a class provided by the Android application framework and <kbd>rgb()</kbd> is a class method defined within the <kbd>Color</kbd> class. The five&#160;<kbd>Colour.rgb()</kbd>&#160;calls specify the colors pink, green, orange, yellow, and cyan, respectively.</span></p>
<p class="p1"><span class="s1">In&#160;<kbd>Block</kbd>, we made use of the <kbd>private</kbd> and <kbd>public</kbd> keywords. These were not added for eye candy; they each have a use. These two keywords, along with the <kbd>protected</kbd> keyword, are called access modifiers.</span></p>
<div class="packt_infobox">Access modifiers are keywords used to specify access restrictions on classes, methods, functions, variables, and structures. Java has three access modifiers: <kbd>private</kbd>, <kbd>public</kbd>, and <kbd>protected</kbd>. In Kotlin, access modifiers are called visibility modifiers. The available visibility modifiers in Kotlin are <kbd>public</kbd>, <kbd>protected</kbd>, <kbd>private</kbd>, and <kbd>internal</kbd>.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Private access modifier (private)</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Methods, variables, constructors, and structures that are declared private can only be accessed within the declaring class. This is with the exception of private top-level functions and properties that are visible to all members of the same file. Private variables within a class can be accessed from outside the class be declaring getter and setter methods that permit access.&#160;</span><span class="s1">Defining setter and getter methods in Java is shown in the following code:</span></p>
<pre class="p1"><span class="s1">public class Person {<br/></span><span class="s1">  Person(String fullName, int age) {<br/>    </span><span class="s1">this.fullName = fullName;<br/>    </span><span class="s1">this.age = age;<br/>  </span><span class="s1">}<br/><br/>  </span><span class="s1">private String fullName;<br/>  </span><span class="s1">private int age;<br/><br/>  </span><span class="s1">public String getFullName() {<br/>    </span><span class="s1">return fullName;<br/>  </span><span class="s1">}<br/><br/>  </span><span class="s1">public int getAge() {<br/>    </span><span class="s1">return age;<br/>  </span><span class="s1">}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">In Kotlin, setter and getter creation is as follows:</span></p>
<pre class="p1"><span class="s1">public class Person(private var fullName: String) {<br/>  </span><span class="s1">var name: String<br/></span><span class="s1">  get() = fullName<br/>  </span><span class="s1">set(value)<span class="Apple-converted-space">  </span>{<br/>    </span><span class="s1">fullName = value<br/>  </span><span class="s1">}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Using the private access modifier is the main means of information hiding within programs. Information hiding is also known as encapsulation.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Public access modifier (public)</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Methods, variables, constructors, and structures declared public can be accessed freely from outside the declaring class. A public class existing in a different package from an accessing class must be imported before it can be used. The following class makes use of the public access modifier:</span></p>
<pre class="p1"><span class="s1">public class Person { .. }</span></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Protected access modifier (protected)</h1>
                </header>
            
            <article>
                
<p>Variables, methods, functions, and structures declared protected can be accessed only by classes in the same package as the defining class or&#160;<span>by subclasses of their defining class that exist in a separate</span> <span>package:</span></p>
<pre class="p1"><span class="s1">public class Person(private var fullName: String) {<br/>  </span><span class="s1">protected name: String<br/></span><span class="s1">  get() = fullName<br/>  </span><span class="s1">set(value)<span class="Apple-converted-space">  </span>{<br/>    </span><span class="s1">fullName = value<br/>  </span><span class="s1">}<br/></span><span class="s1">}</span></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Internal visibility modifier (internal)</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The internal visibility modifier is used to declare a member visible within the same module. A module is a collection of Kotlin files compiled together.<span class="Apple-converted-space">&#160;</span> A module may be a Maven project, a Gradle source set, and IntelliJ IDEA module, or a set of files compiled with an Ant task invocation. Using the internal modifier is similar to using other visibility modifiers:</span></p>
<pre class="p1"><span class="s1">internal class Person { }</span></pre>
<p class="p1"><span class="s1">Having understood access and visibility modifiers, we can continue with the implementation of the <kbd>Block</kbd> class. The next thing we need to do is create a constructor for the class that initializes the instance variables we have created to their initial states. Constructor definitions in Java are syntactically different from Kotlin constructor definitions:</span></p>
<pre class="p1"><span class="s1">public class Block {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private int shapeIndex;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private int frameNumber;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private BlockColor color;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private Point position;</span></pre>
<p class="p1"><span class="s1">Let's see the constructor definition:</span></p>
<pre class="p1"><span class="s1"><span class="Apple-converted-space">  </span>private Block(int shapeIndex, BlockColor blockColor) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.frameNumber = 0;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.shapeIndex = shapeIndex;<br/></span><span class="s1"><span class="Apple-converted-space">    t</span>his.color = blockColor;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.position = new Point(AppModel.FieldConstants<br/>                              .COLUMN_COUNT.getValue() / 2, 0);<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>public enum BlockColor {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>PINK(Color.rgb(255, 105, 180), (byte) 2),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>GREEN(Color.rgb(0, 128, 0), (byte) 3),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>ORANGE(Color.rgb(255, 140, 0), (byte) 4),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>YELLOW(Color.rgb(255, 255, 0), (byte) 5),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>CYAN(Color.rgb(0, 255, 255), (byte) 6);<br/></span><span class="s1"><span class="Apple-converted-space">       <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>BlockColor(int rgbValue, byte value) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.rgbValue = rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.byteValue = value;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final int rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final byte byteValue;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Notice that the preceding constructor definition has been given private access. We did this because we do not want this constructor to be accessed outside of&#160;<kbd>Block</kbd>. As we still want other classes to have a means of creating a block instance, we have to define a static method that permits this. We will call this method <kbd>createBlock</kbd>:</span></p>
<pre class="p1"><span class="s1">public class Block {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private int shapeIndex;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private int frameNumber;<br/></span><span class="s1"><span>  </span>private BlockColor color;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private Point position;<br/></span></pre>
<p class="p1"><span class="s1">Let's see the Constructor definition:</span></p>
<pre class="p1"><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">  </span>private Block(int shapeIndex, BlockColor blockColor) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.frameNumber = 0;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.shapeIndex = shapeIndex;<br/>&lt;/span&gt;<span class="s1"><span class="Apple-converted-space">    </span>this.color = blockColor;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.position = new Point( FieldConstants.COLUMN_COUNT<br/>                               .getValue()/2, 0);<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>public static Block createBlock() {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>Random random = new Random();<br/></span><span class="s1"><span class="Apple-converted-space">    </span>int shapeIndex = random.nextInt(Shape.values().length);<br/></span><span class="s1"><span class="Apple-converted-space">    </span>BlockColor blockColor = BlockColor.values() <br/>         [random.nextInt(BlockColor</span><span class="s1">.values().length)];<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>Block block = new Block(shapeIndex, blockColor);<br/></span><span class="s1"><span class="Apple-converted-space">    </span>block.position.x = block.position.x - Shape.values()<br/>          [shapeIndex].getStartPosition();<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return block;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>public enum BlockColor {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>PINK(Color.rgb(255, 105, 180), (byte) 2),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>GREEN(Color.rgb(0, 128, 0), (byte) 3),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>ORANGE(Color.rgb(255, 140, 0), (byte) 4),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>YELLOW(Color.rgb(255, 255, 0), (byte) 5),<br/></span><span class="s1"><span class="Apple-converted-space">    </span>CYAN(Color.rgb(0, 255, 255), (byte) 6);<br/></span><span class="s1"><span class="Apple-converted-space">       <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>BlockColor(int rgbValue, byte value) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.rgbValue = rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">      </span>this.byteValue = value;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final int rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>private final byte byteValue;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></span></pre>
<p class="p1"><span class="s1"><kbd>createBlock()</kbd> randomly selects the index of a tetromino shape in the <kbd>Shape</kbd> enum class and a <kbd>BlockColor</kbd> and assigns two randomly selected values&#160;to <kbd>shapeIndex</kbd> and <kbd>blockColor</kbd>. A new <kbd>Block</kbd> instance is created with the two values passed as arguments and the position of the block along the <em>X</em> axis is set. Lastly, <kbd>createBlock()</kbd> returns the created and initialized block.</span></p>
<p class="p1"><span class="s1">We need to add a few getter and setter methods to <kbd>Block</kbd>. These methods will give access to crucial properties of instances of the block. Add the following methods to the <kbd>Block</kbd> class:</span></p>
<pre class="p1"><span class="s1">public static int getColor(byte value) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>for (BlockColor colour : BlockColor.values()) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>if (value == colour.byteValue) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>return colour.rgbValue;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return -1;<br/></span><span class="s1">}<br/><br/></span><span class="s1">public final void setState(int frame, Point position) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>this.frameNumber = frame;<br/></span><span class="s1"><span class="Apple-converted-space">  </span>this.position = position;<br/></span><span class="s1">}<br/><br/></span><span class="s1">@NonNull<br/></span><span class="s1">public final byte[][] getShape(int frameNumber) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return Shape.values()[shapeIndex].getFrame(frameNumber).as2dByteArray();<br/></span><span class="s1">}<br/><br/></span><span class="s1">public Point getPosition() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return this.position;<br/></span><span class="s1">}<br/><br/></span><span class="s1">public final int getFrameCount() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return Shape.values()[shapeIndex].getFrameCount();<br/></span><span class="s1">}<br/><br/></span><span class="s1">public int getFrameNumber() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return frameNumber;<br/></span><span class="s1">}<br/><br/></span><span class="s1">public int getColor() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return color.rgbValue;<br/></span><span class="s1">}<br/><br/></span><span class="s1">public byte getStaticValue() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return color.byteValue;<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>@NonNull</kbd> is an annotation provided by the Android application framework that denotes that a field, parameter, or method return can never be null. In the preceding code snippet, it is used in the line prior to the <kbd>getShape()</kbd> method definition to denote that the method cannot return a null value.&#160;</span></p>
<div class="p1 packt_infobox"><span class="s1">In Java, an annotation is a form of metadata that can be added to Java source code. Annotations can be used on classes, methods, variables, parameters, and packages. Annotations can also be declared and used in Kotlin.</span></div>
<p class="p1"><span class="s1">The<span>&#160;</span><kbd>@NotNull</kbd><span>&#160;</span>annotation exists in the<span>&#160;</span><kbd>android.support.annotation</kbd><span>&#160;</span>package. Add the package import to the package imports at the top of <kbd>Block.java</kbd>:</span></p>
<pre class="p1"><span class="s1">import android.support.annotation.NonNull;</span></pre>
<p class="p1"><span class="s1">There's one last thing we should take care of in the <kbd>Block</kbd> class before moving on. In the final line of the&#160;<kbd>Block</kbd>&#160;constructor, the position of the current block instance's position instance variable is set as follows:</span></p>
<pre class="p1"><span class="s1">this.position = new Point(</span><span>FieldConstants</span>.<span>COLUMN_COUNT</span>.getValue()/<span>2</span><span class="s1">, 0);</span></pre>
<p class="p1"><span class="s1">The <kbd>10</kbd> is the column count of the field in which the tetrominoes will be generated. This is a constant value that will be used several times within the code for this application, and as such, is best declared as a constant. Create a package named constants in the base application source package and add a new Kotlin file with the name <kbd>FieldConstants</kbd>&#160;to the package. Next, add constants for the number of columns and rows that the playing field will possess. The field should possess ten columns and twenty rows:</span></p>
<pre class="p1"><span class="s1">enum class FieldConstants(val value: Int) {<br/></span><span class="s1"><span class="Apple-tab-span">  </span>COLUMN_COUNT(10), ROW_COUNT(20);<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Import the package with the <kbd>FieldConstants</kbd> enum class into <kbd>Block.java</kbd>&#160;and replace the&#160;<kbd>10</kbd>&#160;integer with the constant value of the&#160;<kbd>COLUMN_COUNT</kbd>:</span></p>
<pre class="p1"><span class="s1">this.position = new Point( FieldConstants.COLUMN_COUNT.getValue()/2, 0);</span></pre>
<p class="p1"><span class="s1">That's it! We are done with the programmatic modeling of the <kbd>Block</kbd> class.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the application model</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Until now, we have been concerned with modeling specific components that make up tetromino blocks. Now it is time to concern ourselves with defining application logic. We will create an application model to implement the necessary Tetris gameplay logic, as well as to serve as an intermediary interface between views and the block components we have created.</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/9ec55ffe-9589-494a-8b13-8f99d41bd288.jpg" style="width:20.58em;height:9.92em;"/></div>
<p class="p1"><span class="s1">A view will send a request for the performance to the application model, and the model will execute the action if it is valid and send feedback to the view. Similar to the models we have created so far, we need a separate class file for the application model. Go ahead and create a new Kotlin file named <kbd>AppModel.kt</kbd> and add a class named <kbd>AppModel</kbd> to the file with imports for <kbd>Point</kbd>, <kbd>FieldConstants</kbd>, <kbd>array2dOfByte</kbd>, and <kbd>AppPreferences</kbd>:</span></p>
<pre class="p1"><span class="s1">package com.mydomain.tetris.models<br/><br/></span><span class="s1">import android.graphics.Point<br/></span><span class="s1">import com.mydomain.tetris.constants.FieldConstants<br/></span><span class="s1">import com.mydomain.tetris.helpers.array2dOfByte<br/></span><span class="s1">import com.mydomain.tetris.storage.AppPreferences<br/><br/></span><span class="s1">class AppModel</span></pre>
<p class="p1"><span class="s1">Some functions of <kbd>AppModel</kbd> are to keep track of the current score, the <kbd>tetris</kbd> gameplay field state, the current block, the current state of the game, the current status of the game, and the motions being experienced by the current block. <kbd>AppModel</kbd> must also have direct access to values stored within the application's <kbd>SharedPreferences</kbd> file via the <kbd>AppPreferences</kbd> class we created. Catering to these different demands may seem daunting at first, but is easy as pie.</span></p>
<p class="p1"><span class="s1">The first thing we must do is add the necessary constants that will be utilized by <kbd>AppModel</kbd>. We will need to create constants for the possible game statuses and the possible motions that can occur during gameplay. These constants are created with ease with the use of <kbd>enum</kbd> classes:</span></p>
<pre class="p1"><span class="s1">class AppModel {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Statuses {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>AWAITING_START, ACTIVE, INACTIVE, OVER<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Motions {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>LEFT, RIGHT, DOWN, ROTATE<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">We created four status constants earlier. <kbd>AWAITING_START</kbd> is the status of the game before the game has been started. <kbd>ACTIVE</kbd> is the status in which the game exists when gameplay is currently in progress. <kbd>OVER</kbd> is the status that the game takes when the game ends.</span></p>
<p class="p1"><span class="s1">Earlier in this chapter, it was stated that four distinct motions can occur on a block. Blocks can be moved to the right, to the left, up, down, and rotated. <kbd>LEFT</kbd>, <kbd>RIGHT</kbd>, <kbd>UP</kbd>, <kbd>DOWN</kbd>, and <kbd>ROTATE</kbd> are defined in the <kbd>Motions</kbd> enum class to represent these distinct motions.</span></p>
<p class="p1"><span class="s1">Having added the constants required, we can proceed by adding the necessary class properties of <kbd>AppModel</kbd>, which are as follows:</span></p>
<pre class="p1"><span class="s1">package com.mydomain.tetris.models<br/></span><span class="s1"><br/>import android.graphics.Point<br/></span><span class="s1">import com.mydomain.tetris.constants.FieldConstants<br/></span><span class="s1">import com.mydomain.tetris.helpers.array2dOfByte<br/></span><span class="s1">import com.mydomain.tetris.storage.AppPreferences<br/><br/></span><span class="s1">class AppModel {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>var score: Int = 0<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private var preferences: AppPreferences? = null<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>var currentBlock: Block? = null<br/></span><span class="s1"><span class="Apple-converted-space">  </span>var currentState: String = Statuses.AWAITING_START.name<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>private var field: Array&lt;ByteArray&gt; = array2dOfByte(<br/></span><span class="s1"><span class="Apple-converted-space">    </span>FieldConstants.ROW_COUNT.value,<br/></span><span class="s1"><span class="Apple-converted-space">    </span>FieldConstants.COLUMN_COUNT.value<br/></span><span class="s1"><span class="Apple-converted-space">  </span>)<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Statuses {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>AWAITING_START, ACTIVE, INACTIVE, OVER<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Motions {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>LEFT, RIGHT, DOWN, ROTATE<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>score</kbd> is an integer property that will be used to hold the current score of the player within a gaming session. <kbd>preferences</kbd> is a private property that will hold an <kbd>AppPreferences</kbd> object to provide direct access to the application's <kbd>SharedPreferences</kbd> file. <kbd>currentBlock</kbd> is a property that will hold the current block translating across the play field.&#160;<kbd>currentState</kbd> holds the state of the game. <kbd>Statuses.AWAITING_START.name</kbd> returns the name of <kbd>Statuses.AWAITING_START</kbd> in the form of an <kbd>AWAITING_START</kbd> string. The current state of the game is initialized to <kbd>AWAITING_START</kbd> immediately because this is the first state that <kbd>GameActivity</kbd> must transition into upon launch. Lastly, <kbd>field</kbd> is a two-dimensional array that will be used as the playing field for the game.</span></p>
<p class="p1"><span class="s1">Next we must add a few setter and getter functions. These functions are <kbd>setPreferences()</kbd>, <kbd>setCellStatus()</kbd>, and <kbd>getCellStatus()</kbd>. Add the following functions to <kbd>AppModel</kbd>:</span></p>
<pre class="p1"><span class="s1">fun setPreferences(preferences: AppPreferences?) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>this.preferences = preferences<br/></span><span class="s1">}<br/><br/></span><span class="s1">fun getCellStatus(row: Int, column: Int): Byte? {<br/>  </span><span class="s1">return field[row][column]<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun setCellStatus(row: Int, column: Int, status: Byte?) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>if (status != null) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>field[row][column] = status<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">The <kbd>setPreferences()</kbd>&#160;method sets the preferences property of <kbd>AppModel</kbd> to the <kbd>AppPreferences</kbd> instance passed as an argument to the function. The <kbd>getCellStatus()</kbd> method returns the status of a&#160;cell existing in a specified row-column position within the field's two-dimensional array. The&#160;<kbd>setCellStatus()</kbd>&#160;method sets the status of a cell existing in the field to a specified byte.</span></p>
<p class="p1"><span class="s1">Functions for checking state are necessary in the model as well.<span class="Apple-converted-space">&#160;</span>These will serve as a medium to assert the state that the game is currently in. As we have three possible game statuses corresponding to three possible game states, three functions are required for each individual game state. These methods are&#160;<kbd>isGameAwaitingStart()</kbd>, <kbd>isGameActive()</kbd>, and <kbd>isGameOver()</kbd>:</span></p>
<pre class="p1"><span class="s1">class AppModel {<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>var score: Int = 0<br/></span><span class="s1"><span class="Apple-converted-space">  </span>private var preferences: AppPreferences? = null<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>var currentBlock: Block? = null<br/></span><span class="s1"><span class="Apple-converted-space">  </span>var currentState: String = Statuses.AWAITING_START.name<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>private var field: Array&lt;ByteArray&gt; = array2dOfByte(<br/></span><span class="s1"><span class="Apple-converted-space">    </span>FieldConstants.ROW_COUNT.value,<br/></span><span class="s1"><span class="Apple-converted-space">    </span>FieldConstants.COLUMN_COUNT.value<br/></span><span class="s1"><span class="Apple-converted-space">  </span>)<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>fun setPreferences(preferences: AppPreferences?) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>this.preferences = preferences<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>fun getCellStatus(row: Int, column: Int): Byte? {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return field[row][column]<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>private fun setCellStatus(row: Int, column: Int, status: Byte?) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>if (status != null) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>field[row][column] = status<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>fun isGameOver(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return currentState == Statuses.OVER.name<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>fun isGameActive(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return currentState == Statuses.ACTIVE.name<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>fun isGameAwaitingStart(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return currentState == Statuses.AWAITING_START.name<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Statuses {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>AWAITING_START, ACTIVE, INACTIVE, OVER<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>enum class Motions {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>LEFT, RIGHT, DOWN, ROTATE<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">All three methods return Boolean values of either <kbd>true</kbd> or <kbd>false</kbd> depending on whether the game is existing in their respective states. So far, we have not made use of the <kbd>score</kbd> in <kbd>AppModel</kbd>. Let's add a function that can be used to increase the score value held by the <kbd>score</kbd>. We will name the function <kbd>boostScore()</kbd>.</span></p>
<pre class="p1"><span class="s1">private fun boostScore() {<br/></span><span class="s1">  score += 10<br/></span><span class="s1">  if (score &gt; preferences?.getHighScore() as Int)<br/></span><span class="s1">    preferences?.saveHighScore(score)<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">When called, <kbd>boostScore()</kbd> increases the current score of the player by 10 points, after which it checks whether the current score of the player is greater than the high score recorded in the preferences file. If the current score is greater than the saved high score, the high score is overwritten with the current score.</span></p>
<p class="p1"><span class="s1">Having gotten the basic functions and fields up and running, we can progress to creating slightly more complicated functions. The first of these functions is <kbd>generateNextBlock()</kbd>:</span></p>
<pre class="p1"><span class="s1">private fun generateNextBlock() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>currentBlock = Block.createBlock()<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">The <kbd>generateNextBlock()</kbd> function creates a new block instance and sets <kbd>currentBlock</kbd> to the newly created instance.&#160;</span></p>
<p class="p1"><span class="s1">Before going any further with method definitions, let's create one more <kbd>enum</kbd> class to hold constant cell values. Create a <kbd>CellConstants.kt</kbd> file in the constants package and add the following source code to it:</span></p>
<pre class="p1"><span class="s1">package com.mydomain.tetris.constants<br/><br/></span><span class="s1">enum class CellConstants(val value: Byte) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>EMPTY(0), EPHEMERAL(1)<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">You may be wondering what these constants are for. Recall when we created the <kbd>Frame</kbd> class to model a blocks frame, we defined <kbd>addRow()</kbd>, which took a string of 1s and 0s as its argument—with 1 representing cells that made up the frame and 0 representing cells excluded from the frame—and converted these 1s and 0s to byte representations. We are going to be manipulating these bytes in upcoming functions and we need to have corresponding constants for them.</span></p>
<p class="p1"><span class="s1">Import the newly created <kbd>enum</kbd> class into <kbd>AppModel</kbd>. We will make use of it in the upcoming function:</span></p>
<pre class="p1"><span class="s1">private fun validTranslation(position: Point, shape: Array&lt;ByteArray&gt;): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return if (position.y &lt; 0 || position.x &lt; 0) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>false<br/></span><span class="s1"><span class="Apple-converted-space">  </span>} else if (position.y + shape.size &gt; FieldConstants.ROW_COUNT.value) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>false<br/></span><span class="s1"><span class="Apple-converted-space">  </span>} else if (position.x + shape[0].size &gt; FieldConstants<br/>             .COLUMN_COUNT.value) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>false<br/></span><span class="s1"><span class="Apple-converted-space">  </span>} else {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>for (i in 0 until shape.size) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>for (j in 0 until shape[i].size) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>val y = position.y + i<br/></span><span class="s1"><span class="Apple-converted-space">        </span>val x = position.x + j<br/><br/></span><span class="s1"><span class="Apple-converted-space">        </span>if (CellConstants.EMPTY.value != shape[i][j] &amp;&amp; <br/>            CellConstants.EMPTY.value != field[y][x]) {<br/></span><span class="s1"><span class="Apple-converted-space">          </span>return false<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    }</span><br/></span><span class="s1"><span class="Apple-converted-space">    </span>true<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}</span></pre>
<p class="p1"><span class="s1">Add the preceding&#160;<kbd>validTranslation()</kbd> method to <kbd>AppModel</kbd>. As the name implies, this function is used to check whether a translational motion of a tetromino in the playing field is valid based on a set of conditions. It returns a <kbd>true</kbd>&#160; Boolean value if the translation is valid, and <kbd>false</kbd> otherwise. The first three conditionals test whether the position the tetromino is being translated in the field to is a valid one. The <kbd>else</kbd> block checks whether the cells the tetromino is attempting to translate into are empty. If they are not, <kbd>false</kbd> is returned.</span></p>
<p class="p1"><span class="s1">We need a calling function for <kbd>validTranslation()</kbd>. We will declare <kbd>moveValid()</kbd> to serve this purpose. Add the following function to <kbd>AppModel</kbd>:</span></p>
<pre class="p1"><span class="s1">private fun moveValid(position: Point, frameNumber: Int?): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val shape: Array&lt;ByteArray&gt;? = currentBlock?<br/>                                 .getShape(frameNumber as Int)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return validTranslation(position, shape as Array&lt;ByteArray&gt;)<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>moveValid()</kbd> utilizes <kbd>validTranslation()</kbd> to check whether a move performed by the player is permitted. If the move is permitted, it returns <kbd>true</kbd>, otherwise&#160;<kbd>false</kbd> is returned. We need to create a few other important methods. These are <kbd>generateField()</kbd>, <kbd>resetField()</kbd>, <kbd>persistCellData()</kbd>, <kbd>assessField()</kbd>, <kbd>translateBlock()</kbd>, <kbd>blockAdditionPossible()</kbd>, <kbd>shiftRows()</kbd>, <kbd>startGame()</kbd>, <kbd>restartGame()</kbd>, <kbd>endGame()</kbd>, and <kbd>resetModel()</kbd>.</span></p>
<p class="p1"><span class="s1">We will firstly work on the&#160;<kbd>generateField()</kbd>&#160;method. Add the code shown below to <kbd>AppModel</kbd>.</span></p>
<pre class="p1"><span class="s1">fun generateField(action: String) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>if (isGameActive()) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>resetField()<br/></span><span class="s1"><span class="Apple-converted-space">    </span>var frameNumber: Int? = currentBlock?.frameNumber<br/></span><span class="s1"><span class="Apple-converted-space">    </span>val coordinate: Point? = Point()<br/></span><span class="s1"><span class="Apple-converted-space">    </span>coordinate?.x = currentBlock?.position?.x<br/></span><span class="s1"><span class="Apple-converted-space">    </span>coordinate?.y = currentBlock?.position?.y<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>when (action) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>Motions.LEFT.name -&gt; {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>coordinate?.x = currentBlock?.position?.x?.minus(1)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>Motions.RIGHT.name -&gt; {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>coordinate?.x = currentBlock?.position?.x?.plus(1)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>Motions.DOWN.name -&gt; {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>coordinate?.y = currentBlock?.position?.y?.plus(1)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>Motions.ROTATE.name -&gt; {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>frameNumber = frameNumber?.plus(1)<br/><br/></span><span class="s1"><span class="Apple-converted-space">        </span>if (frameNumber != null) {<br/></span><span class="s1"><span class="Apple-converted-space">          </span>if (frameNumber &gt;= currentBlock?.frameCount as Int) {<br/></span><span class="s1"><span class="Apple-converted-space">            </span>frameNumber = 0<br/></span><span class="s1"><span class="Apple-converted-space">          </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>if (!moveValid(coordinate as Point, frameNumber)) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>translateBlock(currentBlock?.position as Point, <br/>                     currentBlock?.frameNumber as Int)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>if (Motions.DOWN.name == action) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>boostScore()<br/></span><span class="s1"><span class="Apple-converted-space">        </span>persistCellData()<br/></span><span class="s1"><span class="Apple-converted-space">        </span>assessField()<br/></span><span class="s1"><span class="Apple-converted-space">        </span>generateNextBlock()<br/><br/></span><span class="s1"><span class="Apple-converted-space">        </span>if (!blockAdditionPossible()) {<br/></span><span class="s1"><span class="Apple-converted-space">          </span>currentState = Statuses.OVER.name;<br/></span><span class="s1"><span class="Apple-converted-space">          </span>currentBlock = null;<br/></span><span class="s1"><span class="Apple-converted-space">          </span>resetField(false);<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>} else {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>if (frameNumber != null) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>translateBlock(coordinate, frameNumber)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>currentBlock?.setState(frameNumber, coordinate)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>generateField()</kbd>&#160;generates a refresh of the field. This field refresh is determined by the action that is passed as the argument of<span>&#160;</span><kbd>generateField()</kbd>.</span></p>
<p class="p1"><span class="s1">First,&#160;<kbd>generateField()</kbd>&#160;checks whether the game is currently in its active state when called. If the game is active, the frame number and coordinates of the block are retrieved. The action requested is then determined via the<span>&#160;</span><kbd>when</kbd><span>&#160;</span>expression. Having determined the requested action, the coordinates of the block are changed appropriately if the action requested is a leftward, rightward, or downward motion. If a rotational motion is requested,<span>&#160;</span><kbd>frameNumber</kbd><span>&#160;</span>is changed to an appropriate number of a frame that represents the tetromino in the rotation exerted.</span></p>
<p class="p1"><span class="s1">The<span>&#160;</span><kbd>generateField()</kbd>&#160;method then checks whether the motion requested is a valid motion via<span>&#160;</span><kbd>moveValid()</kbd>. If the move is not valid, the current block is fixed in the field to its current position with the use of<span>&#160;</span><kbd>translateBlock()</kbd>.</span></p>
<p>The&#160;<span class="s1"><kbd>resetField()</kbd>, <kbd>persistCellData()</kbd> and <kbd>assessField()</kbd>&#160;methods invoked by <kbd>generateField()</kbd> are given below. Add them to&#160;<kbd>AppModel</kbd>:</span></p>
<pre class="p1"><span class="s1">private fun resetField(ephemeralCellsOnly: Boolean = true) {<br/></span><span class="s1"><span class="Apple-converted-space">  f</span>or (i in 0 until FieldConstants.ROW_COUNT.value) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>(0 until FieldConstants.COLUMN_COUNT.value)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>.filter { !ephemeralCellsOnly || field[i][it] == <br/>              CellConstants.EPHEMERAL.value }<br/></span><span class="s1"><span class="Apple-converted-space">    </span>.forEach { field[i][it] = CellConstants.EMPTY.value }<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun persistCellData() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>for (i in 0 until field.size) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>for (j in 0 until field[i].size) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>var status = getCellStatus(i, j)<br/></span><span class="s1"><span class="Apple-converted-space"><br/>      </span>if (status == CellConstants.EPHEMERAL.value) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>status = currentBlock?.staticValue<br/></span><span class="s1"><span class="Apple-converted-space">        </span>setCellStatus(i, j, status)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun assessField() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>for (i in 0 until field.size) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>var emptyCells = 0;<br/></span><span class="s1"><span class="Apple-converted-space"><br/>    </span>for (j in 0 until field[i].size) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>val status = getCellStatus(i, j)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>val isEmpty = CellConstants.EMPTY.value == status<br/></span><span class="s1"><span class="Apple-converted-space">      </span>if (isEmpty)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>emptyCells++<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>if (emptyCells == 0)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>shiftRows(i)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p>As you may have noticed,&#160;<kbd>translateBlock()</kbd> has not been implemented. Go ahead and add this method along with <kbd>blockAdditionPossible()</kbd>, <kbd>shiftRows()</kbd>, <kbd>startGame()</kbd>, <kbd>restartGame()</kbd>, <kbd>endGame()</kbd>, and <kbd>resetModel()</kbd> to <kbd>AppModel</kbd>&#160;is as follows:&#160;</p>
<pre class="p1"><span class="s1">private fun translateBlock(position: Point, frameNumber: Int) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>synchronized(field) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>val shape: Array&lt;ByteArray&gt;? = currentBlock?.getShape(frameNumber)<br/></span><span class="s1"><span class="Apple-converted-space"><br/>    </span>if (shape != null) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>for (i in shape.indices) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>for (j in 0 until shape[i].size) {<br/></span><span class="s1"><span class="Apple-converted-space">          </span>val y = position.y + i<br/></span><span class="s1"><span class="Apple-converted-space">          </span>val x = position.x + j<br/><br/></span><span class="s1"><span class="Apple-converted-space">          </span>if (CellConstants.EMPTY.value != shape[i][j]) {<br/></span><span class="s1"><span class="Apple-converted-space">            </span>field[y][x] = shape[i][j]<br/></span><span class="s1"><span class="Apple-converted-space">          </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun blockAdditionPossible(): Boolean {</span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">  </span>if (!moveValid(currentBlock?.position as Point, <br/>      currentBlock?.frameNumber)) {</span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">    </span>return false<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return true<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun shiftRows(nToRow: Int) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>if (nToRow &gt; 0) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>for (j in nToRow - 1 downTo 0) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>for (m in 0 until field[j].size) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>setCellStatus(j + 1, m, getCellStatus(j, m))<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>for (j in 0 until field[0].size) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>setCellStatus(0, j, CellConstants.EMPTY.value)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">fun startGame() {<br/></span><span class="s1">  if (!isGameActive()) {<br/></span><span class="s1">    currentState = Statuses.ACTIVE.name<br/></span><span class="s1">    generateNextBlock()<br/></span><span class="s1">  }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fun restartGame() {<br/></span><span class="s1">  resetModel()<br/></span><span class="s1">  startGame()<br/></span><span class="s1">}<br/><br/></span><span class="s1">fun endGame() {<br/>  </span><span class="s1">score = 0<br/>  </span><span class="s1">currentState = AppModel.Statuses.OVER.name<br/></span><span class="s1">}<br/><br/></span><span class="s1">private fun resetModel() {<br/>  </span><span class="s1">resetField(false)<br/>  </span><span class="s1">currentState = Statuses.AWAITING_START.name<br/>  </span><span class="s1">score = 0<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">In a scenario where the requested move is a downward motion and the move is not valid, it implies that the block has reached the bottom of the field. In this case, the player's score is boosted via <kbd>boostScore()</kbd> and the states of all cells in the field are persisted via <kbd>persistCellData()</kbd>. The&#160;<kbd>assessField()</kbd>&#160;method is then called to scan through the field row by row and check whether all cells in a row have been filled up:</span></p>
<pre class="p1"><span class="s1">private fun assessField() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>for (i in 0 until field.size) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>var emptyCells = 0;<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>for (j in 0 until field[i].size) {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>val status = getCellStatus(i, j)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>val isEmpty = CellConstants.EMPTY.value == status<br/><br/></span><span class="s1"><span class="Apple-converted-space">      </span>if (isEmpty)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>emptyCells++<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">    </span>if (emptyCells == 0)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>shiftRows(i)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">In the case where all cells in a row are filled up, the row is cleared and shifted by&#160;<kbd>shiftRow()</kbd>. After the assessment of the field is complete, a new block is generated with <kbd>generateNextBlock()</kbd>:</span></p>
<pre class="p1"><span class="s1">private fun generateNextBlock() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>currentBlock = Block.createBlock()<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Before the newly generated block can be pushed to the field, <kbd>AppModel</kbd> makes sure that the field is not already filled up and the block can be moved into the field with <kbd>blockAdditionPossible()</kbd>:</span></p>
<pre class="p1"><span class="s1">private fun blockAdditionPossible(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">  i</span>f (!moveValid(currentBlock?.position as Point,<br/>      currentBlock?.frameNumber)) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>return false<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return true<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">If block addition is not possible, that means all blocks have been stacked to the top edge of the field. This results in a game over. As a result, the current state of the game is set to <kbd>Statuses.OVER</kbd> and the <kbd>currentBlock</kbd> is set to <kbd>null</kbd>. Lastly, the field is cleared.</span></p>
<p class="p1"><span class="s1">On the other hand, if the move was valid from the start, the block is translated to its new coordinates via <kbd>translateBlock()</kbd> and the state of the current block is set to its new coordinates and <kbd>frameNumber</kbd>.</span></p>
<p class="p1"><span class="s1">With those additions in place, we have been able to successfully create the application model to handle the gameplay logic. Now we have to create a view that exploits <kbd>AppModel</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating TetrisView</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">So far, so good. We have successfully implemented classes to model blocks, frames, and shapes of different tetrominoes that will be used within the application, as well as implemented an <kbd>AppModel</kbd> class to coordinate all the interactions between views and these programmatic components created. Without this view existing, there is no means by which a user can interact with <kbd>AppModel</kbd>. If a user cannot interact with the game, the game might as well not exist. In this section, we will implement <kbd>TetrisView</kbd>, the user interface by which a user will play Tetris.</span></p>
<p class="p1"><span class="s1">Create a package named <kbd>view</kbd> in your source package and add a <kbd>TetrisView.kt</kbd> file in it. As we want <kbd>TestrisView</kbd> to be a <kbd>View</kbd>, we must declare it to extend the View class. Add the code below to <kbd>TetrisView.kt</kbd>.&#160;</span></p>
<pre><span>package </span>com.mydomain.tetris.views<br/><br/><span>import </span>android.content.Context<br/><span>import </span>android.graphics.Canvas<br/><span>import </span>android.graphics.Color<br/><span>import </span>android.graphics.Paint<br/><span>import </span>android.graphics.RectF<br/><span>import </span>android.os.Handler<br/><span>import </span>android.os.Message<br/><span>import </span>android.util.AttributeSet<br/><span>import </span>android.view.View<br/>import android.widget.Toast<br/><span>import </span>com.mydomain.tetris.constants.CellConstants<br/><span>import </span>com.mydomain.tetris.GameActivity<br/><span>import </span>com.mydomain.tetris.constants.FieldConstants<br/><span>import </span>com.mydomain.tetris.models.AppModel<br/><span>import </span>com.mydomain.tetris.models.Block<br/><br/><span>class </span>TetrisView : View {<br/><br/>  p<span>rivate val </span><span>paint </span>= Paint()<br/>  <span>private var </span><span>lastMove</span>: Long = <span>0<br/></span><span>  </span><span>private var </span><span>model</span>: AppModel? = <span>null<br/></span><span>  private var </span><span>activity</span>: GameActivity? = <span>null<br/></span><span>  private val </span><span>viewHandler </span>= ViewHandler(<span>this</span>)<br/>  <span>private var </span><span>cellSize</span>: Dimension = Dimension(<span>0</span>, <span>0</span>)<br/>  <span>private var </span><span>frameOffset</span>: Dimension = Dimension(<span>0</span>, <span>0</span>)<br/><br/>  <span>constructor</span>(context: Context, attrs: AttributeSet) : <br/><span>             super</span>(context, attrs)<br/><br/>  <span>constructor</span>(context: Context, attrs: AttributeSet, defStyle: Int) :<br/>             <span>super</span>(context, attrs, defStyle)<br/><br/>  <span>companion object </span>{<br/>    <span>private val </span><span>DELAY </span>= <span>500<br/></span><span>    </span><span>private val </span><span>BLOCK_OFFSET </span>= <span>2<br/></span><span>    </span><span>private val </span><span>FRAME_OFFSET_BASE </span>= <span>10<br/></span><span>  </span>}<br/>}</pre>
<p class="p1"><span class="s1">The&#160;<kbd>TetrisView</kbd>&#160;class is declared to extend <kbd>View</kbd>. <kbd>View</kbd> is a class that all application view elements must extend. As the <kbd>View</kbd> type has a constructor that must be initialized, we are declaring two secondary constructors for <kbd>TetrisView</kbd> that initialize two distinct constructors of the view class, depending on which secondary constructor is called.</span></p>
<p class="p1"><span class="s1">The <kbd>paint</kbd> property is an instance of <kbd>android.graphics.Paint</kbd>. The <kbd>Paint</kbd> class holds style and color information concerning how to draw texts, bitmaps, and geometries. <kbd>lastMove</kbd>&#160;will be used to keep track of the last time in milliseconds that a move was made. The <kbd>model</kbd>&#160;instance will be used to hold an <kbd>AppModel</kbd> instance that will be interacted with by <kbd>TetrisView</kbd> to control gameplay. Activity is an instance of the <kbd>GameActivity</kbd> class we created. The&#160;<kbd>cellSize</kbd> and <kbd>frameOffset</kbd> are properties that will hold dimensions for the size of cells in the game and the frame offset, respectively.</span></p>
<p class="p1"><span class="s1">Neither <kbd>ViewHandler</kbd> nor <kbd>Dimension</kbd> is a class provided to us by the Android application framework. We must implement these two classes.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing ViewHandler</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As blocks will be moving along the fields in intervals with a constant time delay, we need a means of putting the thread that handles the movement of blocks to sleep and waking the thread to make a block motion after a period of time. A good way to take care of this requirement is to use a handler to process message delay requests and continue message handling after the delay has completed. Putting this in more direct terms, according to Android's documentation,</span>&#160;<em>the handler allows you to send and process Message objects associated with a thread's MessageQueue</em><span class="s1">. Every handler instance is associated with a thread and the thread's message queue.</span></p>
<p class="p1"><span class="s1"><kbd>ViewHandler</kbd> is a custom handler we will implement for <kbd>TetrisView</kbd> that caters to the view’s message-sending and processing needs. As <kbd>ViewHandler</kbd> is subclass of <kbd>Handler</kbd>, we must extend <kbd>Handler</kbd> and add our necessary behavior to the <kbd>ViewHandler</kbd> class.</span></p>
<p class="p1"><span class="s1">Add the following <kbd>VieHandler</kbd> class as a private class within <kbd>TetrisView</kbd>:</span></p>
<pre><span>private class </span>ViewHandler(<span>private val </span><span>owner</span>: TetrisView) : Handler() {<br/><br/>  <span>override fun </span>handleMessage(message: Message) {<br/>    i<span>f </span>(message.<span>what </span>== <span>0</span>) {<br/>      <span>if </span>(<span>owner</span>.<span>model </span>!= <span>null</span>) {<br/>        <span>if </span>(<span>owner</span>.<span>model</span>!!.isGameOver()) {<br/>          owner.model?.endGame()<br/>          Toast.makeText(owner.activity, "Game over", <br/>                         Toast.LENGTH_LONG).show();<br/>        }<br/>        <span>if </span>(<span>owner</span>.<span>model</span>!!.isGameActive()) {<br/>          <span>owner</span>.setGameCommandWithDelay(AppModel.Motions.<span>DOWN</span>)<br/>        }<br/>      }<br/>    }<br/>  }<br/><br/>  <span>fun </span>sleep(delay: Long) {<br/>    <span>this</span>.removeMessages(<span>0</span>)<br/>    sendMessageDelayed(obtainMessage(<span>0</span>), delay)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>ViewHandler</kbd> class takes an instance of <kbd>TetrisView</kbd> as an argument in its constructor. <kbd>ViewHandler</kbd> overrides the <kbd>handleMessage()</kbd> function existing in its superclass class. <kbd>handleMessage()</kbd> checks that the what message&#160;was sent. The <kbd>what</kbd> is an integer value denoting the message sent. If <kbd>what</kbd> is equal to <kbd>0</kbd>, and the instance—owner—of <kbd>TetrisView</kbd> passed possesses a model that is not equal to <kbd>0</kbd>, some statuses of the game are checked. If the game is over, it will call <kbd>endGame()</kbd>&#160;of <kbd>AppModel</kbd> function and show a popup alerting the player that the game is over. If the game is in its active state, a down motion is fired.</span></p>
<p class="p1"><span class="s1">The <kbd>sleep()</kbd>&#160;method simply removes any previously sent message and sends a new message with a delay specified by the delay argument.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Dimension</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1"><kbd>Dimension</kbd> only needs to be able to<span class="Apple-converted-space">&#160;</span>hold two properties: width and height. As such, it is a perfect candidate for the utilization of a data class. Add the following private class to the <kbd>TetrisView</kbd> class:</span></p>
<pre class="p1"><span class="s1">private data class Dimension(val width: Int, val height: Int)</span></pre>
<p class="p1"><span class="s1">The preceding one-liner provides us with the properties, as well as the setter and getters we need for them.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing TetrisView</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As you may have guessed, at this point <kbd>TetrisView</kbd> is far from completion. First and foremost we must implement a few setter methods for the <kbd>model</kbd> and <kbd>activity</kbd> properties of the view. These methods are shown below. Make sure to add them to your <kbd>TetrisView</kbd> class.</span></p>
<pre><span>fun </span><span>setModel</span>(model: AppModel) {<br/>    <span>this</span>.<span>model </span>= model<br/>}<br/><br/><span>fun </span><span>setActivity</span>(gameActivity: GameActivity) {<br/>    <span>this</span>.<span>activity </span>= gameActivity<br/>}</pre>
<p class="p1"><span class="s1"><kbd>setModel()</kbd> and <kbd>setActivity()</kbd> are setter functions for the model and activity instance properties. As the names imply, <kbd>setModel()</kbd> sets the current model in use by the view and <kbd>setActivity()</kbd> sets the activity in use. Now, let us add three additional methods <kbd>setGameCommand()</kbd>, <kbd>setGameCommandWithDelay()</kbd> and <kbd>updateScore()</kbd>.</span></p>
<pre><span>fun </span><span>setGameCommand</span>(move: AppModel.Motions) {<br/>  <span>if </span>(<span>null </span>!= <span>model </span>&amp;&amp; (<span>model</span>?.<span>currentState </span>== AppModel.Statuses.<span>ACTIVE</span>.<span>name</span>)) {<br/>    <span>if </span>(AppModel.Motions.<span>DOWN </span>== move) {<br/>      <span>model</span>?.generateField(move.<span>name</span>)<br/>      invalidate()<br/>      <span>return<br/></span><span>    </span>}<br/>    setGameCommandWithDelay(move)<br/>  }<br/>}<br/><br/><span>fun </span><span>setGameCommandWithDelay</span>(move: AppModel.Motions) {<br/>  <span>val </span>now = System.currentTimeMillis()<br/><br/>  <span>if </span>(now - <span>lastMove </span>&gt; <span>DELAY</span>) {<br/>    <span>model</span>?.generateField(move.<span>name</span>)<br/>    invalidate()<br/>    <span>lastMove </span>= now<br/>  }<br/>  updateScores()<br/>  <span>viewHandler</span>.sleep(<span>DELAY</span>.toLong())<br/>}<br/><br/><span>private fun </span><span>updateScores</span>() {<br/>  <span>activity</span>?.<span>tvCurrentScore</span>?.<span>text </span>= <span>"</span><span>${</span><span>model</span>?.<span>score</span><span>}</span><span>"<br/></span><span>  </span><span>activity</span>?.<span>tvHighScore</span>?.<span>text </span>= <span>"</span><span>${</span><span>activity</span>?.<span>appPreferences</span>?.getHighScore()<span>}</span><span>"<br/></span>}</pre>
<p class="p1"><span class="s1">&#160;<kbd>setGameCommand()</kbd> sets the current motion command being executed by the game. If a <kbd>DOWN</kbd> motion command is in execution, the application model generates the field for a block experiencing a downward motion. The <kbd>invalidate()</kbd> method being called within <kbd>setGameCommand()</kbd> can be taken as a request to draw a change on the screen. <kbd>invalidate()</kbd> ultimately results in a call to&#160;<kbd>onDraw()</kbd></span><span>.</span></p>
<p><kbd>onDraw()</kbd> is a method that is inherited from the <kbd>View</kbd> class. It is called when a view should render its content. We will need to provide a custom implementation of this for our view. Add the code below to your <kbd>TetrisView</kbd> class.</p>
<pre><span>override fun </span><span>onDraw</span>(canvas: Canvas) {<br/>  <span>super</span>.onDraw(canvas)<br/>  drawFrame(canvas)<br/><br/>  <span>if </span>(<span>model </span>!= <span>null</span>) {<br/>    <span>for </span>(i <span>in </span><span>0 </span><span>until </span>FieldConstants.<span>ROW_COUNT</span>.<span>value</span>) {<br/>      <span>for </span>(j <span>in </span><span>0 </span><span>until </span>FieldConstants.<span>COLUMN_COUNT</span>.<span>value</span>) {<br/>        drawCell(canvas<span>, </span>i<span>, </span>j)<br/>      }<br/>    }<br/>  }<br/>}<br/><br/><span>private fun </span><span>drawFrame</span>(canvas: Canvas) {<br/>  <span>paint</span>.<span>color </span>= Color.<span>LTGRAY<br/></span><span><br/></span><span>  </span>canvas.drawRect(<span>frameOffset</span>.<span>width</span>.toFloat()<span>,<br/></span><span>            </span><span>frameOffset</span>.<span>height</span>.toFloat()<span>, </span><span>width </span>- <span>frameOffset</span>.<span>width</span>.toFloat()<span>,<br/></span><span>            </span><span>height </span>- <span>frameOffset</span>.<span>height</span>.toFloat()<span>, </span><span>paint</span>)<br/>}<br/><br/><span>private fun </span><span>drawCell</span>(canvas: Canvas<span>, </span>row: Int<span>, </span>col: Int) {<br/>  <span>val </span>cellStatus = <span>model</span>?.getCellStatus(row<span>, </span>col)<br/><br/>  <span>if </span>(CellConstants.<span>EMPTY</span>.<span>value </span>!= cellStatus) {<br/>    <span>val </span>color = <span>if </span>(CellConstants.<span>EPHEMERAL</span>.<span>value </span>== cellStatus) {<br/>      <span>model</span>?.<span>currentBlock</span>?.<span>color<br/></span><span>    </span>} <span>else </span>{<br/>      Block.getColor(cellStatus <span>as </span>Byte)<br/>    }<br/>    drawCell(canvas<span>, </span>col<span>, </span>row<span>, </span>color <span>as </span>Int)<br/>  }<br/>}<br/><br/><span>private fun </span><span>drawCell</span>(canvas: Canvas<span>, </span>x: Int<span>, </span>y: Int<span>, </span>rgbColor: Int) {<br/>  <span>paint</span>.<span>color </span>= rgbColor<br/><br/>  <span>val </span>top: Float = (<span>frameOffset</span>.<span>height </span>+ y * <span>cellSize</span>.<span>height </span>+ <span>BLOCK_OFFSET</span>).toFloat()<br/>  <span>val </span>left: Float = (<span>frameOffset</span>.<span>width </span>+ x * <span>cellSize</span>.<span>width </span>+ <span>BLOCK_OFFSET</span>).toFloat()<br/>  <span>val </span>bottom: Float = (<span>frameOffset</span>.<span>height </span>+ (y + <span>1</span>) * <span>cellSize</span>.<span>height </span>- <span>BLOCK_OFFSET</span>).toFloat()<br/>  <span>val </span>right: Float = (<span>frameOffset</span>.<span>width </span>+ (x + <span>1</span>) * <span>cellSize</span>.<span>width </span>- <span>BLOCK_OFFSET</span>).toFloat()<br/>  <span>val </span>rectangle = RectF(left<span>, </span>top<span>, </span>right<span>, </span>bottom)<br/><br/>  canvas.drawRoundRect(rectangle<span>, </span><span>4F</span><span>, </span><span>4F</span><span>, </span><span>paint</span>)<br/>}<br/><br/><span>override fun </span><span>onSizeChanged</span>(width: Int<span>, </span>height: Int<span>, </span>previousWidth: Int<span>, </span>previousHeight: Int) {<br/>  <span>super</span>.onSizeChanged(width<span>, </span>height<span>, </span>previousWidth<span>, </span>previousHeight)<br/><br/>  <span>val </span>cellWidth = (width - <span>2 </span>* <span>FRAME_OFFSET_BASE</span>) / FieldConstants.<span>COLUMN_COUNT</span>.<span>value<br/></span><span>  </span><span>val </span>cellHeight = (height - <span>2 </span>* <span>FRAME_OFFSET_BASE</span>) / FieldConstants.<span>ROW_COUNT</span>.<span>value<br/></span><span>  </span><span>val </span>n = Math.min(cellWidth<span>, </span>cellHeight)<br/>  <span>this</span>.<span>cellSize </span>= Dimension(n<span>, </span>n)<br/>  <span>val </span>offsetX = (width - FieldConstants.<span>COLUMN_COUNT</span>.<span>value </span>* n) / <span>2<br/></span><span>  </span><span>val </span>offsetY = (height - FieldConstants.<span>ROW_COUNT</span>.<span>value </span>* n) / <span>2<br/></span><span>  </span><span>this</span>.<span>frameOffset </span>= Dimension(offsetX<span>, </span>offsetY)<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>onDraw()</kbd>&#160;method in <kbd>TetrisView</kbd> overrides the <kbd>onDraw()</kbd>&#160;in its&#160;superclass. <kbd>onDraw()</kbd>, takes a canvas object as its only argument and must call the <kbd>onDraw()</kbd> function in its superclass. This is done by invoking <kbd>super.onDraw()</kbd> and passing the canvas instance as an argument.</span></p>
<p class="p1"><span class="s1">After invoking <kbd>super.onDraw()</kbd>, <kbd>onDraw()</kbd> in <kbd>TetrisView</kbd> invokes <kbd>drawFrame()</kbd>, which draws the frame for <kbd>TetrisView</kbd>. After which, individual cells are drawn within the canvas by utilizing the <kbd>drawCell()</kbd> functions we created.&#160;</span></p>
<p class="p1"><span class="s1">The <kbd>setGameCommandWithDelay()</kbd> works similarly to <kbd>setGameCommand()</kbd> with the exception that updates the game score and it puts <kbd>viewHandler</kbd> to sleep after executing the game command.&#160;</span><span class="s1">The <kbd>updateScore()</kbd> function is used to update the current score and high score text views in game activity.</span></p>
<p class="p1"><span class="s1">The <kbd>onSizeChanged()</kbd> is a function that is called when the size of a view has changed. The function provides access to the current width and height of the view, as well as its former width and height. As with other overriden functions we have used, we invoke its counterpart function in its super class. We use the width and height arguments provided to us to calculate and set dimensions for the size of each cell—<kbd>cellSize</kbd>. Finally, in <kbd>onSizeChanged()</kbd>, the <kbd>offsetX</kbd>&#160;and <kbd>offsetY</kbd> are calculated and used to set <kbd>frameOffset</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finishing up GameActivity</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">So far, you have successfully implemented the views, handlers, helper functions, classes, and models necessary to put the Tetris game together. Now we are going to finish up the work we started by putting it all together in <kbd>GameActivity</kbd>. The first thing on our agenda is to add the newly created <kbd>tetris</kbd> view to the game activity's layout. We can easily add <kbd>TetrisView</kbd> as a child element anywhere within a layout file by utilizing the <kbd>&lt;com.mydomain.tetris.views.TetrisView&gt;</kbd> layout tag:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span>&lt;<span>android.support.constraint.ConstraintLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>app</span><span>=</span><span>"http://schemas.android.com/apk/res-auto"<br/></span><span>    </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>tools</span><span>:context=</span><span>"com.mydomain.tetris.GameActivity"</span>&gt;<br/>  &lt;<span>LinearLayout<br/></span><span>         </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>         </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>         </span><span>android</span><span>:orientation=</span><span>"horizontal"<br/></span><span>         </span><span>android</span><span>:weightSum=</span><span>"10"<br/></span><span>         </span><span>android</span><span>:background=</span><span>"#e8e8e8"</span>&gt;<br/>    &lt;<span>LinearLayout<br/></span><span>           </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>           </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>           </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span>           </span><span>android</span><span>:gravity=</span><span>"center"<br/></span><span>           </span><span>android</span><span>:paddingTop=</span><span>"32dp"<br/></span><span>           </span><span>android</span><span>:paddingBottom=</span><span>"32dp"<br/></span><span>           </span><span>android</span><span>:layout_weight=</span><span>"1"</span>&gt;<br/>      &lt;<span>LinearLayout<br/></span><span>              </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_height=</span><span>"0dp"<br/></span><span>              </span><span>android</span><span>:layout_weight=</span><span>"1"<br/></span><span>              </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span>              </span><span>android</span><span>:gravity=</span><span>"center"</span>&gt;<br/>        &lt;<span>TextView<br/></span><span>              </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:text=</span><span>"@string/current_score"<br/></span><span>              </span><span>android</span><span>:textAllCaps=</span><span>"true"<br/></span><span>              </span><span>android</span><span>:textStyle=</span><span>"bold"<br/></span><span>              </span><span>android</span><span>:textSize=</span><span>"14sp"</span>/&gt;<br/>         &lt;<span>TextView<br/></span><span>              </span><span>android</span><span>:id=</span><span>"@+id/tv_current_score"<br/></span><span>              </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:textSize=</span><span>"18sp"</span>/&gt;<br/>         &lt;<span>TextView<br/></span><span>              </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/layout_margin_top"<br/></span><span>              </span><span>android</span><span>:text=</span><span>"@string/high_score"<br/></span><span>              </span><span>android</span><span>:textAllCaps=</span><span>"true"<br/></span><span>              </span><span>android</span><span>:textStyle=</span><span>"bold"<br/></span><span>              </span><span>android</span><span>:textSize=</span><span>"14sp"</span>/&gt;<br/>         &lt;<span>TextView<br/></span><span>              </span><span>android</span><span>:id=</span><span>"@+id/tv_high_score"<br/></span><span>              </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>              </span><span>android</span><span>:textSize=</span><span>"18sp"</span>/&gt;<br/>       &lt;/<span>LinearLayout</span>&gt;<br/>       &lt;<span>Button</span><span><br/></span><span>               </span><span>android</span><span>:id=</span><span>"@+id/btn_restart"<br/></span><span>               </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>               </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>               </span><span>android</span><span>:text=</span><span>"@string/btn_restart"</span>/&gt;<br/>     &lt;/<span>LinearLayout</span>&gt;<br/>     &lt;<span>View<br/></span><span>           </span><span>android</span><span>:layout_width=</span><span>"1dp"<br/></span><span>           </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>           </span><span>android</span><span>:background=</span><span>"#000"</span>/&gt;<br/>     &lt;<span>LinearLayout<br/></span><span>            </span><span>android</span><span>:layout_width=</span><span>"0dp"<br/></span><span>            </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>            </span><span>android</span><span>:layout_weight=</span><span>"9"</span>&gt;<br/>       <span>&lt;!-- Adding TetrisView --&gt;<br/></span><span>       </span>&lt;<span>com.mydomain.tetris.views.TetrisView<br/></span><span>                </span><span>android</span><span>:id=</span><span>"@+id/view_tetris"<br/></span><span>                </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>                </span><span>android</span><span>:layout_height=</span><span>"match_parent" </span>/&gt;<br/><br/>     &lt;/<span>LinearLayout</span>&gt;<br/>   &lt;/<span>LinearLayout</span>&gt;<br/>&lt;/<span>android.support.constraint.ConstraintLayout</span>&gt;</pre>
<p class="p1"><span class="s1">Once you have added the&#160;<kbd>tetris</kbd> view to <kbd>activity_game.xml</kbd>, open the <kbd>GameActivity</kbd> class and employ the changes to the class shown in the following code block:</span></p>
<pre><span>package </span>com.mydomain.tetris<br/><span><br/></span><span>import </span>android.os.Bundle<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.view.MotionEvent<br/><span>import </span>android.view.View<br/><span>import </span>android.widget.Button<br/><span>import </span>android.widget.TextView<br/><span>import </span>com.mydomain.tetris.models.AppModel<br/><span>import </span>com.mydomain.tetris.storage.AppPreferences<br/><span>import </span>com.mydomain.tetris.views.TetrisView<br/><br/><span>class </span>GameActivity: AppCompatActivity() {<br/><br/>  <span>var </span><span>tvHighScore</span>: TextView? = <span>null<br/></span><span>  var </span><span>tvCurrentScore</span>: TextView? = <span>null<br/></span><span>  private lateinit var </span><span>tetrisView</span>: TetrisView<span> <br/></span><span><br/></span><span>  var </span><span>appPreferences</span>: AppPreferences? = <span>null<br/></span><span>  private val </span><span>appModel</span>: AppModel = AppModel() <br/><br/>  <span>public override fun </span>onCreate(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<span>activity_game</span>)<br/>    <span>appPreferences </span>= AppPreferences(<span>this</span>)<br/>    <span>appModel</span>.setPreferences(<span>appPreferences</span>) <br/><br/>    <span>val </span>btnRestart = findViewById&lt;Button&gt;(R.id.<span>btn_restart</span>)<br/>    <span>tvHighScore </span>= findViewById<span>&lt;TextView&gt;</span>(R.id.<span>tv_high_score</span>)<br/>    <span>tvCurrentScore </span>= findViewById<span>&lt;TextView&gt;</span>(R.id.<span>tv_current_score</span>)<br/>    <span>tetrisView </span>= findViewById<span>&lt;TetrisView&gt;</span>(R.id.<span>view_tetris</span>) <br/>    <span>tetrisView</span>.setActivity(<span>this</span>) <br/>    <span>tetrisView</span>.setModel(<span>appModel</span>) <br/><br/>    <span>tetrisView</span>.setOnTouchListener(<span>this</span>::onTetrisViewTouch)<br/>    btnRestart.setOnClickListener(<span>this</span>::btnRestartClick)<br/><br/>    updateHighScore()<br/>    updateCurrentScore()<br/>  }<br/><br/>  <span>private fun </span>btnRestartClick(view: View) {<br/>    a<span>ppModel</span>.restartGame()<br/>  }<br/><br/>  <span>private fun </span>onTetrisViewTouch(view: View, event: MotionEvent):<br/>              Boolean {<br/>    <span>if </span>(<span>appModel</span>.isGameOver() || <span>appModel</span>.isGameAwaitingStart()) {<br/>      <span>appModel</span>.startGame()<br/>      <span>tetrisView</span>.setGameCommandWithDelay(AppModel.Motions.<span>DOWN</span>)<br/><br/>    } <span>else if</span>(<span>appModel</span>.isGameActive()) {<br/>      <span>when </span>(resolveTouchDirection(view, event)) {<br/>        <span>0 </span>-&gt; moveTetromino(AppModel.Motions.<span>LEFT</span>)<br/>        <span>1 </span>-&gt; moveTetromino(AppModel.Motions.<span>ROTATE</span>)<br/>        <span>2 </span>-&gt; moveTetromino(AppModel.Motions.<span>DOWN</span>)<br/>        <span>3 </span>-&gt; moveTetromino(AppModel.Motions.<span>RIGHT</span>)<br/>      }<br/>    }<br/>    <span>return true<br/></span><span>  </span>}<br/><br/>  <span>private fun </span>resolveTouchDirection(view: View, event: MotionEvent): <br/>              Int {<br/>    <span>val </span>x = event.<span>x </span>/ view.<span>width<br/></span><span>    </span><span>val </span>y = event.<span>y </span>/ view.<span>height<br/></span><span>    </span><span>val </span>direction: Int<br/><br/>    direction = <span>if </span>(y &gt; x) {<br/>      <span>if </span>(x &gt; <span>1 </span>- y) <span>2 </span><span>else </span><span>0 <br/></span>    } <br/><span>    else </span>{<br/>      <span>if </span>(x &gt; <span>1 </span>- y) <span>3 </span><span>else </span><span>1<br/></span><span>    </span>}<br/>    <span>return </span>direction<br/>  }<br/><br/>  <span>private fun </span>moveTetromino(motion: AppModel.Motions) {<br/>    <span>if </span>(<span>appModel</span>.isGameActive()) {<br/>      <span>tetrisView</span>.setGameCommand(motion)<br/>    }<br/>  }<br/><br/>  <span>private fun </span>updateHighScore() {<br/>    <span>tvHighScore</span>?.<span>text </span>= <span>"</span><span>${</span><span>appPreferences</span>?.getHighScore()<span>}</span><span>"<br/></span><span>  </span>}<br/><br/>  <span>private fun </span>updateCurrentScore() {<br/>    <span>tvCurrentScore</span>?.<span>text </span>= <span>"0"<br/></span><span>  </span>}<br/>}</pre>
<p>We added an object reference to the <kbd>tetris</kbd> view layout element in <kbd>activity_game.xml</kbd> in the form of the <kbd>tetrisView</kbd> property; we also created an instance of <kbd>AppModel</kbd> that will be used by <kbd>GameActivity</kbd>. In <kbd>oncreate()</kbd>, we set the activity in use by <kbd>tetrisView</kbd> to the current instance of the <kbd>GameActivity</kbd> and set the model in use by <kbd>tetrisView</kbd> to <kbd>appModel</kbd> – the <kbd>AppModel</kbd> instance property we created. In addition, the on-touch listener for&#160;<kbd>tetrisView</kbd><span>&#160;</span><span>was set to the</span> <kbd>onTetrisViewTouch()</kbd> <span>function.</span></p>
<p>If <kbd>tetrisView</kbd> is touched and the game is in an <kbd>AWAITING_START</kbd> or <kbd>OVER</kbd> state, a new game is started. If <kbd>tetrisView</kbd> is touched and the game is in its <kbd>ACTIVE</kbd> state, the direction in which the touch on <kbd>tetrisView</kbd> occurred is resolved with the help of <kbd>resolveTouchDirection()</kbd>. <kbd>moveTetromino()</kbd> is used to move a tetromino block based on the action passed to it. If a left touch occurred, <kbd>moveTetromino()</kbd> is called with <kbd>AppModel.Motions.LEFT</kbd> set as its argument. This results in the movement of the tetromino to the left on the field. Right, down, and up touches on <kbd>tetrisView</kbd> result in rightward, downward, and rotational motions.</p>
<p>Having made all the additions, build and run the project. Once the project launches on your desired device, navigate to game activity and touch the&#160;<kbd>tetris</kbd> view to the right of the screen. The game will start:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/47512283-ebce-429b-aa3c-9014c625a66d.jpg" style="width:14.42em;height:25.92em;"/></div>
<p>Feel free to play around with the game you created. You deserve it!</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to Model-View-Presenter (MVP)</h1>
                </header>
            
            <article>
                
<p>Over the course of developing the Tetris application, we attempted to add structure across our code base by separating out program files into different packages based on the tasks they performed. We tried to abstract application logic into the <kbd>AppModel</kbd> class, and user interactions related to gameplay to be handled by the <kbd>TetrisView</kbd> view class. This certainly brought some order into our code base in contrast with, say, putting all logic into one big class file.</p>
<p>Needless to say, there are better ways to separate concerns within an Android application. One way is the&#160;MVP&#160;pattern.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is MVP?</h1>
                </header>
            
            <article>
                
<p>MVP is a common pattern in Android that is derived from the <strong>Model-View-Controller</strong>&#160;(<strong>MVC</strong>) pattern. MVP attempts to view related concerns from application logic. There are many reasons for which this is done, such as:</p>
<ul>
<li>To increase the maintainability of a code base</li>
<li>To improve application reliability</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="images/c1c00988-da9a-422a-80ae-784431176d2f.jpg" style="width:24.17em;height:5.67em;"/></div>
<p>&#160;Let's familiarize ourselves with the actors in the MVP pattern.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Model</h1>
                </header>
            
            <article>
                
<p>In MVP, models are interfaces that have the task of managing data. The responsibilities of models include interacting with databases, making API calls, communicating over networks, and coordinating objects and other programmatic components to perform specific tasks.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View&#160;&#160;</h1>
                </header>
            
            <article>
                
<p>Views are application entities that display content to users and serve as an interface for user input. A view can be an activity, a fragment, or an Android widget. A view is responsible for rendering data in a way decided upon by the presenter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Presenter</h1>
                </header>
            
            <article>
                
<p>A presenter is a layer that acts as a middleman between a view and a model. The major responsibility of the presenter is querying the model and updating a view. Put simply, presentation logic goes into the presenter. An important thing to keep in mind is that a presenter has a one-to-one relationship with a view.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Varying implementations of MVP</h1>
                </header>
            
            <article>
                
<p>The MVP pattern has varying means by which it is implemented in practice. For example, some implementations of MVP utilize a <em>contract</em> to describe the interaction between the view and presenter.</p>
<p>In addition, there are implementations of MVP that utilize lifecycle callbacks within the presenter, such as <kbd>onCreate()</kbd>. This is in an attempt to mirror callbacks existing in the activity lifecycle. Other implementations discard the implementation of these callbacks entirely.</p>
<p>In reality, there is no one true implementation of MVP in Android applications, but there are best practices that can be followed while implementing MVP. You will learn about these best practices and have hands-on experience with developing an MVP application with Kotlin in <a href="kt-prog-ex_ch05.html">Chapter 5</a>, <em>Building the Messenger Android App</em>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we got down and dirty with Kotlin by implementing a classic game, <em>Tetris</em>. Over the course of this chapter, we learned about a vast array of things, such as how to model logical components of an application with classes, access and visibility modifiers, how to create views and handlers in Android applications, the utilization of data classes to easily create data models, and the MVP pattern.</p>
<p>In the next chapter, we will apply our knowledge of Kotlin to the web domain by implementing the backend of a messenger application.</p>
<p class="mce-root"></p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>