<html><head></head><body>
<div id="_idContainer081">
<h1 class="chapter-number" id="_idParaDest-182"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-183"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.2.1">Getting Started with WorkManager</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In Android, </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">WorkManager</span></strong><span class="koboSpan" id="kobo.5.1"> is an API introduced by Google as part of the Android Jetpack library. </span><span class="koboSpan" id="kobo.5.2">It is a powerful and flexible background task scheduling library that allows you to perform deferrable, asynchronous tasks even when your app is not running or the device is in a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">low-power state.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">WorkManager</span></strong><span class="koboSpan" id="kobo.8.1"> provides a unified API to schedule tasks that need to be executed at a specific time or under certain conditions. </span><span class="koboSpan" id="kobo.8.2">It takes care of managing and running tasks efficiently, depending on factors such as device idle state, network connectivity, and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">battery level.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Furthermore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">WorkManager</span></strong><span class="koboSpan" id="kobo.12.1"> allows observation of work status and chain creation. </span><span class="koboSpan" id="kobo.12.2">This chapter will look into how we can implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">WorkManager</span></strong><span class="koboSpan" id="kobo.14.1"> using examples and learn how it works and its </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, weâ€™ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Understanding the Jetpack </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.20.1"> library</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Understanding </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1"> state</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Understanding threading </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">WorkManager</span></strong></span></li>
<li><span class="koboSpan" id="kobo.27.1">Understanding chaining and canceling </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">work requests</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Implementing migration from Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.31.1"> to the new recommended </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">WorkManager</span></strong></span></li>
<li><span class="koboSpan" id="kobo.33.1">How to </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">debug </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">WorkManager</span></strong></span></li>
<li><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.36.1">Testing </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">Worker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1"> implementations</span></span></li>
</ul>
<h1 id="_idParaDest-184"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.40.1">This chapter utilizes step-by-step examples and does not create a complete project. </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">WorkManager</span></strong><span class="koboSpan" id="kobo.42.1"> is helpful, but because the use case may vary, utilizing examples to see how the code fits your need is an excellent art to learn </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">in programming.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.44.1">Understanding the Jetpack WorkManager library</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.45.1">WorkManager</span></strong><span class="koboSpan" id="kobo.46.1"> is one of the most powerful Jetpack libraries, and it is used for persistent work. </span><span class="koboSpan" id="kobo.46.2">The API allows </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.47.1">observation of persistent status and the ability to </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.48.1">create a complex chain of work. </span><span class="koboSpan" id="kobo.48.2">When building Android applications, it might be a requirement to have your data persist; if you need help to refresh your knowledge, you can reference</span><em class="italic"> </em><a href="B18827_06.xhtml#_idTextAnchor283"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.50.1">, </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Using the Room Database </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">and Testing</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">WorkManager</span></strong><span class="koboSpan" id="kobo.55.1"> is the most-recommended API for any background process and is known to handle unique types of ongoing work as </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">shown here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Immediate</span></strong><span class="koboSpan" id="kobo.58.1">: As the name suggests, these are tasks that must be done immediately or </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">completed soon</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Long-Running</span></strong><span class="koboSpan" id="kobo.61.1">: Tasks that run for a </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">long time</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.63.1">Deferrable</span></strong><span class="koboSpan" id="kobo.64.1">: A task that can be rescheduled and can be assigned a different start time and can also </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">run periodically</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">Some more sample use cases where you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">WorkManager</span></strong><span class="koboSpan" id="kobo.68.1"> are, for instance, if your company wants to create custom notifications, send analytics events, upload images, periodically sync your local data with the network, and more. </span><span class="koboSpan" id="kobo.68.2">Furthermore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">WorkManager</span></strong><span class="koboSpan" id="kobo.70.1"> is the favored API and is highly recommended as it replaces all previous background scheduling APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">in Android.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">There are other APIs that are used for scheduling work. </span><span class="koboSpan" id="kobo.72.2">They are deprecated, and in this book, we will not cover them but will mention them since you might encounter them in work with legacy code; they are </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">Firebase </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">Job Dispatcher</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Job Scheduler</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.77.1">GCM </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">NetWorkManager</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">WorkManage</span><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.80.1">r</span></strong></span></li>
</ul>
<h2 id="_idParaDest-186"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.81.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.82.1">In this recipe, we will go ahead and look at a simple example of how we can create our own custom notification </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">You can also use the same concept to send logs or report analytics for your application if you are listening to </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.87.1">any logs. </span><span class="koboSpan" id="kobo.87.2">We opt for this task because sending notifications to your users is crucial, and most applications do this, compared to uploading images. </span><span class="koboSpan" id="kobo.87.3">In addition, with Android 13 and the new API, itâ€™s mandatory to </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">request </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">android.permission.POST_NOTIFICATION</span><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.90.1">S</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.92.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.93.1">For this recipe, you do not need to create a project, as the concepts can be used in an already-built project; instead, we will look at examples and walk through the examples </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">with explanations:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.95.1">We will need to ensure we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">required dependency:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.97.1">
implementation "androidx.work:work-runtime-ktx:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.98.1">
version-number"</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.99.1">You can get the latest </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">version number</span></strong><span class="koboSpan" id="kobo.101.1"> by following the documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">at </span></span><a href="https://developer.android.com/jetpack/androidx/releases/work"><span class="No-Break"><span class="koboSpan" id="kobo.103.1">https://developer.android.com/jetpack/androidx/releases/work</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.104.1">.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.105.1">Let us now go ahead and create our notification channel. </span><span class="koboSpan" id="kobo.105.2">For this, Google offers a great guide on how you can create one at </span><a href="https://developer.android.com/develop/ui/views/notifications/channels"><span class="koboSpan" id="kobo.106.1">https://developer.android.com/develop/ui/views/notifications/channels</span></a><span class="koboSpan" id="kobo.107.1">, so copy the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.109.1">
private fun createCustomNotificationChannel() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.110.1">
Â Â Â Â if (Build.VERSION.SDK_INT &gt;=</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
Â Â Â Â Build.VERSION_CODES.O) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
Â Â Â Â Â Â Â Â val name = getString(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.113.1">
Â Â Â Â Â Â Â Â Â Â Â Â R.string.notification_channel)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.114.1">
Â Â Â Â Â Â Â Â val notificationDescription = getString(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
Â Â Â Â Â Â Â Â Â Â Â Â R.string.notification_description)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
Â Â Â Â Â Â Â Â val importance =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.117.1">
Â Â Â Â Â Â Â Â Â Â Â Â NotificationManager.IMPORTANCE_DEFAULT</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
Â Â Â Â Â Â Â Â val channel = NotificationChannel(CHANNEL_ID,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.119.1">
Â Â Â Â Â Â Â Â name, importance).apply </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">{</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.121.1">Â Â Â Â Â Â Â Â Â Â Â Â </span></strong><span class="koboSpan" id="kobo.122.1">description = notificationDescription</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.123.1">
Â Â Â Â Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.125.1">
Â Â Â Â Â Â Â Â // Register the channel with the system</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.126.1">
Â Â Â Â Â Â Â Â val notificationManager: NotificationManager =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.127.1">
Â Â Â Â Â Â Â Â Â Â Â Â getSystemService(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.128.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Context.NOTIFICATION_SERVICE) as</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.129.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â NotificationManager</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.130.1">
Â Â Â Â Â Â Â Â notificationManager.createNotificationChannel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.131.1">
Â Â Â Â Â Â Â Â Â Â Â Â channel)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.132.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.133.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.134.1">Also, note that creating </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.135.1">different channels for separating notification types is possible. </span><span class="koboSpan" id="kobo.135.2">As recommended in Android 13, this makes it easier for users to turn them on and off if they do not need them. </span><span class="koboSpan" id="kobo.135.3">For example, a user might want to be aware of the latest brands your app is selling, compared to you sending your users info about old </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">existing brands.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.137.1">Now we can create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">workManagerInstance</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">Let us think of a scenario where we need to fetch data from our servers every 20 or 30 mins and check whether notifications are available. </span><span class="koboSpan" id="kobo.139.3">In that case, we might encounter an issue where users are no longer using our application, which means the application will be put in the background, or the process might even </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">be killed.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.141.1">Hence the question becomes how do we fetch the data when the application is killed? </span><span class="koboSpan" id="kobo.141.2">This is when </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">WorkManager</span></strong><span class="koboSpan" id="kobo.143.1"> comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the rescue.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.145.1">We can now create an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.149.1">
val workManagerInstance = WorkManager.getInstance(application.applicationContext)</span></pre></li>
<li><span class="koboSpan" id="kobo.150.1">We will now need to go ahead and set </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the constraints:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
val ourConstraints = Constraints.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
Â Â Â Â .setRequiredNetworkType(NetworkType.CONNECTED)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
Â Â Â Â .setRequiresBatteryNotLow(false)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
Â Â Â Â .build()</span></pre></li>
<li><span class="koboSpan" id="kobo.156.1">We will also </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.157.1">need to set data to pass to the worker; hence we will create new value data, then we will put a string to the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">endpoint request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
val data = Data.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
data.putString(ENDPOINT_REQUEST, endPoint)</span></pre></li>
<li><span class="koboSpan" id="kobo.161.1">Now we can go ahead and create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">PeriodicWorkRequestBuilder&lt;GetDataWorker&gt;</span></strong><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">In our work, we will set the constraints, set our input data, and pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">GetDataWorker()</span></strong><span class="koboSpan" id="kobo.165.1"> type, which we will create and then build. </span><span class="koboSpan" id="kobo.165.2">Furthermore, since we want to be fetching the data every 20 or 30 mins from our server, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">PeriodicWorkRequestBuilder&lt;Type&gt;()</span></strong><span class="koboSpan" id="kobo.167.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">that purpose:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.169.1">
val job =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.170.1">
Â Â Â Â PeriodicWorkRequestBuilder&lt;GetDataWorker&gt;(20,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
Â Â Â Â Â Â Â Â TimeUnit.MINUTES)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
Â Â Â Â .setConstraints(ourConstraints)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
Â Â Â Â .setInputData(data.build())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.174.1">
Â Â Â Â .build()</span></pre></li>
<li><span class="koboSpan" id="kobo.175.1">We can now finally call </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">workManagerInstance</span></strong><span class="koboSpan" id="kobo.177.1"> and enqueue </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">our job:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.179.1">
workManagerInstance</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.180.1">
Â Â Â Â .enqueue(work)</span></pre></li>
<li><span class="koboSpan" id="kobo.181.1"> We can now go ahead and construct our </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">GetDataWorker()</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">In this class, we will extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Worker</span></strong><span class="koboSpan" id="kobo.185.1"> class, which will override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">doWork()</span></strong><span class="koboSpan" id="kobo.187.1"> function. </span><span class="koboSpan" id="kobo.187.2">In our case, however, instead </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.188.1">of extending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Worker</span></strong><span class="koboSpan" id="kobo.190.1"> class, we will extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">CoroutineWorker(context, workerParameters)</span></strong><span class="koboSpan" id="kobo.192.1">, which will help in our case since we will collect this data in a flow. </span><span class="koboSpan" id="kobo.192.2">We will also be using Hilt, so we will </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">@HiltWorker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
@HiltWorker</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.197.1">
class GetDataWorker @AssistedInject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.198.1">
Â Â Â Â @Assisted context: Context,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.199.1">
Â Â Â Â @Assisted workerParameters: WorkerParameters,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.200.1">
Â Â Â Â private val viewModel: NotificationViewModel</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.201.1">
) : CoroutineWorker(context, workerParameters) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.202.1">
Â Â Â Â override suspend fun doWork(): Result {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
Â Â Â Â Â Â Â Â val ourEndPoint = inputData.getString(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.204.1">
Â Â Â Â Â Â Â Â Â Â Â Â NotificationConstants.ENDPOINT_REQUEST)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.205.1">
Â Â Â Â Â Â Â Â if (endPoint != null) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.206.1">
Â Â Â Â Â Â Â Â Â Â Â Â getData(endPoint)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.207.1">
Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.208.1">
Â Â Â Â Â Â Â Â val dataToOutput = Data.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
Â Â Â Â Â Â Â Â Â Â Â Â .putString(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.210.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â NotificationConstants.NOTIFICATION_DATA,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.211.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Data")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
Â Â Â Â Â Â Â Â Â Â Â Â .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
Â Â Â Â Â Â Â Â return Result.success(dataToOutput)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
Â Â Â Â }</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.215.1">In our case, we are returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">success.</span></strong><span class="koboSpan" id="kobo.217.1"> In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">getData()</span></strong><span class="koboSpan" id="kobo.219.1"> function, we pass in the </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.220.1">endpoint, and we can assume our data has two or three crucial attributes: the ID, the title, and </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the description.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.222.1">We can now </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">send notifications:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.224.1">
val notificationIntent = Intent(this, NotifyUser::class.java).apply </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">{</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.226.1">Â Â Â Â </span></strong><span class="koboSpan" id="kobo.227.1">flags = Intent.FLAG_ACTIVITY_NEW_TASK or</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
Â Â Â Â Â Â Â Â Intent.FLAG_ACTIVITY_CLEAR_TASK</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.229.1">}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.230.1">
notificationIntent.putExtra(NOTIFICATION_EXTRA, true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
notificationIntent.putExtra(NOTIFICATION_ID, notificationId)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
val notifyPendingIntent = PendingIntent.getActivity(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
Â Â Â Â this, 0, notificationIntent,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.234.1">
Â Â Â Â PendingIntent.FLAG_UPDATE_CURRENT</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.235.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
val builder = NotificationCompat</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
Â Â Â Â .Builder(context, Channel_ID_DEFAULT)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.238.1">
Â Â Â Â .setSmallIcon(notificationImage)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
Â Â Â Â .setContentTitle(notificationTitle)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.240.1">
Â Â Â Â .setContentText(notificationContent)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.241.1">
Â Â Â Â .setPriority(NotificationCompat.PRIORITY_HIGH)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
Â Â Â Â .setContentIntent(notifyPendingIntent)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.243.1">
Â Â Â Â .setAutoCancel(true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.244.1">
with(NotificationManagerCompat.from(context)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.245.1">
Â Â Â Â notify(notificationId, builder.build())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.247.1">We also need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">PendingIntent.getActivity()</span></strong><span class="koboSpan" id="kobo.249.1">, which means when there is a </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.250.1">click on the notification, the user will start an activity. </span><span class="koboSpan" id="kobo.250.2">For this to happen, we can </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">getStringExtra(NotificationConstants.NOTIFICATION_ID)</span></strong><span class="koboSpan" id="kobo.252.1"> when a notification is clicked and put extras in our intent. </span><span class="koboSpan" id="kobo.252.2">This will need to happen in </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">our activity:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.254.1">
private fun verifyIntent(intent: Intent?) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
Â Â Â Â intent?.let </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">{</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.257.1">Â Â Â Â </span></strong><span class="koboSpan" id="kobo.258.1">Â Â Â Â if (it.hasExtra(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.259.1">
Â Â Â Â Â Â Â Â Â Â Â NotificationConstants.NOTIFICATION_EXTRA)){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.260.1">
Â Â Â Â Â Â Â Â Â Â Â it.getStringExtra(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
Â Â Â Â Â Â Â Â Â Â Â NotificationConstants.NOTIFICATION_ID)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.263.1">
Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.266.1">And on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">onResume()</span></strong><span class="koboSpan" id="kobo.268.1">, we can now call our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">verifyIntent()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.271.1">
override fun onResume() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
Â Â Â Â super.onResume()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
Â Â Â Â verifyIntent(intent)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.274.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.275.1">And thatâ€™s it; we have custom notifications using </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">WorkMan</span><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.278.1">ager()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.280.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.281.1">When creating a notification, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">importance</span></strong><span class="koboSpan" id="kobo.283.1"> parameter helps determine how to interrupt the user for any given channel, hence why one should specify it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">NotificationChannel</span></strong><span class="koboSpan" id="kobo.285.1"> constructor. </span><span class="koboSpan" id="kobo.285.2">If the importance is high and the device is running Android 5.0+, youâ€™re going to see a heads-up notification, otherwise, it will just be the icon in </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.286.1">the status bar. </span><span class="koboSpan" id="kobo.286.2">However, it is essential to note that all notifications, regardless of their importance, appear in a non-interruptive UI at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">your screen.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">WorkManager</span></strong><span class="koboSpan" id="kobo.290.1"> word is very straightforward, hence removing ambiguity from the API. </span><span class="koboSpan" id="kobo.290.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">WorkManager</span></strong><span class="koboSpan" id="kobo.292.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Work </span></strong><span class="koboSpan" id="kobo.294.1">is referenced utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Worker</span></strong><span class="koboSpan" id="kobo.296.1"> class. </span><span class="koboSpan" id="kobo.296.2">In addition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">doWork()</span></strong><span class="koboSpan" id="kobo.298.1"> function that we call runs asynchronously in the background thread offered by </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">WorkManager()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">doWork()</span></strong><span class="koboSpan" id="kobo.304.1"> function returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Result{}</span></strong><span class="koboSpan" id="kobo.306.1">, and this result can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Success</span></strong><span class="koboSpan" id="kobo.308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Failure</span></strong><span class="koboSpan" id="kobo.310.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Retry</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">When we return the successful </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Result{}</span></strong><span class="koboSpan" id="kobo.314.1">, the work will be done and finished successfully. </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Failure</span></strong><span class="koboSpan" id="kobo.316.1">, as the name suggests, means the work failed, and then we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Retry</span></strong><span class="koboSpan" id="kobo.318.1">, which retries </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the work.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">GetDataWorker()</span></strong><span class="koboSpan" id="kobo.322.1">, we pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">NotificationViewModel</span></strong><span class="koboSpan" id="kobo.324.1"> and inject it into our worker using Hilt. </span><span class="koboSpan" id="kobo.324.2">Sometimes you might encounter a conflict. </span><span class="koboSpan" id="kobo.324.3">The good thing is there is support for such a case with four options for handling any conflict that </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">might occur.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">This case is unique to when you are scheduling unique work; it makes sense to tell </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">WorkManager</span></strong><span class="koboSpan" id="kobo.328.1"> what action must be taken when a conflict arises. </span><span class="koboSpan" id="kobo.328.2">You can solve this problem easily by using the existing work policy, </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">ExisitingWorkPolicy</span></strong><span class="koboSpan" id="kobo.330.1">, which has </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">REPLACE</span></strong><span class="koboSpan" id="kobo.332.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">KEEP APPEND</span></strong><span class="koboSpan" id="kobo.334.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">APPEND_OR_REPLACE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Replace</span></strong><span class="koboSpan" id="kobo.339.1">, as the name suggests, replaces the existing work, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Keep</span></strong><span class="koboSpan" id="kobo.341.1"> keeps existing work and ignores </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.342.1">new work. </span><span class="koboSpan" id="kobo.342.2">When you call </span><em class="italic"><span class="koboSpan" id="kobo.343.1">Append</span></em><span class="koboSpan" id="kobo.344.1">, this adds the new work to the existing one, and finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Append or Replace</span></strong><span class="koboSpan" id="kobo.346.1"> simply does not depend on the pre-requisite </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">work state.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.348.1">Important note</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">WorkManager</span></strong><span class="koboSpan" id="kobo.350.1"> is a singleton, hence it can only be initialized once, that is, either in your app or in the library. </span><span class="koboSpan" id="kobo.350.2">And, if </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.351.1">you are using any workers with custom dependencies, then you have to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">WorkerFactory()</span></strong><span class="koboSpan" id="kobo.353.1"> to the config at the time of </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">custom initi</span><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.355.1">alization.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.356.1">Thereâ€™s moreâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.357.1">We can only cover some </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">WorkManager</span></strong><span class="koboSpan" id="kobo.359.1"> steps here. </span><span class="koboSpan" id="kobo.359.2">Google has great sample code labs that you can follow through and understand how to </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">To read </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.364.1">more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">WorkManager</span></strong><span class="koboSpan" id="kobo.366.1">, you can use this </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">link: </span></span><a href="https://developer.android.com/guide/background/persistent"><span class="No-Break"><span class="koboSpan" id="kobo.368.1">https://developer.android.com/guide/background/persistent</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.370.1">Understanding WorkManager state</span></h1>
<p><span class="koboSpan" id="kobo.371.1">In the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.372.1">Understanding the Jetpack WorkManager library</span></em><span class="koboSpan" id="kobo.373.1">, we looked into how </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.374.1">we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">WorkManager</span></strong><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">In that recipe, you might have noticed </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Work</span></strong><span class="koboSpan" id="kobo.378.1"> goes through a series of state changes, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">doWork</span></strong><span class="koboSpan" id="kobo.380.1"> function returns </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">a result.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">In this recipe, we will explore stat</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.383.1">es </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">in depth.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.385.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.386.1">We will continue working on an example of how you can apply the concepts learned about in this recipe to your </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">already-built project:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.388.1">You might have noticed we mentioned before that we have three states: </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Success</span></strong><span class="koboSpan" id="kobo.390.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Failure</span></strong><span class="koboSpan" id="kobo.392.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Retry</span></strong><span class="koboSpan" id="kobo.394.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Work</span></strong><span class="koboSpan" id="kobo.396.1"> states, however, have different types of processes; we can have a one-time work state, periodic work state, or </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">blocked state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
Result</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
Â Â Â Â SUCCESS, FAILURE, RETRY</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.400.1">You can look into this abstract class in more depth by clicking on the result and seeing how it </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">is written.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.402.1">In the first recipe, </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Understanding the Jetpack WorkManager library</span></em><span class="koboSpan" id="kobo.404.1">, we looked into the </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.405.1">steps of setting up </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">WorkManager</span></strong><span class="koboSpan" id="kobo.407.1">. </span><span class="koboSpan" id="kobo.407.2">Another great example is downloading files. </span><span class="koboSpan" id="kobo.407.3">You can override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">fun doWork()</span></strong><span class="koboSpan" id="kobo.409.1"> and check whether your URI is not equal to null and return a success, </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">else failure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
override suspend fun doWork(): Result {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
Â Â Â Â val file = inputData.getString(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.413.1">
Â Â Â Â Â Â Â Â FileParameters.KEY_FILE_NAME) ?: ""</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
Â Â Â Â if (file.isEmpty()){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
Â Â Â Â Â Â Â Â Result.failure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.417.1">
Â Â Â Â val uri = getSavedFileUri(fileName = file,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
Â Â Â Â Â Â Â Â context = context)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
Â Â Â Â return if (uri != null){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
Â Â Â Â Â Â Â Â Result.success(workDataOf(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
Â Â Â Â Â Â Â Â Â Â Â Â FileParameters.KEY_FILE_URI to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â uri.toString()))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
Â Â Â Â }else{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
Â Â Â Â Â Â Â Â Result.failure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.425.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.426.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.427.1">When handling a state, you can easily check when the state successfully specifies an </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.428.1">action, when it failed to perform an action, and finally, when </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">WorkInfo.State</span></strong><span class="koboSpan" id="kobo.430.1"> is equals to </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">RUNNING</span></strong><span class="koboSpan" id="kobo.432.1">, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">running()</span></strong><span class="koboSpan" id="kobo.434.1">; see the following </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.436.1">
when (state) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.437.1">
Â Â Â Â WorkInfo.State.SUCCEEDED -&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
Â Â Â Â Â Â Â Â success(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.439.1">
Â Â Â Â Â Â Â Â Â Â Â Â //do something</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.440.1">
Â Â Â Â Â Â Â Â )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.441.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
Â Â Â Â WorkInfo.State.FAILED -&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.443.1">
Â Â Â Â Â Â Â Â failed("Downloading failed!")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.444.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.445.1">
Â Â Â Â WorkInfo.State.RUNNING -&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.446.1">
Â Â Â Â Â Â Â Â running()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
Â Â Â Â else -&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.449.1">
Â Â Â Â Â Â Â Â failed("Something went wrong")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.452.1">The success result returns an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">ListenableWorker.Result</span></strong><span class="koboSpan" id="kobo.454.1">, used to indicate that the work was </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">completed successfully.</span></span></li>
<li><span class="koboSpan" id="kobo.456.1">For the mentioned states, you can either use </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">enqueueUniqueWork()</span></strong><span class="koboSpan" id="kobo.458.1">, which is used for one time, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">PeriodicWorkRequestBuilder</span></strong><span class="koboSpan" id="kobo.460.1">, which is used for periodic work. </span><span class="koboSpan" id="kobo.460.2">In our example, we </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">used </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">PeriodicWorkRequestBuilder&lt;Type&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.464.1">
WorkManager.enqueueUniqueWork()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.465.1">
WorkManager.enqueueUnique</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.466.1">PeriodicWork()</span></pre></li>
</ol>
<h2 id="_idParaDest-192"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.467.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.468.1">We always start our request with the </span><em class="italic"><span class="koboSpan" id="kobo.469.1">Enqueued</span></em><span class="koboSpan" id="kobo.470.1"> state for the one-time work state, which means the work will run as soon as the constraints are met. </span><span class="koboSpan" id="kobo.470.2">Thereafter, we move to </span><em class="italic"><span class="koboSpan" id="kobo.471.1">Running</span></em><span class="koboSpan" id="kobo.472.1">, and if we hit a </span><em class="italic"><span class="koboSpan" id="kobo.473.1">Success</span></em><span class="koboSpan" id="kobo.474.1">, the work </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">is done.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">If in any instance, we </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.477.1">end up </span><em class="italic"><span class="koboSpan" id="kobo.478.1">Running</span></em><span class="koboSpan" id="kobo.479.1"> and we donâ€™t hit </span><em class="italic"><span class="koboSpan" id="kobo.480.1">Success</span></em><span class="koboSpan" id="kobo.481.1">, then it means we failed. </span><span class="koboSpan" id="kobo.481.2">Then, we will move back to </span><em class="italic"><span class="koboSpan" id="kobo.482.1">Enqueued</span></em><span class="koboSpan" id="kobo.483.1"> since we need to retry. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.484.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.485.1">.1</span></em><span class="koboSpan" id="kobo.486.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.487.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.488.1">.2</span></em><span class="koboSpan" id="kobo.489.1"> explain the states better for both one-time work and periodic </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">work states.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">Finally, if it happens that our enqueued work gets cancelled, then we move it </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">to cancelled.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.493.1"><img alt="Figure 7.1 â€“ How one-time work requests work" src="image/Figure_7.1_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.494.1">Figure 7.1 â€“ How one-time work requests work</span></p>
<p><span class="koboSpan" id="kobo.495.1">While the preceding </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.496.1">image shows the one-time work state, the following diagram depicts the periodic </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">work state.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.498.1"><img alt="Figure 7.2 â€“ How the periodic woï»¿rk state works" src="image/Figure_7.2_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.499.1">Figure 7.2 â€“ How the periodic wo</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.500.1">rk state works</span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.501.1">Understanding threading in WorkManager</span></h1>
<p><span class="koboSpan" id="kobo.502.1">You can think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">WorkManager</span></strong><span class="koboSpan" id="kobo.504.1"> as any process that runs in a background thread. </span><span class="koboSpan" id="kobo.504.2">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Worker()</span></strong><span class="koboSpan" id="kobo.506.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">WorkManager</span></strong><span class="koboSpan" id="kobo.508.1"> calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">doWork()</span></strong><span class="koboSpan" id="kobo.510.1"> function, this action works in the </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.511.1">background thread. </span><span class="koboSpan" id="kobo.511.2">In detail, the background thread comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Executor</span></strong><span class="koboSpan" id="kobo.513.1"> specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1"> configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">You can also create your own custom executor for your application needs, but if thatâ€™s not needed, you can use the pre-existing one. </span><span class="koboSpan" id="kobo.516.2">This recipe will explore how threading in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Worker()</span></strong><span class="koboSpan" id="kobo.518.1"> works and how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">c</span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.520.1">ustom executor.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.521.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.522.1">In this recipe, since we will be looking at examples, you can follow along by reading and seeing if this a</span><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.523.1">pplies </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">to you.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.525.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.526.1">Letâ€™s learn how threading works </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.530.1">In order to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">WorkManager</span></strong><span class="koboSpan" id="kobo.532.1"> manually, you will need to specify your executor. </span><span class="koboSpan" id="kobo.532.2">This can be done by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">WorkManager.initialize()</span></strong><span class="koboSpan" id="kobo.534.1">, then passing the context, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">configuration builder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.536.1">
WorkManager.initialize(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.537.1">
Â Â Â Â context,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.538.1">
Â Â Â Â Configuration.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.539.1">
Â Â Â Â Â Â Â Â .setExecutor(Executors.newFixedThreadPool(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.540.1">
Â Â Â Â Â Â Â Â Â Â Â Â CONSTANT_THREAD_POOL_INT))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.541.1">
Â Â Â Â Â Â Â Â .build())</span></pre></li>
<li><span class="koboSpan" id="kobo.542.1">In our earlier example in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.543.1">Understanding WorkManager state</span></em><span class="koboSpan" id="kobo.544.1">, we spoke </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.545.1">about a use case where we download files. </span><span class="koboSpan" id="kobo.545.2">These files can be in the form of PDF, JPG, PNG, or even MP4. </span><span class="koboSpan" id="kobo.545.3">We will look at an example that downloads content 20 times; you can specify how many times you want your content </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">to download:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
class GetFiles(context: Context, params: WorkerParameters) : Worker(context, params) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
Â Â Â Â override fun doWork(): ListenableWorker.Result {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.549.1">
Â Â Â Â Â Â Â Â repeat(20) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
Â Â Â Â Â Â Â Â Â Â Â Â try {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â downloadSynchronously("Your Link")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
Â Â Â Â Â Â Â Â Â Â Â Â } catch (e: IOException) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ListenableWorker.Result.failure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
Â Â Â Â Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
Â Â Â Â Â Â Â Â return ListenableWorker.Result.success()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.559.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.560.1">Currently, if we do not handle the case where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Worker()</span></strong><span class="koboSpan" id="kobo.562.1"> is stopped, it is good practice to </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.563.1">ensure that it is dealt with because this is an edge case. </span><span class="koboSpan" id="kobo.563.2">To address this case, we need to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Worker.onStopped()</span></strong><span class="koboSpan" id="kobo.565.1"> method or call </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">Worker.isStopped</span></strong><span class="koboSpan" id="kobo.567.1"> where necessary to free up </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">some resources:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
Â Â Â Â override fun doWork(): ListenableWorker.Result {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
Â Â Â Â Â Â Â Â repeat(20) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.571.1">
Â Â Â Â Â Â Â Â Â Â Â Â if (isStopped) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.572.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.573.1">
Â Â Â Â Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
Â Â Â Â Â Â Â Â Â Â Â Â try {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.575.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â downloadSynchronously("Your Link")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.576.1">
Â Â Â Â Â Â Â Â Â Â Â Â } catch (e: IOException) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.578.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ListenableWorker.Result.failure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
Â Â Â Â Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
Â Â Â Â Â Â Â Â return ListenableWorker.Result.success()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
Â Â Â Â }</span></pre></li>
<li><span class="koboSpan" id="kobo.583.1">Finally, when you stop the worker, the result is entirely ignored until you restart the process again. </span><span class="koboSpan" id="kobo.583.2">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">CoroutineWorker</span></strong><span class="koboSpan" id="kobo.585.1"> in our earlier example since </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">WorkManager</span></strong><span class="koboSpan" id="kobo.587.1"> offers support for coroutines, hence why we collected the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">a flow.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.589.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.590.1">Customizing your executor will require manually </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">initiali</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.592.1">zing </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.595.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.596.1">There is more to learn in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">WorkManager</span></strong><span class="koboSpan" id="kobo.598.1"> Jetpack library, and it is fair to acknowledge </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.599.1">that it canâ€™t all be captured in just a few recipes. </span><span class="koboSpan" id="kobo.599.2">For instance, in some scenarios, when providing a custom threading strategy, you should </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">ListenableWorker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.605.1"> is a class in the Android Jetpack </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">WorkManager</span></strong><span class="koboSpan" id="kobo.607.1"> library that allows you to perform background work in a flexible and efficient manner. </span><span class="koboSpan" id="kobo.607.2">It is a subclass of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Worker</span></strong><span class="koboSpan" id="kobo.609.1"> class and adds the ability to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">ListenableFuture</span></strong><span class="koboSpan" id="kobo.611.1"> from its </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">doWork()</span></strong><span class="koboSpan" id="kobo.613.1"> method, which allows for easier handling of </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">asynchronous operations.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.617.1">, you can create a worker that returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">ListenableFuture</span></strong><span class="koboSpan" id="kobo.619.1"> and register callbacks that will be executed when the future completes. </span><span class="koboSpan" id="kobo.619.2">This can be useful for tasks such as network requests or database operations that require </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">asynchronous operations.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">Worker</span></strong><span class="koboSpan" id="kobo.623.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">CoroutineWorker</span></strong><span class="koboSpan" id="kobo.625.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">RxWorker</span></strong><span class="koboSpan" id="kobo.627.1"> derive from this particular class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">Worker</span></strong><span class="koboSpan" id="kobo.629.1">, as mentioned, runs in the background thread; </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">CoroutineWorker</span></strong><span class="koboSpan" id="kobo.631.1"> is highly recommended for developers using Kotlin. </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">RxWorker</span></strong><span class="koboSpan" id="kobo.633.1"> will not be touched upon here since Rx by itself is a big topic that caters to users that develop in </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">rea</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.635.1">ctive programming.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.636.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.637.1">Your application might be using Rx. </span><span class="koboSpan" id="kobo.637.2">In that case, there are details on how threading works in Rx and </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.638.1">how you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">RxWorker</span></strong><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">See more </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">here: </span></span><a href="https://developer.android.com/guide/background/persistent/threading/rxworker"><span class="No-Break"><span class="koboSpan" id="kobo.642.1">https://developer.android.com/guide/background/persistent/threading/rxworker</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.643.1">.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.644.1">Understanding chaining and canceling work requests</span></h1>
<p><span class="koboSpan" id="kobo.645.1">In Android </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.646.1">development, ensuring you properly handle your applicationâ€™s life cycle is crucial. </span><span class="koboSpan" id="kobo.646.2">Needless to say, this also applies to all background work, as a simple </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.647.1">mistake can lead to your application draining the userâ€™s battery, memory leaks, or even causing the application to crash or suffer from an </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">application not responding</span></strong><span class="koboSpan" id="kobo.649.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.650.1">ANR</span></strong><span class="koboSpan" id="kobo.651.1">) error. </span><span class="koboSpan" id="kobo.651.2">This could </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.652.1">mean terrible reviews in the Play Store, which will later affect your business and causes stress for developers. </span><span class="koboSpan" id="kobo.652.2">How do you ensure this issue is </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">handled well?</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">This can be done by ensuring all conflicts that arise while using </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">WorkManager</span></strong><span class="koboSpan" id="kobo.656.1"> are appropriately handled or guaranteeing the policy we touched on in the previous recipe is well coded. </span><span class="koboSpan" id="kobo.656.2">In this recipe, we will look into chaining and canceling work requests and how to handle long-running </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">work properly.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">Say your project requires an order by which the operation should run; </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">WorkManager</span></strong><span class="koboSpan" id="kobo.660.1"> gives you the ability to enqueue and create a chain that specifies multiple dependent tasks, and here you can set the order in which you want th</span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.661.1">e operations </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">to occur.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.663.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.664.1">In this recipe, we will look at an example of how you might chain your work; since this is concept-based, we will look at the example and</span><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.665.1"> explain how </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">it works.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.667.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.668.1">To perform chaining using </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">WorkManager</span></strong><span class="koboSpan" id="kobo.670.1">, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.672.1">In our example, we will assume we have four unique </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Worker</span></strong><span class="koboSpan" id="kobo.674.1"> jobs to run in parallel. </span><span class="koboSpan" id="kobo.674.2">The output of these jobs will be passed to an upload </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Worker</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">Then, these will be uploaded to our server, like the sample project we had in the </span><em class="italic"><span class="koboSpan" id="kobo.677.1">Understanding the Jetpack WorkManager </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.678.1">library</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.679.1"> recipe.</span></span></li>
<li><span class="koboSpan" id="kobo.680.1">We will have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">WorkManager()</span></strong><span class="koboSpan" id="kobo.682.1"> and pass in our context; then we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">beginWith</span></strong><span class="koboSpan" id="kobo.684.1"> and pass a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">our jobs:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.686.1">
WorkManager.getInstance(context)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
Â Â Â Â .beginWith(listOf(job1, job2, job3, job4))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.688.1">
Â Â Â Â .then(ourCache)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.689.1">
Â Â Â Â .then(upload)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.690.1">
Â Â Â Â .enqueue()</span></pre></li>
<li><span class="koboSpan" id="kobo.691.1">To be able to maintain or preserve all our outputs from our job, we will need to use </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">ArrayCreatingInputMerger::class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
val ourCache: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;GetDataWorker&gt;()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.696.1">
Â Â Â Â .setInputMerger(ArrayCreatingInputMerger::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
Â Â Â Â .setConstraints(constraints)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.698.1">
Â Â Â Â .build()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.699.1">That is about it. </span><span class="koboSpan" id="kobo.699.2">There is definitely more to learn, but th</span><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.700.1">is serves </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">our purpose.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.702.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.703.1">To be able to </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.704.1">create the chain of work, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">WorkManager.beginWith(OneTimeWorkRequest)</span></strong><span class="koboSpan" id="kobo.706.1"> or use </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">WorkManager.beginWith</span></strong><span class="koboSpan" id="kobo.708.1"> and pass </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.709.1">a list of the one-time work requests that you </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">have specified.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">WorkManager.beginWith&lt;List&lt;OneTimeWorkRequest&gt;&gt;</span></strong><span class="koboSpan" id="kobo.713.1"> operations return an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">WorkContinuation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">WorkContinuation.enqueue()</span></strong><span class="koboSpan" id="kobo.719.1"> function to enqueue our </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">WorkContinuation</span></strong><span class="koboSpan" id="kobo.721.1"> chain. </span><span class="koboSpan" id="kobo.721.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">ArrayCreatingInputMerger</span></strong><span class="koboSpan" id="kobo.723.1"> ensures we pair each key with an array. </span><span class="koboSpan" id="kobo.723.2">In addition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">ArrayCreatingInputMerger</span></strong><span class="koboSpan" id="kobo.725.1"> is a class in the Android Jetpack </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">WorkManager</span></strong><span class="koboSpan" id="kobo.727.1"> library that allows you to merge input data from multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.729.1"> instances into a </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">single array.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">Furthermore, if our keys are </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">unique</span></strong><span class="koboSpan" id="kobo.733.1">, we will get a result of one-element arrays. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.734.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.735.1">.3</span></em><span class="koboSpan" id="kobo.736.1"> shows </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.738.1"><img alt="Figure 7.3 â€“ How the array creating input merger works" src="image/Figure_7.3_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.739.1">Figure 7.3 â€“ How the array creating input merger works</span></p>
<p><span class="koboSpan" id="kobo.740.1">If we have any </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.741.1">colliding keys, then our values will be grouped </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.742.1">together in our array, as in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.743.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.744.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 7.4 â€“ Key collision and result" src="image/Figure_7.4_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 7.4 â€“ Key collision and result</span></p>
<p><span class="koboSpan" id="kobo.748.1">The rule of thumb is chains of work typically execute sequentially. </span><span class="koboSpan" id="kobo.748.2">This is reliant on the work being </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.749.1">completed successfully. </span><span class="koboSpan" id="kobo.749.2">You might be wondering what </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.750.1">happens when the job is enqueued in a chain of several work requests; just like a regular queue, all subsequent work is temporarily blocked until the first work request is completed. </span><span class="koboSpan" id="kobo.750.2">Think of it a</span><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.751.1">s </span><em class="italic"><span class="koboSpan" id="kobo.752.1">first come, </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.753.1">first serve</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.755.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.756.1">You might be wondering </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.757.1">how you can support long-running workers; you can learn more </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">at </span></span><a href="https://developer.android.com/guide/background/persistent/how-to/long-running"><span class="No-Break"><span class="koboSpan" id="kobo.759.1">https://developer.android.com/guide/background/persistent/how-to/long-running</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.760.1">.</span></span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.761.1">Implementing migration from Firebase JobDispatcher to the new recommended WorkManager</span></h1>
<p><span class="koboSpan" id="kobo.762.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.763.1">Understanding the Jetpack WorkManager library</span></em><span class="koboSpan" id="kobo.764.1"> recipe, we talked about other </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.765.1">libraries that </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.766.1">are used for scheduling and executing deferrable background work. </span><span class="koboSpan" id="kobo.766.2">Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.768.1"> is one of the popular ones. </span><span class="koboSpan" id="kobo.768.2">If you have used Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.770.1">, you might know it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">JobService()</span></strong><span class="koboSpan" id="kobo.772.1"> subclass as its entry point. </span><span class="koboSpan" id="kobo.772.2">In this recipe, we will look at how you can migrate to the n</span><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.773.1">ewly </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">recommended </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.777.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.778.1">We will be looking at how we can migrate from </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">JobService</span></strong><span class="koboSpan" id="kobo.780.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">WorkerManager</span></strong><span class="koboSpan" id="kobo.782.1">. </span><span class="koboSpan" id="kobo.782.2">This might apply to your project or not. </span><span class="koboSpan" id="kobo.782.3">It is essential to cover it, though, due to the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">WorkManager</span></strong><span class="koboSpan" id="kobo.784.1"> is highly recommended, and we all have some legacy code. </span><span class="koboSpan" id="kobo.784.2">However, if your project is n</span><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.785.1">ew, you can skip </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">this recipe.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.787.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.788.1">To migrate your Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.790.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">WorkManager</span></strong><span class="koboSpan" id="kobo.792.1">, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.794.1">First, you will need to add the required dependency; for this, you can reference the </span><em class="italic"><span class="koboSpan" id="kobo.795.1">Understanding the Jetpack WorkManager </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.796.1">library</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.797.1"> recipe.</span></span></li>
<li><span class="koboSpan" id="kobo.798.1">If you </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.799.1">already have </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.800.1">Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.802.1"> in your project, you might have code similar to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.804.1">
class YourProjectJobService : JobService() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.805.1">
Â Â Â Â override fun onStartJob(job: JobParameters):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.806.1">
Â Â Â Â Boolean {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.807.1">
Â Â Â Â Â Â Â Â // perform some job</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.808.1">
Â Â Â Â Â Â Â Â return false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.809.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.810.1">
Â Â Â Â override fun onStopJob(job: JobParameters):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.811.1">
Â Â Â Â Boolean {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.812.1">
Â Â Â Â Â Â Â Â return false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.813.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.814.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.815.1">It is easier if your application utilizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">JobServices()</span></strong><span class="koboSpan" id="kobo.817.1">; then, it will map to </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.819.1">. </span><span class="koboSpan" id="kobo.819.2">However, if your application is utilizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">SimpleJobService</span></strong><span class="koboSpan" id="kobo.821.1">, then in that case, you should </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">Worker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.825.1">
class YourWorker(context: Context, params: WorkerParameters) :</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.826.1">
Â Â Â Â ListenableWorker(context, params) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
Â Â Â Â override fun startWork():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
Â Â Â Â ListenableFuture&lt;ListenableWorker.Result&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.829.1">
Â Â Â Â Â Â Â Â TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.831.1">
Â Â Â Â override fun onStopped() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.832.1">
Â Â Â Â Â Â Â Â TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.833.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.834.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.835.1">If your </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.836.1">project is using </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">Job.Builder.setRecurring(true)</span></strong><span class="koboSpan" id="kobo.838.1">, in this case, you should change it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">PeriodicWorkRequest</span></strong><span class="koboSpan" id="kobo.840.1"> a class offered </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.841.1">by </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">WorkManager</span></strong><span class="koboSpan" id="kobo.843.1">. </span><span class="koboSpan" id="kobo.843.2">You can also specify your tag, service if the job is recurring, trigger window, </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">and more:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.845.1">
val job = dispatcher.newJobBuilder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.846.1">
Â Â Â Â ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.847.1">
Â Â Â Â .build()</span></pre></li>
<li><span class="koboSpan" id="kobo.848.1">In addition, to be able to achieve what we want, we will need to input data that will act as the input data for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Worker</span></strong><span class="koboSpan" id="kobo.850.1">, then build our </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">WorkRequest</span></strong><span class="koboSpan" id="kobo.852.1"> with our input data and the specific constraint. </span><span class="koboSpan" id="kobo.852.2">You can reference the </span><em class="italic"><span class="koboSpan" id="kobo.853.1">Understanding the Jetpack WorkManager library</span></em><span class="koboSpan" id="kobo.854.1"> recipe, and finally, enqueue the </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">Work Request.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.856.1">Finally, you can create your work request as either one-time or periodic and ensure you handle any ed</span><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.857.1">ge cases, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">canceling work.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.859.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.860.1">In Firebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">JobDispatcher</span></strong><span class="koboSpan" id="kobo.862.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">JobService.onStartJob()</span></strong><span class="koboSpan" id="kobo.864.1">, which is a function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">JobSccheduler</span></strong><span class="koboSpan" id="kobo.866.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">startWork()</span></strong><span class="koboSpan" id="kobo.868.1"> are called on the main thread. </span><span class="koboSpan" id="kobo.868.2">In </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.869.1">comparison, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">WorkManager</span></strong><span class="koboSpan" id="kobo.871.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.873.1"> is the basic unit of work. </span><span class="koboSpan" id="kobo.873.2">In our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">YourWorker</span></strong><span class="koboSpan" id="kobo.875.1"> implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">ListenableWorker</span></strong><span class="koboSpan" id="kobo.877.1"> and returns an instance </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.878.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">ListenableFuture</span></strong><span class="koboSpan" id="kobo.880.1">, which helps in signaling work completion. </span><span class="koboSpan" id="kobo.880.2">However, you can implement your one-threading strategy based on your </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">applicationâ€™s needs.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">In Firebase, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">FirebaseJobBuilder</span></strong><span class="koboSpan" id="kobo.884.1"> uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">Job.Builder</span></strong><span class="koboSpan" id="kobo.886.1"> serves as the Jobs metadata. </span><span class="koboSpan" id="kobo.886.2">In comparison, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">WorkManager</span></strong><span class="koboSpan" id="kobo.888.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">WorkRequest</span></strong><span class="koboSpan" id="kobo.890.1"> to perform a similar role. </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">WorkManager</span></strong><span class="koboSpan" id="kobo.892.1"> usually initializes itsel</span><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.893.1">f by utilizing </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">ContentProvider</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.897.1">How to debug WorkManager</span></h1>
<p><span class="koboSpan" id="kobo.898.1">Any operation that requires working in the background and sometimes making network calls need </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.899.1">proper exception handling. </span><span class="koboSpan" id="kobo.899.2">This is due to the fact that you do not want your users facing issues and a lack of exception handling coming back to haunt your team or you as </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">a developer.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">Hence, knowing how to debug </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">WorkManager</span></strong><span class="koboSpan" id="kobo.903.1"> will come in handy, as this is one of those issues that might last for days if you have a bug. </span><span class="koboSpan" id="kobo.903.2">In this recipe, we wi</span><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.904.1">ll look at how to </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">debug </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.908.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.909.1">To follow this recipe, you must have completed a</span><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.910.1">ll previous recipes of </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">this chapter.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor369"/><span class="koboSpan" id="kobo.912.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.913.1">You might encounter an issue where </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">WorkManager</span></strong><span class="koboSpan" id="kobo.915.1"> no longer runs if it is out of sync. </span><span class="koboSpan" id="kobo.915.2">Follow this recipe to </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">debug </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.919.1">To be able to set up debugging, we will need to first create a custom initialization in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">AndroidManifest.xml</span></strong><span class="koboSpan" id="kobo.921.1"> file, that is, by disabling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">WorkManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.923.1"> initializer:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.924.1">
&lt;provider</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.925.1">
Â Â Â Â ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.926.1">
Â Â Â Â tools:node="remove"/&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.927.1">After, we go ahead and set a minimum logging level to debug in our </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">application class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.929.1">
class App() : Application(), Configuration.Provider {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.930.1">
Â Â Â Â override fun getWorkManagerConfiguration() =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.931.1">
Â Â Â Â Â Â Â Â Configuration.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.932.1">
Â Â Â Â Â Â Â Â Â Â Â Â .setMinimumLoggingLevel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.933.1">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â android.util.Log.DEBUG)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.934.1">
Â Â Â Â Â Â Â Â Â Â Â Â .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.935.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.936.1">Once this is done, we will be able to see logs with the prefix </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">WM-</span></strong><span class="koboSpan" id="kobo.938.1"> in our debug level easily, which will make our debugging work much more straightforward, and voila, we can move o</span><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.939.1">ne step closer to solving </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">our issue.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.941.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.942.1">Sometimes it might be helpful just to utilize the verbose </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">WorkManager</span></strong><span class="koboSpan" id="kobo.944.1"> logs to capture any anomalies. </span><span class="koboSpan" id="kobo.944.2">In </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.945.1">addition, you can enable logging and use your own custom initialization. </span><span class="koboSpan" id="kobo.945.2">That is what we do in the first step of our recipe. </span><span class="koboSpan" id="kobo.945.3">Furthermore, when we declare our own custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">WorkManager</span></strong><span class="koboSpan" id="kobo.947.1"> configuration, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">WorkManager</span></strong><span class="koboSpan" id="kobo.949.1"> will be initialized when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">WorkManager.getInstance(context)</span></strong><span class="koboSpan" id="kobo.951.1"> and n</span><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.952.1">ot naturally at </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">application startup.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.954.1">Testing Worker implementations</span></h1>
<p><span class="koboSpan" id="kobo.955.1">Testing your </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">Worker</span></strong><span class="koboSpan" id="kobo.957.1"> implementation is crucial, as it helps ensure your code is well handled and your </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.958.1">team follows the proper guidelines for writing great code. </span><span class="koboSpan" id="kobo.958.2">This will be an integration test, which means we will add our code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">androidTest</span></strong><span class="koboSpan" id="kobo.960.1"> folder. </span><span class="koboSpan" id="kobo.960.2">This recipe will look </span><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.961.1">into how to add tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">your worker.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.963.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.964.1">To follow along with this recipe, you need to have completed</span><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.965.1"> all previous recipes of </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">this chapter.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.967.1">How to do itâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.968.1">Follow these steps to get </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.969.1">started with testing </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">WorkManager</span></strong><span class="koboSpan" id="kobo.971.1">. </span><span class="koboSpan" id="kobo.971.2">We will look at examples in </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">this recipe:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.973.1">First, you need to add the testing dependency in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.975.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.976.1">
androidTestImplementation("androidx.work:work-testing:$work_version")</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.977.1">In the scenario where something in the API changes in the future, thereâ€™s a stable version that you can use, and you can always find that in the documentation by following this </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">link: </span></span><a href="https://developer.android.com/jetpack/androidx/releases/work"><span class="No-Break"><span class="koboSpan" id="kobo.979.1">https://developer.android.com/jetpack/androidx/releases/work</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.980.1">.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.981.1">We will need to set up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">@Before</span></strong><span class="koboSpan" id="kobo.983.1"> function, as provided </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">by Google:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.985.1">
@RunWith(AndroidJUnit4::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.986.1">
class BasicInstrumentationTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.987.1">
Â Â Â Â @Before</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.988.1">
Â Â Â Â fun setup() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.989.1">
Â Â Â Â Â Â Â Â val context =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.990.1">
Â Â Â Â Â Â Â Â Â Â Â Â InstrumentationRegistry.getTargetContext()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.991.1">
Â Â Â Â Â Â Â Â val config = Configuration.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.992.1">
Â Â Â Â Â Â Â Â Â Â Â Â .setMinimumLoggingLevel(Log.DEBUG)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.993.1">
Â Â Â Â Â Â Â Â Â Â Â Â .setExecutor(SynchronousExecutor())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.994.1">
Â Â Â Â Â Â Â Â Â Â Â Â .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.995.1">
Â Â Â Â Â Â Â Â // Initialize WorkManager for instrumentation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.996.1">
Â Â Â Â Â Â Â Â Â Â Â tests.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.997.1">
Â Â Â Â Â Â Â Â WorkManagerTestInitHelper.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.998.1">
Â Â Â Â Â Â Â Â Â Â Â Â initializeTestWorkManager(context, config)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.999.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.1001.1">Now that we </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.1002.1">have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">WorkManager</span></strong><span class="koboSpan" id="kobo.1004.1"> set up, we can go ahead and structure </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">our test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
class GetDataWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
Â Â Â Â override fun doWork(): Result {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1008.1">
Â Â Â Â Â Â Â Â return when(endpoint) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
Â Â Â Â Â Â Â Â Â Â Â Â 0 -&gt; Result.failure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
Â Â Â Â Â Â Â Â Â Â Â Â else -&gt; Result.success(dataOutput)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
Â Â Â Â Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
Â Â Â Â }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.1014.1">You can easily test and verify the states by following </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">this example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
@Throws(Exception::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
fun testGetDataWorkerHasNoData() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
Â Â Â Â ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
Â Â Â Â val workInfo =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
Â Â Â Â Â Â Â Â workManager.getWorkInfoById(request.id).get()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
Â Â Â Â assertThat(workInfo.state,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
Â Â Â Â Â Â Â Â `is`(WorkInfo.State.FAILED))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1025.1">You can add more tests such as verifying when the state is successful or checking initial delays; you can also go the extra</span><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.1026.1"> mile and test the constraints </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">and more.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.1028.1">How it worksâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.1029.1">The library we use provides excellent support for testing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">Worker</span></strong><span class="koboSpan" id="kobo.1031.1">. </span><span class="koboSpan" id="kobo.1031.2">For instance, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">WorkManagerTestInitHelper</span></strong><span class="koboSpan" id="kobo.1033.1"> supplied to us through the library. </span><span class="koboSpan" id="kobo.1033.2">Furthermore, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">SynchronousExecutor</span></strong><span class="koboSpan" id="kobo.1035.1">, which makes our work as developers easier </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.1036.1">by ensuring synchronous writing tests is easy. </span><span class="koboSpan" id="kobo.1036.2">Also, the issue of handling multiple threads, latches, and locks is </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">dealt with.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">testGetDataWorkerHasNoData</span></strong><span class="koboSpan" id="kobo.1040.1">, we create a request, then enqueue it and wait for the results. </span><span class="koboSpan" id="kobo.1040.2">We later get the info, then assert when the state is failed, it should fail.</span><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.1041.1"> You can also test when it </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">is successful.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.1043.1">Thereâ€™s moreâ€¦</span></h2>
<p><span class="koboSpan" id="kobo.1044.1">To test worker implementations </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.1045.1">with different variants, you can follow this </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">link: </span></span><a href="https://developer.android.com/guide/background/testing/persistent/worker-impl"><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">https://developer.android.com/guide/background/testing/persistent/worker-impl</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">.</span></span></p>
</div>
</body></html>