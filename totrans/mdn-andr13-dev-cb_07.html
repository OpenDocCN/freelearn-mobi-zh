<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-182"><a id="_idTextAnchor320"/>7</h1>
<h1 id="_idParaDest-183"><a id="_idTextAnchor321"/>Getting Started with WorkManager</h1>
<p>In Android, <code>WorkManager</code> is an API introduced by Google as part of the Android Jetpack library. It is a powerful and flexible background task scheduling library that allows you to perform deferrable, asynchronous tasks even when your app is not running or the device is in a low-power state.</p>
<p><code>WorkManager</code> provides a unified API to schedule tasks that need to be executed at a specific time or under certain conditions. It takes care of managing and running tasks efficiently, depending on factors such as device idle state, network connectivity, and battery level.</p>
<p>Furthermore, <code>WorkManager</code> allows observation of work status and chain creation. This chapter will look into how we can implement <code>WorkManager</code> using examples and learn how it works and its use cases.</p>
<p>In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Understanding the Jetpack <code>WorkManager</code> library</li>
<li>Understanding <code>WorkManager</code> state</li>
<li>Understanding threading in <code>WorkManager</code></li>
<li>Understanding chaining and canceling work requests</li>
<li>Implementing migration from Firebase <code>JobDispatcher</code> to the new recommended <code>WorkManager</code></li>
<li>How to debug <code>WorkManager</code></li>
<li><a id="_idTextAnchor322"/>Testing <code>Worker</code> implementations</li>
</ul>
<h1 id="_idParaDest-184"><a id="_idTextAnchor323"/>Technical requirements</h1>
<p>This chapter utilizes step-by-step examples and does not create a complete project. <code>WorkManager</code> is helpful, but because the use case may vary, utilizing examples to see how the code fits your need is an excellent art to learn in programming.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor324"/>Understanding the Jetpack WorkManager library</h1>
<p><strong class="bold">WorkManager</strong> is one of the most powerful Jetpack libraries, and it is used for persistent work. The API allows <a id="_idIndexMarker451"/>observation of persistent status and the ability to <a id="_idIndexMarker452"/>create a complex chain of work. When building Android applications, it might be a requirement to have your data persist; if you need help to refresh your knowledge, you can reference<em class="italic"> </em><a href="B18827_06.xhtml#_idTextAnchor283"><em class="italic">Chapter 6</em></a>, <em class="italic">Using the Room Database </em><em class="italic">and Testing</em>.</p>
<p><code>WorkManager</code> is the most-recommended API for any background process and is known to handle unique types of ongoing work as shown here:</p>
<ul>
<li><strong class="bold">Immediate</strong>: As the name suggests, these are tasks that must be done immediately or completed soon</li>
<li><strong class="bold">Long-Running</strong>: Tasks that run for a long time</li>
<li><strong class="bold">Deferrable</strong>: A task that can be rescheduled and can be assigned a different start time and can also run periodically</li>
</ul>
<p>Some more sample use cases where you can use <code>WorkManager</code> are, for instance, if your company wants to create custom notifications, send analytics events, upload images, periodically sync your local data with the network, and more. Furthermore, <code>WorkManager</code> is the favored API and is highly recommended as it replaces all previous background scheduling APIs in Android.</p>
<p>There are other APIs that are used for scheduling work. They are deprecated, and in this book, we will not cover them but will mention them since you might encounter them in work with legacy code; they are as follows:</p>
<ul>
<li>Firebase Job Dispatcher</li>
<li>Job Scheduler</li>
<li>GCM <code>NetWorkManager</code></li>
<li><code>WorkManage<a id="_idTextAnchor325"/>r</code></li>
</ul>
<h2 id="_idParaDest-186"><a id="_idTextAnchor326"/>Getting ready</h2>
<p>In this recipe, we will go ahead and look at a simple example of how we can create our own custom notification using <code>WorkManager</code>.</p>
<p>You can also use the same concept to send logs or report analytics for your application if you are listening to <a id="_idIndexMarker453"/>any logs. We opt for this task because sending notifications to your users is crucial, and most applications do this, compared to uploading images. In addition, with Android 13 and the new API, it’s mandatory to request <code>android.permission.POST_NOTIFICATION<a id="_idTextAnchor327"/>S</code>.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor328"/>How to do it…</h2>
<p>For this recipe, you do not need to create a project, as the concepts can be used in an already-built project; instead, we will look at examples and walk through the examples with explanations:</p>
<ol>
<li>We will need to ensure we have the required dependency:<pre class="source-code">
implementation "androidx.work:work-runtime-ktx:</pre><pre class="source-code">
version-number"</pre></li>
</ol>
<p>You can get the latest <strong class="bold">version number</strong> by following the documentation at <a href="https://developer.android.com/jetpack/androidx/releases/work">https://developer.android.com/jetpack/androidx/releases/work</a>.</p>
<ol>
<li value="2">Let us now go ahead and create our notification channel. For this, Google offers a great guide on how you can create one at <a href="https://developer.android.com/develop/ui/views/notifications/channels">https://developer.android.com/develop/ui/views/notifications/channels</a>, so copy the following code:<pre class="source-code">
private fun createCustomNotificationChannel() {</pre><pre class="source-code">
    if (Build.VERSION.SDK_INT &gt;=</pre><pre class="source-code">
    Build.VERSION_CODES.O) {</pre><pre class="source-code">
        val name = getString(</pre><pre class="source-code">
            R.string.notification_channel)</pre><pre class="source-code">
        val notificationDescription = getString(</pre><pre class="source-code">
            R.string.notification_description)</pre><pre class="source-code">
        val importance =</pre><pre class="source-code">
            NotificationManager.IMPORTANCE_DEFAULT</pre><pre class="source-code">
        val channel = NotificationChannel(CHANNEL_ID,</pre><pre class="source-code">
        name, importance).apply <strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">            </strong>description = notificationDescription</pre><pre class="source-code">
        <strong class="bold">}</strong></pre><pre class="source-code">
        // Register the channel with the system</pre><pre class="source-code">
        val notificationManager: NotificationManager =</pre><pre class="source-code">
            getSystemService(</pre><pre class="source-code">
                Context.NOTIFICATION_SERVICE) as</pre><pre class="source-code">
                    NotificationManager</pre><pre class="source-code">
        notificationManager.createNotificationChannel(</pre><pre class="source-code">
            channel)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Also, note that creating <a id="_idIndexMarker454"/>different channels for separating notification types is possible. As recommended in Android 13, this makes it easier for users to turn them on and off if they do not need them. For example, a user might want to be aware of the latest brands your app is selling, compared to you sending your users info about old existing brands.</p>
<ol>
<li value="3">Now we can create our <code>workManagerInstance</code>. Let us think of a scenario where we need to fetch data from our servers every 20 or 30 mins and check whether notifications are available. In that case, we might encounter an issue where users are no longer using our application, which means the application will be put in the background, or the process might even be killed.</li>
</ol>
<p>Hence the question becomes how do we fetch the data when the application is killed? This is when <code>WorkManager</code> comes to the rescue.</p>
<ol>
<li value="4">We can now create an instance of <code>WorkManager</code>:<pre class="source-code">
val workManagerInstance = WorkManager.getInstance(application.applicationContext)</pre></li>
<li>We will now need to go ahead and set the constraints:<pre class="source-code">
val ourConstraints = Constraints.Builder()</pre><pre class="source-code">
    .setRequiredNetworkType(NetworkType.CONNECTED)</pre><pre class="source-code">
    .setRequiresBatteryNotLow(false)</pre><pre class="source-code">
    .build()</pre></li>
<li>We will also <a id="_idIndexMarker455"/>need to set data to pass to the worker; hence we will create new value data, then we will put a string to the endpoint request:<pre class="source-code">
val data = Data.Builder()</pre><pre class="source-code">
data.putString(ENDPOINT_REQUEST, endPoint)</pre></li>
<li>Now we can go ahead and create our <code>PeriodicWorkRequestBuilder&lt;GetDataWorker&gt;</code>. In our work, we will set the constraints, set our input data, and pass the <code>GetDataWorker()</code> type, which we will create and then build. Furthermore, since we want to be fetching the data every 20 or 30 mins from our server, we use <code>PeriodicWorkRequestBuilder&lt;Type&gt;()</code> for that purpose:<pre class="source-code">
val job =</pre><pre class="source-code">
    PeriodicWorkRequestBuilder&lt;GetDataWorker&gt;(20,</pre><pre class="source-code">
        TimeUnit.MINUTES)</pre><pre class="source-code">
    .setConstraints(ourConstraints)</pre><pre class="source-code">
    .setInputData(data.build())</pre><pre class="source-code">
    .build()</pre></li>
<li>We can now finally call <code>workManagerInstance</code> and enqueue our job:<pre class="source-code">
workManagerInstance</pre><pre class="source-code">
    .enqueue(work)</pre></li>
<li> We can now go ahead and construct our <code>GetDataWorker()</code>. In this class, we will extend the <code>Worker</code> class, which will override the <code>doWork()</code> function. In our case, however, instead <a id="_idIndexMarker456"/>of extending the <code>Worker</code> class, we will extend the <code>CoroutineWorker(context, workerParameters)</code>, which will help in our case since we will collect this data in a flow. We will also be using Hilt, so we will call <code>@HiltWorker</code>:<pre class="source-code">
@HiltWorker</pre><pre class="source-code">
class GetDataWorker @AssistedInject constructor(</pre><pre class="source-code">
    @Assisted context: Context,</pre><pre class="source-code">
    @Assisted workerParameters: WorkerParameters,</pre><pre class="source-code">
    private val viewModel: NotificationViewModel</pre><pre class="source-code">
) : CoroutineWorker(context, workerParameters) {</pre><pre class="source-code">
    override suspend fun doWork(): Result {</pre><pre class="source-code">
        val ourEndPoint = inputData.getString(</pre><pre class="source-code">
            NotificationConstants.ENDPOINT_REQUEST)</pre><pre class="source-code">
        if (endPoint != null) {</pre><pre class="source-code">
            getData(endPoint)</pre><pre class="source-code">
        }</pre><pre class="source-code">
        val dataToOutput = Data.Builder()</pre><pre class="source-code">
            .putString(</pre><pre class="source-code">
              NotificationConstants.NOTIFICATION_DATA,</pre><pre class="source-code">
              "Data")</pre><pre class="source-code">
            .build()</pre><pre class="source-code">
        return Result.success(dataToOutput)</pre><pre class="source-code">
    }</pre></li>
</ol>
<p>In our case, we are returning <code>success.</code> In our <code>getData()</code> function, we pass in the <a id="_idIndexMarker457"/>endpoint, and we can assume our data has two or three crucial attributes: the ID, the title, and the description.</p>
<ol>
<li value="10">We can now send notifications:<pre class="source-code">
val notificationIntent = Intent(this, NotifyUser::class.java).apply <strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">    </strong>flags = Intent.FLAG_ACTIVITY_NEW_TASK or</pre><pre class="source-code">
        Intent.FLAG_ACTIVITY_CLEAR_TASK</pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
notificationIntent.putExtra(NOTIFICATION_EXTRA, true)</pre><pre class="source-code">
notificationIntent.putExtra(NOTIFICATION_ID, notificationId)</pre><pre class="source-code">
val notifyPendingIntent = PendingIntent.getActivity(</pre><pre class="source-code">
    this, 0, notificationIntent,</pre><pre class="source-code">
    PendingIntent.FLAG_UPDATE_CURRENT</pre><pre class="source-code">
)</pre><pre class="source-code">
val builder = NotificationCompat</pre><pre class="source-code">
    .Builder(context, Channel_ID_DEFAULT)</pre><pre class="source-code">
    .setSmallIcon(notificationImage)</pre><pre class="source-code">
    .setContentTitle(notificationTitle)</pre><pre class="source-code">
    .setContentText(notificationContent)</pre><pre class="source-code">
    .setPriority(NotificationCompat.PRIORITY_HIGH)</pre><pre class="source-code">
    .setContentIntent(notifyPendingIntent)</pre><pre class="source-code">
    .setAutoCancel(true)</pre><pre class="source-code">
with(NotificationManagerCompat.from(context)) {</pre><pre class="source-code">
    notify(notificationId, builder.build())</pre><pre class="source-code">
}</pre></li>
<li>We also need to create a <code>PendingIntent.getActivity()</code>, which means when there is a <a id="_idIndexMarker458"/>click on the notification, the user will start an activity. For this to happen, we can <code>getStringExtra(NotificationConstants.NOTIFICATION_ID)</code> when a notification is clicked and put extras in our intent. This will need to happen in our activity:<pre class="source-code">
private fun verifyIntent(intent: Intent?) {</pre><pre class="source-code">
    intent?.let <strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">    </strong>    if (it.hasExtra(</pre><pre class="source-code">
           NotificationConstants.NOTIFICATION_EXTRA)){</pre><pre class="source-code">
           it.getStringExtra(</pre><pre class="source-code">
           NotificationConstants.NOTIFICATION_ID)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    <strong class="bold">}</strong></pre><pre class="source-code">
}</pre></li>
<li>And on our <code>onResume()</code>, we can now call our <code>verifyIntent()</code> function:<pre class="source-code">
override fun onResume() {</pre><pre class="source-code">
    super.onResume()</pre><pre class="source-code">
    verifyIntent(intent)</pre><pre class="source-code">
}</pre></li>
</ol>
<p>And that’s it; we have custom notifications using our <code>WorkMan<a id="_idTextAnchor329"/>ager()</code>.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor330"/>How it works…</h2>
<p>When creating a notification, the <code>importance</code> parameter helps determine how to interrupt the user for any given channel, hence why one should specify it in the <code>NotificationChannel</code> constructor. If the importance is high and the device is running Android 5.0+, you’re going to see a heads-up notification, otherwise, it will just be the icon in <a id="_idIndexMarker459"/>the status bar. However, it is essential to note that all notifications, regardless of their importance, appear in a non-interruptive UI at the top of your screen.</p>
<p>The <code>WorkManager</code> word is very straightforward, hence removing ambiguity from the API. When using <code>WorkManager</code>, <code>Work </code>is referenced utilizing the <code>Worker</code> class. In addition, the <code>doWork()</code> function that we call runs asynchronously in the background thread offered by the <code>WorkManager()</code>.</p>
<p>The <code>doWork()</code> function returns a <code>Result{}</code>, and this result can be <code>Success</code>, <code>Failure</code>, or <code>Retry</code>. When we return the successful <code>Result{}</code>, the work will be done and finished successfully. <code>Failure</code>, as the name suggests, means the work failed, and then we call <code>Retry</code>, which retries the work.</p>
<p>In our <code>GetDataWorker()</code>, we pass in <code>NotificationViewModel</code> and inject it into our worker using Hilt. Sometimes you might encounter a conflict. The good thing is there is support for such a case with four options for handling any conflict that might occur.</p>
<p>This case is unique to when you are scheduling unique work; it makes sense to tell <code>WorkManager</code> what action must be taken when a conflict arises. You can solve this problem easily by using the existing work policy, <code>ExisitingWorkPolicy</code>, which has <code>REPLACE</code>, <code>KEEP APPEND</code>, and <code>APPEND_OR_REPLACE</code>.</p>
<p><code>Replace</code>, as the name suggests, replaces the existing work, while <code>Keep</code> keeps existing work and ignores <a id="_idIndexMarker460"/>new work. When you call <em class="italic">Append</em>, this adds the new work to the existing one, and finally, <code>Append or Replace</code> simply does not depend on the pre-requisite work state.</p>
<p class="callout-heading">Important note</p>
<p class="callout"><code>WorkManager</code> is a singleton, hence it can only be initialized once, that is, either in your app or in the library. And, if <a id="_idIndexMarker461"/>you are using any workers with custom dependencies, then you have to provide a <code>WorkerFactory()</code> to the config at the time of custom initi<a id="_idTextAnchor331"/>alization.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor332"/>There’s more…</h2>
<p>We can only cover some <code>WorkManager</code> steps here. Google has great sample code labs that you can follow through and understand how to use <code>WorkManager</code>.</p>
<p>To read <a id="_idIndexMarker462"/>more about <code>WorkManager</code>, you can use this link: <a href="https://developer.android.com/guide/background/persistent">https://developer.android.com/guide/background/persistent</a>.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor333"/>Understanding WorkManager state</h1>
<p>In the previous recipe, <em class="italic">Understanding the Jetpack WorkManager library</em>, we looked into how <a id="_idIndexMarker463"/>we can use <code>WorkManager</code>. In that recipe, you might have noticed <code>Work</code> goes through a series of state changes, and the <code>doWork</code> function returns a result.</p>
<p>In this recipe, we will explore stat<a id="_idTextAnchor334"/>es in depth.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor335"/>How to do it…</h2>
<p>We will continue working on an example of how you can apply the concepts learned about in this recipe to your already-built project:</p>
<ol>
<li>You might have noticed we mentioned before that we have three states: <code>Success</code>, <code>Failure</code>, and <code>Retry</code>. <code>Work</code> states, however, have different types of processes; we can have a one-time work state, periodic work state, or blocked state:<pre class="source-code">
Result</pre><pre class="source-code">
    SUCCESS, FAILURE, RETRY</pre></li>
</ol>
<p>You can look into this abstract class in more depth by clicking on the result and seeing how it is written.</p>
<ol>
<li value="2">In the first recipe, <em class="italic">Understanding the Jetpack WorkManager library</em>, we looked into the <a id="_idIndexMarker464"/>steps of setting up <code>WorkManager</code>. Another great example is downloading files. You can override the <code>fun doWork()</code> and check whether your URI is not equal to null and return a success, else failure:<pre class="source-code">
override suspend fun doWork(): Result {</pre><pre class="source-code">
    val file = inputData.getString(</pre><pre class="source-code">
        FileParameters.KEY_FILE_NAME) ?: ""</pre><pre class="source-code">
    if (file.isEmpty()){</pre><pre class="source-code">
        Result.failure()</pre><pre class="source-code">
    }</pre><pre class="source-code">
    val uri = getSavedFileUri(fileName = file,</pre><pre class="source-code">
        context = context)</pre><pre class="source-code">
    return if (uri != null){</pre><pre class="source-code">
        Result.success(workDataOf(</pre><pre class="source-code">
            FileParameters.KEY_FILE_URI to</pre><pre class="source-code">
                uri.toString()))</pre><pre class="source-code">
    }else{</pre><pre class="source-code">
        Result.failure()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>When handling a state, you can easily check when the state successfully specifies an <a id="_idIndexMarker465"/>action, when it failed to perform an action, and finally, when <code>WorkInfo.State</code> is equals to <code>RUNNING</code>, call <code>running()</code>; see the following code snippet:<pre class="source-code">
when (state) {</pre><pre class="source-code">
    WorkInfo.State.SUCCEEDED -&gt; {</pre><pre class="source-code">
        success(</pre><pre class="source-code">
            //do something</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
    WorkInfo.State.FAILED -&gt; {</pre><pre class="source-code">
        failed("Downloading failed!")</pre><pre class="source-code">
    }</pre><pre class="source-code">
    WorkInfo.State.RUNNING -&gt; {</pre><pre class="source-code">
        running()</pre><pre class="source-code">
    }</pre><pre class="source-code">
    else -&gt; {</pre><pre class="source-code">
        failed("Something went wrong")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>The success result returns an instance of <code>ListenableWorker.Result</code>, used to indicate that the work was completed successfully.</li>
<li>For the mentioned states, you can either use <code>enqueueUniqueWork()</code>, which is used for one time, or <code>PeriodicWorkRequestBuilder</code>, which is used for periodic work. In our example, we used <code>PeriodicWorkRequestBuilder&lt;Type&gt;</code>:<pre class="source-code">
WorkManager.enqueueUniqueWork()</pre><pre class="source-code">
WorkManager.enqueueUnique<a id="_idTextAnchor336"/>PeriodicWork()</pre></li>
</ol>
<h2 id="_idParaDest-192"><a id="_idTextAnchor337"/>How it works…</h2>
<p>We always start our request with the <em class="italic">Enqueued</em> state for the one-time work state, which means the work will run as soon as the constraints are met. Thereafter, we move to <em class="italic">Running</em>, and if we hit a <em class="italic">Success</em>, the work is done.</p>
<p>If in any instance, we <a id="_idIndexMarker466"/>end up <em class="italic">Running</em> and we don’t hit <em class="italic">Success</em>, then it means we failed. Then, we will move back to <em class="italic">Enqueued</em> since we need to retry. <em class="italic">Figure 7</em><em class="italic">.1</em> and <em class="italic">Figure 7</em><em class="italic">.2</em> explain the states better for both one-time work and periodic work states.</p>
<p>Finally, if it happens that our enqueued work gets cancelled, then we move it to cancelled.</p>
<div><div><img alt="Figure 7.1 – How one-time work requests work" src="img/Figure_7.1_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – How one-time work requests work</p>
<p>While the preceding <a id="_idIndexMarker467"/>image shows the one-time work state, the following diagram depicts the periodic work state.</p>
<div><div><img alt="Figure 7.2 – How the periodic wo﻿rk state works" src="img/Figure_7.2_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – How the periodic wo<a id="_idTextAnchor338"/>rk state works</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor339"/>Understanding threading in WorkManager</h1>
<p>You can think of <code>WorkManager</code> as any process that runs in a background thread. When we use the <code>Worker()</code>, and <code>WorkManager</code> calls the <code>doWork()</code> function, this action works in the <a id="_idIndexMarker468"/>background thread. In detail, the background thread comes from the <code>Executor</code> specified in the <code>WorkManager</code> configuration.</p>
<p>You can also create your own custom executor for your application needs, but if that’s not needed, you can use the pre-existing one. This recipe will explore how threading in a <code>Worker()</code> works and how to create a c<a id="_idTextAnchor340"/>ustom executor.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor341"/>Getting ready</h2>
<p>In this recipe, since we will be looking at examples, you can follow along by reading and seeing if this a<a id="_idTextAnchor342"/>pplies to you.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor343"/>How to do it…</h2>
<p>Let’s learn how threading works in <code>WorkManager</code>:</p>
<ol>
<li>In order to configure <code>WorkManager</code> manually, you will need to specify your executor. This can be done by calling <code>WorkManager.initialize()</code>, then passing the context, and the configuration builder:<pre class="source-code">
WorkManager.initialize(</pre><pre class="source-code">
    context,</pre><pre class="source-code">
    Configuration.Builder()</pre><pre class="source-code">
        .setExecutor(Executors.newFixedThreadPool(</pre><pre class="source-code">
            CONSTANT_THREAD_POOL_INT))</pre><pre class="source-code">
        .build())</pre></li>
<li>In our earlier example in the previous recipe, <em class="italic">Understanding WorkManager state</em>, we spoke <a id="_idIndexMarker469"/>about a use case where we download files. These files can be in the form of PDF, JPG, PNG, or even MP4. We will look at an example that downloads content 20 times; you can specify how many times you want your content to download:<pre class="source-code">
class GetFiles(context: Context, params: WorkerParameters) : Worker(context, params) {</pre><pre class="source-code">
    override fun doWork(): ListenableWorker.Result {</pre><pre class="source-code">
        repeat(20) {</pre><pre class="source-code">
            try {</pre><pre class="source-code">
                downloadSynchronously("Your Link")</pre><pre class="source-code">
            } catch (e: IOException) {</pre><pre class="source-code">
                return</pre><pre class="source-code">
                    ListenableWorker.Result.failure()</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
        return ListenableWorker.Result.success()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Currently, if we do not handle the case where the <code>Worker()</code> is stopped, it is good practice to <a id="_idIndexMarker470"/>ensure that it is dealt with because this is an edge case. To address this case, we need to override the <code>Worker.onStopped()</code> method or call <code>Worker.isStopped</code> where necessary to free up some resources:<pre class="source-code">
    override fun doWork(): ListenableWorker.Result {</pre><pre class="source-code">
        repeat(20) {</pre><pre class="source-code">
            if (isStopped) {</pre><pre class="source-code">
                break</pre><pre class="source-code">
            }</pre><pre class="source-code">
            try {</pre><pre class="source-code">
                downloadSynchronously("Your Link")</pre><pre class="source-code">
            } catch (e: IOException) {</pre><pre class="source-code">
                return</pre><pre class="source-code">
                    ListenableWorker.Result.failure()</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
        return ListenableWorker.Result.success()</pre><pre class="source-code">
    }</pre></li>
<li>Finally, when you stop the worker, the result is entirely ignored until you restart the process again. We used <code>CoroutineWorker</code> in our earlier example since <code>WorkManager</code> offers support for coroutines, hence why we collected the data in a flow.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Customizing your executor will require manually initiali<a id="_idTextAnchor344"/>zing <code>WorkManager</code>.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor345"/>How it works…</h2>
<p>There is more to learn in the <code>WorkManager</code> Jetpack library, and it is fair to acknowledge <a id="_idIndexMarker471"/>that it can’t all be captured in just a few recipes. For instance, in some scenarios, when providing a custom threading strategy, you should use <code>ListenableWorker</code>.</p>
<p>The <code>ListenableWorker</code> is a class in the Android Jetpack <code>WorkManager</code> library that allows you to perform background work in a flexible and efficient manner. It is a subclass of the <code>Worker</code> class and adds the ability to return a <code>ListenableFuture</code> from its <code>doWork()</code> method, which allows for easier handling of asynchronous operations.</p>
<p>By using <code>ListenableWorker</code>, you can create a worker that returns a <code>ListenableFuture</code> and register callbacks that will be executed when the future completes. This can be useful for tasks such as network requests or database operations that require asynchronous operations.</p>
<p>The <code>Worker</code>, <code>CoroutineWorker</code>, and <code>RxWorker</code> derive from this particular class. <code>Worker</code>, as mentioned, runs in the background thread; <code>CoroutineWorker</code> is highly recommended for developers using Kotlin. <code>RxWorker</code> will not be touched upon here since Rx by itself is a big topic that caters to users that develop in rea<a id="_idTextAnchor346"/>ctive programming.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor347"/>See also</h2>
<p>Your application might be using Rx. In that case, there are details on how threading works in Rx and <a id="_idIndexMarker472"/>how you can use <code>RxWorker</code>. See more here: <a href="https://developer.android.com/guide/background/persistent/threading/rxworker">https://developer.android.com/guide/background/persistent/threading/rxworker</a>.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor348"/>Understanding chaining and canceling work requests</h1>
<p>In Android <a id="_idIndexMarker473"/>development, ensuring you properly handle your application’s life cycle is crucial. Needless to say, this also applies to all background work, as a simple <a id="_idIndexMarker474"/>mistake can lead to your application draining the user’s battery, memory leaks, or even causing the application to crash or suffer from an <strong class="bold">application not responding</strong> (<strong class="bold">ANR</strong>) error. This could <a id="_idIndexMarker475"/>mean terrible reviews in the Play Store, which will later affect your business and causes stress for developers. How do you ensure this issue is handled well?</p>
<p>This can be done by ensuring all conflicts that arise while using <code>WorkManager</code> are appropriately handled or guaranteeing the policy we touched on in the previous recipe is well coded. In this recipe, we will look into chaining and canceling work requests and how to handle long-running work properly.</p>
<p>Say your project requires an order by which the operation should run; <code>WorkManager</code> gives you the ability to enqueue and create a chain that specifies multiple dependent tasks, and here you can set the order in which you want th<a id="_idTextAnchor349"/>e operations to occur.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor350"/>Getting ready</h2>
<p>In this recipe, we will look at an example of how you might chain your work; since this is concept-based, we will look at the example and<a id="_idTextAnchor351"/> explain how it works.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor352"/>How to do it…</h2>
<p>To perform chaining using <code>WorkManager</code>, follow these steps:</p>
<ol>
<li>In our example, we will assume we have four unique <code>Worker</code> jobs to run in parallel. The output of these jobs will be passed to an upload <code>Worker</code>. Then, these will be uploaded to our server, like the sample project we had in the <em class="italic">Understanding the Jetpack WorkManager </em><em class="italic">library</em> recipe.</li>
<li>We will have our <code>WorkManager()</code> and pass in our context; then we will call <code>beginWith</code> and pass a list of our jobs:<pre class="source-code">
WorkManager.getInstance(context)</pre><pre class="source-code">
    .beginWith(listOf(job1, job2, job3, job4))</pre><pre class="source-code">
    .then(ourCache)</pre><pre class="source-code">
    .then(upload)</pre><pre class="source-code">
    .enqueue()</pre></li>
<li>To be able to maintain or preserve all our outputs from our job, we will need to use the <code>ArrayCreatingInputMerger::class</code>:<pre class="source-code">
val ourCache: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;GetDataWorker&gt;()</pre><pre class="source-code">
    .setInputMerger(ArrayCreatingInputMerger::class)</pre><pre class="source-code">
    .setConstraints(constraints)</pre><pre class="source-code">
    .build()</pre></li>
</ol>
<p>That is about it. There is definitely more to learn, but th<a id="_idTextAnchor353"/>is serves our purpose.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor354"/>How it works…</h2>
<p>To be able to <a id="_idIndexMarker476"/>create the chain of work, we use <code>WorkManager.beginWith(OneTimeWorkRequest)</code> or use <code>WorkManager.beginWith</code> and pass <a id="_idIndexMarker477"/>a list of the one-time work requests that you have specified.</p>
<p>The <code>WorkManager.beginWith&lt;List&lt;OneTimeWorkRequest&gt;&gt;</code> operations return an instance of <code>WorkContinuation</code>.</p>
<p>We use the <code>WorkContinuation.enqueue()</code> function to enqueue our <code>WorkContinuation</code> chain. The <code>ArrayCreatingInputMerger</code> ensures we pair each key with an array. In addition, the <code>ArrayCreatingInputMerger</code> is a class in the Android Jetpack <code>WorkManager</code> library that allows you to merge input data from multiple <code>ListenableWorker</code> instances into a single array.</p>
<p>Furthermore, if our keys are <code>unique</code>, we will get a result of one-element arrays. <em class="italic">Figure 7</em><em class="italic">.3</em> shows the output:</p>
<div><div><img alt="Figure 7.3 – How the array creating input merger works" src="img/Figure_7.3_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – How the array creating input merger works</p>
<p>If we have any <a id="_idIndexMarker478"/>colliding keys, then our values will be grouped <a id="_idIndexMarker479"/>together in our array, as in <em class="italic">Figure 7</em><em class="italic">.4</em>.</p>
<div><div><img alt="Figure 7.4 – Key collision and result" src="img/Figure_7.4_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Key collision and result</p>
<p>The rule of thumb is chains of work typically execute sequentially. This is reliant on the work being <a id="_idIndexMarker480"/>completed successfully. You might be wondering what <a id="_idIndexMarker481"/>happens when the job is enqueued in a chain of several work requests; just like a regular queue, all subsequent work is temporarily blocked until the first work request is completed. Think of it a<a id="_idTextAnchor355"/>s <em class="italic">first come, </em><em class="italic">first serve</em>.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor356"/>See also</h2>
<p>You might be wondering <a id="_idIndexMarker482"/>how you can support long-running workers; you can learn more at <a href="https://developer.android.com/guide/background/persistent/how-to/long-running">https://developer.android.com/guide/background/persistent/how-to/long-running</a>.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor357"/>Implementing migration from Firebase JobDispatcher to the new recommended WorkManager</h1>
<p>In the <em class="italic">Understanding the Jetpack WorkManager library</em> recipe, we talked about other <a id="_idIndexMarker483"/>libraries that <a id="_idIndexMarker484"/>are used for scheduling and executing deferrable background work. Firebase <code>JobDispatcher</code> is one of the popular ones. If you have used Firebase <code>JobDispatcher</code>, you might know it uses the <code>JobService()</code> subclass as its entry point. In this recipe, we will look at how you can migrate to the n<a id="_idTextAnchor358"/>ewly recommended <code>WorkManager</code>.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor359"/>Getting ready</h2>
<p>We will be looking at how we can migrate from <code>JobService</code> to <code>WorkerManager</code>. This might apply to your project or not. It is essential to cover it, though, due to the fact that <code>WorkManager</code> is highly recommended, and we all have some legacy code. However, if your project is n<a id="_idTextAnchor360"/>ew, you can skip this recipe.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor361"/>How to do it…</h2>
<p>To migrate your Firebase <code>JobDispatcher</code> to <code>WorkManager</code>, follow these steps:</p>
<ol>
<li>First, you will need to add the required dependency; for this, you can reference the <em class="italic">Understanding the Jetpack WorkManager </em><em class="italic">library</em> recipe.</li>
<li>If you <a id="_idIndexMarker485"/>already have <a id="_idIndexMarker486"/>Firebase <code>JobDispatcher</code> in your project, you might have code similar to the following code snippet:<pre class="source-code">
class YourProjectJobService : JobService() {</pre><pre class="source-code">
    override fun onStartJob(job: JobParameters):</pre><pre class="source-code">
    Boolean {</pre><pre class="source-code">
        // perform some job</pre><pre class="source-code">
        return false</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun onStopJob(job: JobParameters):</pre><pre class="source-code">
    Boolean {</pre><pre class="source-code">
        return false</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>It is easier if your application utilizes <code>JobServices()</code>; then, it will map to <code>ListenableWorker</code>. However, if your application is utilizing <code>SimpleJobService</code>, then in that case, you should use <code>Worker</code>:<pre class="source-code">
class YourWorker(context: Context, params: WorkerParameters) :</pre><pre class="source-code">
    ListenableWorker(context, params) {</pre><pre class="source-code">
    override fun startWork():</pre><pre class="source-code">
    ListenableFuture&lt;ListenableWorker.Result&gt; {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun onStopped() {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>If your <a id="_idIndexMarker487"/>project is using <code>Job.Builder.setRecurring(true)</code>, in this case, you should change it to the <code>PeriodicWorkRequest</code> a class offered <a id="_idIndexMarker488"/>by <code>WorkManager</code>. You can also specify your tag, service if the job is recurring, trigger window, and more:<pre class="source-code">
val job = dispatcher.newJobBuilder()</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    .build()</pre></li>
<li>In addition, to be able to achieve what we want, we will need to input data that will act as the input data for our <code>Worker</code>, then build our <code>WorkRequest</code> with our input data and the specific constraint. You can reference the <em class="italic">Understanding the Jetpack WorkManager library</em> recipe, and finally, enqueue the Work Request.</li>
</ol>
<p>Finally, you can create your work request as either one-time or periodic and ensure you handle any ed<a id="_idTextAnchor362"/>ge cases, such as canceling work.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor363"/>How it works…</h2>
<p>In Firebase <code>JobDispatcher</code>, the <code>JobService.onStartJob()</code>, which is a function in the <code>JobSccheduler</code>, and <code>startWork()</code> are called on the main thread. In <a id="_idIndexMarker489"/>comparison, in <code>WorkManager</code>, the <code>ListenableWorker</code> is the basic unit of work. In our example, <code>YourWorker</code> implements the <code>ListenableWorker</code> and returns an instance <a id="_idIndexMarker490"/>of <code>ListenableFuture</code>, which helps in signaling work completion. However, you can implement your one-threading strategy based on your application’s needs.</p>
<p>In Firebase, the <code>FirebaseJobBuilder</code> uses the <code>Job.Builder</code> serves as the Jobs metadata. In comparison, <code>WorkManager</code> uses <code>WorkRequest</code> to perform a similar role. <code>WorkManager</code> usually initializes itsel<a id="_idTextAnchor364"/>f by utilizing the <code>ContentProvider</code>.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor365"/>How to debug WorkManager</h1>
<p>Any operation that requires working in the background and sometimes making network calls need <a id="_idIndexMarker491"/>proper exception handling. This is due to the fact that you do not want your users facing issues and a lack of exception handling coming back to haunt your team or you as a developer.</p>
<p>Hence, knowing how to debug <code>WorkManager</code> will come in handy, as this is one of those issues that might last for days if you have a bug. In this recipe, we wi<a id="_idTextAnchor366"/>ll look at how to debug <code>WorkManager</code>.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor367"/>Getting ready</h2>
<p>To follow this recipe, you must have completed a<a id="_idTextAnchor368"/>ll previous recipes of this chapter.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor369"/>How to do it…</h2>
<p>You might encounter an issue where <code>WorkManager</code> no longer runs if it is out of sync. Follow this recipe to debug <code>WorkManager</code>:</p>
<ol>
<li>To be able to set up debugging, we will need to first create a custom initialization in our <code>AndroidManifest.xml</code> file, that is, by disabling the <code>WorkManager</code> initializer:<pre class="source-code">
&lt;provider</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    tools:node="remove"/&gt;</pre></li>
<li>After, we go ahead and set a minimum logging level to debug in our application class:<pre class="source-code">
class App() : Application(), Configuration.Provider {</pre><pre class="source-code">
    override fun getWorkManagerConfiguration() =</pre><pre class="source-code">
        Configuration.Builder()</pre><pre class="source-code">
            .setMinimumLoggingLevel(</pre><pre class="source-code">
                android.util.Log.DEBUG)</pre><pre class="source-code">
            .build()</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Once this is done, we will be able to see logs with the prefix <code>WM-</code> in our debug level easily, which will make our debugging work much more straightforward, and voila, we can move o<a id="_idTextAnchor370"/>ne step closer to solving our issue.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor371"/>How it works…</h2>
<p>Sometimes it might be helpful just to utilize the verbose <code>WorkManager</code> logs to capture any anomalies. In <a id="_idIndexMarker492"/>addition, you can enable logging and use your own custom initialization. That is what we do in the first step of our recipe. Furthermore, when we declare our own custom <code>WorkManager</code> configuration, our <code>WorkManager</code> will be initialized when we call the <code>WorkManager.getInstance(context)</code> and n<a id="_idTextAnchor372"/>ot naturally at application startup.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor373"/>Testing Worker implementations</h1>
<p>Testing your <code>Worker</code> implementation is crucial, as it helps ensure your code is well handled and your <a id="_idIndexMarker493"/>team follows the proper guidelines for writing great code. This will be an integration test, which means we will add our code to the <code>androidTest</code> folder. This recipe will look <a id="_idTextAnchor374"/>into how to add tests for your worker.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor375"/>Getting ready</h2>
<p>To follow along with this recipe, you need to have completed<a id="_idTextAnchor376"/> all previous recipes of this chapter.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor377"/>How to do it…</h2>
<p>Follow these steps to get <a id="_idIndexMarker494"/>started with testing <code>WorkManager</code>. We will look at examples in this recipe:</p>
<ol>
<li>First, you need to add the testing dependency in your <code>build.gradle</code> file:<pre class="source-code">
androidTestImplementation("androidx.work:work-testing:$work_version")</pre></li>
</ol>
<p>In the scenario where something in the API changes in the future, there’s a stable version that you can use, and you can always find that in the documentation by following this link: <a href="https://developer.android.com/jetpack/androidx/releases/work">https://developer.android.com/jetpack/androidx/releases/work</a>.</p>
<ol>
<li value="2">We will need to set up our <code>@Before</code> function, as provided by Google:<pre class="source-code">
@RunWith(AndroidJUnit4::class)</pre><pre class="source-code">
class BasicInstrumentationTest {</pre><pre class="source-code">
    @Before</pre><pre class="source-code">
    fun setup() {</pre><pre class="source-code">
        val context =</pre><pre class="source-code">
            InstrumentationRegistry.getTargetContext()</pre><pre class="source-code">
        val config = Configuration.Builder()</pre><pre class="source-code">
            .setMinimumLoggingLevel(Log.DEBUG)</pre><pre class="source-code">
            .setExecutor(SynchronousExecutor())</pre><pre class="source-code">
            .build()</pre><pre class="source-code">
        // Initialize WorkManager for instrumentation</pre><pre class="source-code">
           tests.</pre><pre class="source-code">
        WorkManagerTestInitHelper.</pre><pre class="source-code">
            initializeTestWorkManager(context, config)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that we <a id="_idIndexMarker495"/>have our <code>WorkManager</code> set up, we can go ahead and structure our test:<pre class="source-code">
class GetDataWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) {</pre><pre class="source-code">
    override fun doWork(): Result {</pre><pre class="source-code">
        return when(endpoint) {</pre><pre class="source-code">
            0 -&gt; Result.failure()</pre><pre class="source-code">
            else -&gt; Result.success(dataOutput)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>You can easily test and verify the states by following this example:<pre class="source-code">
@Test</pre><pre class="source-code">
@Throws(Exception::class)</pre><pre class="source-code">
fun testGetDataWorkerHasNoData() {</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    val workInfo =</pre><pre class="source-code">
        workManager.getWorkInfoById(request.id).get()</pre><pre class="source-code">
    assertThat(workInfo.state,</pre><pre class="source-code">
        `is`(WorkInfo.State.FAILED))</pre><pre class="source-code">
}</pre></li>
</ol>
<p>You can add more tests such as verifying when the state is successful or checking initial delays; you can also go the extra<a id="_idTextAnchor378"/> mile and test the constraints and more.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor379"/>How it works…</h2>
<p>The library we use provides excellent support for testing <code>Worker</code>. For instance, we have <code>WorkManagerTestInitHelper</code> supplied to us through the library. Furthermore, we have the <code>SynchronousExecutor</code>, which makes our work as developers easier <a id="_idIndexMarker496"/>by ensuring synchronous writing tests is easy. Also, the issue of handling multiple threads, latches, and locks is dealt with.</p>
<p>In our <code>testGetDataWorkerHasNoData</code>, we create a request, then enqueue it and wait for the results. We later get the info, then assert when the state is failed, it should fail.<a id="_idTextAnchor380"/> You can also test when it is successful.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor381"/>There’s more…</h2>
<p>To test worker implementations <a id="_idIndexMarker497"/>with different variants, you can follow this link: <a href="https://developer.android.com/guide/background/testing/persistent/worker-impl">https://developer.android.com/guide/background/testing/persistent/worker-impl</a>.</p>
</div>
</body></html>