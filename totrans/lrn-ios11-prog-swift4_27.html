<html><head></head><body>
      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Drag and Drop</h1>
            
         </header>
         
         
         <article>
            
            
            <p><em>Drag and drop</em> was introduced in June 2017 at WWDC and it intrigued me in different ways. I love
               using my iPad and I felt like this would make it easier to do things. As I have had
               time to use iOS 11, I think that I was right about my assumption and I cannot wait
               until more apps have this feature.
            </p>
            
            <p>We are going to add drag and drop to our iPad app by letting users drag filter items
               we use in our filter scroller. We will also accept drag and drop from the <em>Photos</em> app. Users will be able to drag from the <em>Photos</em> app and drop it into our scroller when on the iPad.
            </p>
            
            <p>We will cover the following in this chapter:</p>
            
            <ul>
               
               <li>How to drag from a Collection View</li>
               
               <li>How to create custom drag elements</li>
               
               <li>How to accept drag and drop from the <em>Photos</em> app
               </li>
               
            </ul>
            
            <p>There is a lot of code in this chapter, mainly because we will be doing quite a few
               things. The first thing we want to do is drag photos from the <em>Photos</em> app or any app that has photos and drop it into our filter view area. Drag and drop
               is an alternative to using the picker control to add a photo.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Accepting drag from other apps </h1>
            
         </header>
         
         
         <article>
            
            
            <p>Let's get started in accepting drag and drop from other apps:</p>
            
            <ul>
               
               <li>Add drag and drop to our photo view from <em>Photos</em> apps
               </li>
               
               <li>Add drag and drop from filter scroller</li>
               
            </ul>
            
            <p>The first thing we want to do is enable dragging for our filter items. We need to
               create a new extension to our <kbd>PhotoFilterViewController</kbd> called <kbd>PhotoFilterViewController+UIDropInteraction</kbd>. Inside this file, add the following:
            </p>
            <pre>import UIKit<br/>import Foundation<br/>extension PhotoFilterViewController: UIDropInteractionDelegate {<br/>}</pre>
            <p>Next, we need to add all of the methods needed to accept drop interaction. We will
               write this to allow dropping within the app as well as outside of the app. When you
               start to drag an element, Apple calls this a <strong>session</strong>. There are two primary sessions we will need to watch out for, local sessions or
               non-local sessions. Local sessions mean that we are dragging within our app and if
               that is not happening then it means that the session is coming from a different app.
               Let's handle this by first adding the first method <kbd>-dropInteraction:canHandleSession</kbd>:
            </p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, canHandle session: UIDropSession) -&gt; Bool {<br/>    if session.localDragSession == nil {<br/>        return session.canLoadObjects(ofClass: UIImage.self)<br/>    }<br/>    else { return false }<br/>}</pre>
            <p>This method is where we give permission for items to be dropped into our app as well
               as the local dragging of objects. For a local drag, we are accepting an image and
               for now we are not accepting drops from within the app. We will add this later. Let's
               add the next method that we need to implement, <kbd>-dropInteraction:sessionDidUpdate:</kbd>:
            </p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -&gt; UIDropProposal {<br/>    let operation: UIDropOperation<br/>    if session.localDragSession == nil {<br/>        operation = .copy<br/>    }<br/>    else { operation = .copy }<br/>    return UIDropProposal(operation: operation)<br/><br/>}</pre>
            <p>This method is telling our app how we want to consume data and in both cases we are
               going to copy it. Let's add the next method, <kbd>-dropInteraction:performDrop</kbd>:
            </p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {<br/>    if session.localDragSession == nil {<br/>        for dragItem in session.items {<br/>            loadImage(dragItem.itemProvider)<br/>        }<br/>    }<br/>}</pre>
            <p>This method gets called after the user lifts their finger from the screen. This indicates
               the user's intent to drop the item and this is your opportunity to request the data
               for the drag item. We simply take this data and display it in our Image View; we also
               create filter thumbnails. This behavior is the same behavior we have for selecting
               an image in the picker. Finally, we add our last method to <kbd>-dropInteraction:previewForDroppingItem:withDefault</kbd>:
            </p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, previewForDropping item: UIDragItem, withDefault defaultPreview: UITargetedDragPreview) -&gt; UITargetedDragPreview? {<br/>    if item.localObject == nil {<br/>        return nil<br/>    } else {<br/>        let target = UIDragPreviewTarget(container: view, center: imgExample.center)<br/>        return defaultPreview.retargetedPreview(with: target)<br/>    }<br/>}</pre>
            <p>This last method is creating a preview for the image being dragged into our view.
               When you are done your extension should look like the following:
            </p>
            <pre>import UIKit<br/>import Foundation<br/><br/>extension PhotoFilterViewController: UIDropInteractionDelegate {<br/><br/>    func dropInteraction(_ interaction: UIDropInteraction, canHandle session: UIDropSession) -&gt; Bool {<br/>        if session.localDragSession == nil {<br/>            return session.canLoadObjects(ofClass: UIImage.self)        }<br/>        else { return false }<br/>    }<br/><br/>    func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -&gt; UIDropProposal {<br/>        let operation: UIDropOperation<br/>        if session.localDragSession == nil {<br/>            operation = .copy<br/>        }<br/>        else { operation = .copy  }<br/>        return UIDropProposal(operation: operation)<br/>    }<br/><br/>    func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {<br/>        if session.localDragSession == nil {<br/>            for dragItem in session.items {<br/>                loadImage(dragItem.itemProvider)<br/>            }<br/>        }<br/>    }<br/><br/>    func dropInteraction(_ interaction: UIDropInteraction, previewForDropping item: UIDragItem, withDefault defaultPreview: UITargetedDragPreview) -&gt; UITargetedDragPreview? {<br/>        if item.localObject == nil {<br/>            return nil<br/>        } else {<br/>            let target = UIDragPreviewTarget(container: view, center: imgExample.center)<br/>            return defaultPreview.retargetedPreview(with: target)<br/>        }<br/>    }<br/>}</pre>
            <p>We are now done with implementing dragging from other applications. Now that our drop
               implementation is added, we just need to make sure that our view will accept it. Add
               the following method inside the <kbd>PhotoFilterViewController</kbd>:
            </p>
            <pre>func addDropInteraction() {<br/>    view.addInteraction(UIDropInteraction(delegate: self))<br/>}</pre>
            <p>Here, we are implementing the <kbd>UIDropInteraction</kbd> we just created in our extension. We just need to call this method. Add <kbd>addDropInteraction()</kbd> into the <kbd>initialize()</kbd>. It should now look like the following:
            </p>
            <pre>func initialize() {<br/>    requestAccess()<br/>    addDropInteraction()<br/>    setupCollectionView()<br/>    checkDevice()<br/>}</pre>
            <p>Launch the iPad Air simulator and open the <em>Photos</em> app at the same time. You can now drag from the <em>Photos</em> app directly into our filter area:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/b95a18cc-2acc-4128-969f-7733492bb5a2.png"/></div>
            
            <p>We can also drag from Safari and drop into our filter area:</p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="509" src="assets/dcef129d-f3d7-45ec-b105-7a776f99a3eb.png" width="679"/></div>
            
            <p>We can drag our filter items to our Photo, but it currently does not do anything at
               this time. We have some work to do to get this in.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Dragging and dropping filter items </h1>
            
         </header>
         
         
         <article>
            
            
            <p>In order to make our filter items draggable, we have quite a few things to do. First,
               we need to update our <kbd>PhotoFilterViewController+UIDropInteraction</kbd> file. Open it up, look for the <kbd>-dropInteraction:canHandleSession:</kbd> method, and update the <kbd>else</kbd> statement from <kbd>false</kbd> to the following:
            </p>
            <pre>else { return session.canLoadObjects(ofClass: FilterItem.self) }</pre>
            <p>When you are done, your method will look like the following:</p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, canHandle session: UIDropSession) -&gt; Bool {<br/>    if session.localDragSession == nil {<br/>        return session.canLoadObjects(ofClass: UIImage.self)<br/>    }<br/>    else { return session.canLoadObjects(ofClass: FilterItem.self) }<br/>}</pre>
            <p>You can ignore the error for now. Here, we are just making sure that our <kbd>FilterItem</kbd> class can be dropped and loaded. Now, we need to do one more update in this class:
               find the <kbd>-dropInteraction:performDrop:</kbd> method. After the <kbd>if</kbd> statement we are going to add an <kbd>else</kbd>:
            </p>
            <pre>else {<br/>    for dragItem in session.items {<br/>        let itemProvider = dragItem.itemProvider<br/>        itemProvider.loadObject(ofClass: FilterItem.self) { (object, error) in<br/>            if let error = error {<br/>                print(error.localizedDescription)<br/>            } else {<br/>                DispatchQueue.main.async {<br/>                    if let item = object as? FilterItem {<br/>                        print("filter \(item.filter)")<br/>                        self.filterSelected(item: item)<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
            <p>This <kbd>else</kbd> statement we just added will loop through each item that is being dragged and load
               the object. Our app does not support multiple draggable items, but this is where it
               is handled. When we add this code we will have another error but we will address this
               soon. The <kbd>-dropInteraction:performDrop:</kbd> method should now look like the following:
            </p>
            <pre>func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {<br/>    if session.localDragSession == nil {<br/>        for dragItem in session.items {<br/>            loadImage(dragItem.itemProvider)<br/>        }<br/>    }<br/>    else {<br/>        for dragItem in session.items {<br/>            let itemProvider = dragItem.itemProvider<br/>            itemProvider.loadObject(ofClass: FilterItem.self) { (object, error) in<br/>                if let error = error {<br/>                    print(error.localizedDescription)<br/>                } else {<br/>                    DispatchQueue.main.async {<br/>                        if let item = object as? FilterItem {<br/>                            print("filter \(item.filter)")<br/>                            self.filterSelected(item: item)<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
            <p>We still have two errors that we need to fix; let's fix those next by opening the
               <kbd>FilterItem</kbd> class inside your <kbd>Photo Filter</kbd> folder. Add the following under the <kbd>init</kbd> method:
            </p>
            <pre>required init(itemProviderData data: Data, typeIdentifier: String) throws {<br/>    if typeIdentifier == FilterItem.typeIdentifier {<br/>        let item = try? JSONDecoder().decode(FilterItem.self, from: data)<br/>        if let i = item {<br/>            self.name = i.name<br/>            self.filter = i.filter<br/>            return<br/>        }<br/>    }<br/><br/>    throw ParseError.decodingFailed("Invalid type!")<br/><br/>}</pre>
            <p>We are adding our a <kbd>init</kbd> method that we need for dragging. This allows us to pass the data around. We have
               two errors because we need to conform to <kbd>NSItemProviderReading</kbd> and <kbd>NSItemProviderWriting</kbd>. We will write them both in the same file. In the <kbd>Photo Filter</kbd> folder, create a new <kbd>Swift</kbd> class and add the first extension:
            </p>
            <pre>import UIKit<br/>import MobileCoreServices<br/><br/>extension FilterItem: NSItemProviderReading {<br/><br/>    static var readableTypeIdentifiersForItemProvider: [String] {<br/>        return [FilterItem.typeIdentifier]<br/>    }<br/><br/>    static func object(withItemProviderData data: Data, <br/>      typeIdentifier: String) throws -&gt; Self {<br/>        switch typeIdentifier {<br/>        case FilterItem.typeIdentifier:<br/>            return try! JSONDecoder().decode(self, from: data)<br/>        default:<br/>            throw ParseError.decodingFailed("Invalid type!")<br/>        }<br/>    }<br/>}</pre>
            <p>This extension is to conform to <kbd>NSItemProviderReading</kbd>, which decodes the data that we are passing so that we can read it. Next, add the
               last extension by adding the following after our first extension:
            </p>
            <pre>extension FilterItem: NSItemProviderWriting {<br/>    static var writableTypeIdentifiersForItemProvider: [String] {<br/>        return [FilterItem.typeIdentifier, kUTTypeUTF8PlainText as String]<br/>    }<br/><br/>    func loadData(withTypeIdentifier typeIdentifier: String, forItemProviderCompletionHandler completionHandler: @escaping (Data?, Error?) -&gt; Void) -&gt; Progress? {<br/>        let data: Data?<br/>        switch typeIdentifier {<br/>        case FilterItem.typeIdentifier:<br/>            data = try? JSONEncoder().encode(self)<br/>        case kUTTypeUTF8PlainText as NSString as String:<br/>            data = "\(name), \(filter)".data(using: .utf8)<br/>        default:<br/>            data = nil<br/>        }<br/>        completionHandler(data, nil)<br/>        return nil<br/>    }<br/>}</pre>
            <p>This extension allows us to export our data into a binary representation by first
               making sure the class type is of <kbd>FilterItem</kbd>. We are just about done with all the setup we need. We now need to make sure that
               our Collection View allows dragging. Currently, if you try to drag, nothing will happen.
               Open the <kbd>PhotoFilterViewController</kbd> and, in the <kbd>setupCollectionView()</kbd> method, add the following at the bottom of the method:
            </p>
            <pre>collectionView?.dragDelegate = self</pre>
            <p>Adding this line will show an error, but you can ignore it, as we are about to fix
               it. When you finish, the entire method will look like the following:
            </p>
            <pre>func setupCollectionView() {<br/>    let layout = UICollectionViewFlowLayout()<br/>    if Device.isPhone { layout.scrollDirection = .horizontal }<br/>    else { layout.scrollDirection = .vertical }<br/>    layout.sectionInset = UIEdgeInsets(top: 7, left: 7, bottom: 7, right: 7)<br/>    layout.minimumInteritemSpacing = 0<br/>    layout.minimumLineSpacing = 7<br/><br/>    collectionView?.collectionViewLayout = layout<br/>    collectionView?.dragDelegate = self<br/>}</pre>
            <p>This now enables dragging from a Collection View, but we now implement the drag delegate
               code for it all to work. Before we create another extension, let's create a new folder
               inside the <kbd>Photo Filter</kbd> folder and name this folder <kbd>Extensions</kbd>. Then drag both files we created earlier, <kbd>Filter-Item+NSItemProvider</kbd> and <kbd>PhotoFilterViewController+UIDropInteraction</kbd>, into the <kbd>Extensions</kbd> folder.
            </p>
            
            <p>Now that we have that folder set up right, click the <kbd>Extensions</kbd> folder inside the <kbd>Photo Filter</kbd> folder and create a new file called <kbd>PhotoFilterViewController+ UICollectionViewDrag</kbd>. Once you have created the file, add the following:
            </p>
            <pre>import UIKit<br/><br/>extension PhotoFilterViewController: UICollectionViewDragDelegate {<br/>    func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] {<br/>        let itemProvider = NSItemProvider(object: data[indexPath.item])<br/>        let dragItem = UIDragItem(itemProvider: itemProvider)<br/>        return [dragItem]<br/>    }<br/>}</pre>
            <p>This method <kbd>-collectionView:itemsForBeginningDragSession:atIndexPath:</kbd> we are getting the data for the item at index path as a drag is being made. If the
               array is empty, the drag session will not begin. We are finished; if you build and
               run the project, you will now be able to drag filter items onto the selected photo.
               Let's drag from our filter list:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="524" src="assets/a623d906-b32d-4fea-9dc5-3ca466e5d6b0.png" width="711"/></div>
            
            <p>After dropping the filter item, you should see the following:</p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="522" src="assets/f39195cf-d4eb-46b3-a8f8-a9d806ab061c.png" width="693"/></div>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Summary</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In this chapter, we looked at how to accept drag and drop from other applications.
               We also looked at how to create custom drag items using a Collection View. Now, we
               can use drag and drop on the iPad as a way to quickly add photos whereas the iPhone
               will use the <em>Camera Roll</em> only. Drag and drop is only supported for the iPad at this time, but hopefully soon
               Apple will open this up to us to use in our apps. In the next chapter, we will look
               at how to use Siri to request payments for friends for dinner.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   </body></html>