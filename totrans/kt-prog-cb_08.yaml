- en: Anko Commons and Extension Function
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anko Commons 和扩展函数
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Setting up Anko with Gradle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gradle 设置 Anko
- en: Extending Android framework using extension function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展函数扩展 Android 框架
- en: Using extensions as properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将扩展用作属性
- en: Using intents with Anko
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 的意图
- en: Making a call intent using Anko
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 制作电话意图
- en: Sending a text intent using Anko
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 发送文本意图
- en: Browsing the web browser using Anko
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 浏览网页
- en: Sharing some text using intents in Anko
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 的意图分享一些文本
- en: Sending an email using Anko
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 发送电子邮件
- en: Creating Android dialogs with Anko
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 创建 Android 对话框
- en: Showing an alert dialog with a list of text items
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本项列表显示一个警告对话框
- en: Using Anko in Views
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中使用 Anko
- en: Logging using Anko
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 进行日志记录
- en: Handling dimensions with Anko
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anko 处理尺寸
- en: Version checking in Android
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 中的版本检查
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Anko** is a Kotlin library that was developed to make the Android development
    experience better. Kotlin itself makes Android development easier, and Anko is
    a cherry on top of it. With helpers for almost all common Android functionalities,
    Anko drastically reduces the amount of code you write and makes Android development
    fun.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anko** 是一个 Kotlin 库，它被开发出来以改善 Android 开发体验。Kotlin 本身就使 Android 开发变得容易，而 Anko
    则是它的点睛之笔。Anko 几乎为所有常见的 Android 功能提供了辅助工具，大大减少了你需要编写的代码量，并使 Android 开发变得有趣。'
- en: 'Anko consists of several parts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 由几个部分组成：
- en: '**Anko Commons**: It consists of helper methods for intents, dialogs, logging,
    and so on, which reduces the amount of code significantly.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anko Commons**：它包含了一系列辅助方法，用于处理意图、对话框、日志记录等，显著减少了代码量。'
- en: '**Anko Layouts**: With this library, you don''t have to stick to conventional
    XML to create visual interfaces. Anko layout is a fast and type-safe way to write
    dynamic Android layouts.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anko Layouts**：使用这个库，你不必坚持传统的 XML 来创建视觉界面。Anko 布局是一种快速且类型安全的编写动态 Android
    布局的方法。'
- en: '**Anko SQLite**: This is a query DSL and parser collection for Android SQLite,
    which makes working with underlying SQLite database substantially easy.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anko SQLite**：这是一个 Android SQLite 的查询 DSL 和解析器集合，使得与底层 SQLite 数据库的工作变得非常简单。'
- en: '**Anko Coroutines**: Coroutines are a great way to do asynchronous programming.
    Anko coroutines provide utilities based on the `kotlinx.coroutines` ( [https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)) library.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anko Coroutines**：协程是进行异步编程的绝佳方式。Anko 协程提供了基于 `kotlinx.coroutines`（[https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)）库的实用工具。'
- en: In this chapter, we will learn how to use Anko for Android development. So let's
    get started!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Anko 进行 Android 开发。那么，让我们开始吧！
- en: Setting up Anko with Gradle
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gradle 设置 Anko
- en: We will begin by setting up the Anko library in our project. We will be using
    Gradle to handle the dependencies of the project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的项目中设置 Anko 库。我们将使用 Gradle 来处理项目的依赖关系。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio to write code. You can also find the source code
    in the 1-setting-up-anko-with-gradle branch of repository at [https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 来编写代码。你还可以在[https://gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)存储库的1-setting-up-anko-with-gradle
    分支中找到源代码。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to add Anko to your project using the Gradle build system:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用 Gradle 构建系统将 Anko 添加到你的项目中：
- en: 'The easiest way to set up Anko with Gradle is do it by adding the following
    lines in your `build.gradle` file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Gradle 设置 Anko 的最简单方法是，在你的 `build.gradle` 文件中添加以下行：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can replace `$anko_version` with the latest version of Anko, which is 0.10.1
    when this book was written.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将 `$anko_version` 替换为 Anko 的最新版本，当本书编写时，这个版本是 0.10.1。
- en: 'The preceding compile statement will add all available features (including
    Commons, Layouts, SQLite) into your project at once. If you don''t want that,
    and would prefer adding them separately as needed, here are the compile statements:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的编译语句将一次性将所有可用的功能（包括 Commons、Layouts、SQLite）添加到你的项目中。如果你不想这样做，并且希望按需单独添加它们，以下是一些编译语句：
- en: '`anko-commons`: This library contains a lot of helpers for Android SDK for
    Intents, Dialogs and Toasts, Logging, and Resource and Dimension:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anko-commons`：这个库包含了许多 Android SDK 的辅助工具，用于处理意图、对话框、Toast、日志记录以及资源和尺寸：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Anko Layouts**:Anko Layouts is a DSL for writing dynamic Android layouts:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anko Layouts**：Anko Layouts 是一个用于编写动态 Android 布局的 DSL：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`anko-sqlite`: This provides helpers for working with SQLite database:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anko-sqlite`：这为使用SQLite数据库提供了辅助工具：'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`anko-coroutines`: This library makes it easier to work with Kotlin coroutines:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anko-coroutines`：这个库使得使用Kotlin协程变得更加容易：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extending Android framework using extension function
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展函数扩展Android框架
- en: The heading of this recipe might seem very confusing to you as you might be
    thinking "How can I extend the super complex Android framework? And moreover,
    why should I?" We will be dealing with all the "what, why, and hows" of extension
    functions in this recipe. Extension functions are one of the greatest features
    of Kotlin. So let's dive into it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的标题可能对你来说非常令人困惑，因为你可能会想“我怎么能扩展如此复杂的Android框架？而且更重要的是，为什么我要？”我们将在这个菜谱中处理所有关于扩展函数的“是什么、为什么和怎么做”。扩展函数是Kotlin最伟大的功能之一。所以，让我们深入探讨。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: I'll be using Android Studio for coding. We will be creating extension functions
    for Android SDK classes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio进行编码。我们将为Android SDK类创建扩展函数。
- en: How to do it…
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To begin with, let''s see a very simple example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个非常简单的例子：
- en: 'We will create a very simple class `Student`, and we will create an extension
    function for it:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的类`Student`，并为它创建一个扩展函数：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we would want to create an `isAgeGreaterThan20` function, which will return
    `true` if the age is greater than 20, or else, will return `false`. Now suppose
    there's a restriction that we can't touch the Student class, what will you do?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要创建一个`isAgeGreaterThan20`函数，如果年龄大于20则返回`true`，否则返回`false`。现在假设有一个限制，我们不能触摸`Student`类，你会怎么做？
- en: 'In those scenarios, extension functions come in handy when you want to extend
    the functionality of a class. If you try to call the method, you will be shown
    an error, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些场景中，当你想要扩展类的功能时，扩展函数就派上用场了。如果你尝试调用该方法，你会看到一个错误，如下所示：
- en: '![](img/f2ec5eac-255f-455e-9895-c1f060e66664.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2ec5eac-255f-455e-9895-c1f060e66664.png)'
- en: You then need to select the `Create extension function ....` option to create
    an extension function for it. When you select that option, you'll again be given
    two options, asking which object you want to create the extension function.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要选择`创建扩展函数 ...`选项来为它创建一个扩展函数。当你选择该选项时，你将再次被给出两个选项，询问你想要创建扩展函数的对象。
- en: '![](img/5ae7f8e6-9f9c-44ff-b110-5084ebe6e17a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ae7f8e6-9f9c-44ff-b110-5084ebe6e17a.png)'
- en: 'Since we want to create the function for the `Student` class, we will select
    the Student option from the dropdown. On selecting that, the IDE will autogenerate
    the method body. I''ve modified the return type to return a boolean:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们要为`Student`类创建函数，我们将从下拉菜单中选择`Student`选项。选择它后，IDE将自动生成方法体。我已经将返回类型修改为返回布尔值：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can do the operation inside the method block. Here''s how our method
    looks:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在方法块内执行操作。我们的方法看起来是这样的：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that since we are calling the method on a student object, we can access
    it using the `this` keyword, though you can skip the `this` keyword in this case,
    as we aren't dealing with other objects of the same type in this method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，由于我们是在学生对象上调用该方法，我们可以使用`this`关键字来访问它，尽管在这种情况下你可以省略`this`关键字，因为我们在这个方法中不处理相同类型的其他对象。
- en: 'Now, we can call it just like you would call a normal method:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像调用普通方法一样调用它：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s see an example related to Android. If you''ve used any third-party
    library like `Picasso` or `Glide`, you might remember setting images in `ImageView`
    like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个与Android相关的示例。如果你使用过任何第三方库，如`Picasso`或`Glide`，你可能记得像这样在`ImageView`中设置图片：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can create an extension function for `ImageView` named `loadImage` and
    then call that function in your application. Of course, `loadImage` is not a function
    provided by the `ImageView` class, so you need to create an extension function
    for this purpose. We will call the method on the `imageView` object and pass a `url`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个名为`loadImage`的`ImageView`扩展函数，然后在你的应用程序中调用该函数。当然，`loadImage`不是`ImageView`类提供的函数，所以你需要创建一个扩展函数来达到这个目的。我们将在这个`imageView`对象上调用该方法，并传递一个`url`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that in the `loadImage` function, we are referring `this` to the `ImageView`
    object on which the function was called.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在`loadImage`函数中，我们正在将`this`引用到调用该函数的`ImageView`对象上。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '**Extension functions** are resolved statically, which means they are normal
    static methods and have no connection to the class they are extending (that''s
    why we are able to extend classes to which we don''t have access to modify), other
    than taking an instance of this class as a parameter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展函数**是静态解析的，这意味着它们是普通的静态方法，并且与它们扩展的类（这就是为什么我们能够扩展我们无法修改的类）没有关联，除了接受这个类的实例作为参数。'
- en: 'If you decompile the Kotlin bytecode, you will see the code converted to Java:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你反编译Kotlin的字节码，你会看到代码被转换为Java：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, it is just a static method and takes the class as a parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它只是一个静态方法，并接受类作为参数。
- en: There's more…
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since extension functions come in handy, you might be tempted to use them a
    lot. However, with great power comes great responsibility. Since they are resolved
    statically, you shouldn't be using them everywhere, because static functions are
    difficult to test. Using it irresponsibly means your code will be less testable
    and hence less maintainable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于扩展函数非常有用，你可能想大量使用它们。然而，权力越大，责任越大。由于它们是静态解析的，你不应该在所有地方都使用它们，因为静态函数很难测试。不负责任地使用它们意味着你的代码将更难以测试，因此更难以维护。
- en: Using extensions as properties
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将扩展用作属性
- en: In the last recipe, we learned about extension functions. In this recipe, we
    will learn about extension properties. If you feel the need for one or more properties
    from the class, you can add them using the extension properties. In this recipe,
    we will learn how to use extension properties.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们学习了扩展函数。在这个菜谱中，我们将学习扩展属性。如果你需要从类中获取一个或多个属性，你可以使用扩展属性来添加它们。在这个菜谱中，我们将学习如何使用扩展属性。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio for coding purposes. Ensure that you have the latest
    version of Android Studio with Kotlin configured.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio进行编码。确保你有配置了Kotlin的最新版本的Android Studio。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see an example of an extension property now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看扩展属性的例子：
- en: 'We will be using the example of shared preferences. You might be used to doing
    something like this to get hold of shared preferences:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用共享首选项的例子。你可能习惯于这样做来获取共享首选项：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can create an extension property on the `Context` class with name preferences
    and access it as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`Context`类上创建一个名为偏好的扩展属性，并按以下方式访问它：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The extension functions didn't modify the class, and the same goes with extension
    properties; they don't add properties to the class itself and hence we don't have
    any backing field in their case. Also, since we don't have any backing field,
    we can't initialize it. The only way too deal with them is using custom getter
    and setter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数没有修改类，扩展属性也是如此；它们不会向类本身添加属性，因此我们在这种情况下没有后端字段。由于我们没有后端字段，我们无法初始化它。处理它们的唯一方法是通过自定义获取器和设置器。
- en: There's more…
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Similar to extension properties, we can have companion object extensions, which
    means we can add methods to the companion object of a class that helps us access
    it in a static way. Let''s look at an example. Suppose we have a `Student` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展属性类似，我们可以有伴随对象扩展，这意味着我们可以向类的伴随对象添加方法，帮助我们以静态方式访问它。让我们看一个例子。假设我们有一个`Student`类：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s now add an extension method to the companion object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给伴随对象添加一个扩展方法：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you can access it on the class without creating an instance of the class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在不创建类实例的情况下访问它：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using intents with Anko
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Anko与意图一起使用
- en: '**Intents** are one of the most common components used in Android apps. They
    can be thought of as a messenger used to transfer messages between different Android
    components. For example, you send an intent when you need to start an activity,
    you send an intent when you need to start a service. To launch an activity in
    Android, you are first needed to create an intent and then pass it to the `startActivity`
    method. In the following example, we will try to launch an activity with some
    data and flags:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图**是Android应用中最常用的组件之一。它们可以被看作是用于在不同Android组件之间传递消息的信使。例如，当你需要启动一个活动时，你会发送一个意图；当你需要启动一个服务时，你会发送一个意图。要在Android中启动一个活动，你首先需要创建一个意图，然后将其传递给`startActivity`方法。在下面的例子中，我们将尝试使用一些数据和标志启动一个活动：'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, you can assume an extra line for all data that you pass with the intent.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以假设所有你带有意图传递的数据都占用额外的行。
- en: Anko has a better way to achieve similar results. In this recipe, we will learn
    how to achieve this (launching intents) using Anko library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 有一种更好的方法来实现类似的结果。在本食谱中，我们将学习如何使用 Anko 库实现这一点（启动意图）。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purpose. You need to include Anko
    library in your `build.gradle` file at app level. Just add these lines and you
    are good to go:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码目的。您需要在您的 `build.gradle` 文件中在 app 级别包含 Anko 库。只需添加这些行，然后您就可以开始了：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Creating an intent in Anko is very simple. Let''s check the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anko 中创建意图非常简单。让我们检查以下步骤：
- en: 'The functionality for which we wrote the preceding code can be achieved in
    just a few lines with Anko:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们前面编写的代码所实现的功能，使用 Anko 只需几行代码就可以实现：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you don''t want to add the flag, it is much simpler:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不想添加标志，这要简单得多：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adding extra data doesn''t require extra lines:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加额外数据不需要额外的行：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s see the implementation of the preceding methods in the source code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面方法的源代码实现：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `intentFor` method takes `vararg` as a parameter, hence we are able to
    supply multiple data to it. This method calls `createIntent`, which actually creates
    an intent with supplied data, and it looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`intentFor` 方法接受 `vararg` 作为参数，因此我们可以向其提供多个数据。此方法调用 `createIntent`，它实际上创建了一个包含提供数据的意图，其外观如下：'
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, internally it creates the intent in the old fashion and calls
    `fillIntentArguments`, which fills the intent with the data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它以传统的方式内部创建意图，并调用 `fillIntentArguments`，该函数将数据填充到意图中。
- en: Making a call intent using Anko
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 创建拨打电话的意图
- en: In the last recipe, we learned how to create an intent using Anko library. In
    subsequent recipes, we will see how to do common things like sending messages,
    calls, mails, and so on using intents in Anko.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们学习了如何使用 Anko 库创建意图。在随后的食谱中，我们将看到如何使用 Anko 中的意图执行常见操作，如发送消息、拨打电话、发送邮件等。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purposes. You need to include Anko
    library in your `build.gradle` file. Just add the following lines to your `build.gradle`
    file and you are good to go:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码。您需要在您的 `build.gradle` 文件中包含 Anko 库。只需将以下行添加到您的 `build.gradle`
    文件中，然后您就可以开始了：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also clone the [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    repository and switch to the 3-intent-actions branch to get the source code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以克隆 [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    仓库并切换到 3-intent-actions 分支以获取源代码。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s follow the given steps to make a call using intents:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤使用意图拨打电话：
- en: 'Anko provides wrappers around the most common actions that can be done using
    intents; one of them is making calls. For this purpose, Anko provides the `makeCall`
    function, which takes in the phone number you want to call:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Anko 提供了围绕使用意图可以执行的最常见操作的包装器；其中之一是拨打电话。为此，Anko 提供了 `makeCall` 函数，该函数接受您想要拨打的电话号码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `makeCall` function returns true if the action was successful, or returns
    false if it wasn''t. One thing to note is that you need to add the `CALL_PHONE`
    permission in your manifest file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makeCall` 函数在操作成功时返回 true，如果操作未成功则返回 false。需要注意的是，您需要在您的清单文件中添加 `CALL_PHONE`
    权限：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s see the source code of `makeCall function`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `makeCall 函数` 的源代码：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Beneath the wrapper, it's doing the same old way Android SDK used to do, that
    is, using an implicit intent of action `Intent.ACTION_CALL`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装器下面，它正在以 Android SDK 以前使用的老方法进行操作，即使用一个动作 `Intent.ACTION_CALL` 的隐式意图。
- en: Sending a text intent using Anko
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 发送文本意图
- en: Anko provides a wrapper around the intent actions, which makes calling actions
    super easy. One of those actions is sending an SMS. In this recipe, we will see
    how to launch an intent that sends messages to a telephone number.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供了围绕意图操作的包装器，这使得调用操作变得非常简单。其中之一就是发送短信。在本食谱中，我们将看到如何启动一个向电话号码发送消息的意图。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purposes. You need to include Anko
    library in your `build.gradle` file. Just add the given lines and you are good
    to go:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码。您需要在您的 `build.gradle` 文件中包含 Anko 库。只需添加给定的行，然后您就可以开始了：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also clone the [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    repository and switch to the 3-intent-actions branch to get the source code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以克隆 [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    仓库并切换到 3-intent-actions 分支以获取源代码。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s follow these steps to send an SMS using intents:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤使用意图发送短信：
- en: 'Anko provides the `sendSMS` method, which takes in two parameters—one of them
    is the phone number, and the other is the message:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Anko 提供了 `sendSMS` 方法，它接受两个参数——其中一个参数是电话号码，另一个是消息：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Calling this method will launch the messaging app, or will ask you which messaging
    app to launch if you have more than one type of that app and will prefill the
    message body. Calling this function requires you to add the following permission,
    without which it will throw a Security Exception:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用此方法将启动消息应用，或者如果您有多个此类应用，它将询问您要启动哪个消息应用，并将预先填充消息正文。调用此函数需要您添加以下权限，否则它将抛出安全异常：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To understand how its working, let''s dive into its implementation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其工作原理，让我们深入了解其实现：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, it uses an implicit intent to launch the messaging app on your
    device. Since this function requires a context, if you are calling it from a fragment,
    you need to call it as `activity.sendSMS(..)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用隐式意图在您的设备上启动消息应用。由于此函数需要一个上下文，如果您从片段中调用它，您需要将其作为 `activity.sendSMS(..)`
    调用。
- en: Browsing the web browser using Anko
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 浏览网络浏览器
- en: In this recipe, we will talk about the Anko wrapper that will help us browse
    the website using a web browser. So let's get started.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论 Anko 包装器，它将帮助我们使用网络浏览器浏览网站。那么，让我们开始吧。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purpose. You need to include Anko
    library in your `build.gradle` file. Just add this line of code and you are good
    to go:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码。您需要在您的 `build.gradle` 文件中包含 Anko 库。只需添加以下代码行，您就可以开始了：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can also clone the [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    repository and switch to the `3-intent-actions` branch to get the source code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以克隆 [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    仓库并切换到 `3-intent-actions` 分支以获取源代码。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Now, let's see how to launch a browser using an intent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用意图启动浏览器。
- en: 'Anko provides a `browse` function, which takes in the web address and launches
    the browser on your device. If you have multiple browsers, it will show you some
    options to select it. Here''s an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供了一个 `browse` 函数，它接受网页地址并在您的设备上启动浏览器。如果您有多个浏览器，它将显示一些选项供您选择。以下是一个示例：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The web address you put in the parameter needs to have `http://` or `https://`
    as the prefix, otherwise it will throw an `ActivityNotFound` exception.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您放入参数中的网页地址需要以 `http://` 或 `https://` 作为前缀，否则它将抛出 `ActivityNotFound` 异常。
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `browse` function provided by Anko is just a syntactic sugar, beneath which
    we have the same old code that we used previously:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供的 `browse` 函数只是一个语法糖，其下是我们之前使用的相同代码：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Calling this method returns true or false, based on whether the action was successful
    or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法返回 true 或 false，这取决于操作是否成功。
- en: Sharing some text using intents in Anko
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 的意图共享一些文本
- en: In this recipe, we will look at how to share text using Anko wrapper. Sharing
    text is a very common thing and Anko provides a wrapper for this action that is
    very easy to use. So let's get started!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何使用 Anko 包装器来共享文本。共享文本是一个非常常见的事情，Anko 为此提供了一个非常容易使用的包装器。那么，让我们开始吧！
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purposes. You need to include Anko
    library in your `build.gradle` file. Just add the given lines and you are good
    to go:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码目的。您需要在您的 `build.gradle` 文件中包含 Anko 库。只需添加给定的代码行，您就可以开始了：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also clone the repository at [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `3-intent-actions` branch to get the source code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以克隆 [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    仓库并切换到 `3-intent-actions` 分支以获取源代码。
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following steps, we will see how to share text using an intent:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将看到如何使用意图共享文本：
- en: 'Anko provides a `share` method, which takes in a string parameter, that is,
    the text to share and an optional parameter subject. The subject parameter can
    be particularly useful to share text via an email app. After all, who sends a
    subject for a whatsapp message, right? Let''s see its implementation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Anko 提供了一个 `share` 方法，该方法接受一个字符串参数，即要分享的文本和一个可选的参数 subject。主题参数在通过电子邮件应用分享文本时特别有用。毕竟，谁会给
    WhatsApp 消息加上主题呢？让我们看看它的实现：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Without the subject—this won''t fill in the subject line in the mail:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有主题——这不会填写邮件的主题行：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's that simple!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到这种程度！
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If you look at the implementation, you will find that Anko has provided just
    a syntactic sugar that greatly reduces your lines of code to achieve a similar
    thing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看实现，你会发现 Anko 只提供了语法糖，这大大减少了你的代码行数，以实现类似的功能：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the library has taken care of all the issues that might crop
    up and just provided a helper function to make things faster and more fun.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，库已经处理了可能出现的所有问题，并只提供了一个辅助函数来使事情更快、更有趣。
- en: Sending an email using Anko
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 发送电子邮件
- en: In this recipe, we will see how to send an email using Anko's wrapper. Sending
    an email is very useful as almost all apps provide a method of contact. So let's
    get started!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用 Anko 的包装器发送电子邮件。发送电子邮件非常有用，因为几乎所有的应用都提供了一个联系方式。所以，让我们开始吧！
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for coding purposes. You need to include Anko
    library in your `build.gradle` file. Just add these lines and you are good to
    go:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 进行编码。你需要在你的 `build.gradle` 文件中包含 Anko 库。只需添加以下行即可：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can also clone the repository at [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    and switch to the `3-intent-actions` branch to get the source code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [gitlab.com/aanandshekharroy/Anko-examples](https://gitlab.com/aanandshekharroy/Anko-examples)
    仓库中克隆，切换到 `3-intent-actions` 分支以获取源代码。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will use the `email` function provided by Anko library that takes three
    parameters, out of which only one is mandatory:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Anko 库提供的 `email` 函数，该函数接受三个参数，其中只有一个参数是必需的：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can remove the subject and text if you don't want prefilled text in the
    email.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在电子邮件中预填充文本，你可以移除主题和文本。
- en: How it works…
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s take a look at its implementation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实现：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, it checks for the extra data, such as the subject and message
    body, and then launches the email application. The email function provided by
    Anko is just a convenient method that reduces your line of code and makes your
    code look good.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它会检查额外的数据，例如主题和消息正文，然后启动电子邮件应用。Anko 提供的电子邮件函数只是一个方便的方法，它可以减少你的代码行数，并使你的代码看起来更美观。
- en: Creating Android dialogs with Anko
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 创建 Android 对话框
- en: One of the really great features of Anko library is that it can help you create
    alert dialog quite easily and with much less code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 库的一个真正出色的功能是它可以帮助你轻松且代码量更少地创建警报对话框。
- en: In this recipe, we will see how to create alert dialogs in Anko.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何在 Anko 中创建警报对话框。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio to write code. You also need to include the Anko
    library by adding the following lines to your `build.gradle` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 来编写代码。你还需要通过在你的 `build.gradle` 文件中添加以下行来包含 Anko 库：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can find the source code in the 2-creating-dialogs-using-anko branch of
    the [https://gitlab.com/aanandshekharroy/Anko-examples/](https://gitlab.com/aanandshekharroy/Anko-examples/) repository.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://gitlab.com/aanandshekharroy/Anko-examples/](https://gitlab.com/aanandshekharroy/Anko-examples/)
    仓库的 `2-creating-dialogs-using-anko` 分支中找到源代码。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s follow the mentioned steps to create a dialog in Kotlin:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照提到的步骤在 Kotlin 中创建一个对话框：
- en: 'In the first example, we will try to create a simple alert box. To create it,
    you just need to follow this syntax:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将尝试创建一个简单的警报框。要创建它，你只需要遵循以下语法：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you try to run it, you will see something like this:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试运行它，你会看到类似这样的内容：
- en: '![](img/566c798e-ee90-4723-888b-5b0d941edf00.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/566c798e-ee90-4723-888b-5b0d941edf00.jpeg)'
- en: 'There are certain situations where you want the user to perform some actions,
    and so Anko provides you the methods for it. Check out the following example:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一些情况下，你希望用户执行某些操作，因此 Anko 为此提供了方法。查看以下示例：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This inflates the alert dialog, as illustrated:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如上图所示，它填充了警报对话框：
- en: '![](img/54361399-b69a-4644-badb-2045d793508a.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54361399-b69a-4644-badb-2045d793508a.jpeg)'
- en: 'You can also customize the text of `yesButton` and `noButton` by replacing
    them with `positiveButton` and `negativeButton`. Here''s an example:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以通过将它们替换为 `positiveButton` 和 `negativeButton` 来自定义 `yesButton` 和 `noButton`
    的文本。以下是一个示例：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you run the preceding code, you will see a dialog appearing on your device,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你将在设备上看到一个对话框出现，如下所示：
- en: '![](img/f3464484-7132-4981-913e-81b073cbd23c.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3464484-7132-4981-913e-81b073cbd23c.jpeg)'
- en: 'Another common type of dialog used in Android development is a progress dialog.
    You can use Anko to create a progress dialog like this:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 开发中常用的一种对话框类型是进度对话框。你可以使用 Anko 创建一个像这样的进度对话框：
- en: '![](img/480762d5-81a6-4cb1-bd6e-66db83fd8304.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/480762d5-81a6-4cb1-bd6e-66db83fd8304.jpeg)'
- en: 'This kind of progress dialogs is good for showing the user how much progress
    is made. It also provides functions such as `incrementProgressBy`, by which you
    can increase the progress bar. To create such a progress dialog, you need to use
    it like this example:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种进度对话框非常适合显示用户已完成的进度。它还提供了诸如 `incrementProgressBy` 这样的功能，通过它可以增加进度条。要创建这样的进度对话框，你需要像以下示例那样使用它：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Perhaps you would like to have an indefinite progress bar, which looks like
    this:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也许你想要一个不确定的进度条，看起来像这样：
- en: '![](img/ea0ce6a8-8a54-4079-9223-361c32a6a2f1.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea0ce6a8-8a54-4079-9223-361c32a6a2f1.jpeg)'
- en: 'To create an indeterminate progress dialog as in the preceding screenshot,
    simply add the following lines to your previous code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不确定的进度对话框，就像前面的截图所示，只需将以下行添加到之前的代码中：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Showing an alert dialog with a list of text items
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示包含文本项的警告对话框
- en: 'In the previous recipe, we saw how to create different types of dialogs. In
    this recipe, we will see how to create an alert dialog with a list of text items,
    which looks as illustrated in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何创建不同类型的对话框。在本菜谱中，我们将看到如何创建一个包含文本项的警告对话框，其外观如图所示：
- en: '![](img/390e623f-5f95-421b-9087-e9ba66b8efc1.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/390e623f-5f95-421b-9087-e9ba66b8efc1.jpeg)'
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio to write code. You also need to include the Anko
    library by adding these lines to your `build.gradle` file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 编写代码。你还需要通过在 `build.gradle` 文件中添加以下行来包含 Anko 库：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it…
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's go through the given steps to create an alert dialog with a list of items.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤创建一个包含项目列表的警告对话框。
- en: 'Anko provides selectors for creating a dialog with a list of items. Selectors
    are very easy to use. You just need to provide the title of alert dialog, the
    list, and the lambda that will be executed when an option is selected. Here''s
    an implementation of it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供了用于创建包含项目列表的对话框的选择器。选择器非常易于使用。你只需要提供警告对话框的标题、列表以及当选项被选中时将执行的 lambda 表达式。以下是其实施示例：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That's all folks! It's really simple and concise. So, in the preceding example,
    if you click on the list item, you will see a toast with a message that says "So
    you work at Google, right?"
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这真的很简单和简洁。所以，在前面的示例中，如果你点击列表项，你将看到一个消息提示，上面写着“所以你在谷歌工作，对吧？”
- en: How it works…
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Anko hides all the complexity and gives you an easy-to-use function to achieve
    complex things. Let''s check out the implementation of the selector function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 隐藏了所有复杂性，并为你提供了一个易于使用的函数来实现复杂的事情。让我们来看看选择器函数的实现：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, beneath the surface, it's just like the old way, but Anko provides
    syntactic sugar, which helps us achieve the same thing with less code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在表面之下，它和以前的方法一样，但 Anko 提供了语法糖，这有助于我们用更少的代码实现相同的事情。
- en: Using Anko in Views
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中使用 Anko
- en: Anko makes handling views and creating layouts extremely fast and easy. Using
    Anko, we can write clean code that is easy to read and write. In this recipe,
    we will learn how Anko can be used when dealing with views in Android.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 使处理视图和创建布局变得极其快速和简单。使用 Anko，我们可以编写易于阅读和编写的干净代码。在本菜谱中，我们将学习 Anko 在处理 Android
    中的视图时如何使用。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+ as we won''t
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko dependencies to your project
    by adding the following lines to your app level `build.gradle` file and syncing
    the project:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。你可以通过在Android Studio 3+中创建一个新的项目并添加一个空白活动来开始，因为我们不会使用其他菜谱中的任何代码。你还需要对Android开发有一个中级理解。确保你已经通过在你的app级别的`build.gradle`文件中添加以下行并将项目同步来添加Anko依赖项：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, `$anko_version` is the latest version of Anko out there.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$anko_version`是Anko的最新版本。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Anko makes some common Android development stuff extremely easy, such as toasts,
    snackbars, and dialogs. Usually, showing these views takes a lot of code. Let''s
    see how it is just a matter of a few lines of easy code with Anko:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Anko使一些常见的Android开发任务变得极其简单，例如toast、snackbar和对话框。通常，显示这些视图需要大量的代码。让我们看看Anko是如何仅用几行简单的代码就能做到的：
- en: '**Alert dialog**: A popup that appears on top of your view, commonly used for
    alerts:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告对话框**：一个出现在你视图顶部的弹出窗口，通常用于警告：'
- en: 'To show an alert, we use the following syntax (DSL syntax):'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示一个警告，我们使用以下语法（DSL语法）：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Consider that we use a dialog from the `Appcompat` dialog factory:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们使用`Appcompat`对话框工厂中的对话框：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also show progress dialogs and indeterminate progress dialogs:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以显示进度对话框和不定进度对话框：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Toasts**: They can be used to display information for a short period of time:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**Toast**：它们可以用来显示短时间的信息：'
- en: 'To show a toast, we can make use of one of the following syntaxes based on
    the need of the situation:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据具体情况，我们可以使用以下语法之一来显示toast：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Snackbar**: Snackbars are just like Toast messages, except that they provide
    action to interact with:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**Snackbar**：Snackbar与Toast消息类似，但它们提供了与它们交互的操作：'
- en: 'There are different ways to show snackbars, based on whether you use string
    or string resource and what is the duration of timeout of the snackbar and whether
    you need an action button or not. For showing snackbars, you need a reference
    to the parent view in which you wish to show a snackbar. In the case of XML, you
    can find a method by Anko to get the view from its ID or in the case of DSL, you
    can directly use the variable in which you have stored the parent view. Here are
    some syntaxes that we can use:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你是否使用字符串或字符串资源以及snackbar的超时时间长度以及是否需要操作按钮，有不同方式来显示snackbar。为了显示snackbar，你需要一个指向你希望显示snackbar的父视图的引用。在XML的情况下，你可以通过Anko找到一个方法来通过ID获取视图，在DSL的情况下，你可以直接使用存储父视图的变量。以下是我们可以使用的一些语法：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Anko makes it easier to define layouts and handle already created layouts (in
    XML).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Anko使定义布局和处理已创建的布局（在XML中）变得更加容易。
- en: '**Creating a layout in DSL**:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**在DSL中创建布局**：'
- en: 'Creating a layout in DSL is very simple, and we can put it directly in the `onCreate()`
    method of activity, as in the following code:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DSL中创建布局非常简单，我们可以直接将其放在活动的`onCreate()`方法中，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, we can put it in an external class that implements the `AnkoComponent`
    interface:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们也可以将其放在一个实现`AnkoComponent`接口的外部类中：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Also, this is how our layout looks:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，这就是我们的布局看起来：
- en: '![](img/0787be2d-8bd0-4073-9d6a-eaa3aceb09ea.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0787be2d-8bd0-4073-9d6a-eaa3aceb09ea.jpeg)'
- en: '**Handling views of an already existing XML layout**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理已存在的XML布局的视图**：'
- en: 'Suppose we have the following XML layout from one of our old projects:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个来自我们旧项目的以下XML布局：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can use Anko to access the views from this XML layout and also get/set properties
    of these views. Check out this code:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Anko从这个XML布局中访问视图，也可以设置/获取这些视图的属性。查看以下代码：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is how our layout looks:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的布局看起来：
- en: '![](img/e61718f6-10e1-46df-8c7a-0a85481acb8a.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e61718f6-10e1-46df-8c7a-0a85481acb8a.jpeg)'
- en: Logging using Anko
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Anko进行日志记录
- en: Logging is a great way to debug your application. You might have used `android.util.Log`,
    which wasn’t a very convenient way to log messages as it required you to provide
    the `Log` tag with every message and also required you to define the tag, which
    was usually the class name every time. Anko provides the anko-logger, which comes
    with anko-commons. It is a very convenient way of logging messages as it doesn’t
    require you to necessarily override the log tag. In this recipe, we will learn
    how to do it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是调试应用程序的绝佳方式。你可能已经使用过 `android.util.Log`，这不是一个很方便的记录消息的方式，因为它要求你为每条消息提供
    `Log` 标签，并且还需要你定义标签，这通常每次都是类名。Anko 提供了 anko-logger，它包含在 anko-commons 中。这是一个非常方便的记录消息的方式，因为它不需要你一定覆盖日志标签。在本食谱中，我们将学习如何做到这一点。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio to write the code. You need to add `anko-commons`
    to your `build.gradle` file. Anko logger comes within the `anko-commons` library:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 来编写代码。你需要在你的 `build.gradle` 文件中添加 `anko-commons`。Anko 日志记录器包含在
    `anko-commons` 库中：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How to do it…
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow the given steps to learn how to use logging with the help of Anko library:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用 Anko 库进行日志记录：
- en: 'Logging in to Anko is very simple. You just need to implement `AnkoLogger`,
    as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Anko 中进行日志记录非常简单。你只需要实现 `AnkoLogger`，如下所示：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, you can log messages, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以按照以下方式记录消息：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following are the various levels of logging and their comparison with `android.Log.util`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是对各种日志级别及其与 `android.Log.util` 的比较：
- en: '| **android.util.Log** | **AnkoLogger** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **android.util.Log** | **AnkoLogger** |'
- en: '| `v()` | `verbose()` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `v()` | `verbose()` |'
- en: '| `d()` | `debug()` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `d()` | `debug()` |'
- en: '| `i()` | `info()` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `i()` | `info()` |'
- en: '| `w()` | `warn()` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `w()` | `warn()` |'
- en: '| `e()` | `error()` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `e()` | `error()` |'
- en: '| `wtf()` | `wtf()` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `wtf()` | `wtf()` |'
- en: 'The default tag name is a class name. If you want to override the `log` tag,
    you need to override the `loggertag` property:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的标签名称是类名。如果你想覆盖 `log` 标签，你需要覆盖 `loggertag` 属性：
- en: '[PRE64]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can also use logger as a plain object. The following is an example from
    the documentation that uses logger as a plain object:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以将记录器用作普通对象。以下是从文档中提供的示例，它使用记录器作为普通对象：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Each method has two versions: plain and lazy (inlined):'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个方法都有两个版本：普通和懒加载（内联）：
- en: '[PRE66]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The lazy version is executed if `Log.isLoggable(tag, Log.INFO)` is true.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `Log.isLoggable(tag, Log.INFO)` 为真，则执行懒加载版本。
- en: Handling dimensions with Anko
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anko 处理维度
- en: In XML, we use `dp` or `dip` as **density independent pixels** for layouts and
    views and `sp` as scale independent pixels for text. `dp` is a virtual pixel used
    to define layout sizes in a density-independent way; `sp` is like `dp`, but it's
    also scaled according to the user's font preference. In this recipe, we will understand
    how we can define dimensions of views and text in `dp` and `sp` in DSL layouts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 中，我们使用 `dp` 或 `dip` 作为布局和视图的**密度无关像素**，使用 `sp` 作为文本的**缩放无关像素**。`dp` 是一个虚拟像素，用于以密度无关的方式定义布局大小；`sp`
    与 `dp` 类似，但它还会根据用户的字体偏好进行缩放。在本食谱中，我们将了解如何在 DSL 布局中定义视图和文本的 `dp` 和 `sp` 维度。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+ as we won''t
    be using any code from other recipes. You also need an intermediate understanding
    of Android development. Ensure that you have added Anko dependencies to your project
    by adding the following lines to your app-level `build.gradle` file and syncing
    the project:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以在 Android Studio 3+ 中创建一个新的项目，并添加一个空白活动来开始，因为我们不会使用其他食谱中的任何代码。你还需要对
    Android 开发有一个中级理解。确保你已经通过在你的 app-level `build.gradle` 文件中添加以下行并将项目同步来添加 Anko 依赖项：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, `$anko_version` is the latest version of Anko out there.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$anko_version` 是 Anko 的最新版本。
- en: How to do it…
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In the given steps, we will learn how to work with dimensions using Anko library:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的步骤中，我们将学习如何使用 Anko 库来处理维度：
- en: 'Let''s make a layout with a button of 120 `dip` width and `wrapContent` height
    and a text view with 24 `sp` text size. I suggest you to do this on your own,
    using this syntax:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含 120 `dip` 宽度和 `wrapContent` 高度的按钮以及一个 24 `sp` 文字大小的文本视图的布局。我建议你自己尝试，使用以下语法：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is one way you can create the layout using the `dip()` and `sp()`
    methods. `sp` is usually used for text, but to demonstrate, I have used it for
    a view height in the next example. Anko takes the value of the `textSize` property
    in `sp` by default, while you have to provide float:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是通过使用 `dip()` 和 `sp()` 方法创建布局的一种方式。`sp` 通常用于文本，但为了演示，我在下一个示例中使用了它来设置视图的高度。Anko
    默认将 `textSize` 属性的值转换为 `sp`，而您必须提供浮点数：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following is how our layout looks:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们布局的外观：
- en: '![](img/12671ffd-fe19-4557-8d32-97d95cc2bcf6.jpeg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12671ffd-fe19-4557-8d32-97d95cc2bcf6.jpeg)'
- en: Anko also provides additional methods for our convenience, which are `px2dip(pixels)`
    and `px2sp(pixels)`, to convert pixels to `dip` and `sp` respectively. I remember
    coding them by hand before Anko existed, so they are handy a lot of times.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Anko 还提供了方便我们的额外方法，即 `px2dip(pixels)` 和 `px2sp(pixels)`，分别用于将像素转换为 `dip` 和 `sp`。我记得在
    Anko 存在之前手动编写这些代码，所以它们在许多时候都很有用。
- en: Version checking on Android
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 版本检查
- en: 'Android versions are shipped out very frequently. With every latest version
    of Android, you get new features and new improvements. Though Google tries very
    hard to provide backward compatibility, they aren''t able to do so always. For
    example, there is no backward compatibility for Material design components; you
    need to be targeting API levels greater than 21 in order to use them. This requires
    the developer to check beforehand whether the component is supported on that API
    level or not to ensure that your app runs smoothly on all levels. We usually do
    that as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Android 版本发布非常频繁。随着每个最新版本的 Android，您都会获得新的功能和改进。尽管谷歌非常努力地提供向后兼容性，但他们并不总是能够做到。例如，Material
    设计组件没有向后兼容性；您需要针对 API 级别大于 21 才能使用它们。这要求开发者事先检查该 API 级别是否支持该组件，以确保您的应用程序在所有级别上都能平稳运行。我们通常这样做：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Anko provides helper functions that help us achieve similar things but with
    easier syntax. In this recipe, we will see how to use it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 提供了辅助函数，帮助我们以更简单的语法实现类似的功能。在本教程中，我们将看到如何使用它。
- en: Getting ready
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio to write code. You also need to include the Anko
    library by adding these lines to your `build.gradle` file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 来编写代码。您还需要通过在 `build.gradle` 文件中添加以下行来包含 Anko 库：
- en: '[PRE71]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How to do it…
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'It''s very easy to add version checks in Anko, and Anko provides two main functions
    for it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anko 中添加版本检查非常简单，Anko 为此提供了两个主要函数：
- en: '`doIfSdk `: This takes in the version code as a parameter, and also a function.
    If the API level of device is equal to the version code supplied, the function
    is executed. Here''s an example of this function:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doIfSdk`：这个函数接受版本代码作为参数，以及一个函数。如果设备的 API 级别等于提供的版本代码，则执行该函数。以下是这个函数的一个示例：'
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`doFromSdk `: This also takes in the version code as a parameter, along with
    the function, and executes that function if the device SDK level is greater than
    or equal to the supplied version code. The following is an example of the same:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFromSdk`：这个函数也接受版本代码作为参数，以及一个函数，如果设备的 SDK 级别大于或等于提供的版本代码，则执行该函数。以下是这个函数的一个示例：'
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works…
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s see the implementation of the preceding two helper methods:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面两个辅助方法的实现：
- en: 'For `doIfSdk`:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于 `doIfSdk`:'
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For `doFromSdk`:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于 `doFromSdk`:'
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, it's just old Android SDK code behind the hood. The `doFromSdk`
    and `doIfSdk` are just the syntactic sugars on top of it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是隐藏在背后的旧 Android SDK 代码。`doFromSdk` 和 `doIfSdk` 只是其上层的语法糖。
