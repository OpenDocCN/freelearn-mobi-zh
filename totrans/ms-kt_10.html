<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer152">
			<h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor121"/>10</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor122"/>Debugging Your App</h1>
			<p>Debugging is a very important aspect of developing apps. It helps us identify and fix bugs in our code. It is a very important skill to have as a developer. It also helps us avoid bugs in the future. Many tools can help us debug our code. In this chapter, we will be looking at some of the tools that can help us debug <span class="No-Break">our code.</span></p>
			<p>In this chapter, we will learn debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to inspect our Room database, network requests, and background tasks using <span class="No-Break">App Inspection.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>General debugging tips <span class="No-Break">and tricks</span></li>
				<li>Detecting leaks <span class="No-Break">with LeakCanary</span></li>
				<li>Inspecting network requests <span class="No-Break">with Chucker</span></li>
				<li>Using <span class="No-Break">App Inspection</span></li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor123"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) </span><span class="No-Break">downloaded.</span></p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor124"/>General debugging tips and tricks</h1>
			<p>Android Studio provides us with a variety of features that help us debug our code. Some of the features are listed in the <span class="No-Break">following points:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Logcat</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Stack Traces</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Breakpoints</strong></span></li>
			</ul>
			<p>Let us look at each of <span class="No-Break">these closely.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor125"/>Logcat</h2>
			<p>Logcat in Android Studio displays log <a id="_idIndexMarker476"/>messages in real-time from our apps. Each log message has a<a id="_idIndexMarker477"/> priority level attached to it. We add log messages in our app using the <strong class="source-inline">Log</strong> class. This class offers different priority levels that we can use to log messages. The different priority levels are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">V</strong>: Verbose (<span class="No-Break">lowest priority)</span></li>
				<li><span class="No-Break"><strong class="bold">D</strong></span><span class="No-Break">: Debug</span></li>
				<li><span class="No-Break"><strong class="bold">I</strong></span><span class="No-Break">: Info</span></li>
				<li><span class="No-Break"><strong class="bold">W</strong></span><span class="No-Break">: Warning</span></li>
				<li><span class="No-Break"><strong class="bold">E</strong></span><span class="No-Break">: Error</span></li>
				<li><span class="No-Break"><strong class="bold">F</strong></span><span class="No-Break">: Fatal</span></li>
				<li><strong class="bold">S</strong>: Silent (<span class="No-Break">highest priority)</span></li>
			</ul>
			<p>We use the preceding letters to specify the log level. For example, if we want to log a message with the debug level, we will use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
Log.d("TAG", "Message")</pre>			<p>The first parameter is the tag. The tag is used to identify the source of a log message. The second parameter is the<a id="_idIndexMarker478"/> message that we want to log. Each time <a id="_idIndexMarker479"/>we run our app, Logcat shows up at the bottom of the Android Studio window, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B19779_10_01.jpg" alt="Figure 10.1 – Logcat" width="1057" height="227"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Logcat</p>
			<p>From the preceding figure, we can see at the top that the Logcat window shows the device we are running our app on. In this case, we are running our app on a <strong class="bold">Pixel 6 Pro API 33</strong> emulator; yours can be different depending on the emulator you have installed. Next to the device, we can see the <strong class="bold">package</strong> of the app we are running. This has a search bar that allows us to search for specific logs with their tags. Below the search are the actual logs. We can see that each log has a tag, the priority level, the package name of the app, the time the log was created, and the message. We can also see that the logs are color-coded. To see all the color settings for our Logcat, we go to <strong class="bold">Settings</strong> | <strong class="bold">Editor </strong>| <strong class="bold">Color Scheme</strong> | <strong class="bold">Android Logcat</strong>, which shows the color settings as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B19779_10_02.jpg" alt="Figure 10.2 – Logcat color settings" width="926" height="700"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Logcat color settings</p>
			<p>This way, we can set a color <a id="_idIndexMarker480"/>scheme for our Logcat. In the preceding figure, the color scheme has been set to <strong class="bold">Classic Light</strong>. There is a list that shows<a id="_idIndexMarker481"/> the colors for each log level, and you can change the color for each log level. We can also change the font style and size for <span class="No-Break">our Logcat.</span></p>
			<p>With this, let us see how to create our first Logcat message. Let us head over to the <strong class="source-inline">MainActivity.kt</strong> file and add a log message in the <strong class="source-inline">onCreate()</strong> method <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Log.d("First Log", "This is our first log message")</pre>			<p>Run the app and add <strong class="source-inline">First Log</strong> as a search query in the <span class="No-Break">search bar:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B19779_10_03.jpg" alt="Figure 10.3 – Logcat search" width="1058" height="123"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Logcat search</p>
			<p>This only shows the log<a id="_idIndexMarker482"/> message that has the tag <strong class="bold">First Log</strong>. This is particularly<a id="_idIndexMarker483"/> useful when we have a lot of logs, and we want to search for a <span class="No-Break">specific log.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor126"/>Stack traces</h2>
			<p>A <strong class="bold">stack trace</strong> is a list of method calls from the<a id="_idIndexMarker484"/> point where the app was<a id="_idIndexMarker485"/> started to the point where the exception was thrown. It is extremely useful in helping us identify the cause of an exception. Stack traces are normally displayed <span class="No-Break">in Logcat.</span></p>
			<p>To be able to see our first stack trace, let us head over to the <strong class="source-inline">MainActivity.kt</strong> file and add the following code in the <span class="No-Break"><strong class="source-inline">onCreate()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
throw RuntimeException("This is a crash")</pre>			<p>The preceding code will cause the app to crash when you run it. The app crashes immediately after executing the preceding code, and by checking our Logcat, we should be able to see the <span class="No-Break">stack trace:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B19779_10_04.jpg" alt="Figure 10.4 – Crash stack trace" width="1381" height="462"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Crash stack trace</p>
			<p>As shown in the preceding figure, the stack trace shows the exception or reason for the crash. Additionally, it shows the class and method where the exception was thrown. It also shows the line number where the exception was thrown. This is particularly useful in helping us identify the cause of the exception. We can click on the line number directly and it will take us<a id="_idIndexMarker486"/> to the line of code where the exception <span class="No-Break">was thrown.</span></p>
			<p>The stack trace is a crucial tool in <a id="_idIndexMarker487"/>helping us debug our code and quickly detect crashes and the cause of crashes. Before moving on, remember to remove the code that throws the exception so that we can continue with the rest of <span class="No-Break">the chapter.</span></p>
			<p>Android Studio allows us to copy and paste stack traces from a different source and see them in our Logcat. Copy the following <span class="No-Break">stack trace:</span></p>
			<pre class="console">
FATAL EXCEPTION: main
Process: com.packt.chapterten, PID: 7168
java.lang.RuntimeException: Unable to start activity ComponentInfo{com.packt.chapterten/com.packt.chapterten.MainActivity}: java.lang.RuntimeException: This is a crash
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3645)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)
Caused by: java.lang.RuntimeException: This is a crash
at com.packt.chapterten.MainActivity.onCreate(MainActivity.kt:48)
at android.app.Activity.performCreate(Activity.java:8305)
at android.app.Activity.performCreate(Activity.java:8284)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1417)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3626)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)</pre>			<p>Once you are done<a id="_idIndexMarker488"/> copying the stack trace, head over to the <strong class="bold">Code</strong> tab at the top of <a id="_idIndexMarker489"/>Android Studio and select <strong class="bold">Analyze Stack Trace or Thread Dump</strong>, paste the stack trace, and you will see the following dialog with the <span class="No-Break">stack trace:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B19779_10_05.jpg" alt="Figure 10.5 – Analyze stack trace" width="1402" height="1020"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Analyze stack trace</p>
			<p>This shows the preview of<a id="_idIndexMarker490"/> the stack trace we just pasted. Clicking on <strong class="bold">OK</strong> takes us <a id="_idIndexMarker491"/>to Logcat and shows us the stack trace as in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.4</em></span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor127"/>Breakpoints</h2>
			<p>We use <strong class="bold">breakpoints</strong> to debug code<a id="_idIndexMarker492"/> for our apps. A breakpoint is a point in our code where we want the debugger to pause the <a id="_idIndexMarker493"/>execution of our code. This is useful when we are trying to find bugs that only appear under certain conditions. Android Studio allows us to add breakpoints to our code. We can add breakpoints to our code by clicking on the left side of the line number as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B19779_10_06.jpg" alt="Figure 10.6 – Breakpoint" width="627" height="158"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Breakpoint</p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.6</em>, a red circle is displayed when we add a breakpoint. To be able to see how the breakpoint works, we <a id="_idIndexMarker494"/>need to run the <a id="_idIndexMarker495"/>app in <strong class="bold">debug mode</strong>. We can <a id="_idIndexMarker496"/>do this by clicking on the <span class="No-Break"><strong class="bold">Debug</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B19779_10_07.jpg" alt="Figure 10.7 – Debug app" width="514" height="30"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Debug app</p>
			<p>Since the breakpoint is on the <strong class="source-inline">onCreate()</strong> method, the debugger will pause the execution of our code at the breakpoint. Android Studio will highlight the line where the <span class="No-Break">breakpoint is:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19779_10_08.jpg" alt="Figure 10.8 – Line breakpoint" width="734" height="154"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Line breakpoint</p>
			<p>It also shows a <strong class="bold">Debug</strong> window at <span class="No-Break">the bottom:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19779_10_09.jpg" alt="Figure 10.9 – Debug window" width="1105" height="509"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Debug window</p>
			<p>The <strong class="bold">Debug</strong> window shows us the variables that are in the scope of the breakpoint. We can also see the call stack, which<a id="_idIndexMarker497"/> shows us the methods that have been <a id="_idIndexMarker498"/>called before the breakpoint. We can also see the threads that are running in our app. We can also see the breakpoints that we have added to <span class="No-Break">our code.</span></p>
			<p>The <strong class="bold">Debug</strong> window has some buttons at the top that are immensely helpful in debugging <span class="No-Break">our code:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19779_10_10.jpg" alt="Figure 10.10 – Debug window buttons" width="1105" height="509"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Debug window buttons</p>
			<p>The buttons are as highlighted in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.10</em>. Starting from the left to right, the <span class="No-Break">buttons are:</span></p>
			<ul>
				<li><strong class="bold">Show execution point</strong>: This button shows the line of code where the debugger <span class="No-Break">is paused</span></li>
				<li><strong class="bold">Step Over</strong>: This button allows us to execute the current line of code and move to the next line <span class="No-Break">of code</span></li>
				<li><strong class="bold">Step Into</strong>: This button allows us to step into a <span class="No-Break">method call</span></li>
				<li><strong class="bold">Step Out</strong>: This button allows us to step out of a <span class="No-Break">method call</span></li>
				<li><strong class="bold">Run to Cursor</strong>: This button allows us to run the code until the cursor reaches the line of code where the <span class="No-Break">cursor is</span></li>
			</ul>
			<p>On the left of the <strong class="bold">Debug</strong> window, we can also see the <strong class="bold">Play</strong> and <strong class="bold">Stop</strong> buttons. The <strong class="bold">Play</strong> button allows us to resume the <a id="_idIndexMarker499"/>execution of our code and continue the debugging session until the next breakpoint or until the program completes<a id="_idIndexMarker500"/> execution. To learn more about breakpoints, visit the official documentation <span class="No-Break">at </span><a href="https://developer.android.com/studio/debug"><span class="No-Break">https://developer.android.com/studio/debug</span></a><span class="No-Break">.</span></p>
			<p>In this section, we have learned about the different debugging options available in Android Studio. We learned about Logcat, stack traces, and breakpoints. We have also learned how to use these tools to debug our code. In the next section, we will learn about a different debugging tool, LeakCanary, and how to use it to detect memory leaks in <span class="No-Break">our apps.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor128"/>Detecting memory leaks with LeakCanary</h1>
			<p><strong class="bold">LeakCanary</strong> is an <a id="_idIndexMarker501"/>open-source library developed by Square that helps us detect memory leaks in <a id="_idIndexMarker502"/>our apps. The library has knowledge of <a id="_idIndexMarker503"/>the internals of the Android Framework that allows it to narrow down the cause of the memory leak. It helps<a id="_idIndexMarker504"/> reduce the <strong class="bold">Application Not Responding </strong>(<strong class="bold">ANR</strong>) errors and <strong class="bold">out-of-memory crashes</strong> in our apps. Here are some of the most common <a id="_idIndexMarker505"/>causes of <span class="No-Break">memory leaks:</span></p>
			<ul>
				<li>Storing instances of <strong class="source-inline">Activity</strong> as <strong class="source-inline">Context</strong> filed in an object that survives activity recreation due to <span class="No-Break">configuration changes</span></li>
				<li>Forgetting to unregister broadcast receivers, listeners, callbacks, or RxJava subscriptions when they are no <span class="No-Break">longer needed</span></li>
				<li>Storing references to <strong class="source-inline">Context</strong> in a <span class="No-Break">background thread</span></li>
			</ul>
			<p>LeakCanary is quite easy to <a id="_idIndexMarker506"/>set up and no code implementation<a id="_idIndexMarker507"/> is needed to use it. We just need to add the <strong class="source-inline">leakcanary-android</strong> dependency in our <span class="No-Break"><strong class="source-inline">libs.version.toml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<a id="_idTextAnchor129"/>leakcanary-an<a id="_idTextAnchor130"/>droid = "com.squareup.leakcanary:leakcanary-android:2.12"</pre>			<p>Tap t<a id="_idTextAnchor131"/>he <strong class="bold">Sync Now</strong> button to sync the project. Next, let us now add the dependency in our app’s <span class="No-Break"><strong class="source-inline">build.gradle.kts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
debugImplementation(libs.leakcanary.android)</pre>			<p>We have added the dependency using the <strong class="source-inline">debugImplementation</strong> configuration so that it is only added to debug builds. This is because LeakCanary is only used for debugging purposes. We can now run our app and see how LeakCanary works. A separate app will be installed on our device or emulator as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19779_10_11.jpg" alt="Figure 10.11 – Leaks app" width="110" height="116"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Leaks app</p>
			<p>Opening the app brings up the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19779_10_12.jpg" alt="Figure 10.12 – LeakCanary screen" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – LeakCanary screen</p>
			<p>The screen shows the <strong class="bold">Leaks</strong>, <strong class="bold">Heap Dumps</strong>, and <strong class="bold">About</strong> tabs. The <strong class="bold">Leaks</strong> tab shows us the memory leaks that have been detected in our app. The <strong class="bold">Heap Dumps</strong> tab shows us the heap dumps that <a id="_idIndexMarker508"/>have been taken. The <strong class="bold">About</strong> tab shows us the version of LeakCanary we are using <a id="_idIndexMarker509"/>as well as general information. For now, there is no memory leak detected. When a memory leak is detected, LeakCanary will generate a notification or log output with detailed information about the memory leak. This information helps us identify the cause of the memory leak and <span class="No-Break">fix it.</span></p>
			<p>Let us now create a memory leak in our app and see how <span class="No-Break">LeakCanary works:</span></p>
			<ol>
				<li>Create a new file inside the <strong class="source-inline">com.packt.chapterten</strong> package and call it <strong class="source-inline">LeakCanaryTest.kt</strong>. Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
class LeakCanaryTest
class LeakTestUtils {
    companion object {
        val leakCanaryTest = LeakCanaryTest()
    }
}</pre><p class="list-inset">In the preceding <a id="_idIndexMarker510"/>code, we have created a class called <strong class="source-inline">LeakCanaryTest</strong> and another class called <strong class="source-inline">LeakTestUtils</strong>, with a<a id="_idIndexMarker511"/> companion object that stores the <strong class="source-inline">LeakCanaryTest</strong> singleton in a <span class="No-Break">static field.</span></p></li>				<li>Let us now head over to the <strong class="source-inline">MainActivity.kt</strong> file and add the following code in the <span class="No-Break"><strong class="source-inline">onCreate()</strong></span><span class="No-Break"> code:</span><pre class="source-code">
AppWatcher.objectWatcher.expectWeaklyReachable(
    LeakTestUtils.leakCanaryTest,
    "Static reference to LeakCanaryTest"
)</pre><p class="list-inset">In the preceding code, we are telling LeakCanary that the singleton instance of <strong class="source-inline">LeakCanaryTest</strong> will be <span class="No-Break">garbage collected.</span></p></li>				<li>Let us run the app. We can see that LeakCanary has detected a memory leak and shows a notification as seen in the <span class="No-Break">following figure:</span></li>
			</ol>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B19779_10_13.jpg" alt="Figure 10.13 – Memory leak notification" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Memory leak notification</p>
			<ol>
				<li value="4">Click on the <a id="_idIndexMarker512"/>notification and it will take us to the <a id="_idIndexMarker513"/>LeakCanary app where we can see the details of the <span class="No-Break">memory leak:</span></li>
			</ol>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B19779_10_14.jpg" alt="Figure 10.14 – Memory leak details" width="1054" height="1121"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Memory leak details</p>
			<p class="list-inset">As shown in the preceding figure, LeakCanary shows the location of the memory leak and underlines the objects causing the leak. In this case, it is the <strong class="source-inline">leakCanaryTest</strong> object that<a id="_idIndexMarker514"/> is causing the<a id="_idIndexMarker515"/> memory leak. Every time we get a memory leak, we will receive such <span class="No-Break">detailed information.</span></p>
			<p>Remember to remove the code that causes the memory leak in the <strong class="source-inline">MainActivity</strong> <strong class="source-inline">onCreate()</strong> method so that we can continue with the rest of <span class="No-Break">the chapter.</span></p>
			<p>We have learned about LeakCanary and how to use it to detect memory leaks in our apps. You can learn more about LeakCanary <span class="No-Break">at </span><a href="https://square.github.io/leakcanary/"><span class="No-Break">https://square.github.io/leakcanary/</span></a><span class="No-Break">.</span></p>
			<p>In the next section, we will learn<a id="_idIndexMarker516"/> about Chucker, another debugging<a id="_idIndexMarker517"/> tool that helps us inspect network requests in <span class="No-Break">our apps.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor132"/>Inspecting network requests with Chucker</h1>
			<p>This is from the Chucker GitHub (<a href="https://github.com/ChuckerTeam/chucker"><span class="No-Break">https://github.com/ChuckerTeam/chucker</span></a><span class="No-Break">) page:</span></p>
			<p class="author-quote">Chucker simplifies the inspection of HTTP(S) requests/responses fired by our Android apps. Chucker works as an OkHttp Interceptor persisting all those events inside our application, and providing a UI for inspecting and sharing their content. Chucker displays a notification showing a summary of the ongoing network request.</p>
			<p>Tapping the Chucker notification<a id="_idIndexMarker518"/> mentioned previously launches the Chucker UI. Chucker UI shows a list<a id="_idIndexMarker519"/> of all the network requests that have been made by our app. We can tap on a request to see the details of <span class="No-Break">the request.</span></p>
			<p>To use Chucker, follow<a id="_idIndexMarker520"/> <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">chucker</strong> dependency in the <span class="No-Break"><strong class="source-inline">libs.versions.toml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
chucker = "com.github.chuckerteam.chucker:library:4.0.0"
chucker-no-op = "com.github.chuckerteam.chucker:library-no-op:4.0.0"</pre><p class="list-inset">In the preceding code, we have added two dependencies: the first one is the Chucker library, and the second one is a no-op library variant to isolate Chucker from release builds since we only want to see the requests on <span class="No-Break">debug builds.</span></p></li>				<li>Tap the <strong class="bold">Sync Now</strong> button at the top to sync <span class="No-Break">the project.</span></li>
				<li>Next, we need to add the dependency in our app’s <span class="No-Break"><strong class="source-inline">build.gradle.kts</strong></span><span class="No-Break"> file:</span><pre class="source-code">
debugImplementation(libs.chucker)
releaseImplementation(libs.chucker.no.op)</pre></li>				<li>Tap <strong class="bold">Sync Now</strong> at the top. This will add the Chucker dependency in debug <span class="No-Break">builds only.</span></li>
				<li>Next, we need to create a<a id="_idIndexMarker521"/> new <strong class="source-inline">OkHttp</strong> client and add the Chucker interceptor to it. Let us head<a id="_idIndexMarker522"/> over to the <strong class="source-inline">Modules.kt</strong> file and add the following module to the <strong class="source-inline">appModules</strong> <span class="No-Break">module block:</span><pre class="source-code">
single {
    val chuckerCollector = ChuckerCollector(
        context = androidContext(),
        showNotification = true,
        retentionPeriod = RetentionManager.Period.ONE_HOUR
    )
    val chuckerInterceptor = ChuckerInterceptor.Builder(androidContext())
        .collector(chuckerCollector)
        .maxContentLength(250000L)
        .redactHeaders(emptySet())
        .alwaysReadResponseBody(false)
        .build()
   OkHttpClient.Builder()
        .addInterceptor(chuckerInterceptor)
        .build()
}</pre><p class="list-inset">The following explains the <span class="No-Break">preceding code:</span></p><ul><li>We have created a <strong class="source-inline">ChuckerCollector</strong> instance and passed in the <strong class="source-inline">context</strong>, <strong class="source-inline">showNotification</strong>, and <strong class="source-inline">retentionPeriod</strong> parameters. The <strong class="source-inline">context</strong> is the Android context, <strong class="source-inline">showNotification</strong> is a boolean that determines whether to show a notification when a request is made, and <strong class="source-inline">retentionPeriod</strong> is the period for which the data is kept. In this case, we keep the data for <span class="No-Break">one hour.</span></li><li>We have created a <strong class="source-inline">ChuckerInterceptor</strong> instance and passed in the <strong class="source-inline">context</strong>, <strong class="source-inline">collector</strong>, <strong class="source-inline">maxContentLength</strong>, <strong class="source-inline">redactHeaders</strong>, and <strong class="source-inline">alwaysReadResponseBody</strong> parameters. The <strong class="source-inline">context</strong> is the Android context, <strong class="source-inline">collector</strong> is the <strong class="source-inline">ChuckerCollector</strong> instance we created previously, <strong class="source-inline">maxContentLength</strong> is the<a id="_idIndexMarker523"/> maximum length of the response body, <strong class="source-inline">redactHeaders</strong> is a set of headers<a id="_idIndexMarker524"/> to replace with <strong class="source-inline">**</strong> and <strong class="source-inline">alwaysReadResponseBody</strong> is a boolean that determines whether to always read the <span class="No-Break">response body.</span></li><li>We have created an <strong class="source-inline">OkHttpClient</strong> instance and added the <strong class="source-inline">ChuckerInterceptor</strong> <span class="No-Break">to it.</span></li></ul><p class="list-inset">We can now use the <strong class="source-inline">OkHttpClient</strong> instance to make <span class="No-Break">network requests.</span></p></li>				<li>Let us modify our <strong class="source-inline">Retrofit</strong> instance to use the <strong class="source-inline">OkHttpClient</strong> instance we just created. Still in the <strong class="source-inline">Modules.kt</strong> file, modify the Retrofit instance <span class="No-Break">as follows:</span><pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .client(get())
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre><p class="list-inset">We have added the <strong class="source-inline">client</strong> parameter <a id="_idIndexMarker525"/>and passed it in the <strong class="source-inline">OkHttpClient</strong> instance we created <a id="_idIndexMarker526"/>previously using Koin’s <span class="No-Break"><strong class="source-inline">get()</strong></span><span class="No-Break"> call.</span></p><p class="list-inset">With that, our Chucker setup is <span class="No-Break">now complete.</span></p></li>				<li>Build and run the app. We can see that Chucker has detected the network request and shows a notification, as seen in the <span class="No-Break">following figure:</span></li>
			</ol>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B19779_10_15.jpg" alt="Figure 10.15 – Chucker notification" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Chucker notification</p>
			<p class="list-inset">From the preceding figure, we <a id="_idIndexMarker527"/>can see that Chucker has detected the network request and shows the <a id="_idIndexMarker528"/>status code, the method, and the URL of <span class="No-Break">the request.</span></p>
			<ol>
				<li value="8">We can tap on the notification and it will take us to the <span class="No-Break">Chucker UI:</span></li>
			</ol>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B19779_10_16.jpg" alt="Figure 10.16 – Chucker list of requests" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Chucker list of requests</p>
			<p class="list-inset">This shows the list<a id="_idIndexMarker529"/> of the network requests that have been<a id="_idIndexMarker530"/> made by <span class="No-Break">our app.</span></p>
			<ol>
				<li value="9">Tap on a request to see the details of <span class="No-Break">the request:</span></li>
			</ol>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B19779_10_17.jpg" alt="Figure 10.17 – Chucker overview tab" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Chucker overview tab</p>
			<p class="list-inset">The details screen has <a id="_idIndexMarker531"/>three tabs as shown in the preceding <a id="_idIndexMarker532"/>figure. The first tab is the <strong class="bold">Overview</strong> tab, which is shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.17</em>. The <strong class="bold">Overview</strong> tab shows the overview of the request. It shows the request details such as URL, method, response, duration, response size, and so on. The second<a id="_idIndexMarker533"/> tab is the <strong class="bold">Request</strong> tab, which shows the request<a id="_idIndexMarker534"/> headers <span class="No-Break">and body:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B19779_10_18.jpg" alt="Figure 10.18 – Chucker request tab" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Chucker request tab</p>
			<p class="list-inset">For this request, the body is empty since it was a get request. The third tab is the <strong class="bold">Response</strong> tab, which <a id="_idIndexMarker535"/>shows the response headers<a id="_idIndexMarker536"/> <span class="No-Break">and body:</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B19779_10_19.jpg" alt="Figure 10.19 – Chucker response tab" width="1044" height="1111"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Chucker response tab</p>
			<p class="list-inset">From the preceding figure, we can see the response headers and body in <span class="No-Break">JSON format.</span></p>
			<p class="list-inset">The toolbar of the details screen has <strong class="bold">Search</strong>, <strong class="bold">Share</strong>, and <strong class="bold">Save</strong> buttons. The <strong class="bold">Search</strong> button allows us to search in either the request or the response. The <strong class="bold">Share</strong> button allows us to share the request or response details in JSON format. The <strong class="bold">Save</strong> button allows <a id="_idIndexMarker537"/>us to save the request or response details to <span class="No-Break">a file.</span></p>
			<p>Chucker is very helpful in<a id="_idIndexMarker538"/> debugging network requests in our apps. When non-technical teams test the debuggable version of our app, we can always tell them to share these requests, especially when they’re facing issues with their <span class="No-Break">network requests.</span></p>
			<p>That’s it for Chucker. Every time our app makes a network request, Chucker will show a notification and we can tap on the notification to see the details of <span class="No-Break">the request.</span></p>
			<p>We have learned about Chucker and how to use it to inspect network requests in our apps. In the next section, we will learn how to use App Inspection to inspect our app’s room database and explore the features App <span class="No-Break">Inspection offers.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor133"/>Using App Inspection</h1>
			<p><strong class="bold">App Inspection</strong> allows us to debug our <a id="_idIndexMarker539"/>database, inspect network traffic, and debug our background tasks. It is a very important tool in helping us debug our apps. To use App Inspection, let us run our app and then navigate to <strong class="bold">View</strong> | <strong class="bold">Tool Windows</strong> | <strong class="bold">App Inspection</strong> in <span class="No-Break">Android Studio:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B19779_10_20.jpg" alt="Figure 10.20 – App Inspection" width="601" height="332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – App Inspection</p>
			<p>App Inspection automatically connects to our app. The first tab is <strong class="bold">Database Inspector</strong>. On the left, we can see the different databases created by our app. We have the WorkManager, Chucker, LeakCanary, and Cat databases that we created earlier on. Let us click on the <strong class="bold">Cat</strong> database, and <a id="_idIndexMarker540"/>we can see the columns of the table that we created in <span class="No-Break">the database:</span></p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B19779_10_21.jpg" alt="Figure 10.21 – Cat database" width="787" height="228"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Cat database</p>
			<p>This shows the columns and the values that have been saved in the database. We can also run queries in the database. The query option is highlighted in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B19779_10_22.jpg" alt="Figure 10.22 – Execute query button" width="219" height="424"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Execute query button</p>
			<p>We want to run a query that shows the cats with a specific <strong class="source-inline">id</strong>. We can do this by running the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker541"/></span><span class="No-Break">query:</span></p>
			<pre class="source-code">
SELECT * FROM CAT WHERE id == "rrsvsbRgL7zaJuR3"</pre>			<p>You can use a different <strong class="source-inline">id</strong> per the data you have. The query results will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B19779_10_23.jpg" alt="Figure 10.23 – Query results" width="755" height="143"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Query results</p>
			<p>The data has all the cats that have the ID we specified. One thing to note is to ensure that you execute the queries on the correct database, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.23</em>. The database inspector helps us debug and write queries to our database and is very useful when working on apps that use <span class="No-Break">a database.</span></p>
			<p>Let us now head over to the <strong class="bold">Network Inspector</strong> tab. This tab shows us the network requests that have been <a id="_idIndexMarker542"/>made by our app. We can see the request method, the URL, the status code, and the duration of <span class="No-Break">the request:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B19779_10_24.jpg" alt="Figure 10.24 – Network Inspector" width="918" height="334"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Network Inspector</p>
			<p>From the preceding figure, we can see that the requests are for loading the cute cat images and all the details of the request. Similar to Chucker, it also has the request and response tabs that provide more information on the request. However, unlike Chucker, <strong class="bold">Network Inspector</strong> captures the network requests made by the app without any additional setup in the code. The <strong class="bold">Network Inspector</strong> tab is very useful in helping us debug network requests in our apps, especially when working on apps that make a lot of <span class="No-Break">network requests.</span></p>
			<p>Lastly, let us head over to the <strong class="bold">Background Task Inspector</strong> tab. This tab shows us the background task requests that have been made by our app. Our app should show <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B19779_10_25.jpg" alt="Figure 10.25 – Background Task Inspector" width="864" height="410"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Background Task Inspector</p>
			<p>The Background Task Inspector shows us the details of our background tasks. It has information for WorkManager <strong class="bold">Workers</strong>, <strong class="bold">Jobs</strong>, <strong class="bold">Alarms</strong>, and <strong class="bold">WakeLocks</strong>. Since our app only has the workers, we can see that the <strong class="source-inline">PetsSyncWorker</strong> worker has succeeded. On the right are<a id="_idIndexMarker543"/> more details of the worker, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.25</em>. The details show the UUID, constraints, state, and results of the worker, such as the output data, number of retries, and the time it started. This information is very helpful to check whether our background tasks are running <span class="No-Break">as expected.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor134"/>Summary</h1>
			<p>In this chapter, we learned some debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to use App Inspection to debug our database, inspect our network requests, and inspect background <span class="No-Break">tasks, too.</span></p>
			<p>In the next chapter, we will learn Kotlin style and the best practices for writing Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to format, lint, and detect the code <span class="No-Break">smells early.</span></p>
		</div>
	</div></div></body></html>