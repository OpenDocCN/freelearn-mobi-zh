<html><head></head><body><div><div><div><h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor121"/>10</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor122"/>Debugging Your App</h1>
			<p>Debugging is a very important aspect of developing apps. It helps us identify and fix bugs in our code. It is a very important skill to have as a developer. It also helps us avoid bugs in the future. Many tools can help us debug our code. In this chapter, we will be looking at some of the tools that can help us debug our code.</p>
			<p>In this chapter, we will learn debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to inspect our Room database, network requests, and background tasks using App Inspection.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>General debugging tips and tricks</li>
				<li>Detecting leaks with LeakCanary</li>
				<li>Inspecting network requests with Chucker</li>
				<li>Using App Inspection</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor123"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten</a>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor124"/>General debugging tips and tricks</h1>
			<p>Android Studio provides us with a variety of features that help us debug our code. Some of the features are listed in the following points:</p>
			<ul>
				<li><strong class="bold">Logcat</strong></li>
				<li><strong class="bold">Stack Traces</strong></li>
				<li><strong class="bold">Breakpoints</strong></li>
			</ul>
			<p>Let us look at each of these closely.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor125"/>Logcat</h2>
			<p>Logcat in Android Studio displays log <a id="_idIndexMarker476"/>messages in real-time from our apps. Each log message has a<a id="_idIndexMarker477"/> priority level attached to it. We add log messages in our app using the <code>Log</code> class. This class offers different priority levels that we can use to log messages. The different priority levels are as follows:</p>
			<ul>
				<li><strong class="bold">V</strong>: Verbose (lowest priority)</li>
				<li><strong class="bold">D</strong>: Debug</li>
				<li><strong class="bold">I</strong>: Info</li>
				<li><strong class="bold">W</strong>: Warning</li>
				<li><strong class="bold">E</strong>: Error</li>
				<li><strong class="bold">F</strong>: Fatal</li>
				<li><strong class="bold">S</strong>: Silent (highest priority)</li>
			</ul>
			<p>We use the preceding letters to specify the log level. For example, if we want to log a message with the debug level, we will use the following code:</p>
			<pre class="source-code">
Log.d("TAG", "Message")</pre>			<p>The first parameter is the tag. The tag is used to identify the source of a log message. The second parameter is the<a id="_idIndexMarker478"/> message that we want to log. Each time <a id="_idIndexMarker479"/>we run our app, Logcat shows up at the bottom of the Android Studio window, as shown in the following figure:</p>
			<div><div><img src="img/B19779_10_01.jpg" alt="Figure 10.1 – Logcat" width="1057" height="227"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Logcat</p>
			<p>From the preceding figure, we can see at the top that the Logcat window shows the device we are running our app on. In this case, we are running our app on a <strong class="bold">Pixel 6 Pro API 33</strong> emulator; yours can be different depending on the emulator you have installed. Next to the device, we can see the <strong class="bold">package</strong> of the app we are running. This has a search bar that allows us to search for specific logs with their tags. Below the search are the actual logs. We can see that each log has a tag, the priority level, the package name of the app, the time the log was created, and the message. We can also see that the logs are color-coded. To see all the color settings for our Logcat, we go to <strong class="bold">Settings</strong> | <strong class="bold">Editor </strong>| <strong class="bold">Color Scheme</strong> | <strong class="bold">Android Logcat</strong>, which shows the color settings as shown in the following figure:</p>
			<div><div><img src="img/B19779_10_02.jpg" alt="Figure 10.2 – Logcat color settings" width="926" height="700"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Logcat color settings</p>
			<p>This way, we can set a color <a id="_idIndexMarker480"/>scheme for our Logcat. In the preceding figure, the color scheme has been set to <strong class="bold">Classic Light</strong>. There is a list that shows<a id="_idIndexMarker481"/> the colors for each log level, and you can change the color for each log level. We can also change the font style and size for our Logcat.</p>
			<p>With this, let us see how to create our first Logcat message. Let us head over to the <code>MainActivity.kt</code> file and add a log message in the <code>onCreate()</code> method as follows:</p>
			<pre class="source-code">
Log.d("First Log", "This is our first log message")</pre>			<p>Run the app and add <code>First Log</code> as a search query in the search bar:</p>
			<div><div><img src="img/B19779_10_03.jpg" alt="Figure 10.3 – Logcat search" width="1058" height="123"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Logcat search</p>
			<p>This only shows the log<a id="_idIndexMarker482"/> message that has the tag <strong class="bold">First Log</strong>. This is particularly<a id="_idIndexMarker483"/> useful when we have a lot of logs, and we want to search for a specific log.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor126"/>Stack traces</h2>
			<p>A <strong class="bold">stack trace</strong> is a list of method calls from the<a id="_idIndexMarker484"/> point where the app was<a id="_idIndexMarker485"/> started to the point where the exception was thrown. It is extremely useful in helping us identify the cause of an exception. Stack traces are normally displayed in Logcat.</p>
			<p>To be able to see our first stack trace, let us head over to the <code>MainActivity.kt</code> file and add the following code in the <code>onCreate()</code> method:</p>
			<pre class="source-code">
throw RuntimeException("This is a crash")</pre>			<p>The preceding code will cause the app to crash when you run it. The app crashes immediately after executing the preceding code, and by checking our Logcat, we should be able to see the stack trace:</p>
			<div><div><img src="img/B19779_10_04.jpg" alt="Figure 10.4 – Crash stack trace" width="1381" height="462"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Crash stack trace</p>
			<p>As shown in the preceding figure, the stack trace shows the exception or reason for the crash. Additionally, it shows the class and method where the exception was thrown. It also shows the line number where the exception was thrown. This is particularly useful in helping us identify the cause of the exception. We can click on the line number directly and it will take us<a id="_idIndexMarker486"/> to the line of code where the exception was thrown.</p>
			<p>The stack trace is a crucial tool in <a id="_idIndexMarker487"/>helping us debug our code and quickly detect crashes and the cause of crashes. Before moving on, remember to remove the code that throws the exception so that we can continue with the rest of the chapter.</p>
			<p>Android Studio allows us to copy and paste stack traces from a different source and see them in our Logcat. Copy the following stack trace:</p>
			<pre class="console">
FATAL EXCEPTION: main
Process: com.packt.chapterten, PID: 7168
java.lang.RuntimeException: Unable to start activity ComponentInfo{com.packt.chapterten/com.packt.chapterten.MainActivity}: java.lang.RuntimeException: This is a crash
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3645)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)
Caused by: java.lang.RuntimeException: This is a crash
at com.packt.chapterten.MainActivity.onCreate(MainActivity.kt:48)
at android.app.Activity.performCreate(Activity.java:8305)
at android.app.Activity.performCreate(Activity.java:8284)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1417)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3626)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3782)
at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:101)
at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2307)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:201)
at android.os.Looper.loop(Looper.java:288)
at android.app.ActivityThread.main(ActivityThread.java:7872)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:936)</pre>			<p>Once you are done<a id="_idIndexMarker488"/> copying the stack trace, head over to the <strong class="bold">Code</strong> tab at the top of <a id="_idIndexMarker489"/>Android Studio and select <strong class="bold">Analyze Stack Trace or Thread Dump</strong>, paste the stack trace, and you will see the following dialog with the stack trace:</p>
			<div><div><img src="img/B19779_10_05.jpg" alt="Figure 10.5 – Analyze stack trace" width="1402" height="1020"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Analyze stack trace</p>
			<p>This shows the preview of<a id="_idIndexMarker490"/> the stack trace we just pasted. Clicking on <strong class="bold">OK</strong> takes us <a id="_idIndexMarker491"/>to Logcat and shows us the stack trace as in <em class="italic">Figure 10</em><em class="italic">.4</em></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor127"/>Breakpoints</h2>
			<p>We use <strong class="bold">breakpoints</strong> to debug code<a id="_idIndexMarker492"/> for our apps. A breakpoint is a point in our code where we want the debugger to pause the <a id="_idIndexMarker493"/>execution of our code. This is useful when we are trying to find bugs that only appear under certain conditions. Android Studio allows us to add breakpoints to our code. We can add breakpoints to our code by clicking on the left side of the line number as shown in the following figure:</p>
			<div><div><img src="img/B19779_10_06.jpg" alt="Figure 10.6 – Breakpoint" width="627" height="158"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Breakpoint</p>
			<p>As shown in <em class="italic">Figure 10</em><em class="italic">.6</em>, a red circle is displayed when we add a breakpoint. To be able to see how the breakpoint works, we <a id="_idIndexMarker494"/>need to run the <a id="_idIndexMarker495"/>app in <strong class="bold">debug mode</strong>. We can <a id="_idIndexMarker496"/>do this by clicking on the <strong class="bold">Debug</strong> button:</p>
			<div><div><img src="img/B19779_10_07.jpg" alt="Figure 10.7 – Debug app" width="514" height="30"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Debug app</p>
			<p>Since the breakpoint is on the <code>onCreate()</code> method, the debugger will pause the execution of our code at the breakpoint. Android Studio will highlight the line where the breakpoint is:</p>
			<div><div><img src="img/B19779_10_08.jpg" alt="Figure 10.8 – Line breakpoint" width="734" height="154"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Line breakpoint</p>
			<p>It also shows a <strong class="bold">Debug</strong> window at the bottom:</p>
			<div><div><img src="img/B19779_10_09.jpg" alt="Figure 10.9 – Debug window" width="1105" height="509"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Debug window</p>
			<p>The <strong class="bold">Debug</strong> window shows us the variables that are in the scope of the breakpoint. We can also see the call stack, which<a id="_idIndexMarker497"/> shows us the methods that have been <a id="_idIndexMarker498"/>called before the breakpoint. We can also see the threads that are running in our app. We can also see the breakpoints that we have added to our code.</p>
			<p>The <strong class="bold">Debug</strong> window has some buttons at the top that are immensely helpful in debugging our code:</p>
			<div><div><img src="img/B19779_10_10.jpg" alt="Figure 10.10 – Debug window buttons" width="1105" height="509"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Debug window buttons</p>
			<p>The buttons are as highlighted in <em class="italic">Figure 10</em><em class="italic">.10</em>. Starting from the left to right, the buttons are:</p>
			<ul>
				<li><strong class="bold">Show execution point</strong>: This button shows the line of code where the debugger is paused</li>
				<li><strong class="bold">Step Over</strong>: This button allows us to execute the current line of code and move to the next line of code</li>
				<li><strong class="bold">Step Into</strong>: This button allows us to step into a method call</li>
				<li><strong class="bold">Step Out</strong>: This button allows us to step out of a method call</li>
				<li><strong class="bold">Run to Cursor</strong>: This button allows us to run the code until the cursor reaches the line of code where the cursor is</li>
			</ul>
			<p>On the left of the <strong class="bold">Debug</strong> window, we can also see the <strong class="bold">Play</strong> and <strong class="bold">Stop</strong> buttons. The <strong class="bold">Play</strong> button allows us to resume the <a id="_idIndexMarker499"/>execution of our code and continue the debugging session until the next breakpoint or until the program completes<a id="_idIndexMarker500"/> execution. To learn more about breakpoints, visit the official documentation at <a href="https://developer.android.com/studio/debug">https://developer.android.com/studio/debug</a>.</p>
			<p>In this section, we have learned about the different debugging options available in Android Studio. We learned about Logcat, stack traces, and breakpoints. We have also learned how to use these tools to debug our code. In the next section, we will learn about a different debugging tool, LeakCanary, and how to use it to detect memory leaks in our apps.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor128"/>Detecting memory leaks with LeakCanary</h1>
			<p><strong class="bold">LeakCanary</strong> is an <a id="_idIndexMarker501"/>open-source library developed by Square that helps us detect memory leaks in <a id="_idIndexMarker502"/>our apps. The library has knowledge of <a id="_idIndexMarker503"/>the internals of the Android Framework that allows it to narrow down the cause of the memory leak. It helps<a id="_idIndexMarker504"/> reduce the <strong class="bold">Application Not Responding </strong>(<strong class="bold">ANR</strong>) errors and <strong class="bold">out-of-memory crashes</strong> in our apps. Here are some of the most common <a id="_idIndexMarker505"/>causes of memory leaks:</p>
			<ul>
				<li>Storing instances of <code>Activity</code> as <code>Context</code> filed in an object that survives activity recreation due to configuration changes</li>
				<li>Forgetting to unregister broadcast receivers, listeners, callbacks, or RxJava subscriptions when they are no longer needed</li>
				<li>Storing references to <code>Context</code> in a background thread</li>
			</ul>
			<p>LeakCanary is quite easy to <a id="_idIndexMarker506"/>set up and no code implementation<a id="_idIndexMarker507"/> is needed to use it. We just need to add the <code>leakcanary-android</code> dependency in our <code>libs.version.toml</code> file:</p>
			<pre class="source-code">
<a id="_idTextAnchor129"/>leakcanary-an<a id="_idTextAnchor130"/>droid = "com.squareup.leakcanary:leakcanary-android:2.12"</pre>			<p>Tap t<a id="_idTextAnchor131"/>he <code>build.gradle.kts</code> file:</p>
			<pre class="source-code">
debugImplementation(libs.leakcanary.android)</pre>			<p>We have added the dependency using the <code>debugImplementation</code> configuration so that it is only added to debug builds. This is because LeakCanary is only used for debugging purposes. We can now run our app and see how LeakCanary works. A separate app will be installed on our device or emulator as shown in the following figure:</p>
			<div><div><img src="img/B19779_10_11.jpg" alt="Figure 10.11 – Leaks app" width="110" height="116"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Leaks app</p>
			<p>Opening the app brings up the following screen:</p>
			<div><div><img src="img/B19779_10_12.jpg" alt="Figure 10.12 – LeakCanary screen" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – LeakCanary screen</p>
			<p>The screen shows the <strong class="bold">Leaks</strong>, <strong class="bold">Heap Dumps</strong>, and <strong class="bold">About</strong> tabs. The <strong class="bold">Leaks</strong> tab shows us the memory leaks that have been detected in our app. The <strong class="bold">Heap Dumps</strong> tab shows us the heap dumps that <a id="_idIndexMarker508"/>have been taken. The <strong class="bold">About</strong> tab shows us the version of LeakCanary we are using <a id="_idIndexMarker509"/>as well as general information. For now, there is no memory leak detected. When a memory leak is detected, LeakCanary will generate a notification or log output with detailed information about the memory leak. This information helps us identify the cause of the memory leak and fix it.</p>
			<p>Let us now create a memory leak in our app and see how LeakCanary works:</p>
			<ol>
				<li>Create a new file inside the <code>com.packt.chapterten</code> package and call it <code>LeakCanaryTest.kt</code>. Add the following code to the file:<pre class="source-code">
class LeakCanaryTest
class LeakTestUtils {
    companion object {
        val leakCanaryTest = LeakCanaryTest()
    }
}</pre><p class="list-inset">In the preceding <a id="_idIndexMarker510"/>code, we have created a class called <code>LeakCanaryTest</code> and another class called <code>LeakTestUtils</code>, with a<a id="_idIndexMarker511"/> companion object that stores the <code>LeakCanaryTest</code> singleton in a static field.</p></li>				<li>Let us now head over to the <code>MainActivity.kt</code> file and add the following code in the <code>onCreate()</code> code:<pre class="source-code">
AppWatcher.objectWatcher.expectWeaklyReachable(
    LeakTestUtils.leakCanaryTest,
    "Static reference to LeakCanaryTest"
)</pre><p class="list-inset">In the preceding code, we are telling LeakCanary that the singleton instance of <code>LeakCanaryTest</code> will be garbage collected.</p></li>				<li>Let us run the app. We can see that LeakCanary has detected a memory leak and shows a notification as seen in the following figure:</li>
			</ol>
			<div><div><img src="img/B19779_10_13.jpg" alt="Figure 10.13 – Memory leak notification" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Memory leak notification</p>
			<ol>
				<li value="4">Click on the <a id="_idIndexMarker512"/>notification and it will take us to the <a id="_idIndexMarker513"/>LeakCanary app where we can see the details of the memory leak:</li>
			</ol>
			<div><div><img src="img/B19779_10_14.jpg" alt="Figure 10.14 – Memory leak details" width="1054" height="1121"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Memory leak details</p>
			<p class="list-inset">As shown in the preceding figure, LeakCanary shows the location of the memory leak and underlines the objects causing the leak. In this case, it is the <code>leakCanaryTest</code> object that<a id="_idIndexMarker514"/> is causing the<a id="_idIndexMarker515"/> memory leak. Every time we get a memory leak, we will receive such detailed information.</p>
			<p>Remember to remove the code that causes the memory leak in the <code>MainActivity</code> <code>onCreate()</code> method so that we can continue with the rest of the chapter.</p>
			<p>We have learned about LeakCanary and how to use it to detect memory leaks in our apps. You can learn more about LeakCanary at <a href="https://square.github.io/leakcanary/">https://square.github.io/leakcanary/</a>.</p>
			<p>In the next section, we will learn<a id="_idIndexMarker516"/> about Chucker, another debugging<a id="_idIndexMarker517"/> tool that helps us inspect network requests in our apps.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor132"/>Inspecting network requests with Chucker</h1>
			<p>This is from the Chucker GitHub (<a href="https://github.com/ChuckerTeam/chucker">https://github.com/ChuckerTeam/chucker</a>) page:</p>
			<p class="author-quote">Chucker simplifies the inspection of HTTP(S) requests/responses fired by our Android apps. Chucker works as an OkHttp Interceptor persisting all those events inside our application, and providing a UI for inspecting and sharing their content. Chucker displays a notification showing a summary of the ongoing network request.</p>
			<p>Tapping the Chucker notification<a id="_idIndexMarker518"/> mentioned previously launches the Chucker UI. Chucker UI shows a list<a id="_idIndexMarker519"/> of all the network requests that have been made by our app. We can tap on a request to see the details of the request.</p>
			<p>To use Chucker, follow<a id="_idIndexMarker520"/> these steps:</p>
			<ol>
				<li>Add the <code>chucker</code> dependency in the <code>libs.versions.toml</code> file:<pre class="source-code">
chucker = "com.github.chuckerteam.chucker:library:4.0.0"
chucker-no-op = "com.github.chuckerteam.chucker:library-no-op:4.0.0"</pre><p class="list-inset">In the preceding code, we have added two dependencies: the first one is the Chucker library, and the second one is a no-op library variant to isolate Chucker from release builds since we only want to see the requests on debug builds.</p></li>				<li>Tap the <strong class="bold">Sync Now</strong> button at the top to sync the project.</li>
				<li>Next, we need to add the dependency in our app’s <code>build.gradle.kts</code> file:<pre class="source-code">
debugImplementation(libs.chucker)
releaseImplementation(libs.chucker.no.op)</pre></li>				<li>Tap <strong class="bold">Sync Now</strong> at the top. This will add the Chucker dependency in debug builds only.</li>
				<li>Next, we need to create a<a id="_idIndexMarker521"/> new <code>OkHttp</code> client and add the Chucker interceptor to it. Let us head<a id="_idIndexMarker522"/> over to the <code>Modules.kt</code> file and add the following module to the <code>appModules</code> module block:<pre class="source-code">
single {
    val chuckerCollector = ChuckerCollector(
        context = androidContext(),
        showNotification = true,
        retentionPeriod = RetentionManager.Period.ONE_HOUR
    )
    val chuckerInterceptor = ChuckerInterceptor.Builder(androidContext())
        .collector(chuckerCollector)
        .maxContentLength(250000L)
        .redactHeaders(emptySet())
        .alwaysReadResponseBody(false)
        .build()
   OkHttpClient.Builder()
        .addInterceptor(chuckerInterceptor)
        .build()
}</pre><p class="list-inset">The following explains the preceding code:</p><ul><li>We have created a <code>ChuckerCollector</code> instance and passed in the <code>context</code>, <code>showNotification</code>, and <code>retentionPeriod</code> parameters. The <code>context</code> is the Android context, <code>showNotification</code> is a boolean that determines whether to show a notification when a request is made, and <code>retentionPeriod</code> is the period for which the data is kept. In this case, we keep the data for one hour.</li><li>We have created a <code>ChuckerInterceptor</code> instance and passed in the <code>context</code>, <code>collector</code>, <code>maxContentLength</code>, <code>redactHeaders</code>, and <code>alwaysReadResponseBody</code> parameters. The <code>context</code> is the Android context, <code>collector</code> is the <code>ChuckerCollector</code> instance we created previously, <code>maxContentLength</code> is the<a id="_idIndexMarker523"/> maximum length of the response body, <code>redactHeaders</code> is a set of headers<a id="_idIndexMarker524"/> to replace with <code>**</code> and <code>alwaysReadResponseBody</code> is a boolean that determines whether to always read the response body.</li><li>We have created an <code>OkHttpClient</code> instance and added the <code>ChuckerInterceptor</code> to it.</li></ul><p class="list-inset">We can now use the <code>OkHttpClient</code> instance to make network requests.</p></li>				<li>Let us modify our <code>Retrofit</code> instance to use the <code>OkHttpClient</code> instance we just created. Still in the <code>Modules.kt</code> file, modify the Retrofit instance as follows:<pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .client(get())
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre><p class="list-inset">We have added the <code>client</code> parameter <a id="_idIndexMarker525"/>and passed it in the <code>OkHttpClient</code> instance we created <a id="_idIndexMarker526"/>previously using Koin’s <code>get()</code> call.</p><p class="list-inset">With that, our Chucker setup is now complete.</p></li>				<li>Build and run the app. We can see that Chucker has detected the network request and shows a notification, as seen in the following figure:</li>
			</ol>
			<div><div><img src="img/B19779_10_15.jpg" alt="Figure 10.15 – Chucker notification" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Chucker notification</p>
			<p class="list-inset">From the preceding figure, we <a id="_idIndexMarker527"/>can see that Chucker has detected the network request and shows the <a id="_idIndexMarker528"/>status code, the method, and the URL of the request.</p>
			<ol>
				<li value="8">We can tap on the notification and it will take us to the Chucker UI:</li>
			</ol>
			<div><div><img src="img/B19779_10_16.jpg" alt="Figure 10.16 – Chucker list of requests" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Chucker list of requests</p>
			<p class="list-inset">This shows the list<a id="_idIndexMarker529"/> of the network requests that have been<a id="_idIndexMarker530"/> made by our app.</p>
			<ol>
				<li value="9">Tap on a request to see the details of the request:</li>
			</ol>
			<div><div><img src="img/B19779_10_17.jpg" alt="Figure 10.17 – Chucker overview tab" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Chucker overview tab</p>
			<p class="list-inset">The details screen has <a id="_idIndexMarker531"/>three tabs as shown in the preceding <a id="_idIndexMarker532"/>figure. The first tab is the <strong class="bold">Overview</strong> tab, which is shown in <em class="italic">Figure 10</em><em class="italic">.17</em>. The <strong class="bold">Overview</strong> tab shows the overview of the request. It shows the request details such as URL, method, response, duration, response size, and so on. The second<a id="_idIndexMarker533"/> tab is the <strong class="bold">Request</strong> tab, which shows the request<a id="_idIndexMarker534"/> headers and body:</p>
			<div><div><img src="img/B19779_10_18.jpg" alt="Figure 10.18 – Chucker request tab" width="509" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Chucker request tab</p>
			<p class="list-inset">For this request, the body is empty since it was a get request. The third tab is the <strong class="bold">Response</strong> tab, which <a id="_idIndexMarker535"/>shows the response headers<a id="_idIndexMarker536"/> and body:</p>
			<div><div><img src="img/B19779_10_19.jpg" alt="Figure 10.19 – Chucker response tab" width="1044" height="1111"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Chucker response tab</p>
			<p class="list-inset">From the preceding figure, we can see the response headers and body in JSON format.</p>
			<p class="list-inset">The toolbar of the details screen has <strong class="bold">Search</strong>, <strong class="bold">Share</strong>, and <strong class="bold">Save</strong> buttons. The <strong class="bold">Search</strong> button allows us to search in either the request or the response. The <strong class="bold">Share</strong> button allows us to share the request or response details in JSON format. The <strong class="bold">Save</strong> button allows <a id="_idIndexMarker537"/>us to save the request or response details to a file.</p>
			<p>Chucker is very helpful in<a id="_idIndexMarker538"/> debugging network requests in our apps. When non-technical teams test the debuggable version of our app, we can always tell them to share these requests, especially when they’re facing issues with their network requests.</p>
			<p>That’s it for Chucker. Every time our app makes a network request, Chucker will show a notification and we can tap on the notification to see the details of the request.</p>
			<p>We have learned about Chucker and how to use it to inspect network requests in our apps. In the next section, we will learn how to use App Inspection to inspect our app’s room database and explore the features App Inspection offers.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor133"/>Using App Inspection</h1>
			<p><strong class="bold">App Inspection</strong> allows us to debug our <a id="_idIndexMarker539"/>database, inspect network traffic, and debug our background tasks. It is a very important tool in helping us debug our apps. To use App Inspection, let us run our app and then navigate to <strong class="bold">View</strong> | <strong class="bold">Tool Windows</strong> | <strong class="bold">App Inspection</strong> in Android Studio:</p>
			<div><div><img src="img/B19779_10_20.jpg" alt="Figure 10.20 – App Inspection" width="601" height="332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – App Inspection</p>
			<p>App Inspection automatically connects to our app. The first tab is <strong class="bold">Database Inspector</strong>. On the left, we can see the different databases created by our app. We have the WorkManager, Chucker, LeakCanary, and Cat databases that we created earlier on. Let us click on the <strong class="bold">Cat</strong> database, and <a id="_idIndexMarker540"/>we can see the columns of the table that we created in the database:</p>
			<div><div><img src="img/B19779_10_21.jpg" alt="Figure 10.21 – Cat database" width="787" height="228"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Cat database</p>
			<p>This shows the columns and the values that have been saved in the database. We can also run queries in the database. The query option is highlighted in the following figure:</p>
			<div><div><img src="img/B19779_10_22.jpg" alt="Figure 10.22 – Execute query button" width="219" height="424"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Execute query button</p>
			<p>We want to run a query that shows the cats with a specific <code>id</code>. We can do this by running the following <a id="_idIndexMarker541"/>query:</p>
			<pre class="source-code">
SELECT * FROM CAT WHERE id == "rrsvsbRgL7zaJuR3"</pre>			<p>You can use a different <code>id</code> per the data you have. The query results will be as follows:</p>
			<div><div><img src="img/B19779_10_23.jpg" alt="Figure 10.23 – Query results" width="755" height="143"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Query results</p>
			<p>The data has all the cats that have the ID we specified. One thing to note is to ensure that you execute the queries on the correct database, as shown in <em class="italic">Figure 10</em><em class="italic">.23</em>. The database inspector helps us debug and write queries to our database and is very useful when working on apps that use a database.</p>
			<p>Let us now head over to the <strong class="bold">Network Inspector</strong> tab. This tab shows us the network requests that have been <a id="_idIndexMarker542"/>made by our app. We can see the request method, the URL, the status code, and the duration of the request:</p>
			<div><div><img src="img/B19779_10_24.jpg" alt="Figure 10.24 – Network Inspector" width="918" height="334"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Network Inspector</p>
			<p>From the preceding figure, we can see that the requests are for loading the cute cat images and all the details of the request. Similar to Chucker, it also has the request and response tabs that provide more information on the request. However, unlike Chucker, <strong class="bold">Network Inspector</strong> captures the network requests made by the app without any additional setup in the code. The <strong class="bold">Network Inspector</strong> tab is very useful in helping us debug network requests in our apps, especially when working on apps that make a lot of network requests.</p>
			<p>Lastly, let us head over to the <strong class="bold">Background Task Inspector</strong> tab. This tab shows us the background task requests that have been made by our app. Our app should show the following:</p>
			<div><div><img src="img/B19779_10_25.jpg" alt="Figure 10.25 – Background Task Inspector" width="864" height="410"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Background Task Inspector</p>
			<p>The Background Task Inspector shows us the details of our background tasks. It has information for WorkManager <code>PetsSyncWorker</code> worker has succeeded. On the right are<a id="_idIndexMarker543"/> more details of the worker, as shown in <em class="italic">Figure 10</em><em class="italic">.25</em>. The details show the UUID, constraints, state, and results of the worker, such as the output data, number of retries, and the time it started. This information is very helpful to check whether our background tasks are running as expected.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor134"/>Summary</h1>
			<p>In this chapter, we learned some debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect network requests/responses fired by our app using Chucker, and how to use App Inspection to debug our database, inspect our network requests, and inspect background tasks, too.</p>
			<p>In the next chapter, we will learn Kotlin style and the best practices for writing Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to format, lint, and detect the code smells early.</p>
		</div>
	</div></div></body></html>