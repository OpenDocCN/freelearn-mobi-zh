- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced and Custom Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I started learning how to program computers, one of the first things I
    learned was how to use operators. These include basic operators like assignment
    and arithmetic operators, which were covered in *Chapter 3*, *Learning about Variables,
    Constants, Strings, and Operators*. It wasn't until much later, when I learned
    how to program in the C language, that I learned about advanced operators such
    as bitwise operators. While the advanced operators are not as popular as the basic
    operators, they can be very powerful when used correctly. Advanced operators are
    especially useful if you are planning on writing applications that use low-level
    C-based libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How to use bitwise operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What overflow operators are for
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write operator methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create your own custom operator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Learning about Variables, Constants, Strings, and Operators*,
    we looked at the most common operators, like assignment, comparison, and arithmetic
    operators. While these operators are used in virtually every useful application,
    there are some additional operators that aren't used as often but can be very
    powerful when you know how to use them. We will look at some of these more advanced
    operators in this chapter, starting with bitwise operators, but first, we need
    to understand what bits and bytes are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Bits and bytes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A computer thinks in terms of binary digits. These digits are called **bits**
    and can have only two values: *0* or *1*, which represent *on* or *off* in electrical
    terms. Bits are very small and have limited usefulness on their own outside of
    using them for true/false flags. They are grouped together into groups of 4, 8,
    16, 32, or 64 to form data that a computer can use.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'A **byte** in computer terms is a group of 8 bits. If we think in terms of
    a byte, the number 42 is represented like this, where the least significant bit
    is to the right and the most significant bit is to the left:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![A screen shot of a clock  Description automatically generated](img/B16683_15_01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: The number 42 represented in bits'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The top row in *Figure 15.1* shows the value, on or off, of each bit for an
    8-bit byte that equals the number **42**. The second row shows you the value represented
    by each bit in the byte. We can see that for the number **42**, the bits for the
    values of **32**, **8**, and **2** are set. We can then add up those values and
    see that they equal 42: 32+8+2 = 42\. This means that the value of the 8-bit byte
    is 42.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: By default, Swift uses 64-bit numbers; as an example, the standard `Int` type
    is 64 bits. In this chapter we will mostly use the `UInt8` type, which is an unsigned
    integer that has only 8 bits or 1 byte. Keep in mind that the 64-bit types store
    bits in the same way as a byte; they just contain more bits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the least significant bit is to the right while the
    most significant is to the left. This is the way that bits are usually represented
    when shown in diagrams. However, in real-world computer architectures, the bits
    may be stored in memory, where either the most significant bit or the least significant
    bit is stored in the lowest memory address. Let's take a look at what this means.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Endianness
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer terms, the **endianness** of an architecture is the order in which
    bits are stored in the memory. Endianness is expressed as big-endian or little-endian.
    In an architecture that is considered little-endian, the least significant bit
    is stored in the lowest memory address, while in architectures that are considered
    big-endian, the most significant bit is stored in the lowest memory address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When working with the Swift standard library, and for the most part when working
    solely within the Swift language itself, you do not need to worry about how the
    bits are stored. If you need to work with low-level C libraries, across multiple
    architectures, then you may need to understand how information is stored within
    the system because you may be dealing with pointers to memory locations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'For the times when you need to worry about the endianness of the architecture,
    like when we need to interact with low-level C libraries, Swift does have built-in
    instance properties for integers named `littleEndian` and `bigEndian`. The following
    example shows how to use these properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `en.littleEndian` line would return the little-endian representation of
    the number 42, while the `en.bigEndian` line would return the big-endian representation
    of the number 42.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The endianness of both Intel processors and Apple's own A processors is little-endian;
    therefore, in this chapter, we will assume that everything is little-endian.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what bitwise operators are and how we can use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bitwise operators** enable us to manipulate the individual bits of a value.
    One of the advantages of bitwise operators is that they are directly supported
    by the processor and so can be significantly faster than basic arithmetic operations
    like multiplication and division. We will see how to do basic multiplication and
    division using bitwise shift operators later in this chapter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at what we can do with bitwise operators, we will need to have
    the ability to show the binary representation of our variables in order to see
    what the operators are doing. Let's take a look at a couple of ways that we can
    do this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Printing binary numbers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apple provides us with a generic initializer for the `String` type that will
    provide us with the string representation of a given value. This initializer is
    `init(_:radix:uppercase:)`. By default `uppercase` is set to `false` and `radix`
    is set to `10`. The `radix` defines the number base that will be displayed, where
    the `10` stands for base 10\. In order to see the binary representation, we will
    need to set that to `2`. We can use this initializer to show the binary representation
    of a value like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous code would display the following results:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `101010` is the binary representation of the number `42` and `110101`
    is the binary representation of the number `53`. This works really well; however,
    it does not show leading zeros. For example, if we are comparing the binary representation
    of `53` and `123456`, like the following code shows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We end up with results that look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be a lot harder to compare. When I need to easily see the binary representation
    of a number, I usually drop the following extension into my code base:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is OK if you do not understand how this code works at this time since bitwise
    shift operators have not been explained yet. Once they have been explained later
    in this chapter, you will be able to understand how it works.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'This extension will take an integer and return the binary representation of
    the number, with the appropriate number of nibbles. Earlier in the chapter we
    mentioned that a byte has 8 bits; a nibble is half a byte or 4 bits. Within the
    string that is returned, this code will put a space between each nibble to make
    it easier to read. We can use this extension as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this code we are displaying the binary representation of the numbers `53`
    and `230` in two nibbles. The following results show what would be printed to
    the console:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a very basic idea of what bits, bytes, nibbles, and endianness
    are, and we are able to display numbers in binary format, let's look at bitwise
    operators, starting with the bitwise AND operator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise AND operator
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bitwise AND operator (`&`) takes two values and returns a new value where
    the bits in the new value are set to 1 only if the corresponding bits of both
    input values are set to 1\. The AND operator can be read as: if the bit from the
    first value AND the bit of the second value are both 1, then set the corresponding
    bit of the resultant value to 1\. Let''s see how this works by seeing how we would
    do a bitwise AND operation on the numbers 42 and 11:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a keyboard  Description automatically generated](img/B16683_15_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: The AND operator'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'As this diagram shows, the second and fourth bit from the right are both set
    to **1**, therefore the results of the AND operation has those bits set, resulting
    in an output value of **10**. Now let''s see how this works in code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers, in two nibbles, using the `binaryFormat` extension
    to the console. It then performs a bitwise AND operation on the integers and prints
    the binary representation of the results to the console. The following results
    will be printed to the console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the result from the code is the same as shown in the diagram,
    which has a result of `10`. Now let's look at the bitwise OR operator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise OR operator
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bitwise OR operator (`|`) takes two values and returns a new value where
    the bits of the results are set to 1 only if the corresponding bits of either
    or both values are set to 1\. The OR operation reads as: if the bit from the first
    value OR the bit of the second value is 1, then set the bit in the results to
    1\. Let''s see how this works by seeing how we would do a bitwise OR operation
    on the numbers 42 and 11:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a keyboard  Description automatically generated](img/B16683_15_03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The OR operator'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'As this diagram shows, the first, second, fourth, and sixth bits from the right
    are set in one or both of the values, therefore the results of the OR operation
    have all of those bits set. Now let''s see how this works in code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers, in two nibbles, using the `binaryFormat` extension
    to the console. It then performs a bitwise OR operation on the integers and prints
    the binary representation of the results. The following results will be printed
    to the console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, the result from the code is the same as shown in *Figure 15.3*,
    which has a result of `43`. Now let's look at the bitwise XOR operator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise XOR operator
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bitwise XOR operator (`^`) takes two values and returns a new value where
    the bits of the new value are set to 1 only if the corresponding bits of either
    but not both input values are set to 1\. The XOR operator reads: if the bit from
    the first value OR the bit of the second value is 1, but not both, then set the
    bit of the results to 1\. Let''s see how this works by seeing how we would do
    a bitwise OR operation on the numbers 42 and 11:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, box and whisker chart  Description automatically generated](img/B16683_15_04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The XOR operator'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'As this diagram shows, the second and fourth bits from the right are set to
    **1** for both numbers, therefore in the results those bits are not set. However,
    the sixth bit in the number **42** is set to **1** and the first bit in the number
    **11** is set to **1**, therefore in the results those bits are set. Now let''s
    see how this works in code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers to two nibbles using the `binaryFormat` extension.
    It then performs a bitwise XOR operation on the integers and prints the binary
    representation of the results. The following results will be printed to the console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the result from the code is the same as shown in the diagram,
    which has a result of `33`. Now let's look at the bitwise NOT operator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise NOT operator
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bitwise NOT operator (`~`) is different from the other logical operators
    because it only takes one value. The bitwise NOT operator will return a value
    where all of the bits are reversed. What this means is that any bit on the input
    value that is set to 1 will be set to 0 on the resulting value, and any bit that
    is set to 0 on the input value will be set to 1 on the resulting value. Let''s
    see how this would work given a value of 42:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The NOT operator'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram illustrates that when we perform the bitwise NOT operation, all
    of the bits in the result''s value will be the opposite of what they were in the
    original value. Let''s see what this looks like in code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous code performs the NOT operation on the value of the `numberOne`
    variable. The following results will be printed to the console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the results are a negative number. The reason for this is an integer
    is a signed number. With signed numbers, the most significant bit designates whether
    the number is a positive number or a negative number. With all bits being reversed,
    with the NOT operation, a negative number will always turn into a positive number
    and a positive number will always turn into a negative number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the logical bitwise operators, let's look at the
    bitwise shifting operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise shift operators
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift provides two bitwise shift operators, the bitwise left shift operator
    (`<<`) and the bitwise right shift operator (`>>`). These operators shift all
    bits to the left or right by the number of places specified. The shift operators
    have the effect of multiplying (left shift operator) or dividing (right shift
    operator) by factors of two. By shifting the bits to the left by one, you are
    doubling the value, and shifting them to the right by one will halve the value.
    Let''s see how these operators work, starting with the left shift operator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_06.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: The left shift operator'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'With the left shift operator, all bits in the original value are shifted to
    the left by one, with the most significant bit falling off and not factoring into
    the final result. The least significant bit in the result will always be set to
    zero. Now let''s look at the right shift operation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_07.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: The right shift operator'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: With the right shift operator, all bits in the original value are shifted to
    the right one spot, with the least significant digit falling off. The most significant
    digit in the result will always be set to zero.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what this looks like in code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code, we start off by setting a variable to the number `24`. We then
    use the left shift operator to shift the bits one spot to the left. The number
    after the shift operator defines how many spots to shift the numbers. The next
    line shifts the bits one spot to the right, then the next line shifts the bits
    three spots to the left, and the next line shifts the bits four spots to the right.
    The final five lines print out the results to the console. If you run this code,
    you should see the following results:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Looking at the results, we can see that the bits are shifted to the left or
    right depending on the shifting operator used. In the last line, we can see that
    when we shifted to the right four spaces, only one bit was set to `1` rather than
    two. This is because the bit in the fourth spot from the right in the original
    number actually fell off. If we would have shifted to the right five spots, both
    bits that were set to one in the original number would have fallen off and we
    would have been left with all zeros.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at overflow operators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Overflow operators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift, at its core, is designed for safety. One of these safety mechanisms
    is the inability to insert a number into a variable when the variable type is
    too small to hold it. As an example, the following code will throw the following
    error: `arithmetic operation ''255 + 1'' (on type ''UInt8'') results in an overflow`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The reason an error is thrown is we are trying to add one to the maximum number
    that a `UInt8` can hold. This error checking can help prevent unexpected and hard-to-trace
    issues in our applications. Let''s take a second and look at what would happen
    if Swift did not throw an error when an overflow occurs. In a `UInt8` variable,
    which is an 8-bit unsigned integer, the number 255 is stored like this, where
    all of the bits are set to 1:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing clock  Description automatically generated](img/B16683_15_08.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: The binary representation of 255'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we add 1 to this number, the new number will be stored like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_09.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Overflow when trying to represent 256'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the 8 bits that represent the `UInt8` number are all zeros, while
    the leading one falls off or overflows because we can only store 8 bits. In this
    case, when we add one to the number 255, the number stored in the results would
    be 0 if we did not have overflow error checking. This could lead to very unexpected
    behavior in our code that would be hard to track down.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the behavior that we want, Swift does offer three overflow operators
    that will allow us to opt into this behavior. These are the overflow addition
    operator (`&+`), the overflow subtraction operator (`&-`), and the overflow multiplication
    operator (`&*`). The following code shows how these operators work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, we add one to the maximum value of the `UInt8` type, which is
    255, subtract one from the `UInt8` type minimum value, which is 0, and then multiply
    `42` by `10`, which has a result greater than the 255 maximum value of the `UInt8`
    type. The results that are printed to the console are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see from the results, when we add 1 to the maximum value of the `UInt8`
    type, the result is `0`. When we subtract 1 from the minimum value of the `UInt8`
    type, the result is `255` (the maximum value of the `UInt8` type). Finally, when
    we multiply `42` by `10`, which our arithmetic teachers would tell us is 420,
    we actually end up with `164` because of the overflow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we can use operator methods to add operators to our custom
    types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Operator methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operator methods enable us to add implementations of standard Swift operators
    to classes and structures. This is also known as overloading operators. This is
    a very useful feature because it enables us to provide common functionality to
    our custom types using known operators. We''ll take a look at how to do this,
    but first, let''s create a custom type called `MyPoint`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `MyPoint` structure defines a two-dimensional point on a graph. Now let''s
    add three operator methods to this type. The operators that we will add are the
    addition operator (`+`), the addition assignment operator (`+=`), and the inverse
    operator (`-`). The addition operator and the addition assignment operator are
    infix operators because there is a left and right operand (value) to the operation,
    while the inverse operator is a prefix operator because it is used before a single
    value. We also have postfix operators, which are used at the end of a single value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we add operator methods to our types, we add them as static functions using
    the operator symbols as the method names. When we add prefix or postfix operators,
    we also include the `prefix` or `postfix` keyword before the function declaration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The addition operator is an infix operator; therefore, it takes two input parameters
    of the `MyPoint` type. One parameter is for the `MyPoint` instance that is to
    the left side of the addition operator and the other parameter is for the `MyPoint`
    instance that is to the right of the addition operator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The addition assignment operator is also an infix operator; therefore, it also
    takes two input parameters of the `MyPoint` type. The main difference from the
    addition operator is that the resulting value of the addition operation is assigned
    to the `MyPoint` instance that is to the left side of the addition assignment
    operator. Therefore, this parameter is designated as an `inout` parameter so the
    results can be returned within that instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The final operator method that we added is the inverse operator. This operator
    is a prefix operator and is used before an instance of the `MyPoint` type; therefore,
    it only takes a single parameter of the `MyPoint` type. Let''s see how these operators
    work:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, we begin by defining two points and then adding them together
    using the addition operator that we created. The results of this operator are
    put in the new `combined` instance of the `MyPoint` type. The `combined` instance
    will contain the values of `x` as 6 and `y` as 14.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We then use the addition assignment operator that we created to add the values
    in the `firstPoint` instance to the values in the `combined` instance. The result
    of this operation is put in the combined instance of the `MyPoint` type. The `combined`
    instance now contains the values of `x` as 7 and `y` as 14.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the inverse operator on the `combined` instance of the `MyPoint`
    type to reverse the values and save the new values in the `inverse` instance of
    the `MyPoint` type. The `inverse` instance contains the values of `x` as -7 and
    `y` as -18.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We are not limited to using only current operators but can also create our own
    custom operators as well. Let's see how we can do this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Custom operators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom operators enable us to declare and implement our own operators outside
    of the standard operators provided by the Swift language. New operators must be
    declared globally using the `operator` keyword. They must also be defined with
    the `infix`, `prefix`, or `postfix` keywords. Once an operator is defined globally,
    we are then able to add it to our types using the operator methods as shown in
    the previous section. Let''s take a look at this by adding two new operators:
    `•`, which we will use to multiply two points together, and `••`, which will be
    used to square a value. We will add these operators to the `MyPoint` type that
    we created in the last section.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `•` symbol can be typed by holding down the *option* key and pressing the
    number *8* on a computer running macOS.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to declare the operators globally. This can
    be done with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that we define what type of operator it is (`infix`, `prefix`, or `postfix`)
    followed by the `operator` keyword and then the symbol(s) that will be used for
    the operator. Now we can use them exactly like we do normal operators with our
    `MyPoint` type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These new custom operators are added to the `MyPoint` type exactly as we added
    standard operators, using static functions. We are now able to use these operators
    exactly like we would use standard operators:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的自定义操作符就像我们添加标准操作符一样，被添加到`MyPoint`类型中，使用静态函数。我们现在能够像使用标准操作符一样使用这些操作符：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the first line we use the `•` operator to multiply two instances of the `MyPoint`
    type together. The results are put in the multiplied instance of the `MyPoint`
    type. The multiplied instance will now contain the values of `x` as 5 and `y`
    as 40\.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用`•`操作符将两个`MyPoint`类型的实例相乘。结果被放入`MyPoint`类型的乘积实例中。现在，乘积实例将包含`x`的值为5和`y`的值为40。
- en: We then use the `••` operator to square the value of the `secondPoint` instance
    and put the new value in the squared instance. The `squared` instance will now
    contain the values of `x` as 25 and `y` as 100.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`••`操作符平方`secondPoint`实例的值，并将新值放入平方实例中。现在，`squared`实例将包含`x`的值为25和`y`的值为100。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we looked at how we can use the advanced bitwise AND, OR, XOR,
    and NOT operators to manipulate the bits of values stored in variables. We also
    looked at how we can use the left and right shift operators to shift bits to the
    left and right. We then saw how we can use overflow operators to change the default
    behavior for addition, subtraction, and multiplication so errors are not thrown
    if operations return values above the maximum or below the minimum values for
    a type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用高级位与、或、异或和非操作符来操作存储在变量中的值的位。我们还探讨了如何使用左移和右移操作符将位向左和向右移动。然后我们看到如何使用溢出操作符来改变加法、减法和乘法的默认行为，以便在操作返回超出类型的最大值或小于最小值时不会抛出错误。
- en: In the second half of the chapter, we saw how we can add operator methods to
    types, which enables us to use the standard operators provided by Swift with our
    custom types. We also saw how we can create our own custom operators as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们看到了如何向类型添加操作符方法，这使得我们能够使用Swift提供的标准操作符与我们的自定义类型一起使用。我们还看到了如何创建我们自己的自定义操作符。
- en: In the next chapter, we will look at how we can use grand central dispatch and
    operation queues to add concurrency and parallelism to our applications' code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用大中央调度和操作队列向我们的应用程序代码中添加并发性和并行性。
