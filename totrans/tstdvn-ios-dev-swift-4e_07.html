<html><head></head><body>
		<div><h1 id="_idParaDest-83"><em class="italic"><a id="_idTextAnchor151"/>Chapter 5</em>: Building a Structure for ToDo Items</h1>
			<p>iOS apps are often developed using a design pattern called <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>). In this pattern, each class, struct, or enum is either a model object, view, or controller. Model objects are responsible for storing data. They should be independent of the kind of presentation provided by the UI. For example, it should be possible to use the same model object for an iOS app and a command-line tool on macOS.</p>
			<p>View objects present the data. They are responsible for making the objects visible (or hearable, in the case of a VoiceOver-enabled app) for the user. Views are special for the device that the app is executed on. In the case of a cross-platform app, view objects cannot be shared. Each platform needs an implementation of a view layer.</p>
			<p>Controller objects communicate between the model and view objects. They are responsible for making the model objects presentable.</p>
			<p>We will use MVC for our to-do app because it is one of the easiest design patterns, and it is commonly used by Apple in its sample code.</p>
			<p>This chapter starts our journey in the field of TDD with the model layer of our app. By the end of this chapter, we will have a structure where we can store all the information about a to-do item, including an optional location.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Implementing the ToDoItem struct</li>
				<li>Implementing the Location struct</li>
			</ul>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor152"/>Technical requirements</h1>
			<p>All the code for this chapter can be found (in its complete form) here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05</a>.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor153"/>Implementing the ToDoItem struct</h1>
			<p>To be useful, to-do items need a minimal set of information. In this section, we will create a structure to hold this<a id="_idIndexMarker126"/> information while using tests to guide their development.</p>
			<p>A to-do app needs a<a id="_idIndexMarker127"/> model class/struct to store information for to-do items:</p>
			<ol>
				<li>We will start by adding a new test case to the unit test target. Open the to-do project that we created in the <em class="italic">Getting started with Xcode</em> section of <a href="B18127_04_ePub.xhtml#_idTextAnchor134"><em class="italic">Chapter 4</em></a>, <em class="italic">The App We Are Going to Build</em>, and select the <strong class="bold">ToDoTests</strong> group. </li>
				<li>Go to <code>ToDoItemTests</code>, make it a subclass of <code>XCTestCase</code>, select <strong class="bold">Swift</strong> as the language, and click on <strong class="bold">Next</strong>. </li>
				<li>In the next window, click on <strong class="bold">Create</strong>.</li>
				<li>Now, delete the <code>ToDoTests.swift</code> template test case.</li>
			</ol>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor154"/>Adding a title property</h2>
			<p>A to-do item needs a <code>title</code>. Follow these steps to <a id="_idIndexMarker128"/>add one to our <code>ToDoItem</code> struct:</p>
			<ol>
				<li value="1">Open <code>ToDoItemTests.swift</code> and add the following import expression right below <code>import XCTest</code>:<pre>@testable import ToDo</pre></li>
			</ol>
			<p>This is needed to be able to test the <code>ToDo</code> module. The <code>@testable</code> keyword makes the internal methods of the <code>ToDo</code> module accessible to the test case. Alternatively, you could make the methods accessible from the test target using the <code>public</code> or <code>open</code> access levels. But you should only do that when you need that access levels because, for example, the method is part of a Swift package.</p>
			<ol>
				<li value="2">Remove the two template test methods, <code>testExample()</code> and <code>testPerformanceExample()</code>.</li>
				<li>The <code>title</code> string of a to-do item is required. Let's write a test to ensure that an initializer exists that <a id="_idIndexMarker129"/>will take a <code>title</code> string. Add the following test method to the end of the test case (but within the <code>ToDoItemTests</code> class):<pre>// ToDoItemTests.swift
func test_init_takesTitle() {
  ToDoItem(title: "Dummy")
}</pre></li>
				<li>The static analyzer that's built into Xcode will complain that it <code>Cannot find 'ToDoItem' in scope</code>:</li>
			</ol>
			<div><div><img src="img/Figure_5.01_B18127.jpg" alt="Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type</p>
			<p>We cannot compile this code because Xcode cannot find the <code>ToDoItem</code> type. A non-compiling test is a failing test; as soon as we have a failing test, we need to write implementation code to make the test pass.</p>
			<ol>
				<li value="5">To add a file for the implementation code, first, click on the <strong class="bold">ToDo</strong> group in the <strong class="bold">Project</strong> navigator. Otherwise, the added file will be put into the test group. </li>
				<li>Go to <code>ToDoItem.swift</code>, make sure that the file is added to the <code>ToDo</code> target and not to the <code>ToDoTests</code> target, and click on <strong class="bold">Create</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_5.02_B18127.jpg" alt="Figure 5.2 – Adding the file to the main target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Adding the file to the main target</p>
			<ol>
				<li value="7">Open <code>ToDoItem.swift</code> in the editor and <a id="_idIndexMarker130"/>add the following code: <pre>// ToDoItem.swift
struct ToDoItem {
}</pre></li>
			</ol>
			<p>This code is a complete implementation of a struct named <code>ToDoItem</code>. So, Xcode should now be able to find the <code>ToDoItem</code> identifier. </p>
			<ol>
				<li value="8">Run the test by either going to <code>ToDoItem</code>, like this:<pre>let item = ToDoItem()</pre></li>
				<li>However, we want to have an initializer that takes a title. We need to add a property, named <code>title</code>, of the <code>String</code> type to store the <code>title</code> string:<pre>// ToDoItem.swift
struct ToDoItem {
  let title: String
}</pre></li>
			</ol>
			<p>Run the test again; it will pass. We have implemented the first microfeature of our to-do app using TDD – and it wasn't even hard. For the rest of this book, we will do this over and over again until the app is complete. But first, we need to check whether there is anything to refactor in the existing test and implementation code. The tests and code are clean and simple, so there is nothing to refactor yet.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Always remember to check whether refactoring is needed once you have made the tests green.</p>
			<p>There are, however, a few things to note about the test. First, Xcode shows a warning stating <code>_ = ToDoItem(title: "Foo")</code>. This tells Xcode that <a id="_idIndexMarker131"/>we know what we are doing. We want to call the initializer of <code>ToDoItem</code>, but we do not care about its return value.</p>
			<p>Second, there is no <code>XCTAssert</code> function call in the test. To add an assert, we could rewrite the test like this:</p>
			<pre>func test_init_takesTitle() {
  let item = ToDoItem(title: "Dummy")
  XCTAssertNotNil(item, "item should not be nil")
}</pre>
			<p>But in Swift, a non-failable initializer cannot return <code>nil</code>. It always returns a valid instance. This means that the <code>XCTAssertNotNil()</code> method is useless. We do not need it to ensure that we have written enough code to implement the tested microfeature. It is not needed to drive the development, and it does not make the code better.</p>
			<p>Before we proceed with the next few tests, let's set up the editor in a way that makes the TDD workflow easier and faster. First, open <code>ToDoItemTests.swift</code> in the editor. Then, open the <code>ToDoItem.swift</code> to open it in the Assistant Editor. Depending on the size of your screen and your preferences, you <a id="_idIndexMarker132"/>may prefer to hide the navigator again. With this setup, you have the tests and the code side by side, and switching from test to code and vice versa takes no time at all. In addition to this, since the relevant test is visible while you write the code, it can guide the implementation.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor156"/>Adding an itemDescription property</h2>
			<p>A to-do item can have <a id="_idIndexMarker133"/>a description. We would like to have an initializer that also takes a description string. Let's get started:</p>
			<ol>
				<li value="1">To drive the implementation, we need a failing test for the existence of this initializer:<pre>// ToDoItemTests.swift
func test_init_takesTitleAndDescription() {
  _ = ToDoItem(title: "Dummy",
               itemDescription: "Dummy Description")
}</pre></li>
			</ol>
			<p>Again, this code does not compile because there is an extra argument called <code>itemDescription</code> in the call. </p>
			<ol>
				<li value="2">To make this test pass, we must add an <code>itemDescription</code> property of the <code>String?</code> type to <code>ToDoItem</code>:<pre>// ToDoItem.swift
struct ToDoItem {
  let title: String
  let itemDescription: String?
}</pre></li>
				<li>Run the tests. The <code>test_init_takesTitle()</code> test will fail (that is, it will not compile) because there is a <code>init</code> methods as well) can have default values for parameters. You will use this feature to set <code>itemDescription</code> to <code>nil</code> if there is no parameter for it in the initializer.</li>
				<li>Add the following code to <code>ToDoItem</code>:<pre>// ToDoItem.swift
init(title: String,
     itemDescription: String? = nil) {
  self.title = title
  self.itemDescription = itemDescription
}</pre></li>
			</ol>
			<p>This initializer has two arguments. The second argument has a default value, so we do not need to provide both arguments. When the second argument is omitted, the default value is used.</p>
			<ol>
				<li value="5">Now, run the tests to make sure that both tests pass.</li>
			</ol>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor157"/>Removing a hidden source of bugs</h2>
			<p>To be able to use a <a id="_idIndexMarker135"/>short initializer by only setting the title, we need to define it ourselves. But this also introduces a new source of potential bugs. We can remove the two microfeatures we have implemented and still have both tests pass. To take a look at how this works, open <code>ToDoItem.swift</code> and comment out the properties and assignment in the initializer:</p>
			<pre>struct ToDoItem {
//  let title: String
//  let itemDescription: String?
 
  init(title: String,
       itemDescription: String? = nil) {
 
//    self.title = title
//    self.itemDescription = itemDescription
  }
}</pre>
			<p>Run the tests. Both tests will still pass. The reason for this is that they do not check whether the values of the initializer arguments are set to any <code>ToDoItem</code> properties. We can easily extend the tests to make sure that the values are set. First, let's change the name of the first test to <code>test_init_whenGivenTitle_setsTitle()</code> and replace it with the following code:</p>
			<pre>// ToDoItemTests.swift
func test_init_whenGivenTitle_setsTitle() {
  let item = ToDoItem(title: "Dummy")
  XCTAssertEqual(item.title, "Dummy")
}</pre>
			<p>This test does not compile because <code>ToDoItem</code> does not have a <code>title</code> property (it is commented out). This shows that the test is now testing our intention. Remove the comment signs for the title property and assignment of the title in the initializer, and then run the tests again. All the <a id="_idIndexMarker136"/>tests will pass. Now, replace the second test with this one:</p>
			<pre>// ToDoItemTests.swift
func test_init_whenGivenDescription_setsDescription() {
  let item = ToDoItem(title: "Dummy",
                      itemDescription: "Dummy Description")
  XCTAssertEqual(item.itemDescription, "Dummy Description")
}</pre>
			<p>Remove the remaining comment signs in <code>ToDoItem</code> and run the tests again. Both the tests will pass again, and they now test that the initializer works.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is a good idea to use speaking test method names – that is, names that tell the story of the test. It's quite common to use a pattern such as <code>test_&lt;method name&gt;_&lt;precondition&gt;_&lt;expected behavior&gt;</code>. This way, the method name tells all that you need to know about the test when a test fails. In this book, we will try to follow this pattern, but we will leave out some information (for example, the precondition) when the code gets harder to read because of the limited space we have. You should develop a pattern and use it in all your tests.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor158"/>Adding a timestamp property</h2>
			<p>A to-do item can also<a id="_idIndexMarker137"/> have a due date represented by a <code>timestamp</code> property:</p>
			<ol>
				<li value="1">Add the following test to make sure we can initialize an instance of <code>ToDoItem</code> with <code>timestamp</code>:<pre>// ToDoItemTests.swift
func test_init_setsTimestamp() {
  let dummyTimestamp: TimeInterval = 42.0
  let item = ToDoItem(title: "Dummy",
                      timestamp: dummyTimestamp)
  XCTAssertEqual(item.timestamp, dummyTimestamp)
}</pre></li>
			</ol>
			<p>Again, this test does not compile because there is an extra argument in the initializer. From the<a id="_idIndexMarker138"/> implementation of the other properties, we know that we have to add a <code>timestamp</code> property in <code>ToDoItem</code> and set it in the initializer.</p>
			<ol>
				<li value="2">Change <code>ToDoItem</code> so that it looks like this:<pre>// ToDoItem.swift
struct ToDoItem {
  let title: String
  let itemDescription: String?
  let timestamp: TimeInterval?
 
  init(title: String,
       itemDescription: String? = nil,
       timestamp: TimeInterval? = nil) {
 
    self.title = title
    self.itemDescription = itemDescription
    self.timestamp = timestamp
  }
}</pre></li>
				<li>Run the tests. With a bit of luck, all the tests will pass. But what happens if they don't pass on your computer? The reason for this may be because we compare two <code>TimeInterval</code> structures using <code>XCTAssertEqual(_:_:)</code>. <code>TimeInterval</code> is a type alias for <code>Double</code>. Doubles are floating-point numbers and as such are hard to compare to each other. Usually, you can't tell if two floating-point numbers are equal. You can only tell if they are equal in respect to some accuracy. That's why <code>XCTest</code> provides <a id="_idIndexMarker139"/>an assert method with accuracy. </li>
				<li>Replace the assert method call in <code>test_init_setsTimestamp()</code> with the following method call:<pre>XCTAssertEqual(item.timestamp!,
               dummyTimestamp,
               accuracy: 0.000_001)</pre></li>
			</ol>
			<p>Run the tests. You will see that all the tests pass.</p>
			<p>You may have noticed that we have to force unwrap <code>item.timestamp</code> to use it in the assert method with accuracy. The reason for this is that, in contrast to <code>XCTAssertEqual(_:_:)</code>, <code>XCTAssertEqual(_:_:accuracy:)</code> can't compare optional values. <code>timestamp</code> in <code>ToDoItem</code> is optional so that to-do items without due dates can be created. Force unwrapping a value in a unit test is not as problematic as doing so in production code because a crash in a test is only visible for the developer.</p>
			<p>But still, Apple added a feature to <code>XCTest</code> to deal with optional values better. This is so important for the rest of this book that it deserves a section to itself.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor159"/>Dealing with optional values in unit tests</h2>
			<p>With Xcode 11, Apple<a id="_idIndexMarker140"/> introduced the <code>XCTUnwrap(_:)</code> function to <code>XCTest</code>. This function unwraps its parameter and returns the unwrapped value. If the parameter is <code>nil</code>, this function throws an error. In this section, we will use this function to improve our test code. Replace the <code>test_init_setsTimestamp()</code> test method with the following code:</p>
			<pre>// ToDoItemTests.swift
func test_init_setsTimestamp() throws {
  let dummyTimestamp: TimeInterval = 42.0
  let item = ToDoItem(title: "Dummy",
                      timestamp: dummyTimestamp)
  let timestamp = try XCTUnwrap(item.timestamp)
  XCTAssertEqual(timestamp,
                 dummyTimestamp,
                 accuracy: 0.000_001)
} </pre>
			<p>Several things have changed in this code. Let's look at them one by one:</p>
			<ul>
				<li>The method is now marked with <code>throws</code>. The reason for this is that we call a function that can<a id="_idIndexMarker141"/> throw an error. A test method that is marked with <code>throws</code> fails, when an error is thrown and not caught during its execution.</li>
				<li>With <code>try XCTUnwrap(item.timestamp)</code>, we try to unwrap the <code>item.timestamp</code> value.</li>
				<li>The result is assigned to a variable that is used in the <code>XCTAssertEqual</code> method.</li>
			</ul>
			<p>Whenever you have to deal with optionals in test code, this is the preferred way to do so. This way, you get the most valuable information in case the value is unexpectedly <code>nil</code>.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor160"/>Adding a location property</h2>
			<p>The last property that we<a id="_idIndexMarker142"/> would like to be able to set in the initializer of <code>ToDoItem</code> is its <code>Location</code>. The location has a name and can optionally have a coordinate. We will use a struct to encapsulate this data into a type. Let's get started: </p>
			<ol>
				<li value="1">Add the following code to <code>ToDoItemTests</code>:<pre>// ToDoItemTests.swift
func test_init_whenGivenLocation_setsLocation() {
  let dummyLocation = Location(name: "Dummy Name")
}</pre></li>
			</ol>
			<p>The test is not finished, but it already fails because Xcode <code>Location</code> yet. </p>
			<ol>
				<li value="2">Open the <code>Location.swift</code> to the <code>ToDoItem</code> struct, we already know what is needed to make the test green. </li>
				<li>Add the following code to <code>Location.swift</code>:<pre>// Location.swift
struct Location {
  let name: String
}</pre></li>
			</ol>
			<p>This defines a struct called <code>Location</code> with a <code>name</code> property and makes the test code compilable again. But the test is not finished yet. </p>
			<ol>
				<li value="4">Add the following code to <code>test_init_whenGivenLocation_setsLocation()</code>:<pre>// ToDoItemTests.swift
func test_init_whenGivenLocation_setsLocation() {
  let dummyLocation = Location(name: "Dummy Name")
  let item = ToDoItem(title: "Dummy Title",
                      location: dummyLocation)
  XCTAssertEqual(item.location?.name,
                 dummyLocation.name)
}</pre></li>
			</ol>
			<p>Unfortunately, we cannot use the location itself to check for equality yet, so the following assert does not work:</p>
			<pre>XCTAssertEqual(item.location, dummyLocation)</pre>
			<p>The reason <a id="_idIndexMarker143"/>for this is that the first two arguments of <code>XCTAssertEqual()</code> have to conform to the <code>Equatable</code> protocol. We will add the protocol's conformance in the next chapter.</p>
			<p>Again, this does not compile because the initializer of <code>ToDoItem</code> does not have an argument called <code>Location</code>. </p>
			<ol>
				<li value="5">Add the <code>location</code> property and initializer argument to <code>ToDoItem</code>. The result should look like this:<pre>// ToDoItem.swift
struct ToDoItem {
  let title: String
  let itemDescription: String?
  let timestamp: TimeInterval?
  let location: Location?
 
  init(title: String,
       itemDescription: String? = nil,
       timestamp: TimeInterval? = nil,
       location: Location? = nil) {
 
    self.title = title
    self.itemDescription = itemDescription
    self.timestamp = timestamp
    self.location = location
  }
}</pre></li>
				<li>Run the tests again. All the tests will pass and there will be nothing to refactor. We have now<a id="_idIndexMarker144"/> implemented a struct to hold <code>ToDoItem</code> using TDD.</li>
			</ol>
			<p>In the next section, we will implement a structure to store location data for to-do items.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor161"/>Implementing the Location struct</h1>
			<p>In the previous section, we<a id="_idIndexMarker145"/> added a struct to hold information about the location. We will now add tests to make sure that <code>Location</code> has the required <a id="_idIndexMarker146"/>properties and initializer.</p>
			<p>These tests could be added to <code>ToDoItemTests</code>, but they are easier to maintain when the test classes mirror the implementation classes/structs. So, we need a new test case class.</p>
			<p>Open the <code>ToDoTests</code> group, and add a unit test case class called <code>LocationTests</code>. Make sure that you go to <strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Unit Test Case Class</strong> since we want to test the iOS code, and Xcode sometimes navigates to <strong class="bold">OS X</strong> | <strong class="bold">Source</strong>.</p>
			<p>Set up the editor to show <code>LocationTests.swift</code> on the left-hand side and <code>Location.swift</code> in the Assistant Editor on the right-hand side. In the test class, add <code>@testable import ToDo</code> and remove<a id="_idIndexMarker147"/> the <code>testExample()</code> and <code>testPerformanceExample()</code> template tests.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor162"/>Adding a coordinate property</h2>
			<p>The location of a<a id="_idIndexMarker148"/> to-do item will be used in the app to show a map in the details. A location on a map can be stored using <code>latitude</code> and <code>longitude</code> values. In the following steps, we will add a <code>coordinate</code> property to store this information:</p>
			<ol>
				<li value="1">To drive the addition of a <code>Coordinate</code> property, we need a failing test. For the coordinate, we will use the <code>CLLocationCoordinate2D</code> type from the Core Location framework.</li>
				<li>Import <code>CoreLocation</code> below the existing import statements:<pre>// LocationTests.swift
import XCTest
@testable import ToDo
import CoreLocation</pre></li>
				<li>Add the following test to <code>LocationTests</code>:<pre>// LocationTests.swift
func test_init_setsCoordinate() throws {
  let coordinate = CLLocationCoordinate2D(latitude: 1,
                                          longitude: 2)
  let location = Location(name: "",
                          coordinate: coordinate)
  let resultCoordinate = try XCTUnwrap(location.coordinate)
  XCTAssertEqual(resultCoordinate.latitude, 1,
                 accuracy: 0.000_001)
  XCTAssertEqual(resultCoordinate.longitude, 2,
                 accuracy: 0.000_001)
}</pre></li>
			</ol>
			<p>First, we created a coordinate and used it to create an instance of <code>Location</code>. Then, we asserted that the <code>latitude</code> and <code>longitude</code> values of the location coordinates have been set to the correct values. We use values of <code>1</code> and <code>2</code> in the initializer of <code>CLLocationCoordinate2D</code> because it also has an initializer that takes no arguments (<code>CLLocationCoordinate2D()</code>) and sets the <code>longitude</code> and <code>latitude</code> values to<a id="_idIndexMarker149"/> zero. We need to make sure that the initializer of <code>Location</code> assigns the coordinate argument to its property in the test.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have noticed that we have omitted the <code>message</code> parameter in the <code>XCTAssertEqual()</code> function. This is because the used assertion already gives enough context to help us figure out what we expect in the test. We expect that the two values are the same. There is no need to duplicate that information in the message. If you find that information useful, feel free to add a message yourself.</p>
			<p>The test does not compile because <code>Location</code> does not have a <code>coordinate</code> property yet. Similar to <code>ToDoItem</code>, we would like to have a short initializer for locations that only have a <code>name</code> argument. Therefore, we need to implement the initializer ourselves, and we cannot use the one provided by Swift. </p>
			<ol>
				<li value="4">Replace the contents of <code>Location.swift</code> with the following lines of code:<pre>// Location.swift
import Foundation
import CoreLocation
 
struct Location {
  let name: String
  let coordinate: CLLocationCoordinate2D?
 
  init(name: String,
       coordinate: CLLocationCoordinate2D? = nil) {
 
    self.name = ""
    self.coordinate = coordinate
  }
}</pre></li>
				<li>Now, run the tests. All the tests will pass.</li>
			</ol>
			<p>Note that we have<a id="_idIndexMarker150"/> intentionally set <code>name</code> in the initializer to an empty string. This is the easiest implementation that makes the tests pass. But it is not what we want. The initializer should set the name of the location to the value in the <code>name</code> argument. So, we need another test to make sure that <code>name</code> is set correctly.</p>
			<ol>
				<li value="6">Add the following test to <code>LocationTests</code>:<pre>// LocationTests.swift
func test_init_setsName() {
  let location = Location(name: "Dummy")
  XCTAssertEqual(location.name, "Dummy")
}</pre></li>
				<li>Run the test to make sure it fails. To make the test pass, change <code>self.name = ""</code> in the initializer of <code>Location</code> to <code>self.name = name</code>. Run the tests again to check whether they all pass now. There is nothing to refactor in the tests and their implementation.</li>
			</ol>
			<p>Now, the <code>Location</code> structure can store a name and an optional coordinate to be used in the user interface of the app.</p>
			<p>You may have asked yourself, why did we start with the <code>coordinate</code> property and not the <code>name</code> property when implementing that feature? We started with the coordinate because it was new terrain for us. We didn't know how to tackle testing <code>Double</code> values. Sometimes, it can be liberating to work on the most difficult problem first. It depends on how you write code. Tests help us make small baby steps and therefore help make difficult problems easier to solve.</p>
			<p>I wanted to show you <a id="_idIndexMarker151"/>how to test the coordinate first, to address the elephant in the room. If you feel better when working on the easier tests first, go for it. But don't write unnecessary and easy tests just to procrastinate and avoid working on the hard ones.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor163"/>Summary</h1>
			<p>In this chapter, we created a structure to hold information for to-do items using TDD. We learned that TDD means switching between test code and production code all the time. In addition, we realized that we should use the assert method with the accuracy parameter when we need to compare floating-point numbers. What you learned in this chapter will help you write better and more robust unit tests.</p>
			<p>In the next chapter, we will build a structure to manage to-do items. They need to be stored somewhere and we need to have a way to add and check off to-do items.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor164"/>Exercises</h1>
			<ol>
				<li value="1">Try to write a test using <code>XCTAssertEqual(_:_:)</code> that fails, even if the values are equal, because of problems in comparing floating points. Hint: You often get this problem when using simple math functions such as addition and multiplication.</li>
				<li>Make <code>ToDoItem</code> conform to <code>Equatable</code> and rewrite the assertions to take advantage of that conformance.</li>
			</ol>
		</div>
	</body></html>