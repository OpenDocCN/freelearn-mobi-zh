<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor092" class="calibre3 pcalibre pcalibre1"/>7</h1>
<h1 id="_idParaDest-84" class="calibre6"><a id="_idTextAnchor093" class="calibre3 pcalibre pcalibre1"/>Navigating within Your App</h1>
<p class="calibre4">The apps we make need to move from one screen to the other, showing different content on these screens. So far, we have been making apps with only one screen. In this chapter, we will learn how to move from one screen to the other. We will learn how to use the <strong class="bold">Jetpack Compose Navigation</strong> library to navigate to different Jetpack Compose screens within our app. We will learn the tips and best practices for using this library. Also, we will cover how to pass arguments as we navigate to screens. Lastly, we will build on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055" class="calibre3 pcalibre pcalibre1"><em class="italic">Chapter 4</em></a>, by handling navigation on large screens and foldables.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Jetpack Navigation overview</li>
<li class="calibre15">Navigating to Compose destinations</li>
<li class="calibre15">Passing arguments to destinations</li>
<li class="calibre15">Navigation in foldables and large screens</li>
</ul>
<h1 id="_idParaDest-85" class="calibre6"><a id="_idTextAnchor094" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven</a>.</p>
<h1 id="_idParaDest-86" class="calibre6"><a id="_idTextAnchor095" class="calibre3 pcalibre pcalibre1"/>Jetpack Navigation overview</h1>
<p class="calibre4">The Jetpack Navigation library <a id="_idIndexMarker300" class="calibre3 pcalibre pcalibre1"/>provides an API for handling <strong class="bold">complex navigation</strong> with ease while also following the principles of Android Jetpack. The library is available for both the old view system, which uses XML (<a href="https://developer.android.com/guide/navigation" class="calibre3 pcalibre pcalibre1">https://developer.android.com/guide/navigation</a>), and Jetpack Compose (<a href="https://developer.android.com/jetpack/compose/navigation" class="calibre3 pcalibre pcalibre1">https://developer.android.com/jetpack/compose/navigation</a>). We will be learning about the latter in this chapter.</p>
<p class="calibre4">Still building on<a id="_idIndexMarker301" class="calibre3 pcalibre pcalibre1"/> the Pets app we used in the previous chapter, we are going to navigate to a details screen that has a back button to the previous screen. We will also be passing data to the details screen.</p>
<p class="calibre4">To start with, we need to add the Jetpack Navigation Compose dependency to our project. Let’s add the following library inside the <code>versions</code> section in our <code>libs.versions.toml</code> file:</p>
<pre class="source-code">
compose-navigation = "androidx.navigation:navigation-compose:2.7.2"</pre> <p class="calibre4">Next, we need to add the dependency to our app module’s <code>build.gradle.kts</code> file:</p>
<pre class="source-code">
implementation(libs.compose.navigation)</pre> <p class="calibre4">Do a Gradle sync to add the library to our project. The next step is to create <code>NavController</code> and <code>NavHost</code>. <code>NavController</code> is a class that manages app navigation within <code>NavHost</code>. <code>NavHost</code> is a container that hosts composables and handles navigation between them. Let’s create a new package called <code>navigation</code> and create a new sealed class called <code>Screens.kt</code>. Inside the file, let us add the following code:</p>
<pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
}</pre> <p class="calibre4">This is a sealed class that has two objects. A <a id="_idIndexMarker302" class="calibre3 pcalibre pcalibre1"/>sealed class is used to represent restricted class hierarchies wherein the object or value can only have a value among one of the types defined in the sealed class. The first object is <code>PetsScreen</code>, which will be the first screen we will see when we launch the app. The second object is <code>PetDetailsScreen</code>, which will be the screen we will navigate to when we click on a pet item in <code>PetsScreen</code>. Every time we need to add a new destination screen, we will add a new object to the sealed class.</p>
<p class="calibre4">Next, let us <a id="_idIndexMarker303" class="calibre3 pcalibre pcalibre1"/>create a new file inside the <code>navigation</code> package called <code>AppNavigation.kt</code>. Inside the file, let us add the following code:</p>
<pre class="source-code">
@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination =  Screens.PetsScreen.route
    ){
        composable(Screens.PetsScreen.route){
            PetsScreen()
        }
    }
}</pre> <p class="calibre4">Let’s explain the preceding code:</p>
<ul class="calibre16">
<li class="calibre15">We create <strong class="source-inline1">NavController</strong> using the <strong class="source-inline1">rememberNavController()</strong> function. This function is used to create <strong class="source-inline1">NavController</strong> that will be remembered across recompositions. This is important because we need to be able to navigate to different screens in our app.</li>
<li class="calibre15">We create a <strong class="source-inline1">NavHost</strong> composable that takes in <strong class="source-inline1">navController</strong> and <strong class="source-inline1">startDestination</strong>. <strong class="source-inline1">startDestination</strong> is the first screen we want to see when we launch the app. In our case, it is <strong class="source-inline1">PetsScreen</strong>.</li>
<li class="calibre15">We add the <strong class="source-inline1">PetsScreen</strong> composable. This composable has an error because we have <a id="_idIndexMarker304" class="calibre3 pcalibre pcalibre1"/>not created it yet. We will do that shortly.</li>
</ul>
<div><div><img alt="Figure 7.1 – PetsScreen error" src="img/B19779_07_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – PetsScreen error</p>
<p class="calibre4">As seen in the preceding screenshot, the <code>PetsScreen</code> composable is highlighted in red because we have not created the composable yet. We will refactor our code a bit. Let us create a new file called <code>PetsScreen.kt</code>. Inside the file, let’s add the following code:</p>
<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetsScreen(onPetClicked: (Cat) -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                onPetClicked = onPetClicked
            )
        }
    )
}</pre> <p class="calibre4">The <code>PetsScreen</code> composable <a id="_idIndexMarker305" class="calibre3 pcalibre pcalibre1"/>displays a list of pets. We have added a <code>Scaffold</code> composable as the root element. Inside the <code>Scaffold</code> composable, we have added a <code>TopAppBar</code> composable. We have also added a <code>PetList</code> composable as the content of the <code>Scaffold</code> composable. We have added a new <code>onPetClicked</code> callback to the <code>PetList</code> composable. We will be using this callback to navigate to <code>PetDetailsScreen</code> when we click on a pet item in the list.</p>
<p class="calibre4">With this, our navigation graph is ready. We can now add the <code>AppNavigation</code> composable to our <code>MainActivity.kt</code> file. Let’s replace all the code inside the <code>ChapterSevenTheme</code> block with the following:</p>
<pre class="source-code">
ChapterSevenTheme {
    AppNavigation()
}</pre> <p class="calibre4">Build and run the <a id="_idIndexMarker306" class="calibre3 pcalibre pcalibre1"/>app. The app still displays a list of cute pets as before, but now we are using the Jetpack Navigation library to handle our navigation.</p>
<div><div><img alt="Figure 7.2 – Pets" src="img/B19779_07_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Pets</p>
<p class="calibre4">In the next section, let us learn how to navigate to a details screen when we click on a pet item in the list.</p>
<h1 id="_idParaDest-87" class="calibre6"><a id="_idTextAnchor096" class="calibre3 pcalibre pcalibre1"/>Navigating to Compose destinations</h1>
<p class="calibre4">In this <a id="_idIndexMarker307" class="calibre3 pcalibre pcalibre1"/>section, we will learn how to navigate to a details screen when we click on a pet item in the list. First, we need to create a new composable for <code>PetDetailsScreen</code>. Let us create a new file called <code>PetDetailsScreen.kt</code> and create the <code>PetDetailsScreenContent</code> composable as <a id="_idIndexMarker308" class="calibre3 pcalibre pcalibre1"/>follows:</p>
<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/rV1MVEh0Af2Bm4O0",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(2) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = "Tag $it")
                    }
                )
            }
        }
    }
}</pre> <p class="calibre4">Here, we<a id="_idIndexMarker309" class="calibre3 pcalibre pcalibre1"/> created a composable that has <code>Column</code> as the root element. Inside the <code>Column</code> element, we added an <code>AsyncImage</code> composable that displays a cat image. We also added a <code>FlowRow</code> composable to flow items to the next line when space runs out, which cannot be achieved with rows. <code>FlowRow</code> displays two <code>SuggestionChip</code> composables. We will use this composable to display the details of a pet. Notice we are using hardcoded cat IDs and tags for now. We will pass this data from the <code>PetList</code> composable in the next section. Next, let us create the <code>PetDetailsScreen</code> composable as follows:</p>
<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues)
            )
        }
    )
}</pre> <p class="calibre4">The <code>PetDetailsScreen</code> composable<a id="_idIndexMarker310" class="calibre3 pcalibre pcalibre1"/> displays the details of a pet. We have added a <code>Scaffold</code> composable as the root element. Inside the <code>Scaffold</code> composable, we have added a <code>TopAppBar</code> composable. We have also used the <code>PetDetailsScreenContent</code> composable we created earlier as the content of the <code>Scaffold</code> composable. We have added a new <code>onBackPressed</code> callback to the <code>PetDetailsScreen</code> composable. We will be using this callback to navigate back to the previous screen when we click on the back button in <code>TopAppBar</code>.</p>
<p class="calibre4">Our next step is to add a composable for <code>PetDetailsScreen</code> to our <code>AppNavigation.kt</code> file. Let us add the following code to our <code>NavHost</code> below the composable for <code>PetsScreen</code>:</p>
<pre class="source-code">
composable(Screens.PetDetailsScreen.route){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        }
    )
}</pre> <p class="calibre4">Here, we have added a composable for <code>PetDetailsScreen</code>. We passed in the route for the screen and the <code>PetDetailsScreen</code> composable as the content. <code>PetDetailsScreen</code> has the <code>onBackPressed</code> argument. The argument handles the situation where a user taps the back arrow icon, which is normally at the top left. We use <code>navController.popBackStack()</code> inside the <code>onBackPressed</code> argument. This method attempts to pop the current destination off the back stack and navigates to the previous destination.</p>
<p class="calibre4">Now we <a id="_idIndexMarker311" class="calibre3 pcalibre pcalibre1"/>need to do the actual navigation to <code>PetDetailsScreen</code> when we click on a pet item in the list. Let us head over to the <code>PetListItem</code> composable. We will add a new <code>onPetClicked</code> callback to the <code>PetListItem</code> composable. The modified composable should look like this:</p>
<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat, onPetClicked: (Cat) -&gt; Unit) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
              repeat(cat.tags.size) {
                  SuggestionChip(
                      modifier = Modifier
                          .padding(start = 3.dp, end = 3.dp),
                      onClick = { },
                      label = {
                          Text(text = cat.tags[it])
                      }
                  )
              }
            }
        }
    }
}</pre> <p class="calibre4">In the preceding code, we have added a new <code>onPetClicked</code> callback to the composable. We have added the <code>clickable</code> modifier to <code>Column</code> and called the <code>onPetClicked</code> callback inside the modifier. We pass in the <code>cat</code> object to the callback. Next, we<a id="_idIndexMarker312" class="calibre3 pcalibre pcalibre1"/> need to add the <code>onPetClicked</code> callback to the <code>PetList</code> composable, as follows:</p>
<pre class="source-code">
@Composable
fun PetList(modifier: Modifier, onPetClicked: (Cat) -&gt; Unit) {
    // other code
}</pre> <p class="calibre4">Next, we need to pass this callback where we use our <code>PetListItem</code> composable. The modified <code>PetListItem</code> composable at the call site inside the items block should look like this:</p>
<pre class="source-code">
PetListItem(
    cat = pet,
    onPetClicked = onPetClicked
)</pre> <p class="calibre4">Lastly, we need to modify the <code>AppNavigation</code> composable to pass the <code>onPetClicked</code> callback to the <code>PetsScreen</code> composable. The modified <code>AppNavigation</code> composable should look like this:</p>
<pre class="source-code">
PetsScreen(
    onPetClicked = {
        navController.navigate(Screens.PetDetailsScreen.route)
    }
)</pre> <p class="calibre4">Here, we pass the <code>onPetClicked</code> callback to the <code>PetsScreen</code> composable. Inside the callback, we call the <code>navigate()</code> function on <code>navController</code> and pass in the route for <code>PetDetailsScreen</code>. This will navigate to <code>PetDetailsScreen</code> when we click on a<a id="_idIndexMarker313" class="calibre3 pcalibre pcalibre1"/> pet item in the list.</p>
<p class="calibre4">Build and run the app. Click on a pet item in the list. You will see that the app navigates to <code>PetDetailsScreen</code>.</p>
<div><div><img alt="Figure 7.3 – Pet Details screen" src="img/B19779_07_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Pet Details screen</p>
<p class="calibre4">We can see a cute <a id="_idIndexMarker314" class="calibre3 pcalibre pcalibre1"/>cat image and some tags. Additionally, if we press the back button in <code>TopAppBar</code>, we will be able to navigate back to <code>PetsScreen</code>.</p>
<p class="calibre4">So far, we have been able to navigate from <code>PetsScreen</code> to <code>PetDetailsScreen</code>. However, we are not passing any data to <code>PetDetailsScreen</code>. In the next section, we will learn how to pass data to <code>PetDetailsScreen</code>.</p>
<h1 id="_idParaDest-88" class="calibre6"><a id="_idTextAnchor097" class="calibre3 pcalibre pcalibre1"/>Passing arguments to destinations</h1>
<p class="calibre4">In our <code>PetDetailsScreen</code>, we need to remove the hardcoded cat IDs and tags and pass them<a id="_idIndexMarker315" class="calibre3 pcalibre pcalibre1"/> from the <code>PetList</code> composable. Follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Let us head <a id="_idIndexMarker316" class="calibre3 pcalibre pcalibre1"/>over to the <strong class="source-inline1">PetDetailsScreenContent</strong> composable inside the <strong class="source-inline1">PetDetailsScreen.kt</strong> file and modify it as follows:<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetDetailsScreenContent(modifier: Modifier, cat: Cat) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        FlowRow(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
        ) {
            repeat(cat.tags.size) {
                SuggestionChip(
                    modifier = Modifier
                        .padding(start = 3.dp, end = 3.dp),
                    onClick = { },
                    label = {
                        Text(text = cat.tags[it])
                    }
                )
            }
        }
    }
}</pre><p class="calibre4">We have <a id="_idIndexMarker317" class="calibre3 pcalibre pcalibre1"/>added a new <code>cat</code> parameter<a id="_idIndexMarker318" class="calibre3 pcalibre pcalibre1"/> to the composable. We have used the <code>cat</code> object to display the cat image and tags.</p></li> <li class="calibre15">Next, let us head over to the <strong class="source-inline1">PetDetailsScreen</strong> composable and modify it as follows:<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PetDetailsScreen(onBackPressed: () -&gt; Unit, cat: Cat) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(text = "Pet Details")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                ),
                navigationIcon = {
                    IconButton(
                        onClick = onBackPressed,
                        content = {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Back"
                            )
                        }
                    )
                }
            )
        },
        content = { paddingValues -&gt;
            PetDetailsScreenContent(
                modifier = Modifier
                    .padding(paddingValues),
                cat = cat
            )
        }
    )
}</pre><p class="calibre4">Here, we<a id="_idIndexMarker319" class="calibre3 pcalibre pcalibre1"/> have added a new <code>cat</code> parameter to the composable. We have passed the <code>cat</code> object to the <code>PetDetailsScreenContent</code> composable.</p></li> <li class="calibre15">Next, let<a id="_idIndexMarker320" class="calibre3 pcalibre pcalibre1"/> us head over to the <strong class="source-inline1">AppNavigation</strong> composable and add the logic for passing the <strong class="source-inline1">cat</strong> object to <strong class="source-inline1">PetDetailsScreen</strong>. We need to first modify the composable for <strong class="source-inline1">PetDetailsScreen</strong>, as follows:<pre class="source-code">
composable(
    route = "${Screens.PetDetailsScreen.route}/{cat}",
    arguments = listOf(
        navArgument("cat") {
            type = NavType.StringType
        }
    )
){
    PetDetailsScreen(
        onBackPressed = {
            navController.popBackStack()
        },
        cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
    )
}</pre><p class="calibre4">Let’s<a id="_idIndexMarker321" class="calibre3 pcalibre pcalibre1"/> explain the changes:</p><ul class="calibre17"><li class="calibre15">On the <a id="_idIndexMarker322" class="calibre3 pcalibre pcalibre1"/>route, we have added a new parameter called <strong class="source-inline1">cat</strong>. This is the parameter we will use to pass the <strong class="source-inline1">cat</strong> object to <strong class="source-inline1">PetDetailsScreen</strong>.</li><li class="calibre15">We have added a new <strong class="source-inline1">arguments</strong> parameter. This parameter is used to pass arguments to the destination screen. We have added <strong class="source-inline1">navArgument</strong> for the <strong class="source-inline1">cat</strong> parameter. We have set the type to be <strong class="source-inline1">String</strong>. This is because we will be passing a string representation of the <strong class="source-inline1">cat</strong> object.</li><li class="calibre15">We pass the <strong class="source-inline1">cat</strong> object to the <strong class="source-inline1">PetDetailsScreen</strong> composable. We have used <strong class="source-inline1">Json.decodeFromString()</strong> from the Kotlinx Serialization library that we learned about in <a href="B19779_06.xhtml#_idTextAnchor084" class="calibre3 pcalibre pcalibre1"><em class="italic">Chapter 6</em></a> to convert the string value of the <strong class="source-inline1">cat</strong> object into a <strong class="source-inline1">Cat</strong> object. We have used the <strong class="source-inline1">arguments</strong> property of <strong class="source-inline1">NavBackStackEntry</strong> to get the string value of the <strong class="source-inline1">cat</strong> object. We have used the Elvis operator to return an empty string if the <strong class="source-inline1">arguments</strong> property is null.</li></ul></li> <li class="calibre15">Lastly, we need to modify the <strong class="source-inline1">onPetClicked</strong> callback of <strong class="source-inline1">PetsScreen</strong> in the <strong class="source-inline1">AppNavigation</strong> composable, as follows:<pre class="source-code">
composable(Screens.PetsScreen.route) {
    PetsScreen(
        onPetClicked = { cat -&gt;
            navController.navigate(
                "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
            )
        }
    )
}</pre><p class="calibre4">We have <a id="_idIndexMarker323" class="calibre3 pcalibre pcalibre1"/>modified the <code>navigate()</code> function <a id="_idIndexMarker324" class="calibre3 pcalibre pcalibre1"/>to pass the <code>Cat</code> object as a string. We also used <code>Json.encodeToString()</code> from the Kotlinx Serialization library to convert the <code>Cat</code> object into a string. This will be passed as an argument to <code>PetDetailsScreen</code> when we click on a pet item in the list.</p></li> <li class="calibre15">Build and run the app. Click on any cute cat picture from the list and now the details screen will display the cat image and tag of the cute cat that we selected:</li>
</ol>
<div><div><img alt="Figure 7.4 – Pet Details" src="img/B19779_07_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Pet Details</p>
<p class="calibre4">We have<a id="_idIndexMarker325" class="calibre3 pcalibre pcalibre1"/> now been able to pass data to <code>PetDetailsScreen</code>. We <a id="_idIndexMarker326" class="calibre3 pcalibre pcalibre1"/>have learned how to navigate to a compose destination and pass data to the details screen. In the next section, we will learn how to handle navigation in foldables and large screens.</p>
<h1 id="_idParaDest-89" class="calibre6"><a id="_idTextAnchor098" class="calibre3 pcalibre pcalibre1"/>Navigation in foldables and large screens</h1>
<p class="calibre4">In the <em class="italic">Designing UIs for large screens and foldables</em> section of <a href="B19779_04.xhtml#_idTextAnchor055" class="calibre3 pcalibre pcalibre1"><em class="italic">Chapter 4</em></a>, we learned<a id="_idIndexMarker327" class="calibre3 pcalibre pcalibre1"/> about the <code>WindowSize</code> class and how we can make our apps responsive in foldable devices and large screens. In this section, we are going to make our Pets app responsive in foldable devices and<a id="_idIndexMarker328" class="calibre3 pcalibre pcalibre1"/> large screens. We are going to make several changes, as follows:</p>
<ul class="calibre16">
<li class="calibre15">Add a bottom bar to <strong class="source-inline1">PetsScreen</strong>, which will have several options.</li>
<li class="calibre15">Add <strong class="source-inline1">NavigationRail</strong> and <strong class="source-inline1">NavigationDrawer</strong>, which will be used depending on the screen size.</li>
<li class="calibre15">Observe the device’s foldable state and change the layout of the app depending on the foldable state.</li>
<li class="calibre15">Depending on the screen size, we will also change the content type. On large screens, we will display the list of cats and the details of the selected cat side by side. On small screens, we will display the list of cats and the details of the selected cat on different screens.</li>
</ul>
<p class="calibre4">Quite a lot of <a id="_idIndexMarker329" class="calibre3 pcalibre pcalibre1"/>changes are required. The good thing is that I have already made the changes and you can find the final version in the <code>chapterseven</code> folder in the project’s repository. Let us go through the changes one by one:</p>
<ol class="calibre14">
<li class="calibre15">We will start by creating a <strong class="source-inline1">sealed interface</strong> named <strong class="source-inline1">NavigationType</strong> that represents the different types of navigation we will be using in our app. Let us create a new file inside the <strong class="source-inline1">navigation</strong> package called <strong class="source-inline1">NavigationType.kt</strong> and add the following code:<pre class="source-code">
sealed interface NavigationType {
    object BottomNavigation : NavigationType
    object NavigationDrawer : NavigationType
    object NavigationRail : NavigationType
}</pre><p class="calibre4">We are using a sealed interface instead of a sealed class here. This is because we do not need to hold any state in our <code>NavigationType</code>. We also do not need to pass properties to any of the <code>NavigationTypes</code>. We have three options: <code>BottomNavigation</code>, <code>NavigationDrawer</code>, and <code>NavigationRail</code>. We will be using these options to change the navigation type depending on the screen size.</p></li> <li class="calibre15">Next, let us<a id="_idIndexMarker330" class="calibre3 pcalibre pcalibre1"/> create yet another sealed interface called <strong class="source-inline1">ContentType</strong>. This interface will be used to change the content display type depending on the screen size. Let us create a new file called <strong class="source-inline1">ContentType.kt</strong> still inside the <strong class="source-inline1">navigation</strong> package and add the following code:<pre class="source-code">
sealed interface ContentType {
    object List : ContentType
    object ListAndDetail : ContentType
}</pre><p class="calibre4">This <a id="_idIndexMarker331" class="calibre3 pcalibre pcalibre1"/>represents the two modes in which we can display our content depending on the screen size. We have the <code>List</code> mode, which displays the list of cats only. We also have the <code>ListAndDetail</code> mode, which displays the list of cats and the details of the selected cat side by side.</p></li> <li class="calibre15">Next, in our <strong class="source-inline1">Screens.kt</strong> file, we have to add a new destination screen called <strong class="source-inline1">FavoritesScreen</strong>. The final code for the file should look like this:<pre class="source-code">
sealed class Screens(val route: String) {
    object PetsScreen : Screens("pets")
    object PetDetailsScreen : Screens("petDetails")
    object FavoritePetsScreen : Screens("favoritePets")
}</pre><p class="calibre4">We now have three destinations for our app.</p></li> <li class="calibre15">Next, let us add the <strong class="source-inline1">WindowSize</strong> dependencies to the libraries section in the <strong class="source-inline1">libs.versions.toml</strong> file:<pre class="source-code">
compose-window-size = "androidx.compose.material3:material3-window-size-class:1.2.0-alpha07"
androidx-window = "androidx.window:window:1.1.0"</pre></li> <li class="calibre15">We also<a id="_idIndexMarker332" class="calibre3 pcalibre pcalibre1"/> need to add the dependencies to our app module’s <strong class="source-inline1">build.gradle.kts</strong> file:<pre class="source-code">
implementation(libs.compose.window.size)
implementation(libs.androidx.window)</pre><p class="calibre4">Do a Gradle sync to be able to add the dependencies to our project.</p></li> <li class="calibre15">Next, we <a id="_idIndexMarker333" class="calibre3 pcalibre pcalibre1"/>need to create the composables for <strong class="source-inline1">NavigationRail</strong>, <strong class="source-inline1">NavigationDrawer</strong>, and <strong class="source-inline1">BottomNavigation</strong>. Let us create a new file called <strong class="source-inline1">PetsNavigationRail.kt</strong> inside the <strong class="source-inline1">view</strong> package and add the following code:<pre class="source-code">
@Composable
fun PetsNavigationRail(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationRail(
        modifier = Modifier
            .fillMaxHeight()
    ) {
        NavigationRailItem(
            selected = false,
            onClick = onDrawerClicked,
            icon = {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Menu Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationRailItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="calibre4">In the preceding code, we created the <code>PetsNavigationRail()</code> composable, which has three parameters: <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>onDrawerClicked</code>. The first two are callbacks that will be used to navigate to the different screens. We use the <code>onDrawerClicked</code> callback to close or open the drawer when the user interacts <a id="_idIndexMarker334" class="calibre3 pcalibre pcalibre1"/>with it. At the top, we<a id="_idIndexMarker335" class="calibre3 pcalibre pcalibre1"/> have the <code>items</code> variable, which holds a list of all our screens, and the <code>selectedItem</code> variable, which holds the currently selected screen. We use the <code>NavigationRail</code> composable from the Material 3 library to display the navigation rail. To add items to <code>NavigationRail</code>, we use the <code>NavigationRailItem</code> composable. We pass in the selected state of the item, the <code>onClick</code> callback, and the icon to display.</p></li> <li class="calibre15">Next, let us create the <strong class="source-inline1">PetsBottomNavigationBar</strong> composable. Let us create a new file called <strong class="source-inline1">PetsBottomNavigationBar.kt</strong> inside the <strong class="source-inline1">view</strong> package and add the following code:<pre class="source-code">
@Composable
fun PetsBottomNavigationBar(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    NavigationBar(
        modifier = Modifier
            .fillMaxWidth(),
        containerColor = MaterialTheme.colorScheme.background
    ) {
        NavigationBarItem(
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationBarItem(
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="calibre4">The <code>PetsBottomNavigationBar</code> composable is similar to the<code> PetsNavigationRail</code> composable. The only difference is that we are using the <code>NavigationBar</code> composable instead of the <code>NavigationRail</code> composable. We have the home and favorite items. We use the <code>NavigationBarItem</code> composable to add items to <code>NavigationBar</code>. We pass in the<a id="_idIndexMarker336" class="calibre3 pcalibre pcalibre1"/> selected state of the item, the <code>onClick</code> callback, and the icon to display.</p></li> <li class="calibre15">Next, let<a id="_idIndexMarker337" class="calibre3 pcalibre pcalibre1"/> us create the <strong class="source-inline1">PetsNavigationDrawer</strong> composable. Let us create a new file called <strong class="source-inline1">PetsNavigationDrawer.kt</strong> inside the <strong class="source-inline1">view</strong> package and add the following code:<pre class="source-code">
@Composable
fun PetsNavigationDrawer(
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    onDrawerClicked: () -&gt; Unit = {}
) {
    val items = listOf(Screens.PetsScreen, Screens.FavoritePetsScreen)
    val selectedItem = remember { mutableStateOf(items[0]) }
    Column(
        modifier = Modifier
            .wrapContentWidth()
            .fillMaxHeight()
            .background(MaterialTheme.colorScheme.inverseOnSurface)
            .padding(16.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Chapter Seven",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary
            )
            IconButton(
                onClick = onDrawerClicked
            ) {
                Icon(
                    imageVector = Icons.Default.Menu,
                    contentDescription = "Navigation Drawer Icon"
                )
            }
        }
        NavigationDrawerItem(
            label = { Text(text = "Pets") },
            selected = selectedItem.value == Screens.PetsScreen,
            onClick = {
                onHomeClicked()
                selectedItem.value = Screens.PetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = "Home Icon"
                )
            }
        )
        NavigationDrawerItem(
            label = { Text(text = "Favorites") },
            selected = selectedItem.value == Screens.FavoritePetsScreen,
            onClick = {
                onFavoriteClicked()
                selectedItem.value = Screens.FavoritePetsScreen
            },
            icon = {
                Icon(
                    imageVector = Icons.Default.Favorite,
                    contentDescription = "Favorite Icon"
                )
            }
        )
    }
}</pre><p class="calibre4">We used the <code>NavigationDrawer</code> composable from the Material 3 library to display the navigation drawer. We used the <code>NavigationDrawerItem</code> composable to add items to <code>NavigationDrawer</code>. We passed in the label, the selected<a id="_idIndexMarker338" class="calibre3 pcalibre pcalibre1"/> state of the item, the <code>onClick</code> callback, and the icon to display.</p></li> <li class="calibre15">Since <a id="_idIndexMarker339" class="calibre3 pcalibre pcalibre1"/>our <strong class="source-inline1">PetsNavigationDrawer</strong>, <strong class="source-inline1">PetsNavigationRail</strong>, and <strong class="source-inline1">PetsBottomNavigationBar</strong> composables have <strong class="source-inline1">FavoritesScreen</strong>, let us create a new file called <strong class="source-inline1">FavoritePetsScreen.kt</strong> inside the view package and add the following code:<pre class="source-code">
@Composable
fun FavoritePetsScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Favorite Pets")
    }
}</pre><p class="calibre4">This is a simple composable that displays the text <code>"Favorite Pets"</code>. We will use this composable as the content of <code>FavoritesScreen</code>. We also need to refactor our <code>AppNavigation()</code> composable to make it ready to handle the different navigation and content types. The final modified composable should look like this:</p><pre class="source-code">@Composable
fun AppNavigation(
    contentType: ContentType,
    navHostController: NavHostController = rememberNavController()
) {
    NavHost(
        navController = navHostController,
        startDestination = Screens.PetsScreen.route
    ) {
        composable(Screens.PetsScreen.route) {
            PetsScreen(
                onPetClicked = { cat -&gt;
                    navHostController.navigate(
                        "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
                    )
                },
                contentType = contentType
            )
        }
        composable(
            route = "${Screens.PetDetailsScreen.route}/{cat}",
            arguments = listOf(
                navArgument("cat") {
                    type = NavType.StringType
                }
            )
        ) {
            PetDetailsScreen(
                onBackPressed = {
                    navHostController.popBackStack()
                },
                cat = Json.decodeFromString(it.arguments?.getString("cat") ?: "")
            )
        }
        composable(Screens.FavoritePetsScreen.route) {
            FavoritePetsScreen()
        }
    }
}</pre><p class="calibre4">Let’s <a id="_idIndexMarker340" class="calibre3 pcalibre pcalibre1"/>highlight<a id="_idIndexMarker341" class="calibre3 pcalibre pcalibre1"/> the changes:</p><ul class="calibre17"><li class="calibre15">Our <strong class="source-inline1">AppNavigation()</strong> composable now takes in a <strong class="source-inline1">contentType</strong> parameter of type <strong class="source-inline1">ContentType</strong>. This is the parameter we will use to change the content type depending on the screen size. We also pass in a <strong class="source-inline1">navHostController</strong> parameter of type <strong class="source-inline1">NavHostController</strong>. This is the parameter we will use to navigate to different screens in our app. Previously, <strong class="source-inline1">navHostController</strong> was created inside the <strong class="source-inline1">AppNavigation()</strong> composable. We have moved it to the call site so that we can be able to use the same <strong class="source-inline1">navHostController</strong> in different composables.</li><li class="calibre15">We have used the new <strong class="source-inline1">PetsScreen()</strong> composable, which takes in the <strong class="source-inline1">contentType</strong> parameter. Same as before, we still pass <strong class="source-inline1">onPetClicked</strong>, which navigates to <strong class="source-inline1">PetDetailsScreen</strong>. Previously, we were using the <strong class="source-inline1">PetList</strong> composable.</li><li class="calibre15">Lastly, we <a id="_idIndexMarker342" class="calibre3 pcalibre pcalibre1"/>have added our new <strong class="source-inline1">FavoritePetsScreen</strong> destination to the <strong class="source-inline1">NavHost</strong> composable.</li></ul></li> <li class="calibre15">Let us see<a id="_idIndexMarker343" class="calibre3 pcalibre pcalibre1"/> what the new update <strong class="source-inline1">PetsScreen</strong> composable looks like. Let us head over to the <strong class="source-inline1">PetsScreen.kt</strong> file and modify the composable as follows:<pre class="source-code">
@Composable
fun PetsScreen(
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    PetsScreenContent(
        modifier = Modifier
            .fillMaxSize(),
        onPetClicked = onPetClicked,
        contentType = contentType,
        petsUIState = petsUIState
    )
}</pre><p class="calibre4">We have added a new <code>contentType</code> parameter to the composable. We have also added a new <code>petsUIState</code> parameter. This is the UI state of <code>PetsScreen</code>. We will use this state to display the list of cats.</p></li> <li class="calibre15">Next, create<a id="_idIndexMarker344" class="calibre3 pcalibre pcalibre1"/> a new file <a id="_idIndexMarker345" class="calibre3 pcalibre pcalibre1"/>called <strong class="source-inline1">PetsScreenContent.kt</strong> and add the following code:<pre class="source-code">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState
) {
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            if (contentType == ContentType.List) {
                PetList(
                    onPetClicked = onPetClicked,
                    pets = petsUIState.pets,
                    modifier = Modifier
                        .fillMaxWidth()
                )
            } else {
                PetListAndDetails(
                    pets = petsUIState.pets
                )
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre><p class="calibre4">Let’s explain the preceding code:</p><ul class="calibre17"><li class="calibre15"><code>PetList</code> composable should look like this:</p><pre class="source-code">@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked
            )
        }
    }
}</pre><p class="calibre4">No major<a id="_idIndexMarker348" class="calibre3 pcalibre pcalibre1"/> changes here: we have just added the <code>pets</code> parameter. We use this parameter to display the list of cats in our <code>LazyColumn</code>. With this update, it is time to create the <code>PetListAndDetails</code> composable.</p></li> <li class="calibre15">Let us <a id="_idIndexMarker349" class="calibre3 pcalibre pcalibre1"/>create a new file called <strong class="source-inline1">PetListAndDetails.kt</strong> inside the view package and add the following code:<pre class="source-code">
@Composable
fun PetListAndDetails(pets: List&lt;Cat&gt;) {
    var currentPet by remember {
        mutableStateOf(pets.first())
    }
    Row(
        modifier = Modifier
            .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        PetList(
            onPetClicked = {
                currentPet = it
            },
            pets = pets,
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        )
        PetDetailsScreenContent(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
                .weight(1f),
            cat = currentPet
        )
    }
}</pre><p class="calibre4">This <a id="_idIndexMarker350" class="calibre3 pcalibre pcalibre1"/>composable has a <code>Row</code>, which has two items each with a weight of <code>1f</code>. We have used the updated <code>PetListComposable</code> and <code>PetDetailsScreenContent</code> that we created earlier. We have also added a <code>currentPet</code> variable, which holds the currently selected cat. We use this variable to display the details of the selected cat. We also use this variable to update <code>currentPet</code> when we click on a pet item in the list. Make sure you also update <code>PetDetailsScreenContent</code> to take in the new modifier parameter.</p><p class="calibre4">With the<a id="_idIndexMarker351" class="calibre3 pcalibre pcalibre1"/> modifications we have made, let us now create a new composable called <code>AppNavigationContent</code>, which has logic for displaying <code>NavigationRail</code> or <code>BottomNavigation</code> depending on <code>NavigationType</code>.</p></li> <li class="calibre15">Let us <a id="_idIndexMarker352" class="calibre3 pcalibre pcalibre1"/>create a new file called <strong class="source-inline1">AppNavigationContent.kt</strong> inside the navigation package and add the following code:<pre class="source-code">
@Composable
fun AppNavigationContent(
    contentType: ContentType,
    navigationType: NavigationType,
    onFavoriteClicked: () -&gt; Unit,
    onHomeClicked: () -&gt; Unit,
    navHostController: NavHostController,
    onDrawerClicked: () -&gt; Unit = {}
) {
    Row(
        modifier = Modifier
            .fillMaxSize(),
    ) {
        AnimatedVisibility(
            visible = navigationType == NavigationType.NavigationRail
        ) {
            PetsNavigationRail(
                onFavoriteClicked = onFavoriteClicked,
                onHomeClicked = onHomeClicked,
                onDrawerClicked = onDrawerClicked
            )
        }
        Scaffold(
            content = { paddingValues -&gt;
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                ) {
                    AppNavigation(
                        contentType = contentType,
                        navHostController = navHostController
                    )
                }
            },
            bottomBar = {
                AnimatedVisibility(
                    visible = navigationType == NavigationType.BottomNavigation
                ) {
                    PetsBottomNavigationBar(
                        onFavoriteClicked = onFavoriteClicked,
                        onHomeClicked = onHomeClicked
                    )
                }
            }
        )
    }
}</pre><p class="calibre4">Let’s <a id="_idIndexMarker353" class="calibre3 pcalibre pcalibre1"/>explain the preceding code:</p><ul class="calibre17"><li class="calibre15">The <strong class="source-inline1">AppNavigationContent</strong> composable takes a number of parameters. The <strong class="source-inline1">contentType </strong>parameter is used to display the content type. The <strong class="source-inline1">navigationType</strong> parameter is used to toggle the navigation options. <strong class="source-inline1">onFavoriteClicked</strong> and <strong class="source-inline1">onHomeClicked</strong> are callbacks that will be <a id="_idIndexMarker354" class="calibre3 pcalibre pcalibre1"/>used to navigate to the different screens. <strong class="source-inline1">navHostController</strong> is an object that manages navigation within the <strong class="source-inline1">NavHost</strong> <strong class="source-inline1">onDrawerClicked</strong> is used to close or open the drawer when the user interacts with it.</li><li class="calibre15">We have <strong class="source-inline1">Row</strong> as the root element. Inside <strong class="source-inline1">Row</strong>, we have an <strong class="source-inline1">AnimatedVisibility</strong> composable that displays the <strong class="source-inline1">PetsNavigationRail</strong> composable when <strong class="source-inline1">navigationType</strong> is <strong class="source-inline1">NavigationType</strong>.<strong class="source-inline1">NavigationRail</strong>. We have also added a <strong class="source-inline1">Scaffold</strong> composable. We have used the <strong class="source-inline1">AppNavigation</strong> composable as the content of <strong class="source-inline1">Scaffold</strong>, passing in <strong class="source-inline1">contentType</strong> and <strong class="source-inline1">navHostController</strong>. We have also used the <strong class="source-inline1">PetsBottomNavigationBar</strong> composable as the bottom bar of <strong class="source-inline1">Scaffold</strong>. We have used the <strong class="source-inline1">AnimatedVisibility</strong> composable to display the <strong class="source-inline1">PetsBottomNavigationBar</strong> composable when <strong class="source-inline1">navigationType</strong> is <strong class="source-inline1">NavigationType.BottomNavigation</strong>.</li></ul></li> <li class="calibre15">The last step<a id="_idIndexMarker355" class="calibre3 pcalibre pcalibre1"/> is to refactor the <strong class="source-inline1">MainActivity.kt</strong> file to use the new <strong class="source-inline1">AppNavigationContent</strong> composable. We will walk through the changes step by step. There<a id="_idIndexMarker356" class="calibre3 pcalibre pcalibre1"/> are several changes:<ol class="calibre18"><li class="upper-roman">To begin with, we need to observe the device’s foldable state. This will enable us to change the content type and navigation type. Let us create a new file called <strong class="source-inline1">DeviceFoldPosture.kt</strong> inside the <strong class="source-inline1">navigation</strong> package and add the following code:</li></ol><pre class="source-code">
sealed interface DeviceFoldPosture {
    data class BookPosture(val hingePosition: Rect) : DeviceFoldPosture
    data class SeparatingPosture(
        val hingePosition: Rect,
        val orientation: FoldingFeature.Orientation
    ) : DeviceFoldPosture
    object NormalPosture : DeviceFoldPosture
}
@OptIn(ExperimentalContracts::class)
fun isBookPosture(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.HALF_OPENED &amp;&amp;
            foldFeature.orientation == FoldingFeature.Orientation.VERTICAL
}
@OptIn(ExperimentalContracts::class)
fun isSeparating(foldFeature: FoldingFeature?): Boolean {
    contract { returns(true) implies (foldFeature != null) }
    return foldFeature?.state == FoldingFeature.State.FLAT &amp;&amp; foldFeature.isSeparating
}</pre><p class="calibre4">In the<a id="_idIndexMarker357" class="calibre3 pcalibre pcalibre1"/> preceding code, we have<a id="_idIndexMarker358" class="calibre3 pcalibre pcalibre1"/> a sealed interface that represents the different postures a foldable device can be in. We have <code>BookPosture</code>, which represents the posture when the device is in portrait orientation and its fold state is half opened. We have <code>SeparatingPosture</code>, which represents the posture when the fold or hinge device creates two logical display areas. We also have <code>NormalPosture</code>, which represents the posture when the device is not folded. We have two utility functions, <code>isBookPosture()</code> and <code>isSeparating()</code>, which are used to check the posture of the device. We will use these functions to check the posture of<a id="_idIndexMarker359" class="calibre3 pcalibre pcalibre1"/> the device and change the layout of the app depending on the posture.</p><ol class="calibre18"><li class="upper-roman" value="2">Let us head over to the <strong class="source-inline1">MainActivity.kt</strong> file and add the following code <a id="_idIndexMarker360" class="calibre3 pcalibre pcalibre1"/>before the <strong class="source-inline1">setContent</strong> block:</li></ol><pre class="source-code">val deviceFoldingPostureFlow = WindowInfoTracker.getOrCreate(this).windowLayoutInfo(this)
    .flowWithLifecycle(this.lifecycle)
    .map { layoutInfo -&gt;
        val foldingFeature =
            layoutInfo.displayFeatures
                .filterIsInstance&lt;FoldingFeature&gt;()
                .firstOrNull()
        when {
            isBookPosture(foldingFeature) -&gt;
                DeviceFoldPosture.BookPosture(foldingFeature.bounds)
            isSeparating(foldingFeature) -&gt;
                DeviceFoldPosture.SeparatingPosture(
                    foldingFeature.bounds,
                    foldingFeature.orientation
                )
            else -&gt; DeviceFoldPosture.NormalPosture
        }
    }
    .stateIn(
        scope = lifecycleScope,
        started = SharingStarted.Eagerly,
        initialValue = DeviceFoldPosture.NormalPosture
    )</pre><p class="calibre4">Here, we use <code>WindowInfoTracker</code> to get the window layout info. We use <code>flowWithLifecycle()</code> to make sure we only get the layout info when the activity is in <a id="_idIndexMarker361" class="calibre3 pcalibre pcalibre1"/>the correct life cycle state. We then use the <code>map</code> operator to map the layout <a id="_idIndexMarker362" class="calibre3 pcalibre pcalibre1"/>info to the different postures. We use the <code>stateIn()</code> operator, which converts a cold <code>Flow</code> into a hot <code>StateFlow</code> that is started in the given coroutine scope, sharing the most recently emitted value of device posture. We use <code>SharingStarted.Eagerly</code> to make sure we get the latest value of the posture when the activity is in the started state. We use the <code>initialValue</code> parameter to set the initial value of the posture to <code>DeviceFoldPosture.NormalPosture</code>. We will use this flow to observe the device’s posture and change the app’s layout depending on the posture.</p><ol class="calibre18"><li class="upper-roman" value="3">Next, inside our <strong class="source-inline1">setcontent</strong> block, we need to add the variables before the theme block:</li></ol><pre class="source-code">val devicePosture = deviceFoldingPostureFlow.collectAsStateWithLifecycle().value
val windowSizeClass = calculateWindowSizeClass(activity = this)
val scope = rememberCoroutineScope()
val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
val navController = rememberNavController()</pre><p class="calibre4">We have <a id="_idIndexMarker363" class="calibre3 pcalibre pcalibre1"/>added the <code>devicePosture</code> variable, which holds the posture of the device. We have also added the <code>windowSizeClass</code> variable, which holds the window size class of the device; the <code>scope</code> variable, which holds <code>CoroutineScope</code>; the <code>drawerState</code> variable, which holds the state of the drawer; and the <code>navController</code> variable, which holds <code>NavHostController</code>. We will use this variable to navigate to different screens in our app.</p><ol class="calibre18"><li class="upper-roman" value="4">Inside<a id="_idIndexMarker364" class="calibre3 pcalibre pcalibre1"/> our <strong class="source-inline1">ChapterSevenTheme</strong>, we need to add the following code:</li></ol><pre class="source-code">val navigationType: NavigationType
val contentType: ContentType
when (windowSizeClass.widthSizeClass) {
    WindowWidthSizeClass.Compact -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
    WindowWidthSizeClass.Medium -&gt; {
        navigationType = NavigationType.NavigationRail
        contentType = if (devicePosture is DeviceFoldPosture.BookPosture
            || devicePosture is DeviceFoldPosture.SeparatingPosture
        ) {
            ContentType.ListAndDetail
        } else {
            ContentType.List
        }
    }
    WindowWidthSizeClass.Expanded -&gt; {
        navigationType = if (devicePosture is DeviceFoldPosture.BookPosture) {
            NavigationType.NavigationRail
        } else {
            NavigationType.NavigationDrawer
        }
        contentType = ContentType.ListAndDetail
    }
    else -&gt; {
        navigationType = NavigationType.BottomNavigation
        contentType = ContentType.List
    }
}</pre><p class="calibre4">Here, we<a id="_idIndexMarker365" class="calibre3 pcalibre pcalibre1"/> have two <a id="_idIndexMarker366" class="calibre3 pcalibre pcalibre1"/>variables: <code>navigationType</code> and <code>contentType</code>. We use <code>windowSizeClass</code> to get the width of our device and, depending on the width size, we assign the values for our <code>navigationType</code> and <code>contentType</code> variables:</p><ul class="calibre17"><li class="calibre15">If the width size is <strong class="source-inline1">Compact</strong>, we use <strong class="source-inline1">BottomNavigation</strong> for <strong class="source-inline1">navigationType</strong> and <strong class="source-inline1">List</strong> for <strong class="source-inline1">contentType</strong>.</li><li class="calibre15">If the width size is <strong class="source-inline1">Medium</strong>, we use <strong class="source-inline1">NavigationRail</strong> for <strong class="source-inline1">navigationType</strong>. For <strong class="source-inline1">contentType</strong>, we check <strong class="source-inline1">devicePosture</strong>. If <strong class="source-inline1">devicePosture</strong> is <strong class="source-inline1">DeviceFoldPosture.BookPosture</strong> or <strong class="source-inline1">DeviceFoldPosture.SeparatingPosture</strong>, we use <strong class="source-inline1">ListAndDetail</strong> for <strong class="source-inline1">contentType</strong>. If <strong class="source-inline1">devicePosture</strong> is not <strong class="source-inline1">DeviceFoldPosture.BookPosture</strong> or <strong class="source-inline1">DeviceFoldPosture.SeparatingPosture</strong>, we use <strong class="source-inline1">List</strong> for <strong class="source-inline1">contentType</strong>.</li><li class="calibre15">If the <a id="_idIndexMarker367" class="calibre3 pcalibre pcalibre1"/>width size is <strong class="source-inline1">Expanded</strong>, we check <strong class="source-inline1">devicePosture</strong>. If <strong class="source-inline1">devicePosture</strong> is <strong class="source-inline1">DeviceFoldPosture.BookPosture</strong>, we use <strong class="source-inline1">NavigationRail</strong> for <strong class="source-inline1">navigationType</strong>. If <strong class="source-inline1">devicePosture</strong> is not <strong class="source-inline1">DeviceFoldPosture.BookPosture</strong>, we use <strong class="source-inline1">NavigationDrawer</strong> for <strong class="source-inline1">navigationType</strong>. We use <strong class="source-inline1">ListAndDetail</strong> for <strong class="source-inline1">contentType</strong>.</li><li class="calibre15">Lastly, if the width size is anything else, we use <strong class="source-inline1">BottomNavigation</strong> for <strong class="source-inline1">navigationType</strong> and <strong class="source-inline1">List</strong> for <strong class="source-inline1">contentType</strong>.</li></ul><ol class="calibre18"><li class="upper-roman" value="5">Below <a id="_idIndexMarker368" class="calibre3 pcalibre pcalibre1"/>the preceding code, add this <strong class="source-inline1">if</strong> statement:</li></ol><pre class="source-code">if (navigationType == NavigationType.NavigationDrawer) {
    PermanentNavigationDrawer(
        drawerContent = {
            PermanentDrawerSheet {
                PetsNavigationDrawer(
                    onFavoriteClicked = {
                        navController.navigate(Screens.FavoritePetsScreen.route)
                    },
                    onHomeClicked = {
                        navController.navigate(Screens.PetsScreen.route)
                    }
                )
            }
        }
    ) {
        AppNavigationContent(
            navigationType = navigationType,
            contentType = contentType,
            onFavoriteClicked = {
                navController.navigate(Screens.FavoritePetsScreen.route)
            },
            onHomeClicked = {
                navController.navigate(Screens.PetsScreen.route)
            },
            navHostController = navController
        )
    }
}</pre><p class="calibre4">The <a id="_idIndexMarker369" class="calibre3 pcalibre pcalibre1"/>condition checks whether <code>navigationType</code> is <code>NavigationType.NavigationDrawer</code>. If it is, we use the <code>PermanentNavigationDrawer</code> composable from the Material 3 library. We use the <code>PetsNavigationDrawer</code> composable that we created for <code>drawerContent</code>. We use the <code>AppNavigationContent</code> composable as the content of <code>PermanentNavigationDrawer</code>. We pass in the <code>navigationType</code>, <code>contentType</code>, <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>navHostController</code> parameters.</p><ol class="calibre18"><li class="upper-roman" value="6">Next, let <a id="_idIndexMarker370" class="calibre3 pcalibre pcalibre1"/>us add the <strong class="source-inline1">else</strong> condition for our <strong class="source-inline1">if</strong> statement:</li></ol><pre class="source-code">else {
  ModalNavigationDrawer(
      drawerContent = {
          ModalDrawerSheet {
              PetsNavigationDrawer(
                  onFavoriteClicked = {
                      navController.navigate(Screens.FavoritePetsScreen.route)
                  },
                  onHomeClicked = {
                      navController.navigate(Screens.PetsScreen.route)
                  },
                  onDrawerClicked = {
                      scope.launch {
                          drawerState.close()
                      }
                  }
              )
          }
      },
      drawerState = drawerState
  ) {
      AppNavigationContent(
          navigationType = navigationType,
          contentType = contentType,
          onFavoriteClicked = {
              navController.navigate(Screens.FavoritePetsScreen.route)
          },
          onHomeClicked = {
              navController.navigate(Screens.PetsScreen.route)
          },
          navHostController = navController,
          onDrawerClicked = {
              scope.launch {
                  drawerState.open()
              }
          }
      )
  }
}</pre><p class="calibre4">Here, when <code>navigationType</code> is not <code>NavigationType.NavigationDrawer</code>, we use the <code>ModalNavigationDrawer</code> composable from the Material 3 library. We use the <code>PetsNavigationDrawer</code> composable for <code>drawerContent</code>. We use the <code>AppNavigationContent</code> composable as the content of <code>ModalNavigationDrawer</code>. We pass in the <code>navigationType</code>,<code> contentType</code>, <code>onFavoriteClicked</code>, <code>onHomeClicked</code>, and <code>navHostController</code> parameters. We also pass in the <code>drawerState</code> parameter. We use the <code>onDrawerClicked</code> callback to open or close the drawer when the user interacts with it.</p></li> </ol>
<p class="calibre4">Those <a id="_idIndexMarker371" class="calibre3 pcalibre pcalibre1"/>were a<a id="_idIndexMarker372" class="calibre3 pcalibre pcalibre1"/> lot of changes; great work on adding them! We now need to run these changes and see them into action. Luckily, we have a <strong class="bold">resizable emulator</strong> to help test these changes. We will be creating one and testing the app in the next subsection.</p>
<h2 id="_idParaDest-90" class="calibre7"><a id="_idTextAnchor099" class="calibre3 pcalibre pcalibre1"/>Creating and using the resizable emulator</h2>
<p class="calibre4">To create and <a id="_idIndexMarker373" class="calibre3 pcalibre pcalibre1"/>use the resizable emulator, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="bold">Device Manager</strong> window<a id="_idIndexMarker374" class="calibre3 pcalibre pcalibre1"/> from the right sidebar in Android Studio. If you cannot find it there, use the <strong class="bold">View</strong> menu option at the top and select <strong class="bold">Tool Windows</strong>; then, you will see the <strong class="bold">Device </strong><strong class="bold">Manager</strong> option.</li>
</ol>
<div><div><img alt="Figure 7.5 – Device Manager" src="img/B19779_07_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Device Manager</p>
<ol class="calibre14">
<li value="2" class="calibre15">Select <a id="_idIndexMarker375" class="calibre3 pcalibre pcalibre1"/>the <strong class="bold">Virtual</strong> devices tab and click on <strong class="bold">Create Device</strong>, which brings you this pop-up window:</li>
</ol>
<div><div><img alt="Figure 7.6 – New device configurations" src="img/B19779_07_06.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.6 – New device configurations</p>
<p class="calibre4">The window enables you to customize the properties of the device you want to create. You can change the device category and you also select the device you want to create.</p>
<ol class="calibre14">
<li value="3" class="calibre15">Let us <a id="_idIndexMarker376" class="calibre3 pcalibre pcalibre1"/>select the <strong class="bold">Resizable (Experimental)</strong> option under the <strong class="bold">Phone</strong> category. This will enable us to create a resizable device. Click <strong class="bold">Next</strong> and you will see the following window:</li>
</ol>
<div><div><img alt="Figure 7.7 – System Image" src="img/B19779_07_07.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.7 – System Image</p>
<ol class="calibre14">
<li value="4" class="calibre15">Here, you select the system image you want to use. Let us select the <strong class="bold">API 34</strong> system image. Click <strong class="bold">Next</strong> and you will see the following window:</li>
</ol>
<div><div><img alt="Figure 7.8 – Device information" src="img/B19779_07_08.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Device information</p>
<p class="calibre4">This is the <a id="_idIndexMarker377" class="calibre3 pcalibre pcalibre1"/>last step where you confirm the device name and the device orientation. We will maintain the name generated and use portrait as the default orientation.</p>
<ol class="calibre14">
<li value="5" class="calibre15">Click <strong class="bold">Finish</strong> and you will see the device has been added to your list of devices:</li>
</ol>
<div><div><img alt="Figure 7.9 – Devices list" src="img/B19779_07_09.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Devices list</p>
<ol class="calibre14">
<li value="6" class="calibre15">Start the emulator and run the app.</li>
</ol>
<div><div><img alt="Figure 7.10 – Resizable emulator" src="img/B19779_07_10.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Resizable emulator</p>
<p class="calibre4">From the emulator, we<a id="_idIndexMarker378" class="calibre3 pcalibre pcalibre1"/> can see we have two options highlighted. The first one allows us to change the device from a small/normal device to a foldable or tablet device. The second one allows us to change the options when we change to a foldable device. Let us change the device to a foldable device. The app now changes the navigation option to navigation rail and the screen has a list and details of the first cat opened too.</p>
<div><div><img alt="Figure 7.11 – Foldable device navigation rail" src="img/B19779_07_11.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Foldable device navigation rail</p>
<p class="calibre4">On tapping the <strong class="bold">Foldable</strong> options, we <a id="_idIndexMarker379" class="calibre3 pcalibre pcalibre1"/>can see the following options:</p>
<div><div><img alt="Figure 7.12 – Foldable options" src="img/B19779_07_12.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Foldable options</p>
<p class="calibre4">Selecting the<a id="_idIndexMarker380" class="calibre3 pcalibre pcalibre1"/> second option in the foldables section brings us to the following screen:</p>
<div><div><img alt="Figure 7.13 – Foldable device" src="img/B19779_07_13.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Foldable device</p>
<p class="calibre4">From the<a id="_idIndexMarker381" class="calibre3 pcalibre pcalibre1"/> device size option, we can also switch to tablet view:</p>
<div><div><img alt="Figure 7.14 – Tablet view" src="img/B19779_07_14.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Tablet view</p>
<p class="calibre4">You can see<a id="_idIndexMarker382" class="calibre3 pcalibre pcalibre1"/> the app now has a permanent navigation drawer and the screen has a list and details of the first cat opened too. Tap a different cat and you will see the details of the cat displayed on the right side of the screen. We can also navigate to the <strong class="bold">Favorites</strong> screen and back to the <strong class="bold">Pets</strong> screen.</p>
<div><div><img alt="Figure 7.15 – Favorite Pets screen" src="img/B19779_07_15.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Favorite Pets screen</p>
<p class="calibre4">We can also see <a id="_idIndexMarker383" class="calibre3 pcalibre pcalibre1"/>the modal navigation drawer:</p>
<div><div><img alt="Figure 7.16 – Modal navigation drawer" src="img/B19779_07_16.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Modal navigation drawer</p>
<p class="calibre4">The resizable emulator<a id="_idIndexMarker384" class="calibre3 pcalibre pcalibre1"/> is a great way for us to test our app across different device sizes, but it has its own limitations. The following are the limitations of resizable emulators:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Hinge simulation</strong>: While <a id="_idIndexMarker385" class="calibre3 pcalibre pcalibre1"/>resizable emulators offer multi-window support and simulate various orientations, they might not accurately replicate the behavior of a physical hinge on foldable devices. The hinge’s physical characteristics and behavior may affect app layouts and interactions differently.</li>
<li class="calibre15"><strong class="bold">Hardware specifics</strong>: Emulators lack physical hardware components present in foldable devices, such as the actual hinge mechanism, flexible displays, sensors, and proprietary features, impacting the true emulation of foldable device behavior.</li>
<li class="calibre15"><strong class="bold">Performance variation</strong>: Emulators<a id="_idIndexMarker386" class="calibre3 pcalibre pcalibre1"/> may not accurately represent the performance capabilities of real foldable devices, especially in terms of hardware-specific optimizations and performance characteristics.</li>
<li class="calibre15"><strong class="bold">Real-world testing environment</strong>: Foldable devices may have unique environmental factors that impact user experience, such as external lighting conditions affecting the flexible display. Emulators may not replicate these real-world scenarios accurately.</li>
<li class="calibre15"><strong class="bold">Software emulation versus hardware interaction</strong>: Certain foldable device behaviors, such as drag-and-drop interactions across screens or unique gestures, might not be fully emulated in software due to hardware-specific interactions.</li>
</ul>
<p class="calibre4">We have learned how to handle navigation in foldable devices and large screens and how to provide a great user experience as the user is switching between the different screen sizes. This ensures that our app is responsive to different devices and that we satisfactorily use the available screen sizes. The team at Google has published stories of companies that support large screens and foldables; you can have a look here: <a href="https://developer.android.com/large-screens/stories" class="calibre3 pcalibre pcalibre1">https://developer.android.com/large-screens/stories</a>.</p>
<h1 id="_idParaDest-91" class="calibre6"><a id="_idTextAnchor100" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we have learned how to use the Jetpack Compose Navigation library to navigate to different Jetpack Compose screens within our app. We have also learned tips and best practices for using this library. Additionally, we have covered how to pass arguments as we navigate to screens. Lastly, we have built on what we learned in <a href="B19779_04.xhtml#_idTextAnchor055" class="calibre3 pcalibre pcalibre1"><em class="italic">Chapter 4</em></a>, by handling navigation in large screens and foldables in detail.</p>
<p class="calibre4">We have created <code>FavoritePetsScreen</code>, but as of now it only has a <code>Text</code> label. In the next chapter, we will be adding functionality to persist data locally and retrieve that data locally too without any internet access. We will learn how to save our cute cat photos to Room, another Jetpack library for offline storage, and also add pets to our favorites list.</p>
</div>
</body></html>