<html><head></head><body><div><div><div><h1 id="_idParaDest-118" class="chapter-number"><a id="_idTextAnchor135"/>11</h1>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor136"/>Enhancing Code Quality</h1>
			<p>As we develop our Android apps, we must ensure that the code we write complies with the set rules and follows the best practices. This not only helps us to write good code but also makes it easier to maintain and easily onboard others to the code base.</p>
			<p>In this chapter, we will learn about the Kotlin style and the best practices for writing Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to format, lint, and detect the code smells early.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Mastering Kotlin style and best practices</li>
				<li>Using Ktlint for static analysis</li>
				<li>Detecting code smells with Detekt</li>
			</ul>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor137"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven</a></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor138"/>Mastering Kotlin style and best practices</h1>
			<p>As we learned in <a href="B19779_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, Kotlin is a very concise and static language. As such, it is easier for us as developers to not follow some of the recommended practices. This leads to a lot of code smells and <a id="_idIndexMarker544"/>technical debt. A <strong class="bold">code smell</strong> is a pattern or practice that might indicate a deeper <a id="_idIndexMarker545"/>problem within the code. It indicates that the code might lead to potential problems or hinder maintainability. On the other hand, <strong class="bold">technical debt</strong> refers to the cost or consequences of choosing quick and suboptimal <a id="_idIndexMarker546"/>solutions in development to meet immediate needs rather than developing robust and maintainable solutions. We always have to come back later to such solutions to refactor them to be more scalable and maintainable. Let us start by learning about some of the best practices and how to avoid them.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/>Coding conventions</h2>
			<p>Kotlin has a wide variety<a id="_idIndexMarker547"/> of coding conventions that cover everything from naming conventions to formatting. Following these conventions makes it easier to read our code and makes it maintainable. Examples of these are the following:</p>
			<ul>
				<li>Variable names should be in <strong class="bold">camelCase</strong></li>
				<li>Class names should be in <strong class="bold">PascalCase</strong></li>
				<li>Constants should be in <strong class="bold">UPPERCASE</strong></li>
				<li>Functions should be in <strong class="bold">camelCase</strong></li>
				<li>Functions with multiple words should be separated by <strong class="bold">underscores</strong></li>
				<li>Functions with a single expression should be <strong class="bold">inlined</strong></li>
			</ul>
			<p>Kotlin offers a lot of coding conventions. You can find them at <a href="https://kotlinlang.org/docs/coding-conventions.html">https://kotlinlang.org/docs/coding-conventions.html</a>.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/>Null safety</h2>
			<p>As discussed<a id="_idIndexMarker548"/> extensively in <a href="B19779_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, Kotlin has a very strong <code>null</code>. When working with nullable types, it is recommended that we use the safe call operator (<code>?.</code>) and the Elvis operator (<code>?:</code>) to avoid null pointer exceptions. We should also use the <code>let</code> function to perform operations on nullable types. We should also use the safe cast operator (<code>as?</code>) to avoid class cast exceptions. An example is shown in the following snippet:</p>
			<pre class="source-code">
val name: String? = null
name?.let {
  println(it)
}</pre>			<p>In the preceding <a id="_idIndexMarker549"/>example, we declared a <code>name</code> variable of the <code>String</code> type and assigned it <code>null</code>. Then, we used the <code>let</code> function to check whether the variable is <code>null</code> or not. If the variable is not <code>null</code>, then the <code>println(it)</code> function will print the value of the variable.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/>Data classes</h2>
			<p>Kotlin makes it <a id="_idIndexMarker550"/>easy for us to create <code>equals</code>, <code>hashCode</code>, <code>toString</code>, and <code>copy</code> functions. We should use data classes when we need to hold data:</p>
			<pre class="source-code">
data class Person(val name: String, val age: Int)</pre>			<p>In the preceding example, we created a <code>Person</code> data class with two properties: <code>name</code> (which is a <code>String</code> type) and <code>age</code> (which is an <code>Int</code> type).</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/>Extensions functions</h2>
			<p>Kotlin provides <strong class="bold">extension functions</strong>, which allow us to add new functions to new classes without having to<a id="_idIndexMarker551"/> inherit from them. This will help us avoid creating utility classes. While extension functions are powerful, overuse or inappropriate use can lead to code that is hard to read and maintain. An example is shown in the following code block:</p>
			<pre class="source-code">
fun String.removeFirstAndLastChar(): String {
  return when {
  this.length &lt;= 1 -&gt; ""
  else -&gt; this.substring(1, this.length - 1)
  }
}
// Example usage
fun main(args: Array&lt;String&gt;) {
  val myString = "Hello Everyone"
  val result = myString.removeFirstAndLastChar ()
  println(result)
}</pre>			<p>In the preceding example, we created an extension function on the <code>String</code> class. The function removes the first and last character of the string and returns the remaining string. Additionally, we used the <code>when</code> expression to check whether the length of the string is less than or equal to <code>1</code>. If the length is less than or equal to <code>1</code>, then the function returns an empty<a id="_idIndexMarker552"/> string. Otherwise, it returns the substring of the string from index 1 to the length of the string – <code>1</code>. We used the extension function in the <code>main</code> function to remove the first and last character of the <code>"Hello Everyone"</code> string. The result is then printed to the console as follows:</p>
			<pre class="console">
ello Everyon</pre>			<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/>Type inference</h2>
			<p>Kotlin has a very strong type system. As such, we can omit specifying the type of a variable and let the <a id="_idIndexMarker553"/>compiler infer the type. This will help us avoid a lot of boilerplate code. Here is an example:</p>
			<pre class="source-code">
val name = "John Doe" // Compiler infers that name is of type String
val age = 25 // Compiler infers that age is of type Int</pre>			<h2 id="_idParaDest-127"><a id="_idTextAnchor144"/>Collections</h2>
			<p>Kotlin has a rich <code>List</code>, <code>Set</code>, <code>Map</code>, <code>Array</code>, and <code>Sequence</code> as collection types available in Kotlin. Collections <a id="_idIndexMarker554"/>can either be <code>mutable</code> or <code>immutable</code>. A <code>mutable</code> collection can be modified after creation, while an <code>immutable</code> collection cannot be modified after creation. An example of a <code>mutable</code> list is as follows:</p>
			<pre class="source-code">
val mutableList = mutableListOf("Kotlin", "Java", "Python")
mutableList.add("Swift")</pre>			<p>In the preceding example, we created a <code>mutable</code> list of strings. We used the <code>mutableListOf</code> function to create the list. We then added a new string to the list using the <code>add</code> function. An example of an <code>immutable</code> list is as follows:</p>
			<pre class="source-code">
val immutableList = listOf("Kotlin", "Java", "Python")</pre>			<p>In the preceding example, we created an <code>immutable</code> list of strings. We used the <code>listOf</code> function to create the list. We cannot add or remove items from the list after creation. We can only read items from the list. Kotlin collections also have a wide variety of functions that can be used to perform operations on collections. We should use these functions instead of writing our own functions. This helps us make our code concise and readable. Let us see the following example of creating a list and filtering odd and even numbers:</p>
			<pre class="source-code">
val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val evenNumbers = numbers.filter { it % 2 == 0 }
val oddNumbers = numbers.filter { it % 2 != 0 }</pre>			<p>In the preceding example, we created a list of numbers. We then used the <code>filter</code> function to filter even and odd numbers. The <code>filter</code> function takes a lambda as an argument. The lambda is used to filter the numbers. The <code>filter</code> function returns a new list with the filtered numbers. We used the <code>it</code> keyword to refer to the current item in the list. We then used the <code>%</code> operator to check whether the number is even or odd. If the number is even, then the <code>filter</code> function returns <code>true</code> and the number is added to the <code>evenNumbers</code> variable. For odd numbers, the <code>filter</code> function returns <code>false</code> and the number is added to the <code>oddNumbers</code> variable. Kotlin collections also have functions such as <code>map</code>, <code>reduce</code>, <code>fold</code>, <code>flatMap</code>, and so on. We should use these functions instead of<a id="_idIndexMarker555"/> writing our own functions. This helps us make our code concise and readable.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor145"/>Sealed classes and interfaces</h2>
			<p>Kotlin provides <strong class="bold">sealed classes</strong>, which are used to represent restricted class and interface hierarchies. This improves code <a id="_idIndexMarker556"/>readability and ensures that we know all the possible subclasses of a class. Here’s an example of a sealed class:</p>
			<pre class="source-code">
sealed class Shape {
  class Circle(val radius: Double) : Shape()
  class Square(val length: Double) : Shape()
  class Rectangle(val length: Double, val breadth: Double) : Shape()
}</pre>			<p>In the preceding example, we created a sealed class called <code>Shape</code>. We then created three classes (<code>Circle</code>, <code>Square</code>, and <code>Rectangle</code>), which are subclasses of the <code>Shape</code> class. The <code>Shape</code> class can only be extended in the same file where it is declared. We cannot extend the <code>Shape</code> class in another file<a id="_idTextAnchor146"/>.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor147"/>Formatting</h2>
			<p>We use four spaces <a id="_idIndexMarker557"/>for indentation in Kotlin. However, note that this is a convention and not a strict rule. We should always ensure that our code is properly formatted as per the conventions agreed upon by the team or company</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor148"/>Functional programming</h2>
			<p>We should take<a id="_idIndexMarker558"/> advantage of Kotlin <strong class="bold">functional programming</strong> features<a id="_idIndexMarker559"/> such as <strong class="bold">lambdas</strong>, <strong class="bold">higher-order functions</strong>, and <strong class="bold">inline functions</strong>. This will help us make our code more<a id="_idIndexMarker560"/> concise and<a id="_idIndexMarker561"/> readable. An <a id="_idIndexMarker562"/>example is shown in the following code block:</p>
			<pre class="source-code">
val total = numbers.reduce { sum, element -&gt; sum + element }</pre>			<h2 id="_idParaDest-131"><a id="_idTextAnchor149"/>Coroutines</h2>
			<p>Kotlin provides <strong class="bold">coroutines</strong>, which are used to perform asynchronous operations. They are very lightweight and easy to use and help <a id="_idIndexMarker563"/>us avoid callback hell. We should use coroutines when we need to <a id="_idIndexMarker564"/>perform asynchronous operations. An example of a coroutine in Kotlin is as shown here:</p>
			<pre class="source-code">
fun makeNetworkCall() {
  viewModelScope.launch {
    val result = async {
    // perform network call
    }
    // update UI
  }
}</pre>			<p>In the preceding example, we used <code>viewModelScope</code> to launch a coroutine. This is to ensure that the coroutine is canceled when the view model is destroyed. We used the <code>launch</code> coroutine builder to create a new coroutine. Inside the <code>launch</code> lambda, we performed our network call, which is supposed to happen in the background. We used the <code>async</code> coroutine builder, which allows us to await the result of the network call. The <code>async</code> coroutine builder returns a <code>Deferred</code> object. Lastly, we updated the UI with the result of the network call.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor150"/>The when statements</h2>
			<p>Kotlin provides <code>when</code> statements, which <a id="_idIndexMarker565"/>are used to replace <code>switch</code> statements. We<a id="_idIndexMarker566"/> should use <code>when</code> statements when we need to perform conditional operations. If we have blocks with more than one <code>if</code> <code>else</code> statement, we should consider using <code>when</code> statements. An example is shown in the following code:</p>
			<pre class="source-code">
val number = when {
  x % 2 == 0 -&gt; "Even"
  x % 2 != 0 -&gt; "Odd"
  else -&gt; "Invalid"
}</pre>			<h2 id="_idParaDest-133"><a id="_idTextAnchor151"/>Classes and functions</h2>
			<ul>
				<li>Kotlin allows us to declare multiple classes in a single file. We should use this feature to avoid creating a<a id="_idIndexMarker567"/> lot of files, especially for classes that are closely related. We should, however, be keen not to have bloated files with a lot of classes, so we should use this feature with caution.</li>
				<li>We have to ensure that<a id="_idIndexMarker568"/> we define only one <strong class="bold">primary constructor</strong> per class. Instead of overloading the constructor with a second one, we can always consider using default values for the constructor parameters.</li>
				<li>We can use <strong class="bold">companion objects</strong> to create static<a id="_idIndexMarker569"/> members. Both Kotlin’s companion <a id="_idIndexMarker570"/>objects and Java’s <strong class="bold">static members</strong> facilitate the creation of class-level members that can be accessed without creating an instance of the class. However, Kotlin’s companion objects provide additional flexibility by allowing access to non-static members and offer a more expressive syntax.</li>
				<li>We should always avoid returning <code>null</code> from functions. Instead, we should use nullable types.</li>
				<li>We can always use <strong class="bold">scope functions</strong> to perform operations on objects. This will help us avoid creating a lot<a id="_idIndexMarker571"/> of temporary variables.</li>
			</ul>
			<p>This is just a small list of best practices. As the code base grows, it’s hard at times to keep track of all the best practices. This is where static code analysis tools come in handy. They help us identify code smells and technical debt. They also help us identify bugs and security vulnerabilities. In the next section, we will learn about some of the static code analysis tools that we can use to improve the quality of our code.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor152"/>Using Ktlint for static analysis</h1>
			<p>According to the official documentation, ktlint is “<em class="italic">an anti-bikeshedding Kotlin linter with a built-in formatter</em>.” It helps us do <code>gradle</code> tasks that allow us to run <code>ktlint</code> on our project. We are also able to do auto-formatting.</p>
			<p>To set up Ktlint in our project, we need to add the Ktlint plugin to our project’s <code>build.gradle.kts</code> file in the plugins block, as follows:</p>
			<pre class="source-code">
id("org.jlleitschuh.gradle.ktlint") version "11.6.1"</pre>			<p>Tap the <code>build.gradle.kts</code> file below the plugins block:</p>
			<pre class="source-code">
subprojects {
    apply(plugin = "org.jlleitschuh.gradle.ktlint")
    ktlint {
        verbose.set(true)
        android.set(true)
        filter {
            exclude("**/generated/**")
        }
    }
}</pre>			<p>This will apply the plugin to all the project modules. Tap the <code>ktlint</code> block. In our case, we are setting the <code>verbose</code> and <code>android</code> properties to <code>true</code>. We are also excluding the <code>generated</code> folder from the analysis.</p>
			<p>With that, we are ready to use Ktlint. First, though, let’s disable some formatting options. To do this, we need to<a id="_idIndexMarker575"/> create an <code>.editorconfig</code> file in the root of our project. In the file, we add the following code:</p>
			<pre class="source-code">
root = true
[*]
charset = utf-8
insert_final_newline = false
trim_trailing_whitespace = true
[*.{kt,kts}]
indent_size = 4
ij_kotlin_packages_to_use_import_on_demand = unset
ij_kotlin_name_count_to_use_star_import = 999
ij_kotlin_name_count_to_use_star_import_for_members = 999</pre>			<p>This disables some formatting options, the key one being <code>insert_final_newline</code> at the end of each file. This is especially useful for existing projects as it prevents us from having to reformat the whole project. If you need to customize Ktlint behavior, this is the file you use to enable or disable some options.</p>
			<p>Let us now run the <code>ktlintCheck</code> task. To do this, let us open the <strong class="bold">Terminal</strong> tab in our IDE and run the following command:</p>
			<pre class="console">
./gradlew ktlintCheck</pre>			<p>After the task completes, we <a id="_idIndexMarker576"/>will see the following output:</p>
			<div><div><img src="img/B19779_11_01.jpg" alt="Figure 11.1 – Ktlint check failure" width="1089" height="701"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Ktlint check failure</p>
			<div><div><img src="img/B19779_11_02.jpg" alt="Figure 11.2 – Ktlint check failure continued" width="1090" height="702"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Ktlint check failure continued</p>
			<p>From the preceding figures, we can <a id="_idIndexMarker577"/>see that the task was completed with failures, which means our project is not correctly formatted. The output also shows the specific formatting error and the file. We can see indentation, formatting, and new lines issues. We can opt to fix the issues by ourselves but, first, we should always check whether the Ktlint formatter can fix the <a id="_idIndexMarker578"/>issues for us. To do this, we can run the following command:</p>
			<pre class="console">
./gradlew ktlintFormat</pre>			<p>This will run the <code>ktlintFormat</code> task. After the task is completed, we will see the following output:</p>
			<div><div><img src="img/B19779_11_03.jpg" alt="Figure 11.3 – ktlintFormat successful" width="479" height="110"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – ktlintFormat successful</p>
			<p>As seen in the preceding<a id="_idIndexMarker579"/> figure, the task was completed successfully. This means the Ktlint formatter was able to fix the issues for us. If the Ktlint formatter is not able to fix the issues, it normally highlights the issues that the plugin is not able to fix and shows the file and line number. We can then fix the issues manually. For now, we don’t have such issues. We can now run the <code>ktlintCheck</code> task again to confirm that the issues have been fixed. After the task completes, we will see the following output:</p>
			<div><div><img src="img/B19779_11_04.jpg" alt="Figure 11.4 – ktlintFormat successful" width="481" height="110"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – ktlintFormat successful</p>
			<p>As seen in the preceding figure, the build was successful. This means our project is correctly formatted. By using the Git tool in our IDE by pressing <em class="italic">Command</em> + <em class="italic">K</em> on macOS and <em class="italic">Ctrl</em> + <em class="italic">K</em> on Windows, we can see the files that have changes and see the changes made by the Ktlint <a id="_idIndexMarker580"/>formatter. From our project, this is what the commit modal looks like:</p>
			<div><div><img src="img/B19779_11_05.jpg" alt="Figure 11.5 – Git commit modal" width="640" height="770"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Git commit modal</p>
			<p>As shown in <em class="italic">Figure 11</em><em class="italic">.5</em>, the <code>ktlintFormat</code> command has made a bunch of changes to our files. We can check each file for <a id="_idIndexMarker581"/>changes too. The formatter is a good tool to help us quickly format our code according to the Kotlin style and conventions. The <code>ktlintFormat</code> and <code>ktlintCheck</code> commands are the ones to run after you complete your changes before you commit your code. This will help you avoid committing code that is not formatted correctly.</p>
			<p>We have done a basic setup, which is sufficient for most projects. For more information, you can learn more about the plugin, the rules available, and how to customize it here: <a href="https://github.com/jlleitschuh/ktlint-gradle">https://github.com/jlleitschuh/ktlint-gradle</a>.</p>
			<p>We have seen how to<a id="_idIndexMarker582"/> use the Ktlint plugin to format and perform static<a id="_idIndexMarker583"/> analysis of our code. In the next section, we will learn how to use the detekt plugin to check for code smells and technical debt in our code.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor153"/>Detecting code smells with detekt</h1>
			<p>detekt is another static<a id="_idIndexMarker584"/> code analysis tool for Kotlin. It helps us identify problems early and keep the technical debt low throughout the development process. It enforces a set of rules that help us avoid code smells and technical debt. It also gives us the flexibility to create our own custom rule sets. Detekt offers the following features:</p>
			<ul>
				<li>It identifies code smell for Kotlin projects</li>
				<li>It’s easily configurable and customizable to suit our needs</li>
				<li>We can always suppress the warnings if we feel they are not applicable</li>
				<li>We can specify the code smell thresholds that we want to enforce</li>
			</ul>
			<p>We will be using these features in our project. But before that, let us understand the rule sets. detekt has several rule sets that check the compliance of your code with the Kotlin style guide. The available rule sets are as follows:</p>
			<ul>
				<li><strong class="bold">Comments</strong>: This rule set provides rules that address issues in comments and the documentation of the code. It checks header files, comments on private methods, and undocumented classes, properties, or methods.</li>
				<li><strong class="bold">Complexity</strong>: This rule set contains rules that report complex code. It checks for complex conditions, methods, expressions, and classes, as well as long methods and long parameter lists.</li>
				<li><strong class="bold">Coroutines</strong>: This rule set analyzes code for potential coroutine problems.</li>
				<li><code>catch</code> blocks, empty class blocks, and empty function and conditional function blocks.</li>
				<li><strong class="bold">Exceptions</strong>: This rule set reports issues related to how code throws and handles exceptions. For example, it has rules for if you’re catching generic exceptions, among other issues related to handling exceptions.</li>
				<li><strong class="bold">Formatting</strong>: This rule set checks whether your code base follows a specific formatting rule set. It allows for <a id="_idIndexMarker585"/>checking indentation, spacing, semicolons, or even import ordering, among other things.</li>
				<li><strong class="bold">Naming</strong>: This rule set contains rules that assert the naming of different parts of the code base. It checks how we name our classes, packages, functions, and variables. It reports the errors in case we’re not following the set conventions.</li>
				<li><code>ArrayPrimitives</code> or the misuse of <code>forEach</code> loops, for instance.</li>
				<li><strong class="bold">Potential-Bugs</strong>: This rule set provides rules that detect potential bugs.</li>
				<li><strong class="bold">Ruleauthors</strong>: This rule set provides rules that ensure good practices are followed when writing custom rules.</li>
				<li><strong class="bold">Style</strong>: This rule set provides rules that assert the style of the code. This will help keep the code in line with the given code style guidelines.</li>
			</ul>
			<p>With this understanding of detekt rule sets and features, let us now set up detekt in our project.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor154"/>Setting up detekt</h2>
			<p>Similar to Ktlint, detekt is available as a Gradle plugin. To add the plugin to our project, we need to add the<a id="_idIndexMarker586"/> following code to our project’s <code>build.gradle.kts</code> file in the plugins block:</p>
			<pre class="source-code">
id("io.gitlab.arturbosch.detekt") version "1.23.1"</pre>			<p>Click on the <code>build.gradle.kts</code> file below the plugins block:</p>
			<pre class="source-code">
apply(plugin = "io.gitlab.arturbosch.detekt")
detekt {
    parallel = true
}</pre>			<p>This applies the detekt plugin to all the modules that will be in our project so we do not need to add the plugin to each module. We also set the <code>parallel</code> property to <code>true</code>. This will help us run the detekt tasks in parallel and save time when running the tasks. Click on the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. We are now set to use detekt. Open your terminal and run the following command:</p>
			<pre class="console">
./gradlew detekt</pre>			<p>This will run the <code>detekt</code> task. After the task completes, we will see the following output:</p>
			<div><div><img src="img/B19779_11_06.jpg" alt="Figure 11.6 – detekt errors" width="1100" height="355"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – detekt errors</p>
			<p>The first time we run the task, we will get a number of errors. As we can see from the preceding figure, detekt shows the file and line number with the error and the type of rule set that has not been complied with. In <em class="italic">Figure 11</em><em class="italic">.6</em>, we can see the common ones being the function is too long, and magic numbers are included, among others. At the end of the list of errors, detekt <a id="_idIndexMarker587"/>normally shows the total number of weighted issues, as shown in the following figure:</p>
			<div><div><img src="img/B19779_11_07.jpg" alt="Figure 11.7 – detekt errors summary" width="474" height="333"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – detekt errors summary</p>
			<p>We have a total of 121 weighted issues. We are going to see how to suppress some as well as increase thresholds for others and fix the ones that we can shortly. First, we need to change the default behavior of detekt. To do this, we need to create a <code>detekt-config.yml</code> file in the root of our project. detekt has a task that does this. Let us open the <strong class="bold">Terminal</strong> tab in our IDE and run the following command:</p>
			<pre class="console">
./gradlew detektGenerateConfig</pre>			<p>This will generate a <code>config</code> file if we don’t have it already. After the task completes, we will see the following output:</p>
			<div><div><img src="img/B19779_11_08.jpg" alt="Figure 11.8 – detekt config file" width="566" height="385"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – detekt config file</p>
			<p>We need to reference this file to our detekt setup. Let us head over to the project-level <code>build.gradle.kts</code> file and <a id="_idIndexMarker588"/>modify our <code>detekt</code> block to look like this:</p>
			<pre class="source-code">
detekt {
    parallel = true
    config.setFrom(files("${project.rootDir}/config/detekt/detekt.yml"))
}</pre>			<p>Here, we are using our newly created file as the <code>config</code> file. Click on the <code>config</code> file.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor155"/>Customizing detekt</h2>
			<p>At times, <code>detekt</code> might be reporting issues that we do not want to fix or we might want to change the severity or thresholds of the issue. Here is where customizing detekt comes in handy. We can <a id="_idIndexMarker589"/>customize <code>detekt</code> in the <code>detekt.yml</code> file and customize the rules that we are interested in. The first issue we are going to disable is the <code>detekt.yml</code> file and press <em class="italic">Command</em> + <em class="italic">F</em> on macOS or <em class="italic">Ctrl</em> + <em class="italic">F</em> on Windows to search for the <code>MagicNumber</code> issue and modify it as follows:</p>
			<pre class="source-code">
MagicNumber:
  active: false</pre>			<p>We are setting the <code>active</code> property to <code>false</code>. This will disable the issue. By running the <code>./gradlew detekt</code> command again, we can see that we have reduced the error from 121 to 60 now! That’s a significant drop. We can also see that the <code>MagicNumber</code> issue is no longer present.</p>
			<div><div><img src="img/B19779_11_09.jpg" alt="Figure 11.9 – detekt with no magic numbers" width="439" height="331"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – detekt with no magic numbers</p>
			<p>Next, let us ensure that detekt doesn’t complain about Jetpack Compose function naming. Search for the <code>FunctionNaming</code> issue and <a id="_idIndexMarker591"/>modify it to be as follows:</p>
			<pre class="source-code">
FunctionNaming:
  active: true
  excludes: ['**/test/**', '**/androidTest/**', '**/commonTest/**', '**/jvmTest/**', '**/androidUnitTest/**', '**/androidInstrumentedTest/**', '**/jsTest/**', '**/iosTest/**']
  functionPattern: '[a-z][a-zA-Z0-9]*'
  excludeClassPattern: '$^'
  ignoreAnnotated: ['Composable']</pre>			<p>We have added <code>ignoreAnnotated: ['Composable']</code>. This will not report issues for all functions annotated with the <code>@Composable</code> annotation. Composable functions use the Pascal case naming convention. Next, we want to disable the new line at the end of the file rule on detekt since we disabled it on Ktlint. Search for the <code>FinalNewline</code> issue and modify it to be as follows:</p>
			<pre class="source-code">
NewLineAtEndOfFile:
  active: false</pre>			<p>This will disable the issue. By running the <code>./gradlew detekt</code> command again, we can see that we have reduced the errors to only eight now:</p>
			<div><div><img src="img/B19779_11_10.jpg" alt="Figure 11.10 – detekt errors reduced" width="1094" height="230"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – detekt errors reduced</p>
			<p>Now, let us see how to increase the thresholds to resolve the <em class="italic">function too long</em> issue. Search for the <code>FunctionTooLong</code> issue and modify it to be as follows:</p>
			<pre class="source-code">
LongMethod:
  active: true
  threshold: 140</pre>			<p>This will solve all the issues related to the function being too long. Search for the <code>LongParameterList</code> issue and <a id="_idIndexMarker592"/>modify it to be as follows:</p>
			<pre class="source-code">
LongParameterList:
  active: true
  functionThreshold: 8</pre>			<p>We have increased the threshold from <code>6</code> to <code>8</code>. Lastly, search for the <code>ComplexCondition</code> issue and modify it to be as follows:</p>
			<pre class="source-code">
ComplexCondition:
  active: true
  threshold: 6</pre>			<p>We have also increased the threshold from <code>4</code> to <code>6</code>. By running the <code>./gradlew detekt</code> command again, we can see that we have reduced the errors to only three now:</p>
			<div><div><img src="img/B19779_11_11.jpg" alt="Figure 11.11 – More errors removed" width="1093" height="167"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – More errors removed</p>
			<p>Increasing thresholds is a good way of reducing errors. It’s also great since it reduces the amount of refactoring that we have to do. However, we should be careful not to increase the thresholds too much. Let us now try to fix the remaining issues. Let us start with the <code>TooGenericExceptionCaught</code> and <code>SwallowedException</code> issues. This is in our <code>PetsSyncWorker</code> <code>doWork</code> function:</p>
			<pre class="source-code">
override suspend fun doWork(): Result {
    return try {
        petsRepository.fetchRemotePets()
        Result.success()
    } catch (e: Exception) {
        Result.failure()
    }
}</pre>			<p>To resolve the issues, we need to add a <code>log</code> statement to the <code>catch</code> block and catch only the exceptions that we <a id="_idIndexMarker593"/>expect. Let us modify the code to be as follows:</p>
			<pre class="source-code">
override suspend fun doWork(): Result {
    return try {
        petsRepository.fetchRemotePets()
        Result.success()
    } catch (e: IOException) {
        Log.d("PetsSyncWorker", "Error fetching pets", e)
        Result.failure()
    }
}</pre>			<p>We have added a <code>log</code> statement and we are only catching <code>IOException</code>. Lastly, let us fix the <code>UtilityClassWithPublicConstructor</code> issue. This is in our <code>LeakTestUtils</code> class:</p>
			<pre class="source-code">
class LeakTestUtils {
    companion object {
        val leakCanaryTest = LeakCanaryTest()
    }
}</pre>			<p>This class only has a companion object, which returns an instance of the <code>LeakCanaryTest</code> class. We can <a id="_idIndexMarker594"/>use an object instead of a class. Let us modify the class to be as follows:</p>
			<pre class="source-code">
object LeakTestUtils {
    val leakCanaryTest = LeakCanaryTest()
}</pre>			<p>All the issues should be fixed now. By running the <code>./gradlew detekt</code> command again, we can see that we have no errors now:</p>
			<div><div><img src="img/B19779_11_12.jpg" alt="Figure 11.12 – detekt successful run" width="714" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – detekt successful run</p>
			<p>Our build successfully passes. Our project now has a plugin that helps us do static analysis of our code. We can now identify code smells and technical debt early in the development process. We can also use these plugins on <strong class="bold">Continuous Integration/ Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines to <a id="_idIndexMarker595"/>ensure that we don’t merge code that has code smells and technical debt. This will help us keep our code base clean and maintainable, especially when we are working in teams. We will learn about this extensively in <a href="B19779_14.xhtml#_idTextAnchor198"><em class="italic">Chapter 14</em></a>.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor156"/>Summary</h1>
			<p>In this chapter, we have learned about the Kotlin style and the best practices for writing Kotlin code. We have also learned how to use plugins such as Ktlint and Detekt to format, lint, and detect code smells early.</p>
			<p>In the next chapter, we will learn how to add tests for the different layers in the MVVM architecture. We will learn about the importance of adding tests to our apps and how to add unit tests, integration tests, and instrumentation tests.</p>
		</div>
	</div></div></body></html>