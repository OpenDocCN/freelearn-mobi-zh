<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer165">
			<h1 id="_idParaDest-118" class="chapter-number"><a id="_idTextAnchor135"/>11</h1>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor136"/>Enhancing Code Quality</h1>
			<p>As we develop our Android apps, we must ensure that the code we write complies with the set rules and follows the best practices. This not only helps us to write good code but also makes it easier to maintain and easily onboard others to the <span class="No-Break">code base.</span></p>
			<p>In this chapter, we will learn about the Kotlin style and the best practices for writing Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to format, lint, and detect the code <span class="No-Break">smells early.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Mastering Kotlin style and <span class="No-Break">best practices</span></li>
				<li>Using Ktlint for <span class="No-Break">static analysis</span></li>
				<li>Detecting code smells <span class="No-Break">with Detekt</span></li>
			</ul>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor137"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) downloaded.</span></p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven</span></a></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor138"/>Mastering Kotlin style and best practices</h1>
			<p>As we learned in <a href="B19779_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, Kotlin is a very concise and static language. As such, it is easier for us as developers to not follow some of the recommended practices. This leads to a lot of code smells and <a id="_idIndexMarker544"/>technical debt. A <strong class="bold">code smell</strong> is a pattern or practice that might indicate a deeper <a id="_idIndexMarker545"/>problem within the code. It indicates that the code might lead to potential problems or hinder maintainability. On the other hand, <strong class="bold">technical debt</strong> refers to the cost or consequences of choosing quick and suboptimal <a id="_idIndexMarker546"/>solutions in development to meet immediate needs rather than developing robust and maintainable solutions. We always have to come back later to such solutions to refactor them to be more scalable and maintainable. Let us start by learning about some of the best practices and how to <span class="No-Break">avoid them.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/>Coding conventions</h2>
			<p>Kotlin has a wide variety<a id="_idIndexMarker547"/> of coding conventions that cover everything from naming conventions to formatting. Following these conventions makes it easier to read our code and makes it maintainable. Examples of these are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Variable names should be <span class="No-Break">in </span><span class="No-Break"><strong class="bold">camelCase</strong></span></li>
				<li>Class names should be <span class="No-Break">in </span><span class="No-Break"><strong class="bold">PascalCase</strong></span></li>
				<li>Constants should be <span class="No-Break">in </span><span class="No-Break"><strong class="bold">UPPERCASE</strong></span></li>
				<li>Functions should be <span class="No-Break">in </span><span class="No-Break"><strong class="bold">camelCase</strong></span></li>
				<li>Functions with multiple words should be separated <span class="No-Break">by </span><span class="No-Break"><strong class="bold">underscores</strong></span></li>
				<li>Functions with a single expression should <span class="No-Break">be </span><span class="No-Break"><strong class="bold">inlined</strong></span></li>
			</ul>
			<p>Kotlin offers a lot of coding conventions. You can find them <span class="No-Break">at </span><a href="https://kotlinlang.org/docs/coding-conventions.html"><span class="No-Break">https://kotlinlang.org/docs/coding-conventions.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/>Null safety</h2>
			<p>As discussed<a id="_idIndexMarker548"/> extensively in <a href="B19779_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, Kotlin has a very strong <strong class="bold">null safety</strong> system. This is one of the most important features of Kotlin. It is important that we use this feature to its fullest extent. This will help us avoid a lot of null pointer exceptions. We have to use nullable types when variables can be <strong class="source-inline">null</strong>. When working with nullable types, it is recommended that we use the safe call operator (<strong class="source-inline">?.</strong>) and the Elvis operator (<strong class="source-inline">?:</strong>) to avoid null pointer exceptions. We should also use the <strong class="source-inline">let</strong> function to perform operations on nullable types. We should also use the safe cast operator (<strong class="source-inline">as?</strong>) to avoid class cast exceptions. An example is shown in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
val name: String? = null
name?.let {
  println(it)
}</pre>			<p>In the preceding <a id="_idIndexMarker549"/>example, we declared a <strong class="source-inline">name</strong> variable of the <strong class="source-inline">String</strong> type and assigned it <strong class="source-inline">null</strong>. Then, we used the <strong class="source-inline">let</strong> function to check whether the variable is <strong class="source-inline">null</strong> or not. If the variable is not <strong class="source-inline">null</strong>, then the <strong class="source-inline">println(it)</strong> function will print the value of <span class="No-Break">the variable.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/>Data classes</h2>
			<p>Kotlin makes it <a id="_idIndexMarker550"/>easy for us to create <strong class="bold">data classes</strong>. Data classes are classes that are used to hold data. The classes also automatically generate the <strong class="source-inline">equals</strong>, <strong class="source-inline">hashCode</strong>, <strong class="source-inline">toString</strong>, and <strong class="source-inline">copy</strong> functions. We should use data classes when we need to <span class="No-Break">hold data:</span></p>
			<pre class="source-code">
data class Person(val name: String, val age: Int)</pre>			<p>In the preceding example, we created a <strong class="source-inline">Person</strong> data class with two properties: <strong class="source-inline">name</strong> (which is a <strong class="source-inline">String</strong> type) and <strong class="source-inline">age</strong> (which is an <span class="No-Break"><strong class="source-inline">Int</strong></span><span class="No-Break"> type).</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/>Extensions functions</h2>
			<p>Kotlin provides <strong class="bold">extension functions</strong>, which allow us to add new functions to new classes without having to<a id="_idIndexMarker551"/> inherit from them. This will help us avoid creating utility classes. While extension functions are powerful, overuse or inappropriate use can lead to code that is hard to read and maintain. An example is shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
fun String.removeFirstAndLastChar(): String {
  return when {
  this.length &lt;= 1 -&gt; ""
  else -&gt; this.substring(1, this.length - 1)
  }
}
// Example usage
fun main(args: Array&lt;String&gt;) {
  val myString = "Hello Everyone"
  val result = myString.removeFirstAndLastChar ()
  println(result)
}</pre>			<p>In the preceding example, we created an extension function on the <strong class="source-inline">String</strong> class. The function removes the first and last character of the string and returns the remaining string. Additionally, we used the <strong class="source-inline">when</strong> expression to check whether the length of the string is less than or equal to <strong class="source-inline">1</strong>. If the length is less than or equal to <strong class="source-inline">1</strong>, then the function returns an empty<a id="_idIndexMarker552"/> string. Otherwise, it returns the substring of the string from index 1 to the length of the string – <strong class="source-inline">1</strong>. We used the extension function in the <strong class="source-inline">main</strong> function to remove the first and last character of the <strong class="source-inline">"Hello Everyone"</strong> string. The result is then printed to the console <span class="No-Break">as follows:</span></p>
			<pre class="console">
ello Everyon</pre>			<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/>Type inference</h2>
			<p>Kotlin has a very strong type system. As such, we can omit specifying the type of a variable and let the <a id="_idIndexMarker553"/>compiler infer the type. This will help us avoid a lot of boilerplate code. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
val name = "John Doe" // Compiler infers that name is of type String
val age = 25 // Compiler infers that age is of type Int</pre>			<h2 id="_idParaDest-127"><a id="_idTextAnchor144"/>Collections</h2>
			<p>Kotlin has a rich <strong class="bold">collections</strong> library. We use collections to store and manipulate groups of data. We have <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Map</strong>, <strong class="source-inline">Array</strong>, and <strong class="source-inline">Sequence</strong> as collection types available in Kotlin. Collections <a id="_idIndexMarker554"/>can either be <strong class="source-inline">mutable</strong> or <strong class="source-inline">immutable</strong>. A <strong class="source-inline">mutable</strong> collection can be modified after creation, while an <strong class="source-inline">immutable</strong> collection cannot be modified after creation. An example of a <strong class="source-inline">mutable</strong> list is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
val mutableList = mutableListOf("Kotlin", "Java", "Python")
mutableList.add("Swift")</pre>			<p>In the preceding example, we created a <strong class="source-inline">mutable</strong> list of strings. We used the <strong class="source-inline">mutableListOf</strong> function to create the list. We then added a new string to the list using the <strong class="source-inline">add</strong> function. An example of an <strong class="source-inline">immutable</strong> list is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
val immutableList = listOf("Kotlin", "Java", "Python")</pre>			<p>In the preceding example, we created an <strong class="source-inline">immutable</strong> list of strings. We used the <strong class="source-inline">listOf</strong> function to create the list. We cannot add or remove items from the list after creation. We can only read items from the list. Kotlin collections also have a wide variety of functions that can be used to perform operations on collections. We should use these functions instead of writing our own functions. This helps us make our code concise and readable. Let us see the following example of creating a list and filtering odd and <span class="No-Break">even numbers:</span></p>
			<pre class="source-code">
val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val evenNumbers = numbers.filter { it % 2 == 0 }
val oddNumbers = numbers.filter { it % 2 != 0 }</pre>			<p>In the preceding example, we created a list of numbers. We then used the <strong class="source-inline">filter</strong> function to filter even and odd numbers. The <strong class="source-inline">filter</strong> function takes a lambda as an argument. The lambda is used to filter the numbers. The <strong class="source-inline">filter</strong> function returns a new list with the filtered numbers. We used the <strong class="source-inline">it</strong> keyword to refer to the current item in the list. We then used the <strong class="source-inline">%</strong> operator to check whether the number is even or odd. If the number is even, then the <strong class="source-inline">filter</strong> function returns <strong class="source-inline">true</strong> and the number is added to the <strong class="source-inline">evenNumbers</strong> variable. For odd numbers, the <strong class="source-inline">filter</strong> function returns <strong class="source-inline">false</strong> and the number is added to the <strong class="source-inline">oddNumbers</strong> variable. Kotlin collections also have functions such as <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, <strong class="source-inline">fold</strong>, <strong class="source-inline">flatMap</strong>, and so on. We should use these functions instead of<a id="_idIndexMarker555"/> writing our own functions. This helps us make our code concise <span class="No-Break">and readable.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor145"/>Sealed classes and interfaces</h2>
			<p>Kotlin provides <strong class="bold">sealed classes</strong>, which are used to represent restricted class and interface hierarchies. This improves code <a id="_idIndexMarker556"/>readability and ensures that we know all the possible subclasses of a class. Here’s an example of a <span class="No-Break">sealed class:</span></p>
			<pre class="source-code">
sealed class Shape {
  class Circle(val radius: Double) : Shape()
  class Square(val length: Double) : Shape()
  class Rectangle(val length: Double, val breadth: Double) : Shape()
}</pre>			<p>In the preceding example, we created a sealed class called <strong class="source-inline">Shape</strong>. We then created three classes (<strong class="source-inline">Circle</strong>, <strong class="source-inline">Square</strong>, and <strong class="source-inline">Rectangle</strong>), which are subclasses of the <strong class="source-inline">Shape</strong> class. The <strong class="source-inline">Shape</strong> class can only be extended in the same file where it is declared. We cannot extend the <strong class="source-inline">Shape</strong> class in <span class="No-Break">another file<a id="_idTextAnchor146"/>.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor147"/>Formatting</h2>
			<p>We use four spaces <a id="_idIndexMarker557"/>for indentation in Kotlin. However, note that this is a convention and not a strict rule. We should always ensure that our code is properly formatted as per the conventions agreed upon by the team <span class="No-Break">or company</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor148"/>Functional programming</h2>
			<p>We should take<a id="_idIndexMarker558"/> advantage of Kotlin <strong class="bold">functional programming</strong> features<a id="_idIndexMarker559"/> such as <strong class="bold">lambdas</strong>, <strong class="bold">higher-order functions</strong>, and <strong class="bold">inline functions</strong>. This will help us make our code more<a id="_idIndexMarker560"/> concise and<a id="_idIndexMarker561"/> readable. An <a id="_idIndexMarker562"/>example is shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
val total = numbers.reduce { sum, element -&gt; sum + element }</pre>			<h2 id="_idParaDest-131"><a id="_idTextAnchor149"/>Coroutines</h2>
			<p>Kotlin provides <strong class="bold">coroutines</strong>, which are used to perform asynchronous operations. They are very lightweight and easy to use and help <a id="_idIndexMarker563"/>us avoid callback hell. We should use coroutines when we need to <a id="_idIndexMarker564"/>perform asynchronous operations. An example of a coroutine in Kotlin is as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
fun makeNetworkCall() {
  viewModelScope.launch {
    val result = async {
    // perform network call
    }
    // update UI
  }
}</pre>			<p>In the preceding example, we used <strong class="source-inline">viewModelScope</strong> to launch a coroutine. This is to ensure that the coroutine is canceled when the view model is destroyed. We used the <strong class="source-inline">launch</strong> coroutine builder to create a new coroutine. Inside the <strong class="source-inline">launch</strong> lambda, we performed our network call, which is supposed to happen in the background. We used the <strong class="source-inline">async</strong> coroutine builder, which allows us to await the result of the network call. The <strong class="source-inline">async</strong> coroutine builder returns a <strong class="source-inline">Deferred</strong> object. Lastly, we updated the UI with the result of the <span class="No-Break">network call.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor150"/>The when statements</h2>
			<p>Kotlin provides <strong class="source-inline">when</strong> statements, which <a id="_idIndexMarker565"/>are used to replace <strong class="source-inline">switch</strong> statements. We<a id="_idIndexMarker566"/> should use <strong class="source-inline">when</strong> statements when we need to perform conditional operations. If we have blocks with more than one <strong class="source-inline">if</strong> <strong class="source-inline">else</strong> statement, we should consider using <strong class="source-inline">when</strong> statements. An example is shown in the <span class="No-Break">following code</span><span class="No-Break">:</span></p>
			<pre class="source-code">
val number = when {
  x % 2 == 0 -&gt; "Even"
  x % 2 != 0 -&gt; "Odd"
  else -&gt; "Invalid"
}</pre>			<h2 id="_idParaDest-133"><a id="_idTextAnchor151"/>Classes and functions</h2>
			<ul>
				<li>Kotlin allows us to declare multiple classes in a single file. We should use this feature to avoid creating a<a id="_idIndexMarker567"/> lot of files, especially for classes that are closely related. We should, however, be keen not to have bloated files with a lot of classes, so we should use this feature <span class="No-Break">with caution.</span></li>
				<li>We have to ensure that<a id="_idIndexMarker568"/> we define only one <strong class="bold">primary constructor</strong> per class. Instead of overloading the constructor with a second one, we can always consider using default values for the <span class="No-Break">constructor parameters.</span></li>
				<li>We can use <strong class="bold">companion objects</strong> to create static<a id="_idIndexMarker569"/> members. Both Kotlin’s companion <a id="_idIndexMarker570"/>objects and Java’s <strong class="bold">static members</strong> facilitate the creation of class-level members that can be accessed without creating an instance of the class. However, Kotlin’s companion objects provide additional flexibility by allowing access to non-static members and offer a more <span class="No-Break">expressive syntax.</span></li>
				<li>We should always avoid returning <strong class="source-inline">null</strong> from functions. Instead, we should use <span class="No-Break">nullable types.</span></li>
				<li>We can always use <strong class="bold">scope functions</strong> to perform operations on objects. This will help us avoid creating a lot<a id="_idIndexMarker571"/> of <span class="No-Break">temporary variables.</span></li>
			</ul>
			<p>This is just a small list of best practices. As the code base grows, it’s hard at times to keep track of all the best practices. This is where static code analysis tools come in handy. They help us identify code smells and technical debt. They also help us identify bugs and security vulnerabilities. In the next section, we will learn about some of the static code analysis tools that we can use to improve the quality of <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor152"/>Using Ktlint for static analysis</h1>
			<p>According to the official documentation, ktlint is “<em class="italic">an anti-bikeshedding Kotlin linter with a built-in formatter</em>.” It helps us do <strong class="bold">static analysis</strong> of our Kotlin code and has a built-in rule set and formatter. It has<a id="_idIndexMarker572"/> several integrations. For Android projects, we normally use the Gradle integration. We have Ktlint Gradle (<a href="https://github.com/jlleitschuh/ktlint-gradle">https://github.com/jlleitschuh/ktlint-gradle</a>), which provides a wrapper plugin over the ktlint project. After <a id="_idIndexMarker573"/>adding the project to our project, it creates <strong class="source-inline">gradle</strong> tasks that allow us to run <strong class="source-inline">ktlint</strong> on our project. We are also able to <span class="No-Break">do auto-formatting.</span></p>
			<p>To set up Ktlint in our project, we need to add the Ktlint plugin to our project’s <strong class="source-inline">build.gradle.kts</strong> file in the plugins block, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
id("org.jlleitschuh.gradle.ktlint") version "11.6.1"</pre>			<p>Tap the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. This adds the Ktlint plugin to our project. We also need to set the plugin to be applied to all project modules. To do this, we add the following code to the project-level <strong class="source-inline">build.gradle.kts</strong> file below the <span class="No-Break">plugins block:</span></p>
			<pre class="source-code">
subprojects {
    apply(plugin = "org.jlleitschuh.gradle.ktlint")
    ktlint {
        verbose.set(true)
        android.set(true)
        filter {
            exclude("**/generated/**")
        }
    }
}</pre>			<p>This will apply the plugin to all the project modules. Tap the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. In the preceding code, we apply the plugin and do some additional configuration <a id="_idIndexMarker574"/>in the <strong class="source-inline">ktlint</strong> block. In our case, we are setting the <strong class="source-inline">verbose</strong> and <strong class="source-inline">android</strong> properties to <strong class="source-inline">true</strong>. We are also excluding the <strong class="source-inline">generated</strong> folder from <span class="No-Break">the analysis.</span></p>
			<p>With that, we are ready to use Ktlint. First, though, let’s disable some formatting options. To do this, we need to<a id="_idIndexMarker575"/> create an <strong class="source-inline">.editorconfig</strong> file in the root of our project. In the file, we add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
root = true
[*]
charset = utf-8
insert_final_newline = false
trim_trailing_whitespace = true
[*.{kt,kts}]
indent_size = 4
ij_kotlin_packages_to_use_import_on_demand = unset
ij_kotlin_name_count_to_use_star_import = 999
ij_kotlin_name_count_to_use_star_import_for_members = 999</pre>			<p>This disables some formatting options, the key one being <strong class="source-inline">insert_final_newline</strong> at the end of each file. This is especially useful for existing projects as it prevents us from having to reformat the whole project. If you need to customize Ktlint behavior, this is the file you use to enable or disable <span class="No-Break">some options.</span></p>
			<p>Let us now run the <strong class="source-inline">ktlintCheck</strong> task. To do this, let us open the <strong class="bold">Terminal</strong> tab in our IDE and run the <span class="No-Break">following command:</span></p>
			<pre class="console">
./gradlew ktlintCheck</pre>			<p>After the task completes, we <a id="_idIndexMarker576"/>will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B19779_11_01.jpg" alt="Figure 11.1 – Ktlint check failure" width="1089" height="701"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Ktlint check failure</p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B19779_11_02.jpg" alt="Figure 11.2 – Ktlint check failure continued" width="1090" height="702"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Ktlint check failure continued</p>
			<p>From the preceding figures, we can <a id="_idIndexMarker577"/>see that the task was completed with failures, which means our project is not correctly formatted. The output also shows the specific formatting error and the file. We can see indentation, formatting, and new lines issues. We can opt to fix the issues by ourselves but, first, we should always check whether the Ktlint formatter can fix the <a id="_idIndexMarker578"/>issues for us. To do this, we can run the <span class="No-Break">following command:</span></p>
			<pre class="console">
./gradlew ktlintFormat</pre>			<p>This will run the <strong class="source-inline">ktlintFormat</strong> task. After the task is completed, we will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B19779_11_03.jpg" alt="Figure 11.3 – ktlintFormat successful" width="479" height="110"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – ktlintFormat successful</p>
			<p>As seen in the preceding<a id="_idIndexMarker579"/> figure, the task was completed successfully. This means the Ktlint formatter was able to fix the issues for us. If the Ktlint formatter is not able to fix the issues, it normally highlights the issues that the plugin is not able to fix and shows the file and line number. We can then fix the issues manually. For now, we don’t have such issues. We can now run the <strong class="source-inline">ktlintCheck</strong> task again to confirm that the issues have been fixed. After the task completes, we will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B19779_11_04.jpg" alt="Figure 11.4 – ktlintFormat successful" width="481" height="110"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – ktlintFormat successful</p>
			<p>As seen in the preceding figure, the build was successful. This means our project is correctly formatted. By using the Git tool in our IDE by pressing <em class="italic">Command</em> + <em class="italic">K</em> on macOS and <em class="italic">Ctrl</em> + <em class="italic">K</em> on Windows, we can see the files that have changes and see the changes made by the Ktlint <a id="_idIndexMarker580"/>formatter. From our project, this is what the commit modal <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B19779_11_05.jpg" alt="Figure 11.5 – Git commit modal" width="640" height="770"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Git commit modal</p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.5</em>, the <strong class="source-inline">ktlintFormat</strong> command has made a bunch of changes to our files. We can check each file for <a id="_idIndexMarker581"/>changes too. The formatter is a good tool to help us quickly format our code according to the Kotlin style and conventions. The <strong class="source-inline">ktlintFormat</strong> and <strong class="source-inline">ktlintCheck</strong> commands are the ones to run after you complete your changes before you commit your code. This will help you avoid committing code that is not <span class="No-Break">formatted correctly.</span></p>
			<p>We have done a basic setup, which is sufficient for most projects. For more information, you can learn more about the plugin, the rules available, and how to customize it <span class="No-Break">here: </span><a href="https://github.com/jlleitschuh/ktlint-gradle"><span class="No-Break">https://github.com/jlleitschuh/ktlint-gradle</span></a><span class="No-Break">.</span></p>
			<p>We have seen how to<a id="_idIndexMarker582"/> use the Ktlint plugin to format and perform static<a id="_idIndexMarker583"/> analysis of our code. In the next section, we will learn how to use the detekt plugin to check for code smells and technical debt in <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor153"/>Detecting code smells with detekt</h1>
			<p>detekt is another static<a id="_idIndexMarker584"/> code analysis tool for Kotlin. It helps us identify problems early and keep the technical debt low throughout the development process. It enforces a set of rules that help us avoid code smells and technical debt. It also gives us the flexibility to create our own custom rule sets. Detekt offers the <span class="No-Break">following features:</span></p>
			<ul>
				<li>It identifies code smell for <span class="No-Break">Kotlin projects</span></li>
				<li>It’s easily configurable and customizable to suit <span class="No-Break">our needs</span></li>
				<li>We can always suppress the warnings if we feel they are <span class="No-Break">not applicable</span></li>
				<li>We can specify the code smell thresholds that we want <span class="No-Break">to enforce</span></li>
			</ul>
			<p>We will be using these features in our project. But before that, let us understand the rule sets. detekt has several rule sets that check the compliance of your code with the Kotlin style guide. The available rule sets are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Comments</strong>: This rule set provides rules that address issues in comments and the documentation of the code. It checks header files, comments on private methods, and undocumented classes, properties, <span class="No-Break">or methods.</span></li>
				<li><strong class="bold">Complexity</strong>: This rule set contains rules that report complex code. It checks for complex conditions, methods, expressions, and classes, as well as long methods and long <span class="No-Break">parameter lists.</span></li>
				<li><strong class="bold">Coroutines</strong>: This rule set analyzes code for potential <span class="No-Break">coroutine problems.</span></li>
				<li><strong class="bold">Empty-Blocks</strong>: This rule set contains rules that report empty blocks of code. Examples include empty <strong class="source-inline">catch</strong> blocks, empty class blocks, and empty function and conditional <span class="No-Break">function blocks.</span></li>
				<li><strong class="bold">Exceptions</strong>: This rule set reports issues related to how code throws and handles exceptions. For example, it has rules for if you’re catching generic exceptions, among other issues related to <span class="No-Break">handling exceptions.</span></li>
				<li><strong class="bold">Formatting</strong>: This rule set checks whether your code base follows a specific formatting rule set. It allows for <a id="_idIndexMarker585"/>checking indentation, spacing, semicolons, or even import ordering, among <span class="No-Break">other things.</span></li>
				<li><strong class="bold">Naming</strong>: This rule set contains rules that assert the naming of different parts of the code base. It checks how we name our classes, packages, functions, and variables. It reports the errors in case we’re not following the <span class="No-Break">set conventions.</span></li>
				<li><strong class="bold">Performance</strong>: This rule set analyzes code for potential performance problems. Some of the issues it reports include the use of <strong class="source-inline">ArrayPrimitives</strong> or the misuse of <strong class="source-inline">forEach</strong> loops, <span class="No-Break">for instance.</span></li>
				<li><strong class="bold">Potential-Bugs</strong>: This rule set provides rules that detect <span class="No-Break">potential bugs.</span></li>
				<li><strong class="bold">Ruleauthors</strong>: This rule set provides rules that ensure good practices are followed when writing <span class="No-Break">custom rules.</span></li>
				<li><strong class="bold">Style</strong>: This rule set provides rules that assert the style of the code. This will help keep the code in line with the given code <span class="No-Break">style guidelines.</span></li>
			</ul>
			<p>With this understanding of detekt rule sets and features, let us now set up detekt in <span class="No-Break">our project.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor154"/>Setting up detekt</h2>
			<p>Similar to Ktlint, detekt is available as a Gradle plugin. To add the plugin to our project, we need to add the<a id="_idIndexMarker586"/> following code to our project’s <strong class="source-inline">build.gradle.kts</strong> file in the <span class="No-Break">plugins block:</span></p>
			<pre class="source-code">
id("io.gitlab.arturbosch.detekt") version "1.23.1"</pre>			<p>Click on the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. This adds the detekt plugin to our project. We also need to set the plugin to be applied to all project modules. To do this, we add the following code to the project-level <strong class="source-inline">build.gradle.kts</strong> file below the <span class="No-Break">plugins block:</span></p>
			<pre class="source-code">
apply(plugin = "io.gitlab.arturbosch.detekt")
detekt {
    parallel = true
}</pre>			<p>This applies the detekt plugin to all the modules that will be in our project so we do not need to add the plugin to each module. We also set the <strong class="source-inline">parallel</strong> property to <strong class="source-inline">true</strong>. This will help us run the detekt tasks in parallel and save time when running the tasks. Click on the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. We are now set to use detekt. Open your terminal and run the <span class="No-Break">following command:</span></p>
			<pre class="console">
./gradlew detekt</pre>			<p>This will run the <strong class="source-inline">detekt</strong> task. After the task completes, we will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B19779_11_06.jpg" alt="Figure 11.6 – detekt errors" width="1100" height="355"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – detekt errors</p>
			<p>The first time we run the task, we will get a number of errors. As we can see from the preceding figure, detekt shows the file and line number with the error and the type of rule set that has not been complied with. In <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.6</em>, we can see the common ones being the function is too long, and magic numbers are included, among others. At the end of the list of errors, detekt <a id="_idIndexMarker587"/>normally shows the total number of weighted issues, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B19779_11_07.jpg" alt="Figure 11.7 – detekt errors summary" width="474" height="333"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – detekt errors summary</p>
			<p>We have a total of 121 weighted issues. We are going to see how to suppress some as well as increase thresholds for others and fix the ones that we can shortly. First, we need to change the default behavior of detekt. To do this, we need to create a <strong class="source-inline">detekt-config.yml</strong> file in the root of our project. detekt has a task that does this. Let us open the <strong class="bold">Terminal</strong> tab in our IDE and run the <span class="No-Break">following command:</span></p>
			<pre class="console">
./gradlew detektGenerateConfig</pre>			<p>This will generate a <strong class="source-inline">config</strong> file if we don’t have it already. After the task completes, we will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B19779_11_08.jpg" alt="Figure 11.8 – detekt config file" width="566" height="385"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – detekt config file</p>
			<p>We need to reference this file to our detekt setup. Let us head over to the project-level <strong class="source-inline">build.gradle.kts</strong> file and <a id="_idIndexMarker588"/>modify our <strong class="source-inline">detekt</strong> block to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
detekt {
    parallel = true
    config.setFrom(files("${project.rootDir}/config/detekt/detekt.yml"))
}</pre>			<p>Here, we are using our newly created file as the <strong class="source-inline">config</strong> file. Click on the <strong class="bold">Sync Now</strong> button at the top to add the changes to the project. Next, let us now do some configuration to our detekt <span class="No-Break"><strong class="source-inline">config</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor155"/>Customizing detekt</h2>
			<p>At times, <strong class="source-inline">detekt</strong> might be reporting issues that we do not want to fix or we might want to change the severity or thresholds of the issue. Here is where customizing detekt comes in handy. We can <a id="_idIndexMarker589"/>customize <strong class="source-inline">detekt</strong> in the <strong class="source-inline">detekt.yml</strong> file and customize the rules that we are interested in. The first issue we are going to disable is the <strong class="bold">magic number</strong> issue. This is the issue that is raised when we use numbers directly in our code. Let us<a id="_idIndexMarker590"/> open the <strong class="source-inline">detekt.yml</strong> file and press <em class="italic">Command</em> + <em class="italic">F</em> on macOS or <em class="italic">Ctrl</em> + <em class="italic">F</em> on Windows to search for the <strong class="source-inline">MagicNumber</strong> issue and modify it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
MagicNumber:
  active: false</pre>			<p>We are setting the <strong class="source-inline">active</strong> property to <strong class="source-inline">false</strong>. This will disable the issue. By running the <strong class="source-inline">./gradlew detekt</strong> command again, we can see that we have reduced the error from 121 to 60 now! That’s a significant drop. We can also see that the <strong class="source-inline">MagicNumber</strong> issue is no <span class="No-Break">longer present.</span></p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B19779_11_09.jpg" alt="Figure 11.9 – detekt with no magic numbers" width="439" height="331"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – detekt with no magic numbers</p>
			<p>Next, let us ensure that detekt doesn’t complain about Jetpack Compose function naming. Search for the <strong class="source-inline">FunctionNaming</strong> issue and <a id="_idIndexMarker591"/>modify it to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
FunctionNaming:
  active: true
  excludes: ['**/test/**', '**/androidTest/**', '**/commonTest/**', '**/jvmTest/**', '**/androidUnitTest/**', '**/androidInstrumentedTest/**', '**/jsTest/**', '**/iosTest/**']
  functionPattern: '[a-z][a-zA-Z0-9]*'
  excludeClassPattern: '$^'
  ignoreAnnotated: ['Composable']</pre>			<p>We have added <strong class="source-inline">ignoreAnnotated: ['Composable']</strong>. This will not report issues for all functions annotated with the <strong class="source-inline">@Composable</strong> annotation. Composable functions use the Pascal case naming convention. Next, we want to disable the new line at the end of the file rule on detekt since we disabled it on Ktlint. Search for the <strong class="source-inline">FinalNewline</strong> issue and modify it to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
NewLineAtEndOfFile:
  active: false</pre>			<p>This will disable the issue. By running the <strong class="source-inline">./gradlew detekt</strong> command again, we can see that we have reduced the errors to only <span class="No-Break">eight now:</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B19779_11_10.jpg" alt="Figure 11.10 – detekt errors reduced" width="1094" height="230"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – detekt errors reduced</p>
			<p>Now, let us see how to increase the thresholds to resolve the <em class="italic">function too long</em> issue. Search for the <strong class="source-inline">FunctionTooLong</strong> issue and modify it to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
LongMethod:
  active: true
  threshold: 140</pre>			<p>This will solve all the issues related to the function being too long. Search for the <strong class="source-inline">LongParameterList</strong> issue and <a id="_idIndexMarker592"/>modify it to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
LongParameterList:
  active: true
  functionThreshold: 8</pre>			<p>We have increased the threshold from <strong class="source-inline">6</strong> to <strong class="source-inline">8</strong>. Lastly, search for the <strong class="source-inline">ComplexCondition</strong> issue and modify it to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ComplexCondition:
  active: true
  threshold: 6</pre>			<p>We have also increased the threshold from <strong class="source-inline">4</strong> to <strong class="source-inline">6</strong>. By running the <strong class="source-inline">./gradlew detekt</strong> command again, we can see that we have reduced the errors to only <span class="No-Break">three now:</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B19779_11_11.jpg" alt="Figure 11.11 – More errors removed" width="1093" height="167"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – More errors removed</p>
			<p>Increasing thresholds is a good way of reducing errors. It’s also great since it reduces the amount of refactoring that we have to do. However, we should be careful not to increase the thresholds too much. Let us now try to fix the remaining issues. Let us start with the <strong class="source-inline">TooGenericExceptionCaught</strong> and <strong class="source-inline">SwallowedException</strong> issues. This is in our <strong class="source-inline">PetsSyncWorker</strong> <span class="No-Break"><strong class="source-inline">doWork</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
override suspend fun doWork(): Result {
    return try {
        petsRepository.fetchRemotePets()
        Result.success()
    } catch (e: Exception) {
        Result.failure()
    }
}</pre>			<p>To resolve the issues, we need to add a <strong class="source-inline">log</strong> statement to the <strong class="source-inline">catch</strong> block and catch only the exceptions that we <a id="_idIndexMarker593"/>expect. Let us modify the code to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
override suspend fun doWork(): Result {
    return try {
        petsRepository.fetchRemotePets()
        Result.success()
    } catch (e: IOException) {
        Log.d("PetsSyncWorker", "Error fetching pets", e)
        Result.failure()
    }
}</pre>			<p>We have added a <strong class="source-inline">log</strong> statement and we are only catching <strong class="source-inline">IOException</strong>. Lastly, let us fix the <strong class="source-inline">UtilityClassWithPublicConstructor</strong> issue. This is in our <span class="No-Break"><strong class="source-inline">LeakTestUtils</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
class LeakTestUtils {
    companion object {
        val leakCanaryTest = LeakCanaryTest()
    }
}</pre>			<p>This class only has a companion object, which returns an instance of the <strong class="source-inline">LeakCanaryTest</strong> class. We can <a id="_idIndexMarker594"/>use an object instead of a class. Let us modify the class to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
object LeakTestUtils {
    val leakCanaryTest = LeakCanaryTest()
}</pre>			<p>All the issues should be fixed now. By running the <strong class="source-inline">./gradlew detekt</strong> command again, we can see that we have no <span class="No-Break">errors now:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B19779_11_12.jpg" alt="Figure 11.12 – detekt successful run" width="714" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – detekt successful run</p>
			<p>Our build successfully passes. Our project now has a plugin that helps us do static analysis of our code. We can now identify code smells and technical debt early in the development process. We can also use these plugins on <strong class="bold">Continuous Integration/ Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines to <a id="_idIndexMarker595"/>ensure that we don’t merge code that has code smells and technical debt. This will help us keep our code base clean and maintainable, especially when we are working in teams. We will learn about this extensively in <a href="B19779_14.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor156"/>Summary</h1>
			<p>In this chapter, we have learned about the Kotlin style and the best practices for writing Kotlin code. We have also learned how to use plugins such as Ktlint and Detekt to format, lint, and detect code <span class="No-Break">smells early.</span></p>
			<p>In the next chapter, we will learn how to add tests for the different layers in the MVVM architecture. We will learn about the importance of adding tests to our apps and how to add unit tests, integration tests, and <span class="No-Break">instrumentation tests.</span></p>
		</div>
	</div></div></body></html>