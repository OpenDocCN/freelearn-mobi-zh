<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Key-value Programming Approaches</h1></div></div></div><p class="calibre8">Key-value coding<a id="id209" class="calibre1"/> is a really cool function that works well with key-value observing. It allows you to code less and create very elegant solutions and code modules. There are many cases in a real application when something changes and another part of the application should be affected. The thing is that you can do anything when a property of an instance or class changes, including but not limited to checking whether its value is valid, sending a message to someone when something changes to a certain value, and so on. The options are unlimited.</p><p class="calibre8">We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">What is key-value coding?</li><li class="listitem">The NSKeyValueCoding protocol</li><li class="listitem">Manual subsets of the NSKeyValueCoding behavior</li><li class="listitem">Associated objects</li><li class="listitem">Selectors as keys</li><li class="listitem">Maximum flexibility and handling unusual keys/values</li></ul></div><p class="calibre8">Also, do note that the NSKeyValueCoding protocol has been available since Mac OS X 10.0 in Cocoa, and it has also made its appearance in iOS 2.0, which came out in July 11, 2008. Generally, APIs for iOS and Mac tend to make their appearance on the Mac platform first before making their appearance on the iOS platform.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec53" class="calibre1"/>What is key-value coding or KVC?</h1></div></div></div><p class="calibre8">Key-value coding is basically a mechanism to indirectly access an object's properties, rather than explicitly getting and setting those properties via instance variables. With KVC, we use strings as properties keys, which act as an identifier. It is used by passing a "key", which is a string to get or set the property related to that key. For example, take a look at the following code sample:</p><div><pre class="programlisting">@interface DogClass
@property NSString *dog_name;
@property NSInteger number_legs;
@end

DogClass *mydog = [[DogClass alloc] init];
NSString *string = [myDog valueForKey:@"dog_name"];
[mydog setValue:@4 forKey:@"number_legs"];</pre></div><p class="calibre8">In the <a id="id210" class="calibre1"/>preceding code, we created <code class="email">DogClass</code> with two properties of <code class="email">NSString</code> and <code class="email">NSInteger</code>. Then, we used <code class="email">valueForKey</code> and <code class="email">setValue</code> to get the value of <code class="email">dog_name</code> and <code class="email">number_legs</code> respectively using key-value coding.</p><p class="calibre8">If this sounds familiar to you, you may recognize the syntactical similarity when using NSDictionary.</p><p class="calibre8">There is another sample code, which you can refer to for more clarification. Let's check out the following code:</p><div><pre class="programlisting">// The following line sets a property, directly.
//Example A
myObject.myProperty = myValue;

/*
  While this other line sets the same property, this time using KVC.
*/
//Example B
[myObject setValue:myValue forKey:@"myProperty"];</pre></div><p class="calibre8">Some developers who were introduced to Objective-C earlier disliked this approach of setting the property explicitly using the dot operator as seen in <code class="email">myObject.myProperty = myValue</code>, but it is essentially helpful since it separates the property involved in the setting process from the action of setting itself. A normal setter is applicable in this context, but writing your own setters will mean that you are writing a lot of boilerplate code and this will make your code more verbose.</p><p class="calibre8">Basically, your app's accessor methods will implement the methods and patterns signatures determined by the KVC. The task of those accessor methods is to provide a way into the property values of your application's data models. There are two of them, <code class="email">set</code> and <code class="email">get</code> accessors. The <code class="email">set</code> accessors—also known as <code class="email">setters</code>—set the property's value, while the get ones—also known as <code class="email">getters</code>—get/return the property's value.</p><p class="calibre8">Imagine<a id="id211" class="calibre1"/> a <code class="email">NSTableViewDataSource</code> method to handle an edit for one of the rows, other than the default one, without it being KVC. It should look like the following code:</p><div><pre class="programlisting">- (void)tableView:(NSTableView *)aTableView
    setMyObjectValue:(NSString *)anObject
    forMyTableColumn:(NSTableColumn *)aTableColumn
    row:(int)rowIndex
{
    if ([[aTableColumn identifier] isEqual:@"myName"])
    {
        [[myRecords objectAtIndex:rowIndex] setName:anObject];
    }
    else if ([[aTableColumn identifier] isEqual:@"myAddress"])
    {
        [[myRecords objectAtIndex:rowIndex] setAddress:anObject];
    }
}</pre></div><p class="calibre8">However, as soon as we can use KVC, the method can be like this:</p><div><pre class="programlisting">- (void)tableView:(NSTableView *)aTableView
    setMyObjectValue:(NSString *)anObject
    forMyTableColumn:(NSTableColumn *)aTableColumn
    row:(int)rowIndex
{
    [[myRecords objectAtIndex:rowIndex] setValue:anObject forKey:[aTableColumn identifier]];
}</pre></div><p class="calibre8">The essence of KVC is shown here; it's a better approach because each property's edit doesn't need to be handled as a separate condition. Another huge advantage is its efficiency since a table with thousands of columns will be handled by the same code, not even a line added to it. Notice that in the first example, we needed to have two <code class="email">if</code> loops to handle two different identifiers, but using KVC, we can cut down on the verbose code and use <code class="email">setValue</code> instead and achieve the same result with just one statement.</p><p class="calibre8">Besides the fact that key-value coding simplifies your code, implementing its compliant accessors is an effective design principle, and it helps the data encapsulation and makes it easier to work with key-value observing—which we will cover later—and other technologies such as Cocoa bindings, Core Data, and so on.</p><p class="calibre8">
<code class="email">NSKeyValueCoding</code> is an informal protocol that provides the essential methods for KVC, while <code class="email">NSObject</code> provides its default implementations. Key-value coding can access three types of object values; they are attributes, one-to-one relationships, and one-to-many relationships, where we can access a property indirectly using a string.</p><p class="calibre8">What we call attribute is just a simple value property, so it might be a <code class="email">NSString</code> or <code class="email">Boolean</code> value, as well as <code class="email">NSNumber</code> and other immutable object types.</p><p class="calibre8">When an object <a id="id212" class="calibre1"/>has properties of its own, these are known as properties, which are assigned a one-to-one relationship between the object and property. What is interesting about these properties is that they can change, without the object changing itself at all. To better understand this, think of a <code class="email">NSView</code> instance's superview as a one-to-one relationship. A set of related objects make a one-to-many relationship. We can see this in <code class="email">NSArray</code> or <code class="email">NSSet</code> instances, where a <code class="email">NSArray</code> or <code class="email">NSSet</code> instance has a one-to-many relationship to a group of objects.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec54" class="calibre1"/>The NSKeyValueCoding protocol</h1></div></div></div><p class="calibre8">The <a id="id213" class="calibre1"/><code class="email">NSKeyValueCoding</code> protocol is used in every sample code I've shown until now. I also have been calling it a protocol, but as I said earlier, it's an informal protocol, a <code class="email">NSObject</code> category.</p><p class="calibre8">KVC is a mechanism that enables you to indirectly access an object's properties, using a "key" of strings to do it. To enable KVC, <code class="email">NSKeyValueCoding</code> must be complied by your classes. Most of the time, you don't need to do anything in order to get it done because it's complied by <code class="email">NSObject</code>.</p><p class="calibre8">To make a key-value coding compliant class for a certain property, the methods <code class="email">setValue:forKey:</code> and <code class="email">valueForKey:</code> must be implemented to work as expected.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec17" class="calibre1"/>Compliance of attributes and one-to-one relationships</h2></div></div></div><p class="calibre8">You must <a id="id214" class="calibre1"/>ensure that your class has the following specification in case the of properties that are simply attributes or one-to-one relationships; an example would be <code class="email">[myObject setValue:myValue forKey:@"myProperty"];</code>, which we saw earlier:</p><div><ul class="itemizedlist"><li class="listitem">Have an instance variable called <code class="email">&lt;key&gt;</code> or <code class="email">_&lt;key&gt;</code>, or have an implemented method called <code class="email">-&lt;key&gt;</code>, which is a reference to the key in your key-value pair. As a rule of thumb, KVC keys start with lowercase letters, but for ones, such as URL, it's also acceptable if the first letter is uppercase.</li><li class="listitem">If the property is a mutable one, <code class="email">-set&lt;Ket&gt;: </code>would be also implemented.</li><li class="listitem">The implementation of the <code class="email">-set&lt;Key&gt;:</code> method should not include any validation as validation is to be implemented by the method mentioned in the next point.</li><li class="listitem">If the <a id="id215" class="calibre1"/>validation is suitable for the key, <code class="email">-validate&lt;Key&gt;:error: </code>must be implemented here along with your validation code.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec18" class="calibre1"/>Compliance of indexed one-to-many relationships</h2></div></div></div><p class="calibre8">Using <code class="email">NSArrays</code> or <code class="email">NSMutableArrays</code> will introduce you to the concept of one to-many relationships, where<a id="id216" class="calibre1"/> the key-value coding compliance requirements for indexed to-many relationships you need to ensure are:</p><div><ul class="itemizedlist"><li class="listitem">The implementation of a method called <code class="email">-&lt;key&gt;</code>, returning an array</li><li class="listitem">Besides, you might have an <code class="email">NSArray</code> instance variable called <code class="email">&lt;key&gt;</code> or <code class="email">_&lt;key&gt;</code> or even proceed the implementation of <code class="email">-countOf&lt;Key&gt;</code> and one or all of the following: <code class="email">-&lt;key&gt;AtIndexes:</code> or <code class="email">-objectIn&lt;Key&gt;AtIndex:</code></li><li class="listitem">In order to improve performance, you can also implement <code class="email">-get&lt;Key&gt;:range:</code> but it's not a requirement</li></ul></div><p class="calibre8">Otherwise, if you are dealing with mutable indexed ordered one to-many relationships, these are your requirements:</p><div><ul class="itemizedlist"><li class="listitem">Get at least one of the methods implemented: <code class="email">-insertObject:in&lt;Key&gt;AtIndex:</code> and <code class="email">-insert&lt;Key&gt;:atIndexes:</code></li><li class="listitem">Get at least one of the methods implemented: <code class="email">-removeObjectFrom&lt;Key&gt;AtIndex:</code> and <code class="email">-remove&lt;Key&gt;AtIndexes:</code></li><li class="listitem">As an option, you can even implement one of the methods: <code class="email">-replace&lt;Key&gt;AtIndexes:with</code> or <code class="email">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code></li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec19" class="calibre1"/>Compliance of unordered many-to-many relationships</h2></div></div></div><p class="calibre8">NSSets<a id="id217" class="calibre1"/> are an example of an unordered collection and also have a many to-many relationship, so the key-value coding compliance requirements for unordered many to-many relationships you need to ensure are:</p><div><ul class="itemizedlist"><li class="listitem">The implementation of a method called <code class="email">-&lt;key&gt;</code>, returning an <code class="email">NSSet</code></li><li class="listitem">Otherwise, set an instance variable called <code class="email">&lt;key&gt;</code> or <code class="email">_&lt;key&gt;</code></li><li class="listitem">Or get these methods implemented: <code class="email">-enumeratorOf&lt;Key&gt;</code> , <code class="email">-countOf&lt;Key&gt;</code>, and <code class="email">-memberOf&lt;Key&gt;:</code></li></ul></div><p class="calibre8">If it's a mutable unordered to-many relationship, KVC compliance will ask you to:</p><div><ul class="itemizedlist"><li class="listitem">Implement at least one of the following methods: <code class="email">-add&lt;Key&gt;:</code> or <code class="email">-add&lt;Key&gt;Object:</code></li><li class="listitem">Implement at least one of the following methods: <code class="email">-remove&lt;Key&gt;:</code> or <code class="email">-remove&lt;Key&gt;Object:</code></li><li class="listitem">In order to improve performance, you can implement <code class="email">-set&lt;Key&gt;:</code> and <code class="email">-insert&lt;Key&gt;:</code></li></ul></div><p class="calibre8">With <a id="id218" class="calibre1"/>NSString keys, you can set and get values using the methods <code class="email">setValue:forKey:</code> and <code class="email">valueForKey:</code>. This key is a simple string that serves as an identifier to an object's property. A key must be in accordance with the following rules: starting with a lowercase letter, shouldn't contain white-spaces, and make use of ASCII encoding. All these rules are applied in the following sample keys: <code class="email">mySampleKey</code>, <code class="email">pageNumber</code>, and <code class="email">oddSum</code>.</p><p class="calibre8">There are also key paths, they're basically a string with two or more keys separated by dots, as <code class="email">pictures.byOwner.forYear</code>. If you have a hard time trying to understand, think about it as a UNIX directory relative path as shown here, <code class="email">pictures/Vasilkoff/2014</code>.</p><p class="calibre8">It's clear that the folder 2014 is relative to <code class="email">Vasilkoff</code>, which is relative to <code class="email">pictures</code>, which in turn is relative to the user's current directory. In key paths, the first key—in our preceding code sample: <code class="email">pictures</code>—is relative to the receiver object.</p><p class="calibre8">For example, using the concept of address and street as you can derive a street from the address. So, if you use the same concept, the <code class="email">address.street</code> key path will get the value of the address property from the receiving object, and then you can determine the street property relative to the address object.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec20" class="calibre1"/>Advantages of key-value coding</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Most <a id="id219" class="calibre1"/>properties support the <code class="email">NSKeyValueCoding</code> informal protocol by default. Any object that inherits from <code class="email">NSObject</code> has automatic support for <code class="email">NSKeyValueCoding</code>. So, your own custom class will not have support for <code class="email">NSKeyValueCoding</code> unless you explicitly make it inherit from <code class="email">NSObject</code>.</li><li class="listitem">KVC will automatically look for setter and getter methods and if none is found, then it will even get or set instance variables.</li><li class="listitem">The possibility of using key paths is really helpful while handling multiple property objects.</li><li class="listitem">To be<a id="id220" class="calibre1"/> notified of the state change, KVC can be easily integrated with <code class="email">NSKeyValueObserving</code> in order to implement the observer software pattern.</li><li class="listitem">The possibility of dealing with undefined keys.</li><li class="listitem">This provides fallbacks.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec21" class="calibre1"/>Disadvantages of key-value coding</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <a id="id221" class="calibre1"/>property keys must be only <code class="email">NSStrings</code>, which means that the compiler does not have any information on the type of property or any details about its existence. So, any type of information cannot be retrieved from the return value of ID, which as you know, is a pointer to an Objective-C object.</li><li class="listitem">Its extended search path makes it a very slow KVC approach.</li><li class="listitem">The class must provide a method or an instance variable matching the name of the property, only then it will be found by <code class="email">NSKeyValueCoding</code>. If there is a typo in your key, your application will crash during runtime and not compile time, so you must make sure that your key is spelled correctly to avoid a crash.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec55" class="calibre1"/>Manual subsets of NSKeyValueCoding behavior</h1></div></div></div><p class="calibre8">The <code class="email">NSKeyValueCoding</code> protocol <a id="id222" class="calibre1"/>acts in different ways while looking up for methods and instance variables. In the first case, it will look up for the method's selector's name, while in the last, it will look up for the instance variable's name.</p><p class="calibre8">This can be done manually, as we can see in the following samples:</p><div><pre class="programlisting">// Manual implementation of KVC setter for method.
NSString *mySetterString = [@"set" stringByAppendingString:[myKeyString capitalizedString]];
[myObject performSelector:NSSelectorFromString(mySetterString) withObject:myValue];

// Manual implementation of KVC setter for instance variable.
object_setInstanceVariable(myObject, myKeyString, myValue);</pre></div><p class="calibre8">Since <a id="id223" class="calibre1"/>KVC can look up for setters and getters automatically, you might only be required to use the preceding approach by creating your own lookup path if you want to avoid <code class="email">NSKeyValueCoding</code> to find specified or ordinary methods and instance variables.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec22" class="calibre1"/>Advantages of creating your own lookup path</h2></div></div></div><p class="calibre8">To <a id="id224" class="calibre1"/>avoid <code class="email">NSKeyValueCoding</code>, looking for methods or instance variables that will normally be found by <code class="email">NSKeyValueCoding</code> and creating your own lookup path will be the approach you require. Let's start with the advantages and follow that up with the disadvantages:</p><div><ul class="itemizedlist"><li class="listitem">It may be faster than normal <code class="email">NSKeyValueCoding</code> paths.</li><li class="listitem">It gives you more control over the path. Unlike <code class="email">NSKeyValueCoding</code> paths, it will also work for non <code class="email">NSObject</code> inherited classes.</li><li class="listitem">By doing it manually, non-object values can be used for get and set.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec23" class="calibre1"/>Disadvantages of creating your own lookup path</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Generally, you <a id="id225" class="calibre1"/>will spend more time working on it than just using normal <code class="email">NSKeyValueCoding</code> paths</li><li class="listitem">It also provides less flexibility as you need to write more code to cover any unusual key/value cases, which is normally covered by the automatic method</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec56" class="calibre1"/>Associated objects</h1></div></div></div><p class="calibre8">In the <a id="id226" class="calibre1"/>Objective-C 2.0 runtime used by apps in iOS and 64-bit Mac OS X, you're allowed to set an association from any object to another. The object, in this case, without support from instance variables or methods can have a random set of extra properties set by the key at runtime, shown as follows:</p><div><pre class="programlisting">objc_setAssociatedObject(myObject, myKey, myValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</pre></div><p class="calibre8">You can use <a id="id227" class="calibre1"/>this if you want to set a property from outside an object. If you would be an object and your t-shirt color a property of yours, it would be like someone changing its color from outside your house, and you wouldn't even notice it.</p><p class="calibre8">You should use it in similar circumstances, where you want to keep the object away for knowing, supporting, or being involved while you set a property from other parts of the program. Associated objects should not be the method you want to use at the top of your head as lack of type information makes it easy for a crash to appear due to incorrect typing.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec24" class="calibre1"/>Advantages of using associated objects</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">A key<a id="id228" class="calibre1"/> can be any pointer. In this case, <code class="email">OBJC_ASSOCIATION_ASSIGN</code> can be used.</li><li class="listitem">It may be the fastest key-value coding approach.</li><li class="listitem">There is no support required from the method or instance variable.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec25" class="calibre1"/>Disadvantages of using associated objects</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">It has <a id="id229" class="calibre1"/>no effect over the object itself (instance variable or method). The object won't know about its own changes.</li><li class="listitem">In associated objects, a key is no longer <code class="email">NSString</code>, but a pointer.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec57" class="calibre1"/>Selectors as keys</h1></div></div></div><p class="calibre8">Normally, KVC <a id="id230" class="calibre1"/>looks up for a property key and acts only after the property key is found. The other approach is about acting on an object's property in the lookup process. There is a lookup method in Objective-C core and its keys are used as selectors.</p><p class="calibre8">The following line of code is how you implement this lookup method:</p><div><pre class="programlisting">objc_msgSend(myObject, mySetterSelector, myValue);</pre></div><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">This method is very similar to the manual implementation of the instance variable's setter, but instead of using the key to form a selector to do a look up, it uses the selector itself as the key.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec26" class="calibre1"/>Advantages of using selectors as keys</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">It's<a id="id231" class="calibre1"/> possible to get and set non-object data.</li><li class="listitem">From all approaches that handles methods, this is the fastest one.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec27" class="calibre1"/>Disadvantages of using selectors as keys</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">You <a id="id232" class="calibre1"/>need different selectors for get and set</li><li class="listitem">Since selectors are not objects, it's impossible to store directly in <code class="email">NSArray</code> and <code class="email">NSDictionary</code>. Instead, you can use <code class="email">NSValue</code> or Core Foundation</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec58" class="calibre1"/>Maximum flexibility and handling unusual keys/values</h1></div></div></div><p class="calibre8">After you<a id="id233" class="calibre1"/> learned so many ways to use key-value coding, there is still a very important way of implementation if you are looking for <a id="id234" class="calibre1"/>more flexibility while handling unusual keys/values. Just do it yourself. The final approach to key-value coding is to handle the implementation yourself.</p><p class="calibre8">Create a getter and setter method, and inside of each method properly returning and setting the values on a dictionary owned by the object might be the easiest way to do it.</p><p class="calibre8">We can check out this approach in the following sample code:</p><div><pre class="programlisting">/*
//------------------------------
  We create the method called "setCollectionValue:forKey:"
//------------------------------
*/

- (void)setCollectionValue:(id)value forKey:(NSString *)key
{
      /*
     //------------------------------
	 Here we set the value for key in a dictionary owned by the object.
     //------------------------------
     */

      [collectionDictionary setObject:value forKey:key];
}
 /*
//------------------------------
     Then, we create the method called "getCollectionValueForKey:"Note that it's a getter method, so it must return something – (id)
//------------------------------
*/
 - (id)getCollectionValueForKey:(NSString *)key
{
    /* 
   //------------------------------
    Here, we get the object from the dictionary, for the specified key and return it.
   //------------------------------
    */

    return [collectionDictionary objectForKey:key];
}</pre></div><p class="calibre8">In our sample <a id="id235" class="calibre1"/>code, we used <code class="email">NSDictionary</code> for <a id="id236" class="calibre1"/>the value's internal storage; however, you can use your own storage solutions, or even Cocoa key-value storage structures:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">NSMutableDictionary</code></li><li class="listitem"><code class="email">NSMapTable</code></li><li class="listitem"><code class="email">CFMutableDictionaryRef</code></li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec28" class="calibre1"/>Advantages of doing your own implementation</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Multiple <a id="id237" class="calibre1"/>collections can be exposed by a single object</li><li class="listitem">Any data type supported by the respective collection can be used while getting and setting</li><li class="listitem">Among all <a id="id238" class="calibre1"/>methods of implementation, this is the most flexible one</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec29" class="calibre1"/>Disadvantages of doing your own implementation</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">It simply <a id="id239" class="calibre1"/>does not work for random objects, only the target class</li><li class="listitem">You're unable to use other <code class="email">NSKeyValueCoding</code> concepts in addition to this</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec59" class="calibre1"/>Key-value observing</h1></div></div></div><p class="calibre8">Key-value observing—also <a id="id240" class="calibre1"/>known as KVO—is a way to get notified about changes in a variable, but only if it was changed using KVC. We can highlight two things out of this:</p><div><ul class="itemizedlist"><li class="listitem">Firstly, you need KVC in order to do KVO</li><li class="listitem">Secondly, if a variable is changed directly without key-value coding by its default setter and getter methods, you won't get notified at all</li></ul></div><p class="calibre8">Every variable in any key path can be observed by an object. It's useful if you consider using KVO. As KVO is built on top of KVC, you need KVC to implement KVO, and using KVO should be one of the reasons why you need to use KVC.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec30" class="calibre1"/>Implementing key-value observing</h2></div></div></div><p class="calibre8">It is <a id="id241" class="calibre1"/>relatively easy to implement KVO, as we shall see in the following code example. On the specified key path, you add an observer. After this, you can create a method that will be called anytime the observer sees modifications in the variables on its key path.</p><p class="calibre8">An object can be registered as an observer by using the following method from <code class="email">NSKeyCodingProtocol: addObserver:forKeyPath:options:context:</code>. Anytime a modification is performed, the following method is called <code class="email">observeValueForKeyPath:ofObject:change:context:</code>.</p><p class="calibre8">Firstly, go to your class and add the following method:</p><div><pre class="programlisting">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
}</pre></div><p class="calibre8">As you<a id="id242" class="calibre1"/> saw earlier, this method is called when any modification is performed. However, the protocol is even more powerful than this; it gives you the possibility to be notified about a change before it occurs and also after it's done, by using the respective methods: <code class="email">willChangeValueForKey</code> and <code class="email">didChangeValueForKey</code>. You might consider these methods if you need time-specific notifications.</p><p class="calibre8">Let's check out the following code where we register an object as an observer:</p><div><pre class="programlisting">/*
//------------------------------
   We register the object "developmentManager" as the observer of "developer". It will then notify you when any change will take place for the key path "developmentStage".
//------------------------------
*/
[developer addObserver:developmentManager forKeyPath:@"developmentStage" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</pre></div><p class="calibre8">If you look carefully, you will notice that we've used the options <code class="email">NSKeyValueObservingOptionNew</code> and <code class="email">NSKeyValueObservingOptionOld</code>. Both are used if we want to know the old and new values. These values will be stored in our dictionary of changes.</p><p class="calibre8">In our example, let's assume that development stages are represented by levels, <code class="email">NSInteger</code> values from <em class="calibre9">0</em> to <em class="calibre9">10</em>, and at every modification, we need to inform our progress. In this case, we will create two simple methods to do it for us:</p><div><pre class="programlisting">- (void)informNoProgress
{
  NSLog(@"We had no progress today");
}

- (void)informRealProgress
{
  NSLog(@"Our today's progress is of %@ level", developer.developmentStage);
}</pre></div><p class="calibre8">The two preceding methods are now complete; one will inform no progress if the development stage doesn't change—we will consider that it's impossible to decrease, in our scenario, and<a id="id243" class="calibre1"/> the other one will inform the real progress by levels if the development stage changes. However, now, we want to call the properly methods after comparing the values. Remember we used the options <code class="email">NSKeyValueObservingOptionNew</code> and <code class="email">NSKeyValueObservingOptionOld</code>; they will save the old and the new values after a change.</p><p class="calibre8">The old and new values will be handled inside the method that is called when the observer notifies a modification, as follows:</p><div><pre class="programlisting">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if([keyPath isEqualToString:@"developmentStage"])
    {
    /*
    //------------------------------
        Here we store the old and new values for further comparison.
    //------------------------------
    */
     NSInteger oldStage = [changeobjectForKey:NSKeyValueChangeOldKey];
    NSInteger newStage = [changeobjectForKey:NSKeyValueChangeNewKey];
  
    /*
    //------------------------------
        Then, we check whether the oldStage level is lower than the newStage level
    //------------------------------
    */
     if(oldStage &lt; newStage)
    {
      /*
      //------------------------------
          If the value is lower, there is progress and we call the properly method to inform it
      //------------------------------
      */
       [self informRealProgress];

    } else {
      /*
      //------------------------------
	  However, if the old level is not lower, it means there was no progress, we call the method to inform it.
      //------------------------------
      */
       [self informNoProgress];
    }
      }
}</pre></div><p class="calibre8">In the <a id="id244" class="calibre1"/>preceding code, we make sure that if the observed key is the one we are actually looking for, just to be really sure—in our case, the key is <code class="email">developmentStage</code>. Then, we store the old and the new values in order to compare them. If there are positive changes, inform the progress, if not, call the other method to inform about the bad news.</p><p class="calibre8">This is a real handy tool, even more if it is used cleverly as it is really powerful since it allows us to observe or watch a KVC key path on an object and to be notified when the value of the object changes, which can be useful in some programming contexts. Having control even on the change of your properties is a really powerful feature, and I'm sure you will find great cases to use in your own projects.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec31" class="calibre1"/>Performance considerations</h2></div></div></div><p class="calibre8">You <a id="id245" class="calibre1"/>must be careful while overriding KVC methods implementation as the default implementation caches Objective-C runtime information in order to be more effective and less erroneous, and unnecessary overriding implementations can affect the performance of your application.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec60" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">So far, we have taken a deep dive into key-value coding and other details such as various implementation methods, their advantages and disadvantages, and also key-value observing—a mechanism built on top of key-value coding.</p><p class="calibre8">We also saw some working code for key-value coding and key-value observing with some explanation on why we prefer to use key-value coding over other similar methods such as using a dot operator to access properties.</p><p class="calibre8">With this, I hope all these will help to give you an understanding of key-value coding and key-value observing. So with this, let's move on to the next chapter where we will wade into the brand new language by Apple called Swift.</p></div></body></html>