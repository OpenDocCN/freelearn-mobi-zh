<html><head></head><body>
<div><div><h1 class="chapterNumber">8</h1>
<h1 class="chapterTitle" id="_idParaDest-208">Introducing Blazor Hybrid App Development</h1>
<p class="normal">In .NET MAUI, an alternative approach to constructing the <strong class="keyWord">user interface</strong> (<strong class="keyWord">UI</strong>) is by using Blazor. Blazor, a <a id="_idIndexMarker602"/>modern web framework developed by Microsoft, allows developers to create interactive web applications utilizing C# and Razor syntax instead of JavaScript. Additionally, Blazor can be employed in the development of .NET MAUI applications as part of a Blazor Hybrid app. The fundamental building blocks of Blazor are Razor components, which can be reused between native and web applications when utilizing Blazor and Blazor Hybrid. In comparison to XAML UIs, a Blazor UI offers increased reusability, encompassing both native and web applications. In this chapter, we will provide an introduction to Blazor and discuss its implementation in various scenarios. Additionally, we will introduce Razor components and explain how to develop a Blazor Hybrid app using these components.</p>
<p class="normal">We will cover the following topics in this chapter:</p>
<ul>
<li class="bulletList">What is Blazor?</li>
<li class="bulletList">How to create a .NET MAUI Blazor project</li>
<li class="bulletList">How to create a new Razor component</li>
</ul>
<h1 class="heading-1" id="_idParaDest-209">Technical requirements</h1>
<p class="normal">To test and debug the source code in this chapter, you need to have Visual Studio 2022 installed on your PC or Mac. Please refer to the <em class="italic">Development environment setup</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with .NET MAUI</em>, for the details.</p>
<p class="normal">The source code for this chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/41dfc374525657f3c09c3870733ddaccff3c3412">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter08</a>.</p>
<p class="normal">To check out the source code of this chapter, we can use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ git clone -b 2nd/chapter08 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition.git PassXYZ.Vault2
</code></pre>
<p class="normal">To find out more about the source code in this book, please refer to the <em class="italic">Managing the source code in this book</em> section in <em class="chapterRef">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>.</p>
<h1 class="heading-1" id="_idParaDest-210">What is Blazor?</h1>
<p class="normal">Blazor is a <a id="_idIndexMarker603"/>framework designed to build web applications utilizing HTML, CSS, and C#. When developing web applications with Blazor in ASP.NET Core, you have two options to consider: Blazor Server <a id="_idIndexMarker604"/>and Blazor <strong class="keyWord">WebAssembly</strong> (<strong class="keyWord">Wasm</strong>). Furthermore, .NET MAUI enables<a id="_idIndexMarker605"/> the use of Blazor to create native applications, introducing a third variant – the Blazor Hybrid app.</p>
<p class="normal">In web application development, tasks typically involve creating a frontend UI and a backend service. Backend services can <a id="_idIndexMarker606"/>be accessed through RESTful APIs or <strong class="keyWord">remote procedure calls</strong> (<strong class="keyWord">RPCs</strong>). UI components, comprised of HTML, CSS, and JavaScript, are loaded in a browser and displayed as web pages. In the ASP.NET Core architecture, components related to user interaction can be rendered on the server. This hosting model is known as Blazor Server. Alternatively, we can execute most of the UI components within the browser, which is referred to as the Blazor Wasm hosting model.</p>
<p class="normal">In some instances, applications may require access to device-specific features, such as sensors or cameras; to accommodate these requirements, developers usually create native applications. However, Blazor offers an additional solution – the Blazor Hybrid app. Now, let’s discuss Blazor hosting models in more detail.</p>
<h2 class="heading-2" id="_idParaDest-211">Hosting models</h2>
<p class="normal">Blazor is<a id="_idIndexMarker607"/> a web framework designed for building web UI components, commonly <a id="_idIndexMarker608"/>referred to as Razor components, which can be hosted through various methods. These components can operate on the server side within ASP.NET Core (Blazor Server) or client side inside a web browser (Blazor Wasm). </p>
<p class="normal">Furthermore, Razor components can be implemented in native mobile and desktop applications by rendering them <a id="_idIndexMarker609"/>within an embedded Web View control (Blazor Hybrid). Despite the differences in hosting models, the<a id="_idIndexMarker610"/> process of building Razor components remains consistent. Consequently, the same Razor components can be utilized across all hosting models without any modification.</p>
<h3 class="heading-3" id="_idParaDest-212">Blazor Server</h3>
<p class="normal">In traditional <a id="_idIndexMarker611"/>web application development, the logic for<a id="_idIndexMarker612"/> user interactions is executed on the server side. Within the MVC design pattern, handling user interaction is an integral part of the application architecture. When a user interaction occurs in the browser, it is sent back to the server for processing. As a result, the entire page may be reloaded in response to the user’s request. </p>
<p class="normal">To enhance performance, Blazor Server employs <a id="_idIndexMarker613"/>a design that resembles a <strong class="keyWord">single-page application</strong> (<strong class="keyWord">SPA</strong>) framework. When responding to a user request, Blazor Server processes it and only sends the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>) changes <a id="_idIndexMarker614"/>pertaining to the user action to the browser. As depicted in <em class="italic">Figure 8.1</em>, the processing logic in Blazor Server is similar to that of a SPA, with the key distinction being that Razor components are rendered on the server, rather than the browser. In order to facilitate real-time communication between the web client and the server, SignalR, an open source library, is utilized as the connection between the server and browser.</p>
<figure class="mediaobject"><img alt="Figure 7.1: Blazor Server" height="241" src="img/B21554_08_01.png" width="578"/></figure>
<p class="packt_figref">Figure 8.1: Blazor Server</p>
<div><p class="normal"><strong class="keyWord">Razor components versus Blazor components</strong></p>
<p class="normal">People may get confused between Blazor and Razor. Razor was introduced as a template engine of ASP.NET in 2010. Razor syntax is a markup syntax in which developers can embed C# code into an HTML page. Blazor is a web framework that uses Razor syntax as the programming language. It was introduced around 2018. Blazor is a component-based framework, and a Blazor app consists of Razor components. In other words, Blazor is a hosting model for Razor components. Blazor components and Razor components are widely used interchangeably, but the correct terminology is Razor component.</p>
<p class="normal">A Razor component resides in a file with the <code class="inlineCode">.razor</code> extension, and it is compiled as a .NET class at runtime. This <code class="inlineCode">.razor</code> file can also be split into two files with <code class="inlineCode">.razor </code>and <code class="inlineCode">.razor.cs</code> extensions. The idea is quite similar to XAML and code-behind, which we learned about in <em class="italic">Part 1</em> of this book.</p>
</div>
<p class="normal">In Blazor Server, the <a id="_idIndexMarker615"/>app’s state is maintained <a id="_idIndexMarker616"/>on the server, and the client does not need a .NET runtime. This model can result in a faster initial load time as the browser only downloads a small initial payload. However, it requires a constant connection with the server, which may affect the scalability and introduce latency in UI updates.</p>
<h3 class="heading-3" id="_idParaDest-213">Blazor Wasm</h3>
<p class="normal">Blazor Wasm <a id="_idIndexMarker617"/>is a hosting model that renders <a id="_idIndexMarker618"/>Razor components within a web browser. As illustrated in <em class="italic">Figure 8.2</em>, the Razor components are loaded into the browser and compiled into Wasm using the .NET runtime:</p>
<figure class="mediaobject"><img alt="Figure 7.2: Blazor Wasm" height="271" src="img/B21554_08_02.png" width="619"/></figure>
<p class="packt_figref">Figure 8.2: Blazor Wasm</p>
<p class="normal">In the browser, the startup page loads the .NET environment and Razor components. These Razor<a id="_idIndexMarker619"/> components are compiled to Wasm through a .NET <strong class="keyWord">Intermediate Language</strong> (<strong class="keyWord">IL</strong>) interpreter<a id="_idIndexMarker620"/> at runtime, which manages DOM changes. This process is commonly <a id="_idIndexMarker621"/>known as <strong class="keyWord">just-in-time</strong> (<strong class="keyWord">JIT</strong>) compilation. With JIT, the compilation takes place at runtime, which results in slower performance compared <a id="_idIndexMarker622"/>to <strong class="keyWord">ahead-of-time</strong> (<strong class="keyWord">AOT</strong>) compilation. Blazor Wasm apps can be compiled AOT to Wasm to improve runtime performance but at the expense of a much larger download size.</p>
<p class="normal">With the<a id="_idIndexMarker623"/> introduction of .NET 8, a new runtime feature called jiterpreter was introduced in .NET 8 that enables partial JIT support in the .NET IL interpreter to achieve improved runtime performance.</p>
<p class="normal">Blazor Wasm apps can be deployed as static files and hosted on various web server platforms or static site hosting providers. Optionally, Blazor Wasm can also communicate with a server through API calls to retrieve data or offload complex operations.</p>
<div><p class="normal"><strong class="keyWord">Wasm</strong></p>
<p class="normal">Wasm is a binary instruction format for a stack-based virtual machine. Wasm is supported by most modern web browsers. With Wasm, we can use many programming languages to develop client-side components.</p>
</div>
<p class="normal">As a SPA framework, Blazor can be compared to other JavaScript-based SPA frameworks, such as React, Angular, and Vue. Numerous JavaScript SPA frameworks exist, and <em class="italic">Table 8.1</em> contains a comparison between Blazor and React. Although other JavaScript frameworks could also be used for comparison, the decision to choose React was based on the fact that React Native can be utilized to develop Hybrid apps. This shares some similarities with .NET MAUI Blazor, which will be discussed in the following section:</p>
<table class="table-container" id="table001-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Feature</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">React</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Blazor Wasm</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Blazor Server</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Language</p>
</td>
<td class="table-cell">
<p class="normal">JavaScript/JSX/TypeScript</p>
</td>
<td class="table-cell">
<p class="normal">C#</p>
</td>
<td class="table-cell">
<p class="normal">C#</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Runtime</p>
</td>
<td class="table-cell">
<p class="normal">JavaScript engine</p>
</td>
<td class="table-cell">
<p class="normal">Wasm</p>
</td>
<td class="table-cell">
<p class="normal">ASP.NET Core</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Progressive Web App (PWA) Support</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Hosting</p>
</td>
<td class="table-cell">
<p class="normal">Flexible to choose</p>
</td>
<td class="table-cell">
<p class="normal">Flexible to choose</p>
</td>
<td class="table-cell">
<p class="normal">ASP.NET Core</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Static Site Hosting</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Offloads Processing to Clients</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Performance</p>
</td>
<td class="table-cell">
<p class="normal">Lightweight with great performance</p>
</td>
<td class="table-cell">
<p class="normal">There is a heavier first-time load due to the extra download time of .NET runtimes</p>
</td>
<td class="table-cell">
<p class="normal">Similar performance to the JavaScript framework</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 8.1: Comparison of Blazor and React</p>
<p class="normal">Both JavaScript <a id="_idIndexMarker624"/>and Wasm are integral features of modern browsers. SPA frameworks that utilize either JavaScript or Wasm require no <a id="_idIndexMarker625"/>additional dependencies to run in a browser. Blazor Wasm supports JavaScript Interop, enabling the use of JavaScript components with Blazor.</p>
<p class="normal">Both Blazor and React support PWA development, which allows SPAs to function in offline mode.</p>
<p class="normal">Blazor Wasm and React both operate on the client side, utilizing <strong class="keyWord">client-side rendering</strong> (<strong class="keyWord">CSR</strong>). As a result, relying <a id="_idIndexMarker626"/>solely on these libraries for a web application could <a id="_idIndexMarker627"/>negatively affect <strong class="keyWord">search engine optimization</strong> (<strong class="keyWord">SEO</strong>) and the initial loading performance. This is because a considerable amount of time is necessary for the proper rendering of the content on the screen. In fact, in order to display the complete web app, the browser must download the entire application bundle, parse its content, execute it, and then render the result. This process could take several seconds for larger applications.</p>
<p class="normal">On the other hand, Blazor Server <a id="_idIndexMarker628"/>employs <strong class="keyWord">server-side rendering</strong> (<strong class="keyWord">SSR</strong>) to enhance<a id="_idIndexMarker629"/> the performance and user experience of web pages, particularly for users with slow internet connections or devices. SSR can decrease the initial loading time and bandwidth consumption of web pages by only sending the necessary HTML and CSS for the first render, while CSR necessitates downloading and executing a significant amount of JavaScript code before anything is rendered. Moreover, SSR facilitates faster interactions and transitions between pages, as the server can pre-render the upcoming page and transmit it to the browser as soon as the user clicks a link.</p>
<p class="normal">Another <a id="_idIndexMarker630"/>advantage of SSR is that it can improve the SEO and social media sharing of web pages, as the server can provide the full HTML content and metadata of each page to crawlers and bots. CSR can make it harder for crawlers and bots to access and index the content of web pages, as they may not be able to execute JavaScript or wait for asynchronous data fetching. </p>
<p class="normal">SSR can also ensure that the content and layout of web pages are consistent across different browsers and devices, as the server can handle browser compatibility and responsiveness issues.</p>
<p class="normal">In recent developments, both Blazor and JavaScript frameworks have transitioned to mixed rendering modes to harness the benefits of both CSR and SSR. With the introduction of .NET 8, Auto render mode is now available. This mode employs Wasm-based rendering when the .NET Wasm runtime can be loaded swiftly (within 100ms). This generally occurs when the runtime has already been downloaded and cached, or when a high-speed network connection is being used. If these conditions are not satisfied, the Auto render mode defaults to Server render mode while simultaneously downloading the .NET Wasm runtime in the background.</p>
<h3 class="heading-3" id="_idParaDest-214">Blazor Hybrid</h3>
<p class="normal">We can <a id="_idIndexMarker631"/>also utilize Blazor as the UI layer for desktop or <a id="_idIndexMarker632"/>mobile native frameworks, which are referred to as Blazor Hybrid applications. In such an app, Razor components are natively rendered on the device using an integrated WebView control. Wasm is not involved, so the application possesses the same capabilities as a native app.</p>
<p class="normal">In <em class="italic">Figure 8.3</em>, we observe that a <a id="_idIndexMarker633"/>Hybrid app allows us to utilize the <strong class="screenText">BlazorWebView</strong> control for constructing and executing Razor components within an embedded WebView. The <strong class="screenText">BlazorWebView</strong> control can be accessed in .NET MAUI and Windows desktop <a id="_idIndexMarker634"/>environments. By utilizing .NET MAUI and Blazor together, it is possible to use one set of web UI components across mobile, desktop, and web platforms.</p>
<figure class="mediaobject"><img alt="Figure 7.3: BlazorWebView" height="267" src="img/B21554_08_03.png" width="528"/></figure>
<p class="packt_figref">Figure 8.3: BlazorWebView</p>
<p class="normal">Blazor Hybrid<a id="_idIndexMarker635"/> applications can be developed using .NET MAUI, WPF, or Windows Forms. This means that it is possible to create a <a id="_idIndexMarker636"/>Blazor Hybrid application as a WPF, Windows Forms, or .NET MAUI application. In <em class="italic">Part 2</em>, we will focus solely on building a .NET MAUI Blazor Hybrid application.</p>
<p class="normal">We have presented three Blazor hosting models. Among these models, both Blazor Server and Blazor Hybrid applications offer full support for the .NET API. However, Blazor Wasm applications are limited to using a subset of the .NET APIs.</p>
<h2 class="heading-2" id="_idParaDest-215">Blazor Bindings</h2>
<p class="normal">Other than the<a id="_idIndexMarker637"/> hosting models that we previously introduced. There is a special type of Blazor app called Blazor Bindings available. Blazor Bindings or Mobile Blazor Bindings is an<a id="_idIndexMarker638"/> experimental project from Microsoft aimed at expanding the capabilities of Blazor, making it a cross-platform technology not only for creating web applications but also, eventually, for mobile development.</p>
<p class="normal">Blazor is a framework that allows you to build interactive web interfaces using C# instead of JavaScript, for both client and server code. It relies on Wasm to run the C# code directly in the browser.</p>
<p class="normal">With<a id="_idIndexMarker639"/> Mobile Blazor Bindings, the developer can write Blazor syntax and components but have them rendered as native controls on iOS, macOS, Windows, and Android – similar to how .NET MAUI XAML applications operate. </p>
<p class="normal">The key components of <a id="_idIndexMarker640"/>Mobile Blazor Bindings are:</p>
<ul>
<li class="bulletList"><strong class="keyWord">.NET Runtime</strong>: Since .NET 5, we have a common BCL on all support platforms.</li>
<li class="bulletList"><strong class="keyWord">Blazor</strong>: Blazor allows running .NET Standard compatible code in the browser using Wasm. It also provides a way to define UI components using Razor files (<code class="inlineCode">.razor</code>).</li>
<li class="bulletList"><strong class="keyWord">.NET MAUI</strong>: .NET MAUI is a framework for building native UIs for iOS, macOS, Android, and Windows from a single, shared code base. </li>
<li class="bulletList"><strong class="keyWord">BlazorBindings.Maui</strong>: This is the NuGet package published by Oleksandr Liakhevych. This package provides the basic Blazor Bindings functionality.</li>
</ul>
<p class="normal">Mobile Blazor Bindings allow developers to use existing Blazor development skills for mobile application development, where developers can use Razor syntax with C# to build UI components for either Web UI or native UIs.</p>
<p class="normal">It’s important to note that, as of January 2024, Mobile Blazor Bindings are still in the experimental phase and are not recommended for production applications. Microsoft’s original source code repository can be found here: <a href="https://github.com/dotnet/MobileBlazorBindings/">https://github.com/dotnet/MobileBlazorBindings/</a>.</p>
<p class="normal">Currently, the project is in the preview stage and is not under active maintenance. However, some updates have been merged from the GitHub repository of Oleksandr Liakhevych. Oleksandr Liakhevych is actively developing and maintaining his own repository: <a href="https://github.com/Dreamescaper/BlazorBindings.Maui">https://github.com/Dreamescaper/BlazorBindings.Maui</a>.</p>
<p class="normal">I have applied the Blazor Bindings from Oleksandr Liakhevych in implementing the source code for the first and second chapters of the book. The implemented code can be found in the designated branches: <code class="inlineCode">BlazorBindings/chapter01</code> and <code class="inlineCode">BlazorBindings/chapter02</code>: <a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition</a>.</p>
<p class="normal">To gain an understanding of Blazor Bindings, let’s compare the code and screenshot from<a id="_idIndexMarker641"/> the <code class="inlineCode">2nd/chapter01</code> and <code class="inlineCode">BlazorBindings/chapter01</code> branches, as exemplified in the following code and <em class="italic">Figure 8.4</em>. The branch <code class="inlineCode">2nd/chapter01</code> code was created from the .NET MAUI project template, whereas the code in the branch <code class="inlineCode">BlazorBindings/chapter01</code> is the equivalent implementation using Blazor.</p>
<p class="normal"><code class="inlineCode">MainPage.xaml</code> (<code class="inlineCode">2nd/chapter01</code>) – <a href="https://epa.ms/MainPage-CH01">https://epa.ms/MainPage-CH01</a></p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="PassXYZ.Vault.MainPage"&gt;
  &lt;ScrollView&gt;
    &lt;VerticalStackLayout
      Padding="30,0"
      Spacing="25"&gt;
      &lt;Image Source="dotnet_bot.png" HeightRequest="185"
        Aspect="AspectFit"
        SemanticProperties.Description=
          "dot net bot in a race car number eight" /&gt;
      &lt;Label Text="Hello, World!"
        Style="{StaticResource Headline}"
        SemanticProperties.HeadingLevel="Level1" /&gt;
      &lt;Label Text="Welcome to &amp;#10;.NET Multi-platform App UI"
        Style="{StaticResource SubHeadline}"
        SemanticProperties.HeadingLevel="Level2"
        SemanticProperties.Description=
          "Welcome to dot net Multi platform App U I" /&gt;
      &lt;Button x:Name="CounterBtn" Text="Click me"
        SemanticProperties.Hint=
          "Counts the number of times you click"
        Clicked="OnCounterClicked"
        HorizontalOptions="Fill" /&gt;
    &lt;/VerticalStackLayout&gt;
  &lt;/ScrollView&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="normal">Within <code class="inlineCode">MainPage.xaml</code>, a <code class="inlineCode">ScrollView</code> is included. This <code class="inlineCode">ScrollView</code> contains an <code class="inlineCode">Image</code>, two <code class="inlineCode">Label </code>instances, and a <code class="inlineCode">Button</code>, all of <a id="_idIndexMarker642"/>which are housed within the <code class="inlineCode">VerticalStackLayout</code> control.</p>
<p class="normal"><code class="inlineCode">MainPage.Razor</code> (<code class="inlineCode">BlazorBindings/chapter01</code>) – <a href="https://epa.ms/MainPage-BlazorBindings">https://epa.ms/MainPage-BlazorBindings</a></p>
<pre class="programlisting code"><code class="hljs-code">@page "/main"
&lt;ContentPage&gt;
  &lt;ScrollView&gt;
    &lt;VerticalStackLayout Spacing="25"
      Padding="new(30,0)"
      VerticalOptions="LayoutOptions.Center"&gt;
      &lt;Image Source="dotNetBotSource" HeightRequest="200"
          HorizontalOptions="LayoutOptions.Center" /&gt;
      &lt;Label Text="Hello, World!" FontSize="32"
        HorizontalOptions="LayoutOptions.Center" /&gt;
      &lt;Label Text=
        "Welcome to .NET Multi-platform Blazor Bindings App UI"
        FontSize="18"
        HorizontalOptions="LayoutOptions.Center" /&gt;
      &lt;Button Text="@ButtonText"
        HorizontalOptions="LayoutOptions.Fill"
        OnClick="OnCounterClicked" /&gt;
    &lt;/VerticalStackLayout&gt;
  &lt;/ScrollView&gt;
&lt;/ContentPage&gt;
@code {
  ImageSource dotNetBotSource = 
    ImageSource.FromFile("dotnet_bot.png");
  int count = 0;
  string ButtonText =&gt; count switch
  {
    0 =&gt; "Click me",
    1 =&gt; $"Clicked 1 time",
    _ =&gt; $"Clicked {count} times"
  };
  void OnCounterClicked()
  {
    count++;
  }
}
</code></pre>
<p class="normal">Within <code class="inlineCode">MainPage.razor</code>, we’ve replicated the same UI but used Razor syntax. We’ll delve deeper <a id="_idIndexMarker643"/>into the particulars of Razor syntax later in this chapter. Meanwhile, we can compare the UIs in <em class="italic">Figure 8.4</em>. They appear to be identical:</p>
<figure class="mediaobject"><img alt="Screens screenshot of a computer  Description automatically generated" height="682" src="img/B21554_08_04.png" width="665"/></figure>
<p class="packt_figref">Figure 8.4: Recreating the main page UI using Razor syntax</p>
<h2 class="heading-2" id="_idParaDest-216">What’s new in .NET 8 Blazor hosting models</h2>
<p class="normal">In our <a id="_idIndexMarker644"/>previous discussion of Blazor hosting models, we <a id="_idIndexMarker645"/>touched upon the topic of Blazor render modes. Prior to .NET 8, ASP.NET Core supported two render modes: SSR and CSR. These render modes were tied to a project type at compile time.</p>
<p class="normal">However, .NET 8 introduced a new feature to harness the benefits of both SSR and CSR – the Interactive Auto rendering. This new rendering mode initially uses a server-side ASP.NET Core for content rendering and interactivity. </p>
<p class="normal">It then switches to the .NET Wasm runtime on the client side for subsequent rendering and interactivity, after the Blazor bundle is <a id="_idIndexMarker646"/>downloaded and the Wasm runtime activated. Interactive Auto rendering frequently offers the quickest app startup experience.</p>
<p class="normal">This<a id="_idIndexMarker647"/> constitutes a significant departure from previous ASP.NET Core versions. With .NET 8, developers can designate the render modes of individual components at both compile time and runtime. Moreover, these render modes can be defined at both the component and page levels.</p>
<p class="normal">To illustrate this, in the following example, we apply SSR to the <code class="inlineCode">Dialog</code> component:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Dialog @rendermode="InteractiveServer" /&gt;
</code></pre>
<p class="normal">To designate the render modes at the page level, consult the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">@page "..."
@rendermode InteractiveServer 
</code></pre>
<p class="normal">In this code, the entire page will be rendered server side.</p>
<p class="normal">With support for specifying render modes at runtime, the boundary between SSR and CSR has become blurry. Developers now have the flexibility to switch render modes within a single application.</p>
<p class="normal">Before .NET 8, developers could create either a Blazor Server app or a Blazor Wasm app using Visual Studio templates. But .NET 8 introduced a new project template – the Blazor Web app. We’ll examine these project templates further in the next segment.</p>
<h2 class="heading-2" id="_idParaDest-217">Project templates of .NET MAUI and Blazor apps</h2>
<p class="normal">Blazor Server, Blazor Wasm, and <a id="_idIndexMarker648"/>Blazor Hybrid run in different hosting models at runtime, so they <a id="_idIndexMarker649"/>have different capabilities. Blazor Web app<a id="_idIndexMarker650"/> is the new project template<a id="_idIndexMarker651"/> introduced in .NET 8. With this template, we can mix render modes at runtime. In this book, our focus is on Blazor Hybrid applications.</p>
<p class="normal">We can create different project types using either the command line or Visual Studio.</p>
<p class="normal">To conserve <a id="_idIndexMarker652"/>space, we will examine the project templates using the command line only. To list the installed project templates, we can run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet new --list
These templates matched your input:
Template Name       Short Name           Language
------------------  -------------------  ----------
.NET MAUI App       maui                 [C#]
.NET MAUI Blazo...  maui-blazor          [C#]
.NET MAUI Class...  mauilib              [C#]
Blazor Server App   blazorserver         [C#]
Blazor Web App      blazor               [C#]
Blazor WebAssem...  blazorwasm           [C#]
Razor Class Lib...  razorclasslib        [C#]
Class Library       classlib             [C#],F#,VB
</code></pre>
<p class="normal">In the <a id="_idIndexMarker653"/>preceding list, we filtered out irrelevant <a id="_idIndexMarker654"/>project types. To understand the different<a id="_idIndexMarker655"/> project types better, we can review the summary depicted in <em class="italic">Table 8.2</em>:</p>
<table class="table-container" id="table002-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Template Name/Short Name</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">SDK</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Target Framework</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor Wasm app (blazorwasm)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk.</p>
<p class="normal">BlazorWebAssembly</p>
</td>
<td class="table-cell">
<p class="normal">net8.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor Server app (blazorserver)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk.Web</p>
</td>
<td class="table-cell">
<p class="normal">net8.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blazor Web app</p>
<p class="normal">(blazor)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk.Web</p>
<p class="normal">Microsoft.NET.Sdk.</p>
<p class="normal">BlazorWebAssembly</p>
</td>
<td class="table-cell">
<p class="normal">net8.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">.NET MAUI app (maui)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk</p>
</td>
<td class="table-cell">
<p class="normal">net8.0-android</p>
<p class="normal">net8.0-ios</p>
<p class="normal">net8.0-maccatalyst</p>
<p class="normal">net8.0-windows10.0.19041.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">.NET MAUI Blazor app (maui-blazor)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk.Razor</p>
</td>
<td class="table-cell">
<p class="normal">net8.0-android</p>
<p class="normal">net8.0-ios</p>
<p class="normal">net8.0-maccatalyst</p>
<p class="normal">net8.0-windows10.0.19041.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">.NET MAUI Class Library (mauilib)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk</p>
</td>
<td class="table-cell">
<p class="normal">net8.0-android</p>
<p class="normal">net8.0-ios</p>
<p class="normal">net8.0-maccatalyst</p>
<p class="normal">net8.0-windows10.0.19041.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Razor Class Library (razorclasslib)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk.Razor</p>
</td>
<td class="table-cell">
<p class="normal">net8.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Class Library (classlib)</p>
</td>
<td class="table-cell">
<p class="normal">Microsoft.NET.Sdk</p>
</td>
<td class="table-cell">
<p class="normal">net8.0</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 8.2: .NET MAUI and Blazor-related project types</p>
<p class="normal">The <a id="_idIndexMarker656"/>project<a id="_idIndexMarker657"/> types illustrated in <em class="italic">Table 8.2</em> can be categorized into two groups – Blazor apps and .NET MAUI apps. Let’s examine these groups in more detail.</p>
<h3 class="heading-3" id="_idParaDest-218">Blazor apps</h3>
<p class="normal">In both <a id="_idIndexMarker658"/>Blazor Server and Blazor Wasm templates, the target framework is net8.0, but they utilize different SDKs. The Blazor Server application can fully leverage the server’s capabilities using <code class="inlineCode">Microsoft.NET.Sdk.Web</code>, while Blazor Wasm has access to only a limited set of .NET APIs via <code class="inlineCode">Microsoft.NET.Sdk.BlazorWebAssembly</code>. In the template of Blazor Web app, it mixes both Blazor Server and Blazor Wasm.</p>
<p class="normal">To share Razor components between Blazor Server and Blazor Wasm, a Razor Class Library may be employed. This library employs <code class="inlineCode">Microsoft.NET.Sdk.Razor</code>. Additionally, the standard .NET class library, which can be shared across all .NET 8.0 applications, utilizes <code class="inlineCode">Microsoft.NET.Sdk</code>.</p>
<h3 class="heading-3" id="_idParaDest-219">.NET MAUI apps</h3>
<p class="normal">In a .NET MAUI application, one<a id="_idIndexMarker659"/> can create XAML-based .NET MAUI apps <a id="_idIndexMarker660"/>utilizing the <code class="inlineCode">Microsoft.NET.Sdk</code>, while for .NET MAUI Blazor apps, the <code class="inlineCode">Microsoft.NET.Sdk.Razor</code> is employed. Both project types cater to the same collection of target frameworks.</p>
<p class="normal">In order to share components, the standard .NET class library can be utilized. If it is necessary to incorporate .NET MAUI features within the shared components, the .NET MAUI class library may be employed. For instance, <code class="inlineCode">PassXYZLib</code> is a .NET MAUI class library. Although both the .NET class library and the .NET MAUI class library utilize the same <code class="inlineCode">Microsoft.NET.Sdk</code>, they target distinct frameworks.</p>
<h1 class="heading-1" id="_idParaDest-220">Creating a new .NET MAUI Blazor project</h1>
<p class="normal">To learn<a id="_idIndexMarker661"/> how to develop a Blazor Hybrid app, we need to upgrade our <code class="inlineCode">PassXYZ.Vault</code> project to accommodate a Blazor-based UI. Fortunately, we<a id="_idIndexMarker662"/> don’t need to start from scratch – we can simply modify our existing project to support the Blazor UI. By doing this, we can efficiently build both an XAML-based app and a Hybrid app within the same project. Before incorporating the Blazor UI into our app, let’s first establish a new .NET MAUI Blazor project with an identical app name. This will allow us to reference the new project when converting our current project into a .NET MAUI Blazor project.</p>
<p class="normal">We have the option to create this new .NET MAUI Blazor project either through the command line or via Visual Studio. We will demonstrate both methods in this section.</p>
<h2 class="heading-2" id="_idParaDest-221">Generating a .NET MAUI Blazor project with the dotnet command line</h2>
<p class="normal">Let us begin<a id="_idIndexMarker663"/> by creating a new project using the .NET command line. This can be accomplished on both Windows and macOS platforms. To create a new project, we will utilize the short name <code class="inlineCode">maui-blazor</code>, as mentioned in <em class="italic">Table 8.2</em>:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet new maui-blazor -o PassXYZ.Vault
The template ".NET MAUI Blazor Hybrid App" was created successfully.
</code></pre>
<p class="normal">In the previous command, we selected the project template by specifying the short name, <code class="inlineCode">maui-blazor</code>, and designated <code class="inlineCode">PassXYZ.Vault</code> as the project name. After creating the project, it can be built and executed:</p>
<pre class="programlisting con"><code class="hljs-con">C:\ &gt; dotnet build -t:Run -f net8.0-android
MSBuild version 17.8.0-preview-23367-03+0ff2a83e9 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
  PassXYZ.Vault -&gt; C:\PassXYZ.Vault\bin\Debug\net8.0-android\PassXYZ.Vault.dll
Build succeeded.
    0 Warning(s)
    0 Error(s)
Time Elapsed 00:01:43.79
</code></pre>
<p class="normal">In<a id="_idIndexMarker664"/> the <code class="inlineCode">build</code> command, we designate <code class="inlineCode">net8.0-android</code> as the target framework for testing our new app. We can replace the target framework with other supported frameworks such as <code class="inlineCode">net8.0-ios</code>, <code class="inlineCode">net8.0-maccatalyst</code>, or <code class="inlineCode">net8.0-windows10.0.19041.0</code>.</p>
<p class="normal">Refer to <em class="italic">Figure 8.6</em> to view a screenshot of this new app and its project structure. With this, we have successfully created a new project using the command line. Now, let’s explore how to accomplish the same task using Visual Studio on Windows.</p>
<h2 class="heading-2" id="_idParaDest-222">Creating a .NET MAUI Blazor Hybrid App using Visual Studio on Windows</h2>
<p class="normal">To <a id="_idIndexMarker665"/>create a .NET MAUI Blazor Hybrid App project using Visual Studio, begin by launching Visual Studio and selecting <code class="inlineCode">Create a new project</code>, and then in the search box, type <code class="inlineCode">MAUI</code> to filter the available options. As shown in <em class="italic">Figure 8.5</em>, choose <code class="inlineCode">.NET MAUI Blazor Hybrid App</code> from the list of project templates:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" height="579" src="img/B21554_08_05.png" width="825"/></figure>
<p class="packt_figref">Figure 8.5: Creating a new .NET MAUI Blazor Hybrid App project</p>
<p class="normal">After <a id="_idIndexMarker666"/>completing the project creation using the wizard, we can choose <code class="inlineCode">net8.0-android</code> as the target framework for building and running the project. To conserve space, the Android platform will be used as our primary example in this section; however, you are welcome to explore and test other target frameworks if desired.</p>
<h2 class="heading-2" id="_idParaDest-223">Running the new project</h2>
<p class="normal">To execute <a id="_idIndexMarker667"/>the project, press <em class="keystroke">F5</em> or <em class="keystroke">Ctrl</em> + <em class="keystroke">F5</em> in Visual Studio, or use the <code class="inlineCode">dotnet</code> command from the command line. Refer to <em class="italic">Figure 8.6</em> for screenshots illustrating this process and the project structure.</p>
<figure class="mediaobject"><img alt="Figure 7.5: Screenshots and project structure" height="586" src="img/B21554_08_06.png" width="825"/></figure>
<p class="packt_figref">Figure 8.6: Screenshots and project structure</p>
<p class="normal">The UI of the app, created <a id="_idIndexMarker668"/>using the template, resembles a SPA with a navigation menu at the top for Android devices. When executed on Windows with a larger screen, the navigation menu displays on the left side of the screen in a side-by-side manner. The project structure closely mirrors that of a standard .NET MAUI app but with the following notable differences:</p>
<ul>
<li class="bulletList"><code class="inlineCode">wwwroot/</code>: This folder is the root of static files for web pages.</li>
<li class="bulletList"><code class="inlineCode">Pages/</code>: This folder contains Razor pages in the app.</li>
<li class="bulletList"><code class="inlineCode">Shared/</code>: This folder contains Razor components that can be shared.</li>
<li class="bulletList"><code class="inlineCode">Main.razor</code>: This is the main page of the Blazor app.</li>
<li class="bulletList"><code class="inlineCode">_Imports.razor</code>: This is a helper to import Razor components at the folder or project level.</li>
</ul>
<p class="normal">To understand the difference between the .<code class="inlineCode">NET MAUI</code> app and the <code class="inlineCode">.NET MAUI Blazor</code> app, it is helpful to analyze their respective startup code.</p>
<h2 class="heading-2" id="_idParaDest-224">The startup code of the .NET MAUI Blazor Hybrid App</h2>
<p class="normal">All .NET MAUI apps <a id="_idIndexMarker669"/>contain a file named <code class="inlineCode">MauiProgram.cs</code>, which handles their startup and configuration. Let’s examine the startup code of the .NET MAUI Blazor Hybrid App:</p>
<pre class="programlisting code"><code class="hljs-code">namespace PassXYZ.Vault;
public static class MauiProgram {
  public static MauiApp CreateMauiApp() {
    var builder = MauiApp.CreateBuilder();
    builder.UseMauiApp&lt;App&gt;()
      .ConfigureFonts(fonts =&gt; {
        fonts.AddFont("OpenSans-Regular.ttf",
            "OpenSansRegular");
      });
    builder.Services.AddMauiBlazorWebView();                       //(1)
#if DEBUG
    builder.Services.AddBlazorWebViewDeveloperTools();             //(2)
#endif
    builder.Services.AddSingleton&lt;WeatherForecastService&gt;();
    return builder.Build();
  }
}
</code></pre>
<p class="normal">In the .NET MAUI Blazor Hybrid App, we can see that the following Blazor configurations have been added:</p>
<p class="normal"><strong class="keyWord">(1)</strong> <code class="inlineCode">BlazorWebView</code> is added by calling <code class="inlineCode">AddMauiBlazorWebView()</code>.</p>
<p class="normal"><strong class="keyWord">(2)</strong> Developer tools are added by calling <code class="inlineCode">AddBlazorWebViewDeveloperTools()</code> for debugging.</p>
<p class="normal">The rest of the startup process is the same as that for an XAML-based .NET MAUI app. In the <code class="inlineCode">App.xaml.cs</code> file, the <code class="inlineCode">MainPage</code> property, which is inherited from the <code class="inlineCode">App</code> class, is assigned to an instance of <code class="inlineCode">MainPage.xaml</code> as we can see in the following:</p>
<pre class="programlisting code"><code class="hljs-code">namespace PassXYZ.Vault;
public partial class App : Application {
  public App() {
    InitializeComponent();
    MainPage = new MainPage();
  }
}
</code></pre>
<p class="normal">The primary <a id="_idIndexMarker670"/>distinction between XAML-based applications and Blazor Hybrid applications lies in the UI controls used within <code class="inlineCode">MainPage.xaml</code>. Let’s examine the code of <code class="inlineCode">MainPage.xaml</code> closely to better understand this difference:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  xmlns:local="clr-namespace:PassXYZ.Vault"
  x:Class="PassXYZ.Vault.MainPage"
  BackgroundColor="{DynamicResource PageBackgroundColor}"&gt;
  &lt;BlazorWebView HostPage="wwwroot/index.xhtml"&gt;                   //(1)
    &lt;BlazorWebView.RootComponents&gt;                                //(2)
      &lt;RootComponent Selector="#app"                              //(3)
        ComponentType="{x:Type local:Main}" /&gt;                    //(4)
    &lt;/BlazorWebView.RootComponents&gt;
  &lt;/BlazorWebView&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="normal">In the <code class="inlineCode">MainPage.xaml</code>, only one UI element named <code class="inlineCode">BlazorWebView</code> is defined. With the <code class="inlineCode">HostPage</code> property and the nested node <code class="inlineCode">RootComponent</code>, it is possible to customize the <code class="inlineCode">BlazorWebView</code> efficiently.</p>
<p class="normal">We can consider <code class="inlineCode">BlazorWebView</code> to be similar to a browser. In a browser, the UI is typically loaded from an HTML file. The <code class="inlineCode">HostPage</code> property <strong class="keyWord">(1)</strong> serves to indicate the static HTML page that should load within the web view control. In our specific case, this refers to <code class="inlineCode">wwwroot/index.xhtml</code>, which we will examine in <em class="italic">Listing 8.1</em>.</p>
<p class="normal">In this static HTML file, we must designate the location for the Razor component and determine the root component. Both can be specified using the attributes of the nested node <code class="inlineCode">RootComponent</code> <strong class="keyWord">(2)</strong>.</p>
<p class="normal">In the previous chapter, we discovered that an XAML tag ultimately maps to a C# class. In this context, both <code class="inlineCode">BlazorWebView</code> and <code class="inlineCode">RootComponent</code> are also C# classes.</p>
<p class="normal">In the <code class="inlineCode">RootComponent</code>, we utilize the <code class="inlineCode">Selector</code> attribute <strong class="keyWord">(3)</strong> to define a CSS selector that determines the placement of the root Razor component within our application. In our specific instance, we use the <code class="inlineCode">#app</code> CSS selector defined in the <code class="inlineCode">index.xhtml</code> file. The <code class="inlineCode">ComponentType</code> attribute <strong class="keyWord">(4)</strong> establishes the type of the root component, which in our case is <code class="inlineCode">Main</code>.</p>
<p class="normal">Finally, let’s revisit <a id="_idIndexMarker671"/>the HTML file (<code class="inlineCode">index.xhtml</code>) that was mentioned earlier.</p>
<pre class="programlisting code"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
  &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0, maximum-scale=1.0, 
      user-scalable=no, viewport-fit=cover" /&gt;
  &lt;title&gt;PassXYZ.Vault&lt;/title&gt;
  &lt;base href="/" /&gt;
  &lt;link rel="stylesheet" 
     href="css/bootstrap/bootstrap.min.css" /&gt;                    //(1)
  &lt;link href="css/app.css" rel="stylesheet" /&gt;
  &lt;link href="PassXYZ.Vault.styles.css" rel="stylesheet" /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="status-bar-safe-area"&gt;&lt;/div&gt;
  &lt;div id="app"&gt;Loading...&lt;/div&gt;                                  //(2)
  &lt;div id="blazor-error-ui"&gt;
    An unhandled error has occurred.
    &lt;a href="" class="reload"&gt;Reload&lt;/a&gt;
    &lt;a class="dismiss"&gt;<img alt="" height="14" src="img/12.png" width="14"/>&lt;/a&gt;
  &lt;/div&gt;
  &lt;script src="img/blazor.webview.js"
      autostart="false"&gt;                                          //(3)
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="packt_figref">Listing 8.1: <code class="inlineCode">index.xhtml</code> (<a href="https://epa.ms/index8-1">https://epa.ms/index8-1</a>)</p>
<p class="normal">We can see that <code class="inlineCode">index.xhtml</code> is a simple HTML file:</p>
<p class="normal"><strong class="keyWord">(1)</strong> It uses the CSS stylesheet from the Bootstrap framework.</p>
<p class="normal"><strong class="keyWord">(2)</strong> The <code class="inlineCode">id</code> selector is specified as <code class="inlineCode">app</code>, which is then passed to the <code class="inlineCode">Selector</code> attribute of the <code class="inlineCode">RootComponent</code> within the <code class="inlineCode">MainPage.xaml</code> file.</p>
<p class="normal"><strong class="keyWord">(3)</strong> A JavaScript file called <code class="inlineCode">blazor.webview.js</code> is loaded at the end of <code class="inlineCode">index.xhtml</code>. This is responsible for <a id="_idIndexMarker672"/>initializing the runtime environment for <code class="inlineCode">BlazorWebView</code>.</p>
<p class="normal">With that, we have provided an overview of the .NET MAUI Blazor Hybrid app. In the following section, we will substitute the XAML-based UI with one that utilizes Blazor.</p>
<h1 class="heading-1" id="_idParaDest-225">Migrating to a .NET MAUI Blazor Hybrid App</h1>
<p class="normal">In the <a id="_idIndexMarker673"/>previous section, we created a new Hybrid app, which will serve as a reference for migrating our existing application. Instead of starting from scratch, we can take advantage of both the XAML and Blazor UIs within our current app by adjusting the project configuration. For now, we will implement a combination of XAML and Blazor UIs in a single application and, later on, transition entirely to Blazor in the following chapter.</p>
<p class="normal">To convert our app into a .NET MAUI Blazor Hybrid app, it is necessary to implement the following modifications.</p>
<p class="normal">Change the SDK in the project file by replacing <code class="inlineCode">Microsoft.NET.Sdk</code> with <code class="inlineCode">Microsoft.NET.Sdk.Razor</code>, as the .NET MAUI Blazor Hybrid app relies on a different SDK.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">PassXYZ.Vault.csproj</code> project file, the following line is present:
        <pre class="programlisting code"><code class="hljs-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
</code></pre>
</li>
<li class="numberedList">This line needs to be replaced with the following:
        <pre class="programlisting code"><code class="hljs-code">&lt;Project Sdk="Microsoft.NET.Sdk.Razor"&gt;
</code></pre>
</li>
<li class="numberedList">Transfer the subsequent folders from the newly established project into our application:<ul>
<li class="bulletList"><code class="inlineCode">wwwroot</code></li>
<li class="bulletList"><code class="inlineCode">Shared</code></li>
</ul>
</li>
<li class="numberedList">Transfer the subsequent files from the new project to our app:<ul>
<li class="bulletList"><code class="inlineCode">_Imports.razor</code></li>
<li class="bulletList"><code class="inlineCode">MainPage.xaml</code></li>
<li class="bulletList"><code class="inlineCode">MainPage.xaml.cs</code></li>
<li class="bulletList"><code class="inlineCode">Main.razor</code></li>
</ul>
</li>
<li class="numberedList">Revise <code class="inlineCode">MauiProgram.cs</code> by adding the following code:
        <pre class="programlisting code"><code class="hljs-code">    Builder.Services.AddMauiBlazorWebView();
#if DEBUG
    builder.Services.AddBlazorWebViewDeveloperTools();
#endif
</code></pre>
</li>
</ol>
<p class="normal">To review the commit history of these changes, go to <a href="https://epa.ms/Blazor7-1">https://epa.ms/Blazor7-1</a>.</p>
<p class="normal">With <a id="_idIndexMarker674"/>these adjustments, we have implemented all the necessary modifications to the configuration and can now proceed to the subsequent step. Nonetheless, before we delve into working on these changes, let us first acquaint ourselves with the fundamental Razor syntax.</p>
<h1 class="heading-1" id="_idParaDest-226">Understanding Razor syntax</h1>
<p class="normal">Blazor <a id="_idIndexMarker675"/>applications are composed of Razor components. As discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">User Interface Design with XAML</em>, XAML is a language that has its roots in XML. UI elements based on XAML consist of XAML pages and their corresponding C# code-behind files. Razor components closely resemble this pattern, with the primary difference being that Razor employs HTML as its markup language and C# code can be directly embedded within the HTML. Alternatively, we can opt to separate the C# code into a code-behind file, thus maintaining a clear distinction between the UI and its underlying logic.</p>
<h2 class="heading-2" id="_idParaDest-227">Code blocks in Razor</h2>
<p class="normal">To<a id="_idIndexMarker676"/> create the simplest Razor component, it would appear as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;h3&gt;Hello World!&lt;/h3&gt;
@code {
  // Put your C# code here
}
</code></pre>
<p class="normal">In the previous example, we can design our page similarly to an HTML page while incorporating programming logic within a code block. Razor pages or Razor components are generated as C# classes, with the filename serving as the class name. The newly created Razor components can be utilized as HTML tags in another Razor page.</p>
<h2 class="heading-2" id="_idParaDest-228">Implicit Razor expressions</h2>
<p class="normal">In <a id="_idIndexMarker677"/>Razor syntax, we can transition from HTML to C# using the <code class="inlineCode">@</code> symbol. These are referred to as implicit Razor expressions. For instance, we can use the following implicit expression to set the text of the <code class="inlineCode">label</code> tag with the C# variable <code class="inlineCode">currentUser.Username</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;label&gt;@currentUser.Username&lt;/label&gt;
</code></pre>
<p class="normal">There should be no spaces between implicit expressions. Using C# generics in implicit expressions is not possible, as the characters within the angle brackets (<code class="inlineCode">&lt;&gt;</code>) are interpreted as an HTML tag.</p>
<h2 class="heading-2" id="_idParaDest-229">Explicit Razor expressions</h2>
<p class="normal">In order<a id="_idIndexMarker678"/> to address the challenges posed by implicit expressions (e.g., white space or utilizing generics), we can employ explicit Razor expressions. These explicit expressions are composed of an <code class="inlineCode">@</code> symbol followed by parentheses. A generic method can be invoked as demonstrated in the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p&gt;@(GenericMethod&lt;int&gt;())&lt;/p&gt;
</code></pre>
<p class="normal">When we intend to concatenate text with an expression, it is necessary to employ explicit expressions, as demonstrated in the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p&gt;@(currentUser.FirstName)_@(currentUser.LastName)&lt;/p&gt;
</code></pre>
<p class="normal">In more complex scenarios, we can utilize explicit Razor expressions, like passing a lambda expression to an event handler. Let’s examine another instance of employing an explicit Razor expression when embedding HTML within C# code.</p>
<h2 class="heading-2" id="_idParaDest-230">Expression encoding</h2>
<p class="normal">Occasionally, we<a id="_idIndexMarker679"/> might need to incorporate HTML as a string within our C# code; however, the outcome could be different from what we anticipated.</p>
<p class="normal">Let’s say we write the following C# expression:</p>
<pre class="programlisting code"><code class="hljs-code">@("&lt;span&gt;Hello World!&lt;/span&gt;")
</code></pre>
<p class="normal">The result will look like this after rendering:</p>
<pre class="programlisting con"><code class="hljs-con">&amp;lt;span&amp;gt;Hello World&amp;lt;/span&amp;gt;
</code></pre>
<p class="normal">To <a id="_idIndexMarker680"/>preserve the HTML string, it is necessary to utilize the <code class="inlineCode">MarkupString</code> keyword, as demonstrated in the following:</p>
<pre class="programlisting code"><code class="hljs-code">@((MarkupString)"&lt;span&gt;Hello World&lt;/span&gt;")
</code></pre>
<p class="normal">The result of the preceding C# expression is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;span&gt;Hello World!&lt;/span&gt;
</code></pre>
<p class="normal">This is the desired output. We will delve deeper into explicit Razor expressions as we progress with the creation of Razor components.</p>
<h2 class="heading-2" id="_idParaDest-231">Directives</h2>
<p class="normal">In addition<a id="_idIndexMarker681"/> to HTML code and C# code blocks, there are reserved keywords designed for use as Razor directives. These Razor directives are denoted by implicit expressions that follow the <code class="inlineCode">@</code> symbol and contain specific reserved keywords. In the previous section, we encountered the code block represented as <code class="inlineCode">@code</code>. In this instance, <code class="inlineCode">@code</code> serves as a directive, containing the reserved keyword <code class="inlineCode">code</code>. Throughout this book, we will be using the following directives:</p>
<ul>
<li class="bulletList"><code class="inlineCode">@attribute</code>: This is used to add the given attribute to the class.</li>
<li class="bulletList"><code class="inlineCode">@code</code>: This is used to define a code block.</li>
<li class="bulletList"><code class="inlineCode">@implements</code>: This is used to implement an interface for the generated class.</li>
<li class="bulletList"><code class="inlineCode">@inherits</code>: This is used to specify the parent class for the generated class.</li>
<li class="bulletList"><code class="inlineCode">@inject</code>: This is used to inject a service using dependency injection.</li>
<li class="bulletList"><code class="inlineCode">@layout</code>: This is used to specify a layout for routable Razor components.</li>
<li class="bulletList"><code class="inlineCode">@namespace</code>: This is used to define the namespace for the generated class.</li>
<li class="bulletList"><code class="inlineCode">@page</code>: This is used to define a route for the page.</li>
<li class="bulletList"><code class="inlineCode">@using</code>: This is similar to the <code class="inlineCode">using</code> keyword in C#, which imports a namespace.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-232">Directive attributes</h2>
<p class="normal">In a <a id="_idIndexMarker682"/>Razor page, HTML tags can act as classes, and attributes can serve as members of the class. Let’s examine the following example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="currentUser.Username"&gt;
</code></pre>
<p class="normal">Here, <code class="inlineCode">input</code> is an HTML tag, which is a class. The attribute <code class="inlineCode">type</code> serves as a property of the <code class="inlineCode">input</code> tag and its value is <code class="inlineCode">text</code>, which indicates the type of this <code class="inlineCode">input</code> tag. You might have noticed another attribute, <code class="inlineCode">@bind</code>, which appears somewhat different from regular attributes. </p>
<p class="normal">It looks like a Razor implicit expression. In fact, it is an implicit expression, with <code class="inlineCode">bind</code> being a reserved keyword. This attribute functions as a directive attribute. The distinction between a Razor directive and a Razor directive attribute lies in the fact that the latter acts<a id="_idIndexMarker683"/> as an attribute for an HTML tag. Throughout this book, we will be using the following directive attributes:</p>
<ul>
<li class="bulletList"><code class="inlineCode">@bind</code>: This is used in data binding.</li>
<li class="bulletList"><code class="inlineCode">@on{EVENT}</code>: This is used in event handling.</li>
<li class="bulletList"><code class="inlineCode">@on{EVENT}:preventDefault</code>: This is used to prevent the default action for the event.</li>
<li class="bulletList"><code class="inlineCode">@on{EVENT}:stopPropagation</code>: This is used to stop event propagation.</li>
<li class="bulletList"><code class="inlineCode">@ref</code>: This is used to provide a way to reference a component instance.</li>
<li class="bulletList"><code class="inlineCode">@typeparam</code>: This is used to declare a generic type parameter.</li>
</ul>
<p class="normal">Having familiarized ourselves with the fundamental syntax of the Razor markup language, it is time to put it into practice by developing a Razor component within our application.</p>
<h1 class="heading-1" id="_idParaDest-233">Creating a Razor component</h1>
<p class="normal">In <a id="_idIndexMarker684"/>developing a .NET MAUI Blazor Hybrid application, we have the option to either construct the entire UI utilizing Blazor or combine Razor components with XAML components. We will initially explore the second option, as we have already completed a password manager application in the first part of this book.</p>
<h2 class="heading-2" id="_idParaDest-234">Redesigning the login page using a Razor component</h2>
<p class="normal">The<a id="_idIndexMarker685"/> first UI we aim to replace is the login page. We can accomplish this by utilizing a Razor page instead of the XAML page, thereby maintaining the same functionality.</p>
<p class="normal">In a Blazor Hybrid application, the <code class="inlineCode">BlazorWebView</code> serves as the control that hosts Razor components. We can modify <code class="inlineCode">LoginPage.xaml</code> to the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage 
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  xmlns:b="clr-namespace:Microsoft.AspNetCore.Components.
      WebView.Maui;
    assembly=Microsoft.AspNetCore.Components.WebView.Maui"
  xmlns:local="clr-namespace:PassXYZ.Vault.Pages"
  x:Class="PassXYZ.Vault.Views.LoginPage"
  Shell.NavBarIsVisible="False"&gt;
  &lt;b:BlazorWebView HostPage="wwwroot/login.xhtml"&gt;                  //(1)
    &lt;b:BlazorWebView.RootComponents&gt;
      &lt;b:RootComponent Selector="#login-app"                       //(3)
         ComponentType="{x:Type local:Login}" /&gt;                   //(2)
    &lt;/b:BlazorWebView.RootComponents&gt;
  &lt;/b:BlazorWebView&gt;
&lt;/ContentPage&gt;
</code></pre>
<p class="normal">On the <a id="_idIndexMarker686"/>previous page, there is only a <code class="inlineCode">BlazorWebView</code> control. We should focus on the following aspects:</p>
<p class="normal"><strong class="keyWord">(1)</strong> The <code class="inlineCode">HostPage</code> attribute is utilized to indicate the HTML page that should be loaded in <code class="inlineCode">BlazorWebView</code>. In this instance, <code class="inlineCode">login.xhtml</code> (as shown in <em class="italic">Listing 8.2</em>) is the specified page.</p>
<p class="normal">The attributes of <code class="inlineCode">RootComponent</code> specify the Razor component and CSS selector to be used:</p>
<p class="normal"><strong class="keyWord">(2)</strong> The <code class="inlineCode">ComponentType</code> attribute indicates the Razor <code class="inlineCode">Login</code> component, which we will be discussing in detail shortly.</p>
<p class="normal"><strong class="keyWord">(3)</strong> The <code class="inlineCode">Selector</code> attribute indicates the CSS selector where our web UI will be loaded. We have defined the CSS <code class="inlineCode">#login-app</code> ID in <code class="inlineCode">login.xhtml</code>. This <code class="inlineCode">login.xhtml</code> HTML page is created and saved in the <code class="inlineCode">wwwroot</code> folder. Let’s take a look at it in <em class="italic">Listing 8.2</em>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
  &lt;meta name="viewport" content="width=device-width,
    initial-scale=1.0, maximum-scale=1.0, user-scalable=no,
      viewport-fit=cover" /&gt;
  &lt;title&gt;PassXYZ.Vault Login&lt;/title&gt;
  &lt;base href="/" /&gt;
  &lt;link rel="stylesheet" 
     href="css/bootstrap/bootstrap.min.css" /&gt;
  &lt;link href="css/app.css" rel="stylesheet" /&gt;
  &lt;link href="PassXYZ.Vault.styles.css" rel="stylesheet" /&gt;
&lt;/head&gt;
&lt;body class="text-center"&gt;
  &lt;div id="login-app"&gt;Loading...&lt;/div&gt;                           //(1)
  &lt;div id="blazor-error-ui"&gt;
    An unhandled error has occurred.
    &lt;a href="" class="reload"&gt;Reload&lt;/a&gt;
    &lt;a class="dismiss"&gt;<img alt="" height="14" src="img/12.png" width="14"/>&lt;/a&gt;
  &lt;/div&gt;
  &lt;script src="img/blazor.webview.js"
      autostart="false"&gt;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="packt_figref">Listing 8.2: <code class="inlineCode">login.xhtml</code> (<a href="https://epa.ms/Login8-2">https://epa.ms/Login8-2</a>)</p>
<p class="normal">In <em class="italic">Listing 8.2</em>, we observe that it closely resembles <code class="inlineCode">index.xhtml</code>, which we have examined earlier. The CSS ID <code class="inlineCode">"</code><code class="inlineCode">login-app"</code> <strong class="keyWord">(1)</strong> is defined here, serving the purpose of loading our Razor component:</p>
<pre class="programlisting code"><code class="hljs-code">    &lt;div id="login-app"&gt;Loading…&lt;/div&gt;
</code></pre>
<p class="normal">In the .NET MAUI Blazor Hybrid app template, the default CSS framework is Bootstrap (<code class="inlineCode">bootstrap.min.css</code>). At the <a id="_idIndexMarker687"/>time of writing, the embedded Bootstrap version was 5.1. However, you might find a newer version in your project.</p>
<p class="normal">Bootstrap is a <a id="_idIndexMarker688"/>renowned framework for web development, which provides numerous examples of its usage. For instance, there is a sign-in example available on the Bootstrap website for creating a login page, as illustrated in <em class="italic">Figure 8.7</em>. We will utilize this example to construct our <code class="inlineCode">Login</code> component:</p>
<figure class="mediaobject"><img alt="Figure 7.6: Bootstrap sign-in example" height="577" src="img/B21554_08_07.png" width="506"/></figure>
<p class="packt_figref">Figure 8.7: Bootstrap sign-in example</p>
<p class="normal">You can find this sign-in example at <a href="https://getbootstrap.com/docs/5.1/examples/sign-in/">https://getbootstrap.com/docs/5.1/examples/sign-in/</a>.</p>
<p class="normal">This <a id="_idIndexMarker689"/>sign-in example includes two files:</p>
<p class="normal"><code class="inlineCode">index.xhtml</code> (<em class="italic">Listing 8.3</em>) is the UI of the sign-in page. It defines the following:</p>
<ul>
<li class="bulletList">Two <code class="inlineCode">&lt;input&gt;</code> tags for the username <strong class="keyWord">(1)</strong> and password <strong class="keyWord">(2)</strong></li>
<li class="bulletList">An <code class="inlineCode">&lt;input&gt;</code> tag <strong class="keyWord">(3)</strong> for a checkbox to remember the username</li>
<li class="bulletList">A <code class="inlineCode">&lt;button&gt;</code> tag <strong class="keyWord">(4)</strong> to process the login activity</li>
</ul>
<p class="normal">It uses Bootstrap CSS styles and its own styles defined in <code class="inlineCode">signin.css</code>.</p>
<p class="normal"><code class="inlineCode">signin.css</code> (<em class="italic">Listing 8.4</em>) defines the CSS styles specific to the sign-in page:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt; ... &lt;/head&gt;
  &lt;body class="text-center"&gt;
&lt;main class="form-signin"&gt;                                
  &lt;form&gt;
&lt;img class="mb-4" src="img/bootstrap-logo.svg"
  alt="" width="72" height="57"&gt;
    &lt;h1 class="h3 mb-3 fw-normal"&gt;Please sign in&lt;/h1&gt;
    &lt;div class="form-floating"&gt;
      &lt;input type="email" class="form-control"
        id="floatingInput" placeholder="name@example.com"&gt;         //(1)
      &lt;label for="floatingInput"&gt;Email address&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="form-floating"&gt;
      &lt;input type="password" class="form-control"
        id="floatingPassword" placeholder="Password"&gt;              //(2)
      &lt;label for="floatingPassword"&gt;Password&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="checkbox mb-3"&gt;
      &lt;label&gt;
        &lt;input type="checkbox" value="remember-me"&gt;                //(3)
        Remember me
      &lt;/label&gt;
    &lt;/div&gt;
&lt;button class="w-100 btn btn-lg btn-primary"
  type="submit"&gt;Sign in&lt;/button&gt;                                   //(4)
    &lt;p class="mt-5 mb-3 text-muted"&gt;&amp;copy; 2017–2021&lt;/p&gt;
  &lt;/form&gt;
&lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="packt_figref">Listing 8.3: <code class="inlineCode">index.xhtml</code> (Bootstrap sign-in example)</p>
<p class="normal">In <code class="inlineCode">signin.css</code> (<em class="italic">Listing 8.4</em>), we modify the <code class="inlineCode">form-signin</code> CSS class, which is used in the sign-in<a id="_idIndexMarker690"/> section of <code class="inlineCode">index.xhtml</code>:</p>
<pre class="programlisting code"><code class="hljs-code">html,
body {
  height: 100%;
}
body {
  display: flex;
  align-items: center;
  padding-top: 40px;
  padding-bottom: 40px;
  background-color: #f5f5f5;
}
.form-signin {
  width: 100%;
  max-width: 330px;
  padding: 15px;
  margin: auto;
}
.form-signin .checkbox {
  font-weight: 400;
}
.form-signin .form-floating:focus-within {
  z-index: 2;
}
.form-signin input[type="email"] {
  margin-bottom: -1px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.form-signin input[type="password"] {
  margin-bottom: 10px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}
</code></pre>
<p class="packt_figref">Listing 8.4: <code class="inlineCode">signin.css</code> (Bootstrap sign-in example)</p>
<p class="normal">To <a id="_idIndexMarker691"/>create a new Razor component, first, a folder named <code class="inlineCode">Pages</code> needs to be created within the project. Next, right-click on the newly created <code class="inlineCode">Pages</code> folder in Visual Studio and select <strong class="screenText">Add</strong> | <strong class="screenText">Razor Component</strong>…. Name this component <code class="inlineCode">Login.razor</code> and proceed to create the file. Once created, copy the part between the <code class="inlineCode">&lt;main&gt;</code> tag from <em class="italic">Listing 8.3</em> and paste it into the Razor page within a <code class="inlineCode">&lt;div&gt;</code> tag, as demonstrated in <em class="italic">Listing 8.5</em>:</p>
<pre class="programlisting code"><code class="hljs-code">@using System.Diagnostics
@using PassXYZ.Vault.Services
@using PassXYZ.Vault.ViewModels
@inject LoginViewModel viewModel                                  //(1)
@inject LoginService currentUser                                  //(2)
&lt;div&gt;
  &lt;main class="form-signin"&gt;
    &lt;form&gt;
      &lt;img class="mb-4"...&gt;
      &lt;h1 class="h3 mb-3 fw-normal"&gt;Please sign in&lt;/h1&gt;
      &lt;div class="form-floating"&gt;
        &lt;label for="floatingInput"&gt;Username&lt;/label&gt;
        &lt;input type="text" @bind="@currentUser.Username"          //(3)
          class="form-control" id="floatingInput"
          placeholder="Username"&gt;
      &lt;/div&gt;
      &lt;div class="form-floating"&gt;
        &lt;label for="floatingPassword"&gt;Password&lt;/label&gt;
        &lt;input type="password" 
          @bind="@currentUser.Password" class="form-control"
          id="floatingPassword" placeholder="Password"&gt;           //(4)
      &lt;/div&gt;
      &lt;div class="checkbox mb-3"&gt;
        &lt;label&gt;
          &lt;input type="checkbox" value="remember-me"&gt;
              Remember me
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button class="w-100 btn btn-lg btn-primary"
          type="submit" @onclick="OnLogin"&gt;Sign in&lt;/button&gt;
      &lt;p class="mt-5 mb-3 text-muted"&gt;&amp;copy; 2017–2021&lt;/p&gt;
    &lt;/form&gt;
  &lt;/main&gt;
&lt;/div&gt;
@code {
  protected override void OnInitialized() { 
  }
  private void OnLogin(MouseEventArgs e) {
viewModel.Username = currentUser.Username;
viewModel.Password = currentUser.Password;
    viewModel.LoginCommand.Execute(null);                 
  }
}
</code></pre>
<p class="packt_figref">Listing 8.5: <code class="inlineCode">Login.razor</code></p>
<p class="normal">We employ the directive inject to instantiate <code class="inlineCode">LoginViewModel</code> as the <code class="inlineCode">viewModel</code> variable <strong class="keyWord">(1)</strong>, and <code class="inlineCode">LoginService</code> as the <code class="inlineCode">currentUser</code> variable <strong class="keyWord">(2)</strong>. This enables us to reference the <code class="inlineCode">Username</code> <strong class="keyWord">(3)</strong> and <code class="inlineCode">Password</code> <strong class="keyWord">(4)</strong> properties of<code class="inlineCode"> currentUser</code> in the HTML via the <code class="inlineCode">@</code> symbol. Similarly, we can<a id="_idIndexMarker692"/> define the <code class="inlineCode">OnLogin</code> event handler and associate it with the <code class="inlineCode">onclick</code> event.</p>
<p class="normal">Upon entering their username and password, the <code class="inlineCode">currentUser</code> properties are populated accordingly. When the login button is clicked, the <code class="inlineCode">OnLogin</code> function is triggered. Consequently, the view model’s <code class="inlineCode">LoginCommand</code> is executed to initiate the login process.</p>
<h2 class="heading-2" id="_idParaDest-235">The Model-View-ViewModel (MVVM) pattern in Blazor</h2>
<p class="normal">One of <a id="_idIndexMarker693"/>the benefits of utilizing Blazor for UI design<a id="_idIndexMarker694"/> is that it allows us to create most of the UI using HTML initially. After ensuring the UI design meets our expectations, we can then implement the programming logic. By employing the MVVM pattern, which <a id="_idIndexMarker695"/>we explored in <em class="chapterRef">Chapter 3</em>, <em class="italic">User Interface Design with XAML</em>, we can effectively separate responsibilities within the Razor component development. For a Razor component, we can consider the HTML markup as the view and the code block as the ViewModel. Should the logic in the code block become overly complex, we have the option to separate it into a C# code-behind file.</p>
<p class="normal">On the login page, we may proceed with utilizing the <code class="inlineCode">LoginViewModel</code> from the XAML domain. This is made possible by the transition from Blazor to the XAML UI occurring within <code class="inlineCode">LoginViewModel</code>. The primary objective is to demonstrate the seamless integration of Blazor and XAML UIs within a single application. In the subsequent chapter, we will completely replace the XAML UI with the Blazor UI.</p>
<p class="normal">In a Razor component, it is possible to incorporate both HTML and C# within a single file or divide them between a Razor file and a C# code-behind file, similar to XAML.</p>
<p class="normal">Let’s apply this concept to <code class="inlineCode">Login.razor</code>. By splitting it into two files, the component will be divided into two partial classes found in <code class="inlineCode">Login.razor</code> and <code class="inlineCode">Login.razor.cs</code>, as demonstrated in <em class="italic">Listing 8.6</em> and <em class="italic">Listing 8.7</em>:</p>
<pre class="programlisting code"><code class="hljs-code">@namespace PassXYZ.Vault.Pages
&lt;div&gt;
  &lt;main class="form-signin"&gt;
    &lt;form&gt;
      &lt;img class="mb-4"...&gt;
      &lt;h1 class="h3 mb-3 fw-normal"&gt;Please sign in&lt;/h1&gt;
      &lt;div class="form-floating"&gt;
        &lt;label for="floatingInput"&gt;Username&lt;/label&gt;
        &lt;input type="text" @bind="@currentUser.Username"
            class="form-control" id="floatingInput"
                placeholder="Username"&gt;
      &lt;/div&gt;
      &lt;div class="form-floating"&gt;
        &lt;label for="floatingPassword"&gt;Password&lt;/label&gt;
        &lt;input type="password" @bind="@currentUser.
            Password" class="form-control"
              id="floatingPassword" placeholder="Password"&gt;
      &lt;/div&gt;
      &lt;div class="checkbox mb-3"&gt;
        &lt;label&gt;
          &lt;input type="checkbox" value="remember-me"&gt; Remember me
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button class="w-100 btn btn-lg btn-primary"
          type="submit" @onclick="OnLogin"&gt;Sign in&lt;/button&gt;
      &lt;p class="mt-5 mb-3 text-muted"&gt;&amp;copy; 2021–2022&lt;/p&gt;
    &lt;/form&gt;
  &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p class="packt_figref">Listing 8.6: <code class="inlineCode">Login.razor</code> (<a href="https://epa.ms/Login8-6">https://epa.ms/Login8-6</a>)</p>
<p class="normal">In <em class="italic">Listing 8.6</em>, the <a id="_idIndexMarker696"/>HTML markup is solely present in <code class="inlineCode">Login.razor</code>, which effectively separates the UI from the underlying logic, resulting<a id="_idIndexMarker697"/> in a cleaner design. Now, let’s <a id="_idIndexMarker698"/>examine the corresponding C# code in <em class="italic">Listing 8.7</em>:</p>
<pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components;
using System.Diagnostics;
using PassXYZ.Vault.Services;
using PassXYZ.Vault.ViewModels;
using Microsoft.AspNetCore.Components.Web;
namespace PassXYZ.Vault.Pages;
public partial class Login : ComponentBase {
  [Inject]
  LoginViewModel viewModel { get; set; } = default!;
  [Inject]
  LoginService currentUser { get; set; } = default!;
  protected override void OnInitialized()
  {
  }
  private void OnLogin(MouseEventArgs e)
  {
      viewModel.Username = currentUser.Username;
      viewModel.Password = currentUser.Password;
      viewModel.LoginCommand.Execute(null);
  }
}
</code></pre>
<p class="packt_figref"><em class="italic">Listing 8.7</em>: <code class="inlineCode">Login.razor.cs</code> (<a href="https://epa.ms/Login8-7">https://epa.ms/Login8-7</a>)</p>
<p class="normal">In <em class="italic">Listing 8.7</em>, we have transferred all the code from the <code class="inlineCode">@code</code> block to the C# file within the <code class="inlineCode">Login</code> class, which inherits from the <code class="inlineCode">ComponentBase</code> class. All Razor components inherit from <code class="inlineCode">ComponentBase</code>.</p>
<p class="normal">You might <a id="_idIndexMarker699"/>have observed<a id="_idIndexMarker700"/> the usage of the <code class="inlineCode">Inject</code> attribute in the declaration <a id="_idIndexMarker701"/>of the <code class="inlineCode">viewModel</code> and <code class="inlineCode">currentUser</code> properties. These properties are initialized using dependency injection.</p>
<h2 class="heading-2" id="_idParaDest-236">Dependency injection in Blazor</h2>
<p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Software Design with Dependency Injection</em>, we introduced how to use dependency injection in .NET MAUI development. All the concepts presented in that chapter are equally <a id="_idIndexMarker702"/>applicable here; however, Blazor offers additional features. With <a id="_idIndexMarker703"/>Blazor, we can utilize <a id="_idIndexMarker704"/>dependency injection in both HTML and C# code.</p>
<p class="normal">As demonstrated in <em class="italic">Listing 8.5</em>, the following declaration is defined at the beginning of the <code class="inlineCode">Login.razor</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">@inject LoginViewModel viewModel
</code></pre>
<p class="normal">In the preceding code, we initialize the <code class="inlineCode">viewModel</code> property through dependency injection. This approach employs property injection using the Razor directive, which has become more straightforward to use in Blazor than in previous versions.</p>
<p class="normal">When we move it to the C# code-behind file, we can use the <code class="inlineCode">Inject</code> attribute to do the same:</p>
<pre class="programlisting code"><code class="hljs-code">    [Inject]
    LoginViewModel viewModel { get; set; } = default!;
</code></pre>
<p class="normal">In web development, we frequently utilize HTML and CSS in conjunction to design UIs for websites. In the Bootstrap example, a <code class="inlineCode">signin.css</code> file is present. Now, where should we store our CSS styles? We will explore this topic in the subsequent section.</p>
<h2 class="heading-2" id="_idParaDest-237">CSS isolation</h2>
<p class="normal">In the earlier<a id="_idIndexMarker705"/> discussion of the Bootstrap sign-in example, we mentioned the presence of an HTML file and a CSS file. Now, the question arises – where <a id="_idIndexMarker706"/>should the CSS file be placed in order to effectively reuse the sign-in CSS styles on our login page?</p>
<p class="normal">In HTML design, using a CSS framework like Bootstrap may require customization of styles at the page level. To facilitate this in Blazor, a technique called CSS isolation for Razor components is employed. For CSS styles specific to a component or page, we can store them in a file with the <code class="inlineCode">.razor.css</code> extension. The filename should correspond to the <code class="inlineCode">.razor</code> file in the same folder. For instance, on our login page, we can copy the <code class="inlineCode">sign-in.css</code> file from the Bootstrap example to <code class="inlineCode">Login.razor.css</code>, making minor adjustments as demonstrated in <em class="italic">Listing 8.8</em>:</p>
<pre class="programlisting code"><code class="hljs-code">div {
    display: flex;
    align-items: center;
    background-color: #f5f5f5;
}
.form-signin {
    width: 100%;
    max-width: 330px;
    padding: 15px;
    margin: auto;
}
.form-signin .checkbox {
    font-weight: 400;
}
.form-signin .form-floating:focus-within {
    z-index: 2;
}
.form-signin input[type="email"] {
    margin-bottom: -1px;
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
}
.form-signin input[type="password"] {
    margin-bottom: 10px;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
}
#first {
    margin-top: 3em;
}
</code></pre>
<p class="packt_figref">Listing 8.8: <code class="inlineCode">Login.razor.css</code> (<a href="https://epa.ms/Login8-8">https://epa.ms/Login8-8</a>)</p>
<p class="normal">The styles defined in <code class="inlineCode">Login.razor.css</code> are only applied to the rendered output of the <code class="inlineCode">Login</code> component. Finally, let’s look at this new login UI in Blazor:</p>
<figure class="mediaobject">s<img alt="A screenshot of a phone  Description automatically generated" height="554" src="img/B21554_08_08.png" width="825"/></figure>
<p class="packt_figref">Figure 8.8: Sign in page</p>
<p class="normal">In <em class="italic">Figure 8.8</em>, from<a id="_idIndexMarker707"/> left to right, we can see the login page on<a id="_idIndexMarker708"/> Windows, iOS, and Android. We observe that the look and feel of this new UI closely resemble the Bootstrap sign-in example, with the exception of a modified icon. The login functionality remains unchanged; however, we employed Blazor to develop a new UI.</p>
<p class="normal">As the Blazor UI is constructed using web technologies, the appearance and user experience are consistent across different platforms. For instance, in the Android screenshot, you can see an overlap of the input fields with the placeholders upon entering the username and password. This behavior aligns with what you would encounter on all three platforms. Though this issue isn’t present on the desktop browser, BlazorWebView’s behavior does <a id="_idIndexMarker709"/>present some discrepancies compared with traditional desktop browsers. Therefore, while the Blazor UI maintains consistency across various platforms, it may behave differently when accessed through different browsers.</p>
<p class="normal">Upon logging in using this Razor page, the subsequent programming logic continues to align with what was demonstrated in <em class="chapterRef">Chapter 6</em>, <em class="italic">Software Design with Dependency Injection</em>. After the login process, the UI framework reverts to XAML as no other modifications have been made thus far.</p>
<p class="normal">The code in this <a id="_idIndexMarker710"/>chapter illustrates the potential to combine a Blazor UI and XAML-based UI within a single application. However, it is advisable to avoid this approach unless there are no other alternatives available. As depicted in <em class="italic">Figure 8.8</em>, Blazor and XAML UIs employ different technologies, which can present unique challenges during development. By mixing them, we essentially inherit the issues from both types of UI. This could introduce unforeseen complications in the design and development process of the UI.</p>
<h1 class="heading-1" id="_idParaDest-238">Summary</h1>
<p class="normal">In this chapter, we explored Blazor and how to develop a Blazor Hybrid app. Blazor serves as an alternative solution for UI design within .NET MAUI. The primary distinction between Blazor and XAML lies in their appearance: while the XAML UI closely resembles the native interface, the Blazor UI adopts the aesthetics of a web app. Functionality-wise, both offer similar capabilities. Moreover, it is possible to integrate Blazor and XAML within a single app and utilize the MVVM pattern in both.</p>
<p class="normal">An advantage of using Blazor is the ability to share UI code between the Blazor Hybrid app and a web app. If you seek a solution compatible with both native and web apps, .NET MAUI Blazor could be an ideal choice.</p>
<p class="normal">In the upcoming chapter, we will transition to using Blazor for all UIs within our app. Additionally, we will discuss the initial UI design using layout and routing techniques.</p>
<h1 class="heading-1" id="_idParaDest-239">Further reading</h1>
<ul>
<li class="bulletList">ASP.NET Core updates in .NET 8 Preview 2: <a href="https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter">https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter</a></li>
<li class="bulletList">ASP.NET Core updates in .NET 8 Preview 7: <a href="https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode">https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode</a></li>
<li class="bulletList">What’s new in ASP.NET Core 8.0: <a href="https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0">https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0</a></li>
<li class="bulletList">ASP.NET Core Blazor hosting models: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0">https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0</a></li>
<li class="bulletList">ASP.NET Core Blazor render modes: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0">https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0</a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/cross-platform-app">https://packt.link/cross-platform-app</a></p>
<p class="normal"><img alt="" height="354" src="img/QR_Code166522361691420406.png" style="width:10em;" width="354"/></p>
</div>
</div></body></html>