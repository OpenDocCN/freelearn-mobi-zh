- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building User Screen Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the Android activity lifecycle and explains how the Android
    system interacts with your app. By the end of this chapter, you’ll have learned
    how to build user journeys through different screens. You’ll also be able to use
    activity tasks and launch modes, save and restore the state of your activity,
    use logs to report on your application, and share data between screens.
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapter introduced you to the core elements of Android development,
    from configuring your app using the `AndroidManifest.xml` file, working with simple
    activities, and the Android resource structure to building an app with `gradle`
    and running an app on a virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll go further and learn how the Android system interacts
    with your app through the Android lifecycle, how you are notified of changes to
    your app’s state, and how you can use the Android lifecycle to respond to these
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll then progress to learning how to create user journeys through your app
    and how to share data between screens. You’ll be introduced to different techniques
    to achieve these goals so that you’ll be able to use them in your own apps and
    recognize them when you see them used in other apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Activity lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and restoring the Activity state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity interaction with Intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intents, Tasks, and Launch Modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/PmKJ6](https://packt.link/PmKJ6)
  prefs: []
  type: TYPE_NORMAL
- en: The Activity lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used the `onCreate(saveInstanceState: Bundle?)`
    method to display a layout in the UI of our screen. Now, we’ll explore in more
    detail how the Android system interacts with your application to make this happen.
    As soon as an Activity is launched, it goes through a series of steps to take
    it through initialization, from preparing to be displayed to being partially displayed
    and then fully displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also steps that correspond with your application being hidden, backgrounded,
    and then destroyed. This process is called the **Activity lifecycle**. For every
    one of these steps, there is a **callback** that your Activity can use to perform
    actions such as creating and changing the display and saving data when your app
    has been put into the background and then restoring that data after your app comes
    back into the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: These callbacks are made on your Activity’s parent, and it’s up to you to decide
    whether you need to implement them in your own Activity to take any corresponding
    action. Each of these callback functions has the `override` keyword. The `override`
    keyword in Kotlin means that either this function is providing an implementation
    of an interface or an abstract method, or, in the case of your Activity here,
    which is a subclass, it is providing the implementation that will override its
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how the Activity lifecycle works in general, let’s go into
    more detail about the principal callbacks you will work with in order, from creating
    an Activity to the Activity being destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`override fun onCreate(savedInstanceState: Bundle?)`: This is the callback
    that you will use the most for activities that draw a full-sized screen. It’s
    here where you prepare your Activity layout to be displayed. At this stage, after
    the method has completed, it is still not displayed to the user, although it will
    appear that way if you don’t implement any other callbacks. You usually set up
    the UI of your Activity here by calling the `setContentView(R.layout.activity_main)`
    method and carrying out any initialization that is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is only called once in its lifecycle unless the Activity is created
    again. This happens by default for some actions (such as rotating the phone from
    portrait to landscape orientation). The `savedInstanceState` parameter of the
    `Bundle?` type (`?` means the type can be null) in its simplest form is a map
    of key-value pairs optimized to save and restore data.
  prefs: []
  type: TYPE_NORMAL
- en: It will be null if this is the first time that the Activity has been run after
    the app has started, if the Activity is being created for the first time, or if
    the Activity is being recreated without any states being saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`override fun onRestart()`: When the Activity restarts, this is called immediately
    before `onStart()`. It is important to be clear about the difference between restarting
    an Activity and recreating an activity. When the Activity is backgrounded by pressing
    the home button, when it comes back into the foreground again `onRestart()` will
    be called. Recreating an Activity is what happens when a configuration change
    happens, such as the device being rotated. The Activity is finished and then created
    again, in which case `onRestart()` will not be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onStart()`: This is the first callback made when the Activity
    is brought from the background to the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onRestoreInstanceState(savedInstanceState: Bundle?)`: If the
    state has been saved using `onSaveInstanceState(outState: Bundle?)`, this is the
    method that the system calls after `onStart()` where you can retrieve the `Bundle`
    state instead of restoring the state using `onCreate(savedInstanceState: Bundle?)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onResume()`: This callback is run as the final stage of creating
    an Activity for the first time, and also when the app has been backgrounded and
    then is brought into the foreground. Upon the completion of this callback, the
    screen/activity is ready to be used, receive user events, and be responsive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onSaveInstanceState(outState: Bundle?)`: If you want to save
    the state of the activity, this function can do so. You add key-value pairs using
    one of the convenience functions depending on the data type. The data will then
    be available if your Activity is recreated in `onCreate(saveInstanceState: Bundle?)`
    and `onRestoreInstanceState(savedInstanceState: Bundle?)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onPause()`: This function is called when the Activity starts
    to be backgrounded or another dialog or Activity comes into the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onStop()`: This function is called when the Activity is hidden,
    either because it is being backgrounded or another Activity is being launched
    on top of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override fun onDestroy()`: This is called by the system to kill the Activity
    when system resources are low, when `finish()` is called explicitly on the Activity,
    or, more commonly, when the Activity is killed by the user closing the app from
    the recents/overview button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow of callbacks/events is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Activity lifecycle](img/B19411_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Activity lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what these common lifecycle callbacks do, let’s implement
    them to see when they are called.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.01 – logging the Activity Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an application called `Activity Callbacks` with an empty Activity. The
    aim of this exercise is to log the Activity callbacks and the order that they
    occur for common operations:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to verify the order of the callbacks, let’s add a log statement at
    the end of each callback. Open up `MainActivity` and prepare the Activity for
    logging by adding `import android.util.Log` to the `import` statements. Then,
    add a constant to the class to identify your Activity. Constants in Kotlin are
    identified by the `const` keyword and can be declared at the top level (outside
    the class) or in an object within the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Top-level constants are generally used if they are required to be public. For
    private constants, Kotlin provides a convenient way to add static functionality
    to classes by declaring a companion object. Add the following at the bottom of
    the class below `onCreate(savedInstanceState: Bundle?)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a log statement at the end of `onCreate(savedInstanceState: Bundle?)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Activity should now have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`d` in the preceding log statement refers to *debug*. There are six different
    log levels that can be used to output message information from the least to most
    important – `v` for *verbose*, `d` for *debug*, `i` for *info*, `w` for *warn*,
    `e` for *error*, and `wtf` for *what a terrible failure* (this last log level
    highlights an exception that should never occur):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see how the logs are displayed in Android Studio. Open the **Logcat**
    window. It can be accessed by clicking on the **Logcat** tab at the bottom of
    the screen and also from the toolbar by going to **View** | **Tool Windows** |
    **Logcat**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on the virtual device and examine the **Logcat** window output.
    You should see the log statement you have added formatted like the following line
    in *Figure 2**.2*. If the **Logcat** window looks different, you might have to
    enable the newest version of **Logcat** by going to **Android Studio** | **Settings**
    | **Experimental** and checking the box that says **Enable New Logcat** **Tool
    Window**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Log output in Logcat](img/B19411_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Log output in Logcat
  prefs: []
  type: TYPE_NORMAL
- en: 'Log statements can be quite difficult to interpret at first glance, so let’s
    break down the following statement into its separate parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the elements of the log statement in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| **Date** | `2023-01-14` |'
  prefs: []
  type: TYPE_TB
- en: '| **Time** | `16:47:12.330` |'
  prefs: []
  type: TYPE_TB
- en: '| **Process identifier and thread identifier (your app process ID and current**
    **thread ID)** | `26715-26715` |'
  prefs: []
  type: TYPE_TB
- en: '| **Class name** | `MainActivity` |'
  prefs: []
  type: TYPE_TB
- en: '| **Package name** | `com.example.activitycallbacks` |'
  prefs: []
  type: TYPE_TB
- en: '| **Log level** | `D (``for Debug)` |'
  prefs: []
  type: TYPE_TB
- en: '| **Log message** | `onCreate` |'
  prefs: []
  type: TYPE_TB
- en: Figure 2.3 – Table explaining a log statement
  prefs: []
  type: TYPE_NORMAL
- en: By default, in the log filter (the text box above the log window), it says `package:mine`,
    which is your app logs. You can examine the output of the different log levels
    of all the processes on the device by changing the log filter from `level:debug`
    to other options in the drop-down menu. If you select `level:verbose`, as the
    name implies, you will see a lot of output.
  prefs: []
  type: TYPE_NORMAL
- en: '5. What’s great about the `tag` option of the log statement is that it enables
    you to filter the log statements that are reported in the `tag` followed by the
    text of the tag, `tag:MainActivity`, as shown in *Figure 2**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Filtering log statements by the tag name](img/B19411_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Filtering log statements by the tag name
  prefs: []
  type: TYPE_NORMAL
- en: So, if you are debugging an issue in your Activity, you can type in the tag
    name and add logs to your Activity to see the sequence of log statements. This
    is what you are going to do next by implementing the principal Activity callbacks
    and adding a log statement to each one to see when they are run.
  prefs: []
  type: TYPE_NORMAL
- en: '6. Place your cursor on a new line after the closing brace of the `onCreate(savedInstanceState:
    Bundle?)` function and then add the `onRestart()` callback with a log statement.
    Make sure you call through to `super.onRestart()` so that the existing functionality
    of the Activity callback works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, you can start typing the name of a function and autocomplete
    options will pop up with suggestions for functions to override. Alternatively,
    if you go to the top menu and then **Code** | **Generate** | **Override methods**,
    you can select the methods to override.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do this for all of the following callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '7. The completed activity will now override the callbacks with your implementation,
    which adds a log message. The following truncated code snippet shows a log statement
    in `onCreate(savedInstanceState: Bundle?)`. The complete class is available at
    [https://packt.link/Lj2GT](https://packt.link/Lj2GT):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '8. Run the app, and then once it has loaded, as in *Figure 2**.5*, look at
    the **Logcat** output; you should see the following log statements (this is a
    shortened version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Activity has been created, started, and then prepared for the user to interact
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The app loaded and displaying MainActivity](img/B19411_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The app loaded and displaying MainActivity
  prefs: []
  type: TYPE_NORMAL
- en: '9. Press the round home button in the center of the navigation controls in
    the emulator window above the virtual device and background the app. Not all devices
    use the same three-button navigation of *back* (triangle icon), *home* (circle
    icon), and *recents/overview* (square icon). Gesture navigation can also be enabled
    so all these actions can be achieved by swiping and optionally holding. You should
    now see the following **Logcat** output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For apps that target versions below Android Pie (API 28), `onSaveInstanceState(outState:
    Bundle)` may also be called before `onPause()` or `onStop()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '10. Now, bring the app back into the foreground by pressing the recents/overview
    square button in the emulator controls and selecting the app. You should now see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Activity has been restarted. You might have noticed that the `onRestoreInstance`
    **State(savedInstanceState: Bundle)** function was not called. This is because
    the Activity was not destroyed and recreated.'
  prefs: []
  type: TYPE_NORMAL
- en: '11. Press the recents/overview square button again and then swipe the app image
    upward to kill the activity. This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 12. Launch your app again and then rotate the phone. You might find that the
    phone does not rotate, and the display is sideways. If this happens, drag down
    the status bar at the very top of the virtual device, look for a button with a
    rectangular icon with arrows called **Auto-rotate**, and select it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected](img/B19411_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that as stated in step 9, the order of the `onSaveInstanceState(outState:
    Bundle)` callback may vary.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration changes, such as rotating the phone, by default recreate the activity.
    You can choose not to handle certain configuration changes in the app, which will
    then not recreate the activity.
  prefs: []
  type: TYPE_NORMAL
- en: '13. To not recreate the activity for rotation, add `android:configChanges=`
    **"orientation|screenSize|screenLayout"** to `MainActivity` in the `AndroidManifest.xml`
    file. Launch the app and then rotate the phone, and these are the only callbacks
    that you have added to `MainActivity` that you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `orientation` and `screenSize` values have the same function for different
    Android API levels for detecting screen orientation changes. The `screenLayout`
    value detects other layout changes that might occur on foldable phones.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the config changes you can choose to handle yourself (another
    common one is `keyboardHidden` to react to changes in accessing the keyboard).
    The app will still be notified by the system of these changes through the following
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you add this callback function to `MainActivity`, and you have added `android:`
    **configChanges="orientation|screenSize|screenLayout"** to `Main` **Activity**
    in the manifest, you will see it called on rotation.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of not restarting the activity is not recommended as the system
    will not apply alternative resources automatically. So, rotating a device from
    portrait to landscape won’t apply a suitable landscape layout.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned about the principal Activity callbacks and
    how they run when a user carries out common operations with your app through the
    system’s interaction with `MainActivity`. In the next section, we will cover saving
    the state and restoring it, as well as see more examples of how the Activity lifecycle
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and restoring the Activity state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll explore how your Activity saves and restores the state.
    As you’ve learned in the previous section, configuration changes, such as rotating
    the phone, cause the Activity to be recreated. This can also happen if the system
    has to kill your app in order to free up memory.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, it is important to preserve the state of the Activity and
    then restore it. In the next two exercises, you’ll work through an example ensuring
    that the user’s data is restored when `TextView` is created and populated from
    a user’s data after filling in a form.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.02 – saving and restoring the state in layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, firstly create an application called `Save and Restore` with
    an empty activity. The app you are going to create will have a simple form that
    offers a discount code for a user’s favorite restaurant if they enter some personal
    details (no actual information will be sent anywhere, so your data is safe):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `strings.xml` file (located in `app` | `src` | `main` | `res` |
    `values` | `strings.xml`) and add the following strings that you’ll need for your
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `R.layout.activity_main`, replace the contents with the following XML that
    creates a containing layout file and adds a `TextView` header with the text `Enter
    your name and email for a discount code at Your Favorite Restaurant!` This is
    done by adding the `android:text` attribute with the `@``string/header_text` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see here that `android:textSize` is specified in `sp` which stands
    for Scale-independent pixels. This unit type represents the same values as density-independent
    pixels, which define the size measurement according to the density of the device
    that your app is being run on, and also change the text size according to the
    user’s preference, defined in **Settings** | **Display** | **Font style** (this
    might be **Font size and style** or something similar, depending on the exact
    device you are using).
  prefs: []
  type: TYPE_NORMAL
- en: Other attributes in the layout affect positioning. The most common ones are
    padding and margin. Padding is applied on the inside of Views and is the space
    between the text and the border. Margins are specified on the outside of Views
    and are the space from the outer edges of Views. For example, `android:padding`
    sets the padding for the View with the specified value on all sides. Alternatively,
    you can specify the padding for one of the four sides of a View with `android:paddingTop`,
    `android:paddingBottom`, `android:paddingStart`, and `android:paddingEnd`. This
    pattern also exists to specify margins, so `android:layout_margin` specifies the
    margin value for all four sides of a View, and `android:layout_marginTop`, `android:layout_marginBottom`,
    `android:layout_marginStart`, and `android:layout_marginEnd` allow setting the
    margin for individual sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have consistency and uniformity throughout the app with these positioning
    values, you can define the margin and padding values as dimensions contained within
    a `dimens.xml` file so they can be used in multiple layouts. A dimension value
    of `<dimen name="grid_4">4dp</dimen>` can then be used as a View attribute like
    this: `android:paddingStart="@dimen/grid_4"`. To position the content within a
    View, you can specify `android:gravity`. The `center` value constrains the content
    both vertically and horizontally within the View.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add three `EditText` views below `header_text` for the user to add their
    first name, last name, and email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `EditText` fields have an `inputType` attribute to specify the type of input
    that can be entered into the form field. Some values, such as `number` on `EditText`,
    restrict the input that can be entered into the field, and on selecting the field,
    suggest how the keyboard is displayed. Others, such as `android:inputType="textEmailAddress"`,
    will not enforce an `@` symbol being added to the form field, but will give a
    hint to the keyboard to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add a button for the user to press to generate a discount code, a
    `TextView` to display the discount code, and a `TextView` for the confirmation
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are also some attributes that you haven’t seen before. The `xmlns:tools="http://schemas.android.com/tools"`
    tools namespace, which was specified at the top of the XML layout file, enables
    certain features that can be used when creating your app to assist with configuration
    and design.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes are removed when you build your app, so they don’t contribute
    to the overall size of the app. You are using the `tools:text` attribute to show
    the text that will typically be displayed in the form fields. This helps when
    you switch to the `Design` view from viewing the XML in the `Code` view in Android
    Studio as you can see an approximation of how your layout displays on a device.
  prefs: []
  type: TYPE_NORMAL
- en: Run the app and you should see the output displayed in *Figure 2**.7*. The **GET
    DISCOUNT** button has not been enabled and so currently will not do anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The Activity screen on the first launch](img/B19411_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The Activity screen on the first launch
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter some text into each of the form fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The EditText fields filled in](img/B19411_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The EditText fields filled in
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the second rotate button in the virtual device controls (![](img/B19411_02_08.png))
    to rotate the phone 90 degrees to the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The virtual device turned to landscape orientation](img/B19411_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The virtual device turned to landscape orientation
  prefs: []
  type: TYPE_NORMAL
- en: Can you spot what has happened? The `EditText` fields, the Android framework
    will preserve the state of the fields if they have an ID set on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `activity_main.xml` layout file and add an ID to the `Last Name`
    `EditText` which appears below the `First` `Name` `EditText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run up the app again and rotate the device, it will preserve the value
    you have entered. You’ve now seen that you need to set an ID on the `EditText`
    fields to preserve the state. For the `EditText` fields, it’s common to retain
    the state on a configuration change when the user is entering details into a form
    so that it is the default behavior if the field has an ID.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you want to get the details of the `EditText` field once the user
    has entered some text, which is why you set an ID, but setting an ID for other
    field types, such as `TextView`, does not retain the state if you update them
    and you need to save the state yourself. Setting IDs for Views that enable scrolling,
    such as `RecyclerView`, is also important as it enables the scroll position to
    be maintained when the Activity is recreated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have defined the layout for the screen, but you have not added any
    logic for creating and displaying the discount code. In the next exercise, we
    will work through this.
  prefs: []
  type: TYPE_NORMAL
- en: The layout created in this exercise is available at [https://packt.link/ZJleK](https://packt.link/ZJleK).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the entire exercise at [https://packt.link/Kh0kR](https://packt.link/Kh0kR).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.03 – saving and restoring the state with Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to bring all the UI elements in the layout together
    to generate a discount code after the user has entered their data. In order to
    do this, you will have to add logic to the button to retrieve all the `EditText`
    fields and then display a confirmation to the user, as well as generate a discount
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `MainActivity.kt` and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get() = …` is a custom accessor for a property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking the discount button, you retrieve the values from the `first_name`
    and `last_name` fields, concatenate them with a space, and then use a string resource
    to format the discount code confirmation text. The string you reference in the
    `strings.xml` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%s` value specifies a string value to be replaced when the string resource
    is retrieved. This is done by passing in the full name when getting the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code is generated by using the `java.util` package. This creates a unique
    ID, and then the `take()` Kotlin function is used to get the first eight characters
    before setting these to uppercase. Finally, `discountCode` is set in the view,
    the keyboard is hidden, and all the form fields are set back to their initial
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and enter some text into the name and email fields, and then click
    on `GET DISCOUNT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Screen displayed after the user has generated a discount code](img/B19411_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Screen displayed after the user has generated a discount code
  prefs: []
  type: TYPE_NORMAL
- en: The app behaves as expected, showing the confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rotate the phone by pressing the second rotate button (![](img/B19411_02_081.png))
    in the emulator controls and observe the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Discount code no longer displaying on the screen](img/B19411_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Discount code no longer displaying on the screen
  prefs: []
  type: TYPE_NORMAL
- en: Oh, no! The discount code has gone. The `TextView` fields do not retain the
    state, so you will have to save the state yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back into `MainActivity.kt` and add the following Activity callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These callbacks, as the names declare, enable you to save and restore the instance
    state. `on` **SaveInstanceState(outState: Bundle)** allows you to add key-value
    pairs from your Activity when it is being backgrounded or destroyed, which you
    can retrieve in either `onCreate(savedInstanceState: Bundle?)` or `onRestoreInstanceState`
    **(**`savedInstanceState: Bundle)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you have two callbacks to retrieve the state once it has been set. If you
    are doing a lot of initialization in `onCreate(savedInstanceState: Bundle)`, it
    might be better to use `onRestoreInstanceState(savedInstanceState: Bundle)` to
    retrieve this instance state when your Activity is being recreated. In this way,
    it’s clear which state is being recreated. However, you might prefer to use `onCreate(savedInstanceState:
    Bundle)` if there is minimal setup required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever of the two callbacks you decide to use, you will have to get the
    state you set in the `onSaveInstanceState(outState: Bundle)` call. For the next
    step in the exercise, you will use `onRestoreInstanceState(savedInstanceState:
    Bundle)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two constants to the `MainActivity` companion object, which is at the bottom
    of `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add these constants as keys for the values you want to save and retrieve
    and make the following changes to the Activity in the `onSaveInstanceState(outState:
    Bundle)` and `onRestoreInstanceState(savedInstanceState:` `Bundle)` functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the app, enter the values into the `EditText` fields, and then generate
    a discount code. Then, rotate the device and you will see that the discount code
    is restored in *Figure 2**.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Discount code continues to be displayed on the screen](img/B19411_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Discount code continues to be displayed on the screen
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you first saw how the state of the `EditText` fields is maintained
    on configuration changes. You also saved and restored the instance state using
    the Activity lifecycle `onSaveInstanceState(outState: Bundle)` and `onCreate(savedInstanceState:
    Bundle?)`/`onRestoreInstanceState(savedInstanceState: Bundle)` functions. These
    functions provide a way to save and restore simple data. The Android framework
    also provides `ViewModel`, an Android architecture component that is lifecycle-aware.
    The mechanisms of how to save and restore this state (with `ViewModel`) are managed
    by the framework, so you don’t have to explicitly manage it as you have done in
    the preceding example. You will learn how to use this component in [*Chapter 11*](B19411_11.xhtml#_idTextAnchor582),
    *Android* *Architecture Components*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code for this exercise can be found here: [https://packt.link/zsGW3](https://packt.link/zsGW3).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will add another Activity to an app and navigate between
    the activities.
  prefs: []
  type: TYPE_NORMAL
- en: Activity interaction with Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An intent in Android is a communication mechanism between components. Within
    your own app, a lot of the time, you will want another specific Activity to start
    when some action happens in the current activity. Specifying exactly which Activity
    will start is called an `AndroidManifest.xml` file from the previous exercise
    and you will see an example of two intent filters set within the `<intent-filter>`
    XML element of the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The one specified with `<action android:name="android.intent.action.MAIN" />`
    means that this is the main entry point into the app. Depending on which category
    is set, it governs which Activity first starts when the app is started. The other
    intent filter that is specified is `<category android:name="android.intent.category.LAUNCHER"
    />`, which defines that the app should appear in the launcher. When combined,
    the two intent filters define that when the app is started from the launcher,
    `MainActivity` should be started. Removing the `<action android:name="android.intent.action.MAIN"
    />` intent filter results in the `"Error running ''app'': Default Activity not
    found"` message. As the app has not got a main entry point, it can’t be launched.
    If you remove `<category android:name="android.intent.category.LAUNCHER" />` then
    there is nowhere that it can be launched from.'
  prefs: []
  type: TYPE_NORMAL
- en: For the next exercise, you will see how intents work to navigate around your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.04 – an introduction to Intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to create a simple app that uses intents to display
    text to the user based on their input:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio called `Intents Introduction` and select
    an empty Activity. Once you have set up the project, go to the toolbar and select
    `File` | `New` | `Activity` | `Empty` `Activity`. Call it `WelcomeActivity` and
    leave all the other defaults as they are. It will be added to the `AndroidManifest.xml`
    file, ready to use. The issue you have now that you’ve added `WelcomeActivity`
    is knowing how to do anything with it. `MainActivity` starts when you launch the
    app, but you need a way to launch `WelcomeActivity` and then, optionally, pass
    data to it, which is when you use intents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to work through this example, add the following strings to the `strings.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change the `MainActivity` layout in `activity_main.xml` and replace the
    content with the following code to add an `EditText` and a `Button`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The app, when run, looks as in *Figure 2**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The app display after adding the EditText full name field and
    SUBMIT button](img/B19411_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – The app display after adding the EditText full name field and
    SUBMIT button
  prefs: []
  type: TYPE_NORMAL
- en: You now need to configure the button so that when it’s clicked, it retrieves
    the user’s full name from the `EditText` field and then sends it in an intent,
    which starts `WelcomeActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `activity_welcome.xml` layout file to prepare to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are adding a `TextView` field to display the full name of the user with
    a welcome message. The logic to create the full name and welcome message will
    be shown in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `MainActivity` and add a constant value above the class header and
    update the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will use the constant to set the key to hold the full name of the user by
    setting it in the intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following code to the bottom of `onCreate(savedInstanceState:
    Bundle?)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is logic to retrieve the value of the full name and verify that the user
    has filled this in; otherwise, a pop-up toast message will be shown if it’s blank.
    The main logic, however, takes the `fullName` value of the `EditText` field and
    creates an explicit intent to start `WelcomeActivity`, and then puts an `Extra`
    key with a value into the Intent. The last step is to use the intent to start
    `WelcomeActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the app, enter your name, and press **SUBMIT**, as shown in *Figure
    2**.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The default screen displayed when the intent extras data is
    not processed](img/B19411_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The default screen displayed when the intent extras data is not
    processed
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s not very impressive. You’ve added the logic to send the user’s
    name, but not to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this, please open `WelcomeActivity` and add the import `import android.widget.TextView`
    to the imports list and add the following to the bottom of `onCreate(savedInstanceState:
    Bundle?)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We check that the intent that started the Activity is not null and then retrieve
    the string value that was passed from the `MainActivity` intent by getting the
    string `FULL_NAME_KEY` extra key. We then format the `<string name="welcome_text">Hello
    %s, we hope you enjoy using the app!</string>` resource string by getting the
    string from the resources and passing in the `fullname` value retrieved from the
    intent. Finally, this is set as the text of `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app again, and a simple greeting will be displayed, as in *Figure 2**.15*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – User welcome message displayed](img/B19411_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – User welcome message displayed
  prefs: []
  type: TYPE_NORMAL
- en: This exercise, although very simple in terms of layouts and user interaction,
    allows the demonstration of some core principles of intents. You will use them
    to add navigation and create user flows from one section of your app to another.
    In the next section, you will see how you can use intents to launch an Activity
    and receive a result back from it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.05 – retrieving a result from an Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some user flows, you will only launch an Activity for the sole purpose
    of retrieving a result back from it. This pattern is often used to ask permission
    to use a particular feature, popping up a dialog with a question about whether
    the user gives their permission to access contacts, the calendar, and so on, and
    then reporting the result of yes or no back to the calling Activity. In this exercise,
    you will ask the user to pick their favorite color of the rainbow, and then once
    that is chosen, display the result in the calling activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project named `Activity Results` with an empty activity and add
    the following strings to the `strings.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following colors to `colors.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have to set up the Activity that will set the result you receive in
    `MainActivity`. Go to `RainbowColorPickerActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `activity_main.xml` layout file to display a header, a button, and
    then a hidden `android:visibility="gone"` View, which will be made visible and
    set with the user’s favorite color of the rainbow when the result is reported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll be using the `registerForActivityResult(ActivityResultContracts.StartActivityForResult())`
    function to get a result back from the Activity you launch. Add two constant keys
    for the values we want to use in the intent, as well as a default color constant
    above the class header in `MainActivity`, and update the imports so it is displayed
    as follows with the package name and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a property below the class header that is used to both launch
    the new activity and return a result from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the result is returned, you can proceed to query the intent data for the
    values you are expecting. For this exercise, we want to get the background color
    name (`colorName`) and the hexadecimal value of the color (`backgroundColor`)
    so that we can display it. The `?` operator checks whether the value is null (that
    is, not set in the intent), and if so, the Elvis operator (`?:`) sets the default
    value. The color message uses string formatting to set a message, replacing the
    placeholder in the resource value with the color name. Now that you’ve got the
    colors, you can make the `rainbow_color` `TextView` field visible and set the
    background color of the View to `backgroundColor` and add text displaying the
    name of the user’s favorite color of the rainbow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the logic to launch the Activity from the property defined previously
    by adding the following to the bottom of `onCreate(savedInstanceState: Bundle?)`::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates an Intent that is launched for its result: `Intent(this`, `RainbowColor``PickerActivity::class.java)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the layout of the `RainbowColorPickerActivity` activity, you are going
    to display a button with a background color and color name for each of the seven
    colors of the rainbow: `RED`, `ORANGE`, `YELLOW`, `GREEN`, `BLUE`, `INDIGO`, and
    `VIOLET`. These will be displayed in a `LinearLayout` vertical list. For most
    of the layout files in the book, you will be using `ConstraintLayout`, as it provides
    fine-grained positioning of individual Views. For situations where you need to
    display a vertical or horizontal list of a small number of items, `LinearLayout`
    is also a good choice. If you need to display a large number of items, then `RecyclerView`
    is a better option as it can cache layouts for individual rows and recycle views
    that are no longer displayed on the screen. You will learn about `RecyclerView`
    in [*Chapter* *6*](B19411_06.xhtml#_idTextAnchor353), *RecyclerView*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing you need to do in `RainbowColorPickerActivity` is create the
    layout. This will be where you present the user with the option to choose their
    favorite color of the rainbow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `activity_rainbow_color_picker.xml` and replace the layout, inserting
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are adding `ScrollView` to allow the contents to scroll if the screen height
    cannot display all of the items. `ScrollView` can only take one child View, which
    is the layout to scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add `LinearLayout` within `ScrollView` to display the contained views
    in the order that they are added with a header and a footer. The first child View
    is a header with the title of the page and the last View that is added is a footer
    with instructions for the user to pick their favorite color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The layout should now look as in *Figure 2**.16* in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Rainbow colors screen with a header and footer](img/B19411_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Rainbow colors screen with a header and footer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, finally, add the button views between the header and the footer to select
    a color of the rainbow, and then run the app (the following code only displays
    the first button ). The full layout is available at [https://packt.link/ZgdHX](https://packt.link/ZgdHX):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These buttons are displayed in the order of the colors of the rainbow with the
    color text and background. The XML `id` attribute is what you will use in the
    Activity to prepare the result of what is returned to the calling activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `RainbowColorPickerActivity` and replace the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `setRainbowColor` function creates an intent and adds the rainbow color
    name and the rainbow color `hex` value as String extras. The result is then returned
    to the calling Activity, and as you have no further use for this Activity, you
    call `finish()` so that the calling Activity is displayed. The way that you retrieve
    the rainbow color that the user has chosen is by adding a listener for all the
    buttons in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following to the bottom of `onCreate(savedInstanceState: Bundle?)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `colorPickerClickListener` added in the preceding code determines which
    colors to set for the `setRainbowColor(colorName: String, color: Int)` function
    by using a `when` statement. The `when` statement is the equivalent of the `switch`
    statement in Java and languages based on C. It allows multiple conditions to be
    satisfied with one branch and is more concise. In the preceding example, `view.id`
    is matched against the IDs of the rainbow layout buttons and, when found, executes
    the branch, setting the color name and hex value from the string resources to
    pass into `setRainbowColor(colorName: String,` `color: Int)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this click listener to the buttons from the layout below the preceding
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every button has a `ClickListener` interface attached, and as the operation
    is the same, they have the same `ClickListener` interface attached. Then, when
    the button is pressed, it sets the result of the color that the user has chosen
    and returns it to the calling activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the app and press the `CHOOSE COLOR` button, as shown in *Figure 2**.17*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.17 – The rainbow colors app start s\uFEFFcreen](img/B19411_02_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – The rainbow colors app start screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, select your favorite color of the rainbow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – The rainbow colors selection screen](img/B19411_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – The rainbow colors selection screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve chosen your favorite color, a screen with your favorite color will
    be displayed, as shown in *Figure 2**.19*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.19 – The app displaying the selected color](img/B19411_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – The app displaying the selected color
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the app displays the color that you’ve selected as your favorite
    color in *Figure 2**.19*.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise introduced you to another way of creating user flows using `registerFor`
    **ActivityResult**. This can be very useful for carrying out a dedicated Task
    where you need a result before proceeding with the user’s flow through the app.
    Next, you will explore launch modes and how they impact the flow of user journeys
    when building apps.
  prefs: []
  type: TYPE_NORMAL
- en: Intents, Tasks, and Launch Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, you have been using the standard behavior for creating Activities
    and moving from one Activity to the next. When you open the app from the launcher
    with the default behavior, it creates its own Task, and each Activity you create
    is added to a back stack, so when you open three Activities one after the other
    as part of your user’s journey, pressing the back button three times will move
    the user back through the previous screens/Activities and then go back to the
    device’s home screen, while still keeping the app open.
  prefs: []
  type: TYPE_NORMAL
- en: The launch mode for this type of Activity is called `Standard`; it is the default
    and doesn’t need specifying in the Activity element of `AndroidManifest.xml`.
    Even if you launch the same Activity three times, one after the other, there will
    be three instances of the same activity that exhibit the behavior described previously.
  prefs: []
  type: TYPE_NORMAL
- en: For some apps, you may want to change this behavior so the same instance is
    used. The launch mode that can help here is called `singleTop`. If a `singleTop`
    Activity isthe most recently added, when the same `singleTop` Activity is launched
    again, then instead of creating a new Activity, it uses the same Activity and
    runs the `onNewIntent` callback. In this callback, you receive an intent, and
    you can then process this intent as you have done previously in `onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three other launch modes to be aware of called `singleTask`, `singleInstance`
    and `singleInstancePerTask`. These are not for general use and are only used for
    special scenarios. Detailed documentation of all launch modes can be viewed here:
    [https://developer.android.com/guide/topics/manifest/activity-element#lmode](https://developer.android.com/guide/topics/manifest/activity-element#lmode).'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll explore the differences in behavior of the `Standard` and `singleTop`
    launch modes in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.06 – setting the Launch Mode of an Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise has many different layout files and Activities to illustrate
    the two most commonly used launch modes. Please download the code from [https://packt.link/DQrGI](https://packt.link/DQrGI):'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `activity_main.xml` file and examine it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This illustrates a new concept when using layout files. If you have a layout
    file and you would like to include it in another layout, you can use the `<include>`
    XML element (have a look at the following snippet of the layout file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding layout uses the `include` XML element to include the two layout
    files: `letters.xml` and `numbers.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Open up and inspect the `letters.xml` and `numbers.xml` files found in the `res`
    | `layout` folder. These are very similar and are only differentiated from the
    buttons they contain by the ID of the buttons themselves and the text label they
    display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app and you will see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20 – App displaying both the standard and single top modes](img/B19411_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – App displaying both the standard and single top modes
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate/illustrate the difference between the `standard` and
    `singleTop` activity launch modes, you have to launch two or three activities
    one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `MainActivity` and examine the contents of the code block (truncated)
    in `onCreate(savedInstanceState: Bundle?)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The logic contained in the main Activity and the other activities is basically
    the same. It displays an Activity and allows the user to press a button to launch
    another Activity using the same logic of creating a `ClickListener` and setting
    it on the button you saw in *Exercise 2.05*, *Retrieving a result from* *an Activity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file and you will see the following activities
    displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You launch an Activity based on a button pressed on the main screen, but the
    letter and number activities have a different launch mode, which you can see specified
    in the `AndroidManifest.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `standard` launch mode is specified here to illustrate the difference between
    `standard` and `singleTop`, but `standard` is the default and would be how the
    Activity is launched if the `android:launchMode` XML attribute was not present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press one of the letters under the `Standard` heading and you will see the
    following screen (with **A**, **B**, or **C**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.21 – The app displaying standard activity](img/B19411_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – The app displaying standard activity
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep on pressing any of the letter buttons, which will launch another Activity.
    Logs have been added to show this sequence of launching activities. Here is the
    log after pressing 10 letter Activities randomly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you observe the preceding log, every time the user presses a character button
    in launch mode, a new instance of the character Activity is launched and added
    to the back stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close the app, making sure it is not backgrounded (or in the recents/overview
    menu) but is actually closed, and then open the app again and press one of the
    number buttons under the **Single** **Top** heading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.22 – The app displaying the Single Top activity](img/B19411_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – The app displaying the Single Top activity
  prefs: []
  type: TYPE_NORMAL
- en: Press the number buttons 10 times, but make sure you press the same number button
    at least twice sequentially before pressing another number button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The logs you should see in the **Logcat** window (**View** | **Tool Windows**
    | **Logcat**) should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that instead of calling `onCreate` when you pressed the same button
    again at least twice sequentially, the Activity is not created, but a call is
    made to `onNewIntent`. If you press the back button, you’ll notice that it will
    take you less than 10 clicks to back out of the app and return to the home screen,
    reflecting the fact that 10 activities have not been created.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2.01 – creating a login form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this activity is to create a login form with username and password
    fields. Once the values in these fields are submitted, check these entered values
    against the hardcoded values and display a welcome message if they match, or an
    error message if they don’t, and return the user to the login form. The steps
    needed to achieve this are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a form with username and password `EditText` Views and a `LOGIN` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ClickListener` interface to the button to react to a button press event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that the form fields are filled in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the submitted username and password fields against the hardcoded values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display a welcome message with the username if successful and hide the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display an error message if not successful and redirect the user back to the
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few possible ways that you could go about trying to complete this
    activity. Here are three ideas for approaches you could adopt:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `singleTop` Activity and send an intent to route to the same Activity
    to validate the credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `standard` Activity to pass a username and password to another Activity
    and validate the credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `registerForActivityResult` to carry out the validation in another Activity
    and then return the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The completed app, upon its first loading, should look as in *Figure 2**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The app display when first loaded](img/B19411_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – The app display when first loaded
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/PmKJ6](https://packt.link/PmKJ6).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have covered a lot of the groundwork of how your application
    interacts with the Android framework, from the Activity lifecycle callbacks to
    retaining the state in your activities, navigating from one screen to another,
    and how intents and launch modes make this happen. These are core concepts that
    you need to understand in order to move on to more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to fragments and how they fit into
    the architecture of your application, as well as exploring more of the Android
    resources framework.
  prefs: []
  type: TYPE_NORMAL
