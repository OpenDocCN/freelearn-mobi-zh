- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building a Series of Belts and Gears
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一系列皮带和齿轮
- en: In this project, we’re going to explore rotation, and more specifically, how
    to use the `rotation3DEffect` modifier to rotate objects on the *x*-, *y*-, and
    *z*-axis. We will be doing this by animating a series of gears and belts that
    will eventually move a fan blade.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将探索旋转，特别是如何使用 `rotation3DEffect` 修改器在 *x*、*y* 和 *z* 轴上旋转对象。我们将通过动画一系列齿轮和皮带来实现这一点，最终移动风扇叶片。
- en: As we create this project, we will also explore how to use Groups and Pragma
    Marks to make your code more organized, and the `zIndex` property, which changes
    the depth of views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此项目的过程中，我们还将探索如何使用组和祈使标记来使您的代码更有组织性，以及 `zIndex` 属性，该属性会改变视图的深度。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Animating our first circular gear
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画我们的第一个圆形齿轮
- en: Adding a worm gear using shadows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影添加蜗轮齿轮
- en: Using a marching ants effect to create a gear belt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行军蚂蚁效果创建齿轮皮带
- en: Animating a gear shaft image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画齿轮轴图像
- en: Animating a fan image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画风扇图像
- en: Bringing everything together in `ContentView`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ContentView` 中整合一切
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the resources and finished project from the `Chapter 7` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 上的 `Chapter 7` 文件夹下载资源和完善的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Animating our first circular gear
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画我们的第一个圆形齿轮
- en: To begin with, let’s create a new project, which I’m calling `Gears and Belts`.
    Then, add the images for the project (which you can find in the GitHub repository
    provided in the *Technical requirements* section) by dragging and dropping the
    images into Swift’s asset catalog. The images we are using are `singleGear`, `doubleGear`,
    `wormGear`, `motor`, `shaft`, `fan`, and `goldBackground`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的项目，我将它命名为 `Gears and Belts`。然后，通过将图像拖放到 Swift 的资产库中添加项目的图像（您可以在
    *技术要求* 部分提供的 GitHub 仓库中找到这些图像），我们使用的图像有 `singleGear`、`doubleGear`、`wormGear`、`motor`、`shaft`、`fan`
    和 `goldBackground`。
- en: In this section, we are going to start by animating a gear image around the
    *z*-axis, so let’s make a SwiftUI file that will handle creating all the gears
    we need (as we have done in previous projects, we are going to work on each element
    for the project in separate files, and then piece them together in `ContentView`
    to create the finished animations).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先围绕 *z*- 轴动画齿轮图像，因此让我们创建一个 SwiftUI 文件来处理创建我们需要的所有齿轮（正如我们在之前的项目中做的那样，我们将为项目的每个元素在单独的文件中工作，然后将其拼接到
    `ContentView` 中以创建完成的动画）。
- en: To do this, go to `GearView` and press **Create**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请转到 `GearView` 并按 **创建**。
- en: 'Now, we can fill this file by adding the variables needed to make and animate
    gears images. Let’s start with a `State` variable that keeps track of the animation
    state, the state being whether the animation is in motion or not. Add this `@State`
    variable to the file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加制作和动画齿轮图像所需的变量来填充此文件。让我们从一个 `State` 变量开始，该变量跟踪动画状态，状态是动画是否在运动。将此
    `@State` 变量添加到文件中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This variable will help to keep track of whether the gear image is rotating
    or not, so I have called it `rotateGear`. It is also set to `false`, which means
    the animation will start inactive until this variable is changed to `true`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将帮助跟踪齿轮图像是否在旋转，所以我将其命名为 `rotateGear`。它也被设置为 `false`，这意味着动画将处于非活动状态，直到这个变量被更改为
    `true`。
- en: 'The next variable will be of the `String` type, which we can use to set the
    name of the gear image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量将是 `String` 类型，我们可以用它来设置齿轮图像的名称：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you look back into the asset catalog, you will see that you placed three
    different types of gear in there: a single gear, a double gear, and a worm gear.
    So, when it comes time to use all these files in `ContentView`, this `gearImage`
    variable will help save time, as all we need to do is to type in the name of the
    gear we want to use.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾资产库，您会看到您放置了三种不同类型的齿轮：一个单齿轮、一个双齿轮和一个蜗轮齿轮。因此，当需要使用所有这些文件在 `ContentView`
    中时，这个 `gearImage` 变量将帮助节省时间，因为我们只需要输入我们想要使用的齿轮的名称。
- en: 'Next, we need to be able to set the size of the gear; here’s another variable
    to handle that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要能够设置齿轮的大小；这里有一个变量来处理这个任务：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might be wondering why we are setting the width of the gear but not the
    height. Well, the gear images we are using are circles (except for the worm gear);
    as you may know, circles only need one dimension, the width or height, because
    circles have a diameter that is always the same, regardless of which dimension
    is measured.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们要设置齿轮的宽度而不是高度。好吧，我们使用的齿轮图像是圆形的（除了蜗轮齿轮）；正如你可能知道的，圆形只需要一个维度，即宽度或高度，因为圆形的直径总是相同的，无论测量哪个维度。
- en: 'Continuing with the variables needed for this file, let’s add another variable
    that indicates the number of degrees our gear will turn:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加这个文件需要的变量，让我们添加另一个变量来指示齿轮将旋转的度数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This variable is called `gearDegrees`. A value of `360` will turn the gear image
    for one revolution, but right now, it is initialized as `0.0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量被称为`gearDegrees`。`360`的值将使齿轮图像旋转一周，但当前它被初始化为`0.0`。
- en: 'We will also place gears all around the screen, so we’ll need to set a couple
    of variables to handle the location of these gears. We will use two of them to
    set the `X` and `Y` location:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将围绕屏幕放置齿轮，因此我们需要设置一些变量来处理这些齿轮的位置。我们将使用其中两个来设置`X`和`Y`位置：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to be able to rotate the gears, and later the belts, to different
    orientations in relation to their surroundings, so let’s add a variable that will
    be in charge of setting that value:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要能够将齿轮以及后来的皮带旋转到与周围环境不同的方向，所以让我们添加一个变量来负责设置这个值：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will add a variable to set the duration of the spinning gear, meaning
    how long it takes to finish one revolution:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个变量来设置旋转齿轮的持续时间，即完成一次旋转所需的时间：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The duration variable is set to `0`, but when it gets set to a value such as
    `7`, for example, that means it will take 7 seconds for the gear to turn one full
    revolution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间变量被设置为`0`，但当它被设置为例如`7`这样的值时，这意味着齿轮需要7秒钟才能完成一次完整旋转。
- en: 'Finally, for this file, we need three more variables to set the *x*-, *y*-,
    and *z*-axis position of the gear:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个文件，我们还需要三个变量来设置齿轮的*x*、*y*和*z*轴位置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each of these variables will control the axis that the gear rotates around.
    The axis is what allows us to rotate an object in three dimensions, which will
    help create perspective and the effect of depth in the scene. These variables
    are appropriately named `xAxis`, `yAxis`, and `zAxis`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些变量都将控制齿轮旋转的轴。轴是允许我们在三维空间中旋转对象的东西，这将有助于创建透视和场景中的深度效果。这些变量被适当地命名为`xAxis`、`yAxis`和`zAxis`。
- en: 'We have all the variables in place, so let’s now add the code into the body
    of the struct and make our first gear. First, let’s add a `ZStack` to hold all
    of the views we need:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有变量，现在让我们将这些代码添加到结构的主体中，并制作我们的第一个齿轮。首先，让我们添加一个`ZStack`来容纳我们需要的所有视图：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, inside the `ZStack`, we can use the `Image` initializer, which will place
    a gear image on the screen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ZStack`内部，我们可以使用`Image`初始化器，它将在屏幕上放置一个齿轮图像：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember, we have initialized the preceding `gearImage` variable to an empty
    string; this is what we want because it allows us to pass in different string
    names that represent the gear images in the asset catalog.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们已经将前面的`gearImage`变量初始化为空字符串；这正是我们想要的，因为它允许我们传递代表资产目录中齿轮图像的不同字符串名称。
- en: 'Next, we need several modifiers to size and place the gear image, as well as
    the animation modifiers to make the gear image turn. Add the following code under
    `Image(gearImage)`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要几个修饰符来调整齿轮图像的大小和位置，以及动画修饰符来使齿轮图像旋转。在`Image(gearImage)`下添加以下代码：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s look at the modifiers we are using here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里使用的修饰符：
- en: Firstly, we know that we need to give the image the ability to resize, which
    is what the `resizable` modifier is for.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们知道我们需要给图像赋予缩放的能力，这正是`resizable`修饰符的作用。
- en: Then, we want to constrain the gear image dimensions with the `fit` aspect ratio
    option; as we have seen before, this mode preserves the content’s aspect ratio
    and indicates that the object should be scaled to fit within the available space
    while maintaining its aspect ratio. This means that the object will be scaled
    down if necessary so that it fits within the space it’s being displayed in, without
    distorting its shape.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们想要使用`fit`宽高比选项来约束齿轮图像的尺寸；正如我们之前看到的，这种模式会保留内容的宽高比，并指示对象应该缩放以适应可用空间，同时保持其宽高比。这意味着如果需要，对象将被缩小以适应其显示的空间，而不会扭曲其形状。
- en: The other option is `fill`; this means that the object will be scaled up or
    down to fill the space it is being displayed in without distorting its shape.
    Some parts of the object may be outside of the visible area, but the object will
    maintain its aspect ratio. We haven’t used this here though.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是`fill`；这意味着对象将被缩放以填充其显示的空间，而不会扭曲其形状。对象的一些部分可能位于可见区域之外，但对象将保持其宽高比。不过，我们在这里没有使用这个选项。
- en: Next, the frame of the image is set with the `gearWidth` modifer, which has
    been initialized to `0`. By doing this, we can pass in whatever value we need
    to create any size gear.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`gearWidth`修饰符设置图像的框架，该修饰符已初始化为`0`。通过这样做，我们可以传入任何所需的值来创建任何大小的齿轮。
- en: The next line calls the `rotationEffect` modifier, which will rotate `gearImage`
    by a value we pass in. This modifier will only rotate the gear image when the
    `rotateGear` variable becomes `true`; otherwise, a value of `0` gets used, meaning
    no rotation.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行调用`rotationEffect`修饰符，该修饰符将`gearImage`旋转一个我们传入的值。当`rotateGear`变量变为`true`时，此修饰符将仅旋转齿轮图像；否则，使用`0`的值，意味着不旋转。
- en: After that, we add the `animation` modifier, which gets a `linear` animation.
    The duration of the animation will depend on the value that’s held in the `duration`
    variable – here, we have set the duration to `repeatForever` and `autoreverses`
    to `false`. Then, we have the `value` parameter, which accepts into its parameter
    the variable we want to animate and then applies the animation to the view.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们添加`animation`修饰符，它获取一个`linear`动画。动画的持续时间将取决于`duration`变量中持有的值——在这里，我们将持续时间设置为`repeatForever`并将`autoreverses`设置为`false`。然后，我们有`value`参数，它接受我们想要动画化的变量并将其应用于视图。
- en: 'The next modifier is an interesting one, it’s called `rotation3DEffect`. This
    rotates a view in three dimensions around the given axis; the amount of rotation
    will be determined by the `degrees` modifier that is being used within it. To
    understand how the view will be rotated, it’s important to know where the *x*-,
    *y*-, and *z*-axes exist on an iPhone screen. Look at the following illustration:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个修饰符很有趣，它被称为`rotation3DEffect`。这个修饰符会在给定的轴上绕三维视图旋转；旋转量将由它内部使用的`degrees`修饰符确定。为了理解视图将如何旋转，了解*x*、*y*和*z*轴在iPhone屏幕上的位置很重要。请看以下插图：
- en: '![Figure 7.1: The three axes ](img/B18674_07_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：三个坐标轴](img/B18674_07_01.jpg)'
- en: 'Figure 7.1: The three axes'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：三个坐标轴
- en: The *x*-axis runs from left to right on the iPhone screen, the *y*-axis runs
    from top to bottom, and the *z*-axis runs from back to front. These axes are three
    different planes of dimensional space that hold views or objects, and when an
    object rotates, it does so on one, or all, of these axes. Looking at the `rotation3DEffect`
    modifier, if we pass a value in one of the axis parameters, the view will then
    rotate on that axis by the specified number of degrees.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*轴在iPhone屏幕上从左到右延伸，*y*轴从上到下延伸，*z*轴从后向前延伸。这些轴是三个不同的空间维度平面，它们包含视图或对象，当一个对象旋转时，它会在一个或所有这些轴上旋转。查看`rotation3DEffect`修饰符，如果我们传递一个轴参数的值，视图将围绕该轴旋转指定的角度。'
- en: Back to the code, lastly, the gear image will need to be placed somewhere on
    the screen; for that placement, we can use the help of the `offset` modifier.
    This modifier has two parameters, `x` and `y`, and the values will be determined
    by the `offsetGearX` and `offsetGearY` variables.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到代码，最后，齿轮图像需要放置在屏幕上的某个位置；为此，我们可以使用`offset`修饰符的帮助。此修饰符有两个参数，`x`和`y`，其值将由`offsetGearX`和`offsetGearY`变量确定。
- en: 'With the modifiers all in place, we only need to start the animation, so let’s
    add the following code at the end of ZStack’s closing brace:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有修饰符都就绪后，我们只需要开始动画，所以让我们在ZStack的闭合括号末尾添加以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `onAppear` modifier, as we have seen before, will run the code in its body
    when the scene first appears. In the code, we want to toggle the `rotateGear`
    variable to `true` to start the animation. I’m also adding a little bit of black
    shadow to the gear image, which gives it a nicer look around its border.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAppear`修饰符，正如我们之前所看到的，当场景首次出现时，将运行其体内的代码。在代码中，我们希望将`rotateGear`变量切换为`true`以启动动画。我还为齿轮图像添加了一点点黑色阴影，这使得它在边缘处看起来更美观。'
- en: 'Now, with everything we coded so far though, we still don’t see any images
    in the previews! Let’s fix that and add some values into the `Previews` struct
    in order to create a gear. In this example, we’ll use the double gear image, and
    give it a size. Place the following code in `GearView_Previews` so we can see
    the animation work:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管我们已经编写了所有这些代码，但在预览中仍然没有看到任何图像！让我们解决这个问题，并将一些值添加到`Previews`结构中，以便创建一个齿轮。在这个例子中，我们将使用双齿轮图像，并给它一个大小。将以下代码放置在`GearView_Previews`中，以便我们可以看到动画效果：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code fills out the `GearView` struct with some values. The first parameter
    uses the `doubleGear` image from the asset catalog as the gear to display. Next,
    the `gearWidth` and `gearDegrees` parameters receive values to set the width and
    turning degree. Then, for the `offset` parameters, by setting them to zero, the
    gear will just stay in the middle of the screen. Finally, adding a duration of
    5 seconds means it’ll take 5 seconds for the gear to turn for one complete revolution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码用一些值填充了`GearView`结构。第一个参数使用资产目录中的`doubleGear`图像作为要显示的齿轮。接下来，`gearWidth`和`gearDegrees`参数接收值以设置宽度和转动度。然后，对于`offset`参数，通过将它们设置为零，齿轮将保持在屏幕中间。最后，添加5秒的持续时间意味着齿轮将花费5秒完成一整圈的转动。
- en: 'With all that in place, now, we can run the previews and check what we have
    done so far:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都准备好了，现在我们可以运行预览并检查到目前为止我们已经做了什么：
- en: '![Figure 7.2: Adding our first gear ](img/B18674_07_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：添加我们的第一个齿轮](img/B18674_07_02.jpg)'
- en: 'Figure 7.2: Adding our first gear'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：添加我们的第一个齿轮
- en: The gear now turns, again, at a rate of one revolution in 5 seconds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 齿轮现在以每5秒一转的速度转动。
- en: Also, notice that I’m setting a fixed width and height for the preview window,
    as we don’t need a full-size screen to display a small gear; 200 x 200 is more
    than enough room.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我正在为预览窗口设置固定的宽度和高度，因为我们不需要全尺寸屏幕来显示一个小齿轮；200 x 200就足够了。
- en: Now, with our gear in place and this file complete, anytime we need to make
    a gear anywhere in the project, all we have to do is call the `gearView` struct
    and pass in some values to create a gear of any size, wherever needed on the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，齿轮已经放置好，这个文件也完成了，任何时候我们想在项目的任何地方制作一个齿轮，我们只需要调用`gearView`结构并传递一些值来创建任何大小和屏幕上所需位置的齿轮。
- en: However, despite all that work, there is one gear that we won’t be able to turn
    in any meaningful way because it’s not a circular shape, and that’s the worm gear
    image in the asset catalog. In the next section, I’ll explain what a worm gear
    is, and how to make it turn, or at least make it look like it’s turning.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管做了所有这些工作，仍然有一个齿轮我们无法以任何有意义的方式转动，因为它不是圆形的，那就是资产目录中的蜗轮齿轮图像。在下一节中，我将解释什么是蜗轮齿轮，以及如何让它转动，或者至少让它看起来像是在转动。
- en: Animating a worm gear using shadows
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阴影动画蜗轮齿轮
- en: 'Worm gears look like big screws with spiral threads, but without a screw head
    on the top. They’re used in equipment and machines where strength is an important
    factor because they are very durable and can handle a lot of torque. Here is a
    typical worm gear:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 蜗轮齿轮看起来像带有螺旋螺纹的大螺丝，但没有螺丝头。它们用于需要强度作为重要因素的设备和机器中，因为它们非常耐用，可以承受很大的扭矩。这是一个典型的蜗轮齿轮：
- en: '![Figure 7.3: A worm gear ](img/B18674_07_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：蜗轮齿轮](img/B18674_07_03.jpg)'
- en: 'Figure 7.3: A worm gear'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：蜗轮齿轮
- en: If we add a worm gear image to the project and animate it as we did with the
    round gear, it wouldn’t work very well, simply because the worm gear image is
    not a round shape. So, how can we make an irregularly shaped image appear like
    it’s turning as it would in the real world?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将蜗轮齿轮图像添加到项目中，并像处理圆形齿轮一样动画化它，它将不起作用，仅仅是因为蜗轮齿轮图像不是圆形的。那么，我们如何让一个不规则形状的图像看起来像在真实世界中那样转动呢？
- en: What we can do is place small, shaded rectangles over the shiny parts of the
    worm gear image and animate those rectangles instead, which will create the illusion
    that the image is turning or spinning. Clever, right?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做到的是在蜗轮齿轮图像的亮面部分放置小的阴影矩形，并动画化这些矩形，这将产生一种图像正在转动或旋转的错觉。聪明，对吧？
- en: 'First, create a new file, choose the `WormGearView`. Inside this file, within
    the `WormGear` struct, we will start off by adding four `State` properties, one
    for each rectangle we need:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新文件，选择`WormGearView`。在这个文件中，在`WormGear`结构内部，我们首先将添加四个`State`属性，每个矩形需要一个：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now in our main `ZStack`, let’s add another `ZStack` within to display the
    worm gear image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的主`ZStack`中，让我们添加另一个`ZStack`来显示蜗轮齿轮图像：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Image` initializer declares the image and resizes it to a width and height
    that we can use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 初始化器声明了图像并将其调整到我们可以使用的宽度和高度。'
- en: 'Next, we will create the first rectangle that we need to place over the shiny
    part of the worm gear. To do so, add the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建第一个需要放置在蜗轮齿轮光滑部分上的矩形。为此，添加以下代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The rectangles will be placed in an `HStack` because we want to put them side
    by side, going from left to right across the gear. We’re also using familiar modifiers
    that we’ve used before. We’ve made the rectangles black and given them a slight
    corner radius. The opacity of the rectangle will depend on whether the animating
    variable called `rect1` is `true` or not: if the `rect1` property becomes `true`,
    then we will give the rectangle a bit of visibility using an `opacity` of `0.3`;
    when the `rect1` property is `false`, we’ll remove all opacity and hide it.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将矩形放置在 `HStack` 中，因为我们想将它们并排放置，从左到右穿过齿轮。我们还在使用之前使用过的熟悉修饰符。我们将矩形设置为黑色，并给它们轻微的圆角半径。矩形的透明度将取决于名为
    `rect1` 的动画变量是 `true` 还是 `false`：如果 `rect1` 属性变为 `true`，我们将使用 `opacity` 为 `0.3`
    给矩形一点可见性；当 `rect1` 属性为 `false` 时，我们将移除所有透明度并隐藏它。
- en: The next line of code uses the `offset` modifier to place this rectangle directly
    over the first shiny part of this worm gear on the left side. This `offset` modifier
    is also responsible for moving the small rectangle up and down on the *y*-axis,
    either up `14` points when `rect1` is `true`, or it will move the rectangle down
    to `-8` points when it becomes `false`. The effect we’re going for here is to
    animate these tiny rectangles up and down and at the same time, fade them in and
    out over the shiny part of the worm gear image, creating the illusion that the
    part is turning.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用 `offset` 修饰符将此矩形直接放置在左侧蜗轮齿轮的第一个光滑部分上。这个 `offset` 修饰符还负责在 *y* 轴上移动小矩形，当
    `rect1` 为 `true` 时，向上移动 `14` 个点，当它变为 `false` 时，将矩形向下移动到 `-8` 个点。我们在这里想要的效果是让这些小矩形上下移动，同时在其光滑部分上淡入淡出，从而产生部分正在旋转的错觉。
- en: 'Now for the `animation` modifier: this uses an `easeInOut` timing curve, has
    a duration of half a second, and is set to `repeatForever`, with `autoreverses`
    set to `true`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `animation` 修饰符：它使用 `easeInOut` 时间曲线，持续时间为半秒，设置为 `repeatForever`，并将 `autoreverses`
    设置为 `true`。
- en: After that, the `rotationEffect` modifier is used to rotate this small rectangle
    exactly where we want it on the worm gear. The rectangle will rotate around the
    anchor point, which we have set to the top part of the rectangle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `rotationEffect` 修饰符来旋转这个小矩形，使其正好位于我们想要的蜗轮齿轮上的位置。矩形将围绕锚点旋转，我们将锚点设置在矩形的顶部部分。
- en: And finally, in the `onAppear` modifier, we toggled `rect1` so the animation
    starts when the view appears.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `onAppear` 修饰符中，我们切换了 `rect1`，使得动画在视图出现时开始。
- en: 'Now, go ahead and run the project; you can see the results in the preview:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目；你可以在预览中看到结果：
- en: '![Figure 7.4: A worm gear in our animation ](img/B18674_07_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：动画中的蜗轮齿轮](img/B18674_07_04.jpg)'
- en: 'Figure 7.4: A worm gear in our animation'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：动画中的蜗轮齿轮
- en: 'Looking at the figure, it’s a bit hard to see the rectangle, but it’s definitely
    there, a faint thin rectangle just after the third tooth. If you want to see the
    rectangle better, remove the worm gear by misspelling `wormGear` in the `Image`
    initializer, which will remove the worm gear from the previews (they hate when
    we misspell something!). When you run the project again, this is what you’ll see:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看着图，矩形有点难看清楚，但它确实在那里，就在第三个齿之后的一个微弱的细矩形。如果你想更好地看到矩形，请在 `Image` 初始化器中拼写错误 `wormGear`，这将从预览中移除蜗轮齿轮（他们讨厌我们拼写错误！）。当你再次运行项目时，你会看到以下内容：
- en: '![Figure 7.5: The rectangle that overlays the worm gear ](img/B18674_07_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：覆盖蜗轮齿轮的矩形](img/B18674_07_05.jpg)'
- en: 'Figure 7.5: The rectangle that overlays the worm gear'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：覆盖蜗轮齿轮的矩形
- en: You should see the rectangle moving up and down, as well as fading in and out.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到矩形在上下移动，以及淡入淡出。
- en: For the placement of this rectangle, ideally, we want it to be on the left,
    over the first tooth; however, that will happen when we add the other rectangles
    into this `HStack`. Remember, an `HStack` lines everything up from left to right,
    but since we only have one rectangle in the `HStack`, the `HStack` places it in
    the middle for now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s now add a second rectangle into the `HStack`, just under the first
    one:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is almost identical to what we’ve just added for the first rectangle.
    The difference here is we are offsetting the rectangle to a different location
    over the gear image, and the rotation is slightly different so it can be lined
    up over the next shiny part of the gear.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and you’ll see two animating rectangles. They’re not quite centered
    over the first and second shiny teeth of the gears yet, because we have two more
    rectangles to add, and then the `HStack` will center each animating rectangle
    perfectly for us.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue and add the third and fourth rectangles though, take a look
    at the first three modifiers of these two rectangles that we just added. They
    both have identical values in them, so we are repeating the code here, which is
    what we try to avoid when programming. Since the values don’t change in these
    modifiers and we will use them in all four rectangles, instead, we can make a
    custom modifier into which we can put these three modifiers and shorten our code
    a little bit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom modifier, we need to create a struct that conforms to the
    `ViewModifier` protocol. This protocol has one requirement, which is to implement
    a method called `body content` that will accept our content and then must return
    a view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a custom modifier at the bottom of the `WormGear` file. Moving
    outside of the `WormGear` struct completely and coming to the bottom of this file,
    add the following struct:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a custom modifier struct, which I called `RectModifiers`; as you can
    see, we are implementing the `body content` method inside it, which is the requirement
    needed to satisfy the `ViewModifier` protocol. Then, I added the three modifiers
    that we were repeating in our code (i.e., the ones that weren’t changing in value:
    `frame`, `foregroundColor`, and `cornerRadius`).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is go back to the first rectangle that we created, just
    after the worm gear creation, remove those three modifiers, and instead, call
    our custom modifier:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To use it, we pass into it the name of the custom struct we just made, `RectModifiers`.
    This new modifier struct can hold as many modifiers as we want to put in there,
    so modifiers that don’t change in value are probably a good idea to use here;
    this reduces the amount of code we need to write, especially if we have many views
    (for example, if we were to add 30 or 40 rectangles in this file).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can proceed to add the final two rectangles to help with the illusion
    that this gear is turning. Here’s what the code looks like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we try it out, let’s add some shadow to these moving rectangles to help
    make them a little more pronounced. Add this code at the end of the closing brace
    of the first `ZStack`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试之前，让我们给这些移动的矩形添加一些阴影，以帮助使它们更加突出。在第一个 `ZStack` 的闭合花括号末尾添加此代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By using the `shadow` modifier, and passing in a black shadow to go over each
    rectangle, I have given this shadow `4` points of radius, and the shadow will
    be shown on the *y*-axis with a value of `1`. Using a positive number value will
    move the shadow along the *y*-axis, while using a negative number will move the
    shadow along the *y*-axis in the opposite direction. Play around with these numbers
    so you can see how they affect the shadow’s prominence and location.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `shadow` 修饰符，并传入一个覆盖每个矩形的黑色阴影，我给这个阴影设置了 `4` 个半径点，阴影将在 *y* 轴上以 `1` 的值显示。使用正数值将阴影沿
    *y* 轴移动，而使用负数将阴影沿 *y* 轴向相反方向移动。尝试调整这些数字，看看它们如何影响阴影的突出程度和位置。
- en: 'And with that code, this file is now complete. Run the project and see what
    you think:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，这个文件现在就完成了。运行项目，看看你的想法：
- en: '![Figure 7.6: The finished worm gear ](img/B18674_07_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：完成的蜗轮](img/B18674_07_06.jpg)'
- en: 'Figure 7.6: The finished worm gear'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：完成的蜗轮
- en: We have a worm gear that actually looks like it’s turning. Notice that each
    rectangle has lined up completely over the teeth of the worm gear, starting from
    the left and moving to the right. The shiny parts are being covered up and exposed
    over and over again, at a nice even pace, which is actually about how fast many
    worm gears work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个看起来像在转动的蜗轮。注意，每个矩形都已经完全对齐到蜗轮的齿上，从左到右移动。光亮的部分一次又一次地被覆盖和暴露，以一个相当均匀的速度，这实际上就是许多蜗轮的工作速度。
- en: Now we have finished animating the worm gears, we’re going to create a marching
    ants effect that we can use to simulate a moving gear chain. We can accomplish
    that using the `dashPhase` initializer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了蜗轮的动画，我们将创建一个行军蚁效果，我们可以用它来模拟移动的齿轮链条。我们可以使用 `dashPhase` 初始化器来完成这个任务。
- en: Using a marching ants effect to create a gear belt
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用行军蚁效果创建齿轮皮带
- en: Now that we have animated our circular and worm gears, next, we need to make
    some belts that can be used to wrap around those gears and connect them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经动画化了圆形和蜗轮，接下来，我们需要制作一些可以用来缠绕这些齿轮并将它们连接起来的皮带。
- en: What we are actually doing is creating a marching ants effect. You probably
    have used this effect before, but without knowing what it was called – anytime
    you used your mouse or trackpad and outlined a view or created a bounding box
    around objects to select them, you were using the marching ants effect. You may
    remember that in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082) when we used
    the **Lasso Selection** tool in Mac’s Previews app, the little dashes that outlined
    the portion of the image selected were an example of this effect.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上是在创建一个行军蚁效果。你可能之前已经使用过这个效果，但不知道它叫什么名字——每次你使用鼠标或触控板来勾勒一个视图或围绕对象创建一个边界框以选择它们时，你都在使用行军蚁效果。你可能记得在[*第6章*](B18674_06.xhtml#_idTextAnchor082)中，当我们使用Mac预览应用中的**套索选择**工具时，勾勒所选图像部分的短划线就是这种效果的例子。
- en: 'So, to create our gear belt, let’s start this section by adding another new
    file, which we’ll call `BeltView`. Then, as we usually do, we’ll add the variables
    that make everything work first, inside the `BeltView` struct:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建我们的齿轮皮带，让我们从这个部分开始添加另一个新文件，我们将称之为 `BeltView`。然后，像我们通常做的那样，我们首先在 `BeltView`
    结构体中添加使一切工作的变量：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each one of these variables is in charge of a specific task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都负责一个特定的任务：
- en: '`animateBelt` keeps track of the animation for the belt.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animateBelt` 跟踪皮带动画。'
- en: '`beltWidth` and `beltHeight` set the width and height of the belt.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beltWidth` 和 `beltHeight` 设置皮带的宽度和高度。'
- en: '`offsetBeltX` and `offsetBeltY` locate the belt in specific areas on the screen.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetBeltX` 和 `offsetBeltY` 将皮带定位在屏幕上的特定区域。'
- en: '`dashPhaseValue` is in charge of designing the belt – for example, how far
    we want to space the belt segments apart from each other, how thick they should
    be, and so on.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashPhaseValue` 负责设计皮带——例如，我们希望皮带段之间相隔多远，它们应该有多厚，等等。'
- en: '`rotateDegrees` is used after we position the belt to rotate it either horizontally
    or vertically by passing in a degree number.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateDegrees` 在定位皮带后使用，通过传递一个度数来水平或垂直旋转皮带。'
- en: '`xAxis`, `yAxis`, and `zAxis` orient the belt on the *x*-, *y*-, and *z*-axes,
    respectively. You will see these three variables come into play when we start
    piecing together all these separate files into `ContentView`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xAxis`、`yAxis`和`zAxis`分别将皮带定位在*x*、*y*和*z*轴上。当你开始将这些单独的文件拼接到`ContentView`中时，你会看到这三个变量发挥作用。'
- en: 'With the variables in place, we can move into the `body` of the struct and
    start adding the code to create the belt. There’s not a lot of code to make a
    belt. First, start by adding a `ZStack` to hold our views:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量就绪后，我们可以进入结构的`body`部分，并开始添加创建皮带的代码。创建皮带不需要很多代码。首先，添加一个`ZStack`来容纳我们的视图：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we want to create the shape of the belt. If you look at most belts or
    chains that are gear-driven, they have a shape similar to a capsule, and luckily,
    SwiftUI gives us a capsule shape that we can use. Add the following code, including
    its modifiers, inside of the `ZStack`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建皮带形状。如果你看看大多数由齿轮驱动的皮带或链条，它们的形状类似于胶囊，幸运的是，SwiftUI为我们提供了一个我们可以使用的胶囊形状。在`ZStack`内部添加以下代码，包括其修改器：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is only about five lines of code, but it does a lot of work here. First,
    we declare the capsule shape that we need and then use the `stroke` modifier on
    it. The `stroke` modifier does quite a bit and is also responsible for designing
    the belt: its first parameter will give the belt a color (we have chosen black),
    and the second parameter is the `strokeStyle` parameter, where we pass in a `StrokeStyle`
    struct.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是大约五行代码，但在这里做了很多工作。首先，我们声明所需的胶囊形状，然后使用`stroke`修改器。`stroke`修改器做了很多事情，并且也负责设计皮带：它的第一个参数将为皮带赋予颜色（我们选择了黑色），第二个参数是`strokeStyle`参数，其中我们传递一个`StrokeStyle`结构体。
- en: 'This `StrokeStyle` struct has some parameters of its own that help style the
    belt:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`StrokeStyle`结构体有一些自己的参数，有助于美化皮带：
- en: The first one is the `lineWidth` parameter. This one is fairly self-explanatory;
    it just means how wide we want to make the belt, which we have set to `7` points.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是`lineWidth`。这个参数相当直观；它只是意味着我们想要将皮带设置多宽，我们将其设置为`7`点。
- en: There’s also a `lineJoin` parameter. This is a value that determines how the
    segments of the belt will join together. There are three options we could use,
    `round`, `bevel`, and `miter`; I thought the line segments would look best using
    the `round` option, however feel free to experiment with all these values and
    numbers to get the best look for you.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个`lineJoin`参数。这个值决定了皮带各段如何连接在一起。我们可以使用三种选项，`round`、`bevel`和`miter`；我认为使用`round`选项的线段看起来最好，但请随意尝试所有这些值和数字，以获得最适合你的外观。
- en: The next parameter is called `dash`, which is responsible for the length of
    the segments that’s used to create the belt, and the gap between those segments.
    The first value of this parameter will determine the length of the segment (a
    larger number makes the segments bigger, while a smaller number makes the segments
    smaller); I’m using `5` points for this value. The second value determines the
    gap size between the segments (a larger number creates a larger gap, while a smaller
    number creates a smaller gap); for this value, a `1.4` point value creates gap
    that looks really good.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个参数是`dash`，它负责创建皮带的段长度以及这些段之间的间隙。此参数的第一个值将决定段长度（较大的数字使段更大，而较小的数字使段更小）；我使用`5`点作为此值。第二个值决定了段之间的间隙大小（较大的数字创建更大的间隙，而较小的数字创建更小的间隙）；对于此值，`1.4`点的值创建了一个看起来非常好的间隙。
- en: After the `strokeStyle` struct, the next modifier is the `frame`, which sets
    the width and height of the whole belt. Then we added an `animation` modifier,
    with a `linear` animation and a duration of three seconds to complete one revolution,
    and `autoreverses` set to `false` (as we just want the belt to turn in one direction
    only).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`strokeStyle`结构体之后，下一个修改器是`frame`，它设置了整个皮带的宽度和高度。然后我们添加了一个`animation`修改器，具有`linear`动画和三秒钟完成一次旋转的持续时间，并将`autoreverses`设置为`false`（因为我们只想让皮带单向转动）。
- en: 'Now we need to add the `onAppear` modifier so we can start the animation when
    the app loads up. To do that, add the following code right under the existing
    code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加`onAppear`修改器，以便在应用加载时开始动画。为此，在现有代码下方添加以下代码：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code toggles the `animateBelt` property to `true`, kicking off the belt
    animation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将`animateBelt`属性切换为`true`，从而启动皮带动画。
- en: 'There’s only one last bit of code we need to add to finish off the styling
    of the belt, and that is to rotate the belt to the proper angle for the gears.
    Coming out of `ZStack`, just after its closing brace, add the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加最后一段代码来完成皮带样式的设置，那就是将皮带旋转到适合齿轮的正确角度。在 `ZStack` 的闭合括号之后，添加以下代码：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code will act on everything that is in the `ZStack` because it’s been
    put after its closing brace. Here, I added a `shadow` modifier, setting the color
    to black and a radius of `10` to make the belt more pronounced, and placed the
    shadow on the *x*-axis. You can play around with the colors and these numbers
    for the shadow: by increasing the radius, you will make the shadow bigger, and
    by increasing the numbers for the `x` and `y` parameters, you can move the shadow
    up, down, left, and right. Remember, you can use negative numbers to move the
    shadow in the opposite direction.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将对 `ZStack` 中的所有内容起作用，因为它被放置在其闭合括号之后。在这里，我添加了一个 `shadow` 修饰符，将颜色设置为黑色，半径设置为
    `10` 以使皮带更加突出，并将阴影放置在 *x* 轴上。你可以尝试调整阴影的颜色和这些数字：通过增加半径，你可以使阴影更大，通过增加 `x` 和 `y`
    参数的数值，你可以将阴影向上、向下、向左或向右移动。记住，你可以使用负数来将阴影移动到相反的方向。
- en: The next modifier we are placing on the entire `ZStack` is `rotationEffect`.
    This will rotate the completed belt to the angle we specify; when we call these
    various methods later in `ContentView`, we’ll pass in different values that’ll
    orient the belt and size it just the way we want.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要放置在整个 `ZStack` 上的下一个修饰符是 `rotationEffect`。这将使完成的皮带旋转到我们指定的角度；当我们稍后在 `ContentView`
    中调用这些各种方法时，我们将传入不同的值来定位皮带并调整其大小，使其正好符合我们的需求。
- en: Finally, we added the `offset` modifier, which allows us to place the belt anywhere
    on the screen using the *x*- and *y*-coordinates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了 `offset` 修饰符，它允许我们使用 *x* 和 *y* 坐标将皮带放置在屏幕上的任何位置。
- en: 'If you try to test out what we’ve done, you won’t see anything in the previews
    yet because we’ve just added a bunch of different variables into the `BeltView`
    struct. However, we’re not using those variables in the `Previews` struct. To
    fix this, let’s update the `Previews` struct to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试测试我们所做的，你预览中现在不会看到任何东西，因为我们刚刚向 `BeltView` 结构体中添加了一堆不同的变量。然而，我们并没有在 `Previews`
    结构体中使用这些变量。为了解决这个问题，让我们更新 `Previews` 结构体到以下内容：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run `Previews` now, you’ll see the belt in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行 `Previews` 时，你会看到皮带在动作：
- en: '![Figure 7.7: The finished belt with the marching ants effect ](img/B18674_07_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7：带有行军蚁效果的完成皮带](img/B18674_07_07.jpg)'
- en: 'Figure 7.7: The finished belt with the marching ants effect'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：带有行军蚁效果的完成皮带
- en: It’s turning clockwise, has a nice style and spacing to fit our gears later,
    and the shadow makes it really come off the screen a bit.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它是顺时针旋转的，有很好的样式和间距，以适应我们稍后的齿轮，阴影使其真正从屏幕上凸出来。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you notice that the belt is not animating smoothly, meaning it’s rotating
    but pauses slightly every few seconds or so, what you can do is play around with
    the `dashPhase` value, which is used to specify the starting point of the dashes
    in a dashed or dotted line. I set it to an initial value of `45` and that removed
    the pause for me, but if it does not remove it for your project, simply increase
    or decrease that value by 1, check the animation, and then tweak the value again
    by 1 until you find the sweet spot.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到皮带没有平滑地动画，这意味着它在旋转，但每隔几秒钟会稍微暂停一下，你可以尝试调整 `dashPhase` 值，该值用于指定虚线或点划线的起始点。我将其设置为初始值
    `45`，这为我消除了暂停，但如果它没有为你项目消除暂停，只需将此值增加或减少 1，检查动画，然后再次通过 1 调整值，直到找到最佳点。
- en: And that’s another file under our belt (sorry, couldn’t help myself!). Let’s
    continue on to the next section, where we’ll add a gear shaft to the mix. This
    object will turn a belt, which, in turn, will spin a fan.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是另一个文件，我们已经完成了（抱歉，我忍不住了！）。让我们继续到下一部分，我们将添加一个齿轮轴。这个对象将转动皮带，而皮带反过来会转动风扇。
- en: Animating a gear shaft image
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画齿轮轴图像
- en: Continuing on to the next component, we need a gear shaft. A gear shaft is a
    cylindrical rod that has round gears at each end and is used to attach other gears
    or belts together, ultimately producing some form of output or work. For example,
    within the motor in your car, there is a gear shaft that turns due to the gasoline
    combusting. The output or work produced by that process moves the car forward.
    Our gear shaft won’t move a car, but instead, will turn a fan. After creating
    this, as with the worm gear, we will animate the gear shaft by using animating
    rectangles. Again, this is because the image we are using is not round, so we
    cannot rotate it on the *z*-axis like the other gear images.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到下一个组件，我们需要一个齿轮轴。齿轮轴是一个圆柱形杆，两端有圆形齿轮，用于连接其他齿轮或皮带，最终产生某种形式的输出或工作。例如，在你汽车中的发动机内，有一个齿轮轴，由于汽油燃烧而转动。该过程产生的输出或工作使汽车前进。我们的齿轮轴不会移动汽车，而是会转动风扇。创建这个组件后，就像蜗轮齿轮一样，我们将通过使用动画矩形来动画化齿轮轴。同样，这是因为我们使用的图像不是圆形的，所以我们不能像其他齿轮图像一样在*z*轴上旋转它。
- en: 'Let’s start off by creating a new SwiftUI View file, which we’ll call `GearShaftView`.
    Next, let’s add the variables we need for this file; we only need one variable,
    and that’s to track the animation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的SwiftUI视图文件开始，我们将称之为`GearShaftView`。接下来，让我们添加这个文件所需的变量；我们只需要一个变量，那就是用于跟踪动画的变量：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After the variable, we just need to add the code for the gear shaft image and
    animate it. Add the following code inside the `body` property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量之后，我们只需要添加齿轮轴图像的代码并对其动画化。在`body`属性中添加以下代码：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We start by bringing the gear shaft image into the scene and setting the width
    and height dimensions for it. After that, we add a rectangle, which will be the
    animating shadow moving up and down over the shaft. The color of the shadow is
    black, with a little bit of a corner radius added on. The opacity will animate
    from 0, which is invisible, to 0.5, which is 50% visible. This will produce a
    nice shadowy rectangle that appears and disappears at the same cadence that the
    gears and shafts are turning.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将齿轮轴图像引入场景，并设置其宽度和高度尺寸。之后，我们添加一个矩形，它将作为动画阴影在轴上上下移动。阴影的颜色是黑色，并添加了一点点圆角半径。不透明度将从0（不可见）动画到0.5（50%可见）。这将产生一个漂亮的阴影矩形，其出现和消失的节奏与齿轮和轴的旋转节奏相同。
- en: In the next line of code, the animation is added, with a duration of one-half
    a second to complete one revolution. It has `autoreverses` set to `true` because
    if we set `autoreverses` to `false`, then the animation would look too abrupt
    (it needs `autoreverses` in order to slide the rectangle back down).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，添加了动画，完成一次旋转需要半秒钟。它将`autoreverses`设置为`true`，因为我们如果将`autoreverses`设置为`false`，那么动画看起来会太突然（它需要`autoreverses`以便将矩形滑回原位）。
- en: Then, we start the animation in the `onAppear` method and offset the rectangle
    so it’s neatly placed exactly where we want it, over the shaft image, using the
    `offset` modifier set to `0` for `x` and `–7` for `y`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`onAppear`方法中开始动画，并使用`offset`修改器将矩形偏移，使其整齐地放置在我们想要的位置，即轴图像上方，`x`设置为`0`，`y`设置为`-7`。
- en: We are getting close to putting all these files together, but next up, we’re
    going to animate the fan image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将将这些文件全部组合在一起，但接下来，我们将动画化风扇图像。
- en: Animating a fan image
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风扇图像的动画
- en: There are actually two components left to create, the fan and the motor. However,
    we will add the motor when we start piecing all of the files together inside `ContentView`.
    For that reason, let’s focus on creating the fan now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上还有两个组件需要创建，即风扇和电机。然而，当我们开始在`ContentView`内部拼接所有文件时，我们将添加电机。因此，让我们现在专注于创建风扇。
- en: 'Like always, create a new file, select the `FanView`. In this file, we only
    need two variables – one for the state of the animation and one to hold the degrees
    of rotation for the fan; here they are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，创建一个新的文件，选择`FanView`。在这个文件中，我们只需要两个变量——一个用于动画的状态，另一个用于存储风扇的旋转角度；它们如下所示：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This file is quite short, so just add the following code to complete it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件相当短，所以只需添加以下代码来完成它：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s review this code. Inside the `ZStack`, we added the image of the fan and
    resized it. Then we used the `rotationEffect` modifier on it to make it turn.
    We want the fan to spin around its center, so we set the anchor to `center`, and
    then add the animation with a duration of `4`, which means it will spin 4 revolutions
    in 4 seconds. After that, set the animation to `repeatForever` and set `autoreverses`
    to `false` (reverse because we want the fan to spin only in one direction).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这段代码。在 `ZStack` 中，我们添加了风扇的图片并调整了其大小。然后，我们使用 `rotationEffect` 修饰符来使其旋转。我们希望风扇围绕其中心旋转，因此我们将锚点设置为
    `center`，然后添加一个持续时间为 `4` 的动画，这意味着它将在 4 秒内旋转 4 圈。之后，将动画设置为 `repeatForever` 并将 `autoreverses`
    设置为 `false`（反向，因为我们希望风扇只按一个方向旋转）。
- en: Then, let’s start the animation using the `onAppear` modifier and add a nice
    heavy shadow around the fan with a `15`-point radius.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们使用 `onAppear` 修饰符开始动画，并在风扇周围添加一个半径为 `15` 点的阴影。
- en: And that completes the fan. Now, let’s now head over to `ContentView` to create
    the final component – the motor – and start bringing all the files together in
    one view.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在风扇就完成了。接下来，让我们转到 `ContentView` 来创建最终的组件——电机，并开始将所有文件整合到一个视图中。
- en: Bringing everything together in ContentView
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ContentView 中整合所有内容
- en: Okay – we have accomplished a lot, including creating files for single and double
    gears, a worm gear, a gearshift, and a fan. Now, let’s create the final file for
    the motor and organize all these files together in `ContentView`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好了——我们已经完成了许多工作，包括为单齿轮和双齿轮、蜗轮、换挡器和风扇创建了文件。现在，让我们创建电机的最终文件，并将所有这些文件组织到 `ContentView`
    中。
- en: We’re going to use a Swift feature called **Pragma Marks**; this is a special
    syntax that labels and delineates blocks of code with a very thin line between
    them and makes those labels appear in one drop-down menu for easy searching and
    navigation. That’s very helpful when you have very large files with hundreds or
    thousands of lines of code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 **Pragma Marks** 的 Swift 功能；这是一个特殊的语法，它使用非常细的线来标记和划分代码块，并使这些标签出现在一个下拉菜单中，以便于搜索和导航。这对于拥有数百或数千行代码的大型文件非常有帮助。
- en: We will also use a SwiftUI feature called `ContentView` file by grouping multiple
    objects together, such as views, scenes, or even commands, into a single unit.
    We will organize much of the code into groups based on whether it is animated
    on the *x*-, *y*-, or *z*-axis.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个名为 `ContentView` 的 SwiftUI 功能，通过将多个对象（如视图、场景或甚至命令）组合成一个单一单元来使用。我们将根据代码是否在
    *x*、*y* 或 *z* 轴上动画化，将大部分代码组织到不同的组中。
- en: And then we will use the **ZIndex** modifier. This modifier works with views
    that are overlapping each other, so it can be used to force a view either to the
    front or the back of other views. This is important because sometimes we need
    a view to be more prominent in the scene and another view to be hidden behind
    the scene, with only parts of it visible. You’ll see how this works soon.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 **ZIndex** 修饰符。这个修饰符与重叠的视图一起工作，因此可以用来强制一个视图位于其他视图的前面或后面。这很重要，因为有时我们需要一个视图在场景中更加突出，而另一个视图则被隐藏在场景后面，只有部分可见。你很快就会看到它是如何工作的。
- en: 'To help you complete this project, I have also labeled all the views to help
    you identify their location on the screen, and how they are oriented:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你完成这个项目，我还为所有视图添加了标签，以帮助你识别它们在屏幕上的位置以及它们的朝向：
- en: '![Figure 7.8: Our project with the views labeled ](img/B18674_07_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8：带有标签的我们的项目视图](img/B18674_07_08.jpg)'
- en: 'Figure 7.8: Our project with the views labeled'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：带有标签的我们的项目视图
- en: '**G** annotations refer to the gears and **B** annotations refer to the belts.
    I numbered each gear and belt according to how it will appear in the code. We
    will be writing this code sequentially by the numbers – so, **G1**, then **G2**,
    then **G3**, and so on. The diagram shows the placement of all the parts.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**G** 标注指的是齿轮，**B** 标注指的是皮带。我根据它们在代码中出现的顺序为每个齿轮和皮带编号。我们将按编号顺序编写代码——所以，**G1**，然后
    **G2**，然后 **G3**，依此类推。图示显示了所有部件的放置位置。'
- en: As always, we have the `ContentView` file already created for us when we started
    the project, so we don’t need to create any more new files. The first thing we
    are going to do here in `ContentView` is to add the motor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，当我们开始项目时，`ContentView` 文件已经为我们创建好了，所以我们不需要创建任何新的文件。在 `ContentView` 中，我们首先要做的是添加电机。
- en: Adding the motor
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加电机
- en: 'To add the motor, move into the `body` property of `ContentView` and then add
    a main `ZStack` to hold everything. Then, inside that, place another `ZStack`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加电机，进入 `ContentView` 的 `body` 属性，然后添加一个主要的 `ZStack` 来包含所有内容。然后，在那个内部放置另一个
    `ZStack`：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside the second `ZStack`, let’s add our first organizational structure, the
    Pragma Mark. To make a Pragma Mark, the syntax requires two forward slashes and
    `MARK` written in capital letters, followed by a colon. That will create a thin
    line moving across the file. You can write whatever you want after that for the
    title.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `ZStack` 内部，让我们添加第一个组织结构，即 Pragma 标记。要创建一个 Pragma 标记，语法需要两个正斜杠和用大写字母写的
    `MARK`，后面跟着一个冒号。这将创建一条穿过文件的细线。你可以在那之后写任何你想要的内容作为标题。
- en: 'So, to create a Pragma Mark for the motor, enter the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要为电机创建一个 Pragma 标记，输入以下代码：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, notice the very thin line that the Pragma Mark creates from one end of
    the code file to the other within the editor:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意 Pragma 标记在编辑器中从文件一端到另一端创建的非常细的线：
- en: '![Figure 7.9: Our first Pragma Mark ](img/B18674_07_09.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：我们的第一个 Pragma 标记](img/B18674_07_09.jpg)'
- en: 'Figure 7.9: Our first Pragma Mark'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：我们的第一个 Pragma 标记
- en: 'The Pragma Mark also does something very useful behind the scenes too. If you
    look at the top left of your Xcode menu bar, where all the tabs appear, you’ll
    see a **MOTOR** tab:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Pragma 标记也同时在幕后做一些非常有用的操作。如果你查看 Xcode 菜单栏的左上角，那里显示所有标签的地方，你会看到一个 **MOTOR** 标签：
- en: '![Figure 7.10: The Pragma Mark tab ](img/B18674_07_10.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10：Pragma 标记标签](img/B18674_07_10.jpg)'
- en: 'Figure 7.10: The Pragma Mark tab'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：Pragma 标记标签
- en: If you click on the tab, a drop-down menu will open up, containing all the Pragma
    Marks that you created; clicking on any one of them will take you immediately
    to the code in that part of the file. You’ll see the usefulness of this when you
    have dozens or even hundreds of different blocks of code in one file, eliminating
    the need to scroll through a lengthy file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击标签，将弹出一个下拉菜单，包含你创建的所有 Pragma 标记；点击任何一个都会立即带你到文件该部分的代码。当你在一个文件中有成百上千个不同的代码块时，你会看到这个功能的有用性，这样可以避免在冗长的文件中滚动。
- en: 'Now, let’s add the code that creates the motor in the scene:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加创建场景中电机的代码：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is our first time using the `Group` syntax. Looking at the code inside
    the group, it contains everything that we’ve been doing all along: creating the
    motor using the image that’s in the Assets catalog, resizing it, setting the aspect
    ratio so the motor fits on the screen as we want, giving it a frame size, and
    offsetting on the *x*- and *y*-axis.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次使用 `Group` 语法。查看组内的代码，它包含了我们一直在做的事情：使用 Assets 目录中的图片创建电机，调整大小，设置宽高比以便电机按我们的要求适应屏幕，设置框架大小，并在
    x 和 y 轴上偏移。
- en: 'If we run the code, this is what we should have in the previews so far:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，到目前为止预览中应该有这个样子：
- en: '![Figure 7.11: The motor ](img/B18674_07_11.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11：电机](img/B18674_07_11.jpg)'
- en: 'Figure 7.11: The motor'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：电机
- en: There’s only one object in that group, the motor, but that’s perfectly fine
    – we’ll be adding more objects into further groups as we make them. For now, let’s
    now add some gears to the scene.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那个组中只有一个物体，即电机，但这完全没问题——随着我们创建更多的组，我们将添加更多物体。现在，让我们添加一些齿轮到场景中。
- en: Adding the gears along the x-, y-, and z-axes
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沿着 x、y 和 z 轴添加齿轮
- en: In this section, we will use the `GearView` struct to add the gears. Remember,
    we already designed and animated the gears in the `GearView` file, so all we need
    to do is call the `GearView` struct here in `ContentView` and pass in some values.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `GearView` 结构体来添加齿轮。记住，我们已经在 `GearView` 文件中设计和动画化了齿轮，所以我们在这里在 `ContentView`
    中调用 `GearView` 结构体并传递一些值即可。
- en: 'This is where we will also be rotating the gears and belts on the *x*-, *y*-,
    and *z*-axes, so to recap how each axis operates on the screen (shown back in
    *Figure 7**.1*):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在 x、y 和 z 轴上旋转齿轮和皮带的地方，所以为了回顾每个轴在屏幕上的操作（如 *图 7.1* 中所示）：
- en: The *y*-axis runs from top to bottom and bottom to top.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y 轴从上到下和从下到上运行。
- en: The *x*-axis runs from left to right and right to left.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x 轴从左到右和从右到左运行。
- en: The *z*-axis moves from back to front or front to back. Holding an object in
    your hand and moving closer to your eyes is an example of moving that object along
    the *z*-axis.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: z 轴从后向前或从前向后移动。用手拿着物体并靠近眼睛是沿着 z 轴移动该物体的一个例子。
- en: 'With that understanding, let’s start adding components. Put the following code
    in right after the closing brace of the motor group:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些，让我们开始添加组件。在电机组的闭合花括号后立即放置以下代码：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I titled this group `GEARS ANIMATING ON THE Z AXIS`. Here, I’m calling the `GearView`
    struct six times, which creates six gears that are turning on the *z*-axis. Let’s
    just look at `Gear 1`, as they are pretty similar, just with different values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个组命名为 `GEARS ANIMATING ON THE Z AXIS`。在这里，我调用了 `GearView` 结构六次，创建了六个在 *z*-
    轴上旋转的齿轮。让我们只看看 `Gear 1`，因为它们非常相似，只是值不同。
- en: So, in `Gear 1`, I set the gear’s width to `40` points, which makes a small
    gear, and positioned it directly over the front of the motor using the `offsetGearX`
    and `offsetGearY` parameters. The amount of degrees passed into the `gearDegrees`
    parameter is `360`; that’s one revolution of a circle, as we want these gears
    to turn for a full revolution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `Gear 1` 中，我将齿轮的宽度设置为 `40` 点，这使得它成为一个小齿轮，并使用 `offsetGearX` 和 `offsetGearY`
    参数将其直接定位在电机的前面。传递给 `gearDegrees` 参数的度数是 `360`；这是一个圆的一周，因为我们希望这些齿轮完成一次完整旋转。
- en: Since these are 2D images and not 3D images of gears, the depth is not really
    perceivable, and the gears will lie flat and be animated clockwise. The `duration`
    parameter controls the amount of time it takes the gear to turn one full revolution;
    I’m using a value of `7` for the larger gears, and a value of `5` for the smaller
    ones. The small and larger gears are made using the `gearWidth` parameter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是 2D 图像而不是齿轮的 3D 图像，深度实际上是不可感知的，齿轮将平躺并顺时针动画化。`duration` 参数控制齿轮完成一次完整旋转所需的时间；我使用
    `7` 的值用于较大的齿轮，而较小的齿轮使用 `5` 的值。小齿轮和较大齿轮是通过 `gearWidth` 参数制作的。
- en: Looking at the `gearDegrees` parameter, the values I’m using are all set to
    `360` (a positive number) to move them clockwise. Well, that is except for `Gear
    5`, which is set to `-360` (a negative), as that gear will move counterclockwise.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到 `gearDegrees` 参数，我使用的值都设置为 `360`（一个正数），以使它们顺时针旋转。嗯，这除了 `Gear 5` 以外，它被设置为
    `-360`（一个负数），因为那个齿轮将逆时针旋转。
- en: 'This is what the previous code we just wrote should look like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们刚才编写的代码应该看起来像的：
- en: '![Figure 7.12: The gears rotating on the z-axis ](img/B18674_07_12.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12：在 z 轴上旋转的齿轮](img/B18674_07_12.jpg)'
- en: 'Figure 7.12: The gears rotating on the z-axis'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：在 z 轴上旋转的齿轮
- en: If you run this in the simulator, all of those gears will now be turning because
    we set the animation up already in the `GearView` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个模拟器中运行它，所有这些齿轮现在都会转动，因为我们已经在 `GearView` 文件中设置了动画。
- en: 'Let’s continue and add another group of gears that animate on the *y*-axis
    this time. Add the following code right under the closing brace of the previous
    group:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并添加另一组齿轮，这次它们将在 *y*- 轴上动画化。在上一组代码的闭合花括号下添加以下代码：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, we start off this group of code by adding our organizational Pragma Mark
    called `GEARS ANIMATING ON THE Y AXIS`. Here, we call the `GearView` struct four
    times, creating four gears that will rotate on the *y*-axis.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从这个组的代码开始，添加我们的组织性 Pragma 标记，称为 `GEARS ANIMATING ON THE Y AXIS`。在这里，我们调用了
    `GearView` 结构四次，创建了四个将在 *y*- 轴上旋转的齿轮。
- en: Looking at `Gear 7` as an example, this has a width of `100` points, and `gearDegrees`
    is set to `-360` (which means the gear rotates counterclockwise). Next, the code
    repositions the gears using the `offsetGearX` and `offsetGearY` parameters. And
    by using the `rotateDegrees` parameter, and passing in a value of `76`, we can
    rotate this gear on the *y*-axis.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `Gear 7` 为例，它的宽度为 `100` 点，`gearDegrees` 被设置为 `-360`（这意味着齿轮逆时针旋转）。接下来，代码使用
    `offsetGearX` 和 `offsetGearY` 参数重新定位齿轮。通过使用 `rotateDegrees` 参数并传递 `76` 的值，我们可以在
    *y*- 轴上旋转这个齿轮。
- en: The other three gears are almost exactly the same, except their size and offset
    locations vary, but they will all turn on the *y*-axis.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个齿轮几乎完全相同，只是它们的大小和偏移位置不同，但它们都将旋转在 *y*- 轴上。
- en: 'After adding this group of code, this is what your previews should look like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这一组代码后，你的预览应该看起来像这样：
- en: '![Figure 7.13: The gears rotating on the y-axis ](img/B18674_07_13.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13：在 y 轴上旋转的齿轮](img/B18674_07_13.jpg)'
- en: 'Figure 7.13: The gears rotating on the y-axis'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：在 y 轴上旋转的齿轮
- en: Now, when you run the simulator, all these gears will be turning on their set
    axis.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行模拟器时，所有这些齿轮都会在其设定的轴上旋转。
- en: 'Let’s continue and add another group that will make a gear animate on the *x*-axis.
    Add the following code right after the closing brace of the previous group:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `GEAR ANIMATING ON THE X AXIS` group just has one gear here and it’s the
    biggest gear so far, with a width of `175` points. This gear will mesh up with
    two other gears – the gear to its right in the scene and the worm gear.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the code we’ve already placed for the other gears in that
    we use the `GearView` initializer to create it and use the same parameters to
    size and locate it in the scene, but the difference here is that we’re using the
    `xAxis` parameter, and passing in a value of `1`. The `xAxis` parameter will rotate
    this gear on the *x*-axis, a completely different angle than for the *y*-axis
    or *z*-axis. The amount of rotation is `84` degrees.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Before we run this and check things out, let’s add the worm gear to see how
    everything fits together.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Adding the worm gear
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the worm gear to our `ContentView`, add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This grouping is labeled `WORM GEAR` and is placed using the `offset` modifier.
    Something new here though is the `zIndex` modifier. The `zIndex` modifier places
    a view in front of or behind other views, which allows us to position our views
    from front to back or vice versa.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve talked about the *z*-axis already, which relates to depth and objects
    moving closer to and farther away from us. Why would we want to move a view closer
    or further away from our perspective? Well, let’s look at an example of what happens
    if we don’t use the `zIndex` modifier in our code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Adding the worm gear without zIndex ](img/B18674_07_14.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Adding the worm gear without zIndex'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: From the illustration, you can see that the worm gear has now moved to the front,
    which is not the placement that I want. I want the worm gear to mesh up from behind
    `Gear 9`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the `zIndex` modifier back into our code and look at the results:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Adding the worm gear with zIndex ](img/B18674_07_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Adding the worm gear with zIndex'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: All views in SwiftUI have a default `zIndex` of `0`, so when I passed in a negative
    number, the worm gear was placed behind `Gear 9`. As you can see, this can be
    an important modifier when trying to organize your views regarding how close or
    far away you want them to be.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have finished all the gears, so now we can move on to adding
    the belts into the scene.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Adding the belts
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the building out of our scene, let’s add the belts. Add the
    following grouping, which contains three belts that move on the *z*-axis:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we called the `BeltView` struct, set the `animateBelt` properties to
    `true`, and then gave each belt an appropriate width and height so it could connect
    to its corresponding gears using the `beltWidth` and `beltHeight` parameters.
    After that, we place the belts where they need to be using the `offsetBelt` parameters.
    Finally, we rotated the belts either by `90` degrees, which places the belt vertically,
    or by `0` degrees, which places the other belt horizontally. Here’s what they
    look like in relation to the gears they mesh with:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了`BeltView`结构体，将`animateBelt`属性设置为`true`，然后为每条皮带设置了适当的宽度和高度，以便它们可以使用`beltWidth`和`beltHeight`参数连接到相应的齿轮。之后，我们使用`offsetBelt`参数将皮带放置在它们需要的位置。最后，我们将皮带旋转90度，使皮带垂直，或者旋转0度，使另一条皮带水平。以下是它们与它们啮合的齿轮的相对位置：
- en: '![Figure 7.16: The belts on the z-axis ](img/B18674_07_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16：z轴上的皮带](img/B18674_07_16.jpg)'
- en: 'Figure 7.16: The belts on the z-axis'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：z轴上的皮带
- en: 'Now, let’s take a look at rotating belts on the *y*-axis. As before, add the
    following code after the closing brace of the previous group:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看*y*-轴上的旋转皮带。和之前一样，在上一组的闭合括号之后添加以下代码：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Calling the `BeltView` struct again, we have set these two belts to a width
    and height appropriate for the gear they will be meshed with. Then, we used the
    `rotation3DEffect` modifier and rotated these belts on the *y*-axis. The rotation
    happens when we pass a value of `1` into the `y` parameter, and they will rotate
    by `75` degrees. As with the other belts, we offset them so that they line up
    with their corresponding gears using the `offset` modifier.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用`BeltView`结构体，我们将这两条皮带设置为与它们将要啮合的齿轮相匹配的宽度和高度。然后，我们使用了`rotation3DEffect`修改器，并在*y*-轴上旋转了这些皮带。当我们将`1`的值传递到`y`参数时，它们将旋转75度。和其他皮带一样，我们使用`offset`修改器将它们偏移，使它们与相应的齿轮对齐。
- en: 'Now, your previews should look like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的预览应该看起来像这样：
- en: '![Figure 7.17: The belts on the y-axis ](img/B18674_07_17.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17：y轴上的皮带](img/B18674_07_17.jpg)'
- en: 'Figure 7.17: The belts on the y-axis'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：y轴上的皮带
- en: All those belts and gears will be fully animated if you run the project in the
    simulator. That leaves us with only two more groups to go – the gear shaft and
    fan, and a background.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个模拟器中运行项目，所有这些皮带和齿轮都将完全动画化。这让我们只剩下两个小组要完成——齿轮轴和风扇，以及背景。
- en: Adding the gear shafts
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加齿轮轴
- en: 'To bring the shafts into the scene, add the following code next:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要将轴引入场景，请添加以下代码：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is our `GEAR SHAFT` group. Here, I’m calling the `GearShaftView` struct
    twice, to create two gear shafts. Then, all we have to do is simply offset them
    to the proper locations, and call `zIndex` on them, passing in a negative value.
    This will position them behind the other views, creating the illusion that the
    shaft is actually part of the worm gear. Here’s what the previous code produced:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`GEAR SHAFT`小组。在这里，我调用了两次`GearShaftView`结构体，以创建两个齿轮轴。然后，我们只需简单地将它们偏移到正确的位置，并对它们调用`zIndex`，传入一个负值。这将使它们位于其他视图的后面，从而产生齿轮轴实际上是蜗轮齿轮一部分的错觉。以下是之前代码产生的结果：
- en: '![Figure 7.18: The gear shafts ](img/B18674_07_18.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18：齿轮轴](img/B18674_07_18.jpg)'
- en: 'Figure 7.18: The gear shafts'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：齿轮轴
- en: The worm gear and the gear shaft are the two objects that we could not animate
    with conventional methods because that would not look good, and it wouldn’t be
    an accurate representation of how they turn in the physical world. So, we created
    our shadow boxes and placed them strategically over these two shafts. When you
    run this in the simulator, you’ll notice these rectangles appear to make the worm
    gear and two shafts turn.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 蜗轮齿轮和齿轮轴是两个我们无法使用传统方法进行动画化的对象，因为那样看起来不好，而且也不会准确反映它们在物理世界中的转动方式。因此，我们创建了我们的阴影框，并将它们战略性地放置在这两个轴的上方。当你在这个模拟器中运行时，你会注意到这些矩形似乎使蜗轮齿轮和两个轴转动。
- en: Remember, these are just images that are sitting on the screen doing nothing,
    but because of a little trickery, they actually appear like they’re turning!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些只是静止在屏幕上什么也不做的图像，但多亏了一点小技巧，它们实际上看起来像是在转动！
- en: Now, let’s add the final group – the fan.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加最终的组——风扇。
- en: Adding the fan
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加风扇
- en: 'It would be nice if all of these gears and belts would produce some sort of
    output, so in this project, that output will be to spin a fan. Let’s now add the
    final grouping of code right under the existing group:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些齿轮和皮带都能产生某种输出那就太好了，所以在本项目，这个输出将是旋转一个风扇。现在，让我们在现有组下方添加最终的代码组合：
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All we have done is called the `FanView` struct, offset it to the bottom of
    the scene, and set a width for it (since it’s round, we don’t need to set a height).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切都称为`FanView`结构，将其偏移到场景底部，并为其设置宽度（因为它圆形，所以我们不需要设置高度）。
- en: 'Nearly there, just one last task: adding a background.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接近完成，只剩最后一个任务：添加背景。
- en: Adding the background
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加背景
- en: 'I have a nice gold background that’ll look great with all the objects against
    it, so let’s come out of the main `ZStack`, and after its closing brace, add the
    following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个漂亮的金色背景，与所有物体搭配起来会非常好看，所以让我们从主`ZStack`中退出，在其闭合括号之后，添加以下代码：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This sets the gold background to a frame width and height of `400` x `1000`,
    sitting nicely on an iPhone.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将金色背景设置为`400` x `1000`的框架宽度和高度，完美地放置在iPhone上。
- en: 'Finally, run that in the simulator and see what you think:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在模拟器中运行并看看你的想法：
- en: '![Figure 7.19: The completed project ](img/B18674_07_19.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19：完成的项目](img/B18674_07_19.jpg)'
- en: 'Figure 7.19: The completed project'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：完成的项目
- en: Feel free to play around with all the parameters and settings, changing the
    colors of the belts or objects, changing the angles of rotation, and so on. This
    will allow you to really understand what these parameters and functions all do,
    and how they synergistically work together!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整所有参数和设置，改变皮带或物体的颜色，改变旋转角度等等。这将帮助你真正理解这些参数和函数都做了什么，以及它们如何协同工作！
- en: 'Also, notice that we continued to use Pragma Marks throughout the project.
    Let’s see how handy they are; so, come back up to the menu bar and click on the
    last tab (this tab doesn’t have a name, but you can *always* find the Pragma Marks
    in the last tab of the menu bar):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们在整个项目中继续使用`Pragma Marks`。让我们看看它们有多方便；所以，回到菜单栏并点击最后一个标签（这个标签没有名字，但你可以在菜单栏的最后一个标签中*总是*找到`Pragma
    Marks`）：
- en: '![Figure 7.20: Viewing the Pragma Marks of the project ](img/B18674_07_20.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20：查看项目的`Pragma Marks`](img/B18674_07_20.jpg)'
- en: 'Figure 7.20: Viewing the Pragma Marks of the project'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：查看项目的`Pragma Marks`
- en: Every Pragma Mark indicates a different area of code based on the title we gave
    it, which makes it very easy to jump to in an instant, regardless of how big the
    file is.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Pragma Marks`都基于我们给出的标题指示不同的代码区域，这使得无论文件有多大，都能瞬间跳转到它。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In summary, through creating this project, we’ve accomplished quite a bit. As
    before, you saw how to create separate files – in this case, gears and chains
    – how to make a marching ants effect, how to combine everything into `ContentView`,
    and how to organize the code neatly using Pragma Marks and Groups. You also learned
    how to animate objects on all three axes, *x*-, *y*-, and *z*-, and saw how to
    use `zIndex` to place views more dynamically, from back to front, and vice versa.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总结，通过创建这个项目，我们取得了相当大的成就。就像之前一样，你看到了如何创建单独的文件——在这个案例中，齿轮和链条——如何制作蚂蚁行军效果，如何将一切组合到`ContentView`中，以及如何使用`Pragma
    Marks`和组来整洁地组织代码。你还学习了如何沿所有三个轴（*x*、*y*、*z*）动画化对象，以及如何使用`zIndex`更动态地放置视图，从后往前，反之亦然。
- en: In the next project, we will look at animating a flower and its petals so that
    it appears to be breathing, and creating some snow in the background.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将查看如何使花朵及其花瓣看起来像在呼吸，并在背景中创建一些雪花。
