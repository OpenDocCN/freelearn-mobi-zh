- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Series of Belts and Gears
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we’re going to explore rotation, and more specifically, how
    to use the `rotation3DEffect` modifier to rotate objects on the *x*-, *y*-, and
    *z*-axis. We will be doing this by animating a series of gears and belts that
    will eventually move a fan blade.
  prefs: []
  type: TYPE_NORMAL
- en: As we create this project, we will also explore how to use Groups and Pragma
    Marks to make your code more organized, and the `zIndex` property, which changes
    the depth of views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating our first circular gear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a worm gear using shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a marching ants effect to create a gear belt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a gear shaft image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a fan image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing everything together in `ContentView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 7` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Animating our first circular gear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, let’s create a new project, which I’m calling `Gears and Belts`.
    Then, add the images for the project (which you can find in the GitHub repository
    provided in the *Technical requirements* section) by dragging and dropping the
    images into Swift’s asset catalog. The images we are using are `singleGear`, `doubleGear`,
    `wormGear`, `motor`, `shaft`, `fan`, and `goldBackground`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to start by animating a gear image around the
    *z*-axis, so let’s make a SwiftUI file that will handle creating all the gears
    we need (as we have done in previous projects, we are going to work on each element
    for the project in separate files, and then piece them together in `ContentView`
    to create the finished animations).
  prefs: []
  type: TYPE_NORMAL
- en: To do this, go to `GearView` and press **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can fill this file by adding the variables needed to make and animate
    gears images. Let’s start with a `State` variable that keeps track of the animation
    state, the state being whether the animation is in motion or not. Add this `@State`
    variable to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This variable will help to keep track of whether the gear image is rotating
    or not, so I have called it `rotateGear`. It is also set to `false`, which means
    the animation will start inactive until this variable is changed to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next variable will be of the `String` type, which we can use to set the
    name of the gear image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look back into the asset catalog, you will see that you placed three
    different types of gear in there: a single gear, a double gear, and a worm gear.
    So, when it comes time to use all these files in `ContentView`, this `gearImage`
    variable will help save time, as all we need to do is to type in the name of the
    gear we want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to be able to set the size of the gear; here’s another variable
    to handle that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why we are setting the width of the gear but not the
    height. Well, the gear images we are using are circles (except for the worm gear);
    as you may know, circles only need one dimension, the width or height, because
    circles have a diameter that is always the same, regardless of which dimension
    is measured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the variables needed for this file, let’s add another variable
    that indicates the number of degrees our gear will turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This variable is called `gearDegrees`. A value of `360` will turn the gear image
    for one revolution, but right now, it is initialized as `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also place gears all around the screen, so we’ll need to set a couple
    of variables to handle the location of these gears. We will use two of them to
    set the `X` and `Y` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to be able to rotate the gears, and later the belts, to different
    orientations in relation to their surroundings, so let’s add a variable that will
    be in charge of setting that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add a variable to set the duration of the spinning gear, meaning
    how long it takes to finish one revolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The duration variable is set to `0`, but when it gets set to a value such as
    `7`, for example, that means it will take 7 seconds for the gear to turn one full
    revolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for this file, we need three more variables to set the *x*-, *y*-,
    and *z*-axis position of the gear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each of these variables will control the axis that the gear rotates around.
    The axis is what allows us to rotate an object in three dimensions, which will
    help create perspective and the effect of depth in the scene. These variables
    are appropriately named `xAxis`, `yAxis`, and `zAxis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all the variables in place, so let’s now add the code into the body
    of the struct and make our first gear. First, let’s add a `ZStack` to hold all
    of the views we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `ZStack`, we can use the `Image` initializer, which will place
    a gear image on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we have initialized the preceding `gearImage` variable to an empty
    string; this is what we want because it allows us to pass in different string
    names that represent the gear images in the asset catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need several modifiers to size and place the gear image, as well as
    the animation modifiers to make the gear image turn. Add the following code under
    `Image(gearImage)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the modifiers we are using here:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we know that we need to give the image the ability to resize, which
    is what the `resizable` modifier is for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we want to constrain the gear image dimensions with the `fit` aspect ratio
    option; as we have seen before, this mode preserves the content’s aspect ratio
    and indicates that the object should be scaled to fit within the available space
    while maintaining its aspect ratio. This means that the object will be scaled
    down if necessary so that it fits within the space it’s being displayed in, without
    distorting its shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other option is `fill`; this means that the object will be scaled up or
    down to fill the space it is being displayed in without distorting its shape.
    Some parts of the object may be outside of the visible area, but the object will
    maintain its aspect ratio. We haven’t used this here though.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the frame of the image is set with the `gearWidth` modifer, which has
    been initialized to `0`. By doing this, we can pass in whatever value we need
    to create any size gear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line calls the `rotationEffect` modifier, which will rotate `gearImage`
    by a value we pass in. This modifier will only rotate the gear image when the
    `rotateGear` variable becomes `true`; otherwise, a value of `0` gets used, meaning
    no rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we add the `animation` modifier, which gets a `linear` animation.
    The duration of the animation will depend on the value that’s held in the `duration`
    variable – here, we have set the duration to `repeatForever` and `autoreverses`
    to `false`. Then, we have the `value` parameter, which accepts into its parameter
    the variable we want to animate and then applies the animation to the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next modifier is an interesting one, it’s called `rotation3DEffect`. This
    rotates a view in three dimensions around the given axis; the amount of rotation
    will be determined by the `degrees` modifier that is being used within it. To
    understand how the view will be rotated, it’s important to know where the *x*-,
    *y*-, and *z*-axes exist on an iPhone screen. Look at the following illustration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.1: The three axes ](img/B18674_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The three axes'
  prefs: []
  type: TYPE_NORMAL
- en: The *x*-axis runs from left to right on the iPhone screen, the *y*-axis runs
    from top to bottom, and the *z*-axis runs from back to front. These axes are three
    different planes of dimensional space that hold views or objects, and when an
    object rotates, it does so on one, or all, of these axes. Looking at the `rotation3DEffect`
    modifier, if we pass a value in one of the axis parameters, the view will then
    rotate on that axis by the specified number of degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the code, lastly, the gear image will need to be placed somewhere on
    the screen; for that placement, we can use the help of the `offset` modifier.
    This modifier has two parameters, `x` and `y`, and the values will be determined
    by the `offsetGearX` and `offsetGearY` variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the modifiers all in place, we only need to start the animation, so let’s
    add the following code at the end of ZStack’s closing brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `onAppear` modifier, as we have seen before, will run the code in its body
    when the scene first appears. In the code, we want to toggle the `rotateGear`
    variable to `true` to start the animation. I’m also adding a little bit of black
    shadow to the gear image, which gives it a nicer look around its border.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with everything we coded so far though, we still don’t see any images
    in the previews! Let’s fix that and add some values into the `Previews` struct
    in order to create a gear. In this example, we’ll use the double gear image, and
    give it a size. Place the following code in `GearView_Previews` so we can see
    the animation work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code fills out the `GearView` struct with some values. The first parameter
    uses the `doubleGear` image from the asset catalog as the gear to display. Next,
    the `gearWidth` and `gearDegrees` parameters receive values to set the width and
    turning degree. Then, for the `offset` parameters, by setting them to zero, the
    gear will just stay in the middle of the screen. Finally, adding a duration of
    5 seconds means it’ll take 5 seconds for the gear to turn for one complete revolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that in place, now, we can run the previews and check what we have
    done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Adding our first gear ](img/B18674_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Adding our first gear'
  prefs: []
  type: TYPE_NORMAL
- en: The gear now turns, again, at a rate of one revolution in 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that I’m setting a fixed width and height for the preview window,
    as we don’t need a full-size screen to display a small gear; 200 x 200 is more
    than enough room.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with our gear in place and this file complete, anytime we need to make
    a gear anywhere in the project, all we have to do is call the `gearView` struct
    and pass in some values to create a gear of any size, wherever needed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: However, despite all that work, there is one gear that we won’t be able to turn
    in any meaningful way because it’s not a circular shape, and that’s the worm gear
    image in the asset catalog. In the next section, I’ll explain what a worm gear
    is, and how to make it turn, or at least make it look like it’s turning.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a worm gear using shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worm gears look like big screws with spiral threads, but without a screw head
    on the top. They’re used in equipment and machines where strength is an important
    factor because they are very durable and can handle a lot of torque. Here is a
    typical worm gear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: A worm gear ](img/B18674_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: A worm gear'
  prefs: []
  type: TYPE_NORMAL
- en: If we add a worm gear image to the project and animate it as we did with the
    round gear, it wouldn’t work very well, simply because the worm gear image is
    not a round shape. So, how can we make an irregularly shaped image appear like
    it’s turning as it would in the real world?
  prefs: []
  type: TYPE_NORMAL
- en: What we can do is place small, shaded rectangles over the shiny parts of the
    worm gear image and animate those rectangles instead, which will create the illusion
    that the image is turning or spinning. Clever, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file, choose the `WormGearView`. Inside this file, within
    the `WormGear` struct, we will start off by adding four `State` properties, one
    for each rectangle we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our main `ZStack`, let’s add another `ZStack` within to display the
    worm gear image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Image` initializer declares the image and resizes it to a width and height
    that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the first rectangle that we need to place over the shiny
    part of the worm gear. To do so, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The rectangles will be placed in an `HStack` because we want to put them side
    by side, going from left to right across the gear. We’re also using familiar modifiers
    that we’ve used before. We’ve made the rectangles black and given them a slight
    corner radius. The opacity of the rectangle will depend on whether the animating
    variable called `rect1` is `true` or not: if the `rect1` property becomes `true`,
    then we will give the rectangle a bit of visibility using an `opacity` of `0.3`;
    when the `rect1` property is `false`, we’ll remove all opacity and hide it.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code uses the `offset` modifier to place this rectangle directly
    over the first shiny part of this worm gear on the left side. This `offset` modifier
    is also responsible for moving the small rectangle up and down on the *y*-axis,
    either up `14` points when `rect1` is `true`, or it will move the rectangle down
    to `-8` points when it becomes `false`. The effect we’re going for here is to
    animate these tiny rectangles up and down and at the same time, fade them in and
    out over the shiny part of the worm gear image, creating the illusion that the
    part is turning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `animation` modifier: this uses an `easeInOut` timing curve, has
    a duration of half a second, and is set to `repeatForever`, with `autoreverses`
    set to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `rotationEffect` modifier is used to rotate this small rectangle
    exactly where we want it on the worm gear. The rectangle will rotate around the
    anchor point, which we have set to the top part of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, in the `onAppear` modifier, we toggled `rect1` so the animation
    starts when the view appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and run the project; you can see the results in the preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: A worm gear in our animation ](img/B18674_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A worm gear in our animation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the figure, it’s a bit hard to see the rectangle, but it’s definitely
    there, a faint thin rectangle just after the third tooth. If you want to see the
    rectangle better, remove the worm gear by misspelling `wormGear` in the `Image`
    initializer, which will remove the worm gear from the previews (they hate when
    we misspell something!). When you run the project again, this is what you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The rectangle that overlays the worm gear ](img/B18674_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The rectangle that overlays the worm gear'
  prefs: []
  type: TYPE_NORMAL
- en: You should see the rectangle moving up and down, as well as fading in and out.
  prefs: []
  type: TYPE_NORMAL
- en: For the placement of this rectangle, ideally, we want it to be on the left,
    over the first tooth; however, that will happen when we add the other rectangles
    into this `HStack`. Remember, an `HStack` lines everything up from left to right,
    but since we only have one rectangle in the `HStack`, the `HStack` places it in
    the middle for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s now add a second rectangle into the `HStack`, just under the first
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code is almost identical to what we’ve just added for the first rectangle.
    The difference here is we are offsetting the rectangle to a different location
    over the gear image, and the rotation is slightly different so it can be lined
    up over the next shiny part of the gear.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and you’ll see two animating rectangles. They’re not quite centered
    over the first and second shiny teeth of the gears yet, because we have two more
    rectangles to add, and then the `HStack` will center each animating rectangle
    perfectly for us.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue and add the third and fourth rectangles though, take a look
    at the first three modifiers of these two rectangles that we just added. They
    both have identical values in them, so we are repeating the code here, which is
    what we try to avoid when programming. Since the values don’t change in these
    modifiers and we will use them in all four rectangles, instead, we can make a
    custom modifier into which we can put these three modifiers and shorten our code
    a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom modifier, we need to create a struct that conforms to the
    `ViewModifier` protocol. This protocol has one requirement, which is to implement
    a method called `body content` that will accept our content and then must return
    a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a custom modifier at the bottom of the `WormGear` file. Moving
    outside of the `WormGear` struct completely and coming to the bottom of this file,
    add the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a custom modifier struct, which I called `RectModifiers`; as you can
    see, we are implementing the `body content` method inside it, which is the requirement
    needed to satisfy the `ViewModifier` protocol. Then, I added the three modifiers
    that we were repeating in our code (i.e., the ones that weren’t changing in value:
    `frame`, `foregroundColor`, and `cornerRadius`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is go back to the first rectangle that we created, just
    after the worm gear creation, remove those three modifiers, and instead, call
    our custom modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To use it, we pass into it the name of the custom struct we just made, `RectModifiers`.
    This new modifier struct can hold as many modifiers as we want to put in there,
    so modifiers that don’t change in value are probably a good idea to use here;
    this reduces the amount of code we need to write, especially if we have many views
    (for example, if we were to add 30 or 40 rectangles in this file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can proceed to add the final two rectangles to help with the illusion
    that this gear is turning. Here’s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try it out, let’s add some shadow to these moving rectangles to help
    make them a little more pronounced. Add this code at the end of the closing brace
    of the first `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By using the `shadow` modifier, and passing in a black shadow to go over each
    rectangle, I have given this shadow `4` points of radius, and the shadow will
    be shown on the *y*-axis with a value of `1`. Using a positive number value will
    move the shadow along the *y*-axis, while using a negative number will move the
    shadow along the *y*-axis in the opposite direction. Play around with these numbers
    so you can see how they affect the shadow’s prominence and location.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that code, this file is now complete. Run the project and see what
    you think:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: The finished worm gear ](img/B18674_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: The finished worm gear'
  prefs: []
  type: TYPE_NORMAL
- en: We have a worm gear that actually looks like it’s turning. Notice that each
    rectangle has lined up completely over the teeth of the worm gear, starting from
    the left and moving to the right. The shiny parts are being covered up and exposed
    over and over again, at a nice even pace, which is actually about how fast many
    worm gears work.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have finished animating the worm gears, we’re going to create a marching
    ants effect that we can use to simulate a moving gear chain. We can accomplish
    that using the `dashPhase` initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Using a marching ants effect to create a gear belt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have animated our circular and worm gears, next, we need to make
    some belts that can be used to wrap around those gears and connect them.
  prefs: []
  type: TYPE_NORMAL
- en: What we are actually doing is creating a marching ants effect. You probably
    have used this effect before, but without knowing what it was called – anytime
    you used your mouse or trackpad and outlined a view or created a bounding box
    around objects to select them, you were using the marching ants effect. You may
    remember that in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082) when we used
    the **Lasso Selection** tool in Mac’s Previews app, the little dashes that outlined
    the portion of the image selected were an example of this effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create our gear belt, let’s start this section by adding another new
    file, which we’ll call `BeltView`. Then, as we usually do, we’ll add the variables
    that make everything work first, inside the `BeltView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of these variables is in charge of a specific task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`animateBelt` keeps track of the animation for the belt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beltWidth` and `beltHeight` set the width and height of the belt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetBeltX` and `offsetBeltY` locate the belt in specific areas on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashPhaseValue` is in charge of designing the belt – for example, how far
    we want to space the belt segments apart from each other, how thick they should
    be, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateDegrees` is used after we position the belt to rotate it either horizontally
    or vertically by passing in a degree number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xAxis`, `yAxis`, and `zAxis` orient the belt on the *x*-, *y*-, and *z*-axes,
    respectively. You will see these three variables come into play when we start
    piecing together all these separate files into `ContentView`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the variables in place, we can move into the `body` of the struct and
    start adding the code to create the belt. There’s not a lot of code to make a
    belt. First, start by adding a `ZStack` to hold our views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to create the shape of the belt. If you look at most belts or
    chains that are gear-driven, they have a shape similar to a capsule, and luckily,
    SwiftUI gives us a capsule shape that we can use. Add the following code, including
    its modifiers, inside of the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only about five lines of code, but it does a lot of work here. First,
    we declare the capsule shape that we need and then use the `stroke` modifier on
    it. The `stroke` modifier does quite a bit and is also responsible for designing
    the belt: its first parameter will give the belt a color (we have chosen black),
    and the second parameter is the `strokeStyle` parameter, where we pass in a `StrokeStyle`
    struct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `StrokeStyle` struct has some parameters of its own that help style the
    belt:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the `lineWidth` parameter. This one is fairly self-explanatory;
    it just means how wide we want to make the belt, which we have set to `7` points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s also a `lineJoin` parameter. This is a value that determines how the
    segments of the belt will join together. There are three options we could use,
    `round`, `bevel`, and `miter`; I thought the line segments would look best using
    the `round` option, however feel free to experiment with all these values and
    numbers to get the best look for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter is called `dash`, which is responsible for the length of
    the segments that’s used to create the belt, and the gap between those segments.
    The first value of this parameter will determine the length of the segment (a
    larger number makes the segments bigger, while a smaller number makes the segments
    smaller); I’m using `5` points for this value. The second value determines the
    gap size between the segments (a larger number creates a larger gap, while a smaller
    number creates a smaller gap); for this value, a `1.4` point value creates gap
    that looks really good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `strokeStyle` struct, the next modifier is the `frame`, which sets
    the width and height of the whole belt. Then we added an `animation` modifier,
    with a `linear` animation and a duration of three seconds to complete one revolution,
    and `autoreverses` set to `false` (as we just want the belt to turn in one direction
    only).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the `onAppear` modifier so we can start the animation when
    the app loads up. To do that, add the following code right under the existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code toggles the `animateBelt` property to `true`, kicking off the belt
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s only one last bit of code we need to add to finish off the styling
    of the belt, and that is to rotate the belt to the proper angle for the gears.
    Coming out of `ZStack`, just after its closing brace, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will act on everything that is in the `ZStack` because it’s been
    put after its closing brace. Here, I added a `shadow` modifier, setting the color
    to black and a radius of `10` to make the belt more pronounced, and placed the
    shadow on the *x*-axis. You can play around with the colors and these numbers
    for the shadow: by increasing the radius, you will make the shadow bigger, and
    by increasing the numbers for the `x` and `y` parameters, you can move the shadow
    up, down, left, and right. Remember, you can use negative numbers to move the
    shadow in the opposite direction.'
  prefs: []
  type: TYPE_NORMAL
- en: The next modifier we are placing on the entire `ZStack` is `rotationEffect`.
    This will rotate the completed belt to the angle we specify; when we call these
    various methods later in `ContentView`, we’ll pass in different values that’ll
    orient the belt and size it just the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added the `offset` modifier, which allows us to place the belt anywhere
    on the screen using the *x*- and *y*-coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to test out what we’ve done, you won’t see anything in the previews
    yet because we’ve just added a bunch of different variables into the `BeltView`
    struct. However, we’re not using those variables in the `Previews` struct. To
    fix this, let’s update the `Previews` struct to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run `Previews` now, you’ll see the belt in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: The finished belt with the marching ants effect ](img/B18674_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The finished belt with the marching ants effect'
  prefs: []
  type: TYPE_NORMAL
- en: It’s turning clockwise, has a nice style and spacing to fit our gears later,
    and the shadow makes it really come off the screen a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you notice that the belt is not animating smoothly, meaning it’s rotating
    but pauses slightly every few seconds or so, what you can do is play around with
    the `dashPhase` value, which is used to specify the starting point of the dashes
    in a dashed or dotted line. I set it to an initial value of `45` and that removed
    the pause for me, but if it does not remove it for your project, simply increase
    or decrease that value by 1, check the animation, and then tweak the value again
    by 1 until you find the sweet spot.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s another file under our belt (sorry, couldn’t help myself!). Let’s
    continue on to the next section, where we’ll add a gear shaft to the mix. This
    object will turn a belt, which, in turn, will spin a fan.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a gear shaft image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing on to the next component, we need a gear shaft. A gear shaft is a
    cylindrical rod that has round gears at each end and is used to attach other gears
    or belts together, ultimately producing some form of output or work. For example,
    within the motor in your car, there is a gear shaft that turns due to the gasoline
    combusting. The output or work produced by that process moves the car forward.
    Our gear shaft won’t move a car, but instead, will turn a fan. After creating
    this, as with the worm gear, we will animate the gear shaft by using animating
    rectangles. Again, this is because the image we are using is not round, so we
    cannot rotate it on the *z*-axis like the other gear images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start off by creating a new SwiftUI View file, which we’ll call `GearShaftView`.
    Next, let’s add the variables we need for this file; we only need one variable,
    and that’s to track the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After the variable, we just need to add the code for the gear shaft image and
    animate it. Add the following code inside the `body` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We start by bringing the gear shaft image into the scene and setting the width
    and height dimensions for it. After that, we add a rectangle, which will be the
    animating shadow moving up and down over the shaft. The color of the shadow is
    black, with a little bit of a corner radius added on. The opacity will animate
    from 0, which is invisible, to 0.5, which is 50% visible. This will produce a
    nice shadowy rectangle that appears and disappears at the same cadence that the
    gears and shafts are turning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line of code, the animation is added, with a duration of one-half
    a second to complete one revolution. It has `autoreverses` set to `true` because
    if we set `autoreverses` to `false`, then the animation would look too abrupt
    (it needs `autoreverses` in order to slide the rectangle back down).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start the animation in the `onAppear` method and offset the rectangle
    so it’s neatly placed exactly where we want it, over the shaft image, using the
    `offset` modifier set to `0` for `x` and `–7` for `y`.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting close to putting all these files together, but next up, we’re
    going to animate the fan image.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a fan image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are actually two components left to create, the fan and the motor. However,
    we will add the motor when we start piecing all of the files together inside `ContentView`.
    For that reason, let’s focus on creating the fan now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like always, create a new file, select the `FanView`. In this file, we only
    need two variables – one for the state of the animation and one to hold the degrees
    of rotation for the fan; here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is quite short, so just add the following code to complete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s review this code. Inside the `ZStack`, we added the image of the fan and
    resized it. Then we used the `rotationEffect` modifier on it to make it turn.
    We want the fan to spin around its center, so we set the anchor to `center`, and
    then add the animation with a duration of `4`, which means it will spin 4 revolutions
    in 4 seconds. After that, set the animation to `repeatForever` and set `autoreverses`
    to `false` (reverse because we want the fan to spin only in one direction).
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s start the animation using the `onAppear` modifier and add a nice
    heavy shadow around the fan with a `15`-point radius.
  prefs: []
  type: TYPE_NORMAL
- en: And that completes the fan. Now, let’s now head over to `ContentView` to create
    the final component – the motor – and start bringing all the files together in
    one view.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing everything together in ContentView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay – we have accomplished a lot, including creating files for single and double
    gears, a worm gear, a gearshift, and a fan. Now, let’s create the final file for
    the motor and organize all these files together in `ContentView`.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use a Swift feature called **Pragma Marks**; this is a special
    syntax that labels and delineates blocks of code with a very thin line between
    them and makes those labels appear in one drop-down menu for easy searching and
    navigation. That’s very helpful when you have very large files with hundreds or
    thousands of lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use a SwiftUI feature called `ContentView` file by grouping multiple
    objects together, such as views, scenes, or even commands, into a single unit.
    We will organize much of the code into groups based on whether it is animated
    on the *x*-, *y*-, or *z*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: And then we will use the **ZIndex** modifier. This modifier works with views
    that are overlapping each other, so it can be used to force a view either to the
    front or the back of other views. This is important because sometimes we need
    a view to be more prominent in the scene and another view to be hidden behind
    the scene, with only parts of it visible. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you complete this project, I have also labeled all the views to help
    you identify their location on the screen, and how they are oriented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Our project with the views labeled ](img/B18674_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Our project with the views labeled'
  prefs: []
  type: TYPE_NORMAL
- en: '**G** annotations refer to the gears and **B** annotations refer to the belts.
    I numbered each gear and belt according to how it will appear in the code. We
    will be writing this code sequentially by the numbers – so, **G1**, then **G2**,
    then **G3**, and so on. The diagram shows the placement of all the parts.'
  prefs: []
  type: TYPE_NORMAL
- en: As always, we have the `ContentView` file already created for us when we started
    the project, so we don’t need to create any more new files. The first thing we
    are going to do here in `ContentView` is to add the motor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the motor, move into the `body` property of `ContentView` and then add
    a main `ZStack` to hold everything. Then, inside that, place another `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inside the second `ZStack`, let’s add our first organizational structure, the
    Pragma Mark. To make a Pragma Mark, the syntax requires two forward slashes and
    `MARK` written in capital letters, followed by a colon. That will create a thin
    line moving across the file. You can write whatever you want after that for the
    title.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create a Pragma Mark for the motor, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, notice the very thin line that the Pragma Mark creates from one end of
    the code file to the other within the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Our first Pragma Mark ](img/B18674_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Our first Pragma Mark'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pragma Mark also does something very useful behind the scenes too. If you
    look at the top left of your Xcode menu bar, where all the tabs appear, you’ll
    see a **MOTOR** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: The Pragma Mark tab ](img/B18674_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The Pragma Mark tab'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the tab, a drop-down menu will open up, containing all the Pragma
    Marks that you created; clicking on any one of them will take you immediately
    to the code in that part of the file. You’ll see the usefulness of this when you
    have dozens or even hundreds of different blocks of code in one file, eliminating
    the need to scroll through a lengthy file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the code that creates the motor in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our first time using the `Group` syntax. Looking at the code inside
    the group, it contains everything that we’ve been doing all along: creating the
    motor using the image that’s in the Assets catalog, resizing it, setting the aspect
    ratio so the motor fits on the screen as we want, giving it a frame size, and
    offsetting on the *x*- and *y*-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, this is what we should have in the previews so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: The motor ](img/B18674_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The motor'
  prefs: []
  type: TYPE_NORMAL
- en: There’s only one object in that group, the motor, but that’s perfectly fine
    – we’ll be adding more objects into further groups as we make them. For now, let’s
    now add some gears to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the gears along the x-, y-, and z-axes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will use the `GearView` struct to add the gears. Remember,
    we already designed and animated the gears in the `GearView` file, so all we need
    to do is call the `GearView` struct here in `ContentView` and pass in some values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we will also be rotating the gears and belts on the *x*-, *y*-,
    and *z*-axes, so to recap how each axis operates on the screen (shown back in
    *Figure 7**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: The *y*-axis runs from top to bottom and bottom to top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *x*-axis runs from left to right and right to left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *z*-axis moves from back to front or front to back. Holding an object in
    your hand and moving closer to your eyes is an example of moving that object along
    the *z*-axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that understanding, let’s start adding components. Put the following code
    in right after the closing brace of the motor group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I titled this group `GEARS ANIMATING ON THE Z AXIS`. Here, I’m calling the `GearView`
    struct six times, which creates six gears that are turning on the *z*-axis. Let’s
    just look at `Gear 1`, as they are pretty similar, just with different values.
  prefs: []
  type: TYPE_NORMAL
- en: So, in `Gear 1`, I set the gear’s width to `40` points, which makes a small
    gear, and positioned it directly over the front of the motor using the `offsetGearX`
    and `offsetGearY` parameters. The amount of degrees passed into the `gearDegrees`
    parameter is `360`; that’s one revolution of a circle, as we want these gears
    to turn for a full revolution.
  prefs: []
  type: TYPE_NORMAL
- en: Since these are 2D images and not 3D images of gears, the depth is not really
    perceivable, and the gears will lie flat and be animated clockwise. The `duration`
    parameter controls the amount of time it takes the gear to turn one full revolution;
    I’m using a value of `7` for the larger gears, and a value of `5` for the smaller
    ones. The small and larger gears are made using the `gearWidth` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `gearDegrees` parameter, the values I’m using are all set to
    `360` (a positive number) to move them clockwise. Well, that is except for `Gear
    5`, which is set to `-360` (a negative), as that gear will move counterclockwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the previous code we just wrote should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: The gears rotating on the z-axis ](img/B18674_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: The gears rotating on the z-axis'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this in the simulator, all of those gears will now be turning because
    we set the animation up already in the `GearView` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue and add another group of gears that animate on the *y*-axis
    this time. Add the following code right under the closing brace of the previous
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, we start off this group of code by adding our organizational Pragma Mark
    called `GEARS ANIMATING ON THE Y AXIS`. Here, we call the `GearView` struct four
    times, creating four gears that will rotate on the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at `Gear 7` as an example, this has a width of `100` points, and `gearDegrees`
    is set to `-360` (which means the gear rotates counterclockwise). Next, the code
    repositions the gears using the `offsetGearX` and `offsetGearY` parameters. And
    by using the `rotateDegrees` parameter, and passing in a value of `76`, we can
    rotate this gear on the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The other three gears are almost exactly the same, except their size and offset
    locations vary, but they will all turn on the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this group of code, this is what your previews should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: The gears rotating on the y-axis ](img/B18674_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The gears rotating on the y-axis'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you run the simulator, all these gears will be turning on their set
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue and add another group that will make a gear animate on the *x*-axis.
    Add the following code right after the closing brace of the previous group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `GEAR ANIMATING ON THE X AXIS` group just has one gear here and it’s the
    biggest gear so far, with a width of `175` points. This gear will mesh up with
    two other gears – the gear to its right in the scene and the worm gear.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the code we’ve already placed for the other gears in that
    we use the `GearView` initializer to create it and use the same parameters to
    size and locate it in the scene, but the difference here is that we’re using the
    `xAxis` parameter, and passing in a value of `1`. The `xAxis` parameter will rotate
    this gear on the *x*-axis, a completely different angle than for the *y*-axis
    or *z*-axis. The amount of rotation is `84` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Before we run this and check things out, let’s add the worm gear to see how
    everything fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the worm gear
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the worm gear to our `ContentView`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This grouping is labeled `WORM GEAR` and is placed using the `offset` modifier.
    Something new here though is the `zIndex` modifier. The `zIndex` modifier places
    a view in front of or behind other views, which allows us to position our views
    from front to back or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve talked about the *z*-axis already, which relates to depth and objects
    moving closer to and farther away from us. Why would we want to move a view closer
    or further away from our perspective? Well, let’s look at an example of what happens
    if we don’t use the `zIndex` modifier in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Adding the worm gear without zIndex ](img/B18674_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Adding the worm gear without zIndex'
  prefs: []
  type: TYPE_NORMAL
- en: From the illustration, you can see that the worm gear has now moved to the front,
    which is not the placement that I want. I want the worm gear to mesh up from behind
    `Gear 9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the `zIndex` modifier back into our code and look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Adding the worm gear with zIndex ](img/B18674_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Adding the worm gear with zIndex'
  prefs: []
  type: TYPE_NORMAL
- en: All views in SwiftUI have a default `zIndex` of `0`, so when I passed in a negative
    number, the worm gear was placed behind `Gear 9`. As you can see, this can be
    an important modifier when trying to organize your views regarding how close or
    far away you want them to be.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have finished all the gears, so now we can move on to adding
    the belts into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the belts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the building out of our scene, let’s add the belts. Add the
    following grouping, which contains three belts that move on the *z*-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we called the `BeltView` struct, set the `animateBelt` properties to
    `true`, and then gave each belt an appropriate width and height so it could connect
    to its corresponding gears using the `beltWidth` and `beltHeight` parameters.
    After that, we place the belts where they need to be using the `offsetBelt` parameters.
    Finally, we rotated the belts either by `90` degrees, which places the belt vertically,
    or by `0` degrees, which places the other belt horizontally. Here’s what they
    look like in relation to the gears they mesh with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: The belts on the z-axis ](img/B18674_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: The belts on the z-axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at rotating belts on the *y*-axis. As before, add the
    following code after the closing brace of the previous group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `BeltView` struct again, we have set these two belts to a width
    and height appropriate for the gear they will be meshed with. Then, we used the
    `rotation3DEffect` modifier and rotated these belts on the *y*-axis. The rotation
    happens when we pass a value of `1` into the `y` parameter, and they will rotate
    by `75` degrees. As with the other belts, we offset them so that they line up
    with their corresponding gears using the `offset` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your previews should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: The belts on the y-axis ](img/B18674_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: The belts on the y-axis'
  prefs: []
  type: TYPE_NORMAL
- en: All those belts and gears will be fully animated if you run the project in the
    simulator. That leaves us with only two more groups to go – the gear shaft and
    fan, and a background.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the gear shafts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bring the shafts into the scene, add the following code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our `GEAR SHAFT` group. Here, I’m calling the `GearShaftView` struct
    twice, to create two gear shafts. Then, all we have to do is simply offset them
    to the proper locations, and call `zIndex` on them, passing in a negative value.
    This will position them behind the other views, creating the illusion that the
    shaft is actually part of the worm gear. Here’s what the previous code produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: The gear shafts ](img/B18674_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: The gear shafts'
  prefs: []
  type: TYPE_NORMAL
- en: The worm gear and the gear shaft are the two objects that we could not animate
    with conventional methods because that would not look good, and it wouldn’t be
    an accurate representation of how they turn in the physical world. So, we created
    our shadow boxes and placed them strategically over these two shafts. When you
    run this in the simulator, you’ll notice these rectangles appear to make the worm
    gear and two shafts turn.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these are just images that are sitting on the screen doing nothing,
    but because of a little trickery, they actually appear like they’re turning!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add the final group – the fan.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the fan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be nice if all of these gears and belts would produce some sort of
    output, so in this project, that output will be to spin a fan. Let’s now add the
    final grouping of code right under the existing group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All we have done is called the `FanView` struct, offset it to the bottom of
    the scene, and set a width for it (since it’s round, we don’t need to set a height).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearly there, just one last task: adding a background.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I have a nice gold background that’ll look great with all the objects against
    it, so let’s come out of the main `ZStack`, and after its closing brace, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gold background to a frame width and height of `400` x `1000`,
    sitting nicely on an iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run that in the simulator and see what you think:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: The completed project ](img/B18674_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: The completed project'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around with all the parameters and settings, changing the
    colors of the belts or objects, changing the angles of rotation, and so on. This
    will allow you to really understand what these parameters and functions all do,
    and how they synergistically work together!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that we continued to use Pragma Marks throughout the project.
    Let’s see how handy they are; so, come back up to the menu bar and click on the
    last tab (this tab doesn’t have a name, but you can *always* find the Pragma Marks
    in the last tab of the menu bar):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Viewing the Pragma Marks of the project ](img/B18674_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Viewing the Pragma Marks of the project'
  prefs: []
  type: TYPE_NORMAL
- en: Every Pragma Mark indicates a different area of code based on the title we gave
    it, which makes it very easy to jump to in an instant, regardless of how big the
    file is.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, through creating this project, we’ve accomplished quite a bit. As
    before, you saw how to create separate files – in this case, gears and chains
    – how to make a marching ants effect, how to combine everything into `ContentView`,
    and how to organize the code neatly using Pragma Marks and Groups. You also learned
    how to animate objects on all three axes, *x*-, *y*-, and *z*-, and saw how to
    use `zIndex` to place views more dynamically, from back to front, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In the next project, we will look at animating a flower and its petals so that
    it appears to be breathing, and creating some snow in the background.
  prefs: []
  type: TYPE_NORMAL
