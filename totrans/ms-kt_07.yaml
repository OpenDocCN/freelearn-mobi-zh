- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Navigating within Your App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用内导航
- en: The apps we make need to move from one screen to the other, showing different
    content on these screens. So far, we have been making apps with only one screen.
    In this chapter, we will learn how to move from one screen to the other. We will
    learn how to use the **Jetpack Compose Navigation** library to navigate to different
    Jetpack Compose screens within our app. We will learn the tips and best practices
    for using this library. Also, we will cover how to pass arguments as we navigate
    to screens. Lastly, we will build on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055),
    by handling navigation on large screens and foldables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作的应用需要从一个屏幕移动到另一个屏幕，在这些屏幕上显示不同的内容。到目前为止，我们一直只制作单屏幕的应用。在本章中，我们将学习如何从一个屏幕移动到另一个屏幕。我们将学习如何使用**Jetpack
    Compose Navigation**库在应用内导航到不同的Jetpack Compose屏幕。我们将学习使用此库的技巧和最佳实践。此外，我们还将介绍如何在大型屏幕和可折叠设备上处理导航。最后，我们将通过处理大型屏幕和可折叠设备上的导航来扩展我们在[*第4章*](B19779_04.xhtml#_idTextAnchor055)中学到的内容。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Jetpack Navigation overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack Navigation概述
- en: Navigating to Compose destinations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到Compose目标
- en: Passing arguments to destinations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向目标传递参数
- en: Navigation in foldables and large screens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可折叠设备和大型屏幕上的导航
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载Android Studio Hedgehog或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven)找到本章的代码。
- en: Jetpack Navigation overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack Navigation概述
- en: The Jetpack Navigation library provides an API for handling **complex navigation**
    with ease while also following the principles of Android Jetpack. The library
    is available for both the old view system, which uses XML ([https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation)),
    and Jetpack Compose ([https://developer.android.com/jetpack/compose/navigation](https://developer.android.com/jetpack/compose/navigation)).
    We will be learning about the latter in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Navigation库提供了一个API，可以轻松处理**复杂导航**，同时遵循Android Jetpack的原则。该库适用于旧视图系统，该系统使用XML([https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation))，以及Jetpack
    Compose([https://developer.android.com/jetpack/compose/navigation](https://developer.android.com/jetpack/compose/navigation))。在本章中，我们将学习后者。
- en: Still building on the Pets app we used in the previous chapter, we are going
    to navigate to a details screen that has a back button to the previous screen.
    We will also be passing data to the details screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在之前章节中使用过的宠物应用的基础上，导航到一个带有返回上一屏幕按钮的详情屏幕。我们还将向详情屏幕传递数据。
- en: 'To start with, we need to add the Jetpack Navigation Compose dependency to
    our project. Let’s add the following library inside the `versions` section in
    our `libs.versions.toml` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将Jetpack Navigation Compose依赖项添加到我们的项目中。让我们在`libs.versions.toml`文件的`versions`部分添加以下库：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to add the dependency to our app module’s `build.gradle.kts`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将依赖项添加到我们的应用模块的`build.gradle.kts`文件中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Do a Gradle sync to add the library to our project. The next step is to create
    `NavController` and `NavHost`. `NavController` is a class that manages app navigation
    within `NavHost`. `NavHost` is a container that hosts composables and handles
    navigation between them. Let’s create a new package called `navigation` and create
    a new sealed class called `Screens.kt`. Inside the file, let us add the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Gradle同步操作以将库添加到我们的项目中。下一步是创建`NavController`和`NavHost`。`NavController`是一个管理`NavHost`内应用导航的类。`NavHost`是一个容器，它托管可组合项并处理它们之间的导航。让我们创建一个新的包名为`navigation`，并创建一个新的密封类名为`Screens.kt`。在文件内部，让我们添加以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a sealed class that has two objects. A sealed class is used to represent
    restricted class hierarchies wherein the object or value can only have a value
    among one of the types defined in the sealed class. The first object is `PetsScreen`,
    which will be the first screen we will see when we launch the app. The second
    object is `PetDetailsScreen`, which will be the screen we will navigate to when
    we click on a pet item in `PetsScreen`. Every time we need to add a new destination
    screen, we will add a new object to the sealed class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有两个对象的密封类。密封类用于表示受限的类层次结构，其中对象或值只能具有密封类中定义的类型之一。第一个对象是 `PetsScreen`，它将是我们在启动应用时看到的第一个屏幕。第二个对象是
    `PetDetailsScreen`，它将是我们在点击 `PetsScreen` 中的宠物项时导航到的屏幕。每次我们需要添加一个新的目的地屏幕时，我们都会在密封类中添加一个新的对象。
- en: 'Next, let us create a new file inside the `navigation` package called `AppNavigation.kt`.
    Inside the file, let us add the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `navigation` 包内创建一个名为 `AppNavigation.kt` 的新文件。在文件内部，让我们添加以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s explain the preceding code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释前面的代码：
- en: We create `NavController` using the `rememberNavController()` function. This
    function is used to create `NavController` that will be remembered across recompositions.
    This is important because we need to be able to navigate to different screens
    in our app.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `rememberNavController()` 函数创建 `NavController`。此函数用于创建将在重组之间被记住的 `NavController`。这很重要，因为我们需要能够在应用中导航到不同的屏幕。
- en: We create a `NavHost` composable that takes in `navController` and `startDestination`.
    `startDestination` is the first screen we want to see when we launch the app.
    In our case, it is `PetsScreen`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个接受 `navController` 和 `startDestination` 的 `NavHost` 组合。`startDestination`
    是我们启动应用时想要看到的第一个屏幕。在我们的例子中，它是 `PetsScreen`。
- en: We add the `PetsScreen` composable. This composable has an error because we
    have not created it yet. We will do that shortly.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `PetsScreen` 组合。这个组合有错误，因为我们还没有创建它。我们将很快做到这一点。
- en: '![Figure 7.1 – PetsScreen error](img/B19779_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – PetsScreen 错误](img/B19779_07_01.jpg)'
- en: Figure 7.1 – PetsScreen error
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – PetsScreen 错误
- en: 'As seen in the preceding screenshot, the `PetsScreen` composable is highlighted
    in red because we have not created the composable yet. We will refactor our code
    a bit. Let us create a new file called `PetsScreen.kt`. Inside the file, let’s
    add the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`PetsScreen` 组合以红色突出显示，因为我们还没有创建这个组合。我们将对我们的代码进行一些重构。让我们创建一个名为 `PetsScreen.kt`
    的新文件。在文件内部，让我们添加以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PetsScreen` composable displays a list of pets. We have added a `Scaffold`
    composable as the root element. Inside the `Scaffold` composable, we have added
    a `TopAppBar` composable. We have also added a `PetList` composable as the content
    of the `Scaffold` composable. We have added a new `onPetClicked` callback to the
    `PetList` composable. We will be using this callback to navigate to `PetDetailsScreen`
    when we click on a pet item in the list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetsScreen` 组合显示宠物列表。我们已添加一个 `Scaffold` 组合作为根元素。在 `Scaffold` 组合内部，我们添加了一个
    `TopAppBar` 组合。我们还添加了一个 `PetList` 组合作为 `Scaffold` 组合的内容。我们还在 `PetList` 组合中添加了一个新的
    `onPetClicked` 回调。我们将使用此回调在点击列表中的宠物项时导航到 `PetDetailsScreen`。'
- en: 'With this, our navigation graph is ready. We can now add the `AppNavigation`
    composable to our `MainActivity.kt` file. Let’s replace all the code inside the
    `ChapterSevenTheme` block with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的导航图就准备好了。我们现在可以将 `AppNavigation` 组合添加到我们的 `MainActivity.kt` 文件中。让我们用以下代码替换
    `ChapterSevenTheme` 块内的所有代码：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Build and run the app. The app still displays a list of cute pets as before,
    but now we are using the Jetpack Navigation library to handle our navigation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用。应用仍然显示与之前相同的可爱宠物列表，但现在我们正在使用 Jetpack Navigation 库来处理我们的导航。
- en: '![Figure 7.2 – Pets](img/B19779_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 宠物](img/B19779_07_02.jpg)'
- en: Figure 7.2 – Pets
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 宠物
- en: In the next section, let us learn how to navigate to a details screen when we
    click on a pet item in the list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们学习如何在点击列表中的宠物项时导航到详情屏幕。
- en: Navigating to Compose destinations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到 Compose 目的地
- en: 'In this section, we will learn how to navigate to a details screen when we
    click on a pet item in the list. First, we need to create a new composable for
    `PetDetailsScreen`. Let us create a new file called `PetDetailsScreen.kt` and
    create the `PetDetailsScreenContent` composable as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在点击列表中的宠物项时导航到详情屏幕。首先，我们需要为 `PetDetailsScreen` 创建一个新的组合。让我们创建一个名为
    `PetDetailsScreen.kt` 的新文件，并创建 `PetDetailsScreenContent` 组合，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we created a composable that has `Column` as the root element. Inside
    the `Column` element, we added an `AsyncImage` composable that displays a cat
    image. We also added a `FlowRow` composable to flow items to the next line when
    space runs out, which cannot be achieved with rows. `FlowRow` displays two `SuggestionChip`
    composables. We will use this composable to display the details of a pet. Notice
    we are using hardcoded cat IDs and tags for now. We will pass this data from the
    `PetList` composable in the next section. Next, let us create the `PetDetailsScreen`
    composable as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个以 `Column` 作为根元素的组合组件。在 `Column` 元素内部，我们添加了一个显示猫图像的 `AsyncImage`
    组合组件。我们还添加了一个 `FlowRow` 组合组件，当空间不足时，它会将项目流动到下一行，这是使用行无法实现的。`FlowRow` 显示了两个 `SuggestionChip`
    组合组件。我们将使用此组合组件来显示宠物的详细信息。注意，我们现在正在使用硬编码的猫 ID 和标签。我们将在下一节中从 `PetList` 组合组件传递此数据。接下来，让我们按照以下方式创建
    `PetDetailsScreen` 组合组件：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `PetDetailsScreen` composable displays the details of a pet. We have added
    a `Scaffold` composable as the root element. Inside the `Scaffold` composable,
    we have added a `TopAppBar` composable. We have also used the `PetDetailsScreenContent`
    composable we created earlier as the content of the `Scaffold` composable. We
    have added a new `onBackPressed` callback to the `PetDetailsScreen` composable.
    We will be using this callback to navigate back to the previous screen when we
    click on the back button in `TopAppBar`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetDetailsScreen` 组合组件显示宠物的详细信息。我们添加了一个 `Scaffold` 组合组件作为根元素。在 `Scaffold`
    组合组件内部，我们添加了一个 `TopAppBar` 组合组件。我们还使用了之前创建的 `PetDetailsScreenContent` 组合组件作为 `Scaffold`
    组合组件的内容。我们向 `PetDetailsScreen` 组合组件添加了一个新的 `onBackPressed` 回调。我们将使用此回调在点击 `TopAppBar`
    中的返回按钮时导航回上一个屏幕。'
- en: 'Our next step is to add a composable for `PetDetailsScreen` to our `AppNavigation.kt`
    file. Let us add the following code to our `NavHost` below the composable for
    `PetsScreen`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是在 `AppNavigation.kt` 文件中添加 `PetDetailsScreen` 的组合组件。让我们在 `PetsScreen`
    组合组件下面的 `NavHost` 中添加以下代码：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have added a composable for `PetDetailsScreen`. We passed in the route
    for the screen and the `PetDetailsScreen` composable as the content. `PetDetailsScreen`
    has the `onBackPressed` argument. The argument handles the situation where a user
    taps the back arrow icon, which is normally at the top left. We use `navController.popBackStack()`
    inside the `onBackPressed` argument. This method attempts to pop the current destination
    off the back stack and navigates to the previous destination.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `PetDetailsScreen` 添加了一个组合组件。我们传递了屏幕的路由和 `PetDetailsScreen` 组合组件作为内容。`PetDetailsScreen`
    有 `onBackPressed` 参数。该参数处理用户点击顶部左边的返回箭头图标的情况，这通常是位于顶部的。我们在 `onBackPressed` 参数内部使用
    `navController.popBackStack()`。此方法尝试从返回堆栈中弹出当前目标并导航到上一个目标。
- en: 'Now we need to do the actual navigation to `PetDetailsScreen` when we click
    on a pet item in the list. Let us head over to the `PetListItem` composable. We
    will add a new `onPetClicked` callback to the `PetListItem` composable. The modified
    composable should look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在点击列表中的宠物项时实际导航到 `PetDetailsScreen`。让我们转到 `PetListItem` 组合组件。我们将向 `PetListItem`
    组合组件添加一个新的 `onPetClicked` 回调。修改后的组合组件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we have added a new `onPetClicked` callback to the composable.
    We have added the `clickable` modifier to `Column` and called the `onPetClicked`
    callback inside the modifier. We pass in the `cat` object to the callback. Next,
    we need to add the `onPetClicked` callback to the `PetList` composable, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向组合组件添加了一个新的 `onPetClicked` 回调。我们将 `clickable` 修饰符添加到 `Column` 上，并在修饰符内部调用
    `onPetClicked` 回调。我们将 `cat` 对象传递给回调。接下来，我们需要按照以下方式将 `onPetClicked` 回调添加到 `PetList`
    组合组件中：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to pass this callback where we use our `PetListItem` composable.
    The modified `PetListItem` composable at the call site inside the items block
    should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此回调传递到我们使用 `PetListItem` 组合组件的地方。在项目块内部调用位置的修改后的 `PetListItem` 组合组件应该看起来像这样：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, we need to modify the `AppNavigation` composable to pass the `onPetClicked`
    callback to the `PetsScreen` composable. The modified `AppNavigation` composable
    should look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改 `AppNavigation` 组合组件，以便将 `onPetClicked` 回调传递给 `PetsScreen` 组合组件。修改后的
    `AppNavigation` 组合组件应该看起来像这样：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we pass the `onPetClicked` callback to the `PetsScreen` composable. Inside
    the callback, we call the `navigate()` function on `navController` and pass in
    the route for `PetDetailsScreen`. This will navigate to `PetDetailsScreen` when
    we click on a pet item in the list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `onPetClicked` 回调传递给 `PetsScreen` 组合组件。在回调内部，我们在 `navController` 上调用
    `navigate()` 函数并传入 `PetDetailsScreen` 的路由。当我们点击列表中的宠物项目时，这将导航到 `PetDetailsScreen`。
- en: Build and run the app. Click on a pet item in the list. You will see that the
    app navigates to `PetDetailsScreen`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。点击列表中的宠物项目。你会看到应用程序导航到 `PetDetailsScreen`。
- en: '![Figure 7.3 – Pet Details screen](img/B19779_07_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 宠物详情屏幕](img/B19779_07_03.jpg)'
- en: Figure 7.3 – Pet Details screen
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 宠物详情屏幕
- en: We can see a cute cat image and some tags. Additionally, if we press the back
    button in `TopAppBar`, we will be able to navigate back to `PetsScreen`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一张可爱的猫咪图片和一些标签。此外，如果我们按下 `TopAppBar` 中的返回按钮，我们将能够导航回 `PetsScreen`。
- en: So far, we have been able to navigate from `PetsScreen` to `PetDetailsScreen`.
    However, we are not passing any data to `PetDetailsScreen`. In the next section,
    we will learn how to pass data to `PetDetailsScreen`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够从 `PetsScreen` 导航到 `PetDetailsScreen`。然而，我们没有向 `PetDetailsScreen`
    传递任何数据。在下一节中，我们将学习如何向 `PetDetailsScreen` 传递数据。
- en: Passing arguments to destinations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向目标传递参数
- en: 'In our `PetDetailsScreen`, we need to remove the hardcoded cat IDs and tags
    and pass them from the `PetList` composable. Follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PetDetailsScreen` 中，我们需要移除硬编码的猫咪 ID 和标签，并从 `PetList` 组合组件中传递它们。按照以下步骤操作：
- en: 'Let us head over to the `PetDetailsScreenContent` composable inside the `PetDetailsScreen.kt`
    file and modify it as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `PetDetailsScreen.kt` 文件中的 `PetDetailsScreenContent` 组合组件，并按如下方式修改它：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have added a new `cat` parameter to the composable. We have used the `cat`
    object to display the cat image and tags.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向组合组件添加了一个新的 `cat` 参数。我们使用了 `cat` 对象来显示猫咪图片和标签。
- en: 'Next, let us head over to the `PetDetailsScreen` composable and modify it as
    follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们转到 `PetDetailsScreen` 组合组件，并按如下方式修改它：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have added a new `cat` parameter to the composable. We have passed
    the `cat` object to the `PetDetailsScreenContent` composable.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们向组合组件添加了一个新的 `cat` 参数。我们将 `cat` 对象传递给了 `PetDetailsScreenContent` 组合组件。
- en: 'Next, let us head over to the `AppNavigation` composable and add the logic
    for passing the `cat` object to `PetDetailsScreen`. We need to first modify the
    composable for `PetDetailsScreen`, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们转到 `AppNavigation` 组合组件，并添加将 `cat` 对象传递给 `PetDetailsScreen` 的逻辑。我们首先需要修改
    `PetDetailsScreen` 的组合组件，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s explain the changes:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释一下这些更改：
- en: On the route, we have added a new parameter called `cat`. This is the parameter
    we will use to pass the `cat` object to `PetDetailsScreen`.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由上，我们添加了一个新的参数，称为 `cat`。这是我们用来将 `cat` 对象传递到 `PetDetailsScreen` 的参数。
- en: We have added a new `arguments` parameter. This parameter is used to pass arguments
    to the destination screen. We have added `navArgument` for the `cat` parameter.
    We have set the type to be `String`. This is because we will be passing a string
    representation of the `cat` object.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个新的 `arguments` 参数。该参数用于将参数传递到目标屏幕。我们为 `cat` 参数添加了 `navArgument`。我们将类型设置为
    `String`。这是因为我们将传递 `cat` 对象的字符串表示形式。
- en: We pass the `cat` object to the `PetDetailsScreen` composable. We have used
    `Json.decodeFromString()` from the Kotlinx Serialization library that we learned
    about in [*Chapter 6*](B19779_06.xhtml#_idTextAnchor084) to convert the string
    value of the `cat` object into a `Cat` object. We have used the `arguments` property
    of `NavBackStackEntry` to get the string value of the `cat` object. We have used
    the Elvis operator to return an empty string if the `arguments` property is null.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `cat` 对象传递给 `PetDetailsScreen` 组合组件。我们使用了 Kotlinx Serialization 库中的 `Json.decodeFromString()`，这是我们之前在
    [*第 6 章*](B19779_06.xhtml#_idTextAnchor084) 中学习到的，将 `cat` 对象的字符串值转换为 `Cat` 对象。我们使用了
    `NavBackStackEntry` 的 `arguments` 属性来获取 `cat` 对象的字符串值。如果 `arguments` 属性为空，我们使用了
    Elvis 运算符来返回一个空字符串。
- en: 'Lastly, we need to modify the `onPetClicked` callback of `PetsScreen` in the
    `AppNavigation` composable, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改 `AppNavigation` 组合组件中 `PetsScreen` 的 `onPetClicked` 回调，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have modified the `navigate()` function to pass the `Cat` object as a string.
    We also used `Json.encodeToString()` from the Kotlinx Serialization library to
    convert the `Cat` object into a string. This will be passed as an argument to
    `PetDetailsScreen` when we click on a pet item in the list.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已修改 `navigate()` 函数，将 `Cat` 对象作为字符串传递。我们还使用了 Kotlinx Serialization 库中的 `Json.encodeToString()`，将
    `Cat` 对象转换为字符串。这将作为参数传递给 `PetDetailsScreen`，当我们点击列表中的宠物项时。
- en: 'Build and run the app. Click on any cute cat picture from the list and now
    the details screen will display the cat image and tag of the cute cat that we
    selected:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。点击列表中的任何可爱猫咪图片，现在详情屏幕将显示我们选择的可爱猫咪的图片和标签：
- en: '![Figure 7.4 – Pet Details](img/B19779_07_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 宠物详情](img/B19779_07_04.jpg)'
- en: Figure 7.4 – Pet Details
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 宠物详情
- en: We have now been able to pass data to `PetDetailsScreen`. We have learned how
    to navigate to a compose destination and pass data to the details screen. In the
    next section, we will learn how to handle navigation in foldables and large screens.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经能够将数据传递给 `PetDetailsScreen`。我们学习了如何导航到组合目的地并将数据传递到详情屏幕。在下一节中，我们将学习如何在可折叠设备和大型屏幕上处理导航。
- en: Navigation in foldables and large screens
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可折叠设备和大型屏幕的导航
- en: 'In the *Designing UIs for large screens and foldables* section of [*Chapter
    4*](B19779_04.xhtml#_idTextAnchor055), we learned about the `WindowSize` class
    and how we can make our apps responsive in foldable devices and large screens.
    In this section, we are going to make our Pets app responsive in foldable devices
    and large screens. We are going to make several changes, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19779_04.xhtml#_idTextAnchor055) 的 *为大型屏幕和可折叠设备设计 UI* 部分，我们学习了
    `WindowSize` 类以及我们如何在可折叠设备和大型屏幕上使我们的应用程序响应。在本节中，我们将使我们的宠物应用程序在可折叠设备和大型屏幕上响应。我们将进行一些更改，如下所示：
- en: Add a bottom bar to `PetsScreen`, which will have several options.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `PetsScreen` 添加一个底部栏，其中将包含几个选项。
- en: Add `NavigationRail` and `NavigationDrawer`, which will be used depending on
    the screen size.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `NavigationRail` 和 `NavigationDrawer`，它们将根据屏幕大小使用。
- en: Observe the device’s foldable state and change the layout of the app depending
    on the foldable state.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察设备的可折叠状态并根据可折叠状态更改应用程序的布局。
- en: Depending on the screen size, we will also change the content type. On large
    screens, we will display the list of cats and the details of the selected cat
    side by side. On small screens, we will display the list of cats and the details
    of the selected cat on different screens.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据屏幕大小，我们还将更改内容类型。在大型屏幕上，我们将并列显示猫咪列表和所选猫咪的详细信息。在小屏幕上，我们将分别显示猫咪列表和所选猫咪的详细信息。
- en: 'Quite a lot of changes are required. The good thing is that I have already
    made the changes and you can find the final version in the `chapterseven` folder
    in the project’s repository. Let us go through the changes one by one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 需要很多更改。好事是我已经做了这些更改，你可以在项目的 `chapterseven` 文件夹中找到最终版本。让我们逐一查看这些更改：
- en: 'We will start by creating a `sealed interface` named `NavigationType` that
    represents the different types of navigation we will be using in our app. Let
    us create a new file inside the `navigation` package called `NavigationType.kt`
    and add the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为 `NavigationType` 的 `sealed interface`，它代表我们将要在应用程序中使用的不同类型的导航。让我们在
    `navigation` 包内创建一个名为 `NavigationType.kt` 的新文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are using a sealed interface instead of a sealed class here. This is because
    we do not need to hold any state in our `NavigationType`. We also do not need
    to pass properties to any of the `NavigationTypes`. We have three options: `BottomNavigation`,
    `NavigationDrawer`, and `NavigationRail`. We will be using these options to change
    the navigation type depending on the screen size.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用密封接口而不是密封类。这是因为我们不需要在 `NavigationType` 中保留任何状态。我们也不需要将属性传递给任何 `NavigationTypes`。我们有三个选项：`BottomNavigation`、`NavigationDrawer`
    和 `NavigationRail`。我们将使用这些选项根据屏幕大小更改导航类型。
- en: 'Next, let us create yet another sealed interface called `ContentType`. This
    interface will be used to change the content display type depending on the screen
    size. Let us create a new file called `ContentType.kt` still inside the `navigation`
    package and add the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个名为 `ContentType` 的密封接口。这个接口将用于根据屏幕大小更改内容显示类型。让我们在 `navigation` 包内创建一个名为
    `ContentType.kt` 的新文件，并添加以下代码：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This represents the two modes in which we can display our content depending
    on the screen size. We have the `List` mode, which displays the list of cats only.
    We also have the `ListAndDetail` mode, which displays the list of cats and the
    details of the selected cat side by side.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示我们可以根据屏幕大小显示内容的两种模式。我们有 `List` 模式，仅显示猫的列表。我们还有 `ListAndDetail` 模式，它并列显示猫的列表和所选猫的详细信息。
- en: 'Next, in our `Screens.kt` file, we have to add a new destination screen called
    `FavoritesScreen`. The final code for the file should look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `Screens.kt` 文件中，我们必须添加一个新的目标屏幕，称为 `FavoritesScreen`。该文件的最终代码应如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have three destinations for our app.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有三个目标用于我们的应用程序。
- en: 'Next, let us add the `WindowSize` dependencies to the libraries section in
    the `libs.versions.toml` file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `WindowSize` 依赖项添加到 `libs.versions.toml` 文件的库部分：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need to add the dependencies to our app module’s `build.gradle.kts`
    file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将依赖项添加到我们的应用程序模块的 `build.gradle.kts` 文件中：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do a Gradle sync to be able to add the dependencies to our project.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步以便将依赖项添加到我们的项目中。
- en: 'Next, we need to create the composables for `NavigationRail`, `NavigationDrawer`,
    and `BottomNavigation`. Let us create a new file called `PetsNavigationRail.kt`
    inside the `view` package and add the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `NavigationRail`、`NavigationDrawer` 和 `BottomNavigation` 的组合器。让我们在
    `view` 包内创建一个名为 `PetsNavigationRail.kt` 的新文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we created the `PetsNavigationRail()` composable, which
    has three parameters: `onFavoriteClicked`, `onHomeClicked`, and `onDrawerClicked`.
    The first two are callbacks that will be used to navigate to the different screens.
    We use the `onDrawerClicked` callback to close or open the drawer when the user
    interacts with it. At the top, we have the `items` variable, which holds a list
    of all our screens, and the `selectedItem` variable, which holds the currently
    selected screen. We use the `NavigationRail` composable from the Material 3 library
    to display the navigation rail. To add items to `NavigationRail`, we use the `NavigationRailItem`
    composable. We pass in the selected state of the item, the `onClick` callback,
    and the icon to display.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `PetsNavigationRail()` 组合器，它有三个参数：`onFavoriteClicked`、`onHomeClicked`
    和 `onDrawerClicked`。前两个是回调，将用于导航到不同的屏幕。我们使用 `onDrawerClicked` 回调来在用户与之交互时关闭或打开抽屉。在顶部，我们有
    `items` 变量，它包含所有我们的屏幕列表，以及 `selectedItem` 变量，它包含当前选中的屏幕。我们使用来自 Material 3 库的 `NavigationRail`
    组合器来显示导航栏。要向 `NavigationRail` 添加项目，我们使用 `NavigationRailItem` 组合器。我们传入项目的选中状态、`onClick`
    回调和要显示的图标。
- en: 'Next, let us create the `PetsBottomNavigationBar` composable. Let us create
    a new file called `PetsBottomNavigationBar.kt` inside the `view` package and add
    the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `PetsBottomNavigationBar` 组合器。让我们在 `view` 包内创建一个名为 `PetsBottomNavigationBar.kt`
    的新文件，并添加以下代码：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `PetsBottomNavigationBar` composable is similar to the `PetsNavigationRail`
    composable. The only difference is that we are using the `NavigationBar` composable
    instead of the `NavigationRail` composable. We have the home and favorite items.
    We use the `NavigationBarItem` composable to add items to `NavigationBar`. We
    pass in the selected state of the item, the `onClick` callback, and the icon to
    display.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PetsBottomNavigationBar` 组合器与 `PetsNavigationRail` 组合器类似。唯一的区别是我们使用 `NavigationBar`
    组合器而不是 `NavigationRail` 组合器。我们有主页和收藏夹项目。我们使用 `NavigationBarItem` 组合器向 `NavigationBar`
    添加项目。我们传入项目的选中状态、`onClick` 回调和要显示的图标。'
- en: 'Next, let us create the `PetsNavigationDrawer` composable. Let us create a
    new file called `PetsNavigationDrawer.kt` inside the `view` package and add the
    following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `PetsNavigationDrawer` 组合器。让我们在 `view` 包内创建一个名为 `PetsNavigationDrawer.kt`
    的新文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We used the `NavigationDrawer` composable from the Material 3 library to display
    the navigation drawer. We used the `NavigationDrawerItem` composable to add items
    to `NavigationDrawer`. We passed in the label, the selected state of the item,
    the `onClick` callback, and the icon to display.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了来自 Material 3 库的 `NavigationDrawer` 组合器来显示导航抽屉。我们使用 `NavigationDrawerItem`
    组合器向 `NavigationDrawer` 添加项目。我们传入标签、项目的选中状态、`onClick` 回调和要显示的图标。
- en: 'Since our `PetsNavigationDrawer`, `PetsNavigationRail`, and `PetsBottomNavigationBar`
    composables have `FavoritesScreen`, let us create a new file called `FavoritePetsScreen.kt`
    inside the view package and add the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的 `PetsNavigationDrawer`、`PetsNavigationRail` 和 `PetsBottomNavigationBar`
    组合器都包含 `FavoritesScreen`，让我们在视图包内创建一个名为 `FavoritePetsScreen.kt` 的新文件，并添加以下代码：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a simple composable that displays the text `"Favorite Pets"`. We will
    use this composable as the content of `FavoritesScreen`. We also need to refactor
    our `AppNavigation()` composable to make it ready to handle the different navigation
    and content types. The final modified composable should look like this:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的可组合组件，显示文本 `"Favorite Pets"`。我们将使用这个可组合组件作为 `FavoritesScreen` 的内容。我们还需要重构我们的
    `AppNavigation()` 可组合组件，使其准备好处理不同的导航和内容类型。最终修改后的可组合组件应如下所示：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s highlight the changes:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们突出显示这些更改：
- en: Our `AppNavigation()` composable now takes in a `contentType` parameter of type
    `ContentType`. This is the parameter we will use to change the content type depending
    on the screen size. We also pass in a `navHostController` parameter of type `NavHostController`.
    This is the parameter we will use to navigate to different screens in our app.
    Previously, `navHostController` was created inside the `AppNavigation()` composable.
    We have moved it to the call site so that we can be able to use the same `navHostController`
    in different composables.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `AppNavigation()` 可组合组件现在接受一个类型为 `ContentType` 的 `contentType` 参数。这是我们用来根据屏幕大小更改内容类型的参数。我们还传递了一个类型为
    `NavHostController` 的 `navHostController` 参数。这是我们用来在应用中导航到不同屏幕的参数。之前，`navHostController`
    是在 `AppNavigation()` 可组合组件内部创建的。我们已经将其移动到调用位置，这样我们就可以在不同的可组合组件中使用相同的 `navHostController`。
- en: We have used the new `PetsScreen()` composable, which takes in the `contentType`
    parameter. Same as before, we still pass `onPetClicked`, which navigates to `PetDetailsScreen`.
    Previously, we were using the `PetList` composable.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了新的 `PetsScreen()` 可组合组件，它接受 `contentType` 参数。和之前一样，我们仍然传递 `onPetClicked`，它导航到
    `PetDetailsScreen`。之前，我们使用的是 `PetList` 可组合组件。
- en: Lastly, we have added our new `FavoritePetsScreen` destination to the `NavHost`
    composable.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将我们的新 `FavoritePetsScreen` 目的地添加到 `NavHost` 可组合组件中。
- en: 'Let us see what the new update `PetsScreen` composable looks like. Let us head
    over to the `PetsScreen.kt` file and modify the composable as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看新的更新 `PetsScreen` 可组合组件的样子。让我们转到 `PetsScreen.kt` 文件并按如下方式修改可组合组件：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have added a new `contentType` parameter to the composable. We have also
    added a new `petsUIState` parameter. This is the UI state of `PetsScreen`. We
    will use this state to display the list of cats.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向可组合组件添加了一个新的 `contentType` 参数。我们还添加了一个新的 `petsUIState` 参数。这是 `PetsScreen`
    的 UI 状态。我们将使用此状态来显示猫的列表。
- en: 'Next, create a new file called `PetsScreenContent.kt` and add the following
    code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `PetsScreenContent.kt` 的新文件，并添加以下代码：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s explain the preceding code:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释前面的代码：
- en: '`PetsScreenContent` has a parent `Column` composable. Inside the `Colum`n composable,
    we have added three `AnimatedVisibility` composables. The first one is used to
    display `CircularProgressIndicator` when `petsUIState` is loading. The second
    one is used to display the list of cats when the `pets` variable from `petsUIState`
    is not empty. The third one is used to display an error message when `petsUIState`
    has an error.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PetsScreenContent` 有一个父 `Column` 可组合组件。在 `Column` 可组合组件内部，我们添加了三个 `AnimatedVisibility`
    可组合组件。第一个用于在 `petsUIState` 正在加载时显示 `CircularProgressIndicator`。第二个用于在 `petsUIState`
    中的 `pets` 变量不为空时显示猫的列表。第三个用于在 `petsUIState` 有错误时显示错误消息。'
- en: When displaying the list of cats, we check `contentType`. If `contentType` is
    `List`, we display the `PetList` composable. If `contentType` is `ListAndDetail`,
    we display the `PetListAndDetails` composable. We will create the `PetListAndDetails`
    composable shortly. Note the `PetList` composable is also modified to take in
    the `pets` parameter. We will use this parameter to display the list of cats.
    We will see the changes shortly.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当显示猫的列表时，我们检查 `contentType`。如果 `contentType` 是 `List`，我们显示 `PetList` 可组合组件。如果
    `contentType` 是 `ListAndDetail`，我们显示 `PetListAndDetails` 可组合组件。我们将很快创建 `PetListAndDetails`
    可组合组件。注意，`PetList` 可组合组件也被修改为接受 `pets` 参数。我们将使用此参数来显示猫的列表。我们将在稍后看到这些更改。
- en: Lastly, we show the error message if `petsUIState` has an error.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果 `petsUIState` 有错误，我们显示错误消息。
- en: 'Our updated `PetList` composable should look like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们更新的 `PetList` 可组合组件应如下所示：
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'No major changes here: we have just added the `pets` parameter. We use this
    parameter to display the list of cats in our `LazyColumn`. With this update, it
    is time to create the `PetListAndDetails` composable.'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里没有重大更改：我们只是添加了 `pets` 参数。我们使用此参数来在 `LazyColumn` 中显示猫的列表。随着这次更新，现在是时候创建 `PetListAndDetails`
    可组合组件了。
- en: 'Let us create a new file called `PetListAndDetails.kt` inside the view package
    and add the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在视图包内创建一个名为 `PetListAndDetails.kt` 的新文件，并添加以下代码：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This composable has a `Row`, which has two items each with a weight of `1f`.
    We have used the updated `PetListComposable` and `PetDetailsScreenContent` that
    we created earlier. We have also added a `currentPet` variable, which holds the
    currently selected cat. We use this variable to display the details of the selected
    cat. We also use this variable to update `currentPet` when we click on a pet item
    in the list. Make sure you also update `PetDetailsScreenContent` to take in the
    new modifier parameter.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个可组合组件包含一个`Row`，其中有两个项目，每个项目的权重为`1f`。我们使用了之前创建的更新版的`PetListComposable`和`PetDetailsScreenContent`。我们还添加了一个`currentPet`变量，它保存当前选中的猫。我们使用这个变量来显示选中猫的详细信息。我们还使用这个变量在点击列表中的宠物项目时更新`currentPet`。请确保您还更新了`PetDetailsScreenContent`以接受新的修饰符参数。
- en: With the modifications we have made, let us now create a new composable called
    `AppNavigationContent`, which has logic for displaying `NavigationRail` or `BottomNavigation`
    depending on `NavigationType`.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过我们所做的修改，现在让我们创建一个新的可组合组件，称为`AppNavigationContent`，它根据`NavigationType`显示`NavigationRail`或`BottomNavigation`的逻辑。
- en: 'Let us create a new file called `AppNavigationContent.kt` inside the navigation
    package and add the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`navigation`包内创建一个名为`AppNavigationContent.kt`的新文件，并添加以下代码：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s explain the preceding code:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释前面的代码：
- en: The `AppNavigationContent` composable takes a number of parameters. The `contentType`
    parameter is used to display the content type. The `navigationType` parameter
    is used to toggle the navigation options. `onFavoriteClicked` and `onHomeClicked`
    are callbacks that will be used to navigate to the different screens. `navHostController`
    is an object that manages navigation within the `NavHost` `onDrawerClicked` is
    used to close or open the drawer when the user interacts with it.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppNavigationContent`可组合组件接受多个参数。`contentType`参数用于显示内容类型。`navigationType`参数用于切换导航选项。`onFavoriteClicked`和`onHomeClicked`是回调函数，将用于导航到不同的屏幕。`navHostController`是一个对象，用于管理`NavHost`内的导航。`onDrawerClicked`用于在用户与之交互时关闭或打开抽屉。'
- en: We have `Row` as the root element. Inside `Row`, we have an `AnimatedVisibility`
    composable that displays the `PetsNavigationRail` composable when `navigationType`
    is `NavigationType`.`NavigationRail`. We have also added a `Scaffold` composable.
    We have used the `AppNavigation` composable as the content of `Scaffold`, passing
    in `contentType` and `navHostController`. We have also used the `PetsBottomNavigationBar`
    composable as the bottom bar of `Scaffold`. We have used the `AnimatedVisibility`
    composable to display the `PetsBottomNavigationBar` composable when `navigationType`
    is `NavigationType.BottomNavigation`.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有`Row`作为根元素。在`Row`内部，我们有一个`AnimatedVisibility`可组合组件，当`navigationType`为`NavigationType.NavigationRail`时显示`PetsNavigationRail`可组合组件。我们还添加了一个`Scaffold`可组合组件。我们使用`AppNavigation`可组合组件作为`Scaffold`的内容，传递`contentType`和`navHostController`。我们还使用`PetsBottomNavigationBar`可组合组件作为`Scaffold`的底部栏。我们使用`AnimatedVisibility`可组合组件在`navigationType`为`NavigationType.BottomNavigation`时显示`PetsBottomNavigationBar`可组合组件。
- en: 'The last step is to refactor the `MainActivity.kt` file to use the new `AppNavigationContent`
    composable. We will walk through the changes step by step. There are several changes:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将`MainActivity.kt`文件重构以使用新的`AppNavigationContent`可组合组件。我们将逐步说明更改。有几个更改：
- en: 'To begin with, we need to observe the device’s foldable state. This will enable
    us to change the content type and navigation type. Let us create a new file called
    `DeviceFoldPosture.kt` inside the `navigation` package and add the following code:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要观察设备的可折叠状态。这将使我们能够更改内容类型和导航类型。让我们在`navigation`包内创建一个名为`DeviceFoldPosture.kt`的新文件，并添加以下代码：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we have a sealed interface that represents the different
    postures a foldable device can be in. We have `BookPosture`, which represents
    the posture when the device is in portrait orientation and its fold state is half
    opened. We have `SeparatingPosture`, which represents the posture when the fold
    or hinge device creates two logical display areas. We also have `NormalPosture`,
    which represents the posture when the device is not folded. We have two utility
    functions, `isBookPosture()` and `isSeparating()`, which are used to check the
    posture of the device. We will use these functions to check the posture of the
    device and change the layout of the app depending on the posture.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个密封接口，表示可折叠设备可以处于的不同姿态。我们有`BookPosture`，表示设备处于纵向方向且折叠状态为半开时的姿态。我们有`SeparatingPosture`，表示折叠或铰链设备创建两个逻辑显示区域时的姿态。我们还有`NormalPosture`，表示设备未折叠时的姿态。我们有两个实用函数`isBookPosture()`和`isSeparating()`，用于检查设备的姿态。我们将使用这些函数来检查设备的姿态并根据姿态改变应用程序的布局。
- en: 'Let us head over to the `MainActivity.kt` file and add the following code before
    the `setContent` block:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`MainActivity.kt`文件，并在`setContent`块之前添加以下代码：
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we use `WindowInfoTracker` to get the window layout info. We use `flowWithLifecycle()`
    to make sure we only get the layout info when the activity is in the correct life
    cycle state. We then use the `map` operator to map the layout info to the different
    postures. We use the `stateIn()` operator, which converts a cold `Flow` into a
    hot `StateFlow` that is started in the given coroutine scope, sharing the most
    recently emitted value of device posture. We use `SharingStarted.Eagerly` to make
    sure we get the latest value of the posture when the activity is in the started
    state. We use the `initialValue` parameter to set the initial value of the posture
    to `DeviceFoldPosture.NormalPosture`. We will use this flow to observe the device’s
    posture and change the app’s layout depending on the posture.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`WindowInfoTracker`来获取窗口布局信息。我们使用`flowWithLifecycle()`来确保只有在活动处于正确的生命周期状态时才获取布局信息。然后我们使用`map`操作符将布局信息映射到不同的姿态。我们使用`stateIn()`操作符，它将一个冷的`Flow`转换为在给定的协程作用域中启动的热`StateFlow`，共享设备姿态的最新发出值。我们使用`SharingStarted.Eagerly`来确保当活动处于启动状态时，我们获取姿态的最新值。我们使用`initialValue`参数将姿态的初始值设置为`DeviceFoldPosture.NormalPosture`。我们将使用这个流来观察设备的姿态并根据姿态改变应用程序的布局。
- en: 'Next, inside our `setcontent` block, we need to add the variables before the
    theme block:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`setcontent`块内部，我们需要在主题块之前添加变量：
- en: '[PRE34]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have added the `devicePosture` variable, which holds the posture of the device.
    We have also added the `windowSizeClass` variable, which holds the window size
    class of the device; the `scope` variable, which holds `CoroutineScope`; the `drawerState`
    variable, which holds the state of the drawer; and the `navController` variable,
    which holds `NavHostController`. We will use this variable to navigate to different
    screens in our app.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了`devicePosture`变量，它持有设备的姿态。我们还添加了`windowSizeClass`变量，它持有设备的窗口大小类；`scope`变量，它持有`CoroutineScope`；`drawerState`变量，它持有抽屉的状态；以及`navController`变量，它持有`NavHostController`。我们将使用这个变量来导航到我们应用程序中的不同屏幕。
- en: 'Inside our `ChapterSevenTheme`, we need to add the following code:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`ChapterSevenTheme`内部，我们需要添加以下代码：
- en: '[PRE35]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we have two variables: `navigationType` and `contentType`. We use `windowSizeClass`
    to get the width of our device and, depending on the width size, we assign the
    values for our `navigationType` and `contentType` variables:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有两个变量：`navigationType`和`contentType`。我们使用`windowSizeClass`来获取我们设备的宽度，并根据宽度大小为我们的`navigationType`和`contentType`变量分配值：
- en: If the width size is `Compact`, we use `BottomNavigation` for `navigationType`
    and `List` for `contentType`.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是`紧凑`，我们使用`BottomNavigation`作为`navigationType`，使用`List`作为`contentType`。
- en: If the width size is `Medium`, we use `NavigationRail` for `navigationType`.
    For `contentType`, we check `devicePosture`. If `devicePosture` is `DeviceFoldPosture.BookPosture`
    or `DeviceFoldPosture.SeparatingPosture`, we use `ListAndDetail` for `contentType`.
    If `devicePosture` is not `DeviceFoldPosture.BookPosture` or `DeviceFoldPosture.SeparatingPosture`,
    we use `List` for `contentType`.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是`中等`，我们使用`NavigationRail`作为`navigationType`。对于`contentType`，我们检查`devicePosture`。如果`devicePosture`是`DeviceFoldPosture.BookPosture`或`DeviceFoldPosture.SeparatingPosture`，我们使用`ListAndDetail`作为`contentType`。如果`devicePosture`不是`DeviceFoldPosture.BookPosture`或`DeviceFoldPosture.SeparatingPosture`，我们使用`List`作为`contentType`。
- en: If the width size is `Expanded`, we check `devicePosture`. If `devicePosture`
    is `DeviceFoldPosture.BookPosture`, we use `NavigationRail` for `navigationType`.
    If `devicePosture` is not `DeviceFoldPosture.BookPosture`, we use `NavigationDrawer`
    for `navigationType`. We use `ListAndDetail` for `contentType`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是`Expanded`，我们检查`devicePosture`。如果`devicePosture`是`DeviceFoldPosture.BookPosture`，我们使用`NavigationRail`作为`navigationType`。如果`devicePosture`不是`DeviceFoldPosture.BookPosture`，我们使用`NavigationDrawer`作为`navigationType`。我们使用`ListAndDetail`作为`contentType`。
- en: Lastly, if the width size is anything else, we use `BottomNavigation` for `navigationType`
    and `List` for `contentType`.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果宽度大小是其他任何值，我们使用`BottomNavigation`作为`navigationType`和`List`作为`contentType`。
- en: 'Below the preceding code, add this `if` statement:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码下方，添加此`if`语句：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The condition checks whether `navigationType` is `NavigationType.NavigationDrawer`.
    If it is, we use the `PermanentNavigationDrawer` composable from the Material
    3 library. We use the `PetsNavigationDrawer` composable that we created for `drawerContent`.
    We use the `AppNavigationContent` composable as the content of `PermanentNavigationDrawer`.
    We pass in the `navigationType`, `contentType`, `onFavoriteClicked`, `onHomeClicked`,
    and `navHostController` parameters.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件检查`navigationType`是否为`NavigationType.NavigationDrawer`。如果是，我们使用 Material 3
    库中的`PermanentNavigationDrawer`可组合组件。我们使用我们为`drawerContent`创建的`PetsNavigationDrawer`可组合组件。我们将`AppNavigationContent`可组合组件用作`PermanentNavigationDrawer`的内容。我们传递`navigationType`、`contentType`、`onFavoriteClicked`、`onHomeClicked`和`navHostController`参数。
- en: 'Next, let us add the `else` condition for our `if` statement:'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的`if`语句添加`else`条件：
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, when `navigationType` is not `NavigationType.NavigationDrawer`, we use
    the `ModalNavigationDrawer` composable from the Material 3 library. We use the
    `PetsNavigationDrawer` composable for `drawerContent`. We use the `AppNavigationContent`
    composable as the content of `ModalNavigationDrawer`. We pass in the `navigationType`,
    `contentType`, `onFavoriteClicked`, `onHomeClicked`, and `navHostController` parameters.
    We also pass in the `drawerState` parameter. We use the `onDrawerClicked` callback
    to open or close the drawer when the user interacts with it.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，当`navigationType`不是`NavigationType.NavigationDrawer`时，我们使用 Material 3 库中的`ModalNavigationDrawer`可组合组件。我们使用`PetsNavigationDrawer`可组合组件作为`drawerContent`。我们将`AppNavigationContent`可组合组件用作`ModalNavigationDrawer`的内容。我们传递`navigationType`、`contentType`、`onFavoriteClicked`、`onHomeClicked`、`navHostController`和`drawerState`参数。我们还传递`onDrawerClicked`回调，以便在用户与之交互时打开或关闭抽屉。
- en: Those were a lot of changes; great work on adding them! We now need to run these
    changes and see them into action. Luckily, we have a **resizable emulator** to
    help test these changes. We will be creating one and testing the app in the next
    subsection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化有很多；添加它们的工作做得很好！我们现在需要运行这些变化并看到它们付诸实践。幸运的是，我们有一个**可调整大小的模拟器**来帮助测试这些变化。我们将在下一小节创建一个并测试该应用。
- en: Creating and using the resizable emulator
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用可调整大小的模拟器
- en: 'To create and use the resizable emulator, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用可调整大小的模拟器，请按照以下步骤操作：
- en: Open the **Device Manager** window from the right sidebar in Android Studio.
    If you cannot find it there, use the **View** menu option at the top and select
    **Tool Windows**; then, you will see the **Device** **Manager** option.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Android Studio 的右侧侧边栏打开**设备管理器**窗口。如果您在那里找不到它，请使用顶部的**视图**菜单选项并选择**工具窗口**；然后，您将看到**设备**
    **管理器**选项。
- en: '![Figure 7.5 – Device Manager](img/B19779_07_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 设备管理器](img/B19779_07_05.jpg)'
- en: Figure 7.5 – Device Manager
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 设备管理器
- en: 'Select the **Virtual** devices tab and click on **Create Device**, which brings
    you this pop-up window:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**虚拟设备**选项卡，然后点击**创建设备**，这将带您进入此弹出窗口：
- en: '![Figure 7.6 – New device configurations](img/B19779_07_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 新设备配置](img/B19779_07_06.jpg)'
- en: Figure 7.6 – New device configurations
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 新设备配置
- en: The window enables you to customize the properties of the device you want to
    create. You can change the device category and you also select the device you
    want to create.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口允许您自定义您想要创建的设备的属性。您可以更改设备类别，并且还可以选择您想要创建的设备。
- en: 'Let us select the **Resizable (Experimental)** option under the **Phone** category.
    This will enable us to create a resizable device. Click **Next** and you will
    see the following window:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在**电话**类别下选择**可调整大小（实验性）**选项。这将使我们能够创建一个可调整大小的设备。点击**下一步**，您将看到以下窗口：
- en: '![Figure 7.7 – System Image](img/B19779_07_07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 系统镜像](img/B19779_07_07.jpg)'
- en: Figure 7.7 – System Image
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 系统镜像
- en: 'Here, you select the system image you want to use. Let us select the **API
    34** system image. Click **Next** and you will see the following window:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你选择你想要使用的系统镜像。让我们选择 **API 34** 系统镜像。点击 **下一步**，你将看到以下窗口：
- en: '![Figure 7.8 – Device information](img/B19779_07_08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 设备信息](img/B19779_07_08.jpg)'
- en: Figure 7.8 – Device information
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 设备信息
- en: This is the last step where you confirm the device name and the device orientation.
    We will maintain the name generated and use portrait as the default orientation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一步，你需要确认设备名称和设备方向。我们将保持生成的名称并使用纵向作为默认方向。
- en: 'Click **Finish** and you will see the device has been added to your list of
    devices:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成**，你将看到设备已添加到你的设备列表中：
- en: '![Figure 7.9 – Devices list](img/B19779_07_09.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 设备列表](img/B19779_07_09.jpg)'
- en: Figure 7.9 – Devices list
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 设备列表
- en: Start the emulator and run the app.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器并运行应用。
- en: '![Figure 7.10 – Resizable emulator](img/B19779_07_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 可调整大小的模拟器](img/B19779_07_10.jpg)'
- en: Figure 7.10 – Resizable emulator
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 可调整大小的模拟器
- en: From the emulator, we can see we have two options highlighted. The first one
    allows us to change the device from a small/normal device to a foldable or tablet
    device. The second one allows us to change the options when we change to a foldable
    device. Let us change the device to a foldable device. The app now changes the
    navigation option to navigation rail and the screen has a list and details of
    the first cat opened too.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从模拟器中，我们可以看到有两个选项被突出显示。第一个选项允许我们将设备从小型/普通设备更改为折叠或平板电脑设备。第二个选项允许我们在更改为折叠设备时更改选项。让我们将设备更改为折叠设备。现在应用将导航选项更改为导航轨道，并且屏幕上也有打开的第一个猫的列表和详细信息。
- en: '![Figure 7.11 – Foldable device navigation rail](img/B19779_07_11.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 折叠设备导航轨道](img/B19779_07_11.jpg)'
- en: Figure 7.11 – Foldable device navigation rail
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 折叠设备导航轨道
- en: 'On tapping the **Foldable** options, we can see the following options:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **折叠** 选项，我们可以看到以下选项：
- en: '![Figure 7.12 – Foldable options](img/B19779_07_12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 折叠选项](img/B19779_07_12.jpg)'
- en: Figure 7.12 – Foldable options
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 折叠选项
- en: 'Selecting the second option in the foldables section brings us to the following
    screen:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在折叠部分选择第二个选项将带我们到以下屏幕：
- en: '![Figure 7.13 – Foldable device](img/B19779_07_13.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 折叠设备](img/B19779_07_13.jpg)'
- en: Figure 7.13 – Foldable device
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 折叠设备
- en: 'From the device size option, we can also switch to tablet view:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备尺寸选项，我们也可以切换到平板电脑视图：
- en: '![Figure 7.14 – Tablet view](img/B19779_07_14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 平板电脑视图](img/B19779_07_14.jpg)'
- en: Figure 7.14 – Tablet view
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 平板电脑视图
- en: You can see the app now has a permanent navigation drawer and the screen has
    a list and details of the first cat opened too. Tap a different cat and you will
    see the details of the cat displayed on the right side of the screen. We can also
    navigate to the **Favorites** screen and back to the **Pets** screen.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到应用已经有一个永久的导航抽屉，屏幕上也有打开的第一个猫的列表和详细信息。点击不同的猫，你将看到猫的详细信息显示在屏幕的右侧。我们还可以导航到
    **收藏** 屏幕并返回到 **宠物** 屏幕。
- en: '![Figure 7.15 – Favorite Pets screen](img/B19779_07_15.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 收藏宠物屏幕](img/B19779_07_15.jpg)'
- en: Figure 7.15 – Favorite Pets screen
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 收藏宠物屏幕
- en: 'We can also see the modal navigation drawer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到模态导航抽屉：
- en: '![Figure 7.16 – Modal navigation drawer](img/B19779_07_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 模态导航抽屉](img/B19779_07_16.jpg)'
- en: Figure 7.16 – Modal navigation drawer
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 模态导航抽屉
- en: 'The resizable emulator is a great way for us to test our app across different
    device sizes, but it has its own limitations. The following are the limitations
    of resizable emulators:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可调整大小的模拟器是我们测试不同设备尺寸应用的好方法，但它也有其局限性。以下是可以调整大小的模拟器的局限性：
- en: '**Hinge simulation**: While resizable emulators offer multi-window support
    and simulate various orientations, they might not accurately replicate the behavior
    of a physical hinge on foldable devices. The hinge’s physical characteristics
    and behavior may affect app layouts and interactions differently.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**铰链模拟**：虽然可调整大小的模拟器提供多窗口支持和模拟各种方向，但它们可能无法准确复制折叠设备上物理铰链的行为。铰链的物理特性和行为可能以不同的方式影响应用布局和交互。'
- en: '**Hardware specifics**: Emulators lack physical hardware components present
    in foldable devices, such as the actual hinge mechanism, flexible displays, sensors,
    and proprietary features, impacting the true emulation of foldable device behavior.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件特性**：模拟器缺少折叠设备中存在的物理硬件组件，例如实际铰链机制、柔性显示屏、传感器和专有功能，这影响了折叠设备行为的真实模拟。'
- en: '**Performance variation**: Emulators may not accurately represent the performance
    capabilities of real foldable devices, especially in terms of hardware-specific
    optimizations and performance characteristics.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能差异**：仿真器可能无法准确代表真实可折叠设备的性能能力，特别是在硬件特定的优化和性能特性方面。'
- en: '**Real-world testing environment**: Foldable devices may have unique environmental
    factors that impact user experience, such as external lighting conditions affecting
    the flexible display. Emulators may not replicate these real-world scenarios accurately.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实世界测试环境**：可折叠设备可能具有影响用户体验的独特环境因素，例如外部照明条件会影响柔性显示屏。仿真器可能无法准确复制这些现实世界场景。'
- en: '**Software emulation versus hardware interaction**: Certain foldable device
    behaviors, such as drag-and-drop interactions across screens or unique gestures,
    might not be fully emulated in software due to hardware-specific interactions.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件仿真与硬件交互**：某些可折叠设备的行为，如跨屏幕的拖放交互或独特的手势，可能由于硬件特定的交互而无法在软件中完全仿真。'
- en: 'We have learned how to handle navigation in foldable devices and large screens
    and how to provide a great user experience as the user is switching between the
    different screen sizes. This ensures that our app is responsive to different devices
    and that we satisfactorily use the available screen sizes. The team at Google
    has published stories of companies that support large screens and foldables; you
    can have a look here: [https://developer.android.com/large-screens/stories](https://developer.android.com/large-screens/stories).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在可折叠设备和大型屏幕上处理导航，以及如何在用户在不同屏幕尺寸之间切换时提供出色的用户体验。这确保了我们的应用能够对不同设备做出响应，并且能够充分利用可用的屏幕尺寸。谷歌团队发布了支持大屏幕和可折叠设备的公司故事；您可以在此查看：[https://developer.android.com/large-screens/stories](https://developer.android.com/large-screens/stories)。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use the Jetpack Compose Navigation library
    to navigate to different Jetpack Compose screens within our app. We have also
    learned tips and best practices for using this library. Additionally, we have
    covered how to pass arguments as we navigate to screens. Lastly, we have built
    on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055), by handling
    navigation in large screens and foldables in detail.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Jetpack Compose导航库在应用内导航到不同的Jetpack Compose屏幕。我们还学习了使用此库的技巧和最佳实践。此外，我们还介绍了如何在导航到屏幕时传递参数。最后，我们通过详细处理大屏幕和可折叠设备中的导航，在[*第4章*](B19779_04.xhtml#_idTextAnchor055)所学内容的基础上进行了扩展。
- en: We have created `FavoritePetsScreen`, but as of now it only has a `Text` label.
    In the next chapter, we will be adding functionality to persist data locally and
    retrieve that data locally too without any internet access. We will learn how
    to save our cute cat photos to Room, another Jetpack library for offline storage,
    and also add pets to our favorites list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`FavoritePetsScreen`，但截至目前，它只有一个`Text`标签。在下一章中，我们将添加功能以在本地持久化数据，并在没有互联网访问的情况下检索这些数据。我们将学习如何将我们可爱的小猫照片保存到Room，这是另一个用于离线存储的Jetpack库，并且还将添加宠物到我们的收藏列表中。
