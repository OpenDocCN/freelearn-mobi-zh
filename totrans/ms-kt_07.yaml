- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating within Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The apps we make need to move from one screen to the other, showing different
    content on these screens. So far, we have been making apps with only one screen.
    In this chapter, we will learn how to move from one screen to the other. We will
    learn how to use the **Jetpack Compose Navigation** library to navigate to different
    Jetpack Compose screens within our app. We will learn the tips and best practices
    for using this library. Also, we will cover how to pass arguments as we navigate
    to screens. Lastly, we will build on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055),
    by handling navigation on large screens and foldables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Navigation overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to Compose destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation in foldables and large screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven).
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Navigation overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jetpack Navigation library provides an API for handling **complex navigation**
    with ease while also following the principles of Android Jetpack. The library
    is available for both the old view system, which uses XML ([https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation)),
    and Jetpack Compose ([https://developer.android.com/jetpack/compose/navigation](https://developer.android.com/jetpack/compose/navigation)).
    We will be learning about the latter in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Still building on the Pets app we used in the previous chapter, we are going
    to navigate to a details screen that has a back button to the previous screen.
    We will also be passing data to the details screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to add the Jetpack Navigation Compose dependency to
    our project. Let’s add the following library inside the `versions` section in
    our `libs.versions.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the dependency to our app module’s `build.gradle.kts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a Gradle sync to add the library to our project. The next step is to create
    `NavController` and `NavHost`. `NavController` is a class that manages app navigation
    within `NavHost`. `NavHost` is a container that hosts composables and handles
    navigation between them. Let’s create a new package called `navigation` and create
    a new sealed class called `Screens.kt`. Inside the file, let us add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a sealed class that has two objects. A sealed class is used to represent
    restricted class hierarchies wherein the object or value can only have a value
    among one of the types defined in the sealed class. The first object is `PetsScreen`,
    which will be the first screen we will see when we launch the app. The second
    object is `PetDetailsScreen`, which will be the screen we will navigate to when
    we click on a pet item in `PetsScreen`. Every time we need to add a new destination
    screen, we will add a new object to the sealed class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us create a new file inside the `navigation` package called `AppNavigation.kt`.
    Inside the file, let us add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We create `NavController` using the `rememberNavController()` function. This
    function is used to create `NavController` that will be remembered across recompositions.
    This is important because we need to be able to navigate to different screens
    in our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `NavHost` composable that takes in `navController` and `startDestination`.
    `startDestination` is the first screen we want to see when we launch the app.
    In our case, it is `PetsScreen`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the `PetsScreen` composable. This composable has an error because we
    have not created it yet. We will do that shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – PetsScreen error](img/B19779_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – PetsScreen error
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding screenshot, the `PetsScreen` composable is highlighted
    in red because we have not created the composable yet. We will refactor our code
    a bit. Let us create a new file called `PetsScreen.kt`. Inside the file, let’s
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `PetsScreen` composable displays a list of pets. We have added a `Scaffold`
    composable as the root element. Inside the `Scaffold` composable, we have added
    a `TopAppBar` composable. We have also added a `PetList` composable as the content
    of the `Scaffold` composable. We have added a new `onPetClicked` callback to the
    `PetList` composable. We will be using this callback to navigate to `PetDetailsScreen`
    when we click on a pet item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, our navigation graph is ready. We can now add the `AppNavigation`
    composable to our `MainActivity.kt` file. Let’s replace all the code inside the
    `ChapterSevenTheme` block with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the app. The app still displays a list of cute pets as before,
    but now we are using the Jetpack Navigation library to handle our navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Pets](img/B19779_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Pets
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let us learn how to navigate to a details screen when we
    click on a pet item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to Compose destinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to navigate to a details screen when we
    click on a pet item in the list. First, we need to create a new composable for
    `PetDetailsScreen`. Let us create a new file called `PetDetailsScreen.kt` and
    create the `PetDetailsScreenContent` composable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a composable that has `Column` as the root element. Inside
    the `Column` element, we added an `AsyncImage` composable that displays a cat
    image. We also added a `FlowRow` composable to flow items to the next line when
    space runs out, which cannot be achieved with rows. `FlowRow` displays two `SuggestionChip`
    composables. We will use this composable to display the details of a pet. Notice
    we are using hardcoded cat IDs and tags for now. We will pass this data from the
    `PetList` composable in the next section. Next, let us create the `PetDetailsScreen`
    composable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `PetDetailsScreen` composable displays the details of a pet. We have added
    a `Scaffold` composable as the root element. Inside the `Scaffold` composable,
    we have added a `TopAppBar` composable. We have also used the `PetDetailsScreenContent`
    composable we created earlier as the content of the `Scaffold` composable. We
    have added a new `onBackPressed` callback to the `PetDetailsScreen` composable.
    We will be using this callback to navigate back to the previous screen when we
    click on the back button in `TopAppBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to add a composable for `PetDetailsScreen` to our `AppNavigation.kt`
    file. Let us add the following code to our `NavHost` below the composable for
    `PetsScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a composable for `PetDetailsScreen`. We passed in the route
    for the screen and the `PetDetailsScreen` composable as the content. `PetDetailsScreen`
    has the `onBackPressed` argument. The argument handles the situation where a user
    taps the back arrow icon, which is normally at the top left. We use `navController.popBackStack()`
    inside the `onBackPressed` argument. This method attempts to pop the current destination
    off the back stack and navigates to the previous destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to do the actual navigation to `PetDetailsScreen` when we click
    on a pet item in the list. Let us head over to the `PetListItem` composable. We
    will add a new `onPetClicked` callback to the `PetListItem` composable. The modified
    composable should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a new `onPetClicked` callback to the composable.
    We have added the `clickable` modifier to `Column` and called the `onPetClicked`
    callback inside the modifier. We pass in the `cat` object to the callback. Next,
    we need to add the `onPetClicked` callback to the `PetList` composable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to pass this callback where we use our `PetListItem` composable.
    The modified `PetListItem` composable at the call site inside the items block
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to modify the `AppNavigation` composable to pass the `onPetClicked`
    callback to the `PetsScreen` composable. The modified `AppNavigation` composable
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass the `onPetClicked` callback to the `PetsScreen` composable. Inside
    the callback, we call the `navigate()` function on `navController` and pass in
    the route for `PetDetailsScreen`. This will navigate to `PetDetailsScreen` when
    we click on a pet item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the app. Click on a pet item in the list. You will see that the
    app navigates to `PetDetailsScreen`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Pet Details screen](img/B19779_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Pet Details screen
  prefs: []
  type: TYPE_NORMAL
- en: We can see a cute cat image and some tags. Additionally, if we press the back
    button in `TopAppBar`, we will be able to navigate back to `PetsScreen`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been able to navigate from `PetsScreen` to `PetDetailsScreen`.
    However, we are not passing any data to `PetDetailsScreen`. In the next section,
    we will learn how to pass data to `PetDetailsScreen`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to destinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `PetDetailsScreen`, we need to remove the hardcoded cat IDs and tags
    and pass them from the `PetList` composable. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us head over to the `PetDetailsScreenContent` composable inside the `PetDetailsScreen.kt`
    file and modify it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added a new `cat` parameter to the composable. We have used the `cat`
    object to display the cat image and tags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us head over to the `PetDetailsScreen` composable and modify it as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have added a new `cat` parameter to the composable. We have passed
    the `cat` object to the `PetDetailsScreenContent` composable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us head over to the `AppNavigation` composable and add the logic
    for passing the `cat` object to `PetDetailsScreen`. We need to first modify the
    composable for `PetDetailsScreen`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s explain the changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the route, we have added a new parameter called `cat`. This is the parameter
    we will use to pass the `cat` object to `PetDetailsScreen`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added a new `arguments` parameter. This parameter is used to pass arguments
    to the destination screen. We have added `navArgument` for the `cat` parameter.
    We have set the type to be `String`. This is because we will be passing a string
    representation of the `cat` object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass the `cat` object to the `PetDetailsScreen` composable. We have used
    `Json.decodeFromString()` from the Kotlinx Serialization library that we learned
    about in [*Chapter 6*](B19779_06.xhtml#_idTextAnchor084) to convert the string
    value of the `cat` object into a `Cat` object. We have used the `arguments` property
    of `NavBackStackEntry` to get the string value of the `cat` object. We have used
    the Elvis operator to return an empty string if the `arguments` property is null.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, we need to modify the `onPetClicked` callback of `PetsScreen` in the
    `AppNavigation` composable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have modified the `navigate()` function to pass the `Cat` object as a string.
    We also used `Json.encodeToString()` from the Kotlinx Serialization library to
    convert the `Cat` object into a string. This will be passed as an argument to
    `PetDetailsScreen` when we click on a pet item in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build and run the app. Click on any cute cat picture from the list and now
    the details screen will display the cat image and tag of the cute cat that we
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Pet Details](img/B19779_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Pet Details
  prefs: []
  type: TYPE_NORMAL
- en: We have now been able to pass data to `PetDetailsScreen`. We have learned how
    to navigate to a compose destination and pass data to the details screen. In the
    next section, we will learn how to handle navigation in foldables and large screens.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation in foldables and large screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Designing UIs for large screens and foldables* section of [*Chapter
    4*](B19779_04.xhtml#_idTextAnchor055), we learned about the `WindowSize` class
    and how we can make our apps responsive in foldable devices and large screens.
    In this section, we are going to make our Pets app responsive in foldable devices
    and large screens. We are going to make several changes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a bottom bar to `PetsScreen`, which will have several options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `NavigationRail` and `NavigationDrawer`, which will be used depending on
    the screen size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe the device’s foldable state and change the layout of the app depending
    on the foldable state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the screen size, we will also change the content type. On large
    screens, we will display the list of cats and the details of the selected cat
    side by side. On small screens, we will display the list of cats and the details
    of the selected cat on different screens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quite a lot of changes are required. The good thing is that I have already
    made the changes and you can find the final version in the `chapterseven` folder
    in the project’s repository. Let us go through the changes one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a `sealed interface` named `NavigationType` that
    represents the different types of navigation we will be using in our app. Let
    us create a new file inside the `navigation` package called `NavigationType.kt`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are using a sealed interface instead of a sealed class here. This is because
    we do not need to hold any state in our `NavigationType`. We also do not need
    to pass properties to any of the `NavigationTypes`. We have three options: `BottomNavigation`,
    `NavigationDrawer`, and `NavigationRail`. We will be using these options to change
    the navigation type depending on the screen size.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us create yet another sealed interface called `ContentType`. This
    interface will be used to change the content display type depending on the screen
    size. Let us create a new file called `ContentType.kt` still inside the `navigation`
    package and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This represents the two modes in which we can display our content depending
    on the screen size. We have the `List` mode, which displays the list of cats only.
    We also have the `ListAndDetail` mode, which displays the list of cats and the
    details of the selected cat side by side.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, in our `Screens.kt` file, we have to add a new destination screen called
    `FavoritesScreen`. The final code for the file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have three destinations for our app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us add the `WindowSize` dependencies to the libraries section in
    the `libs.versions.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add the dependencies to our app module’s `build.gradle.kts`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do a Gradle sync to be able to add the dependencies to our project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to create the composables for `NavigationRail`, `NavigationDrawer`,
    and `BottomNavigation`. Let us create a new file called `PetsNavigationRail.kt`
    inside the `view` package and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we created the `PetsNavigationRail()` composable, which
    has three parameters: `onFavoriteClicked`, `onHomeClicked`, and `onDrawerClicked`.
    The first two are callbacks that will be used to navigate to the different screens.
    We use the `onDrawerClicked` callback to close or open the drawer when the user
    interacts with it. At the top, we have the `items` variable, which holds a list
    of all our screens, and the `selectedItem` variable, which holds the currently
    selected screen. We use the `NavigationRail` composable from the Material 3 library
    to display the navigation rail. To add items to `NavigationRail`, we use the `NavigationRailItem`
    composable. We pass in the selected state of the item, the `onClick` callback,
    and the icon to display.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us create the `PetsBottomNavigationBar` composable. Let us create
    a new file called `PetsBottomNavigationBar.kt` inside the `view` package and add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PetsBottomNavigationBar` composable is similar to the `PetsNavigationRail`
    composable. The only difference is that we are using the `NavigationBar` composable
    instead of the `NavigationRail` composable. We have the home and favorite items.
    We use the `NavigationBarItem` composable to add items to `NavigationBar`. We
    pass in the selected state of the item, the `onClick` callback, and the icon to
    display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us create the `PetsNavigationDrawer` composable. Let us create a
    new file called `PetsNavigationDrawer.kt` inside the `view` package and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We used the `NavigationDrawer` composable from the Material 3 library to display
    the navigation drawer. We used the `NavigationDrawerItem` composable to add items
    to `NavigationDrawer`. We passed in the label, the selected state of the item,
    the `onClick` callback, and the icon to display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since our `PetsNavigationDrawer`, `PetsNavigationRail`, and `PetsBottomNavigationBar`
    composables have `FavoritesScreen`, let us create a new file called `FavoritePetsScreen.kt`
    inside the view package and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a simple composable that displays the text `"Favorite Pets"`. We will
    use this composable as the content of `FavoritesScreen`. We also need to refactor
    our `AppNavigation()` composable to make it ready to handle the different navigation
    and content types. The final modified composable should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s highlight the changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `AppNavigation()` composable now takes in a `contentType` parameter of type
    `ContentType`. This is the parameter we will use to change the content type depending
    on the screen size. We also pass in a `navHostController` parameter of type `NavHostController`.
    This is the parameter we will use to navigate to different screens in our app.
    Previously, `navHostController` was created inside the `AppNavigation()` composable.
    We have moved it to the call site so that we can be able to use the same `navHostController`
    in different composables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the new `PetsScreen()` composable, which takes in the `contentType`
    parameter. Same as before, we still pass `onPetClicked`, which navigates to `PetDetailsScreen`.
    Previously, we were using the `PetList` composable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have added our new `FavoritePetsScreen` destination to the `NavHost`
    composable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us see what the new update `PetsScreen` composable looks like. Let us head
    over to the `PetsScreen.kt` file and modify the composable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added a new `contentType` parameter to the composable. We have also
    added a new `petsUIState` parameter. This is the UI state of `PetsScreen`. We
    will use this state to display the list of cats.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a new file called `PetsScreenContent.kt` and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s explain the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PetsScreenContent` has a parent `Column` composable. Inside the `Colum`n composable,
    we have added three `AnimatedVisibility` composables. The first one is used to
    display `CircularProgressIndicator` when `petsUIState` is loading. The second
    one is used to display the list of cats when the `pets` variable from `petsUIState`
    is not empty. The third one is used to display an error message when `petsUIState`
    has an error.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When displaying the list of cats, we check `contentType`. If `contentType` is
    `List`, we display the `PetList` composable. If `contentType` is `ListAndDetail`,
    we display the `PetListAndDetails` composable. We will create the `PetListAndDetails`
    composable shortly. Note the `PetList` composable is also modified to take in
    the `pets` parameter. We will use this parameter to display the list of cats.
    We will see the changes shortly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we show the error message if `petsUIState` has an error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our updated `PetList` composable should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No major changes here: we have just added the `pets` parameter. We use this
    parameter to display the list of cats in our `LazyColumn`. With this update, it
    is time to create the `PetListAndDetails` composable.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us create a new file called `PetListAndDetails.kt` inside the view package
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This composable has a `Row`, which has two items each with a weight of `1f`.
    We have used the updated `PetListComposable` and `PetDetailsScreenContent` that
    we created earlier. We have also added a `currentPet` variable, which holds the
    currently selected cat. We use this variable to display the details of the selected
    cat. We also use this variable to update `currentPet` when we click on a pet item
    in the list. Make sure you also update `PetDetailsScreenContent` to take in the
    new modifier parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the modifications we have made, let us now create a new composable called
    `AppNavigationContent`, which has logic for displaying `NavigationRail` or `BottomNavigation`
    depending on `NavigationType`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us create a new file called `AppNavigationContent.kt` inside the navigation
    package and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s explain the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `AppNavigationContent` composable takes a number of parameters. The `contentType`
    parameter is used to display the content type. The `navigationType` parameter
    is used to toggle the navigation options. `onFavoriteClicked` and `onHomeClicked`
    are callbacks that will be used to navigate to the different screens. `navHostController`
    is an object that manages navigation within the `NavHost` `onDrawerClicked` is
    used to close or open the drawer when the user interacts with it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `Row` as the root element. Inside `Row`, we have an `AnimatedVisibility`
    composable that displays the `PetsNavigationRail` composable when `navigationType`
    is `NavigationType`.`NavigationRail`. We have also added a `Scaffold` composable.
    We have used the `AppNavigation` composable as the content of `Scaffold`, passing
    in `contentType` and `navHostController`. We have also used the `PetsBottomNavigationBar`
    composable as the bottom bar of `Scaffold`. We have used the `AnimatedVisibility`
    composable to display the `PetsBottomNavigationBar` composable when `navigationType`
    is `NavigationType.BottomNavigation`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last step is to refactor the `MainActivity.kt` file to use the new `AppNavigationContent`
    composable. We will walk through the changes step by step. There are several changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To begin with, we need to observe the device’s foldable state. This will enable
    us to change the content type and navigation type. Let us create a new file called
    `DeviceFoldPosture.kt` inside the `navigation` package and add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have a sealed interface that represents the different
    postures a foldable device can be in. We have `BookPosture`, which represents
    the posture when the device is in portrait orientation and its fold state is half
    opened. We have `SeparatingPosture`, which represents the posture when the fold
    or hinge device creates two logical display areas. We also have `NormalPosture`,
    which represents the posture when the device is not folded. We have two utility
    functions, `isBookPosture()` and `isSeparating()`, which are used to check the
    posture of the device. We will use these functions to check the posture of the
    device and change the layout of the app depending on the posture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us head over to the `MainActivity.kt` file and add the following code before
    the `setContent` block:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use `WindowInfoTracker` to get the window layout info. We use `flowWithLifecycle()`
    to make sure we only get the layout info when the activity is in the correct life
    cycle state. We then use the `map` operator to map the layout info to the different
    postures. We use the `stateIn()` operator, which converts a cold `Flow` into a
    hot `StateFlow` that is started in the given coroutine scope, sharing the most
    recently emitted value of device posture. We use `SharingStarted.Eagerly` to make
    sure we get the latest value of the posture when the activity is in the started
    state. We use the `initialValue` parameter to set the initial value of the posture
    to `DeviceFoldPosture.NormalPosture`. We will use this flow to observe the device’s
    posture and change the app’s layout depending on the posture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, inside our `setcontent` block, we need to add the variables before the
    theme block:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added the `devicePosture` variable, which holds the posture of the device.
    We have also added the `windowSizeClass` variable, which holds the window size
    class of the device; the `scope` variable, which holds `CoroutineScope`; the `drawerState`
    variable, which holds the state of the drawer; and the `navController` variable,
    which holds `NavHostController`. We will use this variable to navigate to different
    screens in our app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside our `ChapterSevenTheme`, we need to add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have two variables: `navigationType` and `contentType`. We use `windowSizeClass`
    to get the width of our device and, depending on the width size, we assign the
    values for our `navigationType` and `contentType` variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the width size is `Compact`, we use `BottomNavigation` for `navigationType`
    and `List` for `contentType`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the width size is `Medium`, we use `NavigationRail` for `navigationType`.
    For `contentType`, we check `devicePosture`. If `devicePosture` is `DeviceFoldPosture.BookPosture`
    or `DeviceFoldPosture.SeparatingPosture`, we use `ListAndDetail` for `contentType`.
    If `devicePosture` is not `DeviceFoldPosture.BookPosture` or `DeviceFoldPosture.SeparatingPosture`,
    we use `List` for `contentType`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the width size is `Expanded`, we check `devicePosture`. If `devicePosture`
    is `DeviceFoldPosture.BookPosture`, we use `NavigationRail` for `navigationType`.
    If `devicePosture` is not `DeviceFoldPosture.BookPosture`, we use `NavigationDrawer`
    for `navigationType`. We use `ListAndDetail` for `contentType`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, if the width size is anything else, we use `BottomNavigation` for `navigationType`
    and `List` for `contentType`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below the preceding code, add this `if` statement:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The condition checks whether `navigationType` is `NavigationType.NavigationDrawer`.
    If it is, we use the `PermanentNavigationDrawer` composable from the Material
    3 library. We use the `PetsNavigationDrawer` composable that we created for `drawerContent`.
    We use the `AppNavigationContent` composable as the content of `PermanentNavigationDrawer`.
    We pass in the `navigationType`, `contentType`, `onFavoriteClicked`, `onHomeClicked`,
    and `navHostController` parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us add the `else` condition for our `if` statement:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, when `navigationType` is not `NavigationType.NavigationDrawer`, we use
    the `ModalNavigationDrawer` composable from the Material 3 library. We use the
    `PetsNavigationDrawer` composable for `drawerContent`. We use the `AppNavigationContent`
    composable as the content of `ModalNavigationDrawer`. We pass in the `navigationType`,
    `contentType`, `onFavoriteClicked`, `onHomeClicked`, and `navHostController` parameters.
    We also pass in the `drawerState` parameter. We use the `onDrawerClicked` callback
    to open or close the drawer when the user interacts with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Those were a lot of changes; great work on adding them! We now need to run these
    changes and see them into action. Luckily, we have a **resizable emulator** to
    help test these changes. We will be creating one and testing the app in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the resizable emulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and use the resizable emulator, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Device Manager** window from the right sidebar in Android Studio.
    If you cannot find it there, use the **View** menu option at the top and select
    **Tool Windows**; then, you will see the **Device** **Manager** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Device Manager](img/B19779_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Device Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Virtual** devices tab and click on **Create Device**, which brings
    you this pop-up window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – New device configurations](img/B19779_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – New device configurations
  prefs: []
  type: TYPE_NORMAL
- en: The window enables you to customize the properties of the device you want to
    create. You can change the device category and you also select the device you
    want to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us select the **Resizable (Experimental)** option under the **Phone** category.
    This will enable us to create a resizable device. Click **Next** and you will
    see the following window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – System Image](img/B19779_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – System Image
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you select the system image you want to use. Let us select the **API
    34** system image. Click **Next** and you will see the following window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Device information](img/B19779_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Device information
  prefs: []
  type: TYPE_NORMAL
- en: This is the last step where you confirm the device name and the device orientation.
    We will maintain the name generated and use portrait as the default orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Finish** and you will see the device has been added to your list of
    devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Devices list](img/B19779_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Devices list
  prefs: []
  type: TYPE_NORMAL
- en: Start the emulator and run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Resizable emulator](img/B19779_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Resizable emulator
  prefs: []
  type: TYPE_NORMAL
- en: From the emulator, we can see we have two options highlighted. The first one
    allows us to change the device from a small/normal device to a foldable or tablet
    device. The second one allows us to change the options when we change to a foldable
    device. Let us change the device to a foldable device. The app now changes the
    navigation option to navigation rail and the screen has a list and details of
    the first cat opened too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Foldable device navigation rail](img/B19779_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Foldable device navigation rail
  prefs: []
  type: TYPE_NORMAL
- en: 'On tapping the **Foldable** options, we can see the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Foldable options](img/B19779_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Foldable options
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting the second option in the foldables section brings us to the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Foldable device](img/B19779_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Foldable device
  prefs: []
  type: TYPE_NORMAL
- en: 'From the device size option, we can also switch to tablet view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Tablet view](img/B19779_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Tablet view
  prefs: []
  type: TYPE_NORMAL
- en: You can see the app now has a permanent navigation drawer and the screen has
    a list and details of the first cat opened too. Tap a different cat and you will
    see the details of the cat displayed on the right side of the screen. We can also
    navigate to the **Favorites** screen and back to the **Pets** screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Favorite Pets screen](img/B19779_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Favorite Pets screen
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the modal navigation drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Modal navigation drawer](img/B19779_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Modal navigation drawer
  prefs: []
  type: TYPE_NORMAL
- en: 'The resizable emulator is a great way for us to test our app across different
    device sizes, but it has its own limitations. The following are the limitations
    of resizable emulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hinge simulation**: While resizable emulators offer multi-window support
    and simulate various orientations, they might not accurately replicate the behavior
    of a physical hinge on foldable devices. The hinge’s physical characteristics
    and behavior may affect app layouts and interactions differently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware specifics**: Emulators lack physical hardware components present
    in foldable devices, such as the actual hinge mechanism, flexible displays, sensors,
    and proprietary features, impacting the true emulation of foldable device behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance variation**: Emulators may not accurately represent the performance
    capabilities of real foldable devices, especially in terms of hardware-specific
    optimizations and performance characteristics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-world testing environment**: Foldable devices may have unique environmental
    factors that impact user experience, such as external lighting conditions affecting
    the flexible display. Emulators may not replicate these real-world scenarios accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software emulation versus hardware interaction**: Certain foldable device
    behaviors, such as drag-and-drop interactions across screens or unique gestures,
    might not be fully emulated in software due to hardware-specific interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have learned how to handle navigation in foldable devices and large screens
    and how to provide a great user experience as the user is switching between the
    different screen sizes. This ensures that our app is responsive to different devices
    and that we satisfactorily use the available screen sizes. The team at Google
    has published stories of companies that support large screens and foldables; you
    can have a look here: [https://developer.android.com/large-screens/stories](https://developer.android.com/large-screens/stories).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use the Jetpack Compose Navigation library
    to navigate to different Jetpack Compose screens within our app. We have also
    learned tips and best practices for using this library. Additionally, we have
    covered how to pass arguments as we navigate to screens. Lastly, we have built
    on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055), by handling
    navigation in large screens and foldables in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We have created `FavoritePetsScreen`, but as of now it only has a `Text` label.
    In the next chapter, we will be adding functionality to persist data locally and
    retrieve that data locally too without any internet access. We will learn how
    to save our cute cat photos to Room, another Jetpack library for offline storage,
    and also add pets to our favorites list.
  prefs: []
  type: TYPE_NORMAL
