- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, Structures, and Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to group instruction sequences using
    functions and closures.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to think about how to represent complex objects in your code. For
    example, think about a car. You could use a `String` constant to store a car name
    and a `Double` variable to store a car price, but they are not associated with
    one another. You’ve seen that you can group instructions to make functions and
    closures. In this chapter, you’ll learn how to group constants and variables in
    a single entity using **classes** and **structures**, and how to manipulate them.
    You’ll also learn how to use **enumerations** to group a set of related values.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned how to create and initialize
    a class, create a subclass from an existing class, create and initialize a structure,
    differentiate between classes and structures, and create an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Xcode playground for this chapter is in the `Chapter07` folder of the code
    bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Eighth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Eighth-Edition%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/Yl9UuzSR_oE](https://youtu.be/Yl9UuzSR_oE%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to start from scratch, create a new playground and name it `ClassesStructuresAndEnumerations`.
    You can type in and run all the code in this chapter as you go along. Let’s start
    with learning what a class is and how to declare and define it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are useful for representing complex objects, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual employee information for a company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items for sale at an e-commerce site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items you have in your house for insurance purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s what a class declaration and definition look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every class has a descriptive name, and it contains variables or constants used
    to represent an object. Variables or constants associated with a class are called
    **properties**.
  prefs: []
  type: TYPE_NORMAL
- en: A class can also contain functions that perform specific tasks. The functions
    associated with a class are called **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have declared and defined a class, you can create **instances** of
    that class. Imagine you are creating an app for a zoo. If you have an `Animal`
    class, you can use instances of that class to represent different animals at the
    zoo. Each of these instances will have different values for their properties.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about classes, visit [https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to work with classes. You’ll learn how to declare and define
    classes, create instances based on the class declaration, and manipulate those
    instances. You’ll start by creating a class to represent animals in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s declare and define a class that can store details about animals. Add
    the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just declared a very simple class named `Animal`. Convention dictates
    that class names start with a capital letter. This class has properties to store
    the name of the animal, the sound it makes, the number of legs it has, and whether
    it breathes oxygen or not. This class also has a method, `makeSound()`, that prints
    the noise it makes to the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an `Animal` class, let’s use it to create an instance that
    represents an animal in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making an instance of the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have declared and defined a class, you can create instances of that
    class. You will now create an instance of the `Animal` class that represents a
    cat. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of the `Animal` class, list all its properties and call
    its `makeSound()` method; type the following code after your class declaration
    and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can access instance properties and methods by typing a dot after the instance
    name, followed by the property or method you want. You’ll see the values for the
    instance properties and method calls listed in the Debug area. Since the values
    are the default values assigned when the class was created, `name` and `sound`
    contain empty strings, `numberOfLegs` contains `0`, `breathesOxygen` contains
    `true`, and the `makeSound()` method prints an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assign some values to this instance’s properties. Modify your code as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run the program, the following is displayed in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The values for all the instance properties and the result of the `makeSound()`
    method are printed to the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Note that here, you create the instance first, and then assign values to that
    instance. It is also possible to assign the values when the instance is being
    created, and you can do this by implementing an **initializer** in your class
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An initializer is responsible for ensuring all the instance properties have
    valid values when a class is created. Let’s add an initializer for the `Animal`
    class. Modify your class definition as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the initializer uses the `init` keyword and has a list of parameters
    that will be used to set the property values. Note that the `self` keyword distinguishes
    the property names from the parameters. For example, `self.name` refers to the
    property and `name` refers to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the initialization process, every property in the class should
    have a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see some errors in your code at this point as the function call does
    not have any parameters. You will need to update your function call to address
    this. Modify your code as shown and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The results are the same as those in *Step 2*, but you created the instance
    and set its properties in a single instruction. Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Now there are different types of animals, such as mammals, birds, reptiles,
    and fish. You could create a class for each type, but you could also create a
    **subclass** based on an existing class. Let’s see how to do that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Making a subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subclass of a class inherits all the methods and properties of an existing
    class. You can also add additional properties and methods to it if you wish. For
    instance, for an IT company, you could have `CustomerSupportAgent` as a subclass
    of `Employee`. This class would have all the properties of the `Employee` class,
    as well as additional properties required for the customer support role.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll now create `Mammal`, a subclass of the `Animal` class. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the `Mammal` class, type in the following code after the `Animal`
    class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typing `: Animal` after the class name makes the `Mammal` class a subclass
    of the `Animal` class. It has all the properties and methods declared in the `Animal`
    class, and one additional property: `hasFurOrHair`. Since the `Animal` class is
    the parent of the `Mammal` class, you can refer to it as the superclass of the
    `Mammal` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code that creates an instance of your class, as shown, and run
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`cat` is now an instance of the `Mammal` class instead of the `Animal` class.
    As you can see, the results displayed in the Debug area are the same as before,
    and there are no errors. The value for `hasFurOrHair` has not been displayed,
    though. Let’s fix that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following code after all the other code in your playground to display
    the contents of the `hasFurOrHair` property and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the initializer for the `Animal` class does not have a parameter to assign
    a value to `hasFurOrHair`, the default value is used, and `true` will be displayed
    in the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen that a subclass can have additional properties. A subclass can
    also have additional methods, and method implementation in a subclass can differ
    from the superclass implementation. Let’s see how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding a superclass method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, you’ve been using multiple `print()` statements to display the values
    of the class instance. You’ll implement a `description()` method to display all
    the instance properties in the Debug area, so multiple `print()` statements will
    no longer be required. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `Animal` class declaration to implement a `description()` method,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your code as shown to use the `description()` method in place of the
    multiple `print()` statements, and run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even though the `description()` method is not implemented in
    the `Mammal` class, it is implemented in the `Animal` class. This means it will
    be inherited by the `Mammal` class, and the instance properties will be printed
    to the Debug area. Note that the value for the `hasFurOrHair` property is missing,
    and you can’t put it in the `description()` method because the `hasFurOrHair`
    property does not exist for the `Animal` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the implementation of the `description()` method in the `Mammal`
    class to display the `hasFurOrHair` property’s value. Add the following code to
    your `Mammal` class definition and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `override` keyword is used here to specify that the `description()` method
    implemented is to be used in place of the superclass implementation. The `super`
    keyword is used to call the superclass implementation of `description()`. The
    value in `hasFurOrHair` is then added to the string returned by `super.description()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `hasFurOrHair` property’s value is displayed in the Debug area, showing
    that you are using the `Mammal` subclass implementation of the `description()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve created class and subclass declarations and made instances of both. You’ve
    also added initializers and methods to both. Cool! Let’s look at how to declare
    and use structures in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like classes, structures also group together properties and methods used to
    represent an object and do specific tasks. Remember the `Animal` class you created?
    You can also use a structure to accomplish the same thing. There are differences
    between classes and structures though, and you will learn more about those later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what a structure declaration and definition look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a structure is very similar to a class. It also has a descriptive
    name and can contain properties and methods. You can also create instances of
    a structure.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about structures, visit [https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to work with structures. You’ll learn how to declare and define
    structures, create instances based on the structure, and manipulate them. You’ll
    start by creating a structure to represent reptiles in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a structure declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the animal theme, let’s declare and define a structure that
    can store details about reptiles. Add the following code after all the other code
    in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is almost the same as the `Animal` class declaration you
    did earlier. Structure names should also start with a capital letter, and this
    structure has properties to store the name of the animal, the sound it makes,
    how many legs it has, whether it breathes oxygen, and whether it has fur or hair.
    This structure also has a method, `makeSound()`, that prints the sound it makes
    to the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Reptile` structure declaration, let’s use it to create
    an instance representing a snake in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making an instance of the structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with classes, you can create instances from a structure declaration. You
    will now create an instance of the `Reptile` structure that represents a snake,
    print out the property values of that instance, and call the `makeSound()` method.
    Type the following after all the other code in your playground and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you did not need to implement an initializer; structures automatically
    get an initializer for all their properties called the **memberwise initializer**.
    Neat! The following will be displayed in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the structure declaration is very similar to the class declaration,
    there are two differences between a class and a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures cannot inherit from another structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are **reference types**, while structures are **value types**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the difference between value types and reference types in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing value types and reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are reference types. This means when you assign a class instance to
    a variable, you are storing the memory location of the original instance in the
    variable instead of the instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: Structures are value types. This means when you assign a structure instance
    to a variable, that instance is copied, and whatever changes you make to the original
    instance do not affect the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will create an instance of a class and a structure and observe the
    differences between them. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll start by creating a variable containing a structure instance and assigning
    it to a second variable, then change the value of a property in the second variable.
    Type in the following code and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, you declared a structure, `SampleValueType`, that contains
    one property, `sampleProperty`. Next, you created an instance of that structure
    and assigned it to a variable, `a`. After that, you assigned `a` to a new variable,
    `b`. Then, you changed the `sampleProperty` value of `b` to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: When you print out the `sampleProperty` value of `a`, `10` is printed in the
    Debug area, showing that any changes made to the `sampleProperty` value of `b`
    do not affect the `sampleProperty` value of `a`. This is because when you assigned
    `a` to `b`, a copy of `a` was assigned to `b`, so they are separate instances
    that don’t affect one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll create a variable containing a class instance and assign it to
    a second variable, then change the value of a property in the second variable.
    Type in the following code and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, you declared a class, `SampleReferenceType`, that contains
    one property, `sampleProperty`. Then, you created an instance of that class and
    assigned it to a variable, `c`. After that, you assigned `c` to a new variable,
    `d`. Next, you changed the `sampleProperty` value of `d` to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: When you print out the `sampleProperty` value of `c`, `20` is printed in the
    Debug area, showing that any changes made to `c` or `d` affect the same `SampleReferenceType`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question is, which should you use, classes or structures? Let’s explore
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve seen that you can use either a class or a structure to represent a complex
    object. So, which should you use?
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use structures unless you need something that requires
    classes, such as subclasses. This helps prevent some subtle errors that may occur
    due to classes being reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! Now that you have learned about classes and structures, let’s look
    at enumerations, which allow you to group related values, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations allow you to group related values, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compass directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic light colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colors of a rainbow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand why enumerations would be ideal for this purpose, let’s consider
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you’re programming a traffic light. You can use an integer variable
    to represent different traffic light colors where `0` is red, `1` is yellow, and
    `2` is green, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a possible way to represent a traffic light, what happens when
    you assign `3` to `trafficLightColor?` This is an issue as `3` does not represent
    a valid traffic light color. So, it would be better if we could limit the possible
    values of `trafficLightColor` to the colors it can display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what an enumeration declaration and definition look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every enumeration has a descriptive name, and the body contains the associated
    values for that enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about enumerations, visit [https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to work with enumerations. You’ll learn how to create and
    manipulate them. You’ll start by creating one to represent a traffic light color
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create an enumeration to represent a traffic light. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates an enumeration named `TrafficLightColor`, which groups together
    the red, yellow, and green values. The value for the `trafficLightColor` variable
    is limited to `red`, `yellow`, and `green`; setting any other value will generate
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like classes and structures, enumerations can contain methods. Let’s add
    a method to `TrafficLightColor`. Modify your code as shown to make `TrafficLightColor`
    return a string representing the traffic light color and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `description()` method returns a string depending on the value of `trafficLightColor`.
    Since the value of `trafficLightColor` is `TrafficLightColor.red`, **red** will
    appear in the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned how to create and use enumerations to store grouped values, and
    how to add methods to them. Good job!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to declare complex objects using a class, create
    instances of a class, create a subclass, and override a class method. You also
    learned how to declare a structure, create instances of a structure, and understand
    the difference between reference and value types. Finally, you learned how to
    use enumerations to represent a specific set of values.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to use classes and structures to represent complex objects,
    and how to use enumerations to group related values together in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will study how to specify common traits in classes
    and structures using protocols, extend the capability of built-in classes using
    extensions, and handle errors in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Join us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, experts, and the author himself. Ask questions,
    provide solutions to other readers, chat with the author via Ask Me Anything sessions,
    and much more. Scan the QR code or visit the link to join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/ios-Swift](https://packt.link/ios-Swift%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2370024260177612484.png)](https://packt.link/ios-Swift%0D)'
  prefs: []
  type: TYPE_NORMAL
