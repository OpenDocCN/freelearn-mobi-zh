- en: Chapter 2. Making a Good Application Architecture in Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：在Swift中构建良好的应用架构
- en: 'Swift is a high-performance programming language, as you learned in the previous
    chapter. You also learned that writing good code is even more important than making
    it high-performance code. In this chapter, we will put the all-powerful features
    of Swift together and create an application. We will do this by covering the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种高性能编程语言，正如你在上一章所学。你还了解到，编写良好的代码甚至比编写高性能代码更重要。在本章中，我们将结合Swift的所有强大功能来创建一个应用。我们将通过以下主题来实现这一点：
- en: Writing clean code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写干净的代码
- en: Immutability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Value types and immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型和不可变性
- en: Representing the state with classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类表示状态
- en: Representing the absence of values with optionals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选表示值的缺失
- en: Functional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Generics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Making a Swift application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Swift应用
- en: The first step in creating a good application architecture is to create the
    application itself. We will be creating an iOS journal application used to make
    daily notes. We are not going to cover any iOS-specific topics, so you can use
    the same code and create OS X applications as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建良好应用架构的第一步是创建应用本身。我们将创建一个iOS日记应用，用于制作日常笔记。我们不会涵盖任何iOS特定主题，因此你可以使用相同的代码创建OS
    X应用。
- en: Go ahead! Open Xcode and create a new iOS single-view project application. Now,
    we are ready for coding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！打开Xcode并创建一个新的iOS单视图项目应用。现在，我们准备好编码了。
- en: 'First, let''s create a `Person` type, for the owner of the journal, and a journal
    entry type. We will use the `Class` type to create both `Person` and `JournalEntry`.
    Both classes are very simple—just a bunch of properties and an initializer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`Person`类型，用于日记的所有者，以及一个日记条目类型。我们将使用`Class`类型来创建`Person`和`JournalEntry`。这两个类都非常简单——只是一系列属性和一个初始化器：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the minimal setup that we need for the app. Before we move forward,
    let's make the code better.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要为应用设置的最小环境。在我们继续前进之前，让我们让代码变得更好。
- en: The differences between variables and constants
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和常量的区别
- en: Probably, the most often used feature in all programming languages is creating
    and storing a value. We create local variables in functions and declare them in
    classes and other data structures; that's why it's very important to do it properly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是所有编程语言中最常用的功能就是创建和存储值。我们在函数中创建局部变量，并在类和其他数据结构中声明它们；这就是为什么正确地做这件事非常重要。
- en: 'In Swift, there are two ways of creating and storing a value, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，有两种创建和存储值的方式，如下所示：
- en: 'Making it a variable:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其改为变量：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Making it a constant:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其改为常量：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The difference between variables and constants is that a constant value can
    be assigned only once and can''t be changed after that. A variable value, on the
    other hand, can be changed anytime. Here''s an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和常量的区别在于，常量值只能分配一次，并且之后不能更改。另一方面，变量值可以随时更改。以下是一个例子：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The golden rule is to always declare your type as a constant (the `let` keyword
    in the previous example) first. Change it to a variable (the `var` keyword) only
    if you need it afterwards.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 金规则是始终首先将你的类型声明为常量（如前例中的`let`关键字）。只有在你之后需要它时，才将其改为变量（`var`关键字）。
- en: There are some exceptions when you can't declare it as a constant, for example,
    when making `@IBOutles` or `weak`. Also, optional values must be declared as variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例外情况，你不能将其声明为常量，例如，在创建`@IBOutles`或`weak`时。另外，可选值必须声明为变量。
- en: 'Using constants has many benefits over using variables. A constant is an immutable
    type, and we will cover all the benefits of immutability later. The two most important
    benefits are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量比使用变量有许多好处。常量是一种不可变类型，我们将在后面讨论所有不可变性的好处。最重要的两个好处如下：
- en: Safety (protection from unexpected value changes)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性（防止意外值变化）
- en: Better performance
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的性能
- en: 'You should use constants both when declaring properties and as local constants
    in functions. We should apply this rule and change our `Person` and `JournalEntry`
    classes as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在声明属性时以及作为函数中的局部常量时使用常量。我们应该应用这条规则，并按照以下方式更改我们的`Person`和`JournalEntry`类：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Usually, you will find yourself using constants more often than variables.
    Let''s look at an example where you could think about using a variable but, in
    fact, a constant would be a better solution. Let''s say you have created a new
    person in the application and now you want to display a full name with a gender
    prefix:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现自己在变量上使用得比常量多。让我们看看一个你可能认为需要使用变量，但实际上常量会是更好的解决方案的例子。假设你在应用程序中创建了一个新的人，现在你想显示带有性别前缀的全名：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you think a bit more about the problem, you will realize that `fullName`
    of the person should be immutable; it''s not going to change, and it should be
    declared as a constant:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再深入思考一下这个问题，你就会意识到人的`fullName`应该是不可变的；它不会改变，应该声明为常量：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Immutability
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'In the previous section, you learned how important it is to use immutable constants.
    There are more immutable types in Swift, and you should take advantage of them
    and use them. The advantages of immutability are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了使用不可变常量的重要性。Swift 中有更多不可变类型，你应该利用它们并使用它们。不可变性的优势如下：
- en: It removes a bunch of issues related to unintentional value changes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了与意外值更改相关的大量问题
- en: It is a safe multithreading access
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是安全的线程访问
- en: It makes reasoning about code easier
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使代码推理更容易
- en: There is an improvement in performance
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能有所提升
- en: 'By making types immutable, you add an extra level of security. You deny access
    to mutating an instance. In our journal app, it''s not possible to change a person''s
    name after an instance has been created. If, by accident, someone decides to assign
    a new value to the person''s `firstName`, the compiler will show an error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使类型不可变，你增加了额外的安全级别。你拒绝了对实例进行修改的访问。在我们的日记应用中，一旦创建了实例，就无法更改一个人的名字。如果有人意外地决定将新值分配给人的`firstName`，编译器将显示错误：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, there are situations when we need to update a variable. An example
    could be an array; suppose you need to add a new item to it. In our example, maybe
    the person wants to change a nickname in the app. There are two ways to do this,
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下我们需要更新变量。一个例子可以是数组；假设你需要向其中添加一个新项目。在我们的例子中，也许这个人想在应用中更改昵称。有两种方法可以实现这一点，如下所示：
- en: Mutating an existing instance
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改现有实例
- en: Creating a new instance with updated information
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更新信息创建新实例
- en: Mutating an instance in place could lead to a dangerous, unpredictable effect,
    especially when you are mutating a reference instance type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地修改实例可能导致危险且不可预测的效果，尤其是在你正在修改引用实例类型时。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Classes are reference types. "Reference type" means that many variables and
    constants can refer to the same instance data. Changes done to the instance data
    reflect in all variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类是引用类型。“引用类型”意味着许多变量和常量可以引用相同的实例数据。对实例数据的更改会反映在所有变量中。
- en: 'Creating a new instance is a much safer operation. It doesn''t have any impact
    on the existing instances in the system. After we have created a new instance,
    it may be necessary to notify other parts of the system about this change. This
    is a safer way of updating instance data. Let''s look at how we can implement
    a nickname change in our `Person` class. First, let''s add a nickname to the `Person`
    class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新实例是一个更安全的操作。它不会对系统中的现有实例产生影响。在我们创建了新实例之后，可能需要通知系统中的其他部分关于这一变化。这是一种更安全的更新实例数据的方式。让我们看看我们如何在`Person`类中实现昵称更改。首先，让我们向`Person`类添加一个昵称：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because we made a `sam` instance a constant, we can''t assign a new value to
    it after changing `nickName`. In this example, it would be better to make it a
    variable because we actually need to update it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将`sam`实例变成了常量，所以在更改`nickName`之后，我们无法为其分配新值。在这个例子中，最好将其改为变量，因为我们实际上需要更新它：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Multithreading
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: We get more and more core processors nowadays, and working with multithreading
    is a part of our life. We have GCD and NSOperation for performing work on multiple
    threads.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们越来越多地使用核心处理器，与多线程工作已成为我们生活的一部分。我们有 GCD 和 NSOperation 来在多个线程上执行工作。
- en: 'The main issue with multithreading is synchronizing read-and-write access to
    data without corrupting that data. As an example, let''s create an array of journal
    entries and try to modify it in the background and main thread. This will lead
    to an application crash:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程的主要问题是同步对数据的读写访问，而不会破坏数据。作为一个例子，让我们创建一个日记条目的数组，并尝试在后台和主线程中修改它。这将导致应用程序崩溃：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These kinds of issues are really hard to find and debug. If you remove the `sleep(1)`
    delay, the crash might not occur on some devices, depending on which thread is
    run first.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'When you make your data immutable, it becomes read-only and all threads can
    read it simultaneously without any problems:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But we often need to make changes to the data. Instead of making changes directly
    to the source data, a better solution is to create new, updated data and pass
    the result to the caller thread. In this way, multiple threads can safely continue
    performing a read operation. We will take a look at multithreading data synchronization
    in [Chapter 6](part0057_split_000.html#1MBG21-f05765b7b5914043830034430c83d0a0
    "Chapter 6. Architecting Applications for High Performance"), *Architecting Applications
    for High Performance*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Value types and immutability
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different data types in Swift:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value types
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at these.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is a reference type. When you create an instance of a reference type
    and assign it to a variable or constant, you are not only assigning a value but
    also a reference that points to the value, which is located somewhere else (actually
    it is located in the heap memory). When you pass that reference to other functions
    and assign it to other variables, you are creating multiple references that point
    to the same data. If one of those variables changes the data, that change will
    reflect in all other variables as well. Here''s an example that shows this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following diagram shows what the memory for this code would look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Reference types](img/00004.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'All four constants would refer to the same object. The danger in this architecture
    is that if one of those constants updates a piece of instance data, every other
    constant would get updated as well. Here''s an example that shows this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sometimes, this can be desirable behavior, for example, when many variables
    are referencing the same window object. There should be only one window object,
    and changes made in one place should be reflected in others as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A structure, on the other hand, is a value type. When you create an instance
    of a value type and assign it to a variable, you are assigning actual data. When
    you pass that instance to other functions and variables, you are passing a copy
    of that value. The copy is made automatically. You may think that copying values
    would have a negative impact on performance, but in reality, value types give
    higher performance than reference types. Value types are smart enough to optimize
    data copying only when it's required (when data is being modified).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make our `Person` type a `Structure` type, the same code example would
    look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The memory for this structure''s constants would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Value types](img/00005.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: The advantage of this architecture is that your code components are isolated
    and not dependent on each other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'One big difference between reference types and value types is explained as
    follows: when you create a constant as a reference type, you are making a constant
    reference (which means that you can''t change it to point to another instance).
    But you can change the data in the instance itself, as we did in the example by
    updating the `firstName` of the person.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型和值类型之间的一大区别如下所述：当你将一个常量作为引用类型创建时，你创建了一个常量引用（这意味着你不能将其更改为指向另一个实例）。但你可以更改实例本身中的数据，就像我们在示例中通过更新人的`firstName`所做的那样。
- en: When you make a constant of a value type, you get a constant value that can't
    be changed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个值类型的常量时，你得到一个不能更改的常量值。
- en: The power of structures
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体的力量
- en: If you look more closely at the Swift standard library type definition, you
    will discover that most of the types are implemented as a structure, such as `struct`
    `Int`, `struct String`, `struct Array`, and others.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更仔细地查看Swift标准库类型定义，你会发现大多数类型都是作为结构体实现的，例如`struct Int`、`struct String`、`struct
    Array`以及其他。
- en: 'The structure is not only a simple and fast data structure, but also a very
    powerful one. Structures can have methods, properties, and initializers, and they
    can conform to protocols. When you''re designing your entities in the application,
    try to use structures for your data model, and structures are preferred in general.
    Now we will apply this advice and change our types to use a structure instead
    of a class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体不仅是一个简单快速的数据结构，而且是一个非常强大的结构体。结构体可以有方法、属性和初始化器，并且可以遵循协议。当你设计应用程序中的实体时，尽量使用结构体作为你的数据模型，通常结构体是首选。现在我们将应用这个建议，并将我们的类型更改为使用结构体而不是类：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first difference is that we changed the `class` keyword to `struct`. The
    second one is more interesting—we removed the `init` method. If you don''t define
    an initializer, a structure provides a default member-wise initializer. A member-wise
    initializer takes all the properties of the structure. If you need an extra initializer
    in addition to a default member-wise one, you can create it in an extension. In
    this way, you would have two initializers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是我们将`class`关键字更改为`struct`。第二个区别更有趣——我们移除了`init`方法。如果你没有定义初始化器，结构体会提供一个默认的成员变量初始化器。成员变量初始化器会取结构体的所有属性。如果你需要除了默认的成员变量初始化器之外的额外初始化器，你可以在扩展中创建它。这样，你将有两个初始化器：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Representing the state with classes
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类表示状态
- en: 'When designing a data model in the application, use value types. The value
    types should be:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序中的数据模型时，使用值类型。值类型应该是：
- en: Inert
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性
- en: Isolated
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: Interchangeable
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可交换
- en: The value type shouldn't behave and it shouldn't have side effects. The operation
    on the data should go to the value layer. You can learn more about designing data
    models with value types in the presentation *Controlling Complexity in Swift*
    by Andy Matuschak at [https://realm.io/news/andy-matuschak-controlling-complexity/](https://realm.io/news/andy-matuschak-controlling-complexity/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型不应该有行为，也不应该有副作用。数据上的操作应该进入值层。你可以在Andy Matuschak的演讲*Controlling Complexity
    in Swift*中了解更多关于使用值类型设计数据模型的信息，演讲链接为[https://realm.io/news/andy-matuschak-controlling-complexity/](https://realm.io/news/andy-matuschak-controlling-complexity/)。
- en: 'Classes, on the other hand, can have a behavior and a state. An action of creating
    a new `JournalEntry` is a behavior, for example, and it should implemented in
    the class type. The current user''s `JournalEntry` list is a state, and this should
    also be stored in the class type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，类可以有行为和状态。创建一个新的`JournalEntry`的动作是一个行为，例如，它应该在类类型中实现。当前用户的`JournalEntry`列表是一个状态，这也应该存储在类类型中：
- en: 'First, what we do is create a `Journal` data model as a value type. It contains
    data and operations to work with that data (it has the `addEntry` method, which
    creates and adds new entries to the journal):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`Journal`数据模型作为值类型。它包含数据和操作来处理这些数据（它有`addEntry`方法，该方法创建并添加新条目到日记中）：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to create a controller entity as a reference type that will
    hold the current journal state in the application and handle the action of adding
    a new entry:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个作为引用类型的控制器实体，它将在应用程序中保存当前的日记状态并处理添加新条目的动作：
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Representing the absence of values with optionals
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可选值表示值的缺失
- en: 'Let''s go back to the past and see how the absence of a value is represented
    in Objective-C, as an example. There isn''t a standard solution for representing
    the absence of a value for both reference and simple value types. There are two
    different ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到过去，看看Objective-C中如何表示值的缺失，作为一个例子。对于引用类型和简单值类型，没有标准的解决方案来表示值的缺失。有两种不同的方式：
- en: '`nil`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: '`0`, `-1`, `INT_MAX`, `NSNotFound`, and so on'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`、`-1`、`INT_MAX`、`NSNotFound`等等'
- en: For reference types, Objective-C uses the `nil` value to represent that a variable
    doesn't have a value. It points to nowhere.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，Objective-C使用`nil`值来表示变量没有值。它指向任何地方。
- en: For value types, there is no such value as `nil` and it is not possible to assign
    `nil` to an integer variable. To do that, Objective-C (and not only Objective-C
    but also C, Java, and many other languages) uses a few special values that are
    unlikely to be the result of a particular operation. For example, the `indexOfObject`
    method of `NSArray` would return `NSNotFound`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值类型，不存在`nil`这样的值，也无法将`nil`赋值给整型变量。为了实现这一点，Objective-C（以及不仅仅是Objective-C，还包括C、Java和许多其他语言）使用了一些不太可能由特定操作产生的特殊值。例如，`NSArray`的`indexOfObject`方法会返回`NSNotFound`。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`NSNotFound` is just a constant and its value is equal to `NSIntegerMax`, whose
    value, in turn, is `2147483647`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSNotFound`只是一个常量，其值等于`NSIntegerMax`，其值又等于`2147483647`。'
- en: 'Swift uses an optional to represent the absence of a value in a common way
    for both value and reference types. An optional is a way of annotating that the
    value could be missing. You can declare a type as optional in two ways:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Swift使用可选值以统一的方式表示值类型和引用类型中的值缺失。可选值是一种注释方式，表明值可能不存在。你可以通过两种方式将类型声明为可选：
- en: Using the optional keyword, that is, `Optional<Type>`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选关键字，即`Optional<Type>`
- en: By adding a question mark to the end of the type, that is, `Type?`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在类型末尾添加一个问号，即`Type?`
- en: Tip
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`Type?` is the preferred way to declare an optional type.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Type?`是声明可选类型的首选方式。'
- en: 'To represent a missing value, you can simply assign `nil` to an optional, as
    shown in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示缺失的值，你可以简单地给可选值赋值`nil`，如下面的示例所示：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Optional and non-optional types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选类型和非可选类型
- en: 'In Objective-C both optional and non-optional values are represented by the
    same type, for example, `NSInteger, NSSString *`. By looking at the source code
    and method definition, there is no way to say whether a method can return `nil`
    or `NSNotFound` or not:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，可选值和非可选值都由相同的类型表示，例如`NSInteger, NSString *`。通过查看源代码和方法定义，无法确定一个方法是否可以返回`nil`或`NSNotFound`：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Xcode 6.3, we have new Objective-C annotations, `nullable` and `nonnull`,
    that allow us to specify whether `nil` can be passed or not. These annotations
    were added after Swift's release to provide better Objective-C integration with
    Swift.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 6.3中，我们有了新的Objective-C注解`nullable`和`nonnull`，允许我们指定是否可以传递`nil`。这些注解是在Swift发布后添加的，以提供更好的Objective-C与Swift的集成。
- en: 'Swift is stricter about this. It has both optional and non-optional types.
    Two examples of non-optional types are `Int` and `String`. This means that you
    can''t assign `nil` to an `Int` variable or pass `nil` to a function with the
    `Int` parameter type. Optional types, on the other hand, allow you to use `nil`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Swift对此更为严格。它既有可选类型也有非可选类型。非可选类型的两个例子是`Int`和`String`。这意味着你不能将`nil`赋值给`Int`变量或传递`nil`给具有`Int`参数类型的函数。另一方面，可选类型允许你使用`nil`：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This strict rule makes the code's intention really clear. From the API, you
    see that to call an `indexOfObject` function, you need to pass a non-optional
    argument, and it could return `nil` as a result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这项严格的规定使代码的意图非常明确。从API中可以看到，要调用`indexOfObject`函数，需要传递一个非可选参数，并且它可能返回`nil`作为结果。
- en: Safe nil handling
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全的`nil`处理
- en: The other problem is in trying to access `nil` values. If you have been programming
    in C, Java, or Objective-C, you must have faced one of the `NullPointerException`
    exception or the `NSInvalidArgumentException` exception.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于尝试访问`nil`值。如果你使用过C、Java或Objective-C编程，你肯定遇到过`NullPointerException`异常或`NSInvalidArgumentException`异常。
- en: 'In general, it is unsafe to access uninitialized memory. For example, passing
    `nil` to the `initWithString` method in Objective-C would result in an `NSInvalidArgumentException`
    exception, and maybe an application crash:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，访问未初始化的内存是不安全的。例如，在Objective-C中将`nil`传递给`initWithString`方法会导致`NSInvalidArgumentException`异常，甚至可能引发应用程序崩溃：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The sad part is that Objective-C didn't check the difference between `String
    * type` and `nil`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 令人遗憾的是，Objective-C没有检查`String * type`和`nil`之间的区别。
- en: Optionals in Swift not only make it clear about the ability to use `nil`, but
    also make it very safe to work with and avoid crashes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的可选类型不仅清楚地说明了使用`nil`的能力，而且使工作非常安全，避免了崩溃。
- en: Using optionals
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可选类型
- en: 'Now that you''ve understood the background on why optionals were invented,
    let''s go ahead and use them in our application. We have our `JournalEntry` entity,
    and let''s say the user can add a location where this entry was created (this
    is an optional feature; some entries will have it and some will not). We need
    to create a new type to store the geographic location, and add a new `Optional`
    property to our `JournalEntry` entity:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了为什么可选类型被发明出来的背景，让我们继续在我们的应用程序中使用它们。我们有一个`JournalEntry`实体，假设用户可以添加一个创建此条目的位置（这是一个可选功能；一些条目会有，而一些则不会有）。我们需要创建一个新的类型来存储地理位置，并给我们的`JournalEntry`实体添加一个新的`Optional`属性：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Optional variables are assigned a `nil` value by default, and because of this,
    we don't need to make any more changes to our `init` methods (all the properties
    have been provided with a value).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可选变量默认被分配一个`nil`值，因此我们不需要对我们的`init`方法做任何更多修改（所有属性都已提供了值）。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `var: Int? = nil` is the same as `var: Int?`. Don''t assign a nil value
    if you are declaring an optional variable.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`var: Int? = nil`与`var: Int?`相同。如果你在声明可选变量，不要分配一个`nil`值。'
- en: 'This is much more interesting when you try to access an optional value. An
    optional is like a closed box with something inside. To get the value out of it,
    you have to open it first. To check whether an optional has a value inside it,
    use the `if and == nil` or `!= nil` comparison operator. To get actual data out
    of the box, you need to unwrap it using `! sign`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问一个可选值时，这会变得更有趣。可选类型就像一个封闭的盒子，里面装着东西。要从中取出值，你必须先打开它。要检查一个可选值内部是否有值，使用`if
    and == nil`或`!= nil`比较运算符。要从盒子中获取实际数据，你需要使用`! sign`来解包它：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This, however, is not the optimal way of getting a value from an optional.
    A better way is to use the optional binding operator, which checks whether the
    optional has a value, and unwraps its value at once. The syntax is `if let unwrappedValue
    = optional`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是从可选类型中获取值的最佳方式。更好的方法是使用可选绑定运算符，它会检查可选值是否存在，并一次性解包其值。语法是`if let unwrappedValue
    = optional`：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we extract the location to a local constant, and it has the `Optional<Location>`
    type. Next, we apply the optional binding operator and get a value from the options
    to a location constant. The constant name for an optional value is the same as
    the optional name (`location` in this example). This technique is called **name
    shadowing**. When you use a location as an argument for the `showLocation` function,
    you are using the unwrapped constant value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将位置提取到一个局部常量中，它具有`Optional<Location>`类型。接下来，我们应用可选绑定运算符，并将选项中的一个值获取到一个位置常量中。可选值的常量名称与可选名称相同（在这个例子中是`location`）。这种技术被称为**名称遮蔽**。当你将位置作为`showLocation`函数的参数时，你正在使用解包后的常量值。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When using the optional binding operator, use name shadowing. This makes the
    code much more readable. Here is how it would look without name shadowing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可选绑定运算符时，使用名称遮蔽。这使得代码更加易读。以下是未使用名称遮蔽的代码示例：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding different names for the optional and its unwrapped value (`maybeLocation`
    and `location` in our example) makes the code more confusing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为可选及其解包后的值（在我们的例子中是`maybeLocation`和`location`）使用不同的名称会使代码更加混乱。
- en: 'There is also another type of optionals available in Swift—implicitly unwrapped
    optionals. You declare them with `Type!`, for example, `Int!`. An implicitly unwrapped
    option is one that does not require checking of whether values exist inside an
    option, but allows you to access the data as if it were not the optional type.
    Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，还有一种可选类型可用——隐式解包可选类型。你用`Type!`来声明它们，例如`Int!`。隐式解包可选类型是一种不需要检查可选内部是否存在值的类型，但允许你像它不是可选类型一样访问数据。以下是一个例子：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using implicitly unwrapped optionals is unsafe and not recommended. There are
    very few situations where you should use them. They are mostly used to interact
    with the Objective-C API. This is because many types from Objective-C are transformed
    into Swift as implicitly unwrapped optionals.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐式解包的可选类型是不安全的，并且不建议使用。只有极少数情况下你应该使用它们。它们主要用于与 Objective-C API 交互。这是因为 Objective-C
    中的许多类型在转换为 Swift 时被转换成了隐式解包的可选类型。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid using implicitly unwrapped optionals.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用隐式解包的可选类型。
- en: Wrapping up on optionals
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对可选类型的总结
- en: 'If the idea of optionals is new to you, don''t be afraid; you will get used
    to working with them, and you will like them. Here are few small notes that you
    should remember from this topic:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于可选类型的概念感到陌生，请不要害怕；你会习惯与它们一起工作，并且你会喜欢它们。以下是一些关于这个主题你应该记住的小提示：
- en: Don't use implicitly unwrapped optionals wherever possible—almost never!
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量不要使用隐式解包的可选类型——几乎永远不要！
- en: Check whether an optional has a value before accessing it
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问可选类型之前检查它是否有值
- en: Use optional binding and shadowing of the optional variable name to access a
    value
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选绑定和可选变量名的阴影来访问值
- en: Design your API's intentions to be clear with optional and non-optional types
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计你的 API 的意图，使其对可选和非可选类型清晰可见
- en: Functional programming
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: In the functional programming paradigm, a function has a type and it is treated
    in the same way as other types, such as `Int`, `String`, and `Class`. The function
    can be assigned to a variable, passed as an argument to another function, and
    returned from a function as a result type. The main goal is to split the code
    into small, standalone functions. The perfect function has no side effects and
    operates only with arguments that were passed to it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程范式中，一个函数有一个类型，并且它被以与其他类型相同的方式处理，例如 `Int`、`String` 和 `Class`。函数可以被分配给变量，作为另一个函数的参数传递，也可以作为结果类型从函数中返回。主要目标是把代码拆分成小的、独立的函数。完美的函数没有副作用，并且只操作传递给它的参数。
- en: In the functional programming style, you describe *what you want to do* and
    not *how you want to do it*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程风格中，你描述的是*你想做什么*，而不是*你想怎么做*。
- en: Functional programming is great for data transformation and data manipulation.
    This is because you are able to split code into smaller parts. You can often reuse
    some routine boilerplate code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程非常适合数据转换和数据操作。这是因为你可以将代码拆分成更小的部分。你经常可以重用一些常规的样板代码。
- en: Function types
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'Every function has a type. The type of a function consists of its parameter
    type and return type. Now, we will create a few functions with different types
    and perform some operations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个类型。函数的类型由其参数类型和返回类型组成。现在，我们将创建一些具有不同类型的函数并执行一些操作：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `hello` function has the `() -> ()` type. It takes nothing and returns
    nothing. The `add` and `subtract` functions have a different type: `(Int, Int)
    -> Int`. In the preceding example code, we assigned functions to the `hi` and
    `mathOperation` local variables.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 函数具有 `() -> ()` 类型。它不接受任何参数也不返回任何内容。`add` 和 `subtract` 函数有不同的类型：`(Int,
    Int) -> Int`。在前面的示例代码中，我们将函数分配给了 `hi` 和 `mathOperation` 本地变量。'
- en: It is not possible to assign the `hello` function to the `mathOperation` variable
    because they have different types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 无法将 `hello` 函数分配给 `mathOperation` 变量，因为它们的类型不同。
- en: Splitting the code
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分代码
- en: 'Because we can pass one function to another, we can split the code into the
    actual logic and the routine work. Let''s implement a very common operation. The
    task is to double every element in the array. In imperative programming, this
    task would translate into iterating over every element in the array, doubling
    every element, and saving the result in a new array. In the end, the result array
    is returned with all its elements doubled:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以将一个函数传递给另一个函数，所以我们可以将代码拆分成实际的逻辑和常规工作。让我们实现一个非常常见的操作。任务是数组中每个元素的加倍。在命令式编程中，这个任务将转化为遍历数组中的每个元素，加倍每个元素，并将结果保存到一个新数组中。最后，返回一个所有元素都加倍的结果数组：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The problem with this code is that there is only one line that actually does
    the work, that is, `element * 2`. It can''t be reused because this logic is hardcoded
    into the function body. What if we want to triple numbers or do some other transformation?
    Here is how this task is implemented in the functional way:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，只有一行实际执行了工作，那就是 `element * 2`。它不能被重用，因为这种逻辑被硬编码在函数体中。如果我们想将数字乘以三或进行其他转换怎么办？以下是这个任务以函数式方式实现的示例：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The only difference here is that the `transform` function takes a transformation
    function as an argument. The transformation function does all the routine work,
    iterating over an array, but it leaves the actual transformation logic to be performed
    by the function that you passed as an argument. In this way, you can pass different
    functions to the `transform` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是 `transform` 函数接受一个转换函数作为参数。转换函数执行所有常规工作，遍历数组，但它将实际转换逻辑留给作为参数传递的函数执行。这样，你可以向
    `transform` 函数传递不同的函数：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The closure expression
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包表达式
- en: A closure expression is an inline, unnamed, and self-contained block of code.
    You can think of a closure expression as a function without a name; it also takes
    parameters and has a body and a return type. You can use a closure instead of
    a function if they have the same type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包表达式是一个内联、无名称且自包含的代码块。你可以将闭包表达式视为一个没有名称的函数；它也接受参数，有主体和返回类型。如果你可以使用闭包，那么你可以用闭包代替函数。
- en: 'The general syntax for a closure expression is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包表达式的通用语法如下：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s refactor our `transform` function to use a closure instead. Here is
    the result:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的 `transform` 函数以使用闭包。以下是结果：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because closure expressions are designed to be used inline, they have many
    syntax optimizations for making them clean and clear. Here are some examples of
    these optimizations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包表达式旨在内联使用，它们有许多语法优化，使它们简洁明了。以下是一些这些优化的例子：
- en: Type inference
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断
- en: Implicit return type
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式返回类型
- en: Shorthand argument name
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简写参数名
- en: Trailing closure syntax
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾随闭包语法
- en: Type inference
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Thanks to type inference, you don''t need to specify the parameter type and
    return type, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了类型推断，你不需要指定参数类型和返回类型，如下所示：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a general rule, you should avoid specifying types whenever it is possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该在可能的情况下避免指定类型。
- en: Implicit return type
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式返回类型
- en: 'A closure with a single-expression body implicitly returns the result of that
    expression. The `return` keyword can be omitted in such cases:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包具有单表达式主体时，会隐式返回该表达式的结果。在这种情况下可以省略 `return` 关键字：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, we can''t omit the `return` keyword because there is more
    than one expression:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不能省略 `return` 关键字，因为有多个表达式：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Shorthand argument names
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简写参数名
- en: 'You can omit argument names from a closure expression. In such cases, Swift
    provides a default name for every argument. This name consists of the `$` sign
    and the argument index, for example, `$0`, `$1`, `$2`, and so on:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从闭包表达式中省略参数名称。在这种情况下，Swift 为每个参数提供了一个默认名称。这个名称由 `$` 符号和参数索引组成，例如，`$0`、`$1`、`$2`
    等等：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Shorthand argument names are preferred for very short closure expressions in
    which an argument is used once or twice. In other cases, give your argument a
    descriptive name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常短的闭包表达式，其中参数只使用一次或两次，简写参数名是首选。在其他情况下，给你的参数一个描述性的名称。
- en: Trailing closure syntax
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾随闭包语法
- en: 'When a function''s last argument is a closure, you can write the closure expression
    outside the function call:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数的最后一个参数是闭包时，你可以将闭包表达式写在函数调用之外：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can use all closure syntax with trailing closures:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有带有尾随闭包的闭包语法：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If a function has only one argument and it is a closure, you don''t need to
    specify empty parentheses for the function call:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数只有一个参数且它是一个闭包，你不需要在函数调用时指定空括号：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The standard library
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库
- en: 'Swift''s standard library has many functions and methods that accept other
    functions. Here are a few methods of `SequenceType` that you should know and use:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的标准库中有许多接受其他函数的函数和方法。以下是一些你应该了解并使用的 `SequenceType` 方法：
- en: '`map`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`'
- en: '`reduce`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`'
- en: '`filter`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`'
- en: '`sort`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`'
- en: The map method
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`map` 方法'
- en: 'The `map` method applies a `transform` function to every item and returns the
    new resultant collection. This process is called mapping, where the values A to
    B are mapped:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 方法将一个 `transform` 函数应用到每个元素上，并返回新的结果集合。这个过程称为映射，其中值 A 映射到 B：'
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Swift''s standard library uses the `generic` function, but in the following
    example, they have been changed to actual types to provide simpler examples. Here
    is the actual definition of the `map` function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的标准库使用泛型函数，但在以下示例中，它们已被更改为实际类型以提供更简单的示例。以下是 `map` 函数的实际定义：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `map` method does exactly the same job as our `transform` function. So,
    you should be using `map` instead:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 方法与我们的 `transform` 函数执行完全相同的任务。因此，你应该使用 `map`：'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: map for optionals
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选值的 `map` 操作
- en: 'The `Optional` type also has the `map` method, but here it works differently.
    It takes a function that maps an optional value, if it exists, to another value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类型也有 `map` 方法，但在这里它的工作方式不同。它接受一个函数，该函数将可选值映射到另一个值（如果存在）：'
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The body of this `map` method would look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `map` 方法的主体看起来会是这样：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using `map` with optionals can make your code cleaner. Consider the following
    example, which uses the `map` function and manual unwrapping optionals:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 与可选值可以使你的代码更简洁。考虑以下示例，它使用了 `map` 函数和手动解包可选值：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The reduce method
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`reduce` 方法'
- en: 'The `reduce` method takes the initial value and the `combine` function. It
    aggregates the result by calling the `combine` function for every element in the
    sequence. The `combine` function takes the returned value of a previous call of
    the `combine` function itself or an initial value of the first call and an element
    of a collection:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 方法接受初始值和 `combine` 函数。它通过为序列中的每个元素调用 `combine` 函数来聚合结果。`combine` 函数接受前一次调用
    `combine` 函数返回的值或第一次调用的初始值以及集合中的一个元素：'
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The simplest use case of a `reduce` function would be to calculate the sum
    of a few elements. Its implementation looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数最简单的用例可能是计算几个元素的求和。它的实现看起来像这样：'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can make this code cleaner by using closures, shorthand argument names,
    or operator functions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用闭包、简写参数名或操作符函数来使这段代码更简洁：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `+` operator is defined as an operator function and can be used in every
    place where a function is expected.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 操作符被定义为操作符函数，可以在需要函数的任何地方使用。'
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The filter method
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤方法
- en: 'The `filter` method filters out elements from the source collection by asking
    the `includeElement` function what elements to keep. The `includeElement` function
    is called for every element in the source collection, and returns a boolean value
    that indicates whether the element should be kept or removed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法通过询问 `includeElement` 函数哪些元素需要保留来从源集合中过滤元素。`includeElement` 函数会对源集合中的每个元素进行调用，并返回一个布尔值，表示该元素是否应该保留或删除：'
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The implementation looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来像这样：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Functional programming is a very big topic. If you are interested, you can read
    more about it in *Functional Programming in Swift* by Chris Eidhof, Florian Kugler,
    and Wouter Swierstra. You can get it from [http://www.objc.io/books/](http://www.objc.io/books/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一个非常广泛的话题。如果你感兴趣，你可以在 Chris Eidhof、Florian Kugler 和 Wouter Swierstra 的《Swift
    函数式编程》中了解更多信息。你可以从 [http://www.objc.io/books/](http://www.objc.io/books/) 获取它。
- en: Generics
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics are a way of writing generic, reusable code without specifying a type.
    You can write a `generic` function that may not be limited to one type. It's possible
    to create `generic` functions as well as `generic` types that add type restrictions.
    You have used `generic` types in this book even without noticing it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种编写通用、可重用代码的方式，而不需要指定类型。你可以编写一个可能不限于一种类型的 `generic` 函数。你可以创建 `generic` 函数以及添加类型限制的
    `generic` 类型。即使你没有注意到，你在这本书中已经使用了 `generic` 类型。
- en: The main idea behind generics is that instead of specifying a type, you use
    a generic type placeholder. Generics are a great tool for removing code duplication
    and making code reusable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型背后的主要思想是，而不是指定一个类型，你使用一个泛型类型占位符。泛型是消除代码重复和使代码可重用的强大工具。
- en: The first step is to identify the code that can be generic. The best way to
    do this is by asking, "Is this functionality limited only to this type or not?"
    If you realize that it is not, you should consider making it generic.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定可以泛化的代码。最好的方法是问，“这个功能是否仅限于这种类型？”如果你意识到它不是，你应该考虑将其泛化。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make functions generic only if you need to do so and if you are going to use
    them with different types. Making them generic could have a slightly negative
    impact on performance.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你需要这样做并且你打算用不同的类型使用它们时，才使函数泛化。使它们泛化可能会对性能产生轻微的负面影响。
- en: 'Let''s create our first simple generic function. Our `printMe` function can
    work only with integers as of now, but it will be great to make it work with all
    types:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个简单的泛型函数。我们的 `printMe` 函数目前只能处理整数，但让它能够处理所有类型会更好：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To get a generic function or type, you need to specify a generic type parameter
    in the angle brackets (`<T>`) and use that type instead of the actual type:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个泛型函数或类型，你需要在尖括号 (`<T>`) 中指定一个泛型类型参数，并使用该类型而不是实际类型：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The naming convention for type parameters is camel case. In simple cases, where
    the `generic` type doesn't have any special meaning, use the single-character
    name `T`. In complex situations, you can give descriptive names, such as `Key`
    or `Value`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数的命名约定是驼峰式。在简单情况下，当泛型类型没有特殊含义时，使用单字符名称 `T`。在复杂情况下，你可以给出描述性的名称，例如 `Key` 或
    `Value`。
- en: Generic functions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'The `transform` function that we wrote is a great candidate for a `generic`
    function. It doesn''t perform any computation that requires a specific type. The
    only thing we need to do is use a placeholder type name for the array type and
    the transform function instead of the `Int` type:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 `transform` 函数是泛型函数的绝佳候选者。它不执行任何需要特定类型的计算。我们唯一需要做的是为数组类型和转换函数使用占位符类型名称，而不是
    `Int` 类型：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can use our transform function with any type:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的转换函数与任何类型：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Type constraints
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型约束
- en: 'You can''t perform any operations with the variable of the generic type `T`
    because Swift doesn''t know anything about that type. If you try to compare two
    arguments of type `T`, Swift will show the following error: **Could not find and
    overload ''<'' that accepts the supplied arguments**:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能对泛型类型 `T` 的变量执行任何操作，因为 Swift 对该类型一无所知。如果你尝试比较两个类型为 `T` 的参数，Swift 将显示以下错误：**找不到接受提供的参数的重载
    '<'**：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The comparison operator, `<`, is defined in the comparable protocol. We need
    to specify that our generic type `T` should conform to the comparable protocol.
    With a type constraint, you can specify that a type must conform to a protocol
    or inherit from a class. To do that, you list constraints after the colon (`:`)
    in the generic name definition:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符 `<` 在可比较协议中定义。我们需要指定我们的泛型类型 `T` 应该遵守可比较协议。使用类型约束，你可以指定一个类型必须遵守一个协议或继承自一个类。要做到这一点，你需要在泛型名称定义后的冒号（`:`）后面列出约束：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now our `minElem` function can work with any type that conforms to the comparable
    protocol, such as `Int` and `String`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 `minElem` 函数可以与任何遵守可比较协议的类型一起工作，例如 `Int` 和 `String`：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The great thing about making `minElem` a generic function with the `constraint`
    protocol is that it is not limited to only working with existing types. We don't
    need to make any changes to make it work with a new type. Let's say we want to
    find the smallest `JournalEntry` entity. All that we need to do is make sure that
    it conforms to the comparable protocol.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `minElem` 制作为一个具有 `constraint` 协议的泛型函数的伟大之处在于它不仅限于仅与现有类型一起工作。我们不需要对其进行任何更改即可使其与新类型一起工作。假设我们想找到最小的
    `JournalEntry` 实体。我们唯一需要做的是确保它遵守可比较协议。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The comparable protocol requires two function operators to be implemented in
    your type: `==` and `<`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可比较协议要求在你的类型中实现两个函数运算符：`==` 和 `<`：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s say we want to find the smallest `JournalEntry` entity. All that we
    need to do is make sure that it conforms to the comparable protocol:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找到最小的 `JournalEntry` 实体。我们唯一需要做的是确保它遵守可比较协议：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Conform to a protocol in a type extension. In this way, you can split the code
    into functional sections.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型扩展中遵守协议。这样，你可以将代码分成功能部分。
- en: 'When you conform to protocols in the type declaration, the type declaration
    becomes hard to read and contains too much information:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类型声明中遵守协议时，类型声明变得难以阅读，并且包含太多信息：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can create two `JournalEntry` entities and call a `minElem` function.
    The `minElem` function will use the `<` operator function to compare two journal
    entries:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建两个 `JournalEntry` 实体并调用一个 `minElem` 函数。`minElem` 函数将使用 `<` 运算符函数来比较两个日志条目：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The generic type and collections
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型和集合
- en: 'Another great use case for generics is to make a generic type. `Array`, `Dictionary`,
    and `Set` are implemented as generic types:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型另一个很好的用途是创建泛型类型。`Array`、`Dictionary` 和 `Set` 都被实现为泛型类型：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This gives us the ability to store any type in collections and make them single-type
    collections. This means that we can''t store the wrong type in them:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将任何类型存储在集合中，并使它们成为单类型集合。这意味着我们无法将错误类型存储在其中：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can make your own your custom generic types. The rules are the same as
    for declaring a generic function; you specify a generic type in angular brackets,
    and use it everywhere as a type name. As an example, we can make our own simple
    generic stack like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建自己的自定义泛型类型。规则与声明泛型函数相同；你指定一个泛型类型在尖括号中，并在任何地方将其用作类型名称。例如，我们可以创建自己的简单泛型栈，如下所示：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Safety
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: 'Swift is designed for safety. It eliminates many issues of compile time. Here
    is a list of things that Swift handles for you:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是为了安全而设计的。它消除了许多编译时的问题。以下是一些 Swift 为你处理的事情列表：
- en: '**Type safety**: Swift is very strongly typed language. If a function has the
    `Int` parameter, you must pass `Int` as an argument when you call it. This rule
    also applies to operators. Swift doesn''t allow use of the wrong type:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：Swift 是一个非常强类型的语言。如果一个函数有`Int`参数，你必须在使用时传递`Int`作为参数。这个规则也适用于运算符。Swift
    不允许使用错误类型：'
- en: '[PRE67]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**Variables must always be initialized before use**: Accessing non-initialized
    memory is a dangerous operation. Swift handles this problem in a very nice and
    safe way. It doesn''t compile when you try to do that:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量必须在使用前初始化**：访问未初始化的内存是一种危险操作。Swift 以非常优雅和安全的方式处理这个问题。当你尝试这样做时，它不会编译：'
- en: '[PRE68]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Constant values can''t be changed after they have been set, but you can declare
    a constant without setting an initial value and set it later:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常量值在设置后不能更改，但你可以在声明常量时不设置初始值，稍后设置它：
- en: '[PRE69]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you remove the `else` case, the Swift compiler will show an error, because
    in these cases, `z` won't be initialized when `y != 2`.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你移除了`else`分支，Swift 编译器将会显示错误，因为在这些情况下，当`y != 2`时，`z`将不会被初始化。
- en: '**Safe nil handling**: As you have seen already Swift has an optional type
    for safe nil handling and absence-of-value handling.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全的`nil`处理**：正如你所看到的，Swift 有一个可选类型用于安全的`nil`处理和值不存在处理。'
- en: Dangerous operations
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 危险操作
- en: 'There are still situations where we should be careful, because we could make
    an error and cause the application to crash. Here''s a list of these situations:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些情况我们需要小心，因为我们可能会犯错并导致应用程序崩溃。以下是一些情况列表：
- en: '**Implicitly unwrapping optionals**: Unwrapping an optional (the `!` operator)
    is a potentially dangerous operation. You should do it only when you have verified
    that the optional has a value. It is, in fact, better to use optional binding.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式解包的可选值**：解包可选值（`!`运算符）是一个可能危险的操作。你应该只在确认可选值有值时进行解包。实际上，使用可选绑定会更好。'
- en: 'Using the implicitly unwrapped optional is also a very dangerous operation.
    They behave like non-optional types (which do not require unwrapping before accessing
    a value), but they cause a crash when used with the `nil` value:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用隐式解包的可选值也是一个非常危险的操作。它们的行为与非可选类型（在访问值之前不需要解包）类似，但与`nil`值一起使用时会导致崩溃：
- en: '[PRE70]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Type casting**: There are situations where you would like to store any object
    of a base class object and check later on whether that object actually has a specific
    type. You can safely check for the type of an object with the `is` keyword:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型转换**：在某些情况下，你可能希望存储基类对象的任何对象，并在稍后检查该对象是否具有特定的类型。你可以使用`is`关键字安全地检查对象的类型：'
- en: '[PRE71]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Often, you not only need to check whether the variable is of a certain type,
    but also need to cast it to the corresponding type. You can do this in two ways:
    safe and unsafe. You should always use the safe way.'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，你不仅需要检查变量是否为某种类型，还需要将其转换为相应的类型。你可以通过两种方式来完成：安全和不可安全。你应该始终使用安全的方式。
- en: 'Unsafe casting is very similar to unwrapping optionals. It tries to do casting
    without checking whether it''s possible, and this could lead to a crash:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不安全的类型转换与可选值的解包非常相似。它试图在不检查是否可行的情况下进行类型转换，这可能会导致崩溃：
- en: '[PRE72]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Safe casting is like optional binding. First, it checks whether a view is actually
    a `UIImageView` type, and then it performs casting. Finally, it saves the cast
    result in a `view` constant:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全的类型转换类似于可选绑定。首先，它会检查一个视图是否实际上是`UIImageView`类型，然后进行类型转换。最后，它将转换结果保存在一个`view`常量中：
- en: '[PRE73]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Tip
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always use safe casting!
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是使用安全的类型转换！
- en: '**Unsafe types and operations**: You will find many types and methods in Swift''s
    standard library that start with the word `Unsafe*`. Those are particularly dangerous
    operations, and you can understand this from their names. Usually, you would use
    unsafe types to work with C functions. Let''s see an example of the `count` function
    in C, which takes the pointer to `Int` as an argument:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全类型和操作**：你会在 Swift 的标准库中找到许多以单词`Unsafe*`开头的类型和方法。这些操作尤其危险，你可以从它们的名称中理解这一点。通常，你会使用不安全类型来与
    C 函数一起工作。让我们看看 C 中`count`函数的一个例子，它以`Int`的指针作为参数：'
- en: '[PRE74]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The count function in C would be available in Swift with this type:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C 中的`count`函数在 Swift 中将以这种类型可用：
- en: '[PRE75]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You don''t need to make an `UnsafeMutablePointer<32>` variable. You can pass
    an `Int32` Swift variable as an in-out parameter by reference:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不需要创建一个 `UnsafeMutablePointer<32>` 变量。你可以通过引用将一个 `Int32` Swift 变量作为 in-out
    参数传递：
- en: '[PRE76]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can also directly manipulate the pointer''s memory, but this is a very
    dangerous operation and it should be avoided:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以直接操作指针的内存，但这是一个非常危险的操作，应该避免：
- en: '[PRE77]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Tip
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid using unsafe types. The only use case is for interacting with the C function
    and core foundation.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免使用不安全的数据类型。唯一的使用场景是与 C 函数和核心库进行交互。
- en: '**Accessing arrays'' elements**: Although working with arrays is safe, it has
    an unsafe operation that you should be aware of—accessing an element beyond its
    range. As an example, let''s create an array with three elements. Swift still
    allows us to try to access an element at index 10, which will lead to a crash.
    Swift does check the array bounds and does not allow us to use or update the memory
    outside the array. This prevents memory corruption issues, but it does not prevent
    the application from crashing:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问数组元素**：尽管与数组一起工作通常是安全的，但它有一个你应该注意的不安全操作——访问超出其范围的元素。例如，让我们创建一个包含三个元素的数组。Swift
    仍然允许我们尝试访问索引为 10 的元素，这将导致崩溃。Swift 会检查数组边界，并且不允许我们在数组外部使用或更新内存。这可以防止内存损坏问题，但它并不能防止应用程序崩溃：'
- en: '[PRE78]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For safety, check bound arrays before accessing an element:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了安全起见，在访问元素之前检查边界数组：
- en: '[PRE79]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the most important and powerful features
    of Swift. Now you should be confident to use them. Also, this chapter gave you
    some advice on how to use these features and create solid applications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Swift 的一些最重要和最强大的功能。现在你应该有信心使用它们。此外，本章还为你提供了一些关于如何使用这些功能并创建稳固应用程序的建议。
- en: In the next chapter, you will learn different debugging techniques that will
    help identify slow code. As you have already learned, it's very important to identify
    what causes performance issues before doing any optimization.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习不同的调试技术，这些技术将帮助你识别缓慢的代码。正如你已经学到的，在执行任何优化之前，识别导致性能问题的原因非常重要。
