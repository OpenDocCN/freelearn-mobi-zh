- en: Chapter 2. Making a Good Application Architecture in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift is a high-performance programming language, as you learned in the previous
    chapter. You also learned that writing good code is even more important than making
    it high-performance code. In this chapter, we will put the all-powerful features
    of Swift together and create an application. We will do this by covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value types and immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing the state with classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing the absence of values with optionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a Swift application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in creating a good application architecture is to create the
    application itself. We will be creating an iOS journal application used to make
    daily notes. We are not going to cover any iOS-specific topics, so you can use
    the same code and create OS X applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead! Open Xcode and create a new iOS single-view project application. Now,
    we are ready for coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `Person` type, for the owner of the journal, and a journal
    entry type. We will use the `Class` type to create both `Person` and `JournalEntry`.
    Both classes are very simple—just a bunch of properties and an initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the minimal setup that we need for the app. Before we move forward,
    let's make the code better.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between variables and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably, the most often used feature in all programming languages is creating
    and storing a value. We create local variables in functions and declare them in
    classes and other data structures; that's why it's very important to do it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are two ways of creating and storing a value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making it a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making it a constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The difference between variables and constants is that a constant value can
    be assigned only once and can''t be changed after that. A variable value, on the
    other hand, can be changed anytime. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The golden rule is to always declare your type as a constant (the `let` keyword
    in the previous example) first. Change it to a variable (the `var` keyword) only
    if you need it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions when you can't declare it as a constant, for example,
    when making `@IBOutles` or `weak`. Also, optional values must be declared as variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using constants has many benefits over using variables. A constant is an immutable
    type, and we will cover all the benefits of immutability later. The two most important
    benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Safety (protection from unexpected value changes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use constants both when declaring properties and as local constants
    in functions. We should apply this rule and change our `Person` and `JournalEntry`
    classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you will find yourself using constants more often than variables.
    Let''s look at an example where you could think about using a variable but, in
    fact, a constant would be a better solution. Let''s say you have created a new
    person in the application and now you want to display a full name with a gender
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think a bit more about the problem, you will realize that `fullName`
    of the person should be immutable; it''s not going to change, and it should be
    declared as a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how important it is to use immutable constants.
    There are more immutable types in Swift, and you should take advantage of them
    and use them. The advantages of immutability are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It removes a bunch of issues related to unintentional value changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a safe multithreading access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes reasoning about code easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an improvement in performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By making types immutable, you add an extra level of security. You deny access
    to mutating an instance. In our journal app, it''s not possible to change a person''s
    name after an instance has been created. If, by accident, someone decides to assign
    a new value to the person''s `firstName`, the compiler will show an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are situations when we need to update a variable. An example
    could be an array; suppose you need to add a new item to it. In our example, maybe
    the person wants to change a nickname in the app. There are two ways to do this,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutating an existing instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new instance with updated information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating an instance in place could lead to a dangerous, unpredictable effect,
    especially when you are mutating a reference instance type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are reference types. "Reference type" means that many variables and
    constants can refer to the same instance data. Changes done to the instance data
    reflect in all variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new instance is a much safer operation. It doesn''t have any impact
    on the existing instances in the system. After we have created a new instance,
    it may be necessary to notify other parts of the system about this change. This
    is a safer way of updating instance data. Let''s look at how we can implement
    a nickname change in our `Person` class. First, let''s add a nickname to the `Person`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we made a `sam` instance a constant, we can''t assign a new value to
    it after changing `nickName`. In this example, it would be better to make it a
    variable because we actually need to update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Multithreading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We get more and more core processors nowadays, and working with multithreading
    is a part of our life. We have GCD and NSOperation for performing work on multiple
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main issue with multithreading is synchronizing read-and-write access to
    data without corrupting that data. As an example, let''s create an array of journal
    entries and try to modify it in the background and main thread. This will lead
    to an application crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of issues are really hard to find and debug. If you remove the `sleep(1)`
    delay, the crash might not occur on some devices, depending on which thread is
    run first.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you make your data immutable, it becomes read-only and all threads can
    read it simultaneously without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But we often need to make changes to the data. Instead of making changes directly
    to the source data, a better solution is to create new, updated data and pass
    the result to the caller thread. In this way, multiple threads can safely continue
    performing a read operation. We will take a look at multithreading data synchronization
    in [Chapter 6](part0057_split_000.html#1MBG21-f05765b7b5914043830034430c83d0a0
    "Chapter 6. Architecting Applications for High Performance"), *Architecting Applications
    for High Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: Value types and immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different data types in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at these.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is a reference type. When you create an instance of a reference type
    and assign it to a variable or constant, you are not only assigning a value but
    also a reference that points to the value, which is located somewhere else (actually
    it is located in the heap memory). When you pass that reference to other functions
    and assign it to other variables, you are creating multiple references that point
    to the same data. If one of those variables changes the data, that change will
    reflect in all other variables as well. Here''s an example that shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows what the memory for this code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reference types](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'All four constants would refer to the same object. The danger in this architecture
    is that if one of those constants updates a piece of instance data, every other
    constant would get updated as well. Here''s an example that shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, this can be desirable behavior, for example, when many variables
    are referencing the same window object. There should be only one window object,
    and changes made in one place should be reflected in others as well.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A structure, on the other hand, is a value type. When you create an instance
    of a value type and assign it to a variable, you are assigning actual data. When
    you pass that instance to other functions and variables, you are passing a copy
    of that value. The copy is made automatically. You may think that copying values
    would have a negative impact on performance, but in reality, value types give
    higher performance than reference types. Value types are smart enough to optimize
    data copying only when it's required (when data is being modified).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make our `Person` type a `Structure` type, the same code example would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory for this structure''s constants would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Value types](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of this architecture is that your code components are isolated
    and not dependent on each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big difference between reference types and value types is explained as
    follows: when you create a constant as a reference type, you are making a constant
    reference (which means that you can''t change it to point to another instance).
    But you can change the data in the instance itself, as we did in the example by
    updating the `firstName` of the person.'
  prefs: []
  type: TYPE_NORMAL
- en: When you make a constant of a value type, you get a constant value that can't
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The power of structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look more closely at the Swift standard library type definition, you
    will discover that most of the types are implemented as a structure, such as `struct`
    `Int`, `struct String`, `struct Array`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure is not only a simple and fast data structure, but also a very
    powerful one. Structures can have methods, properties, and initializers, and they
    can conform to protocols. When you''re designing your entities in the application,
    try to use structures for your data model, and structures are preferred in general.
    Now we will apply this advice and change our types to use a structure instead
    of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first difference is that we changed the `class` keyword to `struct`. The
    second one is more interesting—we removed the `init` method. If you don''t define
    an initializer, a structure provides a default member-wise initializer. A member-wise
    initializer takes all the properties of the structure. If you need an extra initializer
    in addition to a default member-wise one, you can create it in an extension. In
    this way, you would have two initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Representing the state with classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing a data model in the application, use value types. The value
    types should be:'
  prefs: []
  type: TYPE_NORMAL
- en: Inert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interchangeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value type shouldn't behave and it shouldn't have side effects. The operation
    on the data should go to the value layer. You can learn more about designing data
    models with value types in the presentation *Controlling Complexity in Swift*
    by Andy Matuschak at [https://realm.io/news/andy-matuschak-controlling-complexity/](https://realm.io/news/andy-matuschak-controlling-complexity/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes, on the other hand, can have a behavior and a state. An action of creating
    a new `JournalEntry` is a behavior, for example, and it should implemented in
    the class type. The current user''s `JournalEntry` list is a state, and this should
    also be stored in the class type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, what we do is create a `Journal` data model as a value type. It contains
    data and operations to work with that data (it has the `addEntry` method, which
    creates and adds new entries to the journal):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create a controller entity as a reference type that will
    hold the current journal state in the application and handle the action of adding
    a new entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Representing the absence of values with optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to the past and see how the absence of a value is represented
    in Objective-C, as an example. There isn''t a standard solution for representing
    the absence of a value for both reference and simple value types. There are two
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`, `-1`, `INT_MAX`, `NSNotFound`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reference types, Objective-C uses the `nil` value to represent that a variable
    doesn't have a value. It points to nowhere.
  prefs: []
  type: TYPE_NORMAL
- en: For value types, there is no such value as `nil` and it is not possible to assign
    `nil` to an integer variable. To do that, Objective-C (and not only Objective-C
    but also C, Java, and many other languages) uses a few special values that are
    unlikely to be the result of a particular operation. For example, the `indexOfObject`
    method of `NSArray` would return `NSNotFound`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NSNotFound` is just a constant and its value is equal to `NSIntegerMax`, whose
    value, in turn, is `2147483647`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift uses an optional to represent the absence of a value in a common way
    for both value and reference types. An optional is a way of annotating that the
    value could be missing. You can declare a type as optional in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the optional keyword, that is, `Optional<Type>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By adding a question mark to the end of the type, that is, `Type?`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Type?` is the preferred way to declare an optional type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To represent a missing value, you can simply assign `nil` to an optional, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Optional and non-optional types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Objective-C both optional and non-optional values are represented by the
    same type, for example, `NSInteger, NSSString *`. By looking at the source code
    and method definition, there is no way to say whether a method can return `nil`
    or `NSNotFound` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Xcode 6.3, we have new Objective-C annotations, `nullable` and `nonnull`,
    that allow us to specify whether `nil` can be passed or not. These annotations
    were added after Swift's release to provide better Objective-C integration with
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift is stricter about this. It has both optional and non-optional types.
    Two examples of non-optional types are `Int` and `String`. This means that you
    can''t assign `nil` to an `Int` variable or pass `nil` to a function with the
    `Int` parameter type. Optional types, on the other hand, allow you to use `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This strict rule makes the code's intention really clear. From the API, you
    see that to call an `indexOfObject` function, you need to pass a non-optional
    argument, and it could return `nil` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Safe nil handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other problem is in trying to access `nil` values. If you have been programming
    in C, Java, or Objective-C, you must have faced one of the `NullPointerException`
    exception or the `NSInvalidArgumentException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, it is unsafe to access uninitialized memory. For example, passing
    `nil` to the `initWithString` method in Objective-C would result in an `NSInvalidArgumentException`
    exception, and maybe an application crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The sad part is that Objective-C didn't check the difference between `String
    * type` and `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals in Swift not only make it clear about the ability to use `nil`, but
    also make it very safe to work with and avoid crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Using optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you''ve understood the background on why optionals were invented,
    let''s go ahead and use them in our application. We have our `JournalEntry` entity,
    and let''s say the user can add a location where this entry was created (this
    is an optional feature; some entries will have it and some will not). We need
    to create a new type to store the geographic location, and add a new `Optional`
    property to our `JournalEntry` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Optional variables are assigned a `nil` value by default, and because of this,
    we don't need to make any more changes to our `init` methods (all the properties
    have been provided with a value).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `var: Int? = nil` is the same as `var: Int?`. Don''t assign a nil value
    if you are declaring an optional variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much more interesting when you try to access an optional value. An
    optional is like a closed box with something inside. To get the value out of it,
    you have to open it first. To check whether an optional has a value inside it,
    use the `if and == nil` or `!= nil` comparison operator. To get actual data out
    of the box, you need to unwrap it using `! sign`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, is not the optimal way of getting a value from an optional.
    A better way is to use the optional binding operator, which checks whether the
    optional has a value, and unwraps its value at once. The syntax is `if let unwrappedValue
    = optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we extract the location to a local constant, and it has the `Optional<Location>`
    type. Next, we apply the optional binding operator and get a value from the options
    to a location constant. The constant name for an optional value is the same as
    the optional name (`location` in this example). This technique is called **name
    shadowing**. When you use a location as an argument for the `showLocation` function,
    you are using the unwrapped constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using the optional binding operator, use name shadowing. This makes the
    code much more readable. Here is how it would look without name shadowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding different names for the optional and its unwrapped value (`maybeLocation`
    and `location` in our example) makes the code more confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another type of optionals available in Swift—implicitly unwrapped
    optionals. You declare them with `Type!`, for example, `Int!`. An implicitly unwrapped
    option is one that does not require checking of whether values exist inside an
    option, but allows you to access the data as if it were not the optional type.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using implicitly unwrapped optionals is unsafe and not recommended. There are
    very few situations where you should use them. They are mostly used to interact
    with the Objective-C API. This is because many types from Objective-C are transformed
    into Swift as implicitly unwrapped optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using implicitly unwrapped optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up on optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the idea of optionals is new to you, don''t be afraid; you will get used
    to working with them, and you will like them. Here are few small notes that you
    should remember from this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use implicitly unwrapped optionals wherever possible—almost never!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether an optional has a value before accessing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use optional binding and shadowing of the optional variable name to access a
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your API's intentions to be clear with optional and non-optional types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the functional programming paradigm, a function has a type and it is treated
    in the same way as other types, such as `Int`, `String`, and `Class`. The function
    can be assigned to a variable, passed as an argument to another function, and
    returned from a function as a result type. The main goal is to split the code
    into small, standalone functions. The perfect function has no side effects and
    operates only with arguments that were passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the functional programming style, you describe *what you want to do* and
    not *how you want to do it*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is great for data transformation and data manipulation.
    This is because you are able to split code into smaller parts. You can often reuse
    some routine boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every function has a type. The type of a function consists of its parameter
    type and return type. Now, we will create a few functions with different types
    and perform some operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello` function has the `() -> ()` type. It takes nothing and returns
    nothing. The `add` and `subtract` functions have a different type: `(Int, Int)
    -> Int`. In the preceding example code, we assigned functions to the `hi` and
    `mathOperation` local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to assign the `hello` function to the `mathOperation` variable
    because they have different types.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we can pass one function to another, we can split the code into the
    actual logic and the routine work. Let''s implement a very common operation. The
    task is to double every element in the array. In imperative programming, this
    task would translate into iterating over every element in the array, doubling
    every element, and saving the result in a new array. In the end, the result array
    is returned with all its elements doubled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this code is that there is only one line that actually does
    the work, that is, `element * 2`. It can''t be reused because this logic is hardcoded
    into the function body. What if we want to triple numbers or do some other transformation?
    Here is how this task is implemented in the functional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is that the `transform` function takes a transformation
    function as an argument. The transformation function does all the routine work,
    iterating over an array, but it leaves the actual transformation logic to be performed
    by the function that you passed as an argument. In this way, you can pass different
    functions to the `transform` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The closure expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A closure expression is an inline, unnamed, and self-contained block of code.
    You can think of a closure expression as a function without a name; it also takes
    parameters and has a body and a return type. You can use a closure instead of
    a function if they have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for a closure expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s refactor our `transform` function to use a closure instead. Here is
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because closure expressions are designed to be used inline, they have many
    syntax optimizations for making them clean and clear. Here are some examples of
    these optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shorthand argument name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trailing closure syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to type inference, you don''t need to specify the parameter type and
    return type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a general rule, you should avoid specifying types whenever it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A closure with a single-expression body implicitly returns the result of that
    expression. The `return` keyword can be omitted in such cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can''t omit the `return` keyword because there is more
    than one expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Shorthand argument names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can omit argument names from a closure expression. In such cases, Swift
    provides a default name for every argument. This name consists of the `$` sign
    and the argument index, for example, `$0`, `$1`, `$2`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shorthand argument names are preferred for very short closure expressions in
    which an argument is used once or twice. In other cases, give your argument a
    descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing closure syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a function''s last argument is a closure, you can write the closure expression
    outside the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use all closure syntax with trailing closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has only one argument and it is a closure, you don''t need to
    specify empty parentheses for the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift''s standard library has many functions and methods that accept other
    functions. Here are a few methods of `SequenceType` that you should know and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `map` method applies a `transform` function to every item and returns the
    new resultant collection. This process is called mapping, where the values A to
    B are mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift''s standard library uses the `generic` function, but in the following
    example, they have been changed to actual types to provide simpler examples. Here
    is the actual definition of the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map` method does exactly the same job as our `transform` function. So,
    you should be using `map` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: map for optionals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Optional` type also has the `map` method, but here it works differently.
    It takes a function that maps an optional value, if it exists, to another value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of this `map` method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `map` with optionals can make your code cleaner. Consider the following
    example, which uses the `map` function and manual unwrapping optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The reduce method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reduce` method takes the initial value and the `combine` function. It
    aggregates the result by calling the `combine` function for every element in the
    sequence. The `combine` function takes the returned value of a previous call of
    the `combine` function itself or an initial value of the first call and an element
    of a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest use case of a `reduce` function would be to calculate the sum
    of a few elements. Its implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make this code cleaner by using closures, shorthand argument names,
    or operator functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `+` operator is defined as an operator function and can be used in every
    place where a function is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The filter method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `filter` method filters out elements from the source collection by asking
    the `includeElement` function what elements to keep. The `includeElement` function
    is called for every element in the source collection, and returns a boolean value
    that indicates whether the element should be kept or removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Functional programming is a very big topic. If you are interested, you can read
    more about it in *Functional Programming in Swift* by Chris Eidhof, Florian Kugler,
    and Wouter Swierstra. You can get it from [http://www.objc.io/books/](http://www.objc.io/books/).
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a way of writing generic, reusable code without specifying a type.
    You can write a `generic` function that may not be limited to one type. It's possible
    to create `generic` functions as well as `generic` types that add type restrictions.
    You have used `generic` types in this book even without noticing it.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind generics is that instead of specifying a type, you use
    a generic type placeholder. Generics are a great tool for removing code duplication
    and making code reusable.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to identify the code that can be generic. The best way to
    do this is by asking, "Is this functionality limited only to this type or not?"
    If you realize that it is not, you should consider making it generic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make functions generic only if you need to do so and if you are going to use
    them with different types. Making them generic could have a slightly negative
    impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first simple generic function. Our `printMe` function can
    work only with integers as of now, but it will be great to make it work with all
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a generic function or type, you need to specify a generic type parameter
    in the angle brackets (`<T>`) and use that type instead of the actual type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The naming convention for type parameters is camel case. In simple cases, where
    the `generic` type doesn't have any special meaning, use the single-character
    name `T`. In complex situations, you can give descriptive names, such as `Key`
    or `Value`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `transform` function that we wrote is a great candidate for a `generic`
    function. It doesn''t perform any computation that requires a specific type. The
    only thing we need to do is use a placeholder type name for the array type and
    the transform function instead of the `Int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use our transform function with any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Type constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can''t perform any operations with the variable of the generic type `T`
    because Swift doesn''t know anything about that type. If you try to compare two
    arguments of type `T`, Swift will show the following error: **Could not find and
    overload ''<'' that accepts the supplied arguments**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison operator, `<`, is defined in the comparable protocol. We need
    to specify that our generic type `T` should conform to the comparable protocol.
    With a type constraint, you can specify that a type must conform to a protocol
    or inherit from a class. To do that, you list constraints after the colon (`:`)
    in the generic name definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our `minElem` function can work with any type that conforms to the comparable
    protocol, such as `Int` and `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about making `minElem` a generic function with the `constraint`
    protocol is that it is not limited to only working with existing types. We don't
    need to make any changes to make it work with a new type. Let's say we want to
    find the smallest `JournalEntry` entity. All that we need to do is make sure that
    it conforms to the comparable protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The comparable protocol requires two function operators to be implemented in
    your type: `==` and `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we want to find the smallest `JournalEntry` entity. All that we
    need to do is make sure that it conforms to the comparable protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conform to a protocol in a type extension. In this way, you can split the code
    into functional sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you conform to protocols in the type declaration, the type declaration
    becomes hard to read and contains too much information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create two `JournalEntry` entities and call a `minElem` function.
    The `minElem` function will use the `<` operator function to compare two journal
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The generic type and collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another great use case for generics is to make a generic type. `Array`, `Dictionary`,
    and `Set` are implemented as generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the ability to store any type in collections and make them single-type
    collections. This means that we can''t store the wrong type in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make your own your custom generic types. The rules are the same as
    for declaring a generic function; you specify a generic type in angular brackets,
    and use it everywhere as a type name. As an example, we can make our own simple
    generic stack like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift is designed for safety. It eliminates many issues of compile time. Here
    is a list of things that Swift handles for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type safety**: Swift is very strongly typed language. If a function has the
    `Int` parameter, you must pass `Int` as an argument when you call it. This rule
    also applies to operators. Swift doesn''t allow use of the wrong type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Variables must always be initialized before use**: Accessing non-initialized
    memory is a dangerous operation. Swift handles this problem in a very nice and
    safe way. It doesn''t compile when you try to do that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constant values can''t be changed after they have been set, but you can declare
    a constant without setting an initial value and set it later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you remove the `else` case, the Swift compiler will show an error, because
    in these cases, `z` won't be initialized when `y != 2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Safe nil handling**: As you have seen already Swift has an optional type
    for safe nil handling and absence-of-value handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dangerous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are still situations where we should be careful, because we could make
    an error and cause the application to crash. Here''s a list of these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly unwrapping optionals**: Unwrapping an optional (the `!` operator)
    is a potentially dangerous operation. You should do it only when you have verified
    that the optional has a value. It is, in fact, better to use optional binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the implicitly unwrapped optional is also a very dangerous operation.
    They behave like non-optional types (which do not require unwrapping before accessing
    a value), but they cause a crash when used with the `nil` value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Type casting**: There are situations where you would like to store any object
    of a base class object and check later on whether that object actually has a specific
    type. You can safely check for the type of an object with the `is` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Often, you not only need to check whether the variable is of a certain type,
    but also need to cast it to the corresponding type. You can do this in two ways:
    safe and unsafe. You should always use the safe way.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Unsafe casting is very similar to unwrapping optionals. It tries to do casting
    without checking whether it''s possible, and this could lead to a crash:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Safe casting is like optional binding. First, it checks whether a view is actually
    a `UIImageView` type, and then it performs casting. Finally, it saves the cast
    result in a `view` constant:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Always use safe casting!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unsafe types and operations**: You will find many types and methods in Swift''s
    standard library that start with the word `Unsafe*`. Those are particularly dangerous
    operations, and you can understand this from their names. Usually, you would use
    unsafe types to work with C functions. Let''s see an example of the `count` function
    in C, which takes the pointer to `Int` as an argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The count function in C would be available in Swift with this type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You don''t need to make an `UnsafeMutablePointer<32>` variable. You can pass
    an `Int32` Swift variable as an in-out parameter by reference:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also directly manipulate the pointer''s memory, but this is a very
    dangerous operation and it should be avoided:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using unsafe types. The only use case is for interacting with the C function
    and core foundation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Accessing arrays'' elements**: Although working with arrays is safe, it has
    an unsafe operation that you should be aware of—accessing an element beyond its
    range. As an example, let''s create an array with three elements. Swift still
    allows us to try to access an element at index 10, which will lead to a crash.
    Swift does check the array bounds and does not allow us to use or update the memory
    outside the array. This prevents memory corruption issues, but it does not prevent
    the application from crashing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For safety, check bound arrays before accessing an element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the most important and powerful features
    of Swift. Now you should be confident to use them. Also, this chapter gave you
    some advice on how to use these features and create solid applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn different debugging techniques that will
    help identify slow code. As you have already learned, it's very important to identify
    what causes performance issues before doing any optimization.
  prefs: []
  type: TYPE_NORMAL
