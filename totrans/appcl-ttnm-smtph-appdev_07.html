<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Creating Animations, Transformations, and Understanding Drag-and-drop"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating Animations, Transformations, and Understanding Drag-and-drop</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating a View using the "animate" method</li><li class="listitem" style="list-style-type: disc">Animating a View using 2D matrix and 3D matrix transforms</li><li class="listitem" style="list-style-type: disc">Dragging an ImageView using touch events</li><li class="listitem" style="list-style-type: disc">Scaling an ImageView using a Slider control</li><li class="listitem" style="list-style-type: disc">Saving our Funny Face image using the toImage() method</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Introduction</h1></div></div></div><p>Almost any control or element in Titanium can have an animation or transform applied to it. This allows you to enhance your applications by adding a level of interactivity and "bling" that your apps would otherwise perhaps not have.</p><p>In this chapter, we are going to create a small application that allows the user to choose a "funny face" image, which we are going to position over the top of a photograph of ourselves. We'll use transitions and animations in order to display the funny face pictures and allow the user to adjust the size of his/her photograph and its position so that it fits neatly within the funny-face cutout section.</p><p>Finally, we'll combine both our "me" photograph and the funny face into one complete image using the Windows<code class="literal"> toImage()</code> method, letting the user e-mail the resulting image to his/her friends!<a id="id257" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"/>Note</h3><p>Complete source code for this entire chapter can be found in the<code class="literal"> Chapter 7/FunnyFaces</code> folder.</p></div></div></div>
<div class="section" title="Animating a View using the &quot;animate&quot; method"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Animating a View using the "animate" method</h1></div></div></div><p>Any Window, View, or Component in Titanium can be animated using the<code class="literal"> animate</code> method. This allows you to quickly and confidently create animated objects that can give your applications the "wow" factor. Additionally, you can use animations as a way of holding information or elements off screen until they are actually required. A good example of this would be if you had three different TableViews but only wanted one of those views visible at any one time. Using animations, you could slide those tables in and out of the screen space whenever it suited you, without the complication of creating additional Windows.<a id="id258" class="indexterm"/>
</p><p>In the following recipe, we will create the basic structure of our application by laying out a number of different components and then get down to animating four different ImageViews. These will each contain a different image to use as our "Funny Face" character.<a id="id259" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note49"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 7/Recipe 1</code> folder.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec01"/>Getting ready</h2></div></div></div><p>To prepare for this recipe, open up Titanium Studio and log in if you have not already done so. If you need to register a new account, you can do so for free directly from within the application. Once you are logged in, click on<span class="strong"><strong> New Project</strong></span>, and the details window for creating a new project will appear. Enter in<code class="literal"> FunnyFaces</code> as the name of the app, and fill in the rest of the details with your own information.<a id="id260" class="indexterm"/>
</p><p>Pay attention to the app identifier, which is written normally in reverse domain notation (that is,<span class="emphasis"><em> com.packtpub.funnyfaces)</em></span>. This identifier cannot be easily changed after the project is created and you will need to match it<span class="emphasis"><em> exactly</em></span> when creating provisioning profiles for distributing your apps later on.</p><p>The first thing to do is copy all of the required images into an<code class="literal"> images</code> folder under your project's<code class="literal"> Resources</code> folder. Then, open the<code class="literal"> app.js</code> file in your IDE and replace its contents with the following code. This code will form the basis of our FunnyFaces application layout.<a id="id261" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">// this sets the background color of the master UIView Titanium.UI.setBackgroundColor('#fff');
//
//create root window
//
var win1 = Titanium.UI.createWindow({
title:'Funny Faces',
backgroundColor:'#fff'
});
//this will determine whether we load the 4 funny face
//images or whether one is selected already
var imageSelected = false;
//the 4 image face objects, yet to be instantiated
var image1;
var image2;
var image3;
var image4;
var imageViewMe = Titanium.UI.createImageView({
image: 'images/me.png',
width: 320,
height: 480,
zIndex: 0
left: 0,
top: 0,
zIndex: 0,
visible: false
});
win1.add(imageViewMe);
var imageViewFace = Titanium.UI.createImageView({
image: 'images/choose.png',
width: 320,
height: 480,
zIndex: 1
});
imageViewFace.addEventListener('click', function(e){
if(imageSelected == false){
//transform our 4 image views onto screen so
//the user can choose one!
}
});
win1.add(imageViewFace);
//this footer will hold our save button and zoom slider objects
var footer = Titanium.UI.createView({
height: 40,
backgroundColor: '#000',
bottom: 0,
left: 0,
zIndex: 2
});
var btnSave = Titanium.UI.createButton({
title: 'Save Photo',
width: 100,
left: 10,
height: 34,
top: 3
});
footer.add(btnSave);
var zoomSlider = Titanium.UI.createSlider({
left: 125,
top: 8,
height: 30,
width: 180
});
footer.add(zoomSlider);
win1.add(footer);
//open root window
win1.open();
</pre></div><p>Build and run your application in the emulator for the first time, and you should end up with a screen that looks just similar to the following example:</p><div class="mediaobject"><img src="graphics/3968EXP_07_01.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How to do it…</h2></div></div></div><p>Now, back in the<code class="literal"> app.js</code> file, we are going to animate the four ImageViews which will each provide an option for our funny face image. Inside the declaration of the<code class="literal"> imageViewFace</code> object's event handler, type in the following code:<a id="id262" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">imageViewFace.addEventListener('click', function(e){
if(imageSelected == false){
//transform our 4 image views onto screen so
//the user can choose one!
image1 = Titanium.UI.createImageView({
backgroundImage: 'images/clown.png',
left: -160,
top: -140,
width: 160,
height: 220,
zIndex: 2
});
image1.addEventListener('click', setChosenImage);
win1.add(image1);
image2 = Titanium.UI.createImageView({
backgroundImage: 'images/policewoman.png',
left: 321,
top: -140,
width: 160,
height: 220,
zIndex: 2
});
image2.addEventListener('click', setChosenImage);
win1.add(image2);
image3 = Titanium.UI.createImageView({
backgroundImage: 'images/vampire.png',
left: -160,
bottom: -220,
width: 160,
height: 220,
zIndex: 2
});
image3.addEventListener('click', setChosenImage);
win1.add(image3);
image4 = Titanium.UI.createImageView({
backgroundImage: 'images/monk.png',
left: 321,
bottom: -220,
width: 160,
height: 220,
zIndex: 2
});
image4.addEventListener('click', setChosenImage);
win1.add(image4);
image1.animate({
left: 0,
top: 0,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN
});
image2.animate({
left: 160,
top: 0,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_OUT
});
image3.animate({
left: 0,
bottom: 20,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
image4.animate({
left: 160,
bottom: 20,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_LINEAR
});
}
});
</pre></div><p>Now launch the emulator from Titanium Studio and you should see the initial layout with our "Tap To Choose An Image" view visible. Tapping the choose ImageView should now animate our four funny face options onto the screen, as seen in the following screenshot:<a id="id263" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_07_02.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec03"/>How it works…</h2></div></div></div><p>The first block of code creates the basic layout for our application, which consists of a couple of ImageViews, a footer view holding our "save" button, and the Slider control, which we'll use later on to increase the zoom scale of our own photograph. Our second block of code is where it gets interesting. Here, we're doing a simple check that the user hasn't already selected an image using the<code class="literal"> imageSelected</code> Boolean, before getting into our animated ImageViews, named<code class="literal"> image1, image2, image3, and image4</code>.<a id="id264" class="indexterm"/>
</p><p>The concept behind the animation of these four ImageViews is pretty simple. All we're essentially doing is changing the properties of our control over a period of time, defined by us in milliseconds. Here, we are changing the<code class="literal"> top</code> and<code class="literal"> left</code> properties of all of our images over a period of half a second so that we get an effect of them sliding into place on our screen. You can further enhance these animations by adding more properties to animate, for example, if we wanted to change the opacity of image1 from 50 percent to 100 percent as it slides into place, we could change the code to look something similar to the following:<a id="id265" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">image1 = Titanium.UI.createImageView({
backgroundImage: 'images/clown.png',
left: -160,
top: -140,
width: 160,
height: 220,
zIndex: 2,
opacity: 0.5
});
image1.addEventListener('click', setChosenImage);
win1.add(image1);
image1.animate({
left: 0,
top: 0,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN,
opacity: 1.0
});
</pre></div><p>Finally, the curve property of<code class="literal"> animate()</code> allows you to adjust the easing of your animated component. Here, we used all four animation-curve constants on each of our ImageViews. They are:<a id="id266" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Titanium.UI.ANIMATION_CURVE_EASE_IN:</code> Accelerate the animation slowly<a id="id267" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Titanium.UI.ANIMATION_CURVE_EASE_OUT:</code> Decelerate the animation slowly<a id="id268" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT:</code> Accelerate and decelerate the animation slowly<a id="id269" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Titanium.UI.ANIMATION_CURVE_LINEAR:</code> Make the animation speed constant throughout the animation cycles<a id="id270" class="indexterm"/></li></ul></div></div></div>
<div class="section" title="Animating a View using 2D matrix and 3D matrix transforms"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Animating a View using 2D matrix and 3D matrix transforms</h1></div></div></div><p>You may have noticed that each of our ImageViews in the previous recipe had a<code class="literal"> click</code> event listener attached to them, calling an event handler named<code class="literal"> setChosenImage</code>. This event handler is going to handle setting our chosen "funny face" image to the<code class="literal"> imageViewFace</code> control. It will then animate all four "funny face" ImageView objects on our screen area using a number of different 2D and 3D matrix transforms.<a id="id271" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 7/Recipe 2</code> folder.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec04"/>How to do it…</h2></div></div></div><p>Replace the existing<code class="literal"> setChosenImage</code> function, which currently stands empty, with the following source code:<a id="id272" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//this function sets the chosen image and removes the 4
//funny faces from the screen
function setChosenImage(e){
imageViewFace.image = e.source.backgroundImage;
imageViewMe.visible = true;
//create the first transform
var transform1 = Titanium.UI.create2DMatrix();
transform1 = transform1.rotate(-180);
var animation1 = Titanium.UI.createAnimation({
transform: transform1,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
image1.animate(animation1);
animation1.addEventListener('complete',function(e){
//remove our image selection from win1
win1.remove(image1);
});
//create the second transform
var transform2 = Titanium.UI.create2DMatrix();
transform2 = transform2.scale(0);
var animation2 = Titanium.UI.createAnimation({
transform: transform2,
duration: 500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
image2.animate(animation2);
animation2.addEventListener('complete',function(e){
//remove our image selection from win1
win1.remove(image2);
});
//create the third transform
var transform3 = Titanium.UI.create2DMatrix();
transform3 = transform3.rotate(180);
transform3 = transform3.scale(0);
var animation3 = Titanium.UI.createAnimation({
transform: transform3,
duration: 1000,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
image3.animate(animation3);
animation3.addEventListener('complete',function(e){
//remove our image selection from win1
win1.remove(image3);
});
//create the fourth and final transform
var transform4 = Titanium.UI.create3DMatrix();
transform4 = transform4.rotate(200,0,1,1);
transform4 = transform4.scale(2);
transform4 = transform4.translate(20,50,170);
//the m34 property controls the perspective of the 3D view
transform4.m34 = 1.0/-3000; //m34 is the position at [3,4]
//in the matrix
var animation4 = Titanium.UI.createAnimation({
transform: transform4,
duration: 1500,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
image4.animate(animation4);
animation4.addEventListener('complete',function(e){
//remove our image selection from win1
win1.remove(image4);
});
//change the status of the imageSelected variable
imageSelected = true;
}
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec05"/>How it works…</h2></div></div></div><p>Again, we are creating animations for each of the four ImageViews, but this time in a slightly different way. Instead of using the built-in<code class="literal"> animate</code> method, we are creating a separate animation object for each ImageView, before calling the ImageView's<code class="literal"> animate</code> method and passing this animation object to it. This method of creating animations allows you to have finer control over them, including the use of transforms.<a id="id273" class="indexterm"/>
</p><p>Transforms have a couple of shortcuts to help you perform some of the most common animation types quickly and easily. The<code class="literal"> image1</code> and<code class="literal"> image2</code> transforms, as shown in the previous code, use the<code class="literal"> rotate</code> and<code class="literal"> scale</code> methods respectively. Scale and rotate in this case are 2D matrix transforms, meaning they only transform the object in two-dimensional space along its X-axis and Y-axis. Each of these transformation types takes a single integer parameter; for scale, it is 0-100 percent and for rotate, the number of it is 0-360 degrees.</p><p>Another advantage of using transforms for your animations is that you can easily chain them together to perform a more complex animation style. In the previous code, you can see that both a<code class="literal"> scale</code> and a<code class="literal"> rotate</code> transform are transforming the<code class="literal"> image3</code> component. When you run the application in the emulator or on your device, you should notice that both of these transform animations are applied to the<code class="literal"> image3</code> control!</p><p>Finally, the<code class="literal"> image4</code> control also has a transform animation applied to it, but this time we are using a 3D matrix transform instead of the 2D matrix transforms used for the other three ImageViews. These work the same way as regular 2D matrix transforms, except that you can also animate your control in 3D space, along the Z-axis.</p><p>It's important to note that animations have two event listeners:<code class="literal"> start</code> and<code class="literal"> complete</code>. These event handlers allow you to perform actions based on the beginning or ending of your animation's life cycle. As an example, you could chain animations together by using the<code class="literal"> complete</code> event to add a new animation or transform to an object after the previous animation has finished. In our previous example, we are using this<code class="literal"> complete</code> event to remove our ImageView from the Window once its animation has finished.<a id="id274" class="indexterm"/>
</p></div></div>
<div class="section" title="Dragging an ImageView using touch events"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Dragging an ImageView using touch events</h1></div></div></div><p>Now that we have allowed the user to select a funny face image from our four animated ImageView controls, we need to allow them to adjust the position of their own photo so it fits within the transparent hole that makes up the face portion of our funny face. We are going to do this using the touch events provided by the ImageView control.<a id="id275" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 7/Recipe 3</code> folder.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec06"/>How to do it…</h2></div></div></div><p>The simplest way to perform this task is by capturing the X and Y touch points and moving the ImageView to that location. The code for this is simple. Just add the following code after your declaration of the<code class="literal"> imageViewFace</code> control, but before you add this control to your window:<a id="id276" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">imageViewFace.addEventListener('touchmove', function(e){
imageViewMe.left = e.x;
imageViewMe.top = e.y;
});
</pre></div><p>Now, run your app in the emulator, and after selecting a funny face image, attempt to touch-and-drag your photograph around the screen. You should notice that it works but it doesn't seem quite right, does it? This is because we are moving the image based on the top corner position, instead of the center of the object. Let's change our code to instead work on the center point of the<code class="literal"> imageViewMe</code> control, by replacing the previous code with the following source code:</p><div class="informalexample"><pre class="programlisting">imageViewFace.addEventListener('touchstart', function (e) {
imageViewMe.ox = e.x - imageViewMe.center.x;
imageViewMe.oy = e.y - imageViewMe.center.y;
});
imageViewFace.addEventListener('touchmove', function(e){
imageViewMe.center = {
x:(e.x - imageViewMe.ox),
y:(e.y - imageViewMe.oy)
};
});
</pre></div><p>Run your app in the emulator again and after selecting a funny face image, attempt to touch-and-drag your photograph around the screen. This time you should notice a much smoother, more natural feeling drag-and-drop effect! Try positioning your "me" photograph into the center of one of your funny faces, and you should be able to replicate the following screenshot:<a id="id277" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_07_03.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec07"/>How it works…</h2></div></div></div><p>Here we are using two separate touch events to transform the left and top positioning properties of our<code class="literal"> imageViewMe</code> control. First, we need to find the center point. We do this in our<code class="literal"> touchstart</code> event by the<code class="literal"> center.x</code> and<code class="literal"> center.y</code> properties of our ImageView control and then assign these to a couple of custom variables we have named "ox" and "oy". Doing this within the<code class="literal"> touchstart</code> event ensures that these variables are immediately available to us when the<code class="literal"> touchmove</code> event occurs. Then, within our<code class="literal"> touchmove</code> event, instead of changing the top and left properties of<code class="literal"> imageViewMe</code>, we pass its center property to our new x and y co-ordinates based on the touch events x and y properties, minus the center point we saved as our object's ox and oy variables. This ensures that the movement of the image is nice and smooth!<a id="id278" class="indexterm"/>
</p></div></div>
<div class="section" title="Scaling an ImageView using a Slider control"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Scaling an ImageView using a Slider control</h1></div></div></div><p>We have now created a code to select an animated funny face and we have the ability to move our image around using the drag-and-drop method. We need to be able to scale our —me— photograph using a Slider control and a new transformation.<a id="id279" class="indexterm"/>
</p><p>In the following recipe, we will hook up the event listener of our Slider control and use another 2D matrix transformation, and this time change the scale of our<code class="literal"> imageViewMe</code> control based on the user input.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 7/Recipe 4</code> folder.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec08"/>How to do it…</h2></div></div></div><p>Near the bottom of your current source code, you should have instantiated a Slider control named "<code class="literal">zoomSlider</code>". We are going to replace that code with a slightly updated version, and then capture the slider's change event in order to scale our<code class="literal"> imageViewMe</code> component based on the value selected. Replace your declaration of the<code class="literal"> zoomSlider</code> component with the following code:<a id="id280" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var zoomSlider = Titanium.UI.createSlider({
left: 125,
top: 8,
height: 30,
width: 180,
minValue: 1,
maxValue: 100,
value: 50
});
//create the sliders event listener/handler
zoomSlider.addEventListener('change', function(e){
//create the scaling transform
var transform = Titanium.UI.create2DMatrix();
transform = transform.scale(zoomSlider.value);
var animation = Titanium.UI.createAnimation({
transform: transform,
duration: 100,
curve: Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT
});
imageViewMe.animate(animation);
});
//finally, add our slider to the footer view
footer.add(zoomSlider);
</pre></div><p>Try running your application in the emulator now, and after selecting a funny face image, you should be able to scale the "me" photograph using the Slider control. Try using it in conjunction with the touch-and-drag from the previous recipe to fit your face inside the funny picture hole, as seen in the following screenshot:<a id="id281" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/3968EXP_07_04.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec09"/>How it works…</h2></div></div></div><p>We are performing a very similar action to what we did in the second recipe of this chapter. Within the change event handler of our Slider control, we are applying a 2D matrix transform to the<code class="literal"> imageViewMe</code> control, using the scale method. Our slider has been given a minimum value of 0 and a maximum of 100. These values are the relative percentages that we are going to scale our image by. By using a very short duration (for example, 100 milliseconds) on our animation, we can make the movement of the slider almost instantaneously relate to the scale of the "me" photograph.<a id="id282" class="indexterm"/>
</p></div></div>
<div class="section" title="Saving our &quot;Funny Face&quot; image using the toImage() method"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Saving our "Funny Face" image using the toImage() method</h1></div></div></div><p>For the very last part of this application, we want to combine the two images together (our "me" photograph and the funny face image we have chosen) and save them to the filesystem as one complete image. To do this, we will hook up the event listener of our save button control and use another common method found on almost all views and control types;<code class="literal"> toImage</code>. Once we've combined our two images together and saved it off to the local filesystem, we'll then create a quick e-mail dialog and attach our funny face to it, allowing the user to send the complete image to his/her friends.<a id="id283" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note53"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 7/Recipe 5</code> folder.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec10"/>How to do it…</h2></div></div></div><p>Underneath the instantiation of your<code class="literal"> btnSave</code> object, add the following event listener and handler code:<a id="id284" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">btnSave.addEventListener("click", function(e){
//hide the footer
footer.visible = false;
//do a slight delay before capturing the image
//so we are certain the footer is hidden!
setTimeout(function(e){
//get the merged blob -- note on android you
//might want to use toBlob() instead of toImage()
var mergedImage = win1.toImage();
writeFile = Titanium.Filesystem.getFile(
Titanium.Filesystem.applicationDataDirectory,
'funnyface.jpg');
writeFile.write(mergedImage);
//now email our merged image file!
var emailDialog = Titanium.UI.createEmailDialog();
emailDialog.setSubject(—Check out funny face!—);
emailDialog.addAttachment(writeFile);
emailDialog.addEventListener('complete',function(e) {
//reset variables so we can do another funny face
footer.visible = true;
imageViewFace.image = 'images/choose.png';
imageSelected = false;
});
emailDialog.open();
}, 250);
});
</pre></div><p>Now, launch your application in the emulator or on your device, again going through all of the steps until you have chosen a funny face, and adjust the layout of your photograph accordingly. When done, hit the<span class="strong"><strong> save</strong></span> button and you should see an e-mail dialog appear with your combined image visible as an attachment.<a id="id285" class="indexterm"/>
</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec11"/>How it works…</h2></div></div></div><p>The<code class="literal"> toImage</code> method simply takes a combined screenshot of the element in question. In our case, we are performing the command on<code class="literal"> win1</code>, our root<code class="literal"> Window</code> object. To do this, we are simply hiding our footer control and then setting a short timeout. When elapsed, it uses<code class="literal"> toImage</code> to take a combined screenshot of both our<code class="literal"> imageViewMe</code> and<code class="literal"> imageViewFace</code> controls, which we then save to the filesystem.<a id="id286" class="indexterm"/>
</p><p>There is another method that most controls have called<code class="literal"> toBlob</code>, which works in a very similar manner to<code class="literal"> toImage</code>. Depending on what you are trying to achieve, you can generally use either one of these methods. However, at times, you will find that the Titanium API will contain bugs and only one of them may work. In particular, the<code class="literal"> toBlob</code> method works far better on Android devices than the<code class="literal"> toImage</code> method does. However, as the Titanium platform grows more stable, you can expect better performance from both of these API calls. Additionally, you would use the<code class="literal"> toBlob</code> method in order to store blob data in a local database using SQLite, though in general this approach is not normally used as it is very memory intensive. Saving blob objects to the filesystem is the recommended approach.<a id="id287" class="indexterm"/>
</p><p>The following screenshot shows our final combined image, which has been saved to the filesystem and attached to a new e-mail dialog ready to be shared among the user's friends and family!</p><div class="mediaobject"><img src="graphics/3968EXP_07_05.jpg" alt="How it works…"/></div></div></div></body></html>