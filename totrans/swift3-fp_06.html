<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Map, Filter, and Reduce</h1></div></div></div><p>In previous chapters, we briefly touched on the <code class="literal">map</code> function as an example of built-in higher-order functions. In this chapter, we will explore this topic further and get familiar with <code class="literal">map</code>, <code class="literal">flatMap</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code> functions in Swift with examples. We will also get familiar with the category theory concepts such as Monad, Functor, and Applicative Functor.</p><p>This chapter will cover the following topics with coding examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functor</li><li class="listitem" style="list-style-type: disc">Applicative Functor</li><li class="listitem" style="list-style-type: disc">Monad</li><li class="listitem" style="list-style-type: disc">Map</li><li class="listitem" style="list-style-type: disc">FlatMap and flatten</li><li class="listitem" style="list-style-type: disc">Filter</li><li class="listitem" style="list-style-type: disc">Reduce</li><li class="listitem" style="list-style-type: disc">Apply</li><li class="listitem" style="list-style-type: disc">Join</li><li class="listitem" style="list-style-type: disc">Chaining higher-order functions</li><li class="listitem" style="list-style-type: disc">Zip</li><li class="listitem" style="list-style-type: disc">Practical examples</li></ul></div><p>Collections are used everywhere in our day-to-day development, and to be able to use collections declaratively, we need means such as <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code>. Before going through these functions that are built-in into Swift, let's explore the theoretical background of these concepts.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Functor</h1></div></div></div><p>The name of Functor comes from the category theory. In the category theory, a Functor contains morphisms such as a <code class="literal">map</code> function, which transforms the Functor. We can think about a Functor as a functional design pattern.</p><p>Knowing the category theory is great but we do not have to, so simply put, a Functor is a structure that we can map over. In other words, a Functor is any type that implements the <code class="literal">map</code> function. Examples of Functors are <code class="literal">Dictionary</code>, <code class="literal">Array</code>, <code class="literal">Optional</code>, and <code class="literal">Closure</code> types. Whenever we talk about Functors, the first thing that comes to our mind is that we can call the <code class="literal">map</code> function over them and transform them.</p><p>Unlike its name, the concept is very simple. We will talk about the <code class="literal">map</code> function in more detail in the upcoming sections and explore the usage of Functors.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Applicative Functor</h1></div></div></div><p>The name of Applicative Functor also comes from the category theory and we can think of an <strong>Applicative Functor</strong> as a functional design pattern.</p><p>An Applicative Functor is a Functor equipped with a function that takes a value to an instance of a Functor containing that value. Applicative Functors provide us the ability to operate on not just values, but values in a functorial context, such as optionals, without needing to unwrap or <code class="literal">map</code> over their contents.</p><p>Let's suppose that we have an optional Functor (an optional that has the <code class="literal">map</code> function). We cannot directly apply the <code class="literal">map</code> function on optionals as we need to unwrap them first. Applicative Functors come to the rescue. They add a new function, for instance, <code class="literal">apply</code> to the Functor to make it possible to apply <code class="literal">map</code> on the Functor. Again, unlike its name, the concept is simple; we will talk about the <code class="literal">apply</code> function in an upcoming section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Monad</h1></div></div></div><p>The name of Monad comes from the category theory too and again we can think of a Monad as a functional design pattern.</p><p>A Monad is a type of Functor, a type which, along with <code class="literal">map</code>, implements the <code class="literal">flatMap</code> function. It is simple, right? We have a Functor with an extra functionality and that's the <code class="literal">flatMap</code> implementation. So, any type that we can call <code class="literal">map</code> and <code class="literal">flatMap</code> functions over are Monads. In the following sections, we will talk about <code class="literal">map</code> and <code class="literal">flatMap</code> functions.</p><p>So far, we learned that Functors are structures with <code class="literal">map</code> functions. Applicative Functors are Functors with <code class="literal">apply</code> functions and Monads are Functors with <code class="literal">flatMap</code> functions. Now, let's talk about these important functions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Map</h1></div></div></div><p>Swift has a built-in higher-order function named <code class="literal">map</code> that can be used with collection types such as arrays. The <code class="literal">map</code> function solves the problem of transforming the elements of an array using a function. The following example presents two different approaches to transform a set of numbers:</p><pre class="programlisting">let numbers = [10, 30, 91, 50, 100, 39, 74]&#13;
var formattedNumbers: [String] = []&#13;
&#13;
for number in numbers {&#13;
    let formattedNumber = "\(number)$"&#13;
    formattedNumbers.append(formattedNumber)&#13;
}&#13;
&#13;
let mappedNumbers = numbers.map { "\($0)$" }&#13;
</pre><p>The first approach to solve the problem is imperative and uses for-in loops to go through the collection and transform each element in the array. This iteration technique is known as external iteration because we specify how to iterate. It requires us to explicitly access the elements sequentially from beginning to end. Also, it is required to create a variable that is mutated repeatedly while the task is performed in the loop.</p><p>This process is error prone as we could initialize <code class="literal">formattedNumbers</code> incorrectly. Instead of the external iteration technique, we can use the internal iteration technique.</p><p>Without specifying how to iterate through the elements or declare and use any mutable variables, Swift can determine how to access all the elements to perform the task and hide the details from us. This technique is known as internal iteration.</p><p>One of the internal iteration methods is the <code class="literal">map</code> method. The <code class="literal">map</code> method elegantly simplifies our code and makes it declarative. Let's examine the second approach using the <code class="literal">map</code> function this time:</p><pre class="programlisting">let mappedNumbers = numbers.map { "\($0)$" }&#13;
</pre><p>As seen in this example, we could achieve the same result in one line of code. One of the benefits of using <code class="literal">map</code> is that we can clearly declare the transformation that we are trying to apply to the list of elements. The <code class="literal">map</code> function allows us to declare what we want to achieve rather than how it is implemented. This makes reading and reasoning about our code simpler.</p><p>The <code class="literal">map</code> function can be applied to any container type that wraps a value or multiple values inside itself. Any container that provides the <code class="literal">map</code> function becomes the Functor, as we have seen before.</p><p>We know what the benefits of the <code class="literal">map</code> function/method usage are and how it is used. Let's explore the dynamics of it and create a <code class="literal">map</code> function.</p><p>In 
<a class="link" href="ch05.html" title="Chapter 5. Generics and Associated Type Protocols">Chapter 5</a>
, <em>Generics and Associated Type Protocols</em>, we had the following example:</p><pre class="programlisting">func calculate&lt;T&gt;(a: T,&#13;
                  b: T,&#13;
              funcA: (T, T) -&gt; T,&#13;
              funcB: (T) -&gt; T) -&gt; T {&#13;
&#13;
    return funcA(funcB(a), funcB(b))&#13;
}&#13;
</pre><p>The <code class="literal">calculate</code> function could take <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">funcA</code>, and <code class="literal">funcB</code> as parameters. Let's simplify this function with only two parameters and change the return type:</p><pre class="programlisting">func calculate&lt;T, U&gt;(a: T,&#13;
                 funcA: (T) -&gt; U) -&gt; U {&#13;
&#13;
    return funcA(a)&#13;
}&#13;
</pre><p>Now, the <code class="literal">calculate</code> function takes <code class="literal">a</code> of type <code class="literal">T</code> and <code class="literal">funcA</code> that transforms <code class="literal">T</code> into <code class="literal">U</code>. The <code class="literal">calculate</code> function returns <code class="literal">U</code>. Even though this function does not work on arrays, it would be easy to add the array transformation:</p><pre class="programlisting">func calculate&lt;T, U&gt;(a: [T],&#13;
                 funcA: ([T]) -&gt; [U]) -&gt; [U] {&#13;
&#13;
    return funcA(a)&#13;
}&#13;
</pre><p>So far, we have a <code class="literal">calculate</code> function that takes an array of the generic type <code class="literal">T</code> and a function that transforms an array of <code class="literal">T</code> into an array of <code class="literal">U</code> and finally returns the transformed array of <code class="literal">U</code>.</p><p>By just changing the name of the function and parameters, we can make this even more generic. So let's change the function and parameter names:</p><pre class="programlisting">func map&lt;T, U&gt;(a: [T], transform: [T] -&gt; [U]) -&gt; [U] {&#13;
    return transform(a)&#13;
}&#13;
</pre><p>At this point, we have a half-baked <code class="literal">map</code> function that takes an array of <code class="literal">T</code> and applies the <code class="literal">transform</code> function to it to return a transformed array of <code class="literal">U</code>.</p><p>In fact, this function does nothing and mapping happens in the transform. Let's make this function usable and more understandable:</p><pre class="programlisting">func map&lt;ElementInput, ElementResult&gt;(elements: [ElementInput],&#13;
  transform: (ElementInput) -&gt; ElementResult) -&gt; [ElementResult] {&#13;
    var result: [ElementResult] = []&#13;
&#13;
    for element in elements {&#13;
        result.append(transform(element))&#13;
    }&#13;
 &#13;
    return result&#13;
}&#13;
</pre><p>Now, our <code class="literal">map</code> function takes an array of elements (domain in the category theory), iterates through each element in array, transforms it, and appends it to a new array (codomain in the category theory).</p><p>The result will be another array of the <code class="literal">ElementResult</code> type, which has in fact transformed elements of the input array. Let's test this function:</p><pre class="programlisting">let numbers = [10, 30, 91, 50, 100, 39, 74]&#13;
&#13;
let result = map(elements: numbers, transform: { $0 + 2 })&#13;
</pre><p>The result will be <code class="literal">[12, 32, 93, 52, 102, 41, 76]</code>.</p><p>This example shows us that with higher-order functions and generics, we are able to define functions such as <code class="literal">map</code> that are already a part of the Swift language.</p><p>Now, let's examine the <code class="literal">map</code> function provided in Swift:</p><pre class="programlisting">public func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) -&gt; T) -&gt;&#13;
  [T]</pre><p>This definition is very similar to our implementation with some differences that we will cover here.</p><p>First of all, this is a method that can be called on collections such as an array, so we do not need any input type such as <code class="literal">[ElementInput]</code>.</p><p>Secondly, <code class="literal">@noescape</code> is an attribute in Swift that is used to communicate to the function user that the argument will not live longer than the call. In escape scenarios, if the function dispatches to a different thread, an argument may be captured so that it will exist at a later time when its needed. The <code class="literal">@noescape</code> attribute ensures that this will not happen for this function.</p><p>Finally, <code class="literal">transform</code> is the name of the parameter. The type of the parameter is declared as <code class="literal">(Self.Generator.Element) -&gt; T</code>. This is a closure that takes an argument of the <code class="literal">Self.Generator.Element</code> type and returns an instance of the <code class="literal">T</code> type. The <code class="literal">Self.Generator.Element</code> type is the same type of object as the type contained in the collection.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>FlatMap and flatten</h1></div></div></div><p>The <code class="literal">flatMap</code> method on arrays can be used to flatten one level of dimension of an array. The following example presents a two-dimensional array, in other words, nested arrays. Calling <code class="literal">flatMap</code> on this array reduces one dimension and flattens it so the resulting array becomes <code class="literal">[1, 3, 5, 2, 4, 6]</code>:</p><pre class="programlisting">let twoDimensionalArray = [[1, 3, 5], [2, 4, 6]]&#13;
let oneDimensionalArray = twoDimensionalArray.flatMap { $0 }&#13;
</pre><p>In this example, <code class="literal">flatMap</code> returns an <code class="literal">Array</code> containing the concatenated results of the mapping transform over itself. We can achieve the same result by calling flatten on our array and then map, as follows:</p><pre class="programlisting">let oneDimensionalArray = twoDimensionalArray.flatten().map { $0 }&#13;
</pre><p>To be able to transform each element into an array, we will need to provide a <code class="literal">map</code> method as the closure to the <code class="literal">flatMap</code> method as follows:</p><pre class="programlisting">let transofrmedOneDimensionalArray = twoDimensionalArray.flatMap { &#13;
      $0.map { $0 + 2 } &#13;
}</pre><p>The result will be <code class="literal">[3, 5, 7, 4, 6, 8]</code>.</p><p>The same result can be achieved with the following:</p><pre class="programlisting">let oneDimensionalArray = twoDimensionalArray.flatten().map { $0 + 2 }&#13;
</pre><p>Let's examine another example with an <code class="literal">Array</code> of three dimensions:</p><pre class="programlisting">let threeDimensionalArray = [[1, [3, 5]], [2, [4, 6]]]&#13;
let twoDimensionalArray = threeDimensionalArray.flatMap { $0 }&#13;
</pre><p>The resulting array will be <code class="literal">[1, [3, 5], 2, [4, 6]]</code>.</p><p>Therefore, <code class="literal">flatMap</code> and <code class="literal">flatten</code> only flatten one dimension, and to handle more dimensions and transformations, we need to call the <code class="literal">flatMap</code> and <code class="literal">map</code> methods multiple times accordingly.</p><p>We also know that <code class="literal">twoDimensionalArray</code> and <code class="literal">threeDimensionalArray</code> are Monads, as we could call <code class="literal">map</code> and <code class="literal">flatMap</code> on them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Filter</h1></div></div></div><p>The <code class="literal">filter</code> function takes a function that, given an element in <code class="literal">Array</code>, returns <code class="literal">Bool</code> indicating whether the element should be included in the resulting <code class="literal">Array</code>. The <code class="literal">filter</code> method is declared as follows in Swift:</p><pre class="programlisting">public func filter(@noescape includeElement: &#13;
  (Self.Generator.Element) -&gt; Bool) -&gt; [Self.Generator.Element]</pre><p>The definition is similar to the <code class="literal">map</code> method with the following differences:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">filter</code> function takes a closure that receives elements of itself and returns a <code class="literal">Bool</code> value</li><li class="listitem" style="list-style-type: disc">The result of the <code class="literal">filter</code> method will be an array of its own type</li></ul></div><p>Let's examine the following code to understand how it works:</p><pre class="programlisting">let numbers = [10, 30, 91, 50, 100, 39, 74]&#13;
let evenNumbers = numbers.filter { $0 % 2 == 0 }&#13;
</pre><p>The resulting <code class="literal">evenNumbers</code> array will be <code class="literal">[10, 30, 50, 100, 74]</code>.</p><p>Let's implement the <code class="literal">filter</code> function ourselves. In fact, its implementation is going to be similar to the implementation of <code class="literal">map</code>, except that it does not require a second generic specifying the codomain. Instead, it conditionally adds the original elements to the new <code class="literal">Array</code>:</p><pre class="programlisting">func filter&lt;Element&gt; (elements: [Element], &#13;
                      predicate:(Element -&gt; Bool)) -&gt; [Element] {&#13;
    var result = [Element]()&#13;
    for element in elements {&#13;
        if predicate(element) {&#13;
            result.append(element)&#13;
        }&#13;
    }&#13;
    return result&#13;
}&#13;
</pre><p>The <code class="literal">filter</code> function iterates through each element in our <code class="literal">Array</code> and applies the predicate to it. If the result of the predicate function becomes <code class="literal">true</code>, then <code class="literal">element</code> is added to our new <code class="literal">Array</code>. We can test our <code class="literal">filter</code> function as follows:</p><pre class="programlisting">let filteredArray = filter(elements: numbers) { $0 % 2 == 0 }&#13;
</pre><p>The resulting array will be <code class="literal">[10, 30, 50, 100, 74]</code>, which is identical to the Swift-provided <code class="literal">filter</code> method.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Reduce</h1></div></div></div><p>The <code class="literal">reduce</code> function reduces a list into a single value. Often referred to as <code class="literal">fold</code> or <code class="literal">aggregate</code>, it takes two parameters: a starting value and a function.</p><p>A function takes a running total and an element of the list as parameters and returns a value that is created by combining the elements in the list.</p><p>Unlike <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">flatMap</code>, which would return the same type, <code class="literal">reduce</code> changes the type. In other words, <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">flatMap</code> would take <code class="literal">Array</code> and provide a changed <code class="literal">Array</code>. This is not the case with <code class="literal">reduce</code> as it can change an array to, for instance, a tuple or single value.</p><p>Swift provides the <code class="literal">reduce</code> method on arrays and has the following definition:</p><pre class="programlisting">func reduce&lt;T&gt;(initial: T, @noescape combine: (T, &#13;
  Self.Generator.Element) -&gt; T) -&gt; T</pre><p>If we use the <code class="literal">reduce</code> method on our <code class="literal">numbers</code>
<code class="literal">Array</code>, the result of this call becomes <code class="literal">394</code>:</p><pre class="programlisting">let total = numbers.reduce(0) { $0 + $1 }&#13;
</pre><p>We could also call <code class="literal">reduce</code>, as follows, as the <code class="literal">+</code> operator is a function in Swift:</p><pre class="programlisting">let total = numbers.reduce(0, combine: +)&#13;
</pre><p>Like the <code class="literal">map</code> and <code class="literal">filter</code> methods, developing a <code class="literal">reduce</code> function is also simple:</p><pre class="programlisting">func reduce&lt;Element, Value&gt;(elements: [Element],&#13;
                            initial: Value,&#13;
                            combine: (Value, Element) -&gt; Value) -&gt;     Value {&#13;
    var result = initial&#13;
 &#13;
    for element in elements {&#13;
        result = combine(result, element)&#13;
    }&#13;
 &#13;
    return result&#13;
}&#13;
</pre><p>We can achieve the same result (<code class="literal">394</code>) with the following call:</p><pre class="programlisting">let total = reduce(elements: numbers, initial: 0) { $0 + $1 }&#13;
</pre><p>The <code class="literal"> reduce</code> method can be used with other types such as arrays of Strings.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec35"/>The map function in terms of reduce</h2></div></div></div><p>The reduction pattern is so powerful that every other function that traverses a list can be specified in terms of it. Let's develop a <code class="literal">map</code> function in terms of <code class="literal">reduce</code>:</p><pre class="programlisting">func mapIntermsOfReduce&lt;Element, ElementResult&gt;(elements: [Element],&#13;
  transform: Element -&gt; ElementResult) -&gt; [ElementResult] {&#13;
    return reduce(elements: elements, initial: [ElementResult]()) {&#13;
        $0 + [transform( $1 )]&#13;
    }&#13;
}&#13;
&#13;
let result = mapIntermsOfReduce(elements: numbers, transform: { $0 + 2 })</pre><p>The result is identical to our <code class="literal">map</code> function's result that we developed earlier in this chapter. This is a good example to understand the basics of <code class="literal">reduce</code>.</p><p>In the function body, we provide <code class="literal">elements</code> and an initial empty array of <code class="literal">ElementResult</code>, and finally, we provide a closure to combine the elements.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec36"/>The filter function in terms of reduce</h2></div></div></div><p>It is also possible to develop a <code class="literal">filter</code> function in terms of <code class="literal">reduce</code>:</p><pre class="programlisting">func filterIntermsOfReduce&lt;Element&gt;(elements: [Element],&#13;
                                    predicate: Element -&gt; Bool) -&gt; [Element] {&#13;
    return reduce(elements: elements, initial: []) {&#13;
        predicate($1) ? $0 + [ $1 ] : $0&#13;
    }&#13;
}&#13;
&#13;
let result = filterIntermsOfReduce(elements: numbers) { $0 % 2 == 0 }</pre><p>Again, the result is identical to our previously developed filter function.</p><p>In the function body, we provide elements, an empty initial array, and finally <code class="literal">predicate</code> as a combinator.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec37"/>The flatMap function in terms of reduce</h2></div></div></div><p>To understand the power of reduce, we can implement the <code class="literal">flatMap</code> function in terms of reduce as well:</p><pre class="programlisting">func flatMapIntermsOfReduce&lt;Element&gt;(elements: [Element],&#13;
  transform: (Element) -&gt; Element?) -&gt; [Element] {&#13;
    return reduce(elements: elements, initial: []) {&#13;
        guard let transformationResult = transform($1) else {&#13;
            return $0&#13;
        }&#13;
        return $0 + [transformationResult]&#13;
    }&#13;
}&#13;
&#13;
let anArrayOfNumbers = [1, 3, 5]&#13;
let oneDimensionalArray = flatMapIntermsOfReduce(elements:&#13;
  anArrayOfNumbers) { $0 + 5 }</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec38"/>The flatten function in terms of reduce</h2></div></div></div><p>Finally, let's implement the <code class="literal">flatten</code> function in terms of <code class="literal">reduce</code>:</p><pre class="programlisting">func flattenIntermsOfReduce&lt;Element&gt;(elements: [[Element]]) -&gt; [Element] {&#13;
    return elements.reduce([]) { $0 + $1 }&#13;
}&#13;
</pre><p>This function takes a two-dimensional array and converts it to a one-dimensional array. Let's test this function:</p><pre class="programlisting">let flattened = flattenIntermsOfReduce(elements: [[1, 3, 5], [2, 4, 6]])&#13;
</pre><p>The result will be <code class="literal">[1, 3, 5, 2, 4, 6]</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Apply</h1></div></div></div><p>Apply is a function that applies a function to a list of arguments.</p><p>Unfortunately, Swift does not provide any <code class="literal">apply</code> method on <code class="literal">Arrays</code>. To be able to implement Applicative Functors, we need to develop the <code class="literal">apply</code> function. The following code presents a simple version of the <code class="literal">apply</code> function with only one argument:</p><pre class="programlisting">func apply&lt;T, V&gt;(fn: [T] -&gt; V, args: [T]) -&gt; V {&#13;
    return fn(args)&#13;
}&#13;
</pre><p>The <code class="literal">apply</code> function takes a function and an array of any type and applies the function to the first element of the array. Let's test this function as the following:</p><pre class="programlisting">let numbers = [1, 3, 5]&#13;
&#13;
func incrementValues(a: [Int]) -&gt; [Int] {&#13;
    return a.map { $0 + 1 }&#13;
}&#13;
&#13;
let applied = apply(fn: incrementValues, args: numbers)</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Join</h1></div></div></div><p>The <code class="literal">join</code> function takes an array of objects and joins them with a provided separator. The following example presents a simple version of join:</p><pre class="programlisting">func join&lt;Element: Equatable&gt;(elements: [Element],&#13;
                              separator: String) -&gt; String {&#13;
    return elements.reduce("") {&#13;
        initial, element in&#13;
        let aSeparator = (element == elements.last) ? "" : separator&#13;
        return "\(initial)\(element)\(aSeparator)"&#13;
    }&#13;
}&#13;
</pre><p>This function takes an array with a separator, joins elements in <code class="literal">Array</code>, and provides a single <code class="literal">String</code>. We can test it as follows:</p><pre class="programlisting">let items = ["First", "Second", "Third"]&#13;
let commaSeparatedItems = join(elements: items, separator: ", ")&#13;
</pre><p>The result will be <code class="literal">"First, Second, Third"</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Chaining higher-order functions</h1></div></div></div><p>So far, we learned different functions with some examples for each. Let's see if we can combine them to solve problems that we may encounter in our day-to-day application development.</p><p>Let's assume that we need to receive an object from a backend system as follows:</p><pre class="programlisting">struct User {&#13;
    let name: String&#13;
    let age: Int&#13;
}&#13;
&#13;
let users = [&#13;
    User(name: "Fehiman", age: 60),&#13;
    User(name: "Negar", age: 30),&#13;
    User(name: "Milo", age: 1),&#13;
    User(name: "Tamina", age: 6),&#13;
    User(name: "Neco", age: 30)&#13;
]&#13;
</pre><p>Then we need to calculate the total of ages in the <code class="literal">users</code> array. We can use a combination of the <code class="literal">map</code> and <code class="literal">reduce</code> functions to calculate <code class="literal">totalAge</code> as follows:</p><pre class="programlisting">let totalAge = users.map { $0.age }.reduce(0) { $0 + $1 }&#13;
</pre><p>We were able to chain the map and reduce methods to achieve this.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Zip</h1></div></div></div><p>The <code class="literal">zip</code> function is provided by the Swift standard library and creates a sequence of pairs built out of two underlying sequences, where the elements of the <em>i<sup>th</sup></em> pair are the <em>i<sup>th</sup></em> elements of each underlying sequence.</p><p>For instance, in the following example, <code class="literal">zip</code> takes two <code class="literal">Arrays</code> and creates a pair of these two arrays:</p><pre class="programlisting">let alphabeticNumbers = ["Three", "Five", "Nine", "Ten"]&#13;
let zipped = zip(alphabeticNumbers, numbers).map { $0 }&#13;
</pre><p>The value for <code class="literal">zipped</code> will be <code class="literal">[("Three", 3), ("Five", 5), ("Nine", 9), ("Ten", 10)]</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Practical examples</h1></div></div></div><p>Let's explore some practical examples of higher-order functions.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Sum of an array</h2></div></div></div><p>We can use <code class="literal">reduce</code> to calculate the sum of a list of numbers as follows:</p><pre class="programlisting">let listOfNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#13;
let sumOfNumbers = reduce(elements: listOfNumbers, initial: 0, combine: +)&#13;
&#13;
print(sumOfNumbers)&#13;
</pre><p>The result will be <code class="literal">55</code>, as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Product of an array</h2></div></div></div><p>We can use <code class="literal">reduce</code> to calculate the product of array values as follows:</p><pre class="programlisting">let productOfNumbers = reduce(elements: listOfNumbers, initial: 1,&#13;
  combine: *)&#13;
&#13;
print(productOfNumbers)&#13;
</pre><p>The result will be <code class="literal">3628800</code>, as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Removing nil values from an array</h2></div></div></div><p>We can use <code class="literal">flatMap</code> to get values out of optional arrays and remove <code class="literal">nil</code> values:</p><pre class="programlisting">let optionalArray: [String?] = ["First", "Second", nil, "Fourth"]&#13;
let nonOptionalArray = optionalArray.flatMap { $0 }&#13;
&#13;
print(nonOptionalArray)&#13;
</pre><p>The result will be <code class="literal">["First", "Second", "Fourth"]</code>, as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Removing duplicates in an array</h2></div></div></div><p>We can use <code class="literal">reduce</code> to remove duplicate elements in an array as follows:</p><pre class="programlisting">let arrayWithDuplicates = [1, 1, 2, 3, 3, 4, 4, 5, 6, 7]&#13;
&#13;
arrayWithDuplicates.reduce([]) { (a: [Int], b: Int) -&gt; [Int] in&#13;
    if a.contains(b) {&#13;
        return a&#13;
    } else {&#13;
        return a + [b]&#13;
    }&#13;
}&#13;
</pre><p>The result will be <code class="literal">[1, 2, 3, 4, 5, 6, 7]</code> as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Partitioning an array</h2></div></div></div><p>We can use <code class="literal">reduce</code> to partition an array with a specific criterion. For instance, in the following example, we partition <code class="literal">numbersToPartition</code>
<code class="literal">Array</code> into two partitions, keeping all even numbers in the left partition:</p><pre class="programlisting">typealias Accumlator = (lPartition: [Int], rPartition: [Int])&#13;
&#13;
func partition(list: [Int], criteria: (Int) -&gt; Bool) -&gt; Accumlator {&#13;
    return list.reduce((lPartition: [Int](), rPartition: [Int]())) {&#13;
        (accumlator: Accumlator, pivot: Int) -&gt; Accumlator in&#13;
        if criteria(pivot) {&#13;
            return (lPartition: accumlator.lPartition + [pivot],&#13;
              rPartition: accumlator.rPartition)&#13;
        } else {&#13;
            return (rPartition: accumlator.rPartition + [pivot],&#13;
              lPartition: accumlator.lPartition)&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
let numbersToPartition = [3, 4, 5, 6, 7, 8, 9]&#13;
partition(list: numbersToPartition) { $0 % 2 == 0 }&#13;
</pre><p>We can make this function generic as the following:</p><pre class="programlisting">func genericPartition&lt;T&gt;(list: [T],&#13;
                         criteria: (T) -&gt; Bool) -&gt; (lPartition: &#13;
[T], &#13;
                         rPartition: [T]) {&#13;
    return list.reduce((lPartition: [T](), rPartition: [T]())) {&#13;
        (accumlator: (lPartition: [T], rPartition: [T]), pivot: T) -&gt; (&#13;
          lPartition: [T], rPartition: [T]) in&#13;
        if criteria(pivot) {&#13;
            return (lPartition: accumlator.lPartition + [pivot],&#13;
              rPartition: accumlator.rPartition)&#13;
        } else {&#13;
            return (rPartition: accumlator.rPartition + [pivot],&#13;
              lPartition: accumlator.lPartition)&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
let doublesToPartition = [3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]&#13;
print(genericPartition(list: doublesToPartition) { $0.truncatingRemainder(dividingBy: 2.0) == 0 })</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we started with the category theory concepts such as Functor, Applicative Functor, and Monad and explored higher-order functions such as <code class="literal">map</code>, <code class="literal">filter</code>, <code class="literal">flatMap</code>, <code class="literal">flatten</code>, and <code class="literal">reduce</code>. Then, we examined Swift-provided versions of higher-order functions and implemented a simple version ourselves. Also, we developed <code class="literal">map</code>, <code class="literal">filter</code>, <code class="literal">flatMap</code>, and <code class="literal">flatten</code> functions in terms of the <code class="literal">reduce</code> function.</p><p>Then, we continued with the <code class="literal">apply</code>, <code class="literal">join</code>, and <code class="literal">zip</code> functions and were introduced to chaining higher-order functions.</p><p>Finally, we explored some practical examples of higher-order functions such as removing <code class="literal">nil</code> values from an array, removing duplicates, and partitioning arrays.</p><p>These functions are going to be great tools in our day-to-day development toolkit to use and solve a lot of different kinds of problems.</p><p>In the following chapter, we will get familiar with optional types and discuss non-functional and functional ways to deal with them.</p></div></body></html>