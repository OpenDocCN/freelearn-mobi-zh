<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Foundation Framework – Growing Up</h1></div></div></div><p>In this chapter, we will learn about modules and how they change the way we import frameworks into our files. We will cover both, the new and the old classes of the Foundation Framework, starting with the brand new <code class="literal">NSProgress</code> class. We will see some of the major improvements to the existing classes including <code class="literal">NSArray</code> and the <code class="literal">firstObject</code> method, <code class="literal">NSTimer</code>'s new property for managing tolerance, the additional encodings now supported by <code class="literal">NSData</code>, and lastly new ways to manage URLs with <code class="literal">NSURLUtilities</code>. Let's get started!</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Why Foundation matters</h1></div></div></div><p>Foundation is the core framework of Objective-C. Without it, developing iOS applications would not be possible. Foundation defines the base layer of all classes, as well as functionality for basic data types, including strings, arrays, and dictionaries.</p><p>Changes made to the Foundation<a id="id31" class="indexterm"/> Framework can range from minor enhancements to the introduction of completely new classes. iOS 7 is no exception to this and Apple has provided some great new features that we will explore in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Modules</h1></div></div></div><p>While developing applications using Xcode and the iOS SDK, you may have noticed that it has never been a requirement <a id="id32" class="indexterm"/>to import commonly used header files, such as <code class="literal">UIViewController.h</code> or <code class="literal">UIView.h</code>.</p><p>Open any file in any project, and navigate to any view-controller based <code class="literal">.h</code> file in the project. The very first line of code will read as follows:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>As an iOS developer, you have probably written hundreds of <code class="literal">#import</code> statements in any one project. When the compiler reaches an import statement, it literally inserts every line of code found in the imported header file. In the previous example of the first line of code, <code class="literal">UIKit.h</code> imports all header files<a id="id33" class="indexterm"/> available in the UIKit Framework; so, you don't have to worry about which header file should be imported for different instances.</p><p>If you have ever taken a look at all of the files included in UIKit, you will see that they total over 11,000 lines of code. This means that each file importing <code class="literal">UIKit.h</code> will grow by 11,000 lines of code. This is less than ideal; however, <a id="id34" class="indexterm"/>Apple provides one solution with <strong>precompiled header</strong> (<strong>PCH</strong>) files.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Precompiled headers – a partial solution</h2></div></div></div><p>Each project you create<a id="id35" class="indexterm"/> will automatically generate its own PCH file in the supporting files group. During the preprocessing phase of compilation, the PCH file will load and cache the specified headers to import. The following is an example of a PCH file:</p><div><pre class="programlisting">#import &lt;Availability.h&gt;

#ifndef __IPHONE_5_0
#warning "This project uses features only available in iOS SDK 5.0 and later."
#endif

#ifdef __OBJC__

  #import &lt;UIKit/UIKit.h&gt;
  #import &lt;Foundation/Foundation.h&gt;
  #import "UIImage+ImageEffects.h"

#endif</pre></div><p>Your application may require a specific framework or class in multiple files. Rather than importing the file individually (and repeatedly), adding the import statement to the PCH file will precompute and cache a majority of the work during the preprocessing phase of compilation. This allows each file to be pulled from the cache when available.</p><p>Although this method works well, when importing the Apple frameworks, you must always remember to link<a id="id36" class="indexterm"/> the frameworks to your project. Failing to do so will result in<a id="id37" class="indexterm"/> a number of errors thrown by the compiler.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Modules – smart importing</h2></div></div></div><p>With the introduction of iOS 7, Apple has introduced a new way to handle precompiling frameworks with modules. Instead of replacing an import statement with every line of code, a module encapsulates a<a id="id38" class="indexterm"/> framework into a self-contained block. Modules are precompiled in the same way import statements are precompiled in the PCH file; however, using modules will automatically link the proper framework and provide the exact same speed boost to compilation.</p><p>Modules are enabled by default in all new projects created using Xcode 5. For older projects, you can enable modules in your project's build settings by searching for modules and setting <strong>Enable Modules (C and Objective-C)</strong> to <strong>Yes</strong>.</p><div><img src="img/0319OT_02_01.jpg" alt="Modules – smart importing"/></div><p>Now that modules have been turned on, you can start using the new syntax to import frameworks. At the top of the <code class="literal">.h</code> file you wish to import, simply type the following code:</p><div><pre class="programlisting">@import QuartzCore;</pre></div><p>That's all that is required in your code. Xcode will automatically link the required framework (in this case, <code class="literal">QuartzCore</code>) and provide you with all of the speed boosts for compilation.</p><p>Additionally, you can import specific header files based on need. You may, for instance, only require the <code class="literal">CoreAnimation</code> headers provided by <code class="literal">QuartzCore</code>. You can easily import these headers by typing the following:</p><div><pre class="programlisting">@import QuartzCore.CoreAnimation;</pre></div><p>Additionally, Xcode will automatically convert <code class="literal">#import</code> statements to <code class="literal">@import</code> for you at runtime. Although convenient, it is still recommended you update to new syntax whenever possible.</p><p>It is also important to note that <a id="id39" class="indexterm"/>modules currently only support Apple frameworks. Custom classes and third-party frameworks still require the traditional method or the PCH file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>NSProgress</h1></div></div></div><p>iOS 7 introduces a completely new class to the Foundation framework, <code class="literal">NSProgress</code>. Using <code class="literal">NSProgress</code> involves treating each task of an action as a milestone of completion. By doing so, you, the developer, <a id="id40" class="indexterm"/>can track progress directly in code and perform individual tasks for each milestone.</p><p>For instance, to perform a particular action, you may require four separate tasks to be completed. Each task is capable of monitoring its own progress, and will report once the task is complete. In our example, this would increase the percent of completion to 25.</p><p>
<code class="literal">NSProgress</code> uses <strong>Key Value Observing</strong> (<strong>KVO</strong>) to provide notifications related to progress. These <a id="id41" class="indexterm"/>notifications can be used to update a UI component displaying progress to the user, such as a progress bar or label. The following code is a very simple implementation that demonstrates working with <code class="literal">NSProgress</code> to report progress in a localized manner:</p><div><pre class="programlisting">NSArray *data = @[@"Data 1", @"Data 2", @"Data 3", @"Data 4"];

  self.dataProgress = [NSProgress progressWithTotalUnitCount:data.count];

  int index = 0;

  for (NSString *string in data) {

  // Do something with string or other data
    index ++;
    self.dataProgress.completedUnitCount = index;


    NSLog(@"%@", [self.dataProgress localizedDescription]);

  }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>NSArray</h1></div></div></div><p>When using <code class="literal">NSArray</code>, you must ensure that all supplied indexes are within range and not beyond the length of the array. <a id="id42" class="indexterm"/>When retrieving an element using an index, the index must be between zero and a number (the number being the total items in the array); otherwise, an exception will be thrown. A common use case of this involves grabbing the first or last object from an array.</p><p>
<code class="literal">NSArray</code> has always had the following method to obtain the last object:</p><div><pre class="programlisting">- (id)lastObject;</pre></div><p>Previously, grabbing the first object of an array required checks to ensure that the index was within the bounds of the array, as shown in the following code snippet:</p><div><pre class="programlisting">- (id)firstObjectInArray:(NSArray *)array {

  if (array.count &gt; 0) {
    return array[0];
  }

}</pre></div><p>Although the preceding example is rather small, you can see how more complex implementations can be complicated and time consuming. Thankfully, with iOS 7, Apple has finally made public a previously private method for <code class="literal">NSArray</code> to grab the first object:</p><div><pre class="programlisting">- (id)firstObject;</pre></div><p>This handy method will allow you to quickly access the first object of any array without the hassle. Additionally, if the array is empty, this method will return <code class="literal">nil</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>NSTimer</h1></div></div></div><p>It is a common practice to perform periodic tasks using <code class="literal">NSTimer</code>. The following is an example use of <code class="literal">NSTimer</code> to perform<a id="id43" class="indexterm"/> a task in two-second intervals and repeats:</p><div><pre class="programlisting">[NSTimer scheduledTimerWithTimeInterval:2.0
  target:self
  selector:@selector(targetMethod:)
  userInfo:nil
  repeats:YES];</pre></div><p>The issue with this method<a id="id44" class="indexterm"/> is that the CPU is consistently active in order to perform the desired task repeatedly. When using multiple timers at once, it is possible (although unlikely) that it may reduce the performance of the CPU for the rest of your application. It is always best practice to run tests on your applications to find such possibilities <a id="id45" class="indexterm"/>and use safeguards wherever possible.</p><p>Apple has added a new tolerance property<a id="id46" class="indexterm"/> to <code class="literal">NSTimer</code> to reduce the strain on the CPU when using <code class="literal">NSTimers</code>. This property will tell the application how late a timer is allowed to fire when it has surpassed its scheduled interval. As a result, the application will be able to group actions together to reduce CPU strain.</p><p>This new property can be accessed and set with the following methods:</p><div><pre class="programlisting">- (NSTimeInterval)tolerance;
- (void)setTolerance:(NSTimeInterval)tolerance;</pre></div><p>Setting this property will help create safeguards for your CPU usage related to timers.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>NSData</h1></div></div></div><p>Every application uses data in <a id="id47" class="indexterm"/>some way or another. In some instances, you may require the ability to manipulate individual bytes of data. <code class="literal">NSData</code> encapsulates these raw bytes to allow for easy manipulation using built-in methods.</p><p>With iOS 7, <code class="literal">NSData</code> now adds support for Base64 encoding and decoding; a group of ACSII format binary-to-text encoding schemes. These schemes are most commonly used to transfer data between media that only support text-based data transfer. Encoding images from JSON-based responses from a web API is the most common use for these schemes.</p><p>Prior to iOS 7, developers<a id="id48" class="indexterm"/> were required to use a third-party library or build their own from scratch. Apple has made it exceptionally easy to use these encoding methods with the following methods:</p><div><pre class="programlisting">- (id)initWithBase64EncodedData:(NSData *)base64Data 
  options:(NSDataBase64DecodingOptions)options;

- (NSData *)base64EncodedDataWithOptions:
  (NSDataBase64EncodingOptions)options;

- (id)initWithBase64EncodedString:(NSString *)base64String 
  options:(NSDataBase64DecodingOptions)options;

- (NSString *)base64EncodedStringWithOptions:
  (NSDataBase64EncodingOptions)options;</pre></div><p>The first two methods are focused on UTF-8 encoded data, while the remaining two deal directly with string values. Both pairs of methods provide the same functionality; however, each use case may provide better performance.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>NSURLUtilities</h1></div></div></div><p>The Foundation Framework<a id="id49" class="indexterm"/> includes many different methods related to handling URLs; however, most API's related to manipulating these URLs are based on <code class="literal">NSString</code> because <code class="literal">NSURL</code> is an immutable class.</p><p>In order to fix this issue, Apple has introduced <code class="literal">NSURLComponents</code> to allow for manipulation of URL objects. With <code class="literal">NSURLComponents</code>, <code class="literal">NSURL</code> can be treated as a mutable object that allows direct manipulation. The following code snippet is an example use case:</p><div><pre class="programlisting">NSURLComponents *components = [NSURLComponents componentsWithString:@"http://somewebsite.com"];

components.path = @"/somepath";
components.query = @"queryParameter=parameterValue";

NSLog(@"%@", [components URL]);</pre></div><p>Running this code will output the following to the console:</p><p>
<code class="literal">http://somewebsite.com/somepath?queryParameter=parameterValue</code>
</p><p>Using <code class="literal">NSURLComponents</code>, you may<a id="id50" class="indexterm"/> now directly manipulate <code class="literal">NSURL</code> values without the use of <code class="literal">NSString</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Summary</h1></div></div></div><p>In this chapter, we covered some of the major updates to the Foundation Framework. It is always recommended that you stay up to date with the advancements to Objective-C and Apple's core frameworks. With this knowledge, you now have the tools to build more efficient and better-performing applications!</p><p>Now that we have a better understanding of the new features found in Foundation, it's time to start building our application. In the next chapter, we will begin building our interface using the new Auto Layout features in iOS 7.</p></div></body></html>