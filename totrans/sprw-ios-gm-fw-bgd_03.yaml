- en: Chapter 3. Managing Assets and Scenes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。管理资产和场景
- en: '*In the previous chapter, we drew our first display objects on the screen,
    which in our case were quads. We made a cardboard puppet doll out of quads and
    learned how to use macros. There is one last thing we need to know before developing
    our pirate game. In this chapter, we will learn about managing our assets, such
    as images, sound, and other kinds of files. We will also learn how to group elements
    into scenes and display these scenes.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们在屏幕上绘制了第一个显示对象，在我们的案例中是四边形。我们用四边形制作了一个纸板木偶娃娃，并学习了如何使用宏。在开发我们的海盗游戏之前，我们还需要了解最后一件事。在本章中，我们将学习如何管理我们的资产，例如图像、声音和其他类型的文件。我们还将学习如何将元素分组到场景中并显示这些场景。*'
- en: Working with assets
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与资产一起工作
- en: When we develop a game, we load files. We probably load a lot of images too.
    These images are displayed on the screen and are the graphics of any 2D game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发游戏时，我们加载文件。我们可能还加载了很多图像。这些图像显示在屏幕上，是任何2D游戏的图形。
- en: We will also need to load sound files for playing music and sound effects. Other
    general purpose files include text files that are either localization or game
    information files, such as hit points for enemies, attack strength, or similar
    data that affects the gameplay of the game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要加载音文件以播放音乐和音效。其他通用文件包括文本文件，这些文件可以是本地化文件或游戏信息文件，例如敌人的生命值、攻击强度或类似影响游戏玩法的数据。
- en: Game-relevant data may include saved games and level data. This gameplay-relevant
    data may not always be plain text; in some cases, they are binary files or they
    use a markup language such as XML or JSON. In the iOS and Mac world, the PLIST
    file format is very common and contains a specialized kind of XML format.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏相关的数据可能包括保存的游戏和关卡数据。这种与游戏玩法相关的数据不一定总是纯文本；在某些情况下，它们是二进制文件或使用XML或JSON等标记语言。在iOS和Mac世界中，PLIST文件格式非常常见，包含一种特殊的XML格式。
- en: '![Working with assets](img/1509OS_03_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![与资产一起工作](img/1509OS_03_01.jpg)'
- en: In some games, game engines and game frameworks go a step further when dealing
    with gameplay-relevant data in order to be more dynamic. They allow scripting
    through languages such as Lua and JavaScript. These scripts are loaded and executed
    at runtime.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些游戏中，游戏引擎和游戏框架在处理与游戏玩法相关的数据时会更进一步，以实现更动态的效果。它们允许通过Lua和JavaScript等语言进行脚本编写。这些脚本在运行时加载和执行。
- en: Managing our assets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理我们的资产
- en: Now that we know what assets are, how can we manage them for our game? Before
    we get to that, let's take a look at what we know so far and what the prerequisites
    to effectively load assets are.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么是资产，我们如何为我们的游戏管理它们？在我们到达那里之前，让我们看看我们已经知道的内容以及有效加载资产的前提条件。
- en: Firstly, we know that there are different kinds of assets that can either be
    plain text files or binary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们知道存在不同类型的资产，可以是纯文本文件或二进制文件。
- en: One thing to keep in mind is the memory in mobile devices nowadays. While it
    is the same as the memory in desktop devices from a few years back, not all of
    this is reserved for our application. We should also keep in mind that the size
    of an asset on the disk may not be the same in memory as it is for compressed
    files, especially if the file content is compressed on the disk but has to be
    uncompressed in memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是现在移动设备上的内存。虽然它与几年前桌面设备的内存相同，但并非所有这些内存都保留给我们应用程序。我们还应该记住，磁盘上资产的尺寸在内存中可能不与压缩文件相同，特别是如果文件内容在磁盘上被压缩，但在内存中需要解压缩的话。
- en: 'Consequently, there are a few things we can do, which are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以做几件事情，如下所示：
- en: Limit the number of assets we are loading; this can prove difficult as a game
    can require a high amount of assets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制我们正在加载的资产数量；这可能是一个难题，因为游戏可能需要大量的资产
- en: Limit the number of assets that are currently loaded in memory
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制当前加载到内存中的资产数量
- en: Cache assets that are already loaded so that we don't have the same content
    in memory two or more times
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存已加载的资产，以便我们不会在内存中有两次相同的内容
- en: Let's create a base class that manages a group of assets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基类来管理一组资产。
- en: Time for action – creating a base class
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建基类
- en: 'To create a base class to manage our assets, we need to use the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用于管理我们资产的基类，我们需要使用以下步骤：
- en: Open the Xcode game template if it's not already open, right-click on the **Classes**
    folder, select **New Group**, and rename the group to **Assets**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Xcode游戏模板尚未打开，请打开它，然后在**Classes**文件夹上右键单击，选择**New Group**，并将组重命名为**Assets**。
- en: Right-click on the **Assets** group and select **New File...**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Assets**组并选择**新建文件...**。
- en: Select **Objective-C class** and click on **Next**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Objective-C类**并点击**下一步**。
- en: Enter `AssetsDictionary` in the name field, select **NSObject** from the **Subclass
    of** entry, and click on **Next**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称字段中输入`AssetsDictionary`，从**子类为**条目中选择**NSObject**，然后点击**下一步**。
- en: On the next dialog, click on **Create**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，点击**创建**。
- en: Open the `AssetsDictionary.h` file.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AssetsDictionary.h`文件。
- en: 'Add an instance variable called `_dict`, which is a pointer to `NSMutableDictionary`,
    as shown in the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`_dict`的实例变量，它是一个指向`NSMutableDictionary`的指针，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a property called `verbose`, which is of type `BOOL`, as shown in the following
    code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`verbose`的属性，其类型为`BOOL`，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add an instance method called `registerAsset`, as shown in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`registerAsset`的实例方法，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add another instance method called `unregisterAsset`, as shown in the following
    code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`unregisterAsset`的实例方法，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a third instance method called `clear`, as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`clear`的第三个实例方法，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now switch to `AssetsDictionary.m`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在切换到`AssetsDictionary.m`。
- en: 'Add an initializer with the following content:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化器，内容如下：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the `registerAsset` method with the following piece of code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现`registerAsset`方法：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `unregisterAsset` method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为`unregisterAsset`的方法：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `clear` method that should reset the cache:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`clear`的方法，该方法应该重置缓存：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Switch to the `Game.m` file.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Game.m`文件。
- en: 'Import the `AssetsDictionary.h` file in the `import` section:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`import`部分导入`AssetsDictionary.h`文件：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `init` method, add the following lines:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中，添加以下行：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the example, and you will get the following output:![Time for action – creating
    a base class](img/1509OS_03_02.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![行动时间 – 创建基类](img/1509OS_03_02.jpg)
- en: '*What just happened?*'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. Then, we created a new group where we put everything that relates to
    the management of our assets. Finally, we renamed the newly created group.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们从上一章结束的地方打开了我们的Xcode模板。然后，我们创建了一个新组，将所有与我们的资源管理相关的所有内容都放在里面。最后，我们将新创建的组重命名。
- en: In step 2, we created a new file. In step 3, we selected **Objective-C class**
    from the dialog that popped up. We wanted the class name to be `AssetsDictionary`,
    which is what we entered in step 4; we also confirmed the location where it is
    going to be saved on the hard drive in step 5.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们创建了一个新文件。在步骤3中，我们从弹出的对话框中选择**Objective-C类**。我们希望类名为`AssetsDictionary`，这是我们在步骤4中输入的；我们还确认了它将在硬盘上的保存位置，这是在步骤5中完成的。
- en: Next, we opened the header file and an instance variable to store the name and
    content of an asset. For this, we needed it to be an instance of `NSMutableDictionary`.
    Objective-C Cocoa classes such as `NSDictionary` can be mutable or immutable;
    the contents of mutable classes can change, and the values of immutable classes
    are fixed to the values used when declaring the object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们打开了头文件并创建了一个实例变量来存储资源的名称和内容。为此，我们需要它是一个`NSMutableDictionary`的实例。Objective-C
    Cocoa类如`NSDictionary`可以是可变的或不可变的；可变类的内容可以改变，而不可变类的值固定为声明对象时使用的值。
- en: Though we put the interface section in the header, it is also possible to put
    it right before the implementation section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将接口部分放在了头文件中，但也可以将其放在实现部分之前。
- en: In step 8, we added a property called `verbose`, which is of type `BOOL`. If
    this property is set to `YES`, once an asset is registered, it should write a
    message telling us whether the asset is already in cache. It is sufficient to
    say that its default value should be `NO` so that our console message box is not
    cluttered with messages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们添加了一个名为`verbose`的属性，其类型为`BOOL`。如果这个属性设置为`YES`，一旦一个资源被注册，它应该写一条消息告诉我们该资源是否已经在缓存中。可以说其默认值应该是`NO`，这样我们的控制台消息框就不会被消息填满。
- en: 'We needed to define our method that handles the registering and serving of
    our assets. It takes two parameters: the name of an asset and the content of an
    asset. It returns the content of the asset. Since the content of the asset can
    be anything—but is in most cases an instance of some sort—the type `id` seems
    like the best option here. The type `id` can stand for any class instance; if
    put to a technical term, it''s called dynamic typing.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义我们的方法来处理资产的注册和服务。它接受两个参数：资产的名称和资产的内容。它返回资产的内容。由于资产的内容可以是任何东西——但在大多数情况下是某种类的实例——因此
    `id` 类型在这里似乎是最佳选择。`id` 类型可以代表任何类实例；如果用技术术语来说，它被称为动态类型。
- en: Then, we defined two methods; the first explains how to delete a single asset
    from the cache (step 10), and the second method explains how to clear all assets
    (step 11).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个方法；第一个解释了如何从缓存中删除单个资产（步骤 10），第二个方法解释了如何清除所有资产（步骤 11）。
- en: 'Our header file is done; now, let''s get to the actual implementation. First
    off, switch to the `AssetsDictionary.m` file. In step 13, we added an initializer,
    which does the following two things for us:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的头文件已经完成；现在，让我们着手实际的实现。首先，切换到 `AssetsDictionary.m` 文件。在第 13 步中，我们添加了一个初始化器，它为我们做了以下两件事：
- en: Set up the `_dict` dictionary.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `_dict` 字典。
- en: Set the `verbose` property to `NO` by using its instance variable `_verbose`.
    This is generally not needed as `NO` is the default value for `BOOL`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其实例变量 `_verbose` 将 `verbose` 属性设置为 `NO`。这通常不是必需的，因为 `NO` 是 `BOOL` 的默认值。
- en: In the next step, we implemented the `registerAsset` method. If the key—our
    first parameter—does not exist in the dictionary, we add it to the dictionary
    and return the content of the asset. If it exists, we look up the value from the
    dictionary and return it. In both cases, if the `verbose` property is set to `YES`,
    we will print a fitting message to reflect the current state of the asset.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实现了 `registerAsset` 方法。如果键——我们的第一个参数——在字典中不存在，我们将其添加到字典中并返回资产的内容。如果它存在，我们从字典中查找值并返回它。在这两种情况下，如果
    `verbose` 属性设置为 `YES`，我们将打印一条适当的消息来反映资产当前的状态。
- en: In step 15, we defined a method that allows us to delete a single asset from
    the cache. In step 16 on the other hand, we defined a method to clear the complete
    cache.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 15 步中，我们定义了一个方法，允许我们从缓存中删除单个资产。而在第 16 步中，我们定义了一个方法来清除整个缓存。
- en: Now that the `AssetsDictionary` class is ready for action, let's put it up for
    a test. In step 17, we switched to our `Game.m` file and subsequently imported
    the `AssetsDictionary` header in step 18.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`AssetsDictionary` 类已经准备好投入使用，让我们对其进行测试。在第 17 步中，我们切换到 `Game.m` 文件，并在第 18
    步中随后导入了 `AssetsDictionary` 头文件。
- en: Next, within the initializer of our `Game` class, we defined an instance of
    our `AssetsDictionary` class, set the `verbose` property to `YES`, and registered
    the same asset twice to see whether it will be cached correctly. In the last step,
    we ran the example and looked at the output in the console.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `Game` 类的初始化器中，我们定义了 `AssetsDictionary` 类的一个实例，将 `verbose` 属性设置为 `YES`，并将相同的资产注册两次以查看它是否会被正确缓存。在最后一步中，我们运行了示例并查看了控制台中的输出。
- en: Have a go hero
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来吧，英雄
- en: 'While this class works for our purposes, we could improve the `AssetsDictionary`
    class further. Here are some suggestions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类适用于我们的目的，但我们还可以进一步改进 `AssetsDictionary` 类。以下是一些建议：
- en: 'When getting the cached value of an asset, we look for the value from the dictionary
    twice: the first time when checking whether the key is in the dictionary, and
    the second time when getting the actual value. This may result in a performance
    penalty when loading the assets into the game if there is a huge amount of assets.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当获取资产的缓存值时，我们会从字典中查找两次该值：第一次是在检查键是否在字典中时，第二次是在获取实际值时。如果资产数量巨大，这可能会在将资产加载到游戏中时产生性能惩罚。
- en: Try to use `NSCache` instead of `NSMutableDictionary`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `NSCache` 而不是 `NSMutableDictionary`。
- en: If we want to display progress bars to see how far the loading process currently
    is, we will need a way to get the number of currently registered assets.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想显示进度条以查看当前加载过程已进行到什么程度，我们需要一种方法来获取当前已注册的资产数量。
- en: We can also have an `exists` method that checks whether an asset has already
    been registered and returns the result of this check.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以有一个 `exists` 方法，用于检查资产是否已经被注册，并返回检查结果。
- en: We can add more initializers that take `NSDictionary`, for example.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加更多接受 `NSDictionary` 的初始化器，例如。
- en: Creating a texture manager
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个纹理管理器
- en: When we load an image in Sparrow, we typically want it to be a texture. A texture
    is pixel information that makes up an image. It's conceptually similar to how
    the `BitmapData` class works in ActionScript 3\. If we want it to be displayed
    on the screen, it needs to be put on a geometrical representation, which is typically
    a quad.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Sparrow中加载图像时，我们通常希望它是一个纹理。纹理是构成图像的像素信息。从概念上讲，它与ActionScript 3中的`BitmapData`类类似。如果我们想将其显示在屏幕上，它需要放在一个几何表示上，这通常是一个四边形。
- en: The way we want our texture manager to work is to pass in a filename, which
    will be converted to a texture and is then available to us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的纹理管理器以这种方式工作：传入一个文件名，该文件名将被转换为纹理，然后对我们可用。
- en: Let's use `AssetsDictionary` for our texture manager.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为纹理管理器使用`AssetsDictionary`。
- en: Time for action – managing our textures
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 – 管理我们的纹理
- en: 'To create our texture manager, take a look at the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的纹理管理器，请查看以下步骤：
- en: Add a new Objective-C class called `TextureManager` derived from `AssetsDictionary`
    within the **Assets** group.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Assets**组中添加一个新的名为`TextureManager`的Objective-C类，它继承自`AssetsDictionary`。
- en: 'Add an instance method that will register a texture using its filename and
    return the correct value, which is the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个实例方法，它将使用文件名注册一个纹理并返回正确的值，如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Switch to `TextureManager.m` and implement the method with the following content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`TextureManager.m`并实现以下内容的方法：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Switch to the `Game.m` file, and replace the `AssetsDictionary.h` import with
    the `TextureManager.h` file in the `import` section.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Game.m`文件，并在`import`部分将`AssetsDictionary.h`导入替换为`TextureManager.h`文件。
- en: 'In the `init` method, replace the `AssetsDictionary` test we did earlier in
    the chapter with the following lines:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中，将本章中较早进行的`AssetsDictionary`测试替换为以下行：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the example, and you will get the following output:![Time for action – managing
    our textures](img/1509OS_03_03.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![Time for action – managing our textures](img/1509OS_03_03.jpg)
- en: '*What just happened?*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In the first step, we created a `TextureManager` class, which is a subclass
    of `AssetsDictionary`. In step 2, we defined the `registerTexture` instance method,
    which we implemented in the next step. A lot happened in this one line, explained
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个`TextureManager`类，它是`AssetsDictionary`的子类。在第二步中，我们定义了`registerTexture`实例方法，我们在下一个步骤中实现了它。这一行发生了很多事情，解释如下：
- en: We created an instance of `SPTexture` with the contents of the filename.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用文件名的内容创建了一个`SPTexture`实例。
- en: We registered this instance to utilize `registerAsset` we implemented earlier.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将此实例注册到我们之前实现的`registerAsset`中。
- en: We returned the result of the called method.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回了被调用方法的結果。
- en: Since the result is of the type `id`, we cast it to `SPTexture`— the type we
    want.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于结果是`id`类型，我们将其转换为`SPTexture`——这是我们想要的类型。
- en: Now, we go ahead and switch to the `Game.m` file. We replace the line `#import
    "AssetsDictionary.h"` with `#import "TextureManager.h"`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续切换到`Game.m`文件。我们将`#import "AssetsDictionary.h"`行替换为`#import "TextureManager.h"`。
- en: Then, we delete the example where we tested out the `registerAsset` method from
    `AssetsDictionary`. After this, we set up the same test; however, this time we
    use the `TextureManager` class and the `registerTexture` method. We load the `Default.png`
    file, which is in the `Resources` folder and is currently just a black image.
    The `Default.png` file is part of the original Sparrow barebone template.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们删除了测试`registerAsset`方法的示例。之后，我们设置了相同的测试；然而，这次我们使用`TextureManager`类和`registerTexture`方法。我们加载了位于`Resources`文件夹中的`Default.png`文件，它目前只是一个黑色图像。`Default.png`文件是Sparrow原始骨架模板的一部分。
- en: When we run the example, it loads the image from file the first time, and then
    it uses the cached result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，它第一次从文件中加载图像，然后使用缓存的結果。
- en: Creating a sound manager
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建声音管理器
- en: Now that we have the texture manager, let's create the sound manager that is
    going to be very similar to the previous piece of code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了纹理管理器，让我们创建一个与之前的代码非常相似的声音管理器。
- en: Time for action – implementing a sound manager
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 – 实现声音管理器
- en: 'To implement the sound manager, just follow these simple steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现声音管理器，只需遵循以下简单步骤：
- en: Add a new Objective-C class called `SoundManager` derived from `AssetsDictionary`
    within the **Assets** group.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Assets**组中添加一个新的名为`SoundManager`的Objective-C类。
- en: 'Add an instance method that will register a sound using its filename and return
    the correct value, as shown in the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个实例方法，使用文件名注册声音并返回正确的值，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the method from the previous step with the following content:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步的方法，以下内容：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the first step, we created a `SoundManager` class, which is a subclass of
    `AssetsDictionary`. In step 2, we defined the `registerSound` method, which we
    implemented in the next step; this method loads a sound from file and returns
    the result of the registered asset.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个 `SoundManager` 类，它是 `AssetsDictionary` 的子类。在第二步中，我们定义了 `registerSound`
    方法，我们在下一步中实现了该方法；该方法从文件中加载声音并返回已注册资产的结果。
- en: It is very similar to `TextureManager`, but instead of a texture and `SPTexture`,
    we loaded a sound using `SPSound`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `TextureManager` 非常相似，但不同之处在于我们使用 `SPSound` 加载声音，而不是纹理和 `SPTexture`。
- en: For now, this is all we will do for sounds and sound management since we don't
    have any sound assets to load.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只对声音和声音管理做了这些，因为我们没有要加载的声音资产。
- en: Creating a file manager
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件管理器
- en: 'Now, we almost have a manager for all kinds of assets we want to use. The last
    thing we need is a manager for our data. We know that data assets can be pretty
    much anything, so we need to descope the use case for managing data assets. Let''s
    take a look at what we''ll need right now:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎有了我们想要使用的所有类型资产的经理。我们最后需要的是我们数据的管理器。我们知道数据资产可以是几乎所有东西，因此我们需要缩小管理数据资产的使用场景。让我们看看我们现在需要什么：
- en: Loading a plain text file is always a useful piece of functionality. It could
    contain game texts or a basic level layout.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载纯文本文件总是一件有用的功能。它可能包含游戏文本或基本关卡布局。
- en: '`NSDictionary` and `NSMutableDictionary` are classes we already used and will
    be using to store data. How about we load a file and its content is converted
    to a structure similar to that of `NSDictionary`? The JSON format is very similar
    to a structure we find in `NSDictionary`, and luckily, since iOS 5, we have the
    means of converting a JSON file into `NSDictionary` without needing any third-party
    libraries.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSDictionary` 和 `NSMutableDictionary` 是我们已使用并将继续使用的类，用于存储数据。我们是否可以加载一个文件，并将其内容转换为类似于
    `NSDictionary` 的结构？JSON 格式与我们找到的 `NSDictionary` 结构非常相似，幸运的是，自从 iOS 5 以来，我们可以将
    JSON 文件转换为 `NSDictionary`，而无需任何第三方库。'
- en: Time for action – managing remaining file types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 管理剩余的文件类型
- en: 'To create an asset manager for our files, use the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件资产管理器，请按照以下步骤操作：
- en: Add a new Objective-C class called `FileManager`, which is derived from `AssetsDictionary`
    within the **Assets** group.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 Objective-C 类 `FileManager`，它是 **Assets** 组中 `AssetsDictionary` 的子类。
- en: 'Define an instance method called `registerPlainText`, as shown in the following
    code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `registerPlainText` 的实例方法，如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define another instance method called `registerDictionaryFromJSON`, as shown
    in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个实例方法 `registerDictionaryFromJSON`，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `registerPlainText` method with the following content:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `registerPlainText` 方法，以下内容：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `registerDictionaryFromJSON` method with the following content:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `registerDictionaryFromJSON` 方法，以下内容：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `example.json` file to the `Resource` folder by right-clicking on the
    `Resources` folder and selecting **New File...**. Select **Other** from the tab
    and create an empty file. Fill it with the following content:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `Resources` 文件夹上右键单击并选择 **New File...** 来将 `example.json` 文件添加到 `Resource`
    文件夹中。从选项卡中选择 **Other** 并创建一个空文件。用以下内容填充它：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add `example.txt` to the `Resource` folder, which has the following content:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `example.txt` 添加到 `Resource` 文件夹中，其内容如下：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that all of our data and the `FileManager` class is set up, let's give it
    a spin. Switch to `Game.m`, remove the pieces of code that tested our previous
    asset managers, and import the `FileManager` header file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有数据和 `FileManager` 类，让我们来试一试。切换到 `Game.m`，删除测试我们之前资产管理器的代码片段，并导入 `FileManager`
    头文件。
- en: 'Add the following piece of code to the initializer method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码段添加到初始化方法中：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the example, and see the following output:![Time for action – managing remaining
    file types](img/1509OS_03_04.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，并查看以下输出：![行动时间 – 管理剩余的文件类型](img/1509OS_03_04.jpg)
- en: '*What just happened?*'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the first step, we created a `FileManager` class, which is a subclass of
    `AssetsDictionary`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个 `FileManager` 类，它是 `AssetsDictionary` 的子类。
- en: 'In the next two steps, we defined two instance methods: one for loading plain
    text files and another for loading JSON files.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个步骤中，我们定义了两个实例方法：一个用于加载纯文本文件，另一个用于加载 JSON 文件。
- en: In step 4, we implemented the `registerPlainText` method. We could have put
    it all in a one liner, but that would make it a bit cramped and harder to read.
    So, if the asset was registered, we returned it using the `registerAsset` method.
    We don't need to pass in content this time as the content is already in the dictionary.
    If it is not registered, we need the path to the filename first. Like every resource
    we want to load from the **Resource** folder, without the help of third-party
    libraries, we need to get the exact file location. The `[[NSBundle mainBundle]
    pathForResource]` method gives us the exact file location if we pass a filename.
    The main bundle represents the application bundle of the current app. In the next
    line, we loaded the file into an `NSString`, and the encoding is UTF-8\. We then
    returned the result that had been passed through the `registerAsset` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们实现了 `registerPlainText` 方法。我们本可以将所有内容放在一行中，但那样会使代码显得有些拥挤，难以阅读。因此，如果资产已注册，我们使用
    `registerAsset` 方法返回它。这次我们不需要传递内容，因为内容已经在字典中。如果没有注册，我们需要首先获取文件名路径。像从 **Resource**
    文件夹中加载的每个资源一样，不借助第三方库，我们需要获取确切的文件位置。如果传递一个文件名，`[[NSBundle mainBundle] pathForResource]`
    方法会给出确切的文件位置。主包代表当前应用程序的应用程序包。在下一行中，我们将文件加载到一个 `NSString` 中，编码为 UTF-8。然后，我们返回通过
    `registerAsset` 方法传递的结果。
- en: In the next step, we implemented the `registerDictionaryFromJSON` method that
    works pretty much in the same way as the `registerPlainText` method. However,
    instead of loading the file into an `NSString`, we used an `NSData` object. We
    then converted the file contents through the `NSJSONSerialization` class, which
    offers the `JSONObjectWithData` method. We don't really need to pass in any kind
    of special options right now.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实现了 `registerDictionaryFromJSON` 方法，它的工作方式与 `registerPlainText` 方法几乎相同。然而，我们不是将文件加载到
    `NSString` 中，而是使用了一个 `NSData` 对象。然后，我们通过 `NSJSONSerialization` 类转换文件内容，该类提供了 `JSONObjectWithData`
    方法。现在我们实际上不需要传递任何特殊选项。
- en: We added an `example.json` file, which has one key that is a string value and
    two keys that have number values. In a JSON structure, a key has to be written
    in double quotes and is a string. A value can either be an array, a string, a
    number, a Boolean, a null, or an object. If a value is an object, it can have
    keys and values by itself. So, it can map the structure of `NSDictionary` pretty
    well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `example.json` 文件，它有一个字符串值的键和两个具有数值的键。在 JSON 结构中，键必须用双引号括起来，并且是一个字符串。值可以是数组、字符串、数字、布尔值、null
    或对象。如果值是一个对象，它可以有自己的键和值。因此，它可以很好地映射 `NSDictionary` 的结构。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the JSON format, take a look at [http://json.org/](http://json.org/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON 格式的更多信息，请查看 [http://json.org/](http://json.org/)。
- en: In the next step, we added an `example.txt` file and added some content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们添加了一个 `example.txt` 文件并添加了一些内容。
- en: In step 8, we removed all pieces of code from the previous example and imported
    the `FileManager` header file. We set up the file manager like how we did in the
    previous example. We then called the `registerDictionaryFromJSON` method with
    `example.json` as its parameter. We already know that we can access values from
    an `NSDictionary` instance through the `objectForKey` method, but we can also
    use the square bracket notation, which is more terse and easier to read. Just
    keep in mind that the square bracket notation for keys requires an `NSString`
    instance. Values, on the other hand, can be any object or `@` literal such as
    `@YES`, `@1`, or `@"MyValue"`. Then, we loaded the `example.txt` file and displayed
    it using `NSLog`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步中，我们从上一个示例中删除了所有代码片段，并导入了 `FileManager` 头文件。我们像上一个示例中那样设置了文件管理器。然后，我们用
    `example.json` 作为参数调用了 `registerDictionaryFromJSON` 方法。我们已经知道，我们可以通过 `objectForKey`
    方法从 `NSDictionary` 实例中访问值，但我们也可以使用更简洁、更容易阅读的方括号表示法。只需记住，键的方括号表示法需要一个 `NSString`
    实例。另一方面，值可以是任何对象或 `@` 文字，例如 `@YES`、`@1` 或 `@"MyValue"`。然后，我们加载了 `example.txt`
    文件，并使用 `NSLog` 显示它。
- en: When we ran the example, we saw when and how the assets were being loaded and
    the results of the loaded assets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们看到了资产何时以及如何被加载，以及加载的资产结果。
- en: 'Our `FileManager.h` file will look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FileManager.h` 文件将看起来像以下这样：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `FileManager.m` file will look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FileManager.m` 文件将看起来像以下这样：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Have a go hero
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试吧，英雄
- en: Our file manager works exactly like we want it to work. There is one little
    problem if we want to load the same asset as plain text and convert it to `NSDictionary`
    from a JSON file. Since we only use a single dictionary for all the file elements,
    if we load an asset with the `registerDictionaryFromJSON` method first and later
    load the same asset with the `registerPlainText` method, we will get `NSDictionary`
    converted into an `NSString` instead of the text file directly being loaded and
    added to the dictionary as an `NSString`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管理器工作方式与我们期望的完全一致。如果我们想要将相同的资产作为纯文本加载并从JSON文件转换为`NSDictionary`，则存在一个小问题。由于我们只使用单个字典来处理所有文件元素，如果我们首先使用`registerDictionaryFromJSON`方法加载一个资产，然后使用`registerPlainText`方法再次加载相同的资产，我们将得到将`NSDictionary`转换为`NSString`，而不是直接将文本文件加载并添加到字典中作为`NSString`。
- en: Basic error handling
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本错误处理
- en: For the file manager, we haven't set up any error handling. So, if a file does
    not exist, the application will probably crash and we will be left guessing why
    nothing is happening, without any clue how to proceed. For now, we will add some
    error handling to the `registerPlainText` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件管理器，我们还没有设置任何错误处理。因此，如果文件不存在，应用程序可能会崩溃，我们将无法猜测为什么没有任何事情发生，没有任何线索说明如何进行。现在，我们将向`registerPlainText`方法添加一些错误处理。
- en: Time for action – getting started with basic error handling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候开始基本的错误处理了
- en: 'To add some basic error handling, take a look at the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一些基本的错误处理，请参考以下步骤：
- en: Open the `FileManager.m` file.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FileManager.m`文件。
- en: 'Update the `registerPlainText` method to match the following piece of code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`registerPlainText`方法以匹配以下代码片段：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: While try-catch blocks are available in Objective-C, it's generally not a good
    idea to use them as they are quite slow and they can become quite difficult to
    handle if they are too nested.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Objective-C中提供了try-catch块，但通常不建议使用它们，因为它们相当慢，如果嵌套太深，处理起来也会变得相当困难。
- en: The first thing we need is an error object that is a pointer to `NSError`. When
    loading the text file, we apply the error handling. If there are any errors when
    loading the file, the error object is not nil anymore. If this is the case, we
    log the error.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个指向`NSError`的指针作为错误对象。在加载文本文件时，我们应用错误处理。如果在加载文件时出现任何错误，错误对象将不再为nil。如果是这种情况，我们将记录错误。
- en: Have a go hero
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'This is the most basic error handling at the moment. Here are some suggestions
    on how to improve it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前最基本的错误处理。以下是一些改进建议：
- en: Catch the case if a JSON file cannot be loaded
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获无法加载JSON文件的情况
- en: Catch the case if an invalid JSON file is being processed
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获处理无效JSON文件的情况
- en: Add an `NSError` parameter to register the assets in the file manager
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件管理器添加一个`NSError`参数以注册资产
- en: Putting it all together
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: We now have a couple of different asset managers. It's time to put it all together
    so that we don't have to instantiate the different managers when we want to use
    an asset.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有几个不同的资产管理器。是时候将它们整合在一起，这样我们就不必在想要使用资产时实例化不同的管理器。
- en: Time for action – creating an asset container class
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候创建资产容器类了
- en: 'To put all of our asset managers into one single class, use the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有的资产管理器放入一个单独的类中，请按照以下步骤操作：
- en: Add a new Objective-C class called `Assets` derived from `NSObject` within the
    **Assets** group.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Assets**组内创建一个名为`Assets`的新Objective-C类，继承自`NSObject`。
- en: 'Define a static method for each kind of asset, as shown in the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种资产定义一个静态方法，如下所示：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `Asset.m` file, import all asset managers, as shown in the following
    code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Asset.m`文件中，导入所有资产管理器，如下所示：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For each manager, add a static variable with the appropriate type and set its
    values to `nil`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个管理器，添加一个适当的类型的静态变量，并将其值设置为`nil`：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We need to overwrite the internal static `initialize` method. Use the following
    piece of code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要重写内部的静态`initialize`方法。使用以下代码片段：
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement each of the static methods by using the correct instance method from
    each of the asset managers, as shown in the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每个资产管理器中的正确实例方法实现每个静态方法，如下所示：
- en: '[PRE30]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Switch to the `Game.m` file and update the previous example to use the static
    `Assets` class:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Game.m`文件，并将之前的示例更新为使用静态的`Assets`类：
- en: '[PRE31]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the example. When we check the console, we should see something like what's
    shown in the following screenshot:![Time for action – creating an asset container
    class](img/1509OS_03_05.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。当我们检查控制台时，我们应该看到以下截图所示的内容：![动手实践 – 创建资产容器类](img/1509OS_03_05.jpg)
- en: '*What just happened?*'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the first step, we created an `Assets` class, which is a subclass of `NSObject`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个 `Assets` 类，它是 `NSObject` 的子类。
- en: We defined a static method for each of the asset manager instance methods, such
    as `texture` for `registerTexture` and `sound` for `registerSound`. Then, we proceeded
    to the implementation part.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个资产管理器实例方法定义了一个静态方法，例如 `texture` 用于 `registerTexture`，`sound` 用于 `registerSound`。然后，我们继续到实现部分。
- en: 'For each asset manager, we defined a static variable: `textureAssets` for our
    `TextureManager` class, `textureSounds` for our `SoundManager` class, and so on.
    We set these instances to `nil`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个资产管理器，我们定义了一个静态变量：`textureAssets` 用于我们的 `TextureManager` 类，`textureSounds`
    用于我们的 `SoundManager` 类，等等。我们将这些实例设置为 `nil`。
- en: We had overridden the internal `NSObject` initialize method, which is called
    once internally and does not need to be called by us.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重写了内部的 `NSObject` 初始化方法，该方法在内部调用一次，我们不需要调用它。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about how the initialize method of `NSObject` works can be
    found in the Apple documentation at [https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize](https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `NSObject` 的初始化方法如何工作的更多信息，可以在 Apple 文档中找到，网址为 [https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize](https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize)。
- en: In the `initialize` method, we allocated and initialized each of the instances
    if its value was `nil`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize` 方法中，如果其值为 `nil`，则分配和初始化每个实例。
- en: When implementing each of the static methods in the next step, we needed to
    call the corresponding instance method, such as `[textureAssets registerTexture:filename]`
    for the texture method, and we should not forget that we had to return the value
    of the instance method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现下一步中的每个静态方法时，我们需要调用相应的实例方法，例如纹理方法中的 `[textureAssets registerTexture:filename]`，我们不应忘记我们必须返回实例方法的值。
- en: To use the static `Assets` class in our game file, we needed to update the reference
    to the header file and use the `dictionaryFromJSON` and `plainText` methods from
    the static class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏文件中使用静态 `Assets` 类，我们需要更新对头文件的引用，并使用静态类中的 `dictionaryFromJSON` 和 `plainText`
    方法。
- en: When we ran the example, we saw an output similar to the previous example, where
    we loaded files through the `FileManager`, but in this case we didn't have any
    message about the assets' statuses as the `verbose` flag was not set to `YES`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们看到了与之前示例类似的结果，其中我们通过 `FileManager` 加载文件，但在这个例子中，我们没有关于资产状态的任何消息，因为
    `verbose` 标志未设置为 `YES`。
- en: 'Our `Assets.h` file will look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Assets.h` 文件将如下所示：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our `Assets.m` file will look like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Assets.m` 文件将如下所示：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Before we continue with scene management, let's take a look at how we can use
    the static `Assets` class when displaying an image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行场景管理之前，让我们看看如何在显示图像时使用静态 `Assets` 类。
- en: Time for action – displaying an image
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 显示图像
- en: 'To display an image, we just need to follow these steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示图像，我们只需遵循以下步骤：
- en: 'Inside the `Game` initializer method, add the following piece of code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game` 初始化方法内部，添加以下代码：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At the bottom of the initializer method, add the image to the display tree of
    the `Game` class.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化方法底部，将图像添加到 `Game` 类的显示树中。
- en: Run the example, and you will see the following:![Time for action – displaying
    an image](img/1509OS_03_06.jpg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将看到以下内容：![动手实践 – 显示图像](img/1509OS_03_06.jpg)
- en: '*What just happened?*'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: As we already know, we need the `SPImage` class to display a texture. It can
    be compared to `SPQuad`, but instead of just displaying a color, it displays the
    texture on itself. We used the `Assets` class to get our `Default.png` image from
    the `Resources` folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们需要 `SPImage` 类来显示纹理。它可以与 `SPQuad` 相比，但它不仅仅显示颜色，还在自身上显示纹理。我们使用 `Assets`
    类从 `Resources` 文件夹获取 `Default.png` 图像。
- en: In the next step, we added the image to the display tree of our game class using
    the `addChild` method. Running the example we should see that our cardboard puppet
    doll is not visible anymore because the black image we just loaded is displayed
    on top of the cardboard puppet doll.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们使用`addChild`方法将图像添加到游戏类的显示树中。运行示例后，我们应该看到我们的纸板木偶不再可见，因为我们刚刚加载的黑色图像显示在纸板木偶的上方。
- en: 'Our `Game.m` file should have the following content:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Game.m`文件应该包含以下内容：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Have a go hero
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试英雄
- en: 'Now that our asset management system is done, let''s discuss a few ways in
    which we can improve the setup, which are:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了资产管理系统的设置，让我们讨论一下我们可以改进设置的一些方法，它们是：
- en: Right now, if we pass text files into the texture manager, it may load, but
    it may lead to unexpected results once we try to display the texture on the screen.
    We can check for the file extension and only load the asset if it has the correct
    file extension.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，如果我们将文本文件传递给纹理管理器，它可能会加载，但当我们尝试在屏幕上显示纹理时，可能会得到意外的结果。我们可以检查文件扩展名，并且只有当它具有正确的文件扩展名时才加载资产。
- en: If we go one step further, we can try to automatically detect which asset we
    want to load by its mime type or, if that's not enough, we can try to detect the
    file format through the magic byte.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们再进一步，我们可以尝试通过其MIME类型自动检测我们想要加载的资产，或者如果这还不够，我们可以尝试通过魔数字节检测文件格式。
- en: We tested for the functionality of our asset manager, but if we want more thorough
    tests, we may want to resort to unit tests.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试了资产管理器的功能，但如果我们想要更彻底的测试，我们可能需要求助于单元测试。
- en: What are scenes?
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景是什么？
- en: In a typical game, we have a main menu, an options menu, possibly a credits
    screen, and of course the game itself. We can have all this in a single file,
    but that will become difficult to maintain after a while. So, it will be a good
    idea to group these elements into separate entities, which in our case are scenes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的游戏中，我们有一个主菜单、一个选项菜单，可能还有一个致谢屏幕，当然还有游戏本身。我们可以将这些所有内容放在一个文件中，但过一段时间后，这将变得难以维护。因此，将它们分组到单独的实体中会是一个好主意，在我们的例子中，这些实体就是场景。
- en: In games that depend on having a lot of levels, such as point'n'click games,
    it's also a good idea to have scenes for each level.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖于许多级别的游戏中，例如点对点游戏，为每个级别创建场景也是一个好主意。
- en: Time for action – implementing a scene class
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候实现场景类了
- en: 'To create a scene class, use the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个场景类，请按照以下步骤操作：
- en: Create a new group called **Scene**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Scene**的新组。
- en: Create a new Objective-C class called `Scene`, which is derived from the `SPSprite`
    class, and save it in the **Scene** group.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为`Scene`的Objective-C类，它从`SPSprite`类派生，并将其保存在**Scene**组中。
- en: 'Add a property called `guiLayer`, which is a `SPSPrite` type, as shown in the
    following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`guiLayer`的属性，它是一个`SPSPrite`类型，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add another property called `name`, which is an `NSString`, as shown in the
    following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个属性`name`，它是一个`NSString`，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a third property called `director`, which is an `id`, as shown in the following
    code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`director`的第三个属性，它是一个`id`，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add an initializer that initializes the properties of the class:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化器来初始化类的属性：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a second initializer that sets the name of the scene; this should be called
    `initWithName`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个设置场景名称的第二个初始化器；这应该被命名为`initWithName`：
- en: '[PRE40]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*What just happened?*'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Right now, we don't have any scenes, so we can't run the example just yet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们没有任何场景，所以我们还不能运行示例。
- en: Firstly, we set up the `Scene` class, which needs to be a subclass of `SPSprite`
    because it needs to be added somewhere and we want to allow all kinds of display
    objects to be added to the `scene` instance.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置了`Scene`类，它需要是`SPSprite`的子类，因为它需要被添加到某个地方，并且我们希望允许所有类型的显示对象被添加到`scene`实例中。
- en: We defined three properties; `guiLayer` should be the sprite where all our user
    interface-relevant display objects will be added, `name` should be the name of
    the scene itself, and `director` should be the reference to its parent object.
    In the `init` method, we set default values for these properties. We also added
    a second initializer, which takes a parameter that sets the name of the scene.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个属性；`guiLayer`应该是所有与用户界面相关的显示对象将被添加到的精灵，`name`应该是场景本身的名称，而`director`应该是其父对象的引用。在`init`方法中，我们为这些属性设置默认值。我们还添加了一个第二个初始化器，它接受一个参数来设置场景的名称。
- en: Creating a scene director
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景导演
- en: Now that we have a basic `scene` class, we need something that can actually
    manage all the scenes we want to add.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的 `scene` 类，我们需要一些可以实际管理我们想要添加的所有场景的东西。
- en: Time for action – managing our scenes with a scene director
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用场景导演管理我们的场景
- en: 'To create the scene director, take a look at the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建场景导演，请查看以下步骤：
- en: Create a new Objective-C class called `SceneDirector`, which is derived from
    the `SPSprite` class, and save it in the **Scene** group.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 `SceneDirector` 的 Objective-C 类，它从 `SPSprite` 类派生，并将其保存在 **Scene**
    组中。
- en: Add an instance variable called `_dict`, which is an `NSMutableDictionary` type.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_dict` 的实例变量，其类型为 `NSMutableDictionary`。
- en: 'Add an instance method that will add a scene to the scene director, as shown
    in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个实例方法，该方法将场景添加到场景导演中，如下所示：
- en: '[PRE41]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a second instance method that will add a scene, but this time you are also
    able to define/overwrite the name of the scene:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个实例方法，这次你还可以定义/覆盖场景的名称：
- en: '[PRE42]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add an instance method that will show a scene and take `NSString` as its parameter,
    as shown in the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个实例方法，该方法将显示场景并接受 `NSString` 作为其参数，如下所示：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's switch to the implementation. The initializer should initialize the `_dict`
    variable.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换到实现部分。初始化器应该初始化 `_dict` 变量。
- en: 'Implement the `addScene:(Scene *)scene withName:(NSString *)name` method with
    the following piece of code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码的 `addScene:(Scene *)scene withName:(NSString *)name` 方法：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `addScene:(Scene *)scene` method should be implemented as shown in the
    following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addScene:(Scene *)scene` 方法应按以下代码实现：'
- en: '[PRE45]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `showScene` method should have the following content:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`showScene` 方法应包含以下内容：'
- en: '[PRE46]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the first step, we created the class needed for the scene director. This
    needs to be a `SPSprite` because we want an instance of it to be added to the
    `Game` class, and the scenes that the scene director should mange can be added
    very easily to the scene director.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了场景导演所需的类。这需要是一个 `SPSprite`，因为我们希望它的实例被添加到 `Game` 类中，场景导演应该管理的场景可以很容易地添加到场景导演中。
- en: 'We defined two instance methods that add a scene: the first method takes the
    scene, and the second method takes the scene and a name.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个添加场景的实例方法：第一个方法接受场景，第二个方法接受场景和一个名称。
- en: We also needed an instance that actually shows the scene; it takes a name as
    its parameter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个实例来实际显示场景；它以名称作为其参数。
- en: In the next step, we implemented the initializer of the scene director. We needed
    to initialize our `NSMutableDictionary`. We can do this using the typical `alloc`-and-`init`
    combination or, alternatively, with the more terse `@{}` notation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实现了场景导演的初始化器。我们需要初始化我们的 `NSMutableDictionary`。我们可以使用典型的 `alloc`-and-`init`
    组合，或者，作为替代，使用更简洁的 `@{}` 语法。
- en: We implemented the longer `addScene` method first; we set the scene name to
    the `name` parameter. This overwrites the scene name, even if one has already
    been given. We then added the scene to the dictionary, using the square bracket
    notation which does the same work as `[_dict setObject:scene forKey:name]`. In
    the next line, we set the reference of the `director` property within a scene
    to the current scene director instance. This is needed; in any other case, we
    wouldn't have an option to switch from one scene to another within a scene. We
    also add the scene to the display tree of the current `SceneDirector` instance.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现了较长的 `addScene` 方法；我们将场景名称设置为 `name` 参数。这将覆盖场景名称，即使已经给出了一个。然后我们使用方括号表示法将场景添加到字典中，这与
    `[_dict setObject:scene forKey:name]` 做的是同样的工作。在下一行中，我们将场景中的 `director` 属性的引用设置为当前场景导演实例。这是必需的；在其他情况下，我们就没有从场景切换到另一个场景的选项。我们还添加了场景到当前
    `SceneDirector` 实例的显示树中。
- en: When implementing the shorter `addScene`, we can just call the longer `addScene`
    method and pass it in the name from the current scene as its second parameter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现较短的 `addScene` 方法时，我们只需调用较长的 `addScene` 方法，并将当前场景的名称作为其第二个参数传递。
- en: The last step is all about showing the scene that has been specified as the
    parameter. First, we iterated through all elements in the dictionary, and set
    its visibility to `NO` so it won't show up on the screen; yes, even the scene
    we want to show. Then, we specifically looked for our scene in the dictionary
    and set its visibility to `YES`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是展示已指定为参数的场景。首先，我们遍历字典中的所有元素，并将其可见性设置为`NO`，这样它就不会显示在屏幕上；是的，即使是我们要展示的场景。然后，我们在字典中特别寻找我们的场景，并将其可见性设置为`YES`。
- en: Have a go hero
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Currently, we are loading all our scenes at once. This works for now, but as
    soon as we have a lot of scenes, we may be short on memory. To counteract this
    behavior, we can just have one scene in the memory at the same time. We may need
    to have a reference from our asset to our scene so that we know which asset belongs
    to which scene.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们一次性加载所有场景。这目前是可行的，但随着场景数量的增加，我们可能会遇到内存不足的问题。为了解决这个问题，我们可以同时只保留一个场景在内存中。我们可能需要从我们的资产到场景的引用，以便知道哪个资产属于哪个场景。
- en: Pop quiz
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Can a binary data file be considered as an asset?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 二进制数据文件可以被视为资产吗？
- en: 'Yes'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是
- en: Q2\. Why should we primarily cache our assets in order to reuse already loaded
    assets?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 为什么我们应该首先缓存我们的资产以便重用已加载的资产？
- en: To reduce CPU cycles
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少CPU周期
- en: To save memory
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省内存
- en: To save disk space
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节省磁盘空间
- en: Q3\. Can a texture (as in `SPTexture`) be drawn to the screen directly?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 纹理（如`SPTexture`）可以直接绘制到屏幕上吗？
- en: 'Yes'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot about asset and scene management in this chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于资产和场景管理的内容。
- en: Specifically, we covered how to handle different kinds of assets, cache already
    loaded files, and implement scenes and mechanisms to manage these scenes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了如何处理不同类型的资产、缓存已加载的文件以及实现场景和机制来管理这些场景。
- en: We also touched on some topics such as textures and displaying an image on the
    screen.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涉及了一些主题，例如纹理和屏幕上显示图像。
- en: Now that we know how to handle assets and scenes, we're ready to add the basics
    of our game—which is the topic of the next chapter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理资产和场景，我们准备添加游戏的基础内容——这是下一章的主题。
