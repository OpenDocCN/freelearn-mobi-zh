- en: Chapter 3. Managing Assets and Scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we drew our first display objects on the screen,
    which in our case were quads. We made a cardboard puppet doll out of quads and
    learned how to use macros. There is one last thing we need to know before developing
    our pirate game. In this chapter, we will learn about managing our assets, such
    as images, sound, and other kinds of files. We will also learn how to group elements
    into scenes and display these scenes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Working with assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop a game, we load files. We probably load a lot of images too.
    These images are displayed on the screen and are the graphics of any 2D game.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to load sound files for playing music and sound effects. Other
    general purpose files include text files that are either localization or game
    information files, such as hit points for enemies, attack strength, or similar
    data that affects the gameplay of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Game-relevant data may include saved games and level data. This gameplay-relevant
    data may not always be plain text; in some cases, they are binary files or they
    use a markup language such as XML or JSON. In the iOS and Mac world, the PLIST
    file format is very common and contains a specialized kind of XML format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with assets](img/1509OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In some games, game engines and game frameworks go a step further when dealing
    with gameplay-relevant data in order to be more dynamic. They allow scripting
    through languages such as Lua and JavaScript. These scripts are loaded and executed
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Managing our assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what assets are, how can we manage them for our game? Before
    we get to that, let's take a look at what we know so far and what the prerequisites
    to effectively load assets are.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we know that there are different kinds of assets that can either be
    plain text files or binary.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is the memory in mobile devices nowadays. While it
    is the same as the memory in desktop devices from a few years back, not all of
    this is reserved for our application. We should also keep in mind that the size
    of an asset on the disk may not be the same in memory as it is for compressed
    files, especially if the file content is compressed on the disk but has to be
    uncompressed in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, there are a few things we can do, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the number of assets we are loading; this can prove difficult as a game
    can require a high amount of assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of assets that are currently loaded in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache assets that are already loaded so that we don't have the same content
    in memory two or more times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a base class that manages a group of assets.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a base class to manage our assets, we need to use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Xcode game template if it's not already open, right-click on the **Classes**
    folder, select **New Group**, and rename the group to **Assets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Assets** group and select **New File...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Objective-C class** and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `AssetsDictionary` in the name field, select **NSObject** from the **Subclass
    of** entry, and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next dialog, click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `AssetsDictionary.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance variable called `_dict`, which is a pointer to `NSMutableDictionary`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a property called `verbose`, which is of type `BOOL`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance method called `registerAsset`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another instance method called `unregisterAsset`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a third instance method called `clear`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now switch to `AssetsDictionary.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an initializer with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `registerAsset` method with the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `unregisterAsset` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `clear` method that should reset the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Game.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `AssetsDictionary.h` file in the `import` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `init` method, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example, and you will get the following output:![Time for action – creating
    a base class](img/1509OS_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. Then, we created a new group where we put everything that relates to
    the management of our assets. Finally, we renamed the newly created group.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we created a new file. In step 3, we selected **Objective-C class**
    from the dialog that popped up. We wanted the class name to be `AssetsDictionary`,
    which is what we entered in step 4; we also confirmed the location where it is
    going to be saved on the hard drive in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we opened the header file and an instance variable to store the name and
    content of an asset. For this, we needed it to be an instance of `NSMutableDictionary`.
    Objective-C Cocoa classes such as `NSDictionary` can be mutable or immutable;
    the contents of mutable classes can change, and the values of immutable classes
    are fixed to the values used when declaring the object.
  prefs: []
  type: TYPE_NORMAL
- en: Though we put the interface section in the header, it is also possible to put
    it right before the implementation section.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we added a property called `verbose`, which is of type `BOOL`. If
    this property is set to `YES`, once an asset is registered, it should write a
    message telling us whether the asset is already in cache. It is sufficient to
    say that its default value should be `NO` so that our console message box is not
    cluttered with messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We needed to define our method that handles the registering and serving of
    our assets. It takes two parameters: the name of an asset and the content of an
    asset. It returns the content of the asset. Since the content of the asset can
    be anything—but is in most cases an instance of some sort—the type `id` seems
    like the best option here. The type `id` can stand for any class instance; if
    put to a technical term, it''s called dynamic typing.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we defined two methods; the first explains how to delete a single asset
    from the cache (step 10), and the second method explains how to clear all assets
    (step 11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our header file is done; now, let''s get to the actual implementation. First
    off, switch to the `AssetsDictionary.m` file. In step 13, we added an initializer,
    which does the following two things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the `_dict` dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `verbose` property to `NO` by using its instance variable `_verbose`.
    This is generally not needed as `NO` is the default value for `BOOL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next step, we implemented the `registerAsset` method. If the key—our
    first parameter—does not exist in the dictionary, we add it to the dictionary
    and return the content of the asset. If it exists, we look up the value from the
    dictionary and return it. In both cases, if the `verbose` property is set to `YES`,
    we will print a fitting message to reflect the current state of the asset.
  prefs: []
  type: TYPE_NORMAL
- en: In step 15, we defined a method that allows us to delete a single asset from
    the cache. In step 16 on the other hand, we defined a method to clear the complete
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `AssetsDictionary` class is ready for action, let's put it up for
    a test. In step 17, we switched to our `Game.m` file and subsequently imported
    the `AssetsDictionary` header in step 18.
  prefs: []
  type: TYPE_NORMAL
- en: Next, within the initializer of our `Game` class, we defined an instance of
    our `AssetsDictionary` class, set the `verbose` property to `YES`, and registered
    the same asset twice to see whether it will be cached correctly. In the last step,
    we ran the example and looked at the output in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While this class works for our purposes, we could improve the `AssetsDictionary`
    class further. Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When getting the cached value of an asset, we look for the value from the dictionary
    twice: the first time when checking whether the key is in the dictionary, and
    the second time when getting the actual value. This may result in a performance
    penalty when loading the assets into the game if there is a huge amount of assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to use `NSCache` instead of `NSMutableDictionary`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to display progress bars to see how far the loading process currently
    is, we will need a way to get the number of currently registered assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also have an `exists` method that checks whether an asset has already
    been registered and returns the result of this check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add more initializers that take `NSDictionary`, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a texture manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we load an image in Sparrow, we typically want it to be a texture. A texture
    is pixel information that makes up an image. It's conceptually similar to how
    the `BitmapData` class works in ActionScript 3\. If we want it to be displayed
    on the screen, it needs to be put on a geometrical representation, which is typically
    a quad.
  prefs: []
  type: TYPE_NORMAL
- en: The way we want our texture manager to work is to pass in a filename, which
    will be converted to a texture and is then available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use `AssetsDictionary` for our texture manager.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – managing our textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our texture manager, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Objective-C class called `TextureManager` derived from `AssetsDictionary`
    within the **Assets** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance method that will register a texture using its filename and
    return the correct value, which is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to `TextureManager.m` and implement the method with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Game.m` file, and replace the `AssetsDictionary.h` import with
    the `TextureManager.h` file in the `import` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `init` method, replace the `AssetsDictionary` test we did earlier in
    the chapter with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example, and you will get the following output:![Time for action – managing
    our textures](img/1509OS_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first step, we created a `TextureManager` class, which is a subclass
    of `AssetsDictionary`. In step 2, we defined the `registerTexture` instance method,
    which we implemented in the next step. A lot happened in this one line, explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an instance of `SPTexture` with the contents of the filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We registered this instance to utilize `registerAsset` we implemented earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We returned the result of the called method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the result is of the type `id`, we cast it to `SPTexture`— the type we
    want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we go ahead and switch to the `Game.m` file. We replace the line `#import
    "AssetsDictionary.h"` with `#import "TextureManager.h"`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delete the example where we tested out the `registerAsset` method from
    `AssetsDictionary`. After this, we set up the same test; however, this time we
    use the `TextureManager` class and the `registerTexture` method. We load the `Default.png`
    file, which is in the `Resources` folder and is currently just a black image.
    The `Default.png` file is part of the original Sparrow barebone template.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the example, it loads the image from file the first time, and then
    it uses the cached result.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sound manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the texture manager, let's create the sound manager that is
    going to be very similar to the previous piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing a sound manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the sound manager, just follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Objective-C class called `SoundManager` derived from `AssetsDictionary`
    within the **Assets** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance method that will register a sound using its filename and return
    the correct value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the method from the previous step with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we created a `SoundManager` class, which is a subclass of
    `AssetsDictionary`. In step 2, we defined the `registerSound` method, which we
    implemented in the next step; this method loads a sound from file and returns
    the result of the registered asset.
  prefs: []
  type: TYPE_NORMAL
- en: It is very similar to `TextureManager`, but instead of a texture and `SPTexture`,
    we loaded a sound using `SPSound`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is all we will do for sounds and sound management since we don't
    have any sound assets to load.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we almost have a manager for all kinds of assets we want to use. The last
    thing we need is a manager for our data. We know that data assets can be pretty
    much anything, so we need to descope the use case for managing data assets. Let''s
    take a look at what we''ll need right now:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a plain text file is always a useful piece of functionality. It could
    contain game texts or a basic level layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSDictionary` and `NSMutableDictionary` are classes we already used and will
    be using to store data. How about we load a file and its content is converted
    to a structure similar to that of `NSDictionary`? The JSON format is very similar
    to a structure we find in `NSDictionary`, and luckily, since iOS 5, we have the
    means of converting a JSON file into `NSDictionary` without needing any third-party
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – managing remaining file types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an asset manager for our files, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Objective-C class called `FileManager`, which is derived from `AssetsDictionary`
    within the **Assets** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an instance method called `registerPlainText`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define another instance method called `registerDictionaryFromJSON`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `registerPlainText` method with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `registerDictionaryFromJSON` method with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `example.json` file to the `Resource` folder by right-clicking on the
    `Resources` folder and selecting **New File...**. Select **Other** from the tab
    and create an empty file. Fill it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add `example.txt` to the `Resource` folder, which has the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that all of our data and the `FileManager` class is set up, let's give it
    a spin. Switch to `Game.m`, remove the pieces of code that tested our previous
    asset managers, and import the `FileManager` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following piece of code to the initializer method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example, and see the following output:![Time for action – managing remaining
    file types](img/1509OS_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we created a `FileManager` class, which is a subclass of
    `AssetsDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two steps, we defined two instance methods: one for loading plain
    text files and another for loading JSON files.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we implemented the `registerPlainText` method. We could have put
    it all in a one liner, but that would make it a bit cramped and harder to read.
    So, if the asset was registered, we returned it using the `registerAsset` method.
    We don't need to pass in content this time as the content is already in the dictionary.
    If it is not registered, we need the path to the filename first. Like every resource
    we want to load from the **Resource** folder, without the help of third-party
    libraries, we need to get the exact file location. The `[[NSBundle mainBundle]
    pathForResource]` method gives us the exact file location if we pass a filename.
    The main bundle represents the application bundle of the current app. In the next
    line, we loaded the file into an `NSString`, and the encoding is UTF-8\. We then
    returned the result that had been passed through the `registerAsset` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we implemented the `registerDictionaryFromJSON` method that
    works pretty much in the same way as the `registerPlainText` method. However,
    instead of loading the file into an `NSString`, we used an `NSData` object. We
    then converted the file contents through the `NSJSONSerialization` class, which
    offers the `JSONObjectWithData` method. We don't really need to pass in any kind
    of special options right now.
  prefs: []
  type: TYPE_NORMAL
- en: We added an `example.json` file, which has one key that is a string value and
    two keys that have number values. In a JSON structure, a key has to be written
    in double quotes and is a string. A value can either be an array, a string, a
    number, a Boolean, a null, or an object. If a value is an object, it can have
    keys and values by itself. So, it can map the structure of `NSDictionary` pretty
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the JSON format, take a look at [http://json.org/](http://json.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we added an `example.txt` file and added some content.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we removed all pieces of code from the previous example and imported
    the `FileManager` header file. We set up the file manager like how we did in the
    previous example. We then called the `registerDictionaryFromJSON` method with
    `example.json` as its parameter. We already know that we can access values from
    an `NSDictionary` instance through the `objectForKey` method, but we can also
    use the square bracket notation, which is more terse and easier to read. Just
    keep in mind that the square bracket notation for keys requires an `NSString`
    instance. Values, on the other hand, can be any object or `@` literal such as
    `@YES`, `@1`, or `@"MyValue"`. Then, we loaded the `example.txt` file and displayed
    it using `NSLog`.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we saw when and how the assets were being loaded and
    the results of the loaded assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `FileManager.h` file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `FileManager.m` file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our file manager works exactly like we want it to work. There is one little
    problem if we want to load the same asset as plain text and convert it to `NSDictionary`
    from a JSON file. Since we only use a single dictionary for all the file elements,
    if we load an asset with the `registerDictionaryFromJSON` method first and later
    load the same asset with the `registerPlainText` method, we will get `NSDictionary`
    converted into an `NSString` instead of the text file directly being loaded and
    added to the dictionary as an `NSString`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the file manager, we haven't set up any error handling. So, if a file does
    not exist, the application will probably crash and we will be left guessing why
    nothing is happening, without any clue how to proceed. For now, we will add some
    error handling to the `registerPlainText` method.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – getting started with basic error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add some basic error handling, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `FileManager.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `registerPlainText` method to match the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While try-catch blocks are available in Objective-C, it's generally not a good
    idea to use them as they are quite slow and they can become quite difficult to
    handle if they are too nested.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need is an error object that is a pointer to `NSError`. When
    loading the text file, we apply the error handling. If there are any errors when
    loading the file, the error object is not nil anymore. If this is the case, we
    log the error.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most basic error handling at the moment. Here are some suggestions
    on how to improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: Catch the case if a JSON file cannot be loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch the case if an invalid JSON file is being processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an `NSError` parameter to register the assets in the file manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a couple of different asset managers. It's time to put it all together
    so that we don't have to instantiate the different managers when we want to use
    an asset.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating an asset container class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To put all of our asset managers into one single class, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Objective-C class called `Assets` derived from `NSObject` within the
    **Assets** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a static method for each kind of asset, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Asset.m` file, import all asset managers, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each manager, add a static variable with the appropriate type and set its
    values to `nil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to overwrite the internal static `initialize` method. Use the following
    piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement each of the static methods by using the correct instance method from
    each of the asset managers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the `Game.m` file and update the previous example to use the static
    `Assets` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example. When we check the console, we should see something like what's
    shown in the following screenshot:![Time for action – creating an asset container
    class](img/1509OS_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we created an `Assets` class, which is a subclass of `NSObject`.
  prefs: []
  type: TYPE_NORMAL
- en: We defined a static method for each of the asset manager instance methods, such
    as `texture` for `registerTexture` and `sound` for `registerSound`. Then, we proceeded
    to the implementation part.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each asset manager, we defined a static variable: `textureAssets` for our
    `TextureManager` class, `textureSounds` for our `SoundManager` class, and so on.
    We set these instances to `nil`.'
  prefs: []
  type: TYPE_NORMAL
- en: We had overridden the internal `NSObject` initialize method, which is called
    once internally and does not need to be called by us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about how the initialize method of `NSObject` works can be
    found in the Apple documentation at [https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize](https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/initialize).
  prefs: []
  type: TYPE_NORMAL
- en: In the `initialize` method, we allocated and initialized each of the instances
    if its value was `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing each of the static methods in the next step, we needed to
    call the corresponding instance method, such as `[textureAssets registerTexture:filename]`
    for the texture method, and we should not forget that we had to return the value
    of the instance method.
  prefs: []
  type: TYPE_NORMAL
- en: To use the static `Assets` class in our game file, we needed to update the reference
    to the header file and use the `dictionaryFromJSON` and `plainText` methods from
    the static class.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we saw an output similar to the previous example, where
    we loaded files through the `FileManager`, but in this case we didn't have any
    message about the assets' statuses as the `verbose` flag was not set to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Assets.h` file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Assets.m` file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Before we continue with scene management, let's take a look at how we can use
    the static `Assets` class when displaying an image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display an image, we just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Game` initializer method, add the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the bottom of the initializer method, add the image to the display tree of
    the `Game` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example, and you will see the following:![Time for action – displaying
    an image](img/1509OS_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already know, we need the `SPImage` class to display a texture. It can
    be compared to `SPQuad`, but instead of just displaying a color, it displays the
    texture on itself. We used the `Assets` class to get our `Default.png` image from
    the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we added the image to the display tree of our game class using
    the `addChild` method. Running the example we should see that our cardboard puppet
    doll is not visible anymore because the black image we just loaded is displayed
    on top of the cardboard puppet doll.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Game.m` file should have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our asset management system is done, let''s discuss a few ways in
    which we can improve the setup, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, if we pass text files into the texture manager, it may load, but
    it may lead to unexpected results once we try to display the texture on the screen.
    We can check for the file extension and only load the asset if it has the correct
    file extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we go one step further, we can try to automatically detect which asset we
    want to load by its mime type or, if that's not enough, we can try to detect the
    file format through the magic byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We tested for the functionality of our asset manager, but if we want more thorough
    tests, we may want to resort to unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are scenes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical game, we have a main menu, an options menu, possibly a credits
    screen, and of course the game itself. We can have all this in a single file,
    but that will become difficult to maintain after a while. So, it will be a good
    idea to group these elements into separate entities, which in our case are scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In games that depend on having a lot of levels, such as point'n'click games,
    it's also a good idea to have scenes for each level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing a scene class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a scene class, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new group called **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Objective-C class called `Scene`, which is derived from the `SPSprite`
    class, and save it in the **Scene** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property called `guiLayer`, which is a `SPSPrite` type, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another property called `name`, which is an `NSString`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a third property called `director`, which is an `id`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an initializer that initializes the properties of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a second initializer that sets the name of the scene; this should be called
    `initWithName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, we don't have any scenes, so we can't run the example just yet.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we set up the `Scene` class, which needs to be a subclass of `SPSprite`
    because it needs to be added somewhere and we want to allow all kinds of display
    objects to be added to the `scene` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We defined three properties; `guiLayer` should be the sprite where all our user
    interface-relevant display objects will be added, `name` should be the name of
    the scene itself, and `director` should be the reference to its parent object.
    In the `init` method, we set default values for these properties. We also added
    a second initializer, which takes a parameter that sets the name of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene director
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic `scene` class, we need something that can actually
    manage all the scenes we want to add.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – managing our scenes with a scene director
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the scene director, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Objective-C class called `SceneDirector`, which is derived from
    the `SPSprite` class, and save it in the **Scene** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance variable called `_dict`, which is an `NSMutableDictionary` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance method that will add a scene to the scene director, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a second instance method that will add a scene, but this time you are also
    able to define/overwrite the name of the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance method that will show a scene and take `NSString` as its parameter,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's switch to the implementation. The initializer should initialize the `_dict`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `addScene:(Scene *)scene withName:(NSString *)name` method with
    the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `addScene:(Scene *)scene` method should be implemented as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `showScene` method should have the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we created the class needed for the scene director. This
    needs to be a `SPSprite` because we want an instance of it to be added to the
    `Game` class, and the scenes that the scene director should mange can be added
    very easily to the scene director.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined two instance methods that add a scene: the first method takes the
    scene, and the second method takes the scene and a name.'
  prefs: []
  type: TYPE_NORMAL
- en: We also needed an instance that actually shows the scene; it takes a name as
    its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we implemented the initializer of the scene director. We needed
    to initialize our `NSMutableDictionary`. We can do this using the typical `alloc`-and-`init`
    combination or, alternatively, with the more terse `@{}` notation.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the longer `addScene` method first; we set the scene name to
    the `name` parameter. This overwrites the scene name, even if one has already
    been given. We then added the scene to the dictionary, using the square bracket
    notation which does the same work as `[_dict setObject:scene forKey:name]`. In
    the next line, we set the reference of the `director` property within a scene
    to the current scene director instance. This is needed; in any other case, we
    wouldn't have an option to switch from one scene to another within a scene. We
    also add the scene to the display tree of the current `SceneDirector` instance.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the shorter `addScene`, we can just call the longer `addScene`
    method and pass it in the name from the current scene as its second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is all about showing the scene that has been specified as the
    parameter. First, we iterated through all elements in the dictionary, and set
    its visibility to `NO` so it won't show up on the screen; yes, even the scene
    we want to show. Then, we specifically looked for our scene in the dictionary
    and set its visibility to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we are loading all our scenes at once. This works for now, but as
    soon as we have a lot of scenes, we may be short on memory. To counteract this
    behavior, we can just have one scene in the memory at the same time. We may need
    to have a reference from our asset to our scene so that we know which asset belongs
    to which scene.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Can a binary data file be considered as an asset?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Why should we primarily cache our assets in order to reuse already loaded
    assets?
  prefs: []
  type: TYPE_NORMAL
- en: To reduce CPU cycles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save disk space
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. Can a texture (as in `SPTexture`) be drawn to the screen directly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot about asset and scene management in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how to handle different kinds of assets, cache already
    loaded files, and implement scenes and mechanisms to manage these scenes.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched on some topics such as textures and displaying an image on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to handle assets and scenes, we're ready to add the basics
    of our game—which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
