- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Ocean Scene
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating an ocean scene. To do that, we will be
    revisiting the `Shape` protocol and `path` function that we used in the previous
    project to create the waves, as well as a new SwiftUI property called `animatableData`,
    which will help to make our curvy lines animate in a fluid wave-like motion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will also add an image of a buoy to our scene and animate it in multiple
    different ways, including moving it along an anchor point, rotating it around
    the center of this point, and making it rise up and down along the *y*-axis –
    so the buoy looks like it’s bobbing in the water.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will add some sound effects to the project to help it really come
    alive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wave’s offset property
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wave shape using the Shape protocol and Path function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the wave’s `animatableData` property
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `ContentView` for animation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating and animating the wave shape in the `ContentView`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an animated floating buoy to the ocean scene
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 10` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wave’s offset property
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s start by creating a new SwiftUI project – I’ll be calling it `Making
    Waves`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s add a new file that will be in charge of making the waves for the
    ocean. Press *Command* + *N* to create a new file, then select the `WaveView`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this new file, we will make some minor modifications to the structure
    so that it conforms to the Shape protocol, as we did in the previous project.
    So, at the top of the `WaveView` struct, right after its name, remove the `View`
    protocol and replace it with the `Shape` protocol. Also, remove the `body` property
    as we don’t need that here. The file should look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason why we removed the `body` property was that it was used to return
    a view; however, we will be returning a `path` variable that will hold the shape
    of the wave we want to animate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation we want to create will be a wavy line that moves up and down
    in a wave-like motion, on the *y* axis. We will need a variable to control this
    animation movement, so let’s add a variable inside the `WaveView` struct to handle
    this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It’s called `yOffset` because that’s what the variable will do: it will offset
    the line only on the *y* axis. It gets an initial value of `0.0`. Its type is
    set to `CGFloat`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We will need another special built-in Swift variable that will dynamically change
    the value of the `yOffset` variable and make things animate, called `animatableData`,
    but let’s first create the wave shape itself before adding that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: "Creating a wave shape using the Shape protocol and \LPath function"
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the wave shape, it’s easy – we just need to make three straight lines and
    one curved line and join them together. Think of it as a rectangle, with the top
    line of the rectangle being the curvy wave part (skip to *Figure 10**.4* to see
    what I mean).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于波形形状，这很简单——我们只需要画三条直线和一条曲线，并将它们连接起来。想象成一个矩形，矩形的顶部线是曲线波形部分（跳转到 *图 10**.4* 来看看我的意思）。
- en: 'Before we start adding the wave code, let’s first modify the `Previews` struct
    so that we can see the results of each line of code we add. Modify the code so
    it looks like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始添加波形代码之前，让我们首先修改 `Previews` 结构体，以便我们可以看到我们添加的每一行代码的结果。修改代码，使其看起来如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start off by giving the `yOffset` parameter in the `Previews` struct a value
    of `0.7`. This is a simple hardcoded value that allows us to display our wave
    shape in the previews on the right in Xcode. `yOffset` works by offsetting two
    control points in the Bezier curve – one control point will be offset in the up
    direction for the curvy line and the other control point will be offset in the
    down direction on the curvy line. The next line of code adds a stroke to the wave
    shape, so we can see it in the preview, and gives the wave a height of `250` points.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `Previews` 结构体的 `yOffset` 参数中设置一个值为 `0.7`。这是一个简单的硬编码值，允许我们在 Xcode 右侧的预览中显示我们的波形形状。`yOffset`
    通过偏移贝塞尔曲线中的两个控制点来工作——一个控制点将在曲线线上向上偏移，另一个控制点将在曲线线上向下偏移。下一行代码为波形形状添加了描边，以便我们可以在预览中看到它，并给波形一个
    `250` 点的高度。
- en: 'Now, with these changes in the previews, any code we add to the `WaveView`
    struct will immediately be visible in the previews. Let’s add the wave shape code
    now, small pieces of code at a time, so we can better understand how the wave
    shape is formed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着预览中的这些更改，我们添加到 `WaveView` 结构体中的任何代码都将立即在预览中可见。让我们现在添加波形形状代码，一次添加一小段代码，这样我们可以更好地理解波形形状是如何形成的：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first thing we do is create the `path` instance; this is the variable that
    we’re going to load up with all the lines that make the wave shape.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建 `path` 实例；这是我们将要加载所有构成波形线条的变量。
- en: The next line calls the `move_to` method. This is the method that starts the
    drawing of the shape you’re making; in this project, that’s the wave shape. The
    `to` parameter is asking where on the screen you want to add the first point.
    For that parameter, we pass in the value of `.zero`, which is another way of setting
    the *x*- and *y*-axis values to 0\. (We could simply write out the values as `X:`
    `0` and `Y:` `0`, but using `.zero` is easier.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用 `move_to` 方法。这是开始绘制你正在制作的形状的方法；在这个项目中，那就是波形形状。`to` 参数询问你希望在屏幕上的哪个位置添加第一个点。对于该参数，我们传递
    `.zero` 的值，这是将 *x* 和 *y* 轴值设置为 0 的另一种方式。（我们也可以简单地写出值作为 `X:` `0` 和 `Y:` `0`，但使用
    `.zero` 更容易。）
- en: The next line of code calls the `addLine` function, which simply draws a straight
    line. Its parameters need an X and Y value to know where to put the next point
    to draw the line. For those X and Y values, we pass in two helper functions called
    `minX` and `maxY`, which automatically get different points of the screen for
    us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码调用 `addLine` 函数，它只是简单地绘制一条直线。它的参数需要一个 X 和 Y 值来知道在哪里放置下一个点以绘制线条。对于这些 X 和
    Y 值，我们传递两个辅助函数 `minX` 和 `maxY`，它们会自动为我们获取屏幕上的不同点。
- en: The iPhone uses the X and Y coordinate system – X runs from left to right, and
    Y runs from top to bottom. The top-left corner of the iPhone screen would have
    the X and Y values of 0, 0\. As you move to the right of the screen, the X value
    increases, and as you move down the screen, the Y value increases. So, by using
    the `minX` function in the `addLine` parameter, it will place a point at the far
    left of the screen (the minimum location on the X-coordinate plane). We could
    hardcode a value instead, such as 50 or 100, but by using the `minX` function,
    it tells Xcode to place the point over to the far left of the screen. Though this
    may seem vague, it is helpful when considering that Apple devices have different
    screen sizes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 使用 X 和 Y 坐标系统——X 从左到右运行，Y 从上到下运行。iPhone 屏幕的左上角将具有 X 和 Y 值为 0, 0。当你向屏幕右侧移动时，X
    值增加，当你向屏幕下方移动时，Y 值增加。因此，通过在 `addLine` 参数中使用 `minX` 函数，它将在屏幕的远左端放置一个点（X 坐标平面上的最小位置）。我们也可以使用硬编码的值，例如
    50 或 100，但通过使用 `minX` 函数，它告诉 Xcode 将点放置在屏幕的远左端。虽然这可能看起来有些模糊，但在考虑到苹果设备具有不同的屏幕尺寸时，这很有帮助。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following are the Swift helper functions available for use to place points
    on the screen without hardcoding them: `minX`, `midX`, `maxX`, `minY`, `midY`,
    and `maxY`. The `midX` and `midY` functions, as you might imagine, add a point
    to the middle area of the screen, and `maxX` and `maxY`, when used together, add
    a point to the bottom-right area of the screen.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在屏幕上放置点而不进行硬编码时可以使用的Swift辅助函数：`minX`、`midX`、`maxX`、`minY`、`midY`和`maxY`。正如你可能想象的那样，`midX`和`midY`函数将点添加到屏幕的中间区域，而`maxX`和`maxY`，当一起使用时，将点添加到屏幕的右下角区域。
- en: 'Now, the result of that code is visible in the **Previews** window, showing
    a vertical straight line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该代码的结果在**预览**窗口中可见，显示一条垂直的直线：
- en: '![Figure 10.1: The first line ](img/B18674_10_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：第一行](img/B18674_10_01.jpg)'
- en: 'Figure 10.1: The first line'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：第一行
- en: The `move_to` and `addLine` functions have drawn a line down from the middle-left
    area of the screen to the bottom-left area of the screen. The length of the line
    is set by the `frame` modifier we used in the `Previews` struct. By adding a bigger
    value in the `frame` modifier’s parameter, you make the line bigger.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_to`和`addLine`函数已经从屏幕的中间左区域绘制了一条线到屏幕的左下区域。线的长度是由我们在`Previews`结构体中使用的`frame`修改器设置的。通过在`frame`修改器的参数中添加更大的值，你可以使线变得更长。'
- en: 'Now, with the first line of the wave shape done, let’s draw the second line
    – this will be a horizontal line that starts from the bottom of the first line
    and stretches to the right, across the screen. We can do this by adding the highlighted
    line to our existing code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，波形的第一行已经完成，让我们绘制第二行——这将是一条从第一行的底部开始并向右延伸到屏幕的横线。我们可以通过将高亮显示的线添加到现有代码中来实现这一点：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line of code calls the `addLine` function again, adding a point to the
    `maxX` and `maxY` locations. The result should now look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码再次调用了`addLine`函数，向`maxX`和`maxY`位置添加了一个点。现在结果应该看起来像这样：
- en: '![Figure 10.2: The second line ](img/B18674_10_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：第二行](img/B18674_10_02.jpg)'
- en: 'Figure 10.2: The second line'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：第二行
- en: 'With two lines and half of the wave shape done, let’s now add the third line,
    which is the last straight one. Add the following highlighted line to your existing
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了两条线和波形的一半，让我们现在添加第三条线，这是最后一条直线。将以下高亮显示的行添加到你的现有代码中：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line of code adds a point to the `maxX` (far-right) and `minY` (top-left)
    parts of the screen, so the result will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码向屏幕的`maxX`（最右侧）和`minY`（最左侧）部分添加了一个点，因此结果将看起来像这样：
- en: '![Figure 10.3: The third line ](img/B18674_10_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：第三行](img/B18674_10_03.jpg)'
- en: 'Figure 10.3: The third line'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：第三行
- en: 'Now that we have three straight lines, we just need to add the wavy line to
    the top to complete the wave shape. Let’s add that now:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了三条直线，我们只需要在顶部添加一条波浪线来完成波形。现在让我们添加它：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have used the `addCurve` function to create the Bezier curve. This
    has three parameters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`addCurve`函数来创建贝塞尔曲线。这个函数有三个参数。
- en: The first parameter, `to`, is for adding a point to the screen for drawing the
    curvy line. The previous line of code drew a line that ended at the top-right
    side of the rectangle, so from there, the `addCurve` function will draw to the
    `minX` and `minY` location, which is the top left of the rectangle, effectively
    closing off the shape.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`to`是用来在屏幕上添加一个点以绘制曲线的。上一行代码绘制了一条以矩形右上角为终点的线，因此从那里开始，`addCurve`函数将绘制到`minX`和`minY`位置，即矩形的左上角，从而有效地封闭了形状。
- en: The next two parameters are what are called `control1` and `control2` points,
    specifically. These parameters are here to accept values that will adjust the
    amount of curve in a line that pertains to the *y* axis – `control1` will adjust
    the right portion of the line and `control2` will adjust the left portion of the
    line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个参数被称为`control1`和`control2`点，具体来说。这些参数在这里是为了接受将调整与*y*轴相关的线条曲率的值——`control1`将调整线的右侧部分，而`control2`将调整线的左侧部分。
- en: To understand how these control points work, if we pass in a value of `0` to
    both parameters, then the line created will be straight, not a curvy one; that’s
    because a value of 0 does not alter those points up or down, thus the line remains
    straight. But by passing in floating-point values, the control points start to
    bend the line on the right and left sides by the given amount. The control points
    do not act on the right and left ends of the line; those are the connection points
    that close the wave shape. Instead, the control points are equally spaced and
    offset from the ends.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些控制点是如何工作的，如果我们向这两个参数传递一个 `0` 的值，那么创建的线条将是直的，而不是曲线；这是因为 `0` 的值不会改变这些点的上下位置，因此线条保持直线。但是通过传递浮点值，控制点开始根据给定的量在右侧和左侧弯曲线条。控制点不对线条的右侧和左侧端点起作用；那些是关闭波形形状的连接点。相反，控制点是均匀分布的，并从端点偏移。
- en: Looking at the values being used for the control points now, they have been
    computed to create a line that has a bend going upward on the right side and a
    bend going downward on the left side. The `x` values for `control1` and `control2`
    get their results by multiplying the `maxX` value by 0.45 (this is a hardcoded
    value and helps shape the bend in the line on the *x* axis).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看用于控制点的值，它们已经被计算出来，以创建一条右侧向上弯曲、左侧向下弯曲的线条。`control1` 和 `control2` 的 `x` 值通过将
    `maxX` 值乘以 0.45（这是一个硬编码的值，有助于在 *x* 轴上塑造线条的弯曲）来获得结果。
- en: On the other hand, the `y` values for `control1` and `control2` are computed
    a little differently. `control1` gets its value by subtracting the `minY` value
    by the result of multiplying `maxX` by the `yOffset` variable. `control2` gets
    its value by multiplying the `maxY` value by the `yOffset` value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`control1` 和 `control2` 的 `y` 值的计算方式略有不同。`control1` 通过从 `minY` 值中减去 `maxX`
    乘以 `yOffset` 变量的结果来获得其值。`control2` 通过将 `maxY` 值乘以 `yOffset` 值来获得其值。
- en: These computations may be a bit unclear at first, but when you complete the
    project and experiment with different parameter values, you will see how the math
    works to make the bend in the line move; the amount of movement is related directly
    to how big or small a value the `yOffset` variable has.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算一开始可能有些不清楚，但当你完成项目并尝试不同的参数值时，你会看到数学是如何工作的，使得线条的弯曲移动；移动的量直接与 `yOffset` 变量的值的大小或小有关。
- en: 'Let’s now have a look at the result of adding the control points:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看添加控制点后的结果：
- en: '![Figure 10.4: The completed wave shape ](img/B18674_10_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：完成的波形形状](img/B18674_10_04.jpg)'
- en: 'Figure 10.4: The completed wave shape'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：完成的波形形状
- en: Now, with all four lines completed, we have created the wave shape. Up next,
    we will make the shape come alive using a special Swift property called `animatableData`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成了四条线，我们已经创建了波形。接下来，我们将使用一个名为 `animatableData` 的特殊 Swift 属性使形状变得生动起来。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When working with the `path_in` function, as we are doing here, there is also
    another function that is used to close off the shape we are drawing out: `closeSubpath()`.
    This is helpful when closing the ends of a shape without needing to use the `addLine()`
    function and passing in X and Y points. We didn’t need to use it here because
    we drew the wave shape out and ended with the curvy line on top. If I drew the
    curvy line first and wanted to end with a straight line, then I could have used
    this function to save some code.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `path_in` 函数时，正如我们在这里所做的那样，还有一个用于关闭我们正在绘制的形状的函数：`closeSubpath()`。当不需要使用
    `addLine()` 函数并传入 X 和 Y 点来关闭形状的末端时，这很有用。我们在这里不需要使用它，因为我们绘制了波形，并以顶部的曲线线结束。如果我先画曲线线，然后想要以直线结束，那么我可以使用这个函数来节省一些代码。
- en: Adding the wave’s animatableData property
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加波形的 animatableData 属性
- en: 'We now have a wave shape that we can duplicate as many times as needed to create
    a layered ocean scene. However, those waves are still static, meaning they won’t
    do anything unless we have a way of changing the value in the `yOffset` variable.
    To accomplish that, we need to add one more important variable to the file here:
    `animatableData`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个波形形状，我们可以根据需要多次复制它来创建分层海洋场景。然而，这些波浪仍然是静态的，这意味着除非我们有改变 `yOffset` 变量值的方法，否则它们不会做任何事情。为了实现这一点，我们需要在此文件中添加一个额外的变量：`animatableData`。
- en: 'So, let’s add it right under the declaration of the `yOffset` variable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 `yOffset` 变量的声明下方添加它：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `animatableData` property is an instance of a Swift class called `Animatable`,
    and is a built-in Swift property that has a getter and a setter attached to it.
    Properties with getters and setters do just that: they get a value and set a value.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`animatableData` 属性是名为 `Animatable` 的 Swift 类的实例，并且是一个具有附加获取器和设置器的内置 Swift
    属性。具有获取器和设置器的属性正是这样做的：获取一个值并设置一个值。'
- en: 'Using the `animatableData` property provides a few benefits over animating
    with a simple `@State` property alone:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `animatableData` 属性与仅使用简单的 `@State` 属性进行动画相比，提供了一些好处：
- en: It allows you to declaratively specify that a view can be animated, making it
    clear to other developers (and to the framework) that the view is intended to
    be animated
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你声明性地指定一个视图可以进行动画，使其他开发者（以及框架）清楚地知道该视图旨在进行动画。
- en: It allows the framework to automatically interpolate between the old and new
    values, rather than requiring you to manually calculate the intermediate values
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许框架自动在旧值和新值之间进行插值，而不是要求你手动计算中间值。
- en: It allows you to use the `animation()` method to specify how the animation should
    be performed, such as the duration, curve, and delay
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你使用 `animation()` 方法来指定动画应该如何执行，例如持续时间、曲线和延迟。
- en: It allows you to use more advanced animation techniques, such as `animation(_:)`
    and `transition(_:)`, to specify the animation between different states of the
    view
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你使用更高级的动画技术，如 `animation(_:)` 和 `transition(_:)`，来指定视图不同状态之间的动画。
- en: In our project, we’re using the `animatableData` property to get and set the
    values of the wave’s control points. This getting and setting is happening constantly
    and thus making the value of the `yOffset` variable change constantly too. Since
    the `yOffset` variable is being used to create the curvy line inside the `path_in()`
    function, the result will be that the curvy line dynamically changes too.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用 `animatableData` 属性来获取和设置波形控制点的值。这种获取和设置是持续进行的，因此也会使 `yOffset`
    变量的值不断变化。由于 `yOffset` 变量用于在 `path_in()` 函数内部创建曲线，因此曲线也会动态变化。
- en: With the `animatableData` property in place, and the wave shape completed, we
    can proceed to the `ContentView`, where we will add the animation to the shape.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `animatableData` 属性就位，并且波形形状完成后，我们可以继续到 `ContentView`，在那里我们将动画添加到形状中。
- en: Setting up the ContentView for animation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为动画设置 ContentView
- en: 'Here, in the `ContentView`, we are ready to use the wave shape and add the
    animation to it. Let’s start by creating a new struct at the bottom of the file,
    just above the `Previews` struct, and call it `WaveCreation`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `ContentView` 中，我们准备使用波形形状并添加动画。让我们从在文件底部创建一个新的结构体开始，位于 `Previews` 结构体之上，并将其命名为
    `WaveCreation`：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This struct is very similar to the `ContentView` struct – it conforms to the
    `View` protocol, which means it must implement the `body` property. The `body`
    property itself will return a view, and that will be the animated wave. By the
    end of the next section, we will have created six waves in total, spaced out neatly
    inside of a stack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构体与 `ContentView` 结构体非常相似——它遵循 `View` 协议，这意味着它必须实现 `body` 属性。`body` 属性本身将返回一个视图，那将是动画波形。到下一节结束时，我们将总共创建六个波形，整齐地分布在栈内。
- en: 'We will need several variables to get this working, some for the animation
    and some that allow us to alter the size of the wave curve. Add the following
    code above the `body` property, inside the `WaveCreation` struct:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要几个变量来实现这一点，一些用于动画，一些允许我们改变波形曲线的大小。在 `WaveCreation` 结构体内部，在 `body` 属性上方添加以下代码：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are seven variables here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里共有七个变量：
- en: The first one is a `Binding` variable, which we will use in `ContentView` to
    start the animation when it is set to `true`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个 `Binding` 变量，我们将在 `ContentView` 中使用它，当它设置为 `true` 时开始动画。
- en: The next two variables are called `curveOne` and `curveTwo`, which will be used
    to set the size of the wave’s two curves. Remember the wavy line shape has two
    curves on it, and they were created using those two control points, one for the
    left curve of the wavy line and the other for the right curve of the wavy line.
    The `curveOne` and `curveTwo` variables will allow us to alter the size of those
    curves on that wavy line; a bigger value will give us a bigger curve, and so a
    bigger wave.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个变量被称为`curveOne`和`curveTwo`，它们将被用来设置波浪的两个曲线的大小。记住波浪线形状上有两个曲线，它们是通过这两个控制点创建的，一个用于波浪线的左侧曲线，另一个用于波浪线的右侧曲线。`curveOne`和`curveTwo`变量将允许我们改变波浪线上这些曲线的大小；更大的值将给我们更大的曲线，因此更大的波浪。
- en: Next is the `radius` variable, which allows us to set the radius on a shadow.
    I want to give each wave a shadow later and so this variable makes that customization
    easier.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`radius`变量，它允许我们设置阴影的半径。我打算稍后给每个波添加一个阴影，因此这个变量使得这种定制变得更加容易。
- en: The placement of these shadows is also important; we can control this placement
    with two variables, `shadowX` and `shadowY`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些阴影的位置也很重要；我们可以通过两个变量`shadowX`和`shadowY`来控制这种位置。
- en: Finally, the `duration` variable allows us to set the duration of the animation
    for each wave.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`duration`变量允许我们设置每个波浪动画的持续时间。
- en: 'With those variables in place, we only need a few lines of code to complete
    the `WaveCreation` struct. Those lines are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些变量就位后，我们只需要几行代码就可以完成`WaveCreation`结构体的创建。这些行如下：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line of code calls the `WaveView` struct, and that requires a value
    for its `yOffset` parameter. We’re passing in one of two values: when the `animateOffset`
    variable is `true`, we’re going to use the `curveOne` variable, which means that
    one of the curves on the wavy line will be animated on the *y* axis. But when
    the `animateOffset` variable is `false`, we will then use the `curveTwo` variable,
    which will control the opposite side of the wavy line on the *y* axis.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行调用了`WaveView`结构体，这需要为其`yOffset`参数提供一个值。我们传递两个值之一：当`animateOffset`变量为`true`时，我们将使用`curveOne`变量，这意味着波浪线上的一个曲线将在*y*轴上动画化。但是当`animateOffset`变量为`false`时，我们将使用`curveTwo`变量，这将控制波浪线的另一侧在*y*轴上的位置。
- en: The next line of code uses the `shadow` modifier to add a shadow to the wave.
    Looking at the parameters, the `color` parameter gets a gray color (which will
    look good against the blue waves), the `radius` parameter sets the size of the
    shadow, and the X and Y parameters allow us to adjust the shadow up, down, left,
    and right.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用`shadow`修饰符给波浪添加阴影。查看参数，`color`参数获取灰色颜色（与蓝色波浪搭配看起来很好），`radius`参数设置阴影的大小，X和Y参数允许我们调整阴影的上、下、左、右位置。
- en: Then, the final line adds the animation – this is an `easeInOut` timing curve,
    which means the animation will start slowly, then build up, and when it finishes,
    it will ease itself out slowly. The duration of the animation will be set using
    the `duration` variable, with `repeatForever` and `autoreverses` set to `true`.
    Then, for the `value` parameter, that gets the `animateOffset` variable to start
    the animation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后一行添加了动画——这是一个`easeInOut`时间曲线，这意味着动画将缓慢开始，然后逐渐增强，当它结束时，它会缓慢地结束。动画的持续时间将通过`duration`变量设置，`repeatForever`和`autoreverses`设置为`true`。然后，对于`value`参数，它获取`animateOffset`变量以开始动画。
- en: Now, rather than just having one wave in our scene, we will call this structure
    inside the `ContentView` six times to make the ocean.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们场景中不再只有一个波浪，我们将在`ContentView`中调用这个结构体六次来制作海洋。
- en: Duplicating and animating the wave shape in the ContentView
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`ContentView`中复制并动画化波浪形状
- en: 'When creating our ocean, we’ll stack six waves in our scene and stagger the
    animation values so that they animate at different times. Working in the `ContentView`
    file now, we’ll start by adding a variable inside the `ContentView` struct that
    will toggle the animation on:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建我们的海洋时，我们将在场景中堆叠六个波浪，并错开动画值，使它们在不同的时间动画化。现在在`ContentView`文件中工作，我们首先在`ContentView`结构体中添加一个变量来切换动画：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let’s add a `ZStack` that will hold all the waves, and inside that, let’s
    set the background to a blue sky color:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`ZStack`来容纳所有波浪，并在其中设置背景为蓝色天空颜色：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code adds a `blue` color with an opacity of `0.5` (50%) for the background,
    and then we stretch that background out all the way around the edges of the screen
    using the `edgesIgnoreSafeArea` modifier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为背景添加了不透明度为`0.5`（50%）的`blue`颜色，然后我们使用`edgesIgnoreSafeArea`修饰符将背景拉伸到屏幕的边缘。
- en: 'We are now ready to add the first wave. So, add the following code directly
    underneath the `edgesIgnoring` modifier, inside the `ZStack`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备添加第一个波浪。因此，将以下代码直接添加到`edgesIgnoring`修饰符下方，在`ZStack`内部：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding the wave is simple because we have done all of the work already – here,
    we just call the `WaveCreation` struct and fill some values into its parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 添加波浪非常简单，因为我们已经完成了所有工作——在这里，我们只需调用`WaveCreation`结构体并填充一些值到其参数中。
- en: The first value is for the `animateOffset` parameter, a Boolean that will start
    the animation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值是用于`animateOffset`参数的，这是一个布尔值，用于启动动画。
- en: Then, the `curveOne` and `curveTwo` parameters require a value for both parts
    of the wavy line we made in `WaveView`. When you increase the value for one of
    the curve variables, you increase the height of the wave on one side. If you increase
    the size of both curve variables, you increase the height for both sides of the
    wave. Conversely, if you decrease the value for the curve variables by using negative
    numbers, then the wave gets smaller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`curveOne`和`curveTwo`参数需要为我们在`WaveView`中制作的波浪线的两部分提供值。当你增加曲线变量的值时，你增加了一侧波浪的高度。如果你增加两个曲线变量的值，你增加了波浪两侧的高度。相反，如果你通过使用负数来减少曲线变量的值，那么波浪就会变小。
- en: I’m using a small value here of `.05` and `-.05`. That’s because this is the
    first wave in the scene, and it will be further out to sea, so I want this wave
    to be a little calmer than the waves that are closer to the shore (and the user).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了一个小的值`.05`和`-.05`。这是因为这是场景中的第一个波浪，它将更远地延伸到海中，所以我希望这个波浪比靠近岸边（和用户）的波浪稍微平静一些。
- en: The next parameter is for the radius of the shadow. It’s set to `50`, which
    means it creates a shadow with a size of 50 points. The direction of the shadow
    will be controlled by the `shadowX` and `shadowY` properties – `shadowX` gets
    a value of `0` because I don’t want to move the shadow on the *x* axis left or
    right, but I do want to adjust it on the *y* axis, and a value of `50` points
    for the `shadowY` variable will bring the shadow upward by 50 points.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是用于阴影半径的。它设置为`50`，这意味着它创建了一个大小为50个点的阴影。阴影的方向将由`shadowX`和`shadowY`属性控制——`shadowX`的值为`0`，因为我不想在*x*轴上左右移动阴影，但我确实想在*y*轴上调整它，`shadowY`变量的`50`个点值将使阴影向上移动50个点。
- en: Then, we have the `duration` for the animation. We're setting it to `5` seconds
    to create the slower, calmer animation that we are aiming for with this first
    wave.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有动画的`duration`。我们将其设置为`5`秒，以创建我们希望通过这个第一个波浪实现的较慢、较平静的动画。
- en: Finally, We're setting the opacity of this wave to `.8`, so it’s slightly less
    opaque than some of the other waves that we will be adding. Then, we offset this
    wave using a value of `575` on the *y* axis, putting it toward the bottom of the
    screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这个波浪的不透明度设置为`.8`，使其比我们即将添加的其他波浪稍微不透明一些。然后，我们使用*y*轴上的`575`个点值来偏移这个波浪，将其放置在屏幕底部。
- en: 'That completes our first wave. To see this animation, all we have to do is
    toggle the `animateOffset` variable inside the `onAppear` modifier. Add this code
    right at the end of the `ZStack`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的第一个波浪。要查看这个动画，我们只需在`onAppear`修饰符内切换`animateOffset`变量。将此代码直接添加到`ZStack`的末尾：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that code in place, we can now run the app and see the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码就绪后，我们现在可以运行应用并查看结果：
- en: '![Figure 10.5: Our first wave ](img/B18674_10_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：我们的第一个波浪](img/B18674_10_05.jpg)'
- en: 'Figure 10.5: Our first wave'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：我们的第一个波浪
- en: The first wave has a smooth animation flowing back and forth, and we’re ready
    to build our next wave on top of it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个波浪有一个平滑的来回动画，我们现在准备好在上面构建我们的下一个波浪。
- en: 'The code for the rest of the waves is nearly identical except for the specific
    values that we have set in each parameter. Here is the code for the next five
    waves:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他波浪的代码几乎相同，只是每个参数中设置的特定值不同。以下是下一个五个波浪的代码：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the values here are different from those of the first wave –
    for example, wave 2 has larger values for the curve variables, and the radius
    is bigger as well; however, the duration of this wave is slightly shorter, with
    a value of `4` seconds, making the animation a little faster. Waves 3, 4, 5, and
    6 also have shorter durations, so we are increasing the speed of the animation
    for each wave as we move closer to the user’s point of view.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的值与第一波的值不同——例如，波浪2的曲线变量值更大，半径也更大；然而，这个波浪的持续时间略短，值为`4`秒，使得动画稍微快一些。波浪3、4、5和6也有更短的持续时间，因此，当我们接近用户的视角时，我们正在增加每个波浪的动画速度。
- en: The shadows vary too, adding a nice white cresting look to the wave and helping
    to delineate the waves from each other. I’m using a gray color for the shadows
    as it’s not too pronounced; however, you can try white if you prefer a brighter-looking
    wave.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影也各不相同，为波浪增添了一抹漂亮的白色浪尖效果，并有助于区分波浪彼此之间的界限。我使用灰色来表示阴影，因为它不是太突出；然而，如果你更喜欢看起来更亮的波浪，可以尝试使用白色。
- en: 'Now, go ahead and run the project in the simulator again and check out all
    the waves animating back and forth in our ocean scene:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请在模拟器中再次运行项目，并查看我们海洋场景中来回动画的所有波浪：
- en: '![Figure 10.6: All six waves together ](img/B18674_10_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：所有六个波浪一起](img/B18674_10_06.jpg)'
- en: 'Figure 10.6: All six waves together'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：所有六个波浪一起
- en: As with the first wave, the animation is smooth and rhythmic, and by piling
    up wave upon wave and offsetting each of them a little bit downward, we have created
    an ocean scene.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一波一样，动画平滑且富有节奏感，通过层层叠加波浪并将每个波浪略微向下偏移，我们创建了一个海洋场景。
- en: Next, we’re going to continue adding animations to the scene by adding a buoy
    that will bob up and down in the water, complete with a blinking light.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续向场景中添加动画，通过添加一个在水中上下起伏的浮标来实现，浮标上还配有闪烁的灯光。
- en: Adding an animated floating buoy to the ocean scene
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向海洋场景添加动画浮标
- en: 'When adding the buoy to our ocean scene, we will be giving it four different
    animations. It will do the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将浮标添加到我们的海洋场景中时，我们将给它四个不同的动画。它将执行以下操作：
- en: Have a blinking light at the top of it
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部有一个闪烁的灯光
- en: Tilt forward and backward
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前后倾斜
- en: Move up and down
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下移动
- en: Rotate along its leading anchor
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿其前导锚点旋转
- en: All of these animations will combine to create a realistic-looking bobbing effect
    that simulates a floating object in an ocean reacting to the waves and current.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些动画将结合在一起，创建一个逼真的起伏效果，模拟一个在海洋中漂浮的物体对波浪和洋流的反应。
- en: 'First, download the `buoy` image, which you can find in the `Chapter 10` folder
    in the GitHub repository, and add the image to the Assets catalog. Then, create
    a new SwiftUI View file, which we will call `BuoyView`. Inside the file, we will
    need six variables to get this buoy off the ground and into the water, so add
    the following code to the `BuoyView` struct:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载`buoy`图像，您可以在GitHub仓库中的`第10章`文件夹中找到它，并将图像添加到资产目录中。然后，创建一个新的SwiftUI视图文件，我们将称之为`BuoyView`。在文件中，我们需要六个变量来使这个浮标离开地面并进入水中，所以请将以下代码添加到`BuoyView`结构体中：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we are using three Boolean binding variables, which will oversee their
    respective animations: `tiltForwardBackward`, `upAndDown`, and `leadingAnchorAnimate`.
    Then, three `State` variables are used to make a blinking light animation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了三个布尔绑定变量，它们将监督各自的动画：`tiltForwardBackward`、`upAndDown`和`leadingAnchorAnimate`。然后，使用三个`State`变量来制作闪烁灯光动画。
- en: We just added some binding variables to the `BuoyView` struct, which will introduce
    some errors in the project. The reason why these errors occur is that anytime
    we add binding variables to the struct we are working in, we will need to add
    them in the `Preview` struct as well; otherwise, the previews will complain. The
    Preview struct’s job is to display all the code that’s written within the file,
    so it works hand in hand with the `BuoyView` struct.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚向`BuoyView`结构体中添加了一些绑定变量，这将在项目中引入一些错误。这些错误发生的原因是，每次我们向正在工作的结构体中添加绑定变量时，我们还需要在`Preview`结构体中添加它们；否则，预览将抱怨。`Preview`结构体的任务是显示文件中编写的所有代码，因此它与`BuoyView`结构体协同工作。
- en: 'So, modify the Preview struct code to look like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，修改Preview结构代码，使其看起来如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are now, once again, error-free.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次实现了无错误。
- en: 'Let’s now come into the `body` property and add a `ZStack`, then add the buoy
    image inside of the `ZStack`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入`body`属性，并添加一个`ZStack`，然后在`ZStack`内部添加浮标图像：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We should see the buoy in the previews now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在预览中应该可以看到浮标：
- en: '![Figure 10.7: The buoy ](img/B18674_10_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7：浮标](img/B18674_10_07.jpg)'
- en: 'Figure 10.7: The buoy'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：浮标
- en: We’re going to work on the blinking light first. In order to achieve this effect,
    we have to add a rectangle shape, place it on top of the buoy (inside the curved
    top), then give it some color, and finally toggle that color on and off to make
    it look like the light is blinking.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先处理闪烁的灯光。为了实现这个效果，我们必须添加一个矩形形状，将其放置在浮标顶部（在弯曲的顶部内部），然后给它一些颜色，最后切换颜色以使其看起来像灯光在闪烁。
- en: Making the buoy light blink
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作浮标灯光闪烁
- en: 'To start the process of creating the light, let’s overlay a rectangle on the
    buoy image. Add the following code to do that, right under the `Image` initializer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始创建灯光的过程，让我们在浮标图像上叠加一个矩形。将以下代码添加到`Image`初始化器下方以实现此操作：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the `overlay` modifier, which allows us to add a new view over an existing
    view, to create layers of views.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`overlay`修饰符，它允许我们在现有视图上添加新视图，以创建视图层。
- en: 'If you look in your previews, you will see that the rectangle we just added
    is much too big for what we need. So, there needs to be a little more stylizing
    and resizing of it. But before we go any further, let’s set the color variables
    to some initial values in the `onAppear` modifier so we can see our work progressing
    in the previews. Add this code to the end of the `ZStack`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看预览，你会看到我们刚刚添加的矩形对于我们的需求来说太大。因此，需要对它进行一些更多的样式化和调整大小。但在我们继续之前，让我们在`onAppear`修饰符中将颜色变量设置为一些初始值，这样我们就可以在预览中看到我们的工作进展。将以下代码添加到`ZStack`的末尾：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I’m setting the `red`, `green`, and `blue` variables to a value of `0.5` (50%).
    This equal combination of 50% for these RGB colors produces a gray or neutral
    color, which will look good blinking against the blue sky background later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`red`、`green`和`blue`变量设置为`0.5`（50%）。这些RGB颜色50%的等量组合产生灰色或中性颜色，这将与蓝色天空背景后面的闪烁效果很好。
- en: 'Next, coming back to the `Image` initializer, let’s add that neutral gray color
    to the rectangle using another `overlay` modifier and passing in the color variables.
    Be careful to place the new code directly in front of the overlay’s closing brace,
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回到`Image`初始化器，让我们使用另一个`overlay`修饰符和颜色变量将中性灰色添加到矩形中。请注意，将新代码直接放置在覆盖的闭合括号之前，如下所示：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we have a big gray rectangle, but we don’t see the buoy anymore because
    the rectangle is too big and needs to be resized. We are going to fix that. Add
    the following rectangle modifiers, which will size and position the rectangle,
    and place them directly inside the closing brace of the first `overlay` modifier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个大灰色的矩形，但我们看不到浮标了，因为矩形太大，需要调整大小。我们将解决这个问题。添加以下矩形修饰符，这将调整矩形的大小和位置，并将它们直接放置在第一个`overlay`修饰符的闭合括号内：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `frame` modifier sets the width and height of the rectangle to a small size
    of `12` by `17`. Then, the `position` modifier places the rectangle at the X and
    Y coordinates of `112.5` and `19.5`, which is at the top part of the buoy, the
    area that represents the light.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame`修饰符将矩形的高度和宽度设置为`12`乘以`17`的小尺寸。然后，`position`修饰符将矩形放置在X和Y坐标`112.5`和`19.5`处，这是浮标的顶部部分，代表灯光的区域。'
- en: 'You can see the rectangle in the following image:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图像中看到矩形：
- en: '![Figure 10.8: The buoy with the rectangle overlay ](img/B18674_10_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8：带有矩形覆盖的浮标](img/B18674_10_08.jpg)'
- en: 'Figure 10.8: The buoy with the rectangle overlay'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：带有矩形覆盖的浮标
- en: 'The rectangle looks good; however, a rectangle is, well, a rectangle. It has
    sharp corners on all four sides, whereas the top of the buoy has curved corners,
    as you can see in *Figure 10**.9*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形看起来不错；然而，一个矩形，嗯，就是一个矩形。它的四个边角都很尖锐，而浮标的顶部有圆角，正如你在*图10.9*中可以看到的：
- en: '![Figure 10.9: A closer look at the rectangle overlay ](img/B18674_10_09.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9：矩形覆盖的近距离观察](img/B18674_10_09.jpg)'
- en: 'Figure 10.9: A closer look at the rectangle overlay'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：矩形覆盖的近距离观察
- en: 'Using our current rectangle is a bit like fitting a square peg into a round
    hole. Luckily, SwiftUI does give us a modifier that rounds the corner radius of
    rectangles, but unluckily, there is still a problem with it: it rounds all four
    corners when all we want is for the top two corners to be rounded.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们当前的矩形有点像把方钉塞进圆孔。幸运的是，SwiftUI确实给了我们一个修饰符，可以圆角矩形的角落半径，但不幸的是，它仍然存在一个问题：它将所有四个角落都圆角了，而我们只想对顶部两个角落进行圆角处理。
- en: We could fix this by adding an extension to the corner radius modifier and altering
    its behavior so it will only act on two corners by writing numerous lines of code.
    However, a simpler way of achieving a two-corner radius modifier is by using the
    `padding` modifier in a unique way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个扩展到圆角修饰符并改变其行为，使其只对两个角起作用，通过编写多行代码来解决这个问题。然而，通过以独特的方式使用`padding`修饰符，我们可以以更简单的方式实现两个角的圆角修饰符。
- en: 'To do this, after the last variable in the `BuoyView` struct, add a constant
    to store the radius we want for rounding the two corners of our rectangle:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，在`BuoyView`结构体中的最后一个变量之后添加一个常量来存储我们想要用于圆角的两角半径：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’m calling this constant `cRadius`, for the corner radius, and setting it to
    a value of `8.0` points. The larger you make the corner radius value, the more
    rounded the rectangle becomes; for our purposes, an eight-point value adds just
    enough rounding to our rectangle’s two top corners to make it fit perfectly within
    the buoy light.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个常量命名为`cRadius`，代表圆角半径，并将其设置为8.0点。你使圆角半径值越大，矩形就越圆；就我们的目的而言，8点的值给矩形的两个顶部角添加了足够的圆角，使其完美地适合浮标灯。
- en: 'Add the following code, directly after the second `overlay` modifier, like
    this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`overlay`修饰符之后直接添加以下代码：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here’s what the code does. The `.padding(.bottom, cRadius)` line adds eight-point
    padding to the bottom of the rectangle. Then, we call the `cornerRadius` modifier,
    which will put a corner radius on all four corners of the rectangle. But since
    we have an eight-point padding on the bottom of the rectangle, we don’t see that
    corner radius placed on the bottom; we will only see the curved corners at the
    top of the rectangle, which is exactly what we want.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的作用。`.padding(.bottom, cRadius)`这一行给矩形的底部添加了8点的填充。然后，我们调用`cornerRadius`修饰符，这将在矩形的四个角上放置圆角。但由于矩形的底部有8点的填充，所以我们看不到底部放置的圆角；我们只会看到矩形顶部的圆角，这正是我们想要的。
- en: 'Finally, we call the `padding` modifier again, and again choose the `.bottom`
    option to place padding only on the bottom of the rectangle. This time, however,
    we set a value of `-8` points. When we make this option negative, it effectively
    extends the rectangle downward on the *y* axis – by 8 points – but preserves those
    two sharp corners that we want at the bottom. This is a pretty neat trick and
    saves us some time writing code in an extension for the `cornerRadius` modifier.
    This is the result we see in the previews now:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次调用`padding`修饰符，并再次选择`.bottom`选项，只在矩形的底部放置填充。然而，这次我们设置了一个-8点的值。当我们使这个选项为负值时，它实际上将矩形向下延伸在*y*轴上——8点——但保留了我们在底部想要的两个尖锐角。这是一个相当巧妙的技巧，节省了我们为`cornerRadius`修饰符编写代码的时间。这就是我们现在预览中看到的结果：
- en: '![Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy
    ](img/B18674_10_10.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：矩形覆盖现在适合浮标的弯曲尖端](img/B18674_10_10.jpg)'
- en: 'Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：矩形覆盖现在适合浮标的弯曲尖端
- en: The previews show that our gray rectangle now matches the curvature of the top
    portion of the light and has two sharp corners to match the bottom portion of
    the light.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 预览显示，我们的灰色矩形现在与灯的顶部部分曲线相匹配，并且有两个尖锐的角来匹配灯的底部部分。
- en: 'To finish off the light and make it blink, we only have to add one line of
    code after the last line of code in the `ZStack`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成灯光并使其闪烁，我们只需要在`ZStack`中的最后一行代码之后添加一行代码：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With that code in place, if you run the previews here in the `BuoyView` file,
    you’ll see that now we have a blinking light that will blink on and off for a
    duration of 1 second, repeating forever, or until the app stops:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BuoyView`文件中运行预览，现在你会看到我们有一个闪烁的灯，它会持续1秒的闪烁，然后重复进行，或者直到应用程序停止：
- en: '![Figure 10.11: The completed buoy with a blinking light ](img/B18674_10_11.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：带有闪烁灯的完成浮标](img/B18674_10_11.jpg)'
- en: 'Figure 10.11: The completed buoy with a blinking light'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：带有闪烁灯的完成浮标
- en: Let’s add the animations that make the buoy move now.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来添加使浮标移动的动画。
- en: Making the buoy move
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使浮标移动
- en: 'The first animation that we will add to make the buoy move will be to rotate
    the buoy along its leading anchor point. To do this, add the following code right
    after the previous line of code in the `ZStack`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的第一个动画是使浮标沿着其前导锚点旋转。为此，在`ZStack`中的上一行代码之后添加以下代码：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code uses the `rotationEffect` modifier and will rotate the buoy by either
    `7` degrees when the `leadingAnchorAnimate` property becomes `true`, or `-3` when
    it's `false`. For the `anchor` parameter, we used the `leading` anchor option,
    which pivots the image around the leading edge, but you can use the `bottom` option
    as well for a slightly different rotation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`rotationEffect`修饰符，当`leadingAnchorAnimate`属性变为`true`时，将浮标旋转`7`度，当它为`false`时，旋转`-3`度。对于`anchor`参数，我们使用了`leading`锚点选项，这会使图像围绕前边缘旋转，但您也可以使用`bottom`选项以获得不同的旋转效果。
- en: Then, we added the `animation` modifier, setting its `duration` to `0.9` seconds,
    with `repeatForever`, and `autoreverses` set to `true`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`animation`修饰符，将其`duration`设置为`0.9`秒，并设置为`repeatForever`，`autoreverses`设置为`true`。
- en: We will also toggle the `leadingAnchorAnimate` property to `true` in the `onAppear`
    modifier shortly, but first, let’s add the other two animations to the buoy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`onAppear`修饰符中将`leadingAnchorAnimate`属性切换为`true`，但首先，让我们将其他两个动画添加到浮标上。
- en: 'The next animation to add will make the buoy tilt forward and backward. Add
    the code for this right under the previous code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要添加的动画将使浮标前后倾斜。在上一行代码下方添加此代码：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The is almost identical to the previous code, but the value of `.rotationEffect`
    is now set to `tiltForwardBackward`. The amount of rotation or tilt forward and
    back is going to be either `-20` degrees or `15` degrees, depending on the value
    inside of the `tiltForwardBackward` variable. Also, in the `animation` modifier,
    we’re adding a slight delay of `0.2`, as this will help to add to a real-looking
    bobbing motion.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与之前的代码相同，但`.rotationEffect`的值现在设置为`tiltForwardBackward`。旋转或前后倾斜的量将是`-20`度或`15`度，具体取决于`tiltForwardBackward`变量中的值。此外，在`animation`修饰符中，我们添加了轻微的延迟`0.2`，这将有助于添加更逼真的摆动动作。
- en: 'Now, to add the final animation to the buoy, which will make the image move
    up and down, add this line of code directly after the previous code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了给浮标添加最后的动画，使其上下移动，请在上一行代码之后直接添加以下代码：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A negative value will move an image up the *y* axis and a positive value will
    move the image down the *y* axis. So, this code will move the entire buoy image
    10 points up or down depending on the `upAndDown` variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 负值将使图像沿*y*轴向上移动，正值将使图像沿*y*轴向下移动。因此，此代码将根据`upAndDown`变量将整个浮标图像向上或向下移动10点。
- en: 'The last bit of code we need in the `BuoyView` file is code that toggles on
    these three animations in the `onAppear` modifier. So, add the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BuoyView`文件中，我们需要的最后一部分代码是在`onAppear`修饰符中切换这三个动画的代码。所以，添加以下代码：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That completes the `BuoyView` file, and now we can proceed to `ContentView`
    and add the buoy to the scene.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`BuoyView`文件，现在我们可以继续到`ContentView`并添加浮标到场景中。
- en: Adding the buoy to the scene
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将浮标添加到场景中
- en: 'We want to place the buoy slightly in the distance of our ocean scene, so let’s
    add it right after wave 1\. Add the following code after the closing brace of
    the first wave:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将浮标放置在我们海洋场景的稍远位置，所以让我们在波1之后立即添加它。在第一个波浪的闭合花括号之后添加以下代码：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Inside the `BuoyView` initializer, we pass in the three binding properties that
    initiate three separate animations. We add a dollar sign before those binding
    properties, which tells the compiler that there’s a two-way binding between the
    `BuoyView` struct and the `ContentView` struct. Next, using the `offset` modifier,
    we can place the buoy at the proper height in the ocean scene.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BuoyView`初始化器内部，我们传递了三个绑定属性，这些属性启动了三个不同的动画。在这些绑定属性之前添加一个美元符号，这告诉编译器`BuoyView`结构和`ContentView`结构之间存在双向绑定。接下来，使用`offset`修饰符，我们可以将浮标放置在海洋场景的正确高度。
- en: 'Now, go ahead and run the project in the simulator to see the animations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请在模拟器中运行项目以查看动画：
- en: '![Figure 10.12: The completed animation ](img/B18674_10_12.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：完成的动画](img/B18674_10_12.jpg)'
- en: 'Figure 10.12: The completed animation'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：完成的动画
- en: Though the code for the waves and buoy work independently, the two elements
    visually work together to create our ocean scene.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然波浪和浮标的代码可以独立工作，但这两个元素在视觉上协同工作，共同创建我们的海洋场景。
- en: The final element that we can add next is some sound effects. How about the
    sound of some ocean waves and a buoy bell ringing in the background? That would
    really complete the project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来可以添加的最后一个元素是一些音效。如何？在背景中添加一些海浪声和浮标铃铛声？这将真正完成项目。
- en: Adding sound effects
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音效
- en: We already added sound in [*Chapter 4*](B18674_04.xhtml#_idTextAnchor060), when
    building the record player project, and there’s nothing complicated about it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第4章*](B18674_04.xhtml#_idTextAnchor060)中添加了声音，当时我们在构建唱片机项目时，这并没有什么复杂之处。
- en: First, start by creating a Swift file (just a Swift file, not a SwiftUI View
    one), and call it `PlaySound`. Next, drag the M4A sound effects file called `buoyBells`
    (which you can find on GitHub) and place it into the file navigator.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个Swift文件（只是一个Swift文件，而不是SwiftUI View文件），并将其命名为`PlaySound`。然后，将名为`buoyBells`的M4A声音效果文件（你可以在GitHub上找到）拖放到文件导航器中。
- en: 'Inside the `PlaySound` file, the first thing we need to do is import the AVFoundation
    framework:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlaySound`文件中，我们首先需要做的是导入AVFoundation框架：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The AVFoundation framework gives us access to all the classes and methods needed
    to add audio to a project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: AVFoundation框架为我们提供了添加音频到项目所需的所有类和方法。
- en: 'Next, create an `audioPlayer` object to play our sound file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`audioPlayer`对象来播放我们的声音文件：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This `audioPlayer` object is optional, which you can tell by the question mark
    at the end. It needs to be optional because the sound file may not exist for whatever
    reason – maybe the file gets corrupted, or the sound file has been downloaded
    from a server and the internet has timed out – and so this protects the project
    from crashing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`audioPlayer`对象是可选的，你可以通过末尾的问号来判断。它需要是可选的，因为声音文件可能因为任何原因不存在——比如文件损坏，或者声音文件已经从服务器下载并且网络超时了——这样就可以保护项目不会崩溃。
- en: 'Finally, under the previous line of code, all we need to do is add a function
    to handle the audio needs of this project:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在上一行代码下面，我们只需要添加一个函数来处理这个项目的音频需求：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The function is called `playSound`. It accepts two strings, one to hold the
    name of the file and another to hold the file’s extension type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被命名为`playSound`。它接受两个字符串，一个用于存储文件的名称，另一个用于存储文件的扩展类型。
- en: The first thing we do is try to access the sound file that’s in the app bundle
    by using the `path_forResource()` function. The app bundle is an internal hidden
    folder that is created for each app to hold all the necessary files to get the
    app up and running.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试通过使用`path_forResource()`函数访问应用包中的声音文件。应用包是一个为每个应用创建的内部隐藏文件夹，用于存放启动和运行应用所需的所有必要文件。
- en: If the file exists with the specified name and type, then the code proceeds
    into the `do` block and tries to create the audio player with the path of the
    file’s location stored in the `path` constant. If, for whatever reason, the file
    cannot be found or it’s corrupt, then the code will fall into the `catch` block
    and print out an error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在具有指定名称和类型的文件，则代码将进入`do`块，并尝试使用存储在`path`常量中的文件位置路径创建音频播放器。如果因为任何原因找不到文件或文件损坏，则代码将进入`catch`块并打印出错误。
- en: 'And that’s really it for the `PlaySound` file. Let’s go back into `ContentView`
    and add the sound effects to the project. In the `onAppear` modifier, set the
    sound to start playing with the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`PlaySound`文件来说，这就真的结束了。让我们回到`ContentView`，并将声音效果添加到项目中。在`onAppear`修饰符中，使用以下代码设置声音开始播放：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also need a way of stopping the sound too, when the app stops running on
    the device or the user closes the app. The way to make the sound stop is to call
    the `onDisappear` modifier, which we can use directly on the closing brace of
    the `onAppear` modifier, like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用在设备上停止运行或用户关闭应用时，我们还需要一种停止声音的方法。使声音停止的方法是调用`onDisappear`修饰符，我们可以在`onAppear`修饰符的闭合花括号上直接使用它，如下所示：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And with that, the project is complete!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，项目就完成了！
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an ocean scene, with moving waves and a bobbing
    buoy with a flashing light, and added some sounds too.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们创建了一个海洋场景，其中包括移动的波浪和带有闪烁灯光的漂浮浮标，还添加了一些声音。
- en: More specially, you used the Shape protocol, the `path` function, the `animatableData`
    property, and curve variables to make the wave shape come alive. When working
    on the buoy, we looked at how to combine multiple types of animation to create
    unique effects, and how to turn different colors on and off to create a blinking
    effect.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，你使用了Shape协议、`path`函数、`animatableData`属性和曲线变量来使波浪形状栩栩如生。当我们在浮标上工作时，我们研究了如何组合多种类型的动画来创建独特的效果，以及如何打开和关闭不同的颜色来创建闪烁效果。
- en: The parameters in this project are highly customizable, so feel free to experiment
    further – maybe you want to create bigger waves or more of them, create the waves
    in landscape orientation, alter the shadow to create a horizon, or even replace
    the buoy with a boat!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的参数高度可定制，所以请随意进一步实验——也许你想创建更大的波浪或更多波浪，以横向方向创建波浪，调整阴影以创建地平线，或者甚至用船替换浮标！
- en: Let’s keep going. In the next project, we will create a working elevator animation
    using timers and sound effects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。在下一个项目中，我们将使用计时器和音效创建一个工作电梯动画。
