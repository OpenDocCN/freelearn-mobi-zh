- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Ocean Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating an ocean scene. To do that, we will be
    revisiting the `Shape` protocol and `path` function that we used in the previous
    project to create the waves, as well as a new SwiftUI property called `animatableData`,
    which will help to make our curvy lines animate in a fluid wave-like motion.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add an image of a buoy to our scene and animate it in multiple
    different ways, including moving it along an anchor point, rotating it around
    the center of this point, and making it rise up and down along the *y*-axis –
    so the buoy looks like it’s bobbing in the water.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will add some sound effects to the project to help it really come
    alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wave’s offset property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wave shape using the Shape protocol and Path function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the wave’s `animatableData` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `ContentView` for animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating and animating the wave shape in the `ContentView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an animated floating buoy to the ocean scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 10` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wave’s offset property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s start by creating a new SwiftUI project – I’ll be calling it `Making
    Waves`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s add a new file that will be in charge of making the waves for the
    ocean. Press *Command* + *N* to create a new file, then select the `WaveView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this new file, we will make some minor modifications to the structure
    so that it conforms to the Shape protocol, as we did in the previous project.
    So, at the top of the `WaveView` struct, right after its name, remove the `View`
    protocol and replace it with the `Shape` protocol. Also, remove the `body` property
    as we don’t need that here. The file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The reason why we removed the `body` property was that it was used to return
    a view; however, we will be returning a `path` variable that will hold the shape
    of the wave we want to animate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation we want to create will be a wavy line that moves up and down
    in a wave-like motion, on the *y* axis. We will need a variable to control this
    animation movement, so let’s add a variable inside the `WaveView` struct to handle
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s called `yOffset` because that’s what the variable will do: it will offset
    the line only on the *y* axis. It gets an initial value of `0.0`. Its type is
    set to `CGFloat`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will need another special built-in Swift variable that will dynamically change
    the value of the `yOffset` variable and make things animate, called `animatableData`,
    but let’s first create the wave shape itself before adding that.
  prefs: []
  type: TYPE_NORMAL
- en: "Creating a wave shape using the Shape protocol and \LPath function"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the wave shape, it’s easy – we just need to make three straight lines and
    one curved line and join them together. Think of it as a rectangle, with the top
    line of the rectangle being the curvy wave part (skip to *Figure 10**.4* to see
    what I mean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start adding the wave code, let’s first modify the `Previews` struct
    so that we can see the results of each line of code we add. Modify the code so
    it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We start off by giving the `yOffset` parameter in the `Previews` struct a value
    of `0.7`. This is a simple hardcoded value that allows us to display our wave
    shape in the previews on the right in Xcode. `yOffset` works by offsetting two
    control points in the Bezier curve – one control point will be offset in the up
    direction for the curvy line and the other control point will be offset in the
    down direction on the curvy line. The next line of code adds a stroke to the wave
    shape, so we can see it in the preview, and gives the wave a height of `250` points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with these changes in the previews, any code we add to the `WaveView`
    struct will immediately be visible in the previews. Let’s add the wave shape code
    now, small pieces of code at a time, so we can better understand how the wave
    shape is formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create the `path` instance; this is the variable that
    we’re going to load up with all the lines that make the wave shape.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `move_to` method. This is the method that starts the
    drawing of the shape you’re making; in this project, that’s the wave shape. The
    `to` parameter is asking where on the screen you want to add the first point.
    For that parameter, we pass in the value of `.zero`, which is another way of setting
    the *x*- and *y*-axis values to 0\. (We could simply write out the values as `X:`
    `0` and `Y:` `0`, but using `.zero` is easier.)
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `addLine` function, which simply draws a straight
    line. Its parameters need an X and Y value to know where to put the next point
    to draw the line. For those X and Y values, we pass in two helper functions called
    `minX` and `maxY`, which automatically get different points of the screen for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: The iPhone uses the X and Y coordinate system – X runs from left to right, and
    Y runs from top to bottom. The top-left corner of the iPhone screen would have
    the X and Y values of 0, 0\. As you move to the right of the screen, the X value
    increases, and as you move down the screen, the Y value increases. So, by using
    the `minX` function in the `addLine` parameter, it will place a point at the far
    left of the screen (the minimum location on the X-coordinate plane). We could
    hardcode a value instead, such as 50 or 100, but by using the `minX` function,
    it tells Xcode to place the point over to the far left of the screen. Though this
    may seem vague, it is helpful when considering that Apple devices have different
    screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the Swift helper functions available for use to place points
    on the screen without hardcoding them: `minX`, `midX`, `maxX`, `minY`, `midY`,
    and `maxY`. The `midX` and `midY` functions, as you might imagine, add a point
    to the middle area of the screen, and `maxX` and `maxY`, when used together, add
    a point to the bottom-right area of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the result of that code is visible in the **Previews** window, showing
    a vertical straight line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The first line ](img/B18674_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The first line'
  prefs: []
  type: TYPE_NORMAL
- en: The `move_to` and `addLine` functions have drawn a line down from the middle-left
    area of the screen to the bottom-left area of the screen. The length of the line
    is set by the `frame` modifier we used in the `Previews` struct. By adding a bigger
    value in the `frame` modifier’s parameter, you make the line bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the first line of the wave shape done, let’s draw the second line
    – this will be a horizontal line that starts from the bottom of the first line
    and stretches to the right, across the screen. We can do this by adding the highlighted
    line to our existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code calls the `addLine` function again, adding a point to the
    `maxX` and `maxY` locations. The result should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The second line ](img/B18674_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The second line'
  prefs: []
  type: TYPE_NORMAL
- en: 'With two lines and half of the wave shape done, let’s now add the third line,
    which is the last straight one. Add the following highlighted line to your existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code adds a point to the `maxX` (far-right) and `minY` (top-left)
    parts of the screen, so the result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The third line ](img/B18674_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The third line'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have three straight lines, we just need to add the wavy line to
    the top to complete the wave shape. Let’s add that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `addCurve` function to create the Bezier curve. This
    has three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `to`, is for adding a point to the screen for drawing the
    curvy line. The previous line of code drew a line that ended at the top-right
    side of the rectangle, so from there, the `addCurve` function will draw to the
    `minX` and `minY` location, which is the top left of the rectangle, effectively
    closing off the shape.
  prefs: []
  type: TYPE_NORMAL
- en: The next two parameters are what are called `control1` and `control2` points,
    specifically. These parameters are here to accept values that will adjust the
    amount of curve in a line that pertains to the *y* axis – `control1` will adjust
    the right portion of the line and `control2` will adjust the left portion of the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how these control points work, if we pass in a value of `0` to
    both parameters, then the line created will be straight, not a curvy one; that’s
    because a value of 0 does not alter those points up or down, thus the line remains
    straight. But by passing in floating-point values, the control points start to
    bend the line on the right and left sides by the given amount. The control points
    do not act on the right and left ends of the line; those are the connection points
    that close the wave shape. Instead, the control points are equally spaced and
    offset from the ends.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the values being used for the control points now, they have been
    computed to create a line that has a bend going upward on the right side and a
    bend going downward on the left side. The `x` values for `control1` and `control2`
    get their results by multiplying the `maxX` value by 0.45 (this is a hardcoded
    value and helps shape the bend in the line on the *x* axis).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `y` values for `control1` and `control2` are computed
    a little differently. `control1` gets its value by subtracting the `minY` value
    by the result of multiplying `maxX` by the `yOffset` variable. `control2` gets
    its value by multiplying the `maxY` value by the `yOffset` value.
  prefs: []
  type: TYPE_NORMAL
- en: These computations may be a bit unclear at first, but when you complete the
    project and experiment with different parameter values, you will see how the math
    works to make the bend in the line move; the amount of movement is related directly
    to how big or small a value the `yOffset` variable has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now have a look at the result of adding the control points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The completed wave shape ](img/B18674_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The completed wave shape'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with all four lines completed, we have created the wave shape. Up next,
    we will make the shape come alive using a special Swift property called `animatableData`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the `path_in` function, as we are doing here, there is also
    another function that is used to close off the shape we are drawing out: `closeSubpath()`.
    This is helpful when closing the ends of a shape without needing to use the `addLine()`
    function and passing in X and Y points. We didn’t need to use it here because
    we drew the wave shape out and ended with the curvy line on top. If I drew the
    curvy line first and wanted to end with a straight line, then I could have used
    this function to save some code.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wave’s animatableData property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a wave shape that we can duplicate as many times as needed to create
    a layered ocean scene. However, those waves are still static, meaning they won’t
    do anything unless we have a way of changing the value in the `yOffset` variable.
    To accomplish that, we need to add one more important variable to the file here:
    `animatableData`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s add it right under the declaration of the `yOffset` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `animatableData` property is an instance of a Swift class called `Animatable`,
    and is a built-in Swift property that has a getter and a setter attached to it.
    Properties with getters and setters do just that: they get a value and set a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `animatableData` property provides a few benefits over animating
    with a simple `@State` property alone:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to declaratively specify that a view can be animated, making it
    clear to other developers (and to the framework) that the view is intended to
    be animated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the framework to automatically interpolate between the old and new
    values, rather than requiring you to manually calculate the intermediate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to use the `animation()` method to specify how the animation should
    be performed, such as the duration, curve, and delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to use more advanced animation techniques, such as `animation(_:)`
    and `transition(_:)`, to specify the animation between different states of the
    view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our project, we’re using the `animatableData` property to get and set the
    values of the wave’s control points. This getting and setting is happening constantly
    and thus making the value of the `yOffset` variable change constantly too. Since
    the `yOffset` variable is being used to create the curvy line inside the `path_in()`
    function, the result will be that the curvy line dynamically changes too.
  prefs: []
  type: TYPE_NORMAL
- en: With the `animatableData` property in place, and the wave shape completed, we
    can proceed to the `ContentView`, where we will add the animation to the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the ContentView for animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, in the `ContentView`, we are ready to use the wave shape and add the
    animation to it. Let’s start by creating a new struct at the bottom of the file,
    just above the `Previews` struct, and call it `WaveCreation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This struct is very similar to the `ContentView` struct – it conforms to the
    `View` protocol, which means it must implement the `body` property. The `body`
    property itself will return a view, and that will be the animated wave. By the
    end of the next section, we will have created six waves in total, spaced out neatly
    inside of a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need several variables to get this working, some for the animation
    and some that allow us to alter the size of the wave curve. Add the following
    code above the `body` property, inside the `WaveCreation` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are seven variables here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a `Binding` variable, which we will use in `ContentView` to
    start the animation when it is set to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two variables are called `curveOne` and `curveTwo`, which will be used
    to set the size of the wave’s two curves. Remember the wavy line shape has two
    curves on it, and they were created using those two control points, one for the
    left curve of the wavy line and the other for the right curve of the wavy line.
    The `curveOne` and `curveTwo` variables will allow us to alter the size of those
    curves on that wavy line; a bigger value will give us a bigger curve, and so a
    bigger wave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `radius` variable, which allows us to set the radius on a shadow.
    I want to give each wave a shadow later and so this variable makes that customization
    easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The placement of these shadows is also important; we can control this placement
    with two variables, `shadowX` and `shadowY`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `duration` variable allows us to set the duration of the animation
    for each wave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With those variables in place, we only need a few lines of code to complete
    the `WaveCreation` struct. Those lines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code calls the `WaveView` struct, and that requires a value
    for its `yOffset` parameter. We’re passing in one of two values: when the `animateOffset`
    variable is `true`, we’re going to use the `curveOne` variable, which means that
    one of the curves on the wavy line will be animated on the *y* axis. But when
    the `animateOffset` variable is `false`, we will then use the `curveTwo` variable,
    which will control the opposite side of the wavy line on the *y* axis.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code uses the `shadow` modifier to add a shadow to the wave.
    Looking at the parameters, the `color` parameter gets a gray color (which will
    look good against the blue waves), the `radius` parameter sets the size of the
    shadow, and the X and Y parameters allow us to adjust the shadow up, down, left,
    and right.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the final line adds the animation – this is an `easeInOut` timing curve,
    which means the animation will start slowly, then build up, and when it finishes,
    it will ease itself out slowly. The duration of the animation will be set using
    the `duration` variable, with `repeatForever` and `autoreverses` set to `true`.
    Then, for the `value` parameter, that gets the `animateOffset` variable to start
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, rather than just having one wave in our scene, we will call this structure
    inside the `ContentView` six times to make the ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating and animating the wave shape in the ContentView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating our ocean, we’ll stack six waves in our scene and stagger the
    animation values so that they animate at different times. Working in the `ContentView`
    file now, we’ll start by adding a variable inside the `ContentView` struct that
    will toggle the animation on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add a `ZStack` that will hold all the waves, and inside that, let’s
    set the background to a blue sky color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a `blue` color with an opacity of `0.5` (50%) for the background,
    and then we stretch that background out all the way around the edges of the screen
    using the `edgesIgnoreSafeArea` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to add the first wave. So, add the following code directly
    underneath the `edgesIgnoring` modifier, inside the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding the wave is simple because we have done all of the work already – here,
    we just call the `WaveCreation` struct and fill some values into its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first value is for the `animateOffset` parameter, a Boolean that will start
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `curveOne` and `curveTwo` parameters require a value for both parts
    of the wavy line we made in `WaveView`. When you increase the value for one of
    the curve variables, you increase the height of the wave on one side. If you increase
    the size of both curve variables, you increase the height for both sides of the
    wave. Conversely, if you decrease the value for the curve variables by using negative
    numbers, then the wave gets smaller.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using a small value here of `.05` and `-.05`. That’s because this is the
    first wave in the scene, and it will be further out to sea, so I want this wave
    to be a little calmer than the waves that are closer to the shore (and the user).
  prefs: []
  type: TYPE_NORMAL
- en: The next parameter is for the radius of the shadow. It’s set to `50`, which
    means it creates a shadow with a size of 50 points. The direction of the shadow
    will be controlled by the `shadowX` and `shadowY` properties – `shadowX` gets
    a value of `0` because I don’t want to move the shadow on the *x* axis left or
    right, but I do want to adjust it on the *y* axis, and a value of `50` points
    for the `shadowY` variable will bring the shadow upward by 50 points.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `duration` for the animation. We're setting it to `5` seconds
    to create the slower, calmer animation that we are aiming for with this first
    wave.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, We're setting the opacity of this wave to `.8`, so it’s slightly less
    opaque than some of the other waves that we will be adding. Then, we offset this
    wave using a value of `575` on the *y* axis, putting it toward the bottom of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes our first wave. To see this animation, all we have to do is
    toggle the `animateOffset` variable inside the `onAppear` modifier. Add this code
    right at the end of the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that code in place, we can now run the app and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Our first wave ](img/B18674_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Our first wave'
  prefs: []
  type: TYPE_NORMAL
- en: The first wave has a smooth animation flowing back and forth, and we’re ready
    to build our next wave on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the rest of the waves is nearly identical except for the specific
    values that we have set in each parameter. Here is the code for the next five
    waves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the values here are different from those of the first wave –
    for example, wave 2 has larger values for the curve variables, and the radius
    is bigger as well; however, the duration of this wave is slightly shorter, with
    a value of `4` seconds, making the animation a little faster. Waves 3, 4, 5, and
    6 also have shorter durations, so we are increasing the speed of the animation
    for each wave as we move closer to the user’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The shadows vary too, adding a nice white cresting look to the wave and helping
    to delineate the waves from each other. I’m using a gray color for the shadows
    as it’s not too pronounced; however, you can try white if you prefer a brighter-looking
    wave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and run the project in the simulator again and check out all
    the waves animating back and forth in our ocean scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: All six waves together ](img/B18674_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: All six waves together'
  prefs: []
  type: TYPE_NORMAL
- en: As with the first wave, the animation is smooth and rhythmic, and by piling
    up wave upon wave and offsetting each of them a little bit downward, we have created
    an ocean scene.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’re going to continue adding animations to the scene by adding a buoy
    that will bob up and down in the water, complete with a blinking light.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an animated floating buoy to the ocean scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When adding the buoy to our ocean scene, we will be giving it four different
    animations. It will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a blinking light at the top of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt forward and backward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move up and down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate along its leading anchor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these animations will combine to create a realistic-looking bobbing effect
    that simulates a floating object in an ocean reacting to the waves and current.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the `buoy` image, which you can find in the `Chapter 10` folder
    in the GitHub repository, and add the image to the Assets catalog. Then, create
    a new SwiftUI View file, which we will call `BuoyView`. Inside the file, we will
    need six variables to get this buoy off the ground and into the water, so add
    the following code to the `BuoyView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using three Boolean binding variables, which will oversee their
    respective animations: `tiltForwardBackward`, `upAndDown`, and `leadingAnchorAnimate`.
    Then, three `State` variables are used to make a blinking light animation.'
  prefs: []
  type: TYPE_NORMAL
- en: We just added some binding variables to the `BuoyView` struct, which will introduce
    some errors in the project. The reason why these errors occur is that anytime
    we add binding variables to the struct we are working in, we will need to add
    them in the `Preview` struct as well; otherwise, the previews will complain. The
    Preview struct’s job is to display all the code that’s written within the file,
    so it works hand in hand with the `BuoyView` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, modify the Preview struct code to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are now, once again, error-free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now come into the `body` property and add a `ZStack`, then add the buoy
    image inside of the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the buoy in the previews now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: The buoy ](img/B18674_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The buoy'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to work on the blinking light first. In order to achieve this effect,
    we have to add a rectangle shape, place it on top of the buoy (inside the curved
    top), then give it some color, and finally toggle that color on and off to make
    it look like the light is blinking.
  prefs: []
  type: TYPE_NORMAL
- en: Making the buoy light blink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the process of creating the light, let’s overlay a rectangle on the
    buoy image. Add the following code to do that, right under the `Image` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the `overlay` modifier, which allows us to add a new view over an existing
    view, to create layers of views.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look in your previews, you will see that the rectangle we just added
    is much too big for what we need. So, there needs to be a little more stylizing
    and resizing of it. But before we go any further, let’s set the color variables
    to some initial values in the `onAppear` modifier so we can see our work progressing
    in the previews. Add this code to the end of the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I’m setting the `red`, `green`, and `blue` variables to a value of `0.5` (50%).
    This equal combination of 50% for these RGB colors produces a gray or neutral
    color, which will look good blinking against the blue sky background later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, coming back to the `Image` initializer, let’s add that neutral gray color
    to the rectangle using another `overlay` modifier and passing in the color variables.
    Be careful to place the new code directly in front of the overlay’s closing brace,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a big gray rectangle, but we don’t see the buoy anymore because
    the rectangle is too big and needs to be resized. We are going to fix that. Add
    the following rectangle modifiers, which will size and position the rectangle,
    and place them directly inside the closing brace of the first `overlay` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `frame` modifier sets the width and height of the rectangle to a small size
    of `12` by `17`. Then, the `position` modifier places the rectangle at the X and
    Y coordinates of `112.5` and `19.5`, which is at the top part of the buoy, the
    area that represents the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the rectangle in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: The buoy with the rectangle overlay ](img/B18674_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: The buoy with the rectangle overlay'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rectangle looks good; however, a rectangle is, well, a rectangle. It has
    sharp corners on all four sides, whereas the top of the buoy has curved corners,
    as you can see in *Figure 10**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: A closer look at the rectangle overlay ](img/B18674_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: A closer look at the rectangle overlay'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our current rectangle is a bit like fitting a square peg into a round
    hole. Luckily, SwiftUI does give us a modifier that rounds the corner radius of
    rectangles, but unluckily, there is still a problem with it: it rounds all four
    corners when all we want is for the top two corners to be rounded.'
  prefs: []
  type: TYPE_NORMAL
- en: We could fix this by adding an extension to the corner radius modifier and altering
    its behavior so it will only act on two corners by writing numerous lines of code.
    However, a simpler way of achieving a two-corner radius modifier is by using the
    `padding` modifier in a unique way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, after the last variable in the `BuoyView` struct, add a constant
    to store the radius we want for rounding the two corners of our rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I’m calling this constant `cRadius`, for the corner radius, and setting it to
    a value of `8.0` points. The larger you make the corner radius value, the more
    rounded the rectangle becomes; for our purposes, an eight-point value adds just
    enough rounding to our rectangle’s two top corners to make it fit perfectly within
    the buoy light.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code, directly after the second `overlay` modifier, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what the code does. The `.padding(.bottom, cRadius)` line adds eight-point
    padding to the bottom of the rectangle. Then, we call the `cornerRadius` modifier,
    which will put a corner radius on all four corners of the rectangle. But since
    we have an eight-point padding on the bottom of the rectangle, we don’t see that
    corner radius placed on the bottom; we will only see the curved corners at the
    top of the rectangle, which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `padding` modifier again, and again choose the `.bottom`
    option to place padding only on the bottom of the rectangle. This time, however,
    we set a value of `-8` points. When we make this option negative, it effectively
    extends the rectangle downward on the *y* axis – by 8 points – but preserves those
    two sharp corners that we want at the bottom. This is a pretty neat trick and
    saves us some time writing code in an extension for the `cornerRadius` modifier.
    This is the result we see in the previews now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy
    ](img/B18674_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy'
  prefs: []
  type: TYPE_NORMAL
- en: The previews show that our gray rectangle now matches the curvature of the top
    portion of the light and has two sharp corners to match the bottom portion of
    the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off the light and make it blink, we only have to add one line of
    code after the last line of code in the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With that code in place, if you run the previews here in the `BuoyView` file,
    you’ll see that now we have a blinking light that will blink on and off for a
    duration of 1 second, repeating forever, or until the app stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: The completed buoy with a blinking light ](img/B18674_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: The completed buoy with a blinking light'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the animations that make the buoy move now.
  prefs: []
  type: TYPE_NORMAL
- en: Making the buoy move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first animation that we will add to make the buoy move will be to rotate
    the buoy along its leading anchor point. To do this, add the following code right
    after the previous line of code in the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `rotationEffect` modifier and will rotate the buoy by either
    `7` degrees when the `leadingAnchorAnimate` property becomes `true`, or `-3` when
    it's `false`. For the `anchor` parameter, we used the `leading` anchor option,
    which pivots the image around the leading edge, but you can use the `bottom` option
    as well for a slightly different rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we added the `animation` modifier, setting its `duration` to `0.9` seconds,
    with `repeatForever`, and `autoreverses` set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also toggle the `leadingAnchorAnimate` property to `true` in the `onAppear`
    modifier shortly, but first, let’s add the other two animations to the buoy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next animation to add will make the buoy tilt forward and backward. Add
    the code for this right under the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The is almost identical to the previous code, but the value of `.rotationEffect`
    is now set to `tiltForwardBackward`. The amount of rotation or tilt forward and
    back is going to be either `-20` degrees or `15` degrees, depending on the value
    inside of the `tiltForwardBackward` variable. Also, in the `animation` modifier,
    we’re adding a slight delay of `0.2`, as this will help to add to a real-looking
    bobbing motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to add the final animation to the buoy, which will make the image move
    up and down, add this line of code directly after the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A negative value will move an image up the *y* axis and a positive value will
    move the image down the *y* axis. So, this code will move the entire buoy image
    10 points up or down depending on the `upAndDown` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of code we need in the `BuoyView` file is code that toggles on
    these three animations in the `onAppear` modifier. So, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That completes the `BuoyView` file, and now we can proceed to `ContentView`
    and add the buoy to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the buoy to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to place the buoy slightly in the distance of our ocean scene, so let’s
    add it right after wave 1\. Add the following code after the closing brace of
    the first wave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `BuoyView` initializer, we pass in the three binding properties that
    initiate three separate animations. We add a dollar sign before those binding
    properties, which tells the compiler that there’s a two-way binding between the
    `BuoyView` struct and the `ContentView` struct. Next, using the `offset` modifier,
    we can place the buoy at the proper height in the ocean scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and run the project in the simulator to see the animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: The completed animation ](img/B18674_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: The completed animation'
  prefs: []
  type: TYPE_NORMAL
- en: Though the code for the waves and buoy work independently, the two elements
    visually work together to create our ocean scene.
  prefs: []
  type: TYPE_NORMAL
- en: The final element that we can add next is some sound effects. How about the
    sound of some ocean waves and a buoy bell ringing in the background? That would
    really complete the project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already added sound in [*Chapter 4*](B18674_04.xhtml#_idTextAnchor060), when
    building the record player project, and there’s nothing complicated about it.
  prefs: []
  type: TYPE_NORMAL
- en: First, start by creating a Swift file (just a Swift file, not a SwiftUI View
    one), and call it `PlaySound`. Next, drag the M4A sound effects file called `buoyBells`
    (which you can find on GitHub) and place it into the file navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `PlaySound` file, the first thing we need to do is import the AVFoundation
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The AVFoundation framework gives us access to all the classes and methods needed
    to add audio to a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create an `audioPlayer` object to play our sound file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This `audioPlayer` object is optional, which you can tell by the question mark
    at the end. It needs to be optional because the sound file may not exist for whatever
    reason – maybe the file gets corrupted, or the sound file has been downloaded
    from a server and the internet has timed out – and so this protects the project
    from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, under the previous line of code, all we need to do is add a function
    to handle the audio needs of this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The function is called `playSound`. It accepts two strings, one to hold the
    name of the file and another to hold the file’s extension type.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is try to access the sound file that’s in the app bundle
    by using the `path_forResource()` function. The app bundle is an internal hidden
    folder that is created for each app to hold all the necessary files to get the
    app up and running.
  prefs: []
  type: TYPE_NORMAL
- en: If the file exists with the specified name and type, then the code proceeds
    into the `do` block and tries to create the audio player with the path of the
    file’s location stored in the `path` constant. If, for whatever reason, the file
    cannot be found or it’s corrupt, then the code will fall into the `catch` block
    and print out an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s really it for the `PlaySound` file. Let’s go back into `ContentView`
    and add the sound effects to the project. In the `onAppear` modifier, set the
    sound to start playing with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a way of stopping the sound too, when the app stops running on
    the device or the user closes the app. The way to make the sound stop is to call
    the `onDisappear` modifier, which we can use directly on the closing brace of
    the `onAppear` modifier, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And with that, the project is complete!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an ocean scene, with moving waves and a bobbing
    buoy with a flashing light, and added some sounds too.
  prefs: []
  type: TYPE_NORMAL
- en: More specially, you used the Shape protocol, the `path` function, the `animatableData`
    property, and curve variables to make the wave shape come alive. When working
    on the buoy, we looked at how to combine multiple types of animation to create
    unique effects, and how to turn different colors on and off to create a blinking
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters in this project are highly customizable, so feel free to experiment
    further – maybe you want to create bigger waves or more of them, create the waves
    in landscape orientation, alter the shadow to create a horizon, or even replace
    the buoy with a boat!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s keep going. In the next project, we will create a working elevator animation
    using timers and sound effects.
  prefs: []
  type: TYPE_NORMAL
