- en: Chapter 10. 3D Game Programming with OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a mini three-dimensional animation game using OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned about the anatomy of physics simulation
    in depth. Now, we will explore the most interesting part of the game, which is
    to add three-dimensional objects to your games. In this chapter, we will start
    exploring the basics of OpenGL. Then, step-by-step, we will explore OpenGL in
    depth by crafting some three-dimensional models. In this chapter, we will start
    learning by using the two-dimensional model project, and then we will enhance
    the project to accommodate three-dimensional models.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL stands for Open Graphics Library. This is a widely used library for visualizing
    two-dimensional and three-dimensional objects. This is a standard multipurpose
    two-dimensional and three-dimensional content creation graphics library. It is
    used in various streams, such as mechanical design, architectural design, gaming,
    prototyping, flight simulation, and many more. OpenGL is used to configure and
    submit three-dimensional graphics data to the device. All the data is prepared
    in the form of matrices and they are transformed to vertices, which are transformed
    and assembled to produce two-dimensional rasterized images. Two-dimensional graphics
    have two axes, which are x and y; however, in the case of three-dimensional graphics,
    we have three-dimensional axes, which are x, y, and z, where z is the depth.
  prefs: []
  type: TYPE_NORMAL
- en: This library is designed to compile normal function calls into graphical commands,
    which will get executed on the graphics rendering hardware. All the graphics hardware
    is designed to execute the graphics commands. OpenGL draws and renders views very
    fast.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xcode provides a built-in OpenGL-ES project template; still, we think it will
    be confusing for beginners to start with that template. A typical approach is
    to write the code step-by-step, in order to understand how the code works and
    the functionality of each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will write all the code from scratch, which will help you to understand
    the nitty-gritty of each and every line of code written to render views using
    OpenGL. To add frameworks, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up Xcode. Make a single-view application and click on **Next**. Name your
    project OpenGLSample, click on **Next**, choose a folder to save it in, and click
    on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will add all the required frameworks in the project. To add the frameworks,
    the first step is to add the two required frameworks for our OpenGL project. They
    are `OpenGLES.frameworks` and `GLKit.framework`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add these frameworks in Xcode 6, click on your OpenGLSample project in the
    Groups & Files tree, and select the **OpenGLSample** target. Expand the **Link
    Binary with the Libraries** section, click on the plus button, and select **OpenGLES.framework**.
    Repeat for **GLKit.framework** as well, as shown in the following screenshot:![Getting
    ready](img/00157.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create three-dimensional textures in our app, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Main.storyboard` file and select the view controller. You will see
    a view already added in the view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the view, open the Identity inspector, and set the view's class to `GLKView`,
    as shown in the following screenshot:![How to do it](img/00158.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `ViewController.h`, import `GLKit`/`GLKit.h`, and change the ViewController''s
    parent class from `UIViewController` to `GLKViewController`. `GLKViewController`
    provides the OpenGL render loop in addition to all native view controller functionalities.
    The code will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `viewController.m`. Add the following code to `viewDidLoad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line of the code calls `glClearColor`, which effectively tells OpenGL
    that the clear color should be set to the RGBA value (0.0, 0.5, 0.0, 1.0)—that
    is, fully opaque, dark green. The next line instructs OpenGL to actually clear
    the color buffer—that is, it fills the entire screen with the clear color that
    was set on the previous line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, compile and run the project. You should see something similar to the following
    screenshot:![How to do it](img/00159.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's time to create OpenGL context. Drawing triangles in OpenGL is easier
    than drawing squares because triangles are always coplanar, that is, all of the
    points in the shape are on the same plane. So, to draw a square, we first draw
    two triangles that share an edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To inform OpenGL about where the vertices are, we use a structure for vertices
    and for making an array. This will later show on `GLView` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to define which triangle uses which vertices. In OpenGL, we do
    this by numbering each vertex, and then describing triangles by giving OpenGL
    three numbers at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, `Glubyte` is the type in which the first triangle uses vertices
    `0`, `1`, and `2`, and the second triangle uses vertices `2`, `3`, and `0`. Note
    that both triangles use vertices `0` and `2`. This means that they share an edge,
    which means that there won't be any gap between the two triangles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Both the `SquareVertices` and `SquareTriangles` arrays need to be stored in
    a buffer so that OpenGL can use them for rendering as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we set up the `GLKView` with an OpenGL context, as shown in the following
    code. Because, if we don't do this, none of our OpenGL commands will do anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the buffers starting with the vertex buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The vertex buffer is then filled with the vertex information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same thing is then done for the index buffer, which you''ll recall stores
    information on which vertices the two triangles will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this is done, all of the information has been passed to OpenGL. GLKit provide
    several effects, which are the objects that contain information such as color,
    position, orientation, and so on. In this activity, we will make one square to
    be red and to be present it in the middle of the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first step is to create the effect object, and then provide it with a projection
    matrix. The projection matrix controls the overall sizes of things on the screen.
    In this case, we create a projection matrix that uses the aspect ratio of the
    screen and uses a 60 degrees field of view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to provide a model view matrix. The model view matrix controls
    the position of the object, relative to the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `drawInRect` method after the `viewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The actual work of rendering is done in the `glkView:drawInRect` method. The
    first thing that happens in this is that the view is cleared, by filling the screen
    with black:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now call `prepareToDraw`. It configures OpenGL in such a way that anything
    we draw will use the effect''s setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We first tell OpenGL that we''re going to be working with positions, and then
    tell OpenGL where to find the position information in the vertex data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to know how many vertices we''re asking OpenGL to draw. This
    can be figured out by taking the size of the entire index array, and dividing
    that by the size of one element in that array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, our final implementation class probably looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project, and you will see the red square box on the black screen, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a mini 3D animation game using OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will load a texture and apply it to the square. Later, we
    will make a cube, and finally we will learn how to implement three-dimensional
    animation by rotating our cube in three-dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will start from the place we have left before and will load all the
    textures. To load the textures, follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in our vertex structure, we need to include texture coordinate information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add an image (any) in our project, rename it as `Texture.png`, and then
    add the following code in `viewDidLoad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the earlier square color, remove the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, when rendering in `glkView:drawInRect`, we indicate to OpenGL where
    to find texture coordinates in the vertex information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the square is rendered, you''ll see your image appear on it, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00161.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now we will make it as a cube. The cube is made up of eight vertices, so we
    need to provide information for each vertex, including its position and texture
    coordinates. From now on, rename `SquareVertices` to `CubeVertices` to follow
    a better naming convention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is a purely aesthetic one: the cube will be rotated, in order
    to illustrate that it is in fact a three-dimensional object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the following lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace them with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, to draw our cube, a depth buffer needs to be added and enabled. The
    depth buffer is needed to provide a three-dimensional and more realistic look
    to the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code immediately after the call to EAGLContext''s `setCurrentContext`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, replace the `glClear(GL_COLOR_BUFFER_BIT);` line with the `glClear(GL_COLOR_BUFFER_BIT
    | GL_DEPTH_BUFFER_BIT);` line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the project to see the cube in three-dimensions, as shown in
    the following screenshot:![How to do it](img/00162.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will take it to the next level by adding a code to rotate a cube. Now
    we will animate movement in a view, such as rotation. Add the following instance
    variable to the `ViewController` class in the interface part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the update function should look something similar to the following screenshot:![How
    to do it](img/00163.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now compile and run the application. You will find your cube rotating at the
    angle we have specified, as shown in the following screenshot:![How to do it](img/00164.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have learned various ways to create two-dimensional and three-dimensional
    models using OpenGL. OpenGL serves as the backbone of the three-dimensional game
    programming, and hence is a very vast topic to dive into. We have just taken a
    glance of OpenGL, to know more about it, you can refer to [https://developer.apple.com/opengl/](https://developer.apple.com/opengl/).
  prefs: []
  type: TYPE_NORMAL
