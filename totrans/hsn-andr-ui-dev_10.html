<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making Overviews Even Better</h1>
                </header>
            
            <article>
                
<p>When you built the overview/dashboard screen in <a href="22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml" target="_blank">Chapter 7</a>, <em>Creating Overview Screens</em>, you used a <kbd>RecyclerView</kbd> and used Room and data binding to retrieve the list of records from the database and display them to the user, and it worked fantastically well. However, it can be done even better. <kbd>RecyclerView</kbd> is an incredibly powerful engine for data display, and we've only really scratched the surface of what it's capable of. In this chapter, we'll take a deeper look at some of the ecosystem surrounding the <kbd>RecyclerView</kbd> and integrate some big improvements into the claim example. Specifically, we'll explore the following:</p>
<ul>
<li style="font-weight: 400">Different ways to lay out a <kbd>RecyclerView</kbd> with more than one view type</li>
<li style="font-weight: 400">Ways to improve the <kbd>RecyclerView</kbd> performance</li>
<li style="font-weight: 400">Animating changes to <kbd>RecyclerView</kbd></li>
<li style="font-weight: 400">Keeping the complexity off the main thread</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple view types</h1>
                </header>
            
            <article>
                
<p><kbd>RecyclerView</kbd> is capable of handling almost any number of different types of widgets for display on the screen, and recycling them all independently. This is an amazingly powerful and useful technique, not just for being able to display different types of data on the screen, but also to adjust the layout of the <kbd>RecyclerView</kbd> in a way that is mostly transparent. However, you'll need to look at how exactly you want to break the layout up.</p>
<p class="mce-root">There are generally two main reasons you will want to use different view types in a <kbd>RecyclerView</kbd>:</p>
<ul>
<li class="mce-root">To break up a long list of items with a divider</li>
<li class="mce-root">As you have different types of data you want to render together</li>
</ul>
<p class="mce-root">Let's start with creating and adding dividers; you can just adjust the margin of each of the widgets when the data is bound to them, but that doesn't help the user understand why the divider is there. Often, you'll want a divider to carry details of what it actually represents, such as a date label. In these cases, you need widgets to render the label.</p>
<p class="mce-root">You can create a special variant of your normal item layout that includes the divider, by embedding it in a <kbd>LinearLayout</kbd>. For example, if you wanted to add a divider label to the claim items displayed in the overview of the travel claim application, you could add a special layout named <kbd>card_claim_item_with_divider</kbd>, and have it look something like this:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;layout &gt;<br/>  &lt;data&gt;<br/>    &lt;variable<br/>        name="presenter"<br/>        type="com.packtpub.claim.ui.presenters.ItemPresenter" /&gt;<br/><br/>    &lt;variable<br/>        name="item"<br/>        type="com.packtpub.claim.model.ClaimItem" /&gt;<br/>  &lt;/data&gt;<br/><br/>  &lt;LinearLayout<br/>      android:layout_width="match_parent"<br/>      android:layout_height="wrap_content"<br/>      android:orientation="vertical"&gt;<br/><br/>    &lt;TextView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginTop="@dimen/grid_spacer1"<br/>        android:layout_marginBottom="@dimen/grid_spacer1"<br/>        android:text="@{presenter.dividerLabel(item)}"<br/>        android:textAppearance="@style/TextAppearance.AppCompat.Caption" /&gt;<br/><br/>    &lt;include<br/>        item="@{item}"<br/>        layout="@layout/card_claim_item"<br/>        presenter="@{presenter}" /&gt;<br/>  &lt;/LinearLayout&gt;<br/>&lt;/layout&gt;</pre>
<p>This approach is very simple to implement, because the divider is made part of the item that appears below it. This, in turn, means that your <kbd>Adapter</kbd> implementation only needs to decide whether or not an item needs a divider or not, as opposed to keeping track of the dividers as their own object type.</p>
<p class="mce-root">However, the approach also has several large disadvantages; each divider now carries an entire card with it, and if there are no dividers on the screen, the <kbd>RecyclerView</kbd> will still maintain a pool of them off-screen. This means that the entire unused card is unusable, and takes up much more memory and data than it should. The other problem with this approach is that you have nested the widgets another layer deep, within a <kbd>LinearLayout</kbd>. The <kbd>LinearLayout</kbd> renders the contained widgets in exactly the same way as the <kbd>LinearLayoutManager</kbd> attached to the <kbd>RecyclerView</kbd>. So, this layout introduces a widget into the layout system that doesn't really add any value and will negatively impact the application's performance.</p>
<p class="mce-root">So, what is the alternative? It's quite simple, really; treat dividers as special items in your <kbd>RecyclerView</kbd>. When you break up a <kbd>RecyclerView</kbd>, each view type is given an integer identifier that allows the <kbd>RecyclerView</kbd> to keep track of them independently in different recycling pools, and ensure that each one is only used in the right place. The easiest way to introduce dividers as special items, is to introduce them as special items in your dataset. This can be as simple as adding null values into the <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects where dividers are required, but that won't play very nicely with data binding layers, and doesn't scale well.</p>
<p class="mce-root">A better way is to use a <kbd>wrapper</kbd> object in the dataset that tells the <kbd>Adapter</kbd> implementation how to render each of the items. This list can be calculated upfront and reduces the complexity of the layout and rendering. This also allows for very complex choices to be made for every item in the dataset, without affecting the user's perceived performance of the application. Let's build a <kbd>DisplayItem</kbd> class that can be used along with the <kbd>DataBoundViewHolder</kbd> class, to allow for any number of different item types to be used together in a single <kbd>Adapter</kbd>:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>com.packtpub.claim.ui</kbd> package in the travel claim example project and select <span class="packt_screen">New|</span> <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>DisplayItem</kbd> and click <span class="packt_screen">OK</span>.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Declare an integer field to represent the layout resource for each <kbd>DisplayItem</kbd> object. These will be used by the <kbd>Adapter</kbd> class to figure out which layout to load and render:</li>
</ol>
<pre style="padding-left: 60px">public class DisplayItem {<br/>  <strong>public final int layout;</strong></pre>
<ol start="4">
<li>This class is expected to be used as part of a mixed list, making generics inappropriate at this level. Declare a plain <kbd>Object</kbd> field to hold the data (if there is any) for the <kbd>DisplayItem</kbd> to bind to its layout:</li>
</ol>
<pre style="padding-left: 60px">public final Object value;</pre>
<ol start="5">
<li>Now, you'll need a constructor to assign these two fields:</li>
</ol>
<pre style="padding-left: 60px">public DisplayItem(<br/>    final int layout,<br/>    final Object value) {<br/>    <br/>  this.layout = layout;<br/>  this.value = value;<br/>}</pre>
<ol start="6">
<li>As a convenience to the <kbd>Adapter</kbd> classes, the <kbd>DisplayItem</kbd> will offer a <kbd>bindItem</kbd> method to help with the <kbd>DataBoundViewHolder</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public &lt;I&gt; void bindItem(final DataBoundViewHolder&lt;?, I&gt; holder) {<br/>  @SuppressWarnings("unchecked") final I item = (I) value;<br/>  holder.setItem(item);<br/>}</pre>
<p>This is a very simple class to implement, but makes a very big difference in how the <kbd>Adapter</kbd> implementation works. As the dataset in the <kbd>Adapter</kbd> is no longer the raw dataset read from the database or network, you're free to mix various data sources without having to do any of the work in the <kbd>onBindViewHolder</kbd> method. The <kbd>DisplayItem</kbd> is a bit like a <kbd>ViewHolder</kbd> that doesn't actually hold the user-interface widgets; instead, it just signals which layout needs to be used for the data it carries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing dividers</h1>
                </header>
            
            <article>
                
<p>In order to introduce dividers into the claim overview screen, you'll need to run a second pass over the data being delivered from the Room database layer, and figure which items require a divider. This should be done on a background worker thread, so that larger datasets won't impact the user experience. Let's get to work and add some simple dividers to the travel claim app to appear between claim items made on different days; this will require some major changes to how the <kbd>ClaimItemAdapter</kbd> class works. The most obvious change is that it will now have a <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects instead of directly containing a <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects.</p>
<p>Follow these steps to restructure the <kbd>ClaimItemAdapter</kbd> to use <kbd>DisplayItem</kbd> objects to mix both claim items and dividers in the <kbd>RecyclerView</kbd>:</p>
<ol>
<li style="font-weight: 400">First, you'll need a nice line that you can use as a divider. This will be a drawable that can be rendered using an <kbd>ImageView</kbd> widget. Right-click on the <kbd>res/drawable</kbd> directory and select <span class="packt_screen">New|</span> <span class="packt_screen">Drawable resource file</span>.</li>
<li style="font-weight: 400">Name the new file <kbd>horizontal_divider</kbd>, and click <span class="packt_screen">OK</span> to create the new resource.</li>
<li style="font-weight: 400">Change to the <span class="packt_screen">Text</span> editor.</li>
<li style="font-weight: 400">By default, Android Studio will have created a <kbd>selector</kbd> drawable, but you want to declare a <kbd>shape</kbd> drawable. Replace the generated template code with the following XML drawable:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;shape <br/>    android:shape="line"&gt;<br/><br/>    &lt;stroke<br/>        android:width="1dp"<br/>        android:color="#e0e0e0" /&gt;<br/>&lt;/shape&gt;</pre>
<ol start="5">
<li style="font-weight: 400">You'll also need a layout to use for the dividers in the <kbd>RecyclerView</kbd>. Right-click on the <kbd>res/layout</kbd> directory and select <span class="packt_screen">New|</span> <span class="packt_screen">Layout resource file</span>.</li>
<li style="font-weight: 400">Name the new layout file <kbd>widget_divider</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Root element</span> to <kbd>layout</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new layout resource file.</li>
</ol>
<ol start="9">
<li style="font-weight: 400">The new layout doesn't actually need any variables to be bound, so you can leave the <kbd>data</kbd> section empty. Use an <kbd>ImageView</kbd> to render the new <kbd>horizontal_divider</kbd> at full width:</li>
</ol>
<pre style="padding-left: 60px">&lt;layout &gt;<br/>    &lt;data&gt;&lt;/data&gt;<br/><br/>    <strong>&lt;ImageView</strong><br/><strong>        android:layout_width="match_parent"</strong><br/><strong>        android:layout_height="@dimen/grid_spacer1"</strong><br/><strong>        android:layout_marginTop="@dimen/grid_spacer1"</strong><br/><strong>        android:src="@drawable/horizontal_divider" /&gt;</strong><br/>&lt;/layout&gt;</pre>
<ol start="10">
<li style="font-weight: 400">Now, open the <kbd>ClaimItemAdapter</kbd> source file.</li>
<li style="font-weight: 400">Change the <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects to a <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">private List&lt;DisplayItem&gt; items = Collections.emptyList();</pre>
<ol start="12">
<li>Declare a new override method--<kbd>getItemViewType</kbd>--and use the <kbd>DisplayItem.layout</kbd> value to identify the differences between the layouts that will be used in the <kbd>RecyclerView</kbd>. This method will delegate to the <kbd>DisplayItem</kbd> objects and use the layout resource ID as an identifier:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public int getItemViewType(final int position) {<br/>    return items.get(position).layout;<br/>}</pre>
<div class="packt_tip">It's a common trick to directly use the layout resource ID to determine the different view types in a <kbd>RecyclerView</kbd>. This avoids any mapping between internal ID numbers and the layout resources.</div>
<ol start="13">
<li>Now, change the <kbd>onCreateViewHolder</kbd> method to use the <kbd>viewType</kbd> to decide which layout resource to load. The <kbd>viewType</kbd> will be passed in by the <kbd>RecyclerView</kbd>, and will be the same value that was returned by <kbd>getItemViewType</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt;<br/>    onCreateViewHolder(<br/>      final ViewGroup parent,<br/>      final int viewType) {<br/><br/>  return new DataBoundViewHolder&lt;&gt;(<br/>      DataBindingUtil.inflate(<br/>          layoutInflater,<br/>          <strong>viewType</strong>,<br/>          parent,<br/>          false<br/>      ),<br/>      itemPresenter<br/>  );<br/>}</pre>
<ol start="14">
<li>Change the <kbd>onBindViewHolder</kbd> method to use the <kbd>DisplayItem.bindItem</kbd> method, rather than directly invoking <kbd>DataBoundViewHolder.setItem</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onBindViewHolder(<br/>    final DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt; holder,<br/>    final int position) {<br/><br/>  <strong>items.get</strong><strong>(position).bindItem(holder);</strong><br/>}</pre>
<ol start="15">
<li>At the bottom of the <kbd>ClaimItemAdapter</kbd> class, you'll need a new <kbd>ActionCommand</kbd> inner class to do the work of calculating where the dividers should be placed, and wrapping all the <kbd>ClaimItem</kbd> objects in <kbd>DisplayItem</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">private class CreateDisplayListCommand<br/>        extends ActionCommand&lt;List&lt;ClaimItem&gt;, List&lt;DisplayItem&gt;&gt; {</pre>
<ol start="16">
<li>The <kbd>CreateDisplayListCommand</kbd> will need a utility method to decide whether or not to insert a divider between two items. This utility method will simply check whether both items have timestamps on the same day:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">boolean isDividerRequired(<br/>    final ClaimItem item1, final ClaimItem item2) {<br/>  final Calendar c1 = Calendar.getInstance();<br/>  final Calendar c2 = Calendar.getInstance();<br/><br/>  c1.setTime(item1.getTimestamp());<br/>  c2.setTime(item2.getTimestamp());<br/><br/>  return c1.get(Calendar.DAY_OF_YEAR)<br/>             != c2.get(Calendar.DAY_OF_YEAR)<br/>         || c1.get(Calendar.YEAR)<br/>             != c2.get(Calendar.YEAR);<br/>}</pre>
<ol start="17">
<li>Then, you'll need to implement the <kbd>onBackground</kbd> method of <kbd>ActionCommand</kbd>, and process the list of <kbd>ClaimItem</kbd> objects into a <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public List&lt;DisplayItem&gt; onBackground(<br/>    final List&lt;ClaimItem&gt; claimItems)<br/>    throws Exception {<br/><br/>  final List&lt;DisplayItem&gt; output = new ArrayList&lt;&gt;();<br/><br/>  for (int i = 0; i &lt; claimItems.size(); i++) {<br/>    final ClaimItem item = claimItems.get(i);<br/>    output.add(new DisplayItem(R.layout.card_claim_item, item));<br/><br/>    if (i + 1 &lt; claimItems.size() // not the last item<br/>        &amp;&amp; isDividerRequired(item, claimItems.get(i + 1))) {<br/><br/>      output.add(new DisplayItem(R.layout.widget_divider, null));<br/>    }<br/>  }<br/><br/>  return output;<br/>}</pre>
<ol start="18">
<li>To complete the <kbd>CreateDisplayListCommand</kbd> implementation, you'll need to implement the <kbd>onForeground</kbd> method. This will assign the new <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects up to the <kbd>ClaimItemAdapter</kbd> and notify the <kbd>RecyclerView</kbd> of the changes:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onForeground(final List&lt;DisplayItem&gt; value) {<br/>  ClaimItemAdapter.this.items = value;<br/>  notifyDataSetChanged();<br/>}</pre>
<ol start="19">
<li>You'll need an instance of <kbd>CreateDisplayListCommand</kbd> for the <kbd>ClaimItemAdapter</kbd> to use each time the <kbd>LiveData</kbd> is updated. Create a new field at the top of the <kbd>ClaimItemAdapter</kbd> class, and instantiate it:</li>
</ol>
<pre style="padding-left: 60px"><strong>private final CreateDisplayListCommand createDisplayListCommand</strong><br/><strong>        = new CreateDisplayListCommand();</strong><br/>private final LayoutInflater layoutInflater;<br/>private final ItemPresenter itemPresenter;<br/>private List&lt;DisplayItem&gt; items = Collections.emptyList();</pre>
<ol start="20">
<li>Now, you can change the constructor to use the <kbd>CreateDisplayListCommand</kbd> instead of directly referencing the <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects returned by the Room database:</li>
</ol>
<pre style="padding-left: 60px">public ClaimItemAdapter(<br/>        final Context context,<br/>        final LifecycleOwner owner,<br/>        final LiveData&lt;List&lt;ClaimItem&gt;&gt; liveItems) {<br/><br/>  this.layoutInflater = LayoutInflater.from(context);<br/>  this.itemPresenter = new ItemPresenter(context);<br/><br/>  liveItems.observe(owner, new Observer&lt;List&lt;ClaimItem&gt;&gt;() {<br/>    @Override<br/>    <strong>public void onChanged(final List&lt;ClaimItem&gt; claimItems) {</strong><br/><strong>      createDisplayListCommand.exec(claimItems);</strong><br/><strong>    }</strong><br/>  });<br/>}</pre>
<p>If you run the travel claim application now, you'll have a lovely thin and light divider between any claim items that were captured for different dates. Try creating a few using the datepicker to shift the days and force the user interface to produce different groupings of cards. You'll also find that because all the data still comes from the database, you can add and remove the data, and the user interface will remain up to date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating by Delta Events</h1>
                </header>
            
            <article>
                
<p>Up until this point, when the data changes in the database, the <kbd>ClaimItemAdapter</kbd> simply tells the <kbd>RecyclerView</kbd> that the data has changed. This is not the most efficient use of resources, because the <kbd>RecyclerView</kbd> doesn't actually know what in the model has changed, and it's forced to relayout the entire scene as though the entire model has changed (although it will reuse the widgets it has already pooled).</p>
<p><kbd>RecyclerView</kbd> actually has a secondary mechanism that allows you to tell it what has changed, rather than just saying that the data has changed. This is provided through a series of notifications the signal single items, or ranges being added, removed, and moved. The problem is that in order to use these methods, you need to know what has actually changed.</p>
<p>Most developer's first instincts here will be to use more events and signal from the DAO or a delegate layer what is changing, and then catch those events in the <kbd>Adapter</kbd> and forward them to the <kbd>RecyclerView.</kbd> This can be made to work, and in fact, it can work quite well when done through an event bus rather than having the <kbd>Adapter</kbd> directly attach itself to the DAO layer. The problem is that it also forces you to generate these events, translate them, and they can become unwieldy as the possible list of simultaneous changes becomes more complex.</p>
<p>Another way is to leave the events up to Room. When new data is provided via <kbd>LiveData</kbd>, you can compare the dataset currently displayed to the user with the new dataset and calculate what has changed. This is the same way that version control software such as Git or Mercurial work; they compare what you have done with what you started with to create a delta, or diff of the changes. This can be complicated and hard work, but Android support library has you covered; it provides a class named <kbd>DiffUtil</kbd> that can not only be used to compute the differences between virtually any two datasets, but also produce the correct set of events to deliver to the <kbd>RecyclerView</kbd>. Let's use <kbd>DiffUtil</kbd> in the <kbd>ClaimItemAdapter</kbd>, to only apply the changes to the <kbd>RecyclerView</kbd>:</p>
<ol>
<li style="font-weight: 400">Before searching for differences, it's important to be able to determine whether two <kbd>ClaimItem</kbd> objects refer to the same database record, but are different. For that, you'll need a complete <kbd>equals</kbd> method, which can be generated by Android Studio. Open the <kbd>ClaimItem</kbd> source file in Android Studio.</li>
<li style="font-weight: 400">Click on the class name in the editor, and then select <span class="packt_screen">Code|</span><span class="packt_screen">Generate</span> from the main menu bar.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Select <span class="packt_screen">equals() and hashCode()</span> from the pop-up menu.</li>
<li style="font-weight: 400">Use all the defaults that are provided by the IDE, clicking on <span class="packt_screen">Next</span> and <span class="packt_screen">Finish</span> until the wizard is complete.</li>
<li style="font-weight: 400">Open the <kbd>ClaimItemAdapter</kbd> source file.</li>
<li style="font-weight: 400">At the bottom of the <kbd>ClaimItemAdapter</kbd> class below the <kbd>CreateDisplayListCommand</kbd> inner class, declare a new <kbd>ActionCommand</kbd> inner class to deal with updating the existing list of <kbd>DisplayItem</kbd> objects, and triggering the required change notifications:</li>
</ol>
<pre style="padding-left: 60px">private class UpdateDisplayListCommand<br/>        extends ActionCommand&lt;<br/>            Pair&lt;List&lt;DisplayItem&gt;, List&lt;ClaimItem&gt;&gt;,<br/>            Pair&lt;List&lt;DisplayItem&gt;, DiffUtil.DiffResult&gt;<br/>        &gt; {</pre>
<div class="packt_infobox">This class takes and processes <kbd>Pair</kbd> objects containing two parameters each. As input, we'll be passing the old <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects, and the new <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects that it needs to process. As output, it will produce the new <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects, and a <kbd>DiffResult</kbd> that can be used to trigger the update events.</div>
<ol start="7">
<li>The first thing you'll need in the <kbd>UpdateDisplayListCommand</kbd> is the <kbd>onBackground</kbd> method. This method will use the <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects passed in through the <kbd>Pair</kbd> as the "old" <kbd>List</kbd> of items, and will generate a "new" <kbd>List</kbd> of <kbd>DisplayItem</kbd> objects by invoking the <kbd>CreateDisplayListCommand</kbd> directly:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public Pair&lt;List&lt;DisplayItem&gt;, DiffUtil.DiffResult&gt; onBackground(<br/>        final Pair&lt;List&lt;DisplayItem&gt;, List&lt;ClaimItem&gt;&gt; args)<br/>        throws Exception {<br/><br/>    final List&lt;DisplayItem&gt; oldDisplay = args.first;<br/>    final List&lt;DisplayItem&gt; newDisplay =<br/>            createDisplayListCommand.onBackground(args.second);</pre>
<ol start="8">
<li>Now that you have the <kbd>List</kbd> that is currently being displayed to the user and the <kbd>List</kbd> that needs to be displayed, it's time to calculate the differences between them. In order to keep things completely generic, the <kbd>DiffUtil</kbd> defines a callback interface that is queried to find the details of the two lists. In the <kbd>UpdateDisplayListCommand</kbd> class, we'll simply use an anonymous inner class:</li>
</ol>
<pre style="padding-left: 60px">final DiffUtil.DiffResult result =<br/>      DiffUtil.calculateDiff(new DiffUtil.Callback() {<br/>  @Override<br/>  public int getOldListSize() {<br/>    return oldDisplay.size();<br/>  }<br/><br/>  @Override<br/>  public int getNewListSize() {<br/>    return newDisplay.size();<br/>  }</pre>
<ol start="9">
<li>The <kbd>Callback</kbd> implementation also requires a method to compare items at two different positions, to see whether they appear to be the same item. The first thing to do is to check whether their layouts appear to be the same. If the layouts aren't the same, we can be sure that they are not the same object. If the layouts are the same, then we can look at the layout integer as an indicator of what type of data is in the <kbd>DisplayItem</kbd> object. If it's a <kbd>ClaimItem</kbd>, we use the database ID of the objects to see whether they represent the same record in the database:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public boolean areItemsTheSame(<br/>    final int oldItemPosition,<br/>    final int newItemPosition) {<br/>  final DisplayItem oldItem = oldDisplay.get(oldItemPosition);<br/>  final DisplayItem newItem = newDisplay.get(newItemPosition);<br/><br/>  if (oldItem.layout != newItem.layout) {<br/>    return false;<br/>  }<br/><br/>  switch (newItem.layout) {<br/>    case R.layout.card_claim_item:<br/>      final ClaimItem oldClaimItem = (ClaimItem) oldItem.value;<br/>      final ClaimItem newClaimItem = (ClaimItem) newItem.value;<br/>      return oldClaimItem != null<br/>          &amp;&amp; newClaimItem != null<br/>          &amp;&amp; oldClaimItem.id == newClaimItem.id;<br/>    case R.layout.widget_divider:<br/>      return true;<br/>  }<br/><br/>  return false;<br/>}</pre>
<ol start="10">
<li>The <kbd>Callback</kbd> also needs another method to test whether the contents of the two objects has actually changed. This method will only be invoked by the <kbd>DiffUtil</kbd> if the <kbd>areItemsTheSame</kbd> method returned true, which permits you to take some shortcuts through the implementation by assuming that both sides represent the same record:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public boolean areContentsTheSame(<br/>    final int oldItemPosition,<br/>    final int newItemPosition) {<br/>  final DisplayItem oldItem = oldDisplay.get(oldItemPosition);<br/>  final DisplayItem newItem = newDisplay.get(newItemPosition);<br/><br/>  switch (newItem.layout){<br/>    case R.layout.card_claim_item:<br/>      final ClaimItem oldClaimItem = (ClaimItem) oldItem.value;<br/>      final ClaimItem newClaimItem = (ClaimItem) newItem.value;<br/>      return oldClaimItem != null<br/>          &amp;&amp; newClaimItem != null<br/>          &amp;&amp; oldClaimItem.equals(newClaimItem);<br/>    case R.layout.widget_divider:<br/>      return true;<br/>  }<br/><br/>  return false;<br/>}</pre>
<ol start="11">
<li>That concludes the <kbd>Callback</kbd> implementation. Now, you'll need to close the <kbd>onBackground</kbd> method by returning a <kbd>Pair</kbd> containing the new list of <kbd>DisplayItem</kbd> objects and the <kbd>DiffResult</kbd>:</li>
</ol>
<pre style="padding-left: 60px">  }); // end of the DiffUtil.Callback implementation<br/><br/>  return Pair.create(newDisplay, result);<br/>} // end of the onBackground implementation</pre>
<ol start="12">
<li>In the <kbd>onForeground</kbd> method of the <kbd>UpdateDisplayListCommand</kbd>, you'll need to assign the new list of <kbd>DisplayItem</kbd> objects up to the <kbd>ClaimItemAdapter</kbd>, just as before. However, instead of notifying the <kbd>RecyclerView</kbd> that the whole model has changed, you can use the <kbd>DiffResult</kbd> to relay the differences you found as a series of events:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onForeground(<br/>    final Pair&lt;List&lt;DisplayItem&gt;,<br/>    DiffUtil.DiffResult&gt; value) {<br/>  ClaimItemAdapter.this.items = value.first;<br/>  value.second.dispatchUpdatesTo(ClaimItemAdapter.this);<br/>}</pre>
<ol start="13">
<li>Back at the top of the <kbd>ClaimItemAdapter</kbd>, you'll now need a field with an instance of the new <kbd>UpdateDisplayListCommand</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public class ClaimItemAdapter extends<br/>        RecyclerView.Adapter&lt;DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt;&gt; {<strong><br/><br/>  private final UpdateDisplayListCommand updateCommand</strong><br/><strong>        = new UpdateDisplayListCommand();</strong><br/>  private final CreateDisplayListCommand createDisplayListCommand<br/>        = new CreateDisplayListCommand();<br/>  private final LayoutInflater layoutInflater;<br/>  private final ItemPresenter itemPresenter;</pre>
<ol start="14">
<li>Now, in the <kbd>ClaimItemAdapter</kbd> class's constructor, the <kbd>LiveData</kbd> observer changes again. If the data is from the first notification, there is no point in calculating the differences between the two lists, but if it's any invocation after that, you can now run it through the <kbd>UpdateDisplayListCommand</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public ClaimItemAdapter(<br/>        final Context context,<br/>        final LifecycleOwner owner,<br/>        final LiveData&lt;List&lt;ClaimItem&gt;&gt; liveItems) {<br/><br/>  this.layoutInflater = LayoutInflater.from(context);<br/>  this.itemPresenter = new ItemPresenter(context);<br/><br/>  liveItems.observe(owner, new Observer&lt;List&lt;ClaimItem&gt;&gt;() {<br/>    @Override<br/>    public void onChanged(final List&lt;ClaimItem&gt; claimItems) {<br/>      <strong>if (!items.isEmpty()) {</strong><br/><strong>        updateCommand.exec(Pair.create(items, claimItems));</strong><br/><strong>      } else {</strong><br/><strong>        createDisplayListCommand.exec(claimItems);</strong><br/><strong>      }</strong><br/>    }<br/>  });<br/>}</pre>
<p class="mce-root">These changes might seem like a lot of work just to change the events produced by the <kbd>Adapter</kbd> implementation, but they can be made relatively generic with some work so that they can be reused in various different list implementations. The changes also bring a much nice user experience to the table: animations. Because you are now telling the <kbd>RecyclerView</kbd> exactly what is changing, it will automatically animate the changes for you.</p>
<p class="mce-root">The <kbd>DiffUtil</kbd> is also an excellent tool in this case because of the dividers. Although the model changes one <kbd>ClaimItem</kbd> at a time, the <kbd>DiffUtil</kbd> also takes care of adding and removing any dividers that are affected by these changes. If you triggered each of these events from the database layer, you would need to handle these extra changes manually, and while <kbd>DiffUtil</kbd> might not be the most efficient tool, it keeps the data absolutely consistent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<ol>
<li>How many different view types can you use in a single <kbd>RecyclerView</kbd> instance?
<ul>
<li>One or two</li>
<li>Any number</li>
<li>256</li>
</ul>
</li>
<li>When using a <kbd>DiffUtil</kbd>, which of the following applies to the data you are comparing?
<ul>
<li style="font-weight: 400">It must be a database entity</li>
<li style="font-weight: 400">It must be comparable</li>
<li style="font-weight: 400">It is exposed through a Callback</li>
</ul>
</li>
<li>When adding dividers to a <kbd>RecyclerView</kbd>, you should do which of these?
<ul>
<li style="font-weight: 400">Make them part of the item above the divider</li>
<li style="font-weight: 400">Add them to the display in the <kbd>onBindViewHolder</kbd> method</li>
<li style="font-weight: 400">Make them distinct items in the dataset</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we largely focused on the <kbd>RecyclerView</kbd> and how to make it work even better within your application, and especially for overview/dashboard screens. Changes such as adding the dividers and animations don't change the functionality of an application, but they do change the user experience. In this case, they make it easier for the user to understand the screen and easier for them to understand what happened when things changed.</p>
<p class="mce-root">These sorts of changes can be seen as "polishing" the application. You can build the application without them to ensure that everything works, and then add them in afterward. It's a good idea to slowly build a list of generic structures that can be used to quickly polish any application. A good example will be a generic <kbd>ActionCommand</kbd> to use the <kbd>DiffUtil</kbd> and apply the changes to an <kbd>Adapter</kbd>.</p>
<p>In the next chapter, we'll spend some more time on polishing applications. We'll look at animations, colors, and styling, and explore how to define and use them throughout an application to apply a consistent theme.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>