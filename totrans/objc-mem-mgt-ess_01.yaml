- en: Chapter 1. Introduction to Objective-C Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章  Objective-C内存管理简介
- en: In this chapter, we will concern ourselves principally with the core issues
    of the memory management problem as well as an Objective-C-based solution of it.
    We will look at the ownership and life cycle of the object. This basic idea is
    known as manual references counting, or **Manual Retain Release** (**MRR**), where
    you need to claim and relinquish ownership of every object. It defines an object's
    life cycle. And finally, we'll take a look deeper into **NSObject** for a better
    understanding of what's going on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注内存管理问题的核心问题以及基于Objective-C的解决方案。我们将研究对象的所有权和生命周期。这个基本思想被称为手动引用计数，或**手动保留释放**（**MRR**），其中你需要声明和放弃每个对象的所有权。它定义了对象的生命周期。最后，我们将更深入地探讨**NSObject**，以便更好地理解正在发生的事情。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why do we need memory management in Objective-C?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要在Objective-C中进行内存管理？
- en: An object's ownership and life cycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的所有权和生命周期
- en: The principles of reference counting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数的原理
- en: What's a memory leak and why pay attention to it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是内存泄漏，为什么要注意它？
- en: Why do we need memory management in Objective-C?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要在Objective-C中进行内存管理？
- en: It does not matter what programming language is being used; the question of
    memory management always persists. In general, it is a question of resource management
    that cannot be avoided because memory is always a limited resource.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用什么编程语言，内存管理的问题总是存在的。一般来说，这是一个无法避免的资源管理问题，因为内存始终是有限的资源。
- en: The scripting languages and Java, where memory management is handled by the
    virtual machine or application (where it is hidden from the code), are not always
    effective enough. While it is easier for the programmer this way, it can have
    a negative impact on resources, since you don't have an absolute control of it
    and there are objects still "living" when we don't need them anymore, plus these
    "living" objects still occupy precious memory space, which can be used by other
    objects. Additionally, depending on what you ask, another opinion is that an automatic
    memory management is the only right way to go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言和Java，在内存管理由虚拟机或应用程序（在代码中隐藏）处理的情况下，并不总是足够有效。虽然这种方式对程序员来说更容易，但它可能会对资源产生负面影响，因为你没有对其绝对的控制权，而且当不再需要时，仍然有对象“活着”，此外，这些“活着”的对象仍然占用宝贵的内存空间，这些空间本可以由其他对象使用。另外，根据你的要求，另一种观点认为，自动内存管理是唯一正确的方向。
- en: Such talks usually start discussions like "Which is the best programming language?"
    and" What is the best way of memory management?". Let's leave that meaningless
    business for blogs' and forums' "Holy-Wars". Every tool has it's use in the correct
    context and Objective-C memory management concept is quite efficient in terms
    of both time cost savings and resource saving.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的讨论通常开始于像“哪种编程语言最好？”和“内存管理的最佳方式是什么？”这样的讨论。让我们把那些无意义的争论留给博客和论坛上的“圣战”吧。每个工具在正确的上下文中都有其用途，而Objective-C的内存管理概念在时间和资源节约方面都相当高效。
- en: The memory in Objective-C, is managed in a different way from some of the widespread
    languages such as C/C++, Java, or C#, which are typically taught in schools as
    it introduces new concepts such as object ownership. Memory management is crucial
    for devices that run on a limited amount of memory such as mobile phones, smart
    watches, and so on, since effective memory management will allow you to squeeze
    every ounce of performance needed to run efficiently on these small devices, where
    memory is scarce on these devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的内存管理方式与一些广泛使用的语言（如C/C++、Java或C#）不同，这些语言通常在学校教授，因为它引入了新的概念，如对象所有权。对于运行在有限内存上的设备（如手机、智能手表等）来说，内存管理至关重要，因为有效的内存管理将允许你从这些小型设备中榨取每一滴性能，在这些设备上，内存非常稀缺。
- en: An object's ownership and life cycle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的所有权和生命周期
- en: The idea of object ownership abstraction is simple—one entity is simply responsible
    for another and an entity has the ability to own an object. When an entity owns
    an object, the entity is responsible to free that object too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对象所有权抽象的想法很简单——一个实体简单地负责另一个实体，并且实体有拥有对象的能力。当一个实体拥有一个对象时，该实体也负责释放该对象。
- en: 'Let''s go to our code example. If an object was created and used in the main
    function, then the main function is responsible for the object, as the following
    code listing demonstrates:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码示例。如果一个对象在主函数中被创建并使用，那么主函数对该对象负责，如下面的代码列表所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取您购买的所有
    Packt 出版物的代码。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: What makes this concept a bit more complicated is that objects can be owned
    by more than one entity. So, an object may be created and owned in the main function
    and will also be used by another entity that will claim ownership of the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个概念变得稍微复杂一点的是，对象可能被多个实体拥有。因此，一个对象可能被在主函数中创建和拥有，同时也会被另一个实体使用，该实体将声明对对象的拥有权。
- en: 'A common situation where you will see multiple object ownership is when you
    use arrays. Arrays are indexed lists of objects, and when an object is placed
    into an array, the array claims ownership of the object. So, if I create an object
    in the main function and then put that object into an array, both the main function
    and the array will claim ownership of the object and create a reference to it
    at the same time. Ownership and reference are different as an object references
    another object, which it does not own and both are responsible for cleaning up
    the object. The following code demonstrates this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在使用数组时看到多个对象拥有权的情况是一个常见的情况。数组是对象的索引列表，当一个对象被放入数组中时，数组声明对对象的拥有权。因此，如果我在主函数中创建一个对象并将其放入数组中，主函数和数组将同时声明对对象的拥有权并为其创建一个引用。拥有权和引用是不同的，因为一个对象引用另一个对象，它并不拥有，并且两者都负责清理对象。以下代码演示了这一点：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just like objects in the real world, Objective-C objects are created; they live,
    and then go away when the application is closed. This is how the object life cycle
    works. Obviously, arrays have to claim the ownership on the object and prevent
    it to be deleted in the release method called in the main function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实世界中的对象一样，Objective-C 对象被创建；它们存在，然后在应用程序关闭时消失。这就是对象生命周期的工作方式。显然，数组必须声明对对象的拥有权，并防止在主函数中调用的释放方法中删除对象。
- en: However, what is the correct way for the entity to claim its rights on an object
    that it owns? Let's take a deeper look at the problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实体如何正确地对其拥有的对象声明其权利呢？让我们更深入地看看这个问题。
- en: Ownership of object and reference counting
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象拥有权和引用计数
- en: To indicate the number of owners using objects, those objects are given a reference
    count.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示使用对象的拥有者数量，这些对象被赋予了一个引用计数。
- en: At the beginning, the reference count of the object is `1`. This happens because
    the function creating the object is going to use that object. When any entity
    needs to claim an ownership of the object, since that entity is going to access
    and use that object, it sends a retain message to it and its retain count is incremented
    by `1`. When an entity is finished with the object, it sends the release message
    to the object and its retain count decrements by `1`. As long as this object's
    reference count is higher than zero, some "things" are using it. When it comes
    to zero, the object is no longer useful for any of those "things", and it can
    be safely deallocated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，对象的引用计数为 `1`。这是因为创建对象的函数将要使用该对象。当任何实体需要声明对对象的拥有权时，由于该实体将要访问和使用该对象，它会向其发送保留消息，并且其保留计数增加
    `1`。当实体完成对对象的操作后，它会向对象发送释放消息，并且其保留计数减少 `1`。只要这个对象的引用计数大于零，一些“东西”正在使用它。当它降到零时，该对象对那些“东西”就不再有用，并且可以安全地释放。
- en: 'Let''s return to the example with the object owned by an array. Explanations
    are given in the following code comments and diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到由数组拥有的对象的例子。以下代码注释和图中给出了解释：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram illustrates the principle of reference counting:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了引用计数的原理：
- en: '![Ownership of object and reference counting](img/00002.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![对象拥有权和引用计数](img/00002.jpeg)'
- en: Forgetting to send a release message to an object before setting a pointer to
    point at something else will guarantee you a memory leak. In order to create an
    object before it's initiated, a chunk of the OS memory is allocated to store it.
    Also, if you send a `release` statement to an object, which was not previously
    sent, a `retain` statement is sent to the object. This will be considered as a
    **premature deallocation**, where the memory previously allocated to it is not
    related to it anymore. A lot of time is spent on debugging these issues, which
    can easily become very complex in large projects. If you don't follow some solid
    principles for memory management, you can often forget and quickly find yourself
    getting stuck for hours checking every retain and release statement. Even worse
    is if you're going through someone else's code, and they mess things up. Going
    through to fix memory management issues in someone else's code can take forever.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在将指针设置为指向其他对象之前忘记向对象发送释放消息将保证你会有内存泄漏。为了在初始化之前创建一个对象，操作系统会分配一块内存来存储它。此外，如果你向一个之前未发送过释放语句的对象发送了释放语句，则会向该对象发送一个保留语句。这将被视为**过早释放**，即之前分配给它的内存不再与其相关。调试这些问题会花费很多时间，在大项目中这些问题很容易变得非常复杂。如果你不遵循一些关于内存管理的坚实基础原则，你经常会忘记，并且很快就会发现自己花费数小时检查每一个保留和释放语句。更糟糕的是，如果你正在查看别人的代码，而他们搞砸了。在别人的代码中修复内存管理问题可能需要很长时间。
- en: What's a memory leak and why pay attention to it?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是内存泄漏，为什么要注意它？
- en: A memory leak is when your program loses track of a piece of memory that was
    allocated and has forgotten to release it. The consequence is that the "leaked"
    memory will never be freed by the program. When more memory is leaked after a
    certain point in time, there will be no more free memory and this will cause your
    application to crash. Usually, this tends to happen when a piece of code does
    `new`, `malloc`, or `alloc`, but never does a corresponding "delete", "free",
    or "release" respectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是指你的程序失去了对已分配但忘记释放的内存的跟踪。结果是，“泄漏”的内存将永远不会被程序释放。在某个时间点之后，如果继续泄漏更多内存，将没有更多空闲内存，这将导致你的应用程序崩溃。通常，这倾向于发生在代码执行
    `new`、`malloc` 或 `alloc`，但从未执行相应的“delete”、“free”或“release”操作时。
- en: When you do `new`, `malloc`, or `alloc`, what the operating system does is that
    it is giving your program a chunk of memory on the heap. The OS says, "Here, take
    this memory address and have this block of memory on it." Thus, you need to create
    a reference to that memory address (usually in the form of a pointer), depending
    on the OS, such as, "I'm done with this, it's not useful anymore" (by calling
    "free", "delete", or "release").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 `new`、`malloc` 或 `alloc` 时，操作系统所做的就是给你的程序在堆上分配一块内存。操作系统会说：“这里，拿这个内存地址，并在它上面有一个内存块。”因此，你需要创建对该内存地址的引用（通常以指针的形式），根据操作系统，例如，“我完成了这个，它不再有用”（通过调用“free”、“delete”或“release”）。
- en: 'Memory leaks happen when you throw away your pointer to that memory. If your
    program does not retain where your memory is allocated on the heap, how can you
    even free it? The following line of code shows an example of a memory leak if
    you never call the release method on it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你丢弃指向该内存的指针时，内存泄漏就会发生。如果你的程序不知道你的内存是在堆上分配的，你怎么能释放它呢？以下代码行展示了如果你从未调用释放方法，它将是一个内存泄漏的例子：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So why should you care? At best, you're the dissipating memory that will be
    freed when the user quits your app. At worst, there could be a memory leak that
    happens in every screen. It would not be a great mode to end up your program,
    especially if the user lets it run for a long time. A program crash is very hard
    to debug as it can crash at random moments in your application as memory leaks
    are very unpredictable to replicate and creating an application that crashes often
    will lead to bad reviews of your program on the App Store, or through word of
    mouth, which is something that you do not want to happen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么你应该关心呢？最好的情况是，你是当用户退出你的应用程序时将被释放的消耗内存。最坏的情况是，每个屏幕都可能发生内存泄漏。这并不是结束程序的好方法，特别是如果用户让它长时间运行。程序崩溃很难调试，因为它可以在应用程序的随机时刻崩溃，因为内存泄漏很难复制。创建一个经常崩溃的应用程序会导致你的程序在
    App Store 上或通过口碑收到差评，这是你不想发生的事情。
- en: This is why in the process of evolution, there are other methods of memory management
    in Objective-C, which you will find further in this book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在进化的过程中，Objective-C 中有其他内存管理方法，你将在本书中进一步了解。
- en: What is an object within Objective-C?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 中的对象是什么？
- en: How do things work inside Objective-C? `NSObject` is the root class of most
    Objective-C class hierarchies, through it an object inherits basic methods and
    behaves like an Objective-C object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 内部是如何工作的？`NSObject`是大多数Objective-C类层次结构的根类，通过它，对象继承基本方法，并表现出Objective-C对象的特性。
- en: This object is an instance of a class and can also be a member of a class or
    one of its derivatives. So, let's take a deeper look at `NSObject`. In the early
    stage, Objective-C had a class called `Object`. This had a method called `+new`,
    which wrapped `malloc()`, and a method called `-free`. Since Objective-C objects
    were generally aliased and managing object life cycles became quite complex, this
    was troublesome.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是一个类的实例，也可以是类的一个成员或其派生类之一。因此，让我们更深入地了解`NSObject`。在早期，Objective-C 有一个名为`Object`的类。它有一个名为`+new`的方法，该方法封装了`malloc()`，还有一个名为`-free`的方法。由于Objective-C
    对象通常被别名化，并且管理对象的生命周期变得相当复杂，这很麻烦。
- en: 'NSObject is used by NeXT—Steve Job''s second company, founded after he was
    fired from Apple in 1985—in order to provide reference counting, thus, dividing
    Object pointers in two categories: pointers that own references and pointers that
    do not own references. Those pointers that contribute towards the object''s reference
    count are owning reference pointers. If there is a certainty that a reference
    is going to be held somewhere else for the duration of a variable''s lifetime,
    a non-owning reference pointer can be used avoiding the additional overhead of
    reference count manipulation since a non-owning reference pointer does not have
    the added cost of keeping track of object ownership.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: NSObject 被NeXT（史蒂夫·乔布斯在1985年被苹果公司解雇后创立的第二家公司）使用，以便提供引用计数，因此，将对象指针分为两类：拥有引用的指针和不拥有引用的指针。那些对对象引用计数有贡献的指针是拥有引用指针。如果确定一个引用将在变量生命周期的某个时刻被其他地方持有，可以使用非拥有引用指针，从而避免引用计数操作的额外开销，因为非拥有引用指针没有跟踪对象拥有的额外成本。
- en: 'Non-owning reference pointers are often used for autoreleased values. Autorelease
    pools make it possible for a temporary object to receive a non-owning reference
    pointer in return. An object, by receiving an `-autorelease` message is added
    to a list that will be deallocated afterwards, with the destruction of the current
    autorelease pool. You can call autorelease using the autorelease method as shown
    here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 非拥有引用指针通常用于自动释放值。自动释放池使得临时对象能够接收非拥有引用指针作为回报。通过接收一个`-autorelease`消息，对象被添加到一个列表中，之后将被释放，与当前自动释放池的销毁同时进行。您可以使用如下所示的自动释放方法调用自动释放：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following table shows some description on the roles of autorelease and
    release:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了自动释放和释放的一些描述：
- en: '| Release type | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 释放类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The autorelease method | An object is sent a release message, but put in
    an autorelease pool and the object is released when the pool is drained later
    during the run loop, but still occupies memory |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 自动释放方法 | 对象收到释放消息，但放入自动释放池，对象将在运行循环中稍后池被耗尽时释放，但仍然占用内存 |'
- en: '| The release method | An object is released immediately and memory is freed
    after the object is released |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 释放方法 | 对象被立即释放，并在对象释放后释放内存 |'
- en: Any object that receives the autorelease message will be released when the autorelease
    pool is drained. Using autorelease instead of the normal release method will extend
    the lifetime of an object until the pool is drained at the end of the run loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何收到自动释放消息的对象将在自动释放池耗尽时被释放。使用自动释放而不是常规释放方法将延长对象的生命周期，直到运行循环结束时池被耗尽。
- en: At **Worldwide Developers Conference** (**WWDC**) 2011, Apple introduced ARC,
    the acronym of Automatic Reference Counting. It forces the compiler to handle
    the memory management calls at compile time instead of the conventional garbage
    collection functionality, which occurs during runtime. ARC also adds some things
    to the language model in general. It has been supported since iOS5, OS X 10.7,
    and by GNUstep.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年的**全球开发者大会**（**WWDC**）上，苹果公司引入了ARC（自动引用计数）的缩写。它强制编译器在编译时处理内存管理调用，而不是传统的垃圾回收功能，该功能在运行时发生。ARC还向语言模型中添加了一些内容。它自iOS5、OS
    X 10.7以及GNUstep以来一直得到支持。
- en: First, what we will find out is that there are two NSObjects in Cocoa, a class
    and a protocol. Why is this so and what is the purpose of this? Let's look into
    classes and protocols.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将发现 Cocoa 中有两个 NSObjects，一个类和一个协议。为什么会这样，这个设计的目的是什么？让我们来看看类和协议。
- en: In Objective-C, protocols define a set of behaviors that an object is expected
    to conform to in certain situations at runtime. For example, a table view object
    is expected to be able to communicate with a certain data source so that the table
    view will know what data and information to display. Protocols and classes do
    not share the same namespaces (a set of identifiers containing names, the names
    of classes and protocols, thus the same name can exist in different namespaces).
    It's possible to have both, which are unrelated at the language level, but have
    the same name. This is the case with NSObject.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，协议定义了一组对象在运行时预期遵循的行为。例如，一个表格视图对象预期能够与某个数据源进行通信，以便表格视图知道要显示哪些数据和信息。协议和类不共享相同的命名空间（包含名称、类和协议名称的标识符集合，因此相同的名称可以存在于不同的命名空间中）。两者都可以存在，在语言层面上它们是无关的，但具有相同的名称。这种情况在
    NSObject 中就是这样。
- en: If you look at the language, there are no places where you can use either a
    protocol or a class name. Using class names as the target of message sends, as
    type names, and in `@interface` declarations is allowed. Likewise, it's possible
    to use protocols names in a few identical places; however, not in the same way.
    Having a protocol with the same name as a class won't result any issue.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言中，没有地方可以使用协议或类名。将类名用作消息发送的目标、类型名称和在 `@interface` 声明中是允许的。同样，在几个相同的位置可以使用协议名称；然而，方式不同。具有与类相同名称的协议不会引起任何问题。
- en: It is impossible for root class to have a superclass as they are at the top
    of the hierarchy, so there is no superclass above a root class and NSObject class
    is one of them. And I give emphasis on saying *one of them* because in comparison
    to other programming languages in Objective-C, it's perfectly possible to have
    the existence of multiple root classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根类不可能有超类，因为它们位于层次结构的顶部，因此没有根类之上的超类，NSObject 类就是其中之一。我强调说“其中之一”，因为在与其他编程语言相比的
    Objective-C 中，存在多个根类的存在是完全可能的。
- en: Java's single root class is named `java.lang.Object`, which is the parent ultimate
    class of any other. For this reason, any piece of code in Java, which comes from
    any object, has the basic methods added by `java.lang.Object`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的单一根类名为 `java.lang.Object`，它是任何其他类的父终极类。因此，任何来自对象的 Java 代码，都添加了由 `java.lang.Object`
    添加的基本方法。
- en: Cocoa can have multiple root classes. Besides `NSObject`, there is `NSProxy`
    and a few others root classes; and such root classes are, in part, the reason
    for the existence of the `NSObject` protocol. The `NSObject` protocol determines
    a specific set of basic methods, expecting their implementation by the others
    root classes, consequently, making those methods available whenever and wherever
    they are needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa 可以有多个根类。除了 `NSObject`，还有 `NSProxy` 和其他一些根类；这些根类部分是 `NSObject` 协议存在的原因。`NSObject`
    协议确定了一组特定的基本方法，期望其他根类实现这些方法，从而使得这些方法在需要时随时可用。
- en: 'The `NSObject` class is in accordance to the `NSObject` protocol, which results
    in the implementation of this basic method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSObject` 类遵循 `NSObject` 协议，这导致了该基本方法的实现：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implementing the same method works for `NSProxy`, which is also in accordance
    to the `NSObject` protocol:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `NSProxy`，实现相同的方法也是适用的，它也遵循 `NSObject` 协议：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Methods such as hash, description, `isEqual`, `isKindOfClass`, `isProxy`, and
    others are found in the `NSObject` protocol. `NSProxy` to `NSObject` protocol
    denotes that, implementing the basic `NSObject` methods, it's still possible to
    count on `NSProxy` instances.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NSObject` 协议中可以找到诸如 hash、description、`isEqual`、`isKindOfClass`、`isProxy`
    等方法。`NSProxy` 到 `NSObject` 协议表示，即使实现了基本的 `NSObject` 方法，仍然可以依赖 `NSProxy` 实例。
- en: Subclassing `NSObject` would pull in a lot of baggage that may cause a problem.
    `NSProxy` assists in order to prevent this by giving you a simpler superclass
    that doesn't have so much extra stuff in it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 继承 `NSObject` 会带来很多可能引起问题的负担。`NSProxy` 通过提供一个更简单的超类来帮助防止这种情况，这个超类中包含的额外内容较少。
- en: The fact that the `NSObject` protocol is useful for root classes isn't all that
    interesting for most Objective-C programming, for the simple fact that we don't
    make use of other root classes frequently. However, it will be very convenient
    when you need to make your own protocols.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数Objective-C编程来说，`NSObject`协议对根类的有用性并不那么有趣，因为简单的事实是我们不经常使用其他根类。然而，当你需要创建自己的协议时，这将非常方便。
- en: 'Let''s say, you have the following protocol:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，你有一个以下协议：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And there is a pointer to a simple object, `myOwnObject`, that accords to it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有一个指向简单对象`myOwnObject`的指针，它符合它：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can tell this object to perform `myFunction`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉这个对象执行`myFunction`：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, you cannot ask the object for its description:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能要求对象提供其描述：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And you can''t check it for equality:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法检查它的相等性：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In general, you can't ask it to do any of the stuff that a normal object can
    do. There are times when this doesn't have any importance, but in some circumstances,
    you will wish to be able to perform this task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不能要求它执行任何正常对象可以执行的操作。有时候这并不重要，但在某些情况下，你可能会希望能够执行这个任务。
- en: 'As mentioned earlier, `NSObject`, the root class of most Objective-C class
    hierarchies and through `NSObjects`, your Objective-C classes can inherit an interface
    to the system and also gain the ability to behave as Objective-C objects. So,
    `NSObject` is important if you want your objects to gain access to methods such
    as `isEqual`, so on, and so forth. This is where the `NSObject` protocol comes
    into the picture. Protocols can inherit from other protocols, which means that
    `MyProtocol` can inherit from the `NSObject` protocol:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`NSObject`是大多数Objective-C类层次结构的根类，通过`NSObjects`，你的Objective-C类可以继承系统接口，并获得作为Objective-C对象的行为能力。因此，如果你想让你的对象能够访问`isEqual`等方法，`NSObject`就很重要。这就是`NSObject`协议出现的地方。协议可以继承自其他协议，这意味着`MyProtocol`可以继承自`NSObject`协议：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This says that not only do objects that conform to `MyOwnProtocol` respond to
    `myFunction`, but they also respond to all those common messages in the `NSObject`
    protocol. Knowing that any object in your application directly or indirectly inherits
    from the `NSObject` class, that it's in accordance to the `NSObject` protocol,
    there is no imposition to any additional requirements on people implementing `MyOwnProtocol`,
    while giving you the permission to use these basic methods on instances.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示不仅符合`MyOwnProtocol`的对象会响应`myFunction`，它们还会响应`NSObject`协议中的所有那些常见消息。既然知道你的应用程序中的任何对象都是直接或间接地从`NSObject`类继承而来，并且符合`NSObject`协议，那么对实现`MyOwnProtocol`的人就没有额外的要求，同时允许你在实例上使用这些基本方法。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that there are two different NSObjects is abnormal for the frameworks;
    however, it starts to make sense when you go deeper into it. The `NSObject` protocol
    grants the permission to all root classes that have the same basic methods, making,
    also, a very easy way to declare a protocol that also includes basic functionality
    expected from any object. The `NSObject` class introduces it all together, since
    it's in accordance to the `NSObject` protocol. One thing to note here is that
    a custom class that's created and does not inherit `NSObject` can be considered
    as a root class, but once you make your custom class inherit from `NSObject`,
    then the root class won't be your custom class anymore, and the root class will
    be `NSObject`. However, generally, most of your custom classes should inherit
    from NSObjects; it will implement NSObject's functionality such as `alloc`, `init`,
    `release`, and so on and without inheriting from NSObject, these functionalities
    need to be written and implemented by you.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于框架来说，存在两个不同的`NSObject`是不正常的；然而，当你深入了解时，这开始变得有意义。`NSObject`协议允许所有具有相同基本方法的根类获得权限，这也为声明一个包含任何对象预期功能的基本功能协议提供了一个非常简单的方法。`NSObject`类将所有这些功能一起引入，因为它符合`NSObject`协议。这里需要注意的是，一个创建的且没有继承`NSObject`的自定义类可以被视为根类，但一旦你的自定义类从`NSObject`继承，那么根类就不再是你的自定义类，而是`NSObject`。然而，通常，你的大多数自定义类都应该继承自NSObjects；它将实现NSObject的功能，如`alloc`、`init`、`release`等，如果没有从NSObject继承，这些功能需要由你编写和实现。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what memory management in Objective-C is and how
    it works. You also learned the best practices while working with Manual Retain
    Release, and got an introduction to Automatic Reference Counting, Objective-C
    Objects, and root classes. ARC basically can be considered as a compile time guard
    against memory leaks as the compiler will automatically write the release statements
    for you at compile time. So, there is no need to write verbose release statements
    in your code to keep it clean and terse.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Objective-C 中的内存管理是什么以及它是如何工作的。你还学习了在手动管理保留和释放时的一些最佳实践，并了解了自动引用计数（ARC）、Objective-C
    对象和根类的基础知识。ARC 基本上可以被视为一种编译时防止内存泄漏的防护措施，因为编译器会在编译时自动为你编写释放语句。因此，你不需要在代码中编写冗长的释放语句来保持代码的简洁和紧凑。
- en: One tip to note for coding with memory management is that whenever you do `alloc`
    and `init`, then write your release code after that and put it in its appropriate
    place in your class, you can forget to call the release method after writing some
    or fixing some bugs. So writing your object release statements after you do `alloc`
    and `init` will help you to keep memory leaks to a minimum so that you won't have
    a situation where you get a memory leak as you have forgotten to write your object
    release statement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内存管理进行编码时，需要注意的一个小贴士是，无论何时你执行 `alloc` 和 `init`，然后在该之后编写你的释放代码，并将其放在你的类中适当的位置，你可能会忘记在编写某些代码或修复某些错误后调用释放方法。因此，在你执行
    `alloc` 和 `init` 之后编写你的对象释放语句将帮助你将内存泄漏降到最低，这样你就不会因为忘记编写对象释放语句而出现内存泄漏的情况。
- en: In the next chapter, you will learn more about ARC, how it works, its advantages,
    how to set up your projects to use ARC and memory models in Objective-C and UI
    Kit with ARC.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于 ARC 的内容，包括它是如何工作的、它的优点，以及如何设置你的项目以使用 ARC 和 Objective-C 及 UI Kit
    中的内存模型。
