# 8

# 服务、WorkManager和通知

本章将向您介绍在应用后台管理长时间运行任务的概念。在本章结束时，您将能够触发后台任务，当后台任务完成时为用户创建一个通知，并从通知中启动一个应用。本章将为您提供一个关于如何管理后台任务并让用户了解这些任务进度的坚实基础。

在上一章中，我们学习了如何请求用户权限并使用谷歌的地图API。有了这些知识，我们获取了用户的位置并允许他们在本地地图上部署一个代理。在本章中，我们将学习如何跟踪长时间运行的过程并向用户报告其进度。

我们将构建一个示例应用，假设**秘密猫特工**（**SCAs**）在15秒内被部署。当一只猫成功部署后，我们将通知用户并让他们启动应用，向他们展示成功的部署消息。

注意

我们将选择15秒，这样我们就可以避免在后台任务完成之前等待很长时间。

在移动世界中，持续的后台任务相当常见。即使应用未处于活动状态，后台任务也会运行。长时间运行的后台任务示例包括文件下载、资源清理作业、播放音乐和跟踪用户的位置。

从历史上看，谷歌为Android开发者提供了多种执行此类任务的方式：`服务`、`JobScheduler`、Firebase的`JobDispatcher`和`AlarmManager`。由于Android世界的碎片化，处理起来相当混乱。幸运的是，自从2019年3月以来，我们有了更好的（更稳定的）选择。

随着`WorkManager`的引入，谷歌已经为我们抽象了基于API版本选择后台执行机制的逻辑。我们仍然使用前台服务，这是一种特殊的服务，用于某些应该在运行时让用户知道的任务，例如播放音乐或在运行的应用中跟踪用户的位置。

注意

**服务**是设计在后台运行的应用组件，即使在应用未运行时也是如此。除了与通知相关联的前台服务外，服务没有用户界面。

在我们继续之前，先退一步。我们提到了服务，我们将专注于前台服务，但我们还没有完全解释什么是服务。服务是设计在后台运行的应用组件，即使在应用未运行时也是如此。

服务没有用户界面，除了前台服务。需要注意的是，服务在其宿主进程的主线程上运行。这意味着它们的操作可能会阻塞应用。我们必须在服务内部启动一个单独的线程来避免这种情况。

让我们开始，看看Android中用于管理后台任务的多种方法的实现。

在本章中，我们将涵盖以下主题：

+   使用`WorkManager`启动后台任务

+   对用户可见的后台操作 – 使用前台服务

# 技术要求

本章所有练习和活动的完整代码可在GitHub上找到，链接为[https://packt.link/i8IRQ](https://packt.link/i8IRQ)

# 使用`WorkManager`启动后台任务

我们在这里要解决的第一个问题是是否选择`WorkManager`或前台服务？为了回答这个问题，一个好的经验法则是问你是否需要用户实时跟踪操作。

如果答案是肯定的（例如，如果你有一个像响应用户的位置或播放背景音乐这样的任务），那么你应该使用带有附加通知的前台服务来给用户实时状态指示。当后台任务可以延迟或不需要用户交互（例如，下载大文件）时，使用`WorkManager`。

注意

从`WorkManager`的`2.3.0-alpha02`版本开始，你可以通过调用`setForegroundAsync(ForegroundInfo)`通过`WorkManager`单例启动前台服务。我们对那个前台服务的控制相当有限。它确实允许你将（预定义的）通知附加到工作，这就是为什么它值得提及。

在我们的示例应用中，我们将跟踪SCAs的部署准备工作。在代理可以出发之前，他们需要拉伸，梳理毛发，访问猫砂盆，并穿戴装备。这些任务中的每一个都需要一些时间。因为不能催促猫，代理会根据自己的时间完成每个步骤。我们能做的只是等待（并通知用户任务何时完成）。`WorkManager`非常适合这种场景。

要使用`WorkManager`，我们需要熟悉其四个主要类：

+   `WorkManager`：它接收工作并根据提供的参数和约束（如网络连接和设备充电）对其进行排队。

+   `Worker`：这是需要执行的工作的包装器。它有一个函数`doWork()`，我们重写它来实现后台工作代码。`doWork()`函数将在后台线程中执行。

+   `WorkRequest`：这个类将`Worker`类绑定到参数和约束。`WorkRequest`有两种类型：`OneTimeWorkRequest`，它只运行一次工作，和`PeriodicWorkRequest`，它可以用来安排工作在固定间隔运行。

+   `ListenableWorker.Result`：你可能已经猜到了，但这是一个持有执行工作结果的类。结果可以是`Success`、`Failure`或`Retry`。

除了这四个类之外，我们还有一个`Data`类，它持有传递给工作者的数据和从工作者返回的数据。

让我们回到我们的例子。我们想要定义四个需要按顺序发生的任务：猫需要伸展，然后需要梳理毛发，然后去猫砂盆，最后需要穿上衣服。

在我们开始使用 `WorkManager` 之前，我们必须首先将其依赖项包含在我们的应用 `build.gradle` 文件中：

[PRE0]

在我们的项目中包含 `WorkManager` 后，我们将继续创建我们的工作者。第一个工作者可能看起来像这样：

[PRE1]

我们首先通过扩展 `Worker` 并重写其 `doWork()` 函数来开始。然后，我们从输入数据中读取 SCA ID。然后，因为我们没有真实的传感器来跟踪猫伸展的进度，所以我们通过引入一个 3 秒（3,000 毫秒）的 `Thread.sleep(Long)` 调用来伪造等待。最后，我们使用我们在输入中收到的 ID 构造一个输出 `data` 类，并带着成功的结果返回它。

一旦我们为所有任务创建了工作者（`CatStretchingWorker`、`CatFurGroomingWorker`、`CatLitterBoxSittingWorker` 和 `CatSuitUpWorker`），类似于我们创建第一个工作者那样，我们可以调用 `WorkManager` 来链式连接它们。假设除非我们连接到互联网，否则我们无法知道代理的进度。我们的调用可能看起来像这样：

[PRE2]

在前面的代码中，我们首先构建了一个 `Constraints` 实例，声明我们需要连接到互联网才能执行工作。然后我们定义我们的输入数据，将其设置为 SCA ID。接下来，我们通过构建 `OneTimeWorkRequest` 将约束和输入数据绑定到我们的 `Worker` 类。

其他 `WorkRequest` 实例的构建已被省略，但它们几乎与这里展示的实例相同。我们现在可以将所有请求链式连接，并在 `WorkManager` 类中排队。你可以通过直接将 `WorkRequest` 实例传递给 `WorkManager` 的 `enqueue()` 函数来排队一个 `WorkRequest` 实例，或者你可以通过将所有 `WorkRequest` 实例作为一个列表传递给 `WorkManager` 的 `enqueue()` 函数来使多个 `WorkRequest` 实例并行运行。

当满足约束条件时，我们的任务将由 `WorkManager` 执行。

每个 `Request` 实例都有一个唯一的标识符。`WorkManager` 为每个请求公开了一个 `LiveData` 属性，允许我们通过传递其唯一标识符来跟踪其工作进度，如下面的代码所示：

[PRE3]

工作状态可以是 `BLOCKED`（存在一个请求链，而这个请求不在链中），`ENQUEUED`（存在一个请求链，而这个工作在链中），`RUNNING`（`doWork()` 中的工作正在执行），和 `SUCCEEDED`。工作也可以被取消，导致 `CANCELLED` 状态，或者它可能失败，导致 `FAILED` 状态。

最后，还有`Result.retry`。返回此结果会告诉`WorkManager`类再次入队工作。何时再次运行工作的策略由`WorkRequest` `Builder`上设置的`backoff`标准定义。默认的`backoff`策略是指数的，但我们可以将其设置为线性的。我们还可以定义初始的`backoff`时间。

让我们将到目前为止获得的知识应用到以下练习中。在本节中，我们将从我们发出部署命令的那一刻开始跟踪我们的SCA，直到它到达目的地的那一刻。

## 练习8.01 – 使用WorkManager类执行后台工作

在这个第一个练习中，我们将通过入队链式`WorkRequest`类来跟踪SCA在准备出发时的状态。

1.  首先创建一个新的`Empty Activity`项目（**File** | **New** | **New Project** | **Empty Activity**）。点击**Next**。

1.  将你的应用程序命名为`Cat` `Agent Tracker`。

1.  确保你的包名是`com.example.catagenttracker`。

1.  将保存位置设置为你要保存项目的地方。

1.  将其他所有内容保留为默认值，然后点击**完成**。

1.  确保你在**项目**面板中处于Android视图。

1.  打开你的应用的`build.gradle`文件。在`dependencies`块中添加`WorkManager`依赖项：

    [PRE4]

这将允许你在代码中使用`WorkManager`及其依赖项。

1.  在你的应用包下创建一个新的包（在`com.example.catagenttracker`上右键点击，然后选择`com.example.catagenttracker.worker`。

1.  在`com.example.catagenttracker.worker`下创建一个新的类，命名为`CatStretchingWorker`（在`worker`上右键点击，然后选择**New** | **New** **Kotlin File/Class**）。在**Kind**下，选择**Class**。

1.  要定义一个将睡眠`3`秒的`Worker`实例，更新新类如下：

    [PRE5]

这将为`Worker`实现添加所需的依赖项，并扩展`Worker`类。要实现实际的工作，你需要重写`doWork(): Result`，使其从输入中读取猫代理ID，睡眠`3`秒（`3,000`毫秒），构建一个包含猫代理ID的输出数据实例，并通过`Result.success`值传递它。

1.  重复*步骤9*和*步骤10*以创建三个更多相同的工作者，分别命名为`CatFurGroomingWorker`、`CatLitterBoxSittingWorker`和`CatSuitUpWorker`。

1.  打开`MainActivity`。在类末尾之前添加以下内容：

    [PRE6]

此辅助函数为你构建一个包含猫代理ID的输入`Data`实例。

1.  将以下内容添加到`onCreate(Bundle?)`函数中：

    [PRE7]

添加的第一行定义了一个网络约束。它告诉`WorkManager`类在执行工作之前等待网络连接。然后，你定义你的猫代理ID。最后，你定义四个请求，传入你的`Worker`类、网络约束和以输入数据形式提供的猫代理ID。

1.  在类的顶部，定义你的`WorkManager`：

    [PRE8]

1.  在你刚刚添加的代码下方添加一个链式`enqueue`请求，仍然在`onCreate`函数内：

    [PRE9]

你的`WorkRequests`现在已入队，在它们的约束条件满足且`WorkManager`类准备好执行它们时按顺序执行。

1.  定义一个函数来显示带有提供消息的吐司。它应该看起来像这样：

    [PRE10]

1.  要跟踪入队`WorkRequest`实例的进度，请在`enqueue`调用之后添加以下内容：

    [PRE11]

上述代码观察了`WorkManager`类为每个`WorkRequest`提供的`WorkInfo`可观察对象。当每个请求完成时，会显示一个包含相关信息的吐司（Toast）。

1.  运行你的应用程序：

![图8.1 – 按顺序显示的吐司](img/B19411_08_01.jpg)

图8.1 – 按顺序显示的吐司

现在，你应该会看到一个简单的`Hello World!`屏幕。然而，如果你等待几秒钟，你将开始看到通知吐司，告知你SCA准备部署到现场时的进度。你会注意到，吐司的顺序与你入队请求的顺序一致，并且它们会按顺序执行延迟。

# 对用户可见的后台操作 – 使用前台服务

我们将我们的SCA（服务组件架构）全部准备就绪，现在它们已经准备好前往指定的目的地。为了跟踪SCA，我们将定期使用前台服务轮询SCA的位置，并更新附加到该服务上的粘性通知（用户无法取消的通知）以显示新的位置。

注意

为了简化起见，我们将伪造位置。根据你在[*第7章*](B19411_07.xhtml#_idTextAnchor421)，“Android权限和Google Maps”中学到的知识，你可以稍后用使用地图的真实实现替换这个实现。

前台服务是执行后台操作的另一种方式。这个名字可能有点令人费解。它的目的是将这些服务与基本的Android（后台）服务区分开来。前者与一个通知相关联，而后者在后台运行，没有内置的用户界面表示。

前台服务和后台服务之间的重要区别之一是，当系统内存不足时，后者是终止候选者，而前者则不是。

自Android 9（派，或API级别28）起，我们必须请求`FOREGROUND_SERVICE`权限才能使用前台服务。由于它是一个正常权限，它将自动授予我们的应用程序。

在我们可以启动前台服务之前，我们必须首先创建一个。前台服务是Android抽象`Service`类的子类。如果我们不打算绑定到服务，在我们的例子中我们也不这样做，我们可以简单地重写`onBind(Intent)`使其返回`null`。

作为旁注，绑定是感兴趣客户端与服务通信的一种方式。在这本书中，我们不会关注这种方法，因为还有其他更简单的方法，你将会发现。

前台服务必须与通知绑定。在Android 8（Oreo，或API级别26）及以上版本中，如果前台服务在**应用程序无响应**（**ANR**）时间窗口内（大约五秒）没有绑定到任何一个，服务将被停止，应用将被声明为无响应。

由于这个要求，我们最好尽快将服务与通知绑定。最好的地方是在服务的`onCreate()`函数中这样做。一个快速实现可能看起来像这样：

[PRE12]

让我们将其分解。

我们首先定义通道ID。这对于Android Oreo或更高版本是必需的，在Android的早期版本中被忽略。在Android Oreo中，谷歌引入了通道的概念。通道用于分组通知，并允许用户过滤掉不想要的 notifications。

接下来，我们定义`pendingIntent`。这将是在用户点击通知时启动的`Intent`。在这个例子中，主活动将被启动。它是通过将一个启动活动的`Intent`包装在`PendingIntent`中来构建的。请求代码被设置为`0`，因为在这个例子中我们不期望有结果，所以代码将不会被使用。

对于低于S（31）的API，标志被设置为`0`。否则，它被设置为推荐的`PendingIntent.FLAG_IMMUTABLE`，这意味着在发送时传递给`Intent`的额外参数将被忽略。

使用通道ID和`pendingIntent`，我们可以构建我们的通知。我们使用`NotificationCompat`，它消除了支持旧API级别的一些样板代码。我们传入上下文和通道ID。我们定义标题、文本、小图标、`Intent`和滚动消息，并构建通知以完成构建器：

[PRE13]

要在前台启动一个服务，将通知附加到它，我们调用`startForeground(Int, Notification)`函数，传入一个通知ID（任何唯一的`int`值来标识这个服务，该值不能为0）和一个通知，该通知必须将其优先级设置为`PRIORITY_LOW`或更高。在我们的例子中，我们没有指定优先级，这将其设置为`PRIORITY_DEFAULT`：

如果启动，我们的服务现在将显示一个粘性通知。点击通知将启动我们的主活动。

目前，我们的服务除了显示通知外不执行任何操作。要向其中添加一些功能，我们需要重写`onStartCommand(Intent?, Int, Int)`。当服务通过Intent启动时，会调用这个函数。

这也给了我们读取通过该Intent传递的任何额外数据的机会。它还提供了标志（可能设置为`START_FLAG_REDELIVERY`或`START_FLAG_RETRY`）和一个唯一的请求ID。我们将在本章的后面部分学习如何读取额外数据。在简单实现中，你不需要担心标志或请求ID。

重要的一点是`onStartCommand(Intent?, Int, Int)`在UI线程上被调用，所以不要在这里执行任何长时间运行的操作，否则你的应用会冻结，给用户带来糟糕的体验。相反，我们可以创建一个新的`HandlerThread`（一个具有looper的线程，用于为线程运行消息循环）并把它的工作发送给它。

这意味着我们将有一个无限循环在运行，等待我们通过一个`Handler`来向其发送消息。当我们收到一个`start`命令时，我们可以将我们想要执行的工作发送给它。然后，这项工作将在那个线程上执行。

当我们的长时间运行的工作完成时，我们可能希望发生几件事情。首先，我们可能希望通知任何感兴趣的人（例如，如果它正在运行，我们的主活动）我们已经完成。然后，我们可能想要停止在前台运行。最后，如果我们不期望再次需要该服务，我们可以停止它。

应用有几种与服务通信的方式：绑定、使用广播接收器、使用总线架构或使用结果接收器，仅举几例。在我们的例子中，我们将使用Google的`LiveData`。

在我们继续之前，值得简要提及广播接收器。广播接收器允许我们的应用使用类似于*发布-订阅*设计模式的模式发送和接收消息。

系统会广播一些事件，例如设备启动或充电开始。我们的服务也可以广播状态更新。例如，它们可以在完成时广播一个长时间的计算结果。如果我们应用注册接收某个消息，系统将在该消息广播时通知我们。

这曾经是与服务通信的常见方式，但现在`LocalBroadcastManager`类已被弃用，因为它是一个应用级的事件总线，鼓励了反模式。

话虽如此，广播接收器对于系统级事件仍然很有用。我们首先定义一个类，它覆盖了`BroadcastReceiver`抽象类：

[PRE14]

当`ToastBroadcastReceiver`接收到一个事件时，它将显示一个吐司，显示事件的动作和URI。

我们可以通过`Manifest.xml`文件注册我们的接收器：

[PRE15]

指定`android:exported="true"`告诉系统这个接收器可以接收来自应用外部的消息。动作定义了我们感兴趣的消息。我们可以指定多个动作。在这个例子中，我们监听设备开始充电的情况。请注意，将此值设置为`true`允许其他应用，包括恶意应用，激活此接收器。

我们还可以注册接收编码消息：

[PRE16]

将此代码添加到活动或我们的自定义应用程序类中也会注册我们的接收器的新实例。只要上下文（活动或应用）有效，这个接收器就会存在。因此，相应地，如果活动或应用被销毁，我们的接收器将被释放以进行垃圾回收。

现在回到我们的实现。`LiveData` 已经包含在 `androidx.appcompat` 中，这样我们就不必手动将其包含到我们的项目中。我们可以在服务的伴生对象中定义一个 `LiveData` 实例，如下所示：

[PRE17]

注意，我们将 `MutableLiveData` 实例隐藏在 `LiveData` 接口后面。这样做是为了确保消费者只能读取数据。现在我们可以使用 `mutableWorkCompletion` 实例通过为其赋值来报告完成。然而，我们必须记住，值只能分配给主线程上的 `LiveData` 实例。

这意味着一旦我们的工作完成，我们必须切换回主线程。我们可以轻松实现这一点——我们只需要一个新的处理器，使用主 `Looper`（通过调用 `Looper.getMainLooper()` 获取），然后我们可以向其发送更新。

现在我们已经准备好让服务开始工作，我们终于可以启动它了。在我们这样做之前，我们必须确保我们已经将服务添加到 `<application></application>` 块中的 `AndroidManifest.xml` 文件中，如下面的代码所示：

[PRE18]

要启动我们添加到清单中的服务，我们创建 `Intent`，传递任何所需的额外数据，如下面的代码所示：

[PRE19]

然后，我们调用 `ContextCompat.startForegroundService(Context, Intent)` 来触发 `Intent` 并启动服务。

## 练习 8.02 – 使用前台服务跟踪 SCA 的作业

在第一个练习中，你使用 `WorkManager` 类和多个 Worker 实例显示吐司来跟踪 SCA 准备出发的情况。在这个练习中，你将通过显示一个倒计时通知来跟踪 SCA 部署到现场并向指定的目标移动。

这个通知将由前台服务驱动，它将展示并持续更新它。在任何时候点击通知，如果主活动尚未运行，它将启动主活动，并始终将其带到前台：

1.  首先，将 `WorkManager` 依赖项添加到你的应用的 `build.gradle` 文件中：

    [PRE20]

1.  创建一个名为 `RouteTrackingService` 的新类，继承自抽象类 `Service`：

    [PRE21]

在这个练习中，你将不会依赖绑定，因此在 `onBind(Intent)` 实现中简单地返回 `null` 是安全的。

1.  在新创建的服务中，定义一些你稍后需要的常量，以及用于观察进度的 `LiveData` 实例：

    [PRE22]

`NOTIFICATION_ID` 必须是此服务拥有的通知的唯一标识符，且不能为 `0`。现在，`EXTRA_SECRET_CAT_AGENT_ID` 是你将用于向服务传递数据的常量。`mutableTrackingCompletion` 是私有的，用于允许你通过 `LiveData` 内部发布完成更新，而不在服务外部暴露可变性。`trackingCompletion` 然后用于以不可变的方式公开 `LiveData` 实例供观察。

1.  在你的 `RouteTrackingService` 类中添加一个函数，以提供 `PendingIntent` 给你的粘性通知：

    [PRE23]

这将在用户点击`Notification`时启动`MainActivity`。您调用`PendingIntent.getActivity()`，传递一个上下文、没有请求代码（`0`）、将启动`MainActivity`的`Intent`以及如果可用则传递`FLAG_IMMUTABLE`标志，否则不传递任何标志（`0`）。您将获得一个`PendingIntent`，它将启动该活动。

1.  添加另一个函数以在运行Android Oreo或更高版本的设备上创建`NotificationChannel`并返回通道ID：

    [PRE24]

您首先检查Android版本。只有在Android O或更高版本时才需要创建通道。否则，您可以返回一个空字符串。对于Android O，您定义通道ID。这需要对于包来说是唯一的。接下来，您定义一个用户可见的通道名称。

这可以（并且应该）进行本地化。为了简化，我们跳过了那部分。然后创建一个`NotificationChannel`实例，并将重要性设置为`IMPORTANCE_DEFAULT`。重要性决定了发送到该通道的通知的干扰程度。

最后，使用`Notification Service`和`NotificationChannel`实例中提供的数据创建一个通道。该函数返回通道ID，以便可以用于构建`Notification`。

1.  创建一个函数以提供`Notification.Builder`：

    [PRE25]

此函数接受您之前创建的函数生成的`pendingIntent`和`channelId`实例，并构建一个`NotificationCompat.Builder`类。

构建器允许您定义标题（第一行）、文本（第二行）、要使用的小图标（大小根据设备而异）、当用户点击**Notification**时触发的`Intent`以及一个标签（用于辅助功能；在Android Lollipop之前，在通知显示之前显示）。

将通知设置为持续状态可以防止用户将其取消。这也防止了Android因频繁更新而静音通知。

您还可以设置其他属性。探索`NotificationCompat.Builder`类。在实际项目中，请记住使用`strings.xml`中的字符串资源而不是硬编码的字符串。

1.  实现以下代码以引入一个启动前台服务的函数：

    [PRE26]

您首先使用您之前引入的`getPendingIntent`函数获取`PendingIntent`。然后，根据设备的API级别，您创建一个通知通道并获取其ID或设置一个空ID。

您将`pendingIntent`和`channelId`传递给构建`NotificationCompat.Builder`的函数，并以前台服务的方式启动服务，提供`NOTIFICATION_ID`和由构建器构建的通知。该函数返回`NotificationCompat.Builder`，稍后用于更新通知。

1.  在您的服务中定义两个字段——一个用于持有可重用的`NotificationCompat.Builder`类，另一个用于持有`Handler`的引用，您稍后将在后台使用它来发布工作：

    [PRE27]

1.  接下来，重写`onCreate()`以将服务作为前台服务启动，并保留`Notification.Builder`的引用，然后创建`serviceHandler`：

    [PRE28]

注意，要创建`Handler`实例，你必须首先初始化并启动`HandlerThread`。

1.  定义一个跟踪你部署的SCA在接近其指定目的地时的调用：

    [PRE29]

这将首先获取`NotificationManager`的引用。然后，它将从`10`倒数到`0`，在更新之间睡眠1秒，然后使用剩余时间更新通知。注意我们设置了静默通知。这避免了通知每秒播放声音。

1.  添加一个在主线程上通知观察者完成情况的函数：

    [PRE30]

通过在主`Looper`上发布消息，你确保更新发生在主（UI）应用线程上。当设置代理ID的值时，你是在通知所有观察者该代理ID已到达目的地。

1.  按如下方式重写`onStartCommand(Intent?, Int, Int)`：

    [PRE31]

你首先将调用委托给`super`，它内部调用`onStart()`并返回一个向后兼容的状态，你可以返回这个状态。你存储这个返回值。接下来，你从通过`Intent`传递的额外内容中获取SCA ID。如果没有提供代理ID，该服务将无法工作，因此你抛出一个异常。

接下来，你切换到`onCreate`中定义的背景线程，以阻塞方式跟踪代理到其目的地。当跟踪完成时，你通知观察者任务已完成，停止前台服务（通过传递`true`移除通知），并停止服务本身，因为你不期望很快再次需要它。然后你返回之前存储的从`super`返回的值。

1.  更新你的`AndroidManifest.xml`文件以请求必要的权限并引入服务：

    [PRE32]

首先，我们声明我们的应用需要`FOREGROUND_SERVICE`权限。除非我们这样做，否则系统会阻止我们的应用使用前台服务。我们还请求`POST_NOTIFICATIONS`权限，没有这个权限，我们无法在SDK 33+上显示通知。接下来，我们声明服务。设置`android:enabled="true"`告诉系统它可以实例化该服务。

默认值为`"true"`，因此这是可选的。使用`android:exported="true"`定义服务告诉系统其他应用程序可以启动该服务。在我们的情况下，我们不需要这个额外的功能，但我们添加它只是为了让你了解这种能力。

1.  回到你的`MainActivity`。引入一个用于启动`RouteTrackingService`的函数：

    [PRE33]

此函数首先观察`trackingCompletion` `LiveData`以获取完成更新，并在完成时显示结果。然后，它定义一个用于启动服务的`Intent`，将SCA ID作为该`Intent`的额外参数。然后，它使用`ContextCompat`以前台服务的方式启动服务，这为您隐藏了兼容性相关的逻辑。

1.  现在，将`onCreate()`中的逻辑（`setContentView`调用之后的所有内容）提取到一个名为`dispatchCat`的私有函数中。

1.  将`dispatchCat`更新为在SCA装备完毕并准备出发时立即开始跟踪：

    [PRE34]

1.  创建一个名为`ensurePermissionGrantedAndDispatchCat`的新私有函数。在这个函数中，确保你有`POST_NOTIFICATIONS`权限。如果没有，请请求它。有关实现细节，请参阅[*第7章*](B19411_07.xhtml#_idTextAnchor421)，*Android权限和Google Maps*。如果你或你有权限，请调用`dispatchCat`。

1.  启动应用程序：

![图8.2 – 通知倒计时](img/B19411_08_02.jpg)

图8.2 – 通知倒计时

在通知告知你SCA的准备工作步骤之后，你应该在你的状态栏中看到一个通知。然后，该通知应从10倒数到0，消失，并替换为一个吐司通知，告知你代理已到达目的地。看到最后一个吐司通知告诉你，你成功将SCA ID传达给了服务，并在后台任务完成后将其返回。

利用本章获得的所有知识，让我们完成以下活动。

## 活动8.01 – 喝水提醒

人类平均每天会流失大约2,500 **毫升**（**ml**）的水。为了保持健康，我们需要消耗与流失相等的水量。然而，由于现代生活的繁忙性质，我们很多人会忘记定期补充水分。

注意

有关此信息的更多信息，请参阅[https://packt.link/90nbQ](https://packt.link/90nbQ)。

假设你想开发一个应用程序，该应用程序可以跟踪你的水分流失（统计上）并持续更新你的体液平衡。从平衡状态开始，应用程序会逐渐降低用户跟踪的水位。用户可以在喝了一杯水后告诉应用程序，应用程序会相应地更新水位。

水位持续更新的过程将利用你运行后台任务的知识，你还将利用与服务通信的知识来根据用户交互更新余额。

以下步骤将帮助你完成活动：

1.  创建一个空的活动项目，并将你的应用程序命名为`My Water Tracker`。

1.  将前台服务和发布通知权限添加到你的`AndroidManifest.xml`文件中。

1.  创建一个新的服务。

1.  在你的服务中定义一个变量来跟踪水位。

1.  定义通知ID和额外的`Intent`数据键的常量。

1.  从服务中设置通知的创建。

1.  添加请求通知权限（如果需要）、启动前台服务和更新水位的功能。

1.  将水位设置为每5秒降低0.144毫升。

1.  处理来自服务外部的液体添加。

1.  确保服务在销毁时清理回调和消息。

1.  在`Manifest.xml`文件中注册服务。

1.  在创建活动并在必要时授予通知权限后，从`MainActivity`启动服务。

1.  在主活动布局中添加一个带有**喝了一杯水**标签的按钮。

1.  当用户点击按钮时，通知服务需要增加250毫升的水位。

注意

该活动的解决方案可在[https://packt.link/By7eE](https://packt.link/By7eE)找到。

# 摘要

在本章中，我们学习了如何使用`WorkManager`和前台服务执行长时间运行的后台任务。我们讨论了如何向用户传达进度，以及如何在任务执行完成后将用户带回应用。本章涵盖的所有主题都非常广泛，你可以进一步探索与服务通信、构建通知和使用`WorkManager`类。

对于大多数常见场景，你现在拥有了所需的工具。常见的用例包括后台下载、清理缓存资源、在应用不在前台运行时播放媒体，以及结合我们从[*第7章*](B19411_07.xhtml#_idTextAnchor421)学到的知识，即*Android权限和Google Maps*，跟踪用户随时间变化的位置。

在下一章中，我们将探讨通过编写单元和集成测试来使我们的应用更加健壮和易于维护。这在你的代码在后台运行且错误发生时并不立即明显的情况下尤其有帮助。
