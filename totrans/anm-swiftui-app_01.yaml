- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Exploring the Fundamentals of SwiftUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SwiftUI基础
- en: Welcome to *Animating SwiftUI Applications*! If you picked up this book, then
    there’s a good chance you are a developer – or aspiring to be one – and you want
    to learn more about SwiftUI animations. Or maybe you’re fascinated by animations
    and how they work like I am. I know for me that the first time I played a video
    game (before the home computer was even available) and saw objects collide and
    bounce off each other on the screen, I was hooked by animations and the code behind
    how they worked. Whatever the reason you’re here though, together we will explore
    the amazing things we can make happen on an Apple device by leveraging the power
    of SwiftUI’s animation classes, methods, and properties.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 *Animating SwiftUI Applications*！如果你拿起这本书，那么你很可能是一名开发者——或者正在努力成为开发者——并且你想要了解更多关于SwiftUI动画的知识。或者也许你对动画以及它们是如何工作的很感兴趣，就像我一样。我知道对我来说，第一次玩电子游戏（在家用电脑出现之前）并看到屏幕上的物体相互碰撞并弹跳，我被动画以及它们工作背后的代码深深吸引。无论你为什么来到这里，但我们将一起探索利用SwiftUI动画类、方法和属性的力量，在苹果设备上可以实现的惊人事物。
- en: This chapter starts with a brief look at the two programming styles, imperative
    and declarative, and will give you an idea of why Apple introduced the declarative
    SwiftUI way of coding to the development world. Then, we’ll explore the Xcode
    interface, the free application from Apple, where we do all of our work. Finally,
    we’ll look at the SwiftUI structures needed to develop apps, which is the foundation
    for proceeding further with animations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从简要介绍两种编程风格，命令式和声明式，并给你一个为什么苹果将声明式的SwiftUI编程方式引入开发世界的原因。然后，我们将探索苹果提供的免费应用程序Xcode的界面，在那里我们完成所有的工作。最后，我们将查看开发应用程序所需的SwiftUI结构，这是进一步进行动画的基础。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding imperative and declarative programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令式和声明式编程
- en: Exploring the Xcode interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Xcode界面
- en: Understanding the state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解状态
- en: Understanding SwiftUI structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SwiftUI结构
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to write code that can run on Apple devices, first, we need an Apple
    computer. This can be any of their models, but the MacBook Pro is the most popular
    for coding because of its power and speed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写能在苹果设备上运行的代码，首先，我们需要一台苹果电脑。这可以是他们任何一款型号，但MacBook Pro因其强大的性能和速度，是编码中最受欢迎的选择。
- en: Once we have the hardware, then the next bit of tech we need to write code is
    the software. Apple has put together a very comprehensive set of tools all bundled
    into one program called Xcode, which is free to download from the App Store. Those
    two things are everything you need to start writing code on Apple, but if you
    want to upload your finished app to the App Store, then you will need an Apple
    Developer account. This currently costs $99 a year to maintain, but it is necessary
    to be able to sell your apps to the world. Go to [developer.apple.com](http://developer.apple.com)
    and sign up for an account there.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了硬件，接下来我们需要的技术来编写代码就是软件。苹果已经将一套非常全面的工具捆绑在一个名为Xcode的程序中，可以从App Store免费下载。这两样东西就是你开始编写苹果代码所需的一切，但如果你想要将你的完成的应用程序上传到App
    Store，那么你需要一个苹果开发者账户。目前，维护这个账户每年需要99美元，但这是将你的应用程序销售给全世界所必需的。请访问[developer.apple.com](http://developer.apple.com)并在那里注册账户。
- en: You should also have a working knowledge of the Swift programming language so
    that you feel comfortable writing code, but you don’t have to be an expert by
    any means; it’s just that it is very helpful if you understand, or at least recognize,
    the syntax of the Swift language and the fundamentals of **object-oriented programming**
    (**OOP**) so that you can follow along with the projects better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该具备Swift编程语言的实际知识，这样你才能在编写代码时感到舒适，但你不一定需要成为专家；只是如果你理解，或者至少能识别Swift语言的语法和面向对象编程（**OOP**）的基础，这将非常有帮助，这样你就能更好地跟随项目进行。
- en: With that said, if you are a complete beginner to writing code, you might be
    a bit confused here – but not to worry, when Apple introduced the Swift programming
    language in 2014, they held fast to their goal of making one of the easiest-to-pick-up
    and most user-friendly programming languages to date. And for the most part, the
    Swift language reads like English sentences, so you can progress very quickly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果您是编写代码的初学者，您可能会在这里感到有些困惑——但不用担心，当苹果在2014年推出Swift编程语言时，他们坚持了他们的目标，即创建迄今为止最容易上手和最用户友好的编程语言之一。而且，从很大程度上说，Swift语言读起来就像英语句子，所以您可以非常快速地进步。
- en: 'Here is what I recommend when you’re just starting out learning Swift:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您刚开始学习Swift时，我推荐以下内容：
- en: Start with the Swift tutorials offered by Paul Hudson. He is a brilliant Swift
    programmer, and one of the most prolific in the industry. He has put together
    tons of free Swift training tutorials and videos that get you to write code fast.
    I have worked with Paul on many projects, and you would be hard-pressed to find
    a better and more thorough teaching style – he’s also just an all-around nice
    guy. Check out all his stuff at [hackingwithswift.com](http://hackingwithswift.com).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从保罗·哈德森提供的Swift教程开始。他是一位出色的Swift程序员，也是业界最富有创造力的人之一。他已经整理了大量免费Swift培训教程和视频，帮助您快速编写代码。我曾与保罗合作过许多项目，您很难找到比他更好、更全面的授课风格——他也是一个非常和善的人。请访问他的所有资料[http://hackingwithswift.com](http://hackingwithswift.com)。
- en: Someone else I have worked with (and continue to work with) is John D. Gauchat.
    He has put together a Swift and SwiftUI Mastermind series of books that can serve
    as both a reference and a guide/cookbook of code for when you need to remember
    the syntax or how to implement something fast. He is very thorough as well, and
    you can find his work at [jdgauchat.com](http://jdgauchat.com).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我还与另一位（并且继续与他合作）的人约翰·D·高查特合作过。他已经整理了一套Swift和SwiftUI大师系列书籍，这些书籍可以作为参考和指南/代码手册，当您需要记住语法或快速实现某事时使用。他同样非常全面，您可以在[http://jdgauchat.com](http://jdgauchat.com)找到他的作品。
- en: Finally, if you like structured video courses, I have translated many of Paul’s
    and John’s Swift and SwiftUI books into video courses, and they are available
    over at [udemy.com](http://udemy.com) – just search for my name to see them all,
    including the video version of this book (which includes extra projects).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您喜欢结构化的视频课程，我已经将保罗和约翰的许多Swift和SwiftUI书籍翻译成了视频课程，它们在[udemy.com](http://udemy.com)上提供——只需搜索我的名字即可查看所有课程，包括本书的视频版本（其中包含额外项目）。
- en: OK, that’s enough of those shameful plugs, but if you are a complete beginner,
    I want you to learn the Swift programming language from the very best, and those
    two guys are; this way, you will be ready to follow along and code in no time.
    So, go get some Swift knowledge under your belt, and come back here. I’ll wait…
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这些令人尴尬的推荐就到这里，但如果您是编程的初学者，我希望您从最好的Swift编程语言开始学习，这两位就是；这样，您将很快准备好跟随并编写代码。所以，去获取一些Swift知识，然后回来这里。我会等你的…
- en: 'Finally, to access all of the code in this book, go to the following GitHub
    repository: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要访问本书中的所有代码，请访问以下GitHub仓库：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Understanding imperative and declarative programming
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令式和声明式编程
- en: SwiftUI is a fairly new framework introduced by Apple in 2019 that includes
    intuitive new design tools that help make building great-looking interfaces almost
    as easy as dragging and dropping… almost. With its modular approach, it’s estimated
    that you can build the same projects previously built in Xcode using about five
    times less code. Also, SwiftUI was Apple’s solution for building apps that can
    easily be used on all of their other platforms – so, an app can be built once,
    and it will perform perfectly on iOS, tvOS, macOS, and watchOS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI是苹果在2019年推出的一种相对较新的框架，它包括直观的新设计工具，可以帮助构建看起来很棒的界面，几乎就像拖放一样简单…几乎。凭借其模块化方法，据估计，您可以使用大约五分之一的代码构建之前在Xcode中构建的相同项目。此外，SwiftUI是苹果为构建可以在其所有其他平台上轻松使用的应用程序的解决方案——因此，一个应用程序只需构建一次，就可以在iOS、tvOS、macOS和watchOS上完美运行。
- en: The SwiftUI interface, which we will cover shortly, uses editor and canvas preview
    windows that work in tandem. As you code in the Xcode editor, the new design canvas
    displays everything completely in sync and renders in real time as you type. So,
    any change you make in the editor is immediately reflected in the canvas preview,
    and vice versa.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍SwiftUI界面，它使用协同工作的编辑器和画布预览窗口。当你使用Xcode编辑器编写代码时，新的设计画布会完全同步显示，并且在你键入时实时渲染。因此，你在编辑器中做出的任何更改都会立即反映在画布预览中，反之亦然。
- en: I mentioned the ease of drag and dropping in code earlier; this is because those
    nice engineers at Apple must have spent countless nights working hard putting
    together a huge selection of pre-made chunks of code called views and modifiers
    that you can drag and drop right into the editor. This includes things such as
    buttons, labels, menus, lists, pickers, forms, text fields, toggle switches, modifiers,
    events, navigation objects, effects, and well, much more, but you get the point.
    Unlike UIKit and Storyboards, when you drop a view or a modifier into the editor
    or on the canvas, SwiftUI generates the code for that view automatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过代码中拖放操作的便捷性；这是因为那些优秀的苹果工程师们肯定花费了无数个夜晚辛勤工作，精心打造了一个庞大的预置代码块集合，称为视图和修饰符，你可以直接拖放到编辑器中。这包括按钮、标签、菜单、列表、选择器、表单、文本字段、切换开关、修饰符、事件、导航对象、效果等等，但关键点在于此。与UIKit和Storyboards不同，当你将视图或修饰符拖放到编辑器或画布上时，SwiftUI会自动生成该视图的代码。
- en: The SwiftUI approach to app development is known as **declarative programming**,
    and it has become widely popular in the last few years. Examples of declarative
    programming would include frameworks such as React and cross-platform development
    frameworks such as React Native and Flutter. So, now it’s Apple’s turn to offer
    its own completely native declarative UI framework, SwiftUI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI的app开发方法被称为**声明式编程**，在过去的几年中已经变得非常流行。声明式编程的例子包括React框架以及跨平台开发框架如React
    Native和Flutter。因此，现在是苹果公司推出它自己的完全本地的声明式UI框架SwiftUI的时候了。
- en: But what does declarative programming actually mean? Well, to best describe
    declarative programming, let’s first understand what imperative programming is.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但声明式编程实际上意味着什么呢？好吧，为了最好地描述声明式编程，让我们首先了解命令式编程是什么。
- en: '**Imperative programming** has been the oldest programming paradigm since the
    dawn of computer languages. The word “imperative” has its origin in the Latin
    word “imperare”, which means “to command,” and it was first used to express a
    command – for example: “do it”! (Hmm, I wonder whether Nike borrowed that imperative
    command and tweaked it a little…) This style of programming is what iOS developers
    used before SwiftUI came out.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式编程**是自计算机语言诞生以来最古老的编程范式。单词“imperative”源自拉丁语单词“imperare”，意为“命令”，它最初被用来表达命令——例如：“做它！”（嗯，我想知道耐克是否借鉴了这个命令式指令并稍作修改……）这种编程风格是SwiftUI推出之前iOS开发者所使用的。'
- en: Imperative programming is a programming paradigm that uses statements that change
    a program’s state. These statements are executed in a specific order, and they
    usually involve assignment statements, loops, and control structures that specify
    how the computation should be carried out.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程是一种编程范式，它使用改变程序状态的语句。这些语句按照特定顺序执行，通常涉及赋值语句、循环和控制结构，这些结构指定了计算应该如何执行。
- en: In imperative programming, the programmer specifies exactly how the computation
    should be carried out, using statements that tell the computer what to do. This
    can make imperative programs more complex because the programmer has to specify
    all of the steps of computation. However, it can also make them more flexible
    because the programmer has more control over the details of the computation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，程序员通过告诉计算机做什么来指定计算的具体执行方式。这可能会使命令式程序更加复杂，因为程序员必须指定计算的所有步骤。然而，这也可能使它们更加灵活，因为程序员对计算的细节有更多的控制。
- en: 'Here is an example of imperative programming using the UIKit framework in iOS:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用iOS中UIKit框架进行命令式编程的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code creates a new `UIButton`, sets its title and title color, and adds
    an action to be performed when the button is tapped. It then adds the button to
    the view hierarchy. This code is imperative because it specifies the exact steps
    needed to create and configure the button and add it to the view.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新的 `UIButton`，设置了其标题和标题颜色，并添加了在按钮被点击时执行的操作。然后它将按钮添加到视图层次结构中。这段代码是命令式的，因为它指定了创建和配置按钮并将其添加到视图的精确步骤。
- en: 'Now, this same code could also be written in a declarative style using a library
    such as SwiftUI, ReactiveCocoa, or RxSwift, which allows you to specify the desired
    behavior of the button rather than the steps needed to achieve it. Here is the
    same example written using SwiftUI:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段相同的代码也可以使用类似 SwiftUI、ReactiveCocoa 或 RxSwift 这样的库以声明式风格编写，这些库允许你指定按钮的期望行为而不是实现它的步骤。以下是使用
    SwiftUI 编写的相同示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `Button` view is declarative, because it specifies the
    desired behavior of the button (displaying text and performing an action when
    tapped), rather than the steps needed to create and configure the button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Button` 视图是声明式的，因为它指定了按钮的期望行为（显示文本并在点击时执行操作），而不是创建和配置按钮所需的步骤。
- en: SwiftUI uses a declarative style of programming, which can make it easier to
    understand and maintain your code because you don’t have to specify all of the
    intermediate steps needed to achieve the desired behavior. It also allows your
    code to automatically update when the underlying data changes because you specify
    the desired outcome rather than the steps needed to achieve it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 使用声明式编程风格，这使得理解和维护代码变得更加容易，因为你不需要指定实现所需行为所需的所有中间步骤。它还允许你的代码在底层数据发生变化时自动更新，因为你指定的是期望的结果而不是实现它的步骤。
- en: So, declarative programming is a programming paradigm in which a program specifies
    what it wants to achieve, rather than how to achieve it. The focus is on the “what”
    rather than the “how.” Declarative programs are usually easier to understand because
    they don’t require the programmer to specify every single step of the computation.
    They can also be more concise because they don’t need to specify all of the intermediate
    steps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，声明式编程是一种编程范式，其中程序指定它想要实现的内容，而不是如何实现它。重点是“什么”而不是“如何”。声明式程序通常更容易理解，因为它们不需要程序员指定计算的每个步骤。它们也可以更简洁，因为它们不需要指定所有中间步骤。
- en: There are many different programming languages and technologies that support
    declarative programming, including SQL, HTML, and functional programming languages
    such as Haskell and Lisp. In general, declarative programming is well suited to
    tasks that involve defining data relationships or specifying a desired output,
    rather than specifying the steps needed to achieve something.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的编程语言和技术支持声明式编程，包括 SQL、HTML 以及 Haskell 和 Lisp 这样的函数式编程语言。一般来说，声明式编程非常适合涉及定义数据关系或指定期望输出的任务，而不是指定实现某事的步骤。
- en: 'To clarify, let’s use the analogy of an artist: imperative languages paint
    by numbers to reach the desired result, a finished painting, but declarative languages
    use the finished painting and let background algorithms (functions and methods)
    automatically choose the appropriate colors and brush strokes to achieve the desired
    result. Also, by using this declarative approach, SwiftUI minimizes or eliminates
    programming side effects, usually caused by tracking the state of the program.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，让我们用艺术家的类比：命令式语言通过数字绘画以达到预期的结果，即完成的作品，而声明式语言使用完成的作品，让后台算法（函数和方法）自动选择合适的颜色和笔触以达到预期的结果。此外，通过使用这种声明式方法，SwiftUI
    最小化或消除了通常由跟踪程序状态引起的编程副作用。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will want to keep in mind that in many cases, code will be a mixture of
    both imperative and declarative styles, so it’s not always one or the other.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住，在许多情况下，代码将是命令式和声明式风格的混合体，所以它不总是单一的风格。
- en: With a better understanding of SwiftUI now, we will proceed to an overview of
    the Xcode interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 SwiftUI 有更好的理解，我们将继续介绍 Xcode 界面概述。
- en: Exploring the Xcode interface
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Xcode 界面
- en: In this section, we will take a tour of the Xcode interface. I’m assuming that
    you have used Xcode before, practicing your Swift skills, which means you have
    a good handle on many of the things here in the interface. However, there are
    a few new additions to accommodate SwiftUI.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将游览 Xcode 界面。我假设您之前已经使用过 Xcode，练习 Swift 技能，这意味着您已经很好地掌握了界面中的许多事物。然而，有一些新功能是为了适应
    SwiftUI 而添加的。
- en: When you first start up Xcode, you see the welcome screen. On the right is a
    list of recent projects, and on the left, there are buttons to start a new project,
    open an existing project, or clone one saved in a repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次启动 Xcode 时，您会看到欢迎界面。在右侧是一个最近项目的列表，在左侧有按钮可以开始一个新项目、打开一个现有项目或克隆一个存储在仓库中的项目。
- en: '![Figure 1.1: Xcode welcome screen ](img/B18674_01_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：Xcode 欢迎界面](img/B18674_01_01.jpg)'
- en: 'Figure 1.1: Xcode welcome screen'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：Xcode 欢迎界面
- en: We will be using the first option, which is **Create a new Xcode project**,
    for all of our projects, so select that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第一个选项，即 **创建一个新的 Xcode 项目**，用于我们所有的项目，因此请选择该选项。
- en: 'The next screen lets us choose options for the project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一屏允许我们选择项目的选项：
- en: '![Figure 1.2: Project options  ](img/B18674_01_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：项目选项](img/B18674_01_02.jpg)'
- en: 'Figure 1.2: Project options'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：项目选项
- en: 'Let’s look at these options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些选项：
- en: '**Product Name**: This will be the name of the project. You should select a
    name that is directly related to what the project will do.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品名称**: 这将是项目的名称。您应该选择一个与项目将要执行的任务直接相关的名称。'
- en: '**Team**: This will be the developer account you created with your Apple ID
    at [developer.apple.com](http://developer.apple.com), or a company account if
    you have one.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队**: 这将是您使用 Apple ID 在 [developer.apple.com](http://developer.apple.com)
    创建的开发者账户，或者如果您有的话，也可以是公司账户。'
- en: '`com.SMDAppTech`).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.SMDAppTech`）。'
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you were wondering why Apple requires this reverse notion, here’s a deeper
    explanation. Reverse domain name notation (or reverse DNS) is a system used to
    map an IP address to a domain name. Reverse DNS strings are based on registered
    domain names, with the order of the components reversed for grouping purposes.
    Here is an example: if a company making a product called MyProduct has the domain
    name [exampleDomain.com](http://exampleDomain.com), they could use a reverse DNS
    string of `com.exampleDomain.MyProduct` as an identifier for that product. Reverse
    DNS names are a simple way of eliminating namespace collisions since any domain
    name is globally unique to its registered owner.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么苹果要求这种反向概念，这里有一个更深入的解释。反向域名命名法（或反向 DNS）是一种将 IP 地址映射到域名系统的系统。反向 DNS
    字符串基于注册的域名，为了分组目的，组件的顺序被反转。以下是一个示例：如果一个名为 MyProduct 的产品公司拥有 [exampleDomain.com](http://exampleDomain.com)
    的域名，他们可以使用 `com.exampleDomain.MyProduct` 作为该产品的标识符。反向 DNS 名称是一种简单消除命名空间冲突的方法，因为任何域名都是其注册所有者的全球唯一标识符。
- en: '**Interface**: This is where we select the technology we will use to design
    the UI. From the drop-down list, you can choose **SwiftUI** or **Storyboard**.
    SwiftUI is a system that lets us declare the interface from code, while Storyboard
    is a graphical system that allows us to drag and drop many components and controls
    onto a storyboard to create the user interface – we want to select **SwiftUI**.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**界面**: 这是选择我们将用于设计 UI 的技术的位置。从下拉列表中，您可以选择 **SwiftUI** 或 **Storyboard**。SwiftUI
    是一个系统，允许我们从代码中声明界面，而 Storyboard 是一个图形系统，允许我们将许多组件和控制拖放到故事板中，以创建用户界面 - 我们想要选择 **SwiftUI**。'
- en: 'A quick note: even though we drag and drop onto the storyboard in that option,
    the code is not generated after you drop an object onto the board. You still have
    to write out the code for each object and make connections for buttons and other
    controls. Whereas in SwiftUI, you can drag and drop similar components, and the
    code is automatically propagated in the editor for you. You then fill out the
    body with what you want it to do.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速说明：尽管我们可以在那个选项中将对象拖放到故事板中，但在您将对象拖放到板上后，并不会生成代码。您仍然需要为每个对象编写代码，并为按钮和其他控件建立连接。而在
    SwiftUI 中，您可以拖放类似的组件，并且代码会自动在编辑器中传播。然后您填写主体，使其执行您想要的功能。
- en: '**Language**: This is the coding language; here, we will select **Swift**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**: 这是编程语言；在这里，我们将选择 **Swift**。'
- en: We don’t need to use core data, which is a way of persisting your data so it
    always loads back up again, and we don’t need to include tests for any of the
    projects.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要使用核心数据，这是一种持久化数据的方式，以便它总是可以再次加载，并且我们不需要为任何项目包含测试。
- en: When we hit **Next**, we’re asked where to save the project. I like to save
    it on the desktop, but you can choose any location you want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**下一步**时，系统会询问我们希望将项目保存到何处。我喜欢将其保存在桌面上，但你可以选择任何你想要的位置。
- en: 'And now we are in the Xcode interface:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了 Xcode 界面：
- en: '![Figure 1.3: Xcode interface ](img/B18674_01_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：Xcode 界面](img/B18674_01_03.jpg)'
- en: 'Figure 1.3: Xcode interface'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：Xcode 界面
- en: 'The Xcode interface is the part of Xcode where we do all of our coding. It
    is split up into different sections; here are those sections explained:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 界面是我们在其中进行所有编码的 Xcode 部分。它被分成不同的部分；以下是这些部分的解释：
- en: '**Project** **Navigator** (**1)**:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目导航**（**1**）：'
- en: This is a collapsible space that contains all the project files. A file called
    `ContentView` is here, into which we can write our code, and we can create more
    files as the project grows. If you have worked in Xcode before with UIKit, then
    the `ContentView` file is analogous to UIKit’s View Controller, where it had the
    `ViewDidLoad` method, in which we would usually load some user interface code.
    Here, we put the UI code in the `ContentView` struct and create other structs
    as needed. We can also organize all these files by creating and naming new groups
    and folders. There’s another file here called `Assets.xcassets` (also called the
    Assets catalog), where we place the images and colors needed for our project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可折叠的空间，包含了所有项目文件。有一个名为 `ContentView` 的文件在这里，我们可以将代码写入其中，并且随着项目的增长，我们可以创建更多文件。如果你之前使用过
    Xcode 并与 UIKit 一起工作过，那么 `ContentView` 文件类似于 UIKit 的 View Controller，其中包含 `ViewDidLoad`
    方法，我们通常会在其中加载一些用户界面代码。在这里，我们将 UI 代码放在 `ContentView` 结构中，并根据需要创建其他结构。我们还可以通过创建和命名新的组和文件夹来组织所有这些文件。这里还有一个名为
    `Assets.xcassets` 的文件（也称为资产目录），我们将项目所需的图像和颜色放置在这里。
- en: Looking at the top of the `Demo`. This is the main folder of your project into
    which everything else is placed, including the new Swift files that you create.
    Clicking on that takes us to many different options and settings to configure
    the app, things such as the deployment target, signing, capabilities, build settings,
    and more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查看顶部的 `Demo`。这是你的项目的主要文件夹，其中包含了放置所有其他内容的地方，包括你创建的新 Swift 文件。点击它将带我们进入许多不同的选项和设置来配置应用，例如部署目标、签名、功能、构建设置等。
- en: '**Tool** **bar** (**2**):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**（**2**）：'
- en: 'Let’s look at the toolbar (after the traffic light buttons), starting from
    left to right:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看工具栏（在交通灯按钮之后），从左到右依次是：
- en: There is a navigator toggle button that opens and closes the **Project Navigator**
    pane that we just looked at, to give you more working space when you need it.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个导航切换按钮，可以打开和关闭我们刚刚查看的**项目导航**面板，在你需要更多工作空间时提供帮助。
- en: To the right of the navigation button is a play button that runs and stops the
    project.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航按钮的右侧有一个播放按钮，用于运行和停止项目。
- en: Next, you will see the title of your project. However, if you click on it, this
    is a drop-down list, allowing you to select the scheme and various different simulators
    or devices to run your project in. A scheme is a destination for running the app.
    For example, Xcode lets us run the project on different simulators, on a device,
    in a window on the Mac computer, on an Apple watch, on an iPad, or on an Apple
    TV if we are building for those. We are building for the iPhone, so you can select
    any of the iPhone simulator models from the list, or connect your iPhone to your
    computer and you will see it appear in the list. If you select your iPhone, you
    can see what your app looks like running on an actual device.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你会看到你项目的标题。然而，如果你点击它，这将弹出一个下拉列表，允许你选择方案以及各种不同的模拟器或设备来运行你的项目。方案是运行应用的目的地。例如，Xcode
    允许我们在不同的模拟器、设备、Mac 电脑上的窗口、Apple Watch、iPad 或 Apple TV 上运行项目（如果我们在为这些设备构建）。我们正在为
    iPhone 构建，所以你可以从列表中选择任何 iPhone 模拟器模型，或者将你的 iPhone 连接到你的电脑，你会在列表中看到它。如果你选择了你的 iPhone，你可以看到你的应用在实际设备上运行的样子。
- en: After that, there is a display area to show any errors or warnings, as well
    as the app’s current status.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，有一个显示区域，用于显示任何错误或警告，以及应用当前的运行状态。
- en: To the right on the toolbar is a plus button that opens up a library of tools
    that we use to help create the user interface, things such as modifiers, views,
    controls, and code snippets.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具栏的右侧有一个加号按钮，它打开了一个工具库，我们使用这些工具来帮助创建用户界面，例如修饰符、视图、控件和代码片段。
- en: And finally, there's another button at the far right to show or collapse the
    Utilities Inspector, again, for more screen real estate when needed.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities** (**3**):'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Utilities** Inspector is a collapsible area that offers more options
    to edit and configure the interface and its elements. There are five tabs at the
    top for this; from left to right, they are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**File Inspector** is used to adjust the parameters for the file you are working
    in'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History Inspector** is used to view your project’s history (this is not used
    much in a SwiftUI project)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick Help Inspector** will give you a description/definition of the code
    selected in the editor'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility Inspector** is for configuring things such as voiceover, Braille
    reading, and other settings related to making your app more accessible'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes Inspector** gives you the option to change any of the attributes
    of a particular view, modifier, or other control that you have selected'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug/Console** (**4**):'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a collapsible space that appears and disappears by toggling the button
    on the bottom right. The area can also be divided into two sections. When split,
    the section on the left provides information for debugging, and the right is a
    console used to display any relevant information when we run the code, as well
    as warnings and errors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Editor** (**5**):'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the area in which we write our code. This section of Xcode is not collapsible,
    but we can split it into two or more sections by clicking the button at the far
    right just underneath the toolbar. It can be positioned at the top or the bottom
    depending on how you like to write code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There is also a feature called the mini-map, a miniature map of the code file,
    which offers a helpful view of the entire file, and makes it easy to reference
    and navigate around your code, especially if you have very large files. We can
    enable it by clicking on the little hamburger icon at the top right and choosing
    **Mini Map**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas** **Previews** (**6**):'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The canvas is its own collapsible section of Xcode that features a graphical
    simulator called a preview, that has a real-time connection to the code within
    the editor. Any changes we make in the editor will be reflected in the preview.
    There is a **Run** button on the preview to test out what you’ve done so far,
    but the preview is a great visual aid that helps speed up development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: That’s the XCode interface in a nutshell. It may look daunting at first, but
    as you code along through the projects, you will become more comfortable and start
    to learn where everything is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue and look at the concept of the state, which is data that can
    change. We hold our data in variables, and that data changes many times when we
    animate something in SwiftUI; when the data changes, SwiftUI helpfully will handle
    updating the animations for us by using the state to refresh the views.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the state
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In SwiftUI, a state is a piece of data that can change. When the state changes,
    the view that depends on the state is automatically refreshed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare a state in a SwiftUI view by using the `@State` property wrapper.
    For example, see the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `name` is a state that is stored as a string. You can then use this state
    to display dynamic content in your view:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To change the state, we can assign a new value to the `@State` property. For
    example, see the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the button is tapped, the name state is changed to `"Jack"` and the view
    is automatically refreshed to display the new name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue now and look at what makes up SwiftUI and helps it works so well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SwiftUI structures
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI gives us views, controls, modifiers, and layout structures for declaring
    the user interface. The framework also includes event handlers for providing taps,
    gestures, and other kinds of input for our app, as well as tools for managing
    the flow of data coming from your app’s models.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: But what’s a model? A **model** is simply a folder we create in the **Project
    Navigator** window where we usually keep the app’s data; for example, if we are
    working on a weather app, we can keep our wind, temperature, precipitation, and
    snow accumulation data in the app’s model after it has been received from the
    internet through an **Application Programming Interface** (**API**) call, which
    is prebuilt software that talks to other programs for us. That data will then
    be processed and sent down to the views and controls that the user will see and
    can interact with.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI allows us to avoid using Interface Builder and Storyboards to design
    the app’s user interface, as we can use the preview canvas and the editor instead.
    We can inspect the user interface as we write code, and also generate code when
    dragging and dropping views/controls into the canvas. The code within the editor
    and the canvas preview are side by side; changing one will update the other.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: When building our apps, we use **views**. Nearly everything is a view in SwiftUI,
    and they are the building blocks of our apps, things such as text boxes, buttons,
    toggles, pickers, shapes, colors (yes, even colors are a view), stacks, and more.
    We add them to the canvas by dragging them out of the view’s library, or by typing
    out the code in the editor, and then setting their properties with modifiers.
    Each view will have its own unique set of properties and modifiers, and many views
    will also share those same properties and modifiers too.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the SwiftUI structures we will look at so you can get a good
    foundation for completing this book’s projects:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks (`VStack`, `HStack`, and `ZStack`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Spacer` view
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Divider` view
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `padding` modifier
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GeometryReader`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through each of these now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first things we will look at is **computed properties** because
    that is how views are made. Here is a look at the template code that we see when
    we first create a new SwiftUI project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要首先关注的是 **计算属性**，因为这就是视图是如何创建的。这里是我们第一次创建一个新的 SwiftUI 项目时看到的模板代码：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run that code, this is what we see in the preview window:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，在预览窗口中我们会看到以下内容：
- en: '![Figure 1.4: Running the template code ](img/B18674_01_04_NEW.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：运行模板代码](img/B18674_01_04_NEW.jpg)'
- en: 'Figure 1.4: Running the template code'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：运行模板代码
- en: The **Hello, world!** string is displayed in the middle of the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hello, world!** 字符串显示在屏幕中间。'
- en: Looking at the code, we see that it includes a `struct` object called `ContentView`,
    which is the basic building block struct that SwiftUI creates for us. Inside that
    is a computed property called `body` – it has open and close parentheses, and
    yes, it has a body where you place your code to be executed, as does any function
    in Swift. Computed properties do not store values as a regular stored property
    or variable would. Instead, this property will compute the code you place in between
    the parentheses and then return the result.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，我们看到它包含一个名为 `ContentView` 的 `struct` 对象，这是 SwiftUI 为我们创建的基本构建块结构体。在这个结构体内部有一个名为
    `body` 的计算属性——它有开闭括号，是的，它有一个放置你代码以执行的地方，就像 Swift 中的任何函数一样。计算属性不会像常规存储属性或变量那样存储值。相反，这个属性将计算你放在括号之间的代码，然后返回结果。
- en: Computed properties can have getters and or setters. They can either get and
    return a value, set a new value, or do both. However, if it just has a getter,
    then it’s known as a read-only property because it will only return the computed
    properties value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性可以有 getter 和或 setter。它们可以获取并返回一个值，设置一个新值，或者两者都做。然而，如果它只有一个 getter，那么它就被称为只读属性，因为它只会返回计算属性的值。
- en: 'You might be wondering if this is a computed read-only property, where are
    the getter and return keywords? Well, this code is actually the shorthand version
    of a computed property. It’s optional to write out the longhand version, but we
    could if we wanted more readable and descriptive code; if we did, it would look
    like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这是否是一个计算只读属性，那么 getter 和 return 关键字在哪里？嗯，实际上这段代码是计算属性的简写版本。写长版本是可选的，但如果我们想写更易读和描述性的代码，我们可以这样做；如果那样做，它看起来会像这样：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code does the same thing as before: it returns the `get` and `return`.
    Again, they are optional, so you will see the shorthand version in most cases,
    because less code is, well, less code, which makes life easier. Still, many developers
    prefer the clarity of adding those keywords... it’s up to you.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前做的是同一件事：它返回 `get` 和 `return`。再次强调，它们是可选的，所以在大多数情况下，你会看到简写版本，因为代码越少，生活就越简单。然而，许多开发者更喜欢添加这些关键字带来的清晰度...这取决于你。
- en: There’s another curious bit of syntax here and that’s the `some View` keyword.
    The `some` keyword indicates that an opaque type will be returned, and `View`
    is the opaque type in this instance. Opaque refers to something that’s not clear
    or not easily understood. So, what’s not clear? That would be the type that this
    view will return. That’s because, being an opaque type, it hides the type and
    its implementation from us. All it cares about is that a single view will be returned,
    which is important because only one view can be returned to satisfy the `some`
    keyword’s requirements. The view’s type that will be returned is determined by
    what we put into the body of the computed property. In the code, there is a `Text`
    view there, so that’s the type that is returned.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有趣的语法点，那就是 `some View` 关键字。`some` 关键字表示将返回一个不透明类型，而在这个例子中，`View` 是不透明类型。不透明指的是那些不清晰或不容易理解的东西。那么，什么是不清晰的？那就是这个视图将返回的类型。这是因为，作为一个不透明类型，它隐藏了类型及其实现。它唯一关心的是返回一个单一的视图，这很重要，因为只有单个视图才能满足
    `some` 关键字的要求。返回的视图类型取决于我们放入计算属性体中的内容。在代码中，有一个 `Text` 视图，所以返回的类型就是它。
- en: When we create custom views, we just have to make sure that it conforms to the
    `View` protocol. To do that, we just need to implement the required `body` computed
    property, then we can add whatever view we want to display, things such as buttons,
    toggles, pickers, shapes, colors, and so on, but again, just one view.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建自定义视图时，我们只需确保它符合 `View` 协议。要做到这一点，我们只需要实现所需的 `body` 计算属性，然后我们可以添加任何我们想要显示的视图，比如按钮、开关、选择器、形状、颜色等等，但同样，只能是一个视图。
- en: Another bit of syntax to look at is `.padding()`, called a layout modifier –
    it modifies the layout of the text view by placing 20 points of padding (that’s
    the default amount when we don’t choose a value) all around the text view. Many
    different modifiers are grouped into different categories, such as text modifiers,
    image modifiers, list modifiers, and more.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Have a play around and experiment with them by clicking on the plus button on
    the top right in Xcode and then selecting the **Modifiers** tab. You will quickly
    get to know the many different modifiers as you start building the projects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to the organizational layout of these views on
    the screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember I said that the `some View` protocol has one requirement, and that
    is to return just one view when we run the code. That’s fine in very simple apps,
    but more often than not, we need to return more than one view – several views
    might need to be displayed on the screen for the user to interact with in fact,
    such as a button, a text field, some images, text, and so on. We need to organize
    these views vertically and horizontally on the screen, as well as on the *z*-axis
    (placing views on top of each other).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, SwiftUI gives us vertical, horizontal, and zed stacks, or `VStack`,
    `HStack`, and `ZStack` for short. These are container views that can hold 10 views
    inside them. The views inside them are know as **child views**. Let’s look at
    each now.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: VStack
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Text` view, and it displays **Hello World!** on the user’s screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to have more than one view returned from inside the body
    computed property? Maybe we want to have a `Button` *and* a `Text` view on the
    screen, as in this code example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we press *Command* + *B* to build this code, it builds cleanly and error-free.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though this code is error-free, nothing appears in the previews, so
    it won’t do anything when we press the play button to run it. The code won’t do
    anything because there are two views inside the body computed property: a `Text`
    view and a `Button` view. This violates the `View` protocol, which only wants
    `some View` returned (singular), not `some` `Views` (plural).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the same code with a minor change made to it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I have put all of the code inside the `VStack`. Now, when we run it, everything
    works as expected, and the two views can coexist inside the `body` computed property
    without any issues. If we press the button, the text will change depending on
    the value in the `changeText` property:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: VStack ](img/B18674_01_05.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: VStack'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The `VStack` can hold 10 child views and is still considered to only return
    one view itself, so the `some View` protocol is satisfied. If you need more than
    10 children, you can nest VStacks inside each other to add even more views.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `VStack`, as you might imagine, will stack all of its children vertically,
    but you can also set an optional alignment and spacing within the `VStack` initializer
    too.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，`VStack` 将其所有子视图垂直堆叠，但你也可以在 `VStack` 初始化器中设置可选的对齐和间距。
- en: Alignment
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对齐
- en: 'By default, everything in the `VStack` is center-aligned, but if you want all
    of its child views aligned to the leading edge or trailing edge, you can use the
    `alignment` parameter like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`VStack` 中的所有内容都是居中对齐的，但如果你想让所有子视图都对齐到前导边缘或尾随边缘，你可以使用 `alignment` 参数，如下所示：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All the child views are now aligned to the leading edge within the `VStack`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有子视图现在都在 `VStack` 内部对齐到前导边缘：
- en: '![Figure 1.6: Leading alignment ](img/B18674_01_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：前导对齐](img/B18674_01_06.jpg)'
- en: 'Figure 1.6: Leading alignment'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：前导对齐
- en: 'You can also align the views to the trailing edge or the center. To do that,
    we use dot syntax to access those other `enumeration` values: `.leading`, `.trailing`,
    or `.center` are the options available for alignment.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将视图对齐到尾随边缘或中心。为此，我们使用点符号来访问那些其他 `enumeration` 值：`.leading`、`.trailing` 或
    `.center` 是可用于对齐的选项。
- en: Spacing
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间距
- en: 'The other parameter inside the `VStack` is the `spacing` option. This will
    put some space between all the child views:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`VStack` 内部的另一个参数是 `spacing` 选项。这将使所有子视图之间有一定的空间：'
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code puts 10 points of space between each child view, as we can see here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在每个子视图之间放置了 10 个点的空间，正如我们在这里可以看到的：
- en: '![Figure 1.7: VStack spacing ](img/B18674_01_07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7：VStack 间距](img/B18674_01_07.jpg)'
- en: 'Figure 1.7: VStack spacing'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：VStack 间距
- en: That’s how the `VStack` works; let’s continue and look at the `HStack` now.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `VStack` 的工作方式；让我们继续，现在看看 `HStack`。
- en: HStack
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HStack
- en: 'In contrast to a `VStack`, an **HStack** displays its children horizontally.
    Here’s an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `VStack` 相比，**HStack** 水平显示其子视图。以下是一个例子：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The number views are now all stacked horizontally:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视图现在都是水平堆叠的：
- en: '![Figure 1.8: HStack ](img/B18674_01_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8：HStack](img/B18674_01_08.jpg)'
- en: 'Figure 1.8: HStack'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：HStack
- en: 'Adding a `font` modifier to the entire parent stack will affect all the children
    inside it, but to affect an individual child view, you need to place the modifier
    on it directly. Here is an example of doing that:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `font` 修饰符添加到整个父堆叠将影响其中所有的子视图，但要影响单个子视图，你需要直接将其放置在其上。以下是一个示例：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As a result, the `Text` view number of `4` has now been altered to have a larger
    font:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Text` 视图的编号 `4` 现在已经被修改为具有更大的字体：
- en: '![Figure 1.9: Modifying the child ](img/B18674_01_09.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9：修改子视图](img/B18674_01_09.jpg)'
- en: 'Figure 1.9: Modifying the child'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：修改子视图
- en: Let’s look at another important stack, the `ZStack`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个重要的堆叠，即 `ZStack`。
- en: ZStack
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ZStack
- en: 'A **ZStack** is a stack that will overlay its children, one on top of another.
    With this stack, we can create a hierarchy of views, where the first view in the
    stack will be placed at the bottom, and subsequent views will be stacked up on
    top of each other in sequential order. Take a look at this example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZStack** 是一个将覆盖其子视图的堆叠，一个叠在另一个上面。使用这个堆叠，我们可以创建一个视图层次结构，其中堆叠中的第一个视图将被放置在底部，后续视图将按顺序堆叠在彼此的顶部。看看这个例子：'
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code contains two views:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含两个视图：
- en: The first is the `Image` view, which accepts images that you have imported into
    the Assets catalog, and makes it possible to display the images on the screen.
    By using the `systemName` parameter, we can choose a system image from Apple’s
    stock of pre-made images, from many different categories.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是 `Image` 视图，它接受你已导入到资产目录中的图像，并使得在屏幕上显示图像成为可能。通过使用 `systemName` 参数，我们可以从苹果预制的图像库中选择一个系统图像，这些图像来自许多不同的类别。
- en: To use a system image in your projects, download the `Image` parameter called
    `systemName`. For my example, I’ve used an image called `rectangle.inset.filled.and.person.filled`
    and have placed it at the beginning of the `ZStack`; any view added underneath
    it will be placed on top of that image.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的项目中使用系统图像，请下载名为 `systemName` 的 `Image` 参数。在我的例子中，我使用了一个名为 `rectangle.inset.filled.and.person.filled`
    的图像，并将其放置在 `ZStack` 的开头；任何添加在其下方的视图都将放置在该图像的上方。
- en: The second view is a `Text` view, placed on top of the system image by the `ZStack`.
    Again, because the code for the `Text` view is added under the code that creates
    the `Image` view, it is placed on top of the `Image` view when we run the app.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个视图是一个 `Text` 视图，通过 `ZStack` 放置在系统图像的顶部。同样，因为 `Text` 视图的代码是在创建 `Image` 视图的代码下方添加的，所以当我们运行应用时，它会被放置在
    `Image` 视图的上方。
- en: Then, I use a little bit of padding, and we can position that text where we
    want it. You can also use the `offset` modifier to place views anywhere on the
    screen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用了一点点填充，我们可以将文本放置在我们想要的位置。你也可以使用`offset`修饰符将视图放置在屏幕上的任何位置。
- en: 'You can see the result of the code in the following figure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的图中看到代码的结果：
- en: '![Figure 1.10: ZStack ](img/B18674_01_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10：ZStack](img/B18674_01_10.jpg)'
- en: 'Figure 1.10: ZStack'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：ZStack
- en: There are also three modifiers in this code that we will look at in more depth
    when we start building the projects – that’s the `renderingMode`, `resizable`,
    and `frame` modifiers. They are used here because we need to render and resize
    the image correctly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，还有三个修饰符，当我们开始构建项目时，我们将更深入地研究它们——那就是`renderingMode`、`resizable`和`frame`修饰符。它们在这里被使用，因为我们需要正确地渲染和调整图像的大小。
- en: Combining stacks
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合栈
- en: 'Now that we have seen how the three stacks can be used to display multiple
    views and position them where we want them on the screen, let’s look at an example
    that combines all three stacks, and the child views inside them, to produce a
    varied layout:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用三个栈来显示多个视图并将它们放置在屏幕上的任何位置，让我们看看一个示例，它结合了所有三个栈以及它们内部的子视图，以产生一个多样化的布局：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s break down this code to get a clear understanding of what we are doing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码，以便清楚地了解我们在做什么。
- en: First is the `VStack`. This will be our main stack and will hold all of our
    code. Using the `VStack` in this way means we can squeeze 10 child views inside
    it, but we only need to place a couple of views inside for this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`VStack`。这将是我们主要的栈，将包含我们所有的代码。以这种方式使用`VStack`意味着我们可以在其中挤压10个子视图，但在这个例子中我们只需要放置几个视图。
- en: Next is the `ZStack`. Inside are its two child views – a `Text` view and an
    `Image` view. Since the `Image` view comes first in the code, the `Text` view
    gets placed on top of it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`ZStack`。内部包含其两个子视图——一个`Text`视图和一个`Image`视图。由于`Image`视图在代码中排在前面，所以`Text`视图被放置在它上面。
- en: Notice how each child view in the `ZStack` has its own set of modifiers that
    are indented; these are to style these child views with colors and sizes and to
    position them on the screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ZStack`中的每个子视图都有自己的缩进修饰符集；这些修饰符用于使用颜色和大小来样式化这些子视图，并在屏幕上定位它们。
- en: The next stack is the `HStack`. Remember that this arranges its children horizontally,
    and it has two child views, including an `Image` view and `VStack`. Notice how
    we can nest stacks inside of other stacks as we are doing here, with this `VStack`
    inside of a `HStack`. The `HStack` places its first child view to the left – that’s
    the tornado image – and then places its second child view to the right – that’s
    the `VStack`. If we look inside the `VStack` now, it has two child views of its
    own. They will be placed vertically, with the smaller text on the bottom.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个栈是`HStack`。记住，这个栈是水平排列其子元素的，并且它有两个子视图，包括一个`Image`视图和一个`VStack`。注意我们如何像这里这样在栈中嵌套栈，这个`VStack`就在`HStack`里面。`HStack`将其第一个子视图放置在左侧——那就是龙卷风图像——然后将其第二个子视图放置在右侧——那就是`VStack`。如果我们现在查看`VStack`内部，它有自己的两个子视图。它们将垂直排列，较小的文本在底部。
- en: Don’t worry if this nesting of stacks seems a bit confusing at first; as we
    start building projects, you will train your brain to think and see in hierarchies,
    and this will become very natural to you.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始这种栈的嵌套看起来有点混乱，请不要担心；当我们开始构建项目时，你将训练你的大脑以层次结构思考和观察，这对你来说将变得非常自然。
- en: 'By nesting the different stacks, we can make all kinds of interesting layout
    scenes. Here is the result of our example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套不同的栈，我们可以制作出各种有趣的布局场景。以下是我们的示例结果：
- en: '![Figure 1.11: Combining and nesting stacks ](img/B18674_01_11.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11：组合和嵌套栈](img/B18674_01_11.jpg)'
- en: 'Figure 1.11: Combining and nesting stacks'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：组合和嵌套栈
- en: Stacks are great for helping to organize and lay our views out on the screen,
    but there is another container view we can use that offers even more flexibility.
    That’s the `GeometryReader` view. However, we will look at that at the end of
    the chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 栈对于帮助组织和在屏幕上布局视图非常出色，但我们可以使用另一个提供更多灵活性的容器视图。那就是`GeometryReader`视图。然而，我们将在本章末尾讨论它。
- en: For now, let’s look at a `Spacer` view – this is a view that helps with spacing
    out the layout in our UI design.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个`Spacer`视图——这是一个帮助在UI设计中布局间距的视图。
- en: Spacer views
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间视图
- en: A `HStack`, a `Spacer` view expands horizontally as much as the stack allows,
    moving sibling views out of the way within the limits of the stack’s size.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `HStack`，一个 `Spacer` 视图会水平扩展到堆栈允许的最大程度，在堆栈尺寸的范围内移开兄弟视图。
- en: 'This is the `Spacer` initializer: `Spacer(minLength: CGFloat)`. This initializer
    creates a flexible space. The `minLength` argument sets the minimum size that
    the space can take. If the argument is left empty, the minimum length is zero.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '这是 `Spacer` 初始化器：`Spacer(minLength: CGFloat)`。这个初始化器创建一个灵活的空间。`minLength` 参数设置空间可以取的最小尺寸。如果参数留空，则最小长度为零。'
- en: 'Here’s an example of using a `Spacer` view in a `HStack`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在 `HStack` 中使用 `Spacer` 视图的例子：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create a horizontal stack with `Spacer` view will take up all of
    the remaining space so that the two pieces of text are pushed to the edges of
    the container:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有 `Spacer` 视图的水平堆栈，它会占据所有剩余空间，从而使两段文本被推到容器的边缘：
- en: '![Figure 1.12: Spacer ](img/B18674_01_12.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12：分隔符](img/B18674_01_12.jpg)'
- en: 'Figure 1.12: Spacer'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：分隔符
- en: The `Spacer` view can also be used in the `VStack`, and it will expand and push
    the child views apart vertically instead of horizontally. The `Spacer` view won’t
    do anything within the `ZStack` though, as that stack deals with the depth of
    a view on the *z*-axis, front to back.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spacer` 视图也可以用在 `VStack` 中，并且它会垂直扩展并推离子视图，而不是水平扩展。不过，`Spacer` 视图在 `ZStack`
    中不会做任何事情，因为那个堆栈处理视图在 *z*-轴上的深度，从前往后。'
- en: Where `Spacer` separates views by creating space between them, another object
    called a `Divider` view separates views with a thin line, either vertically or
    horizontally.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Spacer` 通过在它们之间创建空间来分隔视图时，另一个称为 `Divider` 视图的物体通过一条细线垂直或水平地分隔视图。
- en: Divider views
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分隔符视图
- en: A **Divider view** is a visual element, a dividing line, that can be used to
    separate content either horizontally or vertically. You can also alter the divider’s
    thickness. Let’s look at some examples.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**分隔符视图**是一个视觉元素，一条分隔线，可以用来水平或垂直地分隔内容。你还可以更改分隔线的厚度。让我们看看一些例子。'
- en: Horizontal
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平
- en: 'The following code creates a horizontal divider:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个水平分隔符：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we have added a horizontal dividing line and set its color
    to black using the `background` modifier:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了一条水平分隔线，并使用 `background` 修饰符将其颜色设置为黑色：
- en: '![Figure 1.13: Divider ](img/B18674_01_13.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13：分隔符](img/B18674_01_13.jpg)'
- en: 'Figure 1.13: Divider'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：分隔符
- en: Vertical
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直
- en: 'If we want to change the horizontal line to a vertical one, then we can pass
    the `width` parameter using a smaller number, and the `height` parameter using
    a larger number, as in this example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将水平线改为垂直线，那么我们可以使用较小的数字传递 `width` 参数，并使用较大的数字传递 `height` 参数，如下例所示：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the `offset` modifier lets us place the line anywhere on the screen,
    or on any view for that matter. Here is the result:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `offset` 修饰符可以让我们将线条放置在屏幕上的任何位置，或者任何视图上。以下是结果：
- en: '![Figure 1.14: Vertical Divider view ](img/B18674_01_14.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14：垂直分隔符视图](img/B18674_01_14.jpg)'
- en: 'Figure 1.14: Vertical Divider view'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：垂直分隔符视图
- en: Thickness
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 厚度
- en: 'We can change the thickness of the dividing line using the `frame` modifier,
    like so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `frame` 修饰符更改分隔线的厚度，如下所示：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, by using the `height` and `width` parameters of the `frame` modifier,
    we can change the dimensions of the `Divider` view, so we can make a line as long
    and wide as we want. The result of our example can be seen here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用 `frame` 修饰符的 `height` 和 `width` 参数，我们可以更改 `Divider` 视图的尺寸，这样我们就可以制作出我们想要的任意长和宽的线条。我们示例的结果如下所示：
- en: '![Figure 1.15: Divider thickness ](img/B18674_01_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15：分隔符厚度](img/B18674_01_15.jpg)'
- en: 'Figure 1.15: Divider thickness'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15：分隔符厚度
- en: That’s pretty much all the configuring we can do with the `Divider` view. Let’s
    now look at one of the most frequently used modifiers in SwiftUI – the `padding`
    modifier.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们可以用 `Divider` 视图做的所有配置。现在让我们看看 SwiftUI 中最常用的修饰符之一——`padding` 修饰符。
- en: The padding modifier
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充修饰符
- en: You may have noticed that we have used the **padding modifier** quite a bit
    already without really explaining it yet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们已经在没有真正解释的情况下大量使用了 **padding modifier**。
- en: Every view has its own dimensions and space that it takes up on the screen.
    For example, we can place two views side by side and they will be very close to
    each other, separated by only a few points.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都有自己的尺寸和它在屏幕上占据的空间。例如，我们可以将两个视图并排放置，它们将非常接近，仅由几个点分隔。
- en: Points and pixels refer to different ways of measuring the size of the views
    on the screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 点和像素是衡量屏幕上视图大小的不同方式。
- en: '**Points** are used to specify the size of text and other UI elements, and
    they are independent of the resolution of the device’s screen. This means that
    a point will always be the same size on any device, regardless of the screen’s
    resolution.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**点**用于指定文本和其他 UI 元素的大小，并且它们与设备屏幕的分辨率无关。这意味着在任何设备上，点的大小始终相同，无论屏幕的分辨率如何。'
- en: '**Pixels**, on the other hand, are the individual dots that make up the screen
    of an iPhone (or any other device). Pixels are used to measure the physical resolution
    of a device’s screen.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**像素**是构成 iPhone（或任何其他设备）屏幕的单独点。像素用于衡量设备屏幕的物理分辨率。
- en: 'When you add a `padding` modifier to a view, it adds a small amount of empty
    space all around that view by default, and that space is measured in points. The
    `padding` modifier by default adds eight points of empty space around a view,
    but if you want to be more specific about the amount of space with which to pad
    your view, then you can pass in a value (an integer) for a custom amount of padding.
    Let’s look at an example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向一个视图添加 `padding` 修饰符时，默认情况下会在该视图周围添加一定量的空白空间，并且该空间以点为单位衡量。默认情况下，`padding`
    修饰符会在视图周围添加八点的空白空间，但如果您想更具体地指定填充视图的空间量，则可以传递一个值（一个整数）作为自定义填充量。让我们看一个例子：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, there are four `Text` views inside the `VStack`. At the end of
    the VStack’s closing brace is a call to the `background` modifier, which will
    color the background yellow so that you can see the `padding` modifier at work.
    Next, I added the `padding` modifier and passed in `30` points, which will be
    applied around the `VStack` equally. Finally, I colored the padding red, again,
    using the `background` modifier, so you can see the padding directly. In the example,
    the padding will look like a red frame around `VStack`, as shown in the following
    screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`VStack` 内部有四个 `Text` 视图。在 `VStack` 的闭合括号末尾是一个对 `background` 修饰符的调用，这将使背景变为黄色，以便您可以看到
    `padding` 修饰符的作用。接下来，我添加了 `padding` 修饰符并传递了 `30` 点，这将均匀地应用于 `VStack`。最后，我再次使用
    `background` 修饰符将填充涂成红色，这样您可以直接看到填充。在示例中，填充将看起来像围绕 `VStack` 的红色框架，如下面的截图所示：
- en: '![Figure 1.16: Padding ](img/B18674_01_16.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16：填充](img/B18674_01_16.jpg)'
- en: 'Figure 1.16: Padding'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：填充
- en: 'Let’s look at some of the other `padding` options. The modifier allows us to
    choose from predefined enum values if we only want to pad one side, as in the
    following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他一些 `padding` 选项。修饰符允许我们选择预定义的枚举值，如果我们只想填充一边，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code pads only the `leading` edge of each `Text` view by `75` points of
    space:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仅通过 `75` 点的空间填充每个 `Text` 视图的 `leading` 边缘：
- en: '![Figure 1.17: Padding options ](img/B18674_01_17.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17：填充选项](img/B18674_01_17.jpg)'
- en: 'Figure 1.17: Padding options'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17：填充选项
- en: We can also choose other padding options by typing in a dot for the `alignment`
    parameter and selecting from many different options, including `trailing`, `top`,
    `bottom`, `horizontal`, `infinity`, and others.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过输入一个点作为 `alignment` 参数并从许多不同的选项中选择来选择其他填充选项，包括 `trailing`、`top`、`bottom`、`horizontal`、`infinity`
    等。
- en: 'Looking at the previous code, notice the placement of the `padding` modifier;
    it has been put on the closing brace of the `VStack`. When placed like this, all
    the children inside the `VStack` have the padding applied to them, but if we want
    to pad the child views individually, we can do so by placing modifiers directly
    on them:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的代码，注意 `padding` 修饰符的位置；它已经被放在 `VStack` 的闭合括号上。当以这种方式放置时，`VStack` 内部的所有子视图都会应用填充，但如果我们要单独填充子视图，我们可以通过直接在它们上放置修饰符来实现：
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, you can add modifiers to child views individually, styling
    them as you need for your layout. The result is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以单独为子视图添加修饰符，根据您的布局需求进行样式化。结果如下：
- en: '![Figure 1.18: Padding children ](img/B18674_01_18.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18：填充子视图](img/B18674_01_18.jpg)'
- en: 'Figure 1.18: Padding children'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18：填充子视图
- en: Each child view now has its own padding, either `leading` or `trailing`, which
    alters its placement on the screen.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子视图现在都有自己的填充，可以是 `leading` 或 `trailing`，这会改变其在屏幕上的位置。
- en: Let’s finish up this chapter by looking at closures, which is essentially a
    function without a name, and then another container view that offers some more
    flexibility than the other stacks we previously looked at – the `GeometryReader`
    view.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看闭包来结束这一章，闭包本质上是一个没有名称的函数，然后是另一个提供比我们之前查看的其他堆栈更多灵活性的容器视图——`GeometryReader`
    视图。
- en: Closures
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Here is the easy definition of a **closure**: a closure is a function without
    a name. Remember a function is a block of code that runs whatever code statements
    are in its body when it is called.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是闭包的简单定义：闭包是一个没有名称的函数。记住，函数是一个代码块，当它被调用时，会运行其体内的任何代码语句。
- en: 'But let’s look at a more detailed definition of a closure: a closure is a self-contained
    block of code that can be passed around and executed at a later time.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们先来详细定义一下闭包：闭包是一个自包含的代码块，它可以被传递并在稍后执行。
- en: 'Closures are not exactly functions, but they are similar, with some key differences:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包并不完全是函数，但它们很相似，有一些关键的区别：
- en: Closures can be stored as variables and passed as arguments to functions
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包可以作为变量存储，并作为参数传递给函数
- en: Closures can capture and store references to any variables or constants from
    the context in which they are defined, which allows them to maintain the state
    and preserve data between invocations
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包可以捕获并存储它们定义的上下文中的任何变量或常量的引用，这使得它们能够在调用之间保持状态并保留数据。
- en: Closures don’t have a name as a function would
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包没有像函数那样的名称
- en: In SwiftUI, closures are often used as a way to respond to user input or other
    events. For example, you might use a closure as the action for a button, or to
    provide a block of code to be executed when a view appears or disappears.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中，闭包通常被用作响应用户输入或其他事件的方式。例如，你可能将闭包用作按钮的动作，或者提供一段代码块，在视图出现或消失时执行。
- en: 'Here’s an example of a closure being used as the action for a button in SwiftUI:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个闭包被用作 SwiftUI 中按钮动作的例子：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the closure is defined using the `{ }` syntax and is passed
    as the `action` parameter to the `Button` view. Yes, that’s right, the `Button`
    action is a closure, and when the button is pressed, the code inside the closure
    will be executed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，闭包使用 `{ }` 语法定义，并作为 `action` 参数传递给 `Button` 视图。是的，没错，`Button` 的动作就是一个闭包，当按钮被按下时，闭包内部的代码将被执行。
- en: 'Closures can also be used to provide custom behavior for views in SwiftUI.
    For example, you might use a closure to perform some custom animation when a view
    appears or disappears:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包还可以用于为 SwiftUI 中的视图提供自定义行为。例如，你可能使用闭包在视图出现或消失时执行一些自定义动画：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, the `onAppear` modifier is called on the `Text` view and is
    passed a closure that will be executed when the view appears on the screen.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`onAppear` 修改器被调用在 `Text` 视图上，并传递了一个当视图出现在屏幕上时将被执行的闭包。
- en: We also have trailing closures. A trailing closure is a closure that is written
    after the function or method it is passed to. The closure is “trailing” because
    it comes after the function or method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有尾随闭包。尾随闭包是一个写在传递给它的函数或方法之后的闭包。闭包被称为“尾随”因为它位于函数或方法之后。
- en: 'Here’s an example of a function that takes a closure as an argument:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接受闭包作为参数的函数的例子：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s how you would call this function and pass a closure as an argument:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用这个函数并传递一个闭包作为参数：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, the closure is written after the `doSomething` function and
    is therefore a trailing closure. In SwiftUI, you can use trailing closures to
    provide custom behavior for views. For example, you might use a trailing closure
    to perform some custom animation when a view appears or disappears:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，闭包写在 `doSomething` 函数之后，因此是一个尾随闭包。在 SwiftUI 中，你可以使用尾随闭包为视图提供自定义行为。例如，你可能使用尾随闭包在视图出现或消失时执行一些自定义动画：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `onAppear` method is called on the `Text` view and is passed
    a trailing closure that will be executed when the view appears on the screen.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`onAppear` 方法被调用在 `Text` 视图上，并传递了一个当视图出现在屏幕上时将被执行的尾随闭包。
- en: Don’t worry if you haven’t quite grasped how closures work yet; they are not
    as complicated as they appear, and you will understand them better as we progress
    throughout the book. For now, let’s move on to `GeometryReader`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还没有完全理解闭包的工作原理，不要担心；它们并不像看起来那么复杂，随着我们继续阅读本书，你会更好地理解它们。现在，让我们继续到 `GeometryReader`。
- en: GeometryReader
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GeometryReader
- en: The `GeometryReader` will contain the position and size of the view we are working
    with, and we can then alter or place that view however we want with the values
    that are returned by `GeometryReader`’s proxy.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeometryReader` 将包含我们正在处理的视图的位置和大小，然后我们可以使用 `GeometryReader` 代理返回的值来更改或放置该视图。'
- en: Using these values, we can make the child views dynamically update their position
    depending on the device size and position when the orientation changes to either
    landscape or portrait. This all will become clearer when we see an example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些值，我们可以使子视图根据设备大小和位置动态更新其位置，当方向更改为横屏或竖屏时。这一切将在我们看到示例时变得更加清晰。
- en: 'Let’s look at how to create `GeometryReader`. The following is the initializer
    used to create the `GeometryReader` view:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建 `GeometryReader`。以下是用作创建 `GeometryReader` 视图的初始化器：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `content` parameter is a closure that receives a geometry proxy value with
    the view’s position and dimensions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 参数是一个闭包，它接收一个包含视图位置和尺寸的几何代理值。'
- en: 'To retrieve those values, we use the following properties and method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索这些值，我们使用以下属性和方法：
- en: The `size` property will return the width and height of the `GeometryReader`
    view
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` 属性将返回 `GeometryReader` 视图的宽度和高度'
- en: The `safeAreaInsets` property will return an `EdgeInsets` value with the insets
    for the safe area
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`safeAreaInsets` 属性将返回一个包含安全区域边距的 `EdgeInsets` 值'
- en: 'The `frame(in: )` method returns the position and size of the `GeometryReader`
    view'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame(in:)` 方法返回 `GeometryReader` 视图的位置和大小'
- en: 'Here is the code to create an empty `GeometryReader`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一个空的 `GeometryReader` 的代码：
- en: '[PRE28]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is what we see when we run the code. Notice how it pushes itself out to
    occupy all the space on the screen; the yellow background shows all the areas
    of this empty `GeometryReader`, which is the entire screen.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行代码时看到的结果。注意它如何将自己推出去以占据屏幕上的所有空间；黄色背景显示了整个屏幕上这个空白的 `GeometryReader` 的所有区域。
- en: '![Figure 1.19: GeometryReader ](img/B18674_01_19.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19：GeometryReader](img/B18674_01_19.jpg)'
- en: 'Figure 1.19: GeometryReader'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19：GeometryReader
- en: 'The default behavior of `GeometryReader` is to align its children in the upper-left
    corner and place them on top of each other. In this next example, the code places
    three views inside `GeometryReader`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeometryReader` 的默认行为是将其子视图对齐在左上角并将它们堆叠在一起。在下一个示例中，代码将三个视图放置在 `GeometryReader`
    内部：'
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we run this code, notice that only one tornado image is visible:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，请注意只有一张龙卷风图像是可见的：
- en: '![Figure 1.20: GeometryReader default child alignment ](img/B18674_01_20.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20：GeometryReader 默认子视图对齐](img/B18674_01_20.jpg)'
- en: 'Figure 1.20: GeometryReader default child alignment'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20：GeometryReader 默认子视图对齐
- en: There are actually three tornado images in this example, but you can only see
    one because the default behavior is to place them on top of each other in the
    upper-left corner.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个例子中有三个龙卷风图像，但你只能看到其中一个，因为默认行为是将它们堆叠在屏幕左上角。
- en: 'We obviously don’t want all the child views stacked on one another, so we will
    explore the following concepts to really utilize `GeometryReader`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不希望所有子视图都堆叠在一起，因此我们将探索以下概念以真正利用 `GeometryReader`：
- en: Sizing a view to accommodate rotating the device
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为适应设备旋转而调整视图大小
- en: Positioning a view anywhere on the screen
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上的任何位置定位视图
- en: Reading a view’s position in terms of its global and local space
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以全局和局部空间为依据读取视图的位置
- en: We’ll look at these now.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在就来查看这些。
- en: Sizing views
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整视图大小
- en: Let’s first look at the property that is used to access the `GeometryReader`’s
    size... aptly named, the `size` property. This will return the width and height
    of the `GeometryReader` view.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看用来访问 `GeometryReader` 的大小属性……恰如其名，`size` 属性。这将返回 `GeometryReader` 视图的宽度和高度。
- en: 'Here is an example of adding an image inside the `GeometryReader` view, and
    seeing how it adapts its size when the device is rotated:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 `GeometryReader` 视图内添加图像并查看设备旋转时它如何调整其大小的示例：
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following figure shows the size of the image in portrait mode:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了竖屏模式下图像的大小：
- en: '![Figure 1.21: GeometryReader size property (portrait) ](img/B18674_01_21.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21：GeometryReader 的大小属性（纵向）](img/B18674_01_21.jpg)'
- en: 'Figure 1.21: GeometryReader size property (portrait)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21：GeometryReader 的大小属性（纵向）
- en: 'In portrait mode, the image is bigger, but when the device is rotated to landscape,
    the image scales down to adapt to the screen change, as shown here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在竖屏模式下，图像更大，但当设备旋转到横屏时，图像会缩小以适应屏幕变化，如下所示：
- en: '![Figure 1.22: GeometryReader size property (landscape) ](img/B18674_01_22.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图1.22：GeometryReader大小属性（横向）](img/B18674_01_22.jpg)'
- en: 'Figure 1.22: GeometryReader size property (landscape)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.22：GeometryReader大小属性（横向）
- en: In this example, we added an `Image` view within a `GeometryReader` view. I
    defined the `Proxy` parameter as `geometryProxy`, but you can call it anything
    you want. `geometryProxy` holds the information about `GeometryReader`’s dimensions
    and position. Using this `Proxy` object, the size of the image is changed when
    we rotate the device. The image will be half the width of the container, and the
    height will be a quarter of the height of the container.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`GeometryReader`视图中添加了一个`Image`视图。我将`Proxy`参数定义为`geometryProxy`，但你可以将其命名为任何你想要的。`geometryProxy`包含有关`GeometryReader`的尺寸和位置的信息。使用此`Proxy`对象，当旋转设备时，图像的大小会改变。图像的宽度将是容器宽度的一半，高度将是容器高度的四分之一。
- en: Using `geometryProxy.size` lets us access the height and width of `GeometryReader`.
    The `Image` view will adapt when the device is rotated. I’m also using the `scaledToFit`
    modifier so that we can keep the correct aspect ratio for the image.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`geometryProxy.size`让我们可以访问`GeometryReader`的高度和宽度。当设备旋转时，`Image`视图将适应。我还使用了`scaledToFit`修饰符，以便我们可以保持图像的正确宽高比。
- en: I set the `Image` view’s background to gray so that you can see the space that’s
    available in both portrait and landscape modes. When it’s in landscape mode, there’s
    much more space available around the `Image` view because it scales down.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`Image`视图的背景设置为灰色，这样你就可以看到在纵向和横向模式下都可用空间。当处于横向模式时，`Image`视图周围有更多的可用空间，因为它会缩小。
- en: Also notice that the image is positioned in the top-left corner of the `GeometryReader`
    view. Again, that’s the default location for its child views; they will simply
    stack up on each other in that area.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，图像被定位在`GeometryReader`视图的左上角。同样，这也是其子视图的默认位置；它们将简单地堆叠在那个区域。
- en: Next, we will look at positioning those child views anywhere we want within
    the `GeometryReader` container.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在`GeometryReader`容器内将那些子视图放置在我们想要的任何位置。
- en: Positioning views
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位视图
- en: 'We’ve seen how `GeometryReader` can dynamically change the size of a view as
    it’s rotated, but it can also position the views within it. The positioning information
    is returned by the `geometryProxy` closure, and we can pass that information into
    the `x` and `y` parameters of the `position` modifier via the `size` property.
    Here’s an example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`GeometryReader`如何动态地改变视图的大小，当它旋转时，但它也可以在内部定位视图。定位信息由`geometryProxy`闭包返回，我们可以通过`size`属性将此信息传递到`position`修饰符的`x`和`y`参数。以下是一个示例：
- en: '[PRE31]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code here has two VStacks within `GeometryReader`, and each `VStack` has
    the `position` modifier on its closing brace, so everything within the VStacks
    will be positioned according to the values in the `position` modifier’s `x` and
    `y` parameters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码在`GeometryReader`中有两个`VStack`，每个`VStack`在其闭合括号上都有`position`修饰符，所以`VStack`内的所有内容都将根据`position`修饰符的`x`和`y`参数的值进行定位。
- en: 'The result when running this code is the placement of the `Image` and `Text`
    views according to the `size.width` and `size.height` values, as shown in this
    figure:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的结果是`Image`和`Text`视图的放置根据`size.width`和`size.height`值，如图所示：
- en: '![Figure 1.23: GeometryReader positioning views ](img/B18674_01_23.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图1.23：GeometryReader定位视图](img/B18674_01_23.jpg)'
- en: 'Figure 1.23: GeometryReader positioning views'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.23：GeometryReader定位视图
- en: Let’s continue with `GeometryReader` and see how we can read the values of its
    position.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用`GeometryReader`并看看我们如何读取其位置值。
- en: Reading the position
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取位置
- en: If we need to get the position of the `GeometryReader` view in terms of its
    `coordinate` location, again, we can use the `geometryProxy` object and pass its
    information into the `frame()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要以`coordinate`位置来获取`GeometryReader`视图的位置，我们再次可以使用`geometryProxy`对象，并通过将其信息传递到`frame()`方法中。
- en: 'There are two coordinate spaces in SwiftUI:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI中有两个坐标空间：
- en: '**Global space**: The coordinates of the entire screen'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局空间**：整个屏幕的坐标'
- en: '**Local space**: The coordinates of individual views'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部空间**：单个视图的坐标'
- en: When reading the values of the local coordinate space of the `GeometryReader`
    view, we will always see `0,0` for `x` and `y`. That’s because `GeometryReader`
    always starts at that position, `0,0`, the top-left corner of the screen.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取`GeometryReader`视图的局部坐标空间值时，我们总会看到`x`和`y`的值为`0,0`。那是因为`GeometryReader`始终从该位置开始，即屏幕的左上角`0,0`。
- en: 'So, to get the position of the views in relation to where they are on the screen,
    we need to use the global coordinates. Here is an example that gets and displays
    the local and global values for the `GeometryReader` view:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获取视图相对于屏幕上的位置，我们需要使用全局坐标。以下是一个获取并显示 `GeometryReader` 视图局部和全局值的示例：
- en: '[PRE32]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice that the values are being formatted using a format specifier: `%.f`.
    This format specifier will truncate some of the decimal places so it displays
    fewer zeros.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些值正在使用格式说明符进行格式化：`%.f`。此格式说明符将截断一些小数位，以显示更少的零。
- en: 'Running the code will display the `x` and `y` coordinate values for both the
    global and local space for the views, when the device is in portrait mode, as
    shown here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将在设备处于纵向模式时显示视图的全局和局部空间的 `x` 和 `y` 坐标值，如下所示：
- en: '![Figure 1.24: Reading the position (portrait) ](img/B18674_01_24.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24：读取位置（纵向）](img/B18674_01_24.jpg)'
- en: 'Figure 1.24: Reading the position (portrait)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24：读取位置（纵向）
- en: 'Rotating the device into landscape mode changes the global values to reflect
    the new location of the `Image` and `Text` views, as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 将设备旋转到横向模式会改变全局值，以反映 `Image` 和 `Text` 视图的新位置，如下所示：
- en: '![Figure 1.25: Reading the position (landscape) ](img/B18674_01_25.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.25：读取位置（横向）](img/B18674_01_25.jpg)'
- en: 'Figure 1.25: Reading the position (landscape)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25：读取位置（横向）
- en: The code in this example demonstrates the difference between the global and
    local coordinate spaces. The values for the local coordinate space always return
    `0,0` because that is the starting position of `GeometryReader`, but the values
    for the global coordinate space are the origin of the `geometryProxy` frame within
    the entire screen. So, the global values change as the device is rotated because
    the view’s position has changed. The local values do not change as they reflect
    the screen’s upper-left corner, `0,0`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的代码演示了全局坐标空间和局部坐标空间之间的区别。局部坐标空间的值始终返回 `0,0`，因为那是 `GeometryReader` 的起始位置，但全局坐标空间的值是整个屏幕内
    `geometryProxy` 帧的起点。因此，全局值会随着设备的旋转而改变，因为视图的位置已经改变。局部值不会改变，因为它们反映了屏幕的左上角，即 `0,0`。
- en: 'SwiftUI also offers properties to get the minimum, middle, and maximum coordinate
    positions from within `GeometryReader`’s frame for both the global and local spaces:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 还提供了获取 `GeometryReader` 帧内全局和局部空间的最低、中间和最大坐标位置的性质：
- en: '[PRE33]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We use these properties with dot syntax, right at the end of the `frame` method.
    Here is an example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用点语法，在 `frame` 方法的最后使用这些属性。以下是一个示例：
- en: '[PRE34]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code will return the minimum, the middle, and the maximum `x` and `y`
    coordinates for `GeometryReader`’s frame and display them on the screen for both
    local and global spaces in portrait mode, as shown here:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将返回 `GeometryReader` 帧的最小、中间和最大 `x` 和 `y` 坐标，并在纵向模式下在屏幕上显示局部和全局空间的坐标，如下所示：
- en: '![Figure 1.26: Using the min, mid, and max properties (portrait) ](img/B18674_01_26.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.26：使用 min、mid 和 max 属性（纵向）](img/B18674_01_26.jpg)'
- en: 'Figure 1.26: Using the min, mid, and max properties (portrait)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26：使用 min、mid 和 max 属性（纵向）
- en: 'When the device is rotated, those values will adjust to new values that reflect
    the change in the screen’s orientation, as shown here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备旋转时，这些值将调整为新值，以反映屏幕方向的变化，如下所示：
- en: '![Figure 1.27: Using the min, mid, and max properties (landscape) ](img/B18674_01_27.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.27：使用 min、mid 和 max 属性（横向）](img/B18674_01_27.jpg)'
- en: 'Figure 1.27: Using the min, mid, and max properties (landscape)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.27：使用 min、mid 和 max 属性（横向）
- en: The SwiftUI structures you have just learned about will be the building blocks
    for the programs we will write going forward. Rather than listing all the structures
    in one chapter, which can be a lot to take in, I will introduce new ones in different
    projects throughout the book.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到的 SwiftUI 结构将是我们接下来要编写的程序的基础。由于在一个章节中列出所有结构可能会太多，难以消化，我将在整本书的不同项目中介绍新的结构。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To sum up what we learned in this chapter, we introduced SwiftUI and saw the
    difference between the two programming paradigms, imperative and declarative.
    After that, we explored the Xcode interface. Then, we covered the important function
    of the state, and finally looked at the building blocks of SwiftUI – these are
    fundamentals that you will use throughout this book and are an essential first
    step toward creating beautiful animations in SwiftUI.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章所学内容，我们介绍了 SwiftUI 并看到了两种编程范式——命令式和声明式之间的区别。之后，我们探索了 Xcode 的界面。然后，我们涵盖了状态的重要功能，最后查看
    SwiftUI 的构建块——这些是你在整本书中都会用到的基本概念，也是创建 SwiftUI 中美丽动画的必要第一步。
- en: In the next chapter, we will explore animations, how they work, and the kinds
    of properties that can be animated.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨动画，它们是如何工作的，以及可以动画化的属性种类。
