- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Fundamentals of SwiftUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Animating SwiftUI Applications*! If you picked up this book, then
    there’s a good chance you are a developer – or aspiring to be one – and you want
    to learn more about SwiftUI animations. Or maybe you’re fascinated by animations
    and how they work like I am. I know for me that the first time I played a video
    game (before the home computer was even available) and saw objects collide and
    bounce off each other on the screen, I was hooked by animations and the code behind
    how they worked. Whatever the reason you’re here though, together we will explore
    the amazing things we can make happen on an Apple device by leveraging the power
    of SwiftUI’s animation classes, methods, and properties.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a brief look at the two programming styles, imperative
    and declarative, and will give you an idea of why Apple introduced the declarative
    SwiftUI way of coding to the development world. Then, we’ll explore the Xcode
    interface, the free application from Apple, where we do all of our work. Finally,
    we’ll look at the SwiftUI structures needed to develop apps, which is the foundation
    for proceeding further with animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding imperative and declarative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Xcode interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SwiftUI structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write code that can run on Apple devices, first, we need an Apple
    computer. This can be any of their models, but the MacBook Pro is the most popular
    for coding because of its power and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the hardware, then the next bit of tech we need to write code is
    the software. Apple has put together a very comprehensive set of tools all bundled
    into one program called Xcode, which is free to download from the App Store. Those
    two things are everything you need to start writing code on Apple, but if you
    want to upload your finished app to the App Store, then you will need an Apple
    Developer account. This currently costs $99 a year to maintain, but it is necessary
    to be able to sell your apps to the world. Go to [developer.apple.com](http://developer.apple.com)
    and sign up for an account there.
  prefs: []
  type: TYPE_NORMAL
- en: You should also have a working knowledge of the Swift programming language so
    that you feel comfortable writing code, but you don’t have to be an expert by
    any means; it’s just that it is very helpful if you understand, or at least recognize,
    the syntax of the Swift language and the fundamentals of **object-oriented programming**
    (**OOP**) so that you can follow along with the projects better.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, if you are a complete beginner to writing code, you might be
    a bit confused here – but not to worry, when Apple introduced the Swift programming
    language in 2014, they held fast to their goal of making one of the easiest-to-pick-up
    and most user-friendly programming languages to date. And for the most part, the
    Swift language reads like English sentences, so you can progress very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what I recommend when you’re just starting out learning Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the Swift tutorials offered by Paul Hudson. He is a brilliant Swift
    programmer, and one of the most prolific in the industry. He has put together
    tons of free Swift training tutorials and videos that get you to write code fast.
    I have worked with Paul on many projects, and you would be hard-pressed to find
    a better and more thorough teaching style – he’s also just an all-around nice
    guy. Check out all his stuff at [hackingwithswift.com](http://hackingwithswift.com).
  prefs: []
  type: TYPE_NORMAL
- en: Someone else I have worked with (and continue to work with) is John D. Gauchat.
    He has put together a Swift and SwiftUI Mastermind series of books that can serve
    as both a reference and a guide/cookbook of code for when you need to remember
    the syntax or how to implement something fast. He is very thorough as well, and
    you can find his work at [jdgauchat.com](http://jdgauchat.com).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you like structured video courses, I have translated many of Paul’s
    and John’s Swift and SwiftUI books into video courses, and they are available
    over at [udemy.com](http://udemy.com) – just search for my name to see them all,
    including the video version of this book (which includes extra projects).
  prefs: []
  type: TYPE_NORMAL
- en: OK, that’s enough of those shameful plugs, but if you are a complete beginner,
    I want you to learn the Swift programming language from the very best, and those
    two guys are; this way, you will be ready to follow along and code in no time.
    So, go get some Swift knowledge under your belt, and come back here. I’ll wait…
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to access all of the code in this book, go to the following GitHub
    repository: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding imperative and declarative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI is a fairly new framework introduced by Apple in 2019 that includes
    intuitive new design tools that help make building great-looking interfaces almost
    as easy as dragging and dropping… almost. With its modular approach, it’s estimated
    that you can build the same projects previously built in Xcode using about five
    times less code. Also, SwiftUI was Apple’s solution for building apps that can
    easily be used on all of their other platforms – so, an app can be built once,
    and it will perform perfectly on iOS, tvOS, macOS, and watchOS.
  prefs: []
  type: TYPE_NORMAL
- en: The SwiftUI interface, which we will cover shortly, uses editor and canvas preview
    windows that work in tandem. As you code in the Xcode editor, the new design canvas
    displays everything completely in sync and renders in real time as you type. So,
    any change you make in the editor is immediately reflected in the canvas preview,
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned the ease of drag and dropping in code earlier; this is because those
    nice engineers at Apple must have spent countless nights working hard putting
    together a huge selection of pre-made chunks of code called views and modifiers
    that you can drag and drop right into the editor. This includes things such as
    buttons, labels, menus, lists, pickers, forms, text fields, toggle switches, modifiers,
    events, navigation objects, effects, and well, much more, but you get the point.
    Unlike UIKit and Storyboards, when you drop a view or a modifier into the editor
    or on the canvas, SwiftUI generates the code for that view automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The SwiftUI approach to app development is known as **declarative programming**,
    and it has become widely popular in the last few years. Examples of declarative
    programming would include frameworks such as React and cross-platform development
    frameworks such as React Native and Flutter. So, now it’s Apple’s turn to offer
    its own completely native declarative UI framework, SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: But what does declarative programming actually mean? Well, to best describe
    declarative programming, let’s first understand what imperative programming is.
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative programming** has been the oldest programming paradigm since the
    dawn of computer languages. The word “imperative” has its origin in the Latin
    word “imperare”, which means “to command,” and it was first used to express a
    command – for example: “do it”! (Hmm, I wonder whether Nike borrowed that imperative
    command and tweaked it a little…) This style of programming is what iOS developers
    used before SwiftUI came out.'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming is a programming paradigm that uses statements that change
    a program’s state. These statements are executed in a specific order, and they
    usually involve assignment statements, loops, and control structures that specify
    how the computation should be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: In imperative programming, the programmer specifies exactly how the computation
    should be carried out, using statements that tell the computer what to do. This
    can make imperative programs more complex because the programmer has to specify
    all of the steps of computation. However, it can also make them more flexible
    because the programmer has more control over the details of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of imperative programming using the UIKit framework in iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new `UIButton`, sets its title and title color, and adds
    an action to be performed when the button is tapped. It then adds the button to
    the view hierarchy. This code is imperative because it specifies the exact steps
    needed to create and configure the button and add it to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this same code could also be written in a declarative style using a library
    such as SwiftUI, ReactiveCocoa, or RxSwift, which allows you to specify the desired
    behavior of the button rather than the steps needed to achieve it. Here is the
    same example written using SwiftUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Button` view is declarative, because it specifies the
    desired behavior of the button (displaying text and performing an action when
    tapped), rather than the steps needed to create and configure the button.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI uses a declarative style of programming, which can make it easier to
    understand and maintain your code because you don’t have to specify all of the
    intermediate steps needed to achieve the desired behavior. It also allows your
    code to automatically update when the underlying data changes because you specify
    the desired outcome rather than the steps needed to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: So, declarative programming is a programming paradigm in which a program specifies
    what it wants to achieve, rather than how to achieve it. The focus is on the “what”
    rather than the “how.” Declarative programs are usually easier to understand because
    they don’t require the programmer to specify every single step of the computation.
    They can also be more concise because they don’t need to specify all of the intermediate
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different programming languages and technologies that support
    declarative programming, including SQL, HTML, and functional programming languages
    such as Haskell and Lisp. In general, declarative programming is well suited to
    tasks that involve defining data relationships or specifying a desired output,
    rather than specifying the steps needed to achieve something.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify, let’s use the analogy of an artist: imperative languages paint
    by numbers to reach the desired result, a finished painting, but declarative languages
    use the finished painting and let background algorithms (functions and methods)
    automatically choose the appropriate colors and brush strokes to achieve the desired
    result. Also, by using this declarative approach, SwiftUI minimizes or eliminates
    programming side effects, usually caused by tracking the state of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will want to keep in mind that in many cases, code will be a mixture of
    both imperative and declarative styles, so it’s not always one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: With a better understanding of SwiftUI now, we will proceed to an overview of
    the Xcode interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Xcode interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a tour of the Xcode interface. I’m assuming that
    you have used Xcode before, practicing your Swift skills, which means you have
    a good handle on many of the things here in the interface. However, there are
    a few new additions to accommodate SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: When you first start up Xcode, you see the welcome screen. On the right is a
    list of recent projects, and on the left, there are buttons to start a new project,
    open an existing project, or clone one saved in a repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Xcode welcome screen ](img/B18674_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Xcode welcome screen'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the first option, which is **Create a new Xcode project**,
    for all of our projects, so select that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screen lets us choose options for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Project options  ](img/B18674_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Project options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product Name**: This will be the name of the project. You should select a
    name that is directly related to what the project will do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team**: This will be the developer account you created with your Apple ID
    at [developer.apple.com](http://developer.apple.com), or a company account if
    you have one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.SMDAppTech`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were wondering why Apple requires this reverse notion, here’s a deeper
    explanation. Reverse domain name notation (or reverse DNS) is a system used to
    map an IP address to a domain name. Reverse DNS strings are based on registered
    domain names, with the order of the components reversed for grouping purposes.
    Here is an example: if a company making a product called MyProduct has the domain
    name [exampleDomain.com](http://exampleDomain.com), they could use a reverse DNS
    string of `com.exampleDomain.MyProduct` as an identifier for that product. Reverse
    DNS names are a simple way of eliminating namespace collisions since any domain
    name is globally unique to its registered owner.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface**: This is where we select the technology we will use to design
    the UI. From the drop-down list, you can choose **SwiftUI** or **Storyboard**.
    SwiftUI is a system that lets us declare the interface from code, while Storyboard
    is a graphical system that allows us to drag and drop many components and controls
    onto a storyboard to create the user interface – we want to select **SwiftUI**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quick note: even though we drag and drop onto the storyboard in that option,
    the code is not generated after you drop an object onto the board. You still have
    to write out the code for each object and make connections for buttons and other
    controls. Whereas in SwiftUI, you can drag and drop similar components, and the
    code is automatically propagated in the editor for you. You then fill out the
    body with what you want it to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Language**: This is the coding language; here, we will select **Swift**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t need to use core data, which is a way of persisting your data so it
    always loads back up again, and we don’t need to include tests for any of the
    projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we hit **Next**, we’re asked where to save the project. I like to save
    it on the desktop, but you can choose any location you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we are in the Xcode interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Xcode interface ](img/B18674_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Xcode interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Xcode interface is the part of Xcode where we do all of our coding. It
    is split up into different sections; here are those sections explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project** **Navigator** (**1)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a collapsible space that contains all the project files. A file called
    `ContentView` is here, into which we can write our code, and we can create more
    files as the project grows. If you have worked in Xcode before with UIKit, then
    the `ContentView` file is analogous to UIKit’s View Controller, where it had the
    `ViewDidLoad` method, in which we would usually load some user interface code.
    Here, we put the UI code in the `ContentView` struct and create other structs
    as needed. We can also organize all these files by creating and naming new groups
    and folders. There’s another file here called `Assets.xcassets` (also called the
    Assets catalog), where we place the images and colors needed for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the top of the `Demo`. This is the main folder of your project into
    which everything else is placed, including the new Swift files that you create.
    Clicking on that takes us to many different options and settings to configure
    the app, things such as the deployment target, signing, capabilities, build settings,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tool** **bar** (**2**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the toolbar (after the traffic light buttons), starting from
    left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a navigator toggle button that opens and closes the **Project Navigator**
    pane that we just looked at, to give you more working space when you need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the right of the navigation button is a play button that runs and stops the
    project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you will see the title of your project. However, if you click on it, this
    is a drop-down list, allowing you to select the scheme and various different simulators
    or devices to run your project in. A scheme is a destination for running the app.
    For example, Xcode lets us run the project on different simulators, on a device,
    in a window on the Mac computer, on an Apple watch, on an iPad, or on an Apple
    TV if we are building for those. We are building for the iPhone, so you can select
    any of the iPhone simulator models from the list, or connect your iPhone to your
    computer and you will see it appear in the list. If you select your iPhone, you
    can see what your app looks like running on an actual device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, there is a display area to show any errors or warnings, as well
    as the app’s current status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the right on the toolbar is a plus button that opens up a library of tools
    that we use to help create the user interface, things such as modifiers, views,
    controls, and code snippets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, there's another button at the far right to show or collapse the
    Utilities Inspector, again, for more screen real estate when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities** (**3**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Utilities** Inspector is a collapsible area that offers more options
    to edit and configure the interface and its elements. There are five tabs at the
    top for this; from left to right, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File Inspector** is used to adjust the parameters for the file you are working
    in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History Inspector** is used to view your project’s history (this is not used
    much in a SwiftUI project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick Help Inspector** will give you a description/definition of the code
    selected in the editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility Inspector** is for configuring things such as voiceover, Braille
    reading, and other settings related to making your app more accessible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes Inspector** gives you the option to change any of the attributes
    of a particular view, modifier, or other control that you have selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug/Console** (**4**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a collapsible space that appears and disappears by toggling the button
    on the bottom right. The area can also be divided into two sections. When split,
    the section on the left provides information for debugging, and the right is a
    console used to display any relevant information when we run the code, as well
    as warnings and errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Editor** (**5**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the area in which we write our code. This section of Xcode is not collapsible,
    but we can split it into two or more sections by clicking the button at the far
    right just underneath the toolbar. It can be positioned at the top or the bottom
    depending on how you like to write code.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a feature called the mini-map, a miniature map of the code file,
    which offers a helpful view of the entire file, and makes it easy to reference
    and navigate around your code, especially if you have very large files. We can
    enable it by clicking on the little hamburger icon at the top right and choosing
    **Mini Map**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas** **Previews** (**6**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The canvas is its own collapsible section of Xcode that features a graphical
    simulator called a preview, that has a real-time connection to the code within
    the editor. Any changes we make in the editor will be reflected in the preview.
    There is a **Run** button on the preview to test out what you’ve done so far,
    but the preview is a great visual aid that helps speed up development.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the XCode interface in a nutshell. It may look daunting at first, but
    as you code along through the projects, you will become more comfortable and start
    to learn where everything is.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue and look at the concept of the state, which is data that can
    change. We hold our data in variables, and that data changes many times when we
    animate something in SwiftUI; when the data changes, SwiftUI helpfully will handle
    updating the animations for us by using the state to refresh the views.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In SwiftUI, a state is a piece of data that can change. When the state changes,
    the view that depends on the state is automatically refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare a state in a SwiftUI view by using the `@State` property wrapper.
    For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `name` is a state that is stored as a string. You can then use this state
    to display dynamic content in your view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the state, we can assign a new value to the `@State` property. For
    example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the button is tapped, the name state is changed to `"Jack"` and the view
    is automatically refreshed to display the new name.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue now and look at what makes up SwiftUI and helps it works so well.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SwiftUI structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI gives us views, controls, modifiers, and layout structures for declaring
    the user interface. The framework also includes event handlers for providing taps,
    gestures, and other kinds of input for our app, as well as tools for managing
    the flow of data coming from your app’s models.
  prefs: []
  type: TYPE_NORMAL
- en: But what’s a model? A **model** is simply a folder we create in the **Project
    Navigator** window where we usually keep the app’s data; for example, if we are
    working on a weather app, we can keep our wind, temperature, precipitation, and
    snow accumulation data in the app’s model after it has been received from the
    internet through an **Application Programming Interface** (**API**) call, which
    is prebuilt software that talks to other programs for us. That data will then
    be processed and sent down to the views and controls that the user will see and
    can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI allows us to avoid using Interface Builder and Storyboards to design
    the app’s user interface, as we can use the preview canvas and the editor instead.
    We can inspect the user interface as we write code, and also generate code when
    dragging and dropping views/controls into the canvas. The code within the editor
    and the canvas preview are side by side; changing one will update the other.
  prefs: []
  type: TYPE_NORMAL
- en: When building our apps, we use **views**. Nearly everything is a view in SwiftUI,
    and they are the building blocks of our apps, things such as text boxes, buttons,
    toggles, pickers, shapes, colors (yes, even colors are a view), stacks, and more.
    We add them to the canvas by dragging them out of the view’s library, or by typing
    out the code in the editor, and then setting their properties with modifiers.
    Each view will have its own unique set of properties and modifiers, and many views
    will also share those same properties and modifiers too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the SwiftUI structures we will look at so you can get a good
    foundation for completing this book’s projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks (`VStack`, `HStack`, and `ZStack`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Spacer` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Divider` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `padding` modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GeometryReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through each of these now.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first things we will look at is **computed properties** because
    that is how views are made. Here is a look at the template code that we see when
    we first create a new SwiftUI project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run that code, this is what we see in the preview window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Running the template code ](img/B18674_01_04_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Running the template code'
  prefs: []
  type: TYPE_NORMAL
- en: The **Hello, world!** string is displayed in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code, we see that it includes a `struct` object called `ContentView`,
    which is the basic building block struct that SwiftUI creates for us. Inside that
    is a computed property called `body` – it has open and close parentheses, and
    yes, it has a body where you place your code to be executed, as does any function
    in Swift. Computed properties do not store values as a regular stored property
    or variable would. Instead, this property will compute the code you place in between
    the parentheses and then return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties can have getters and or setters. They can either get and
    return a value, set a new value, or do both. However, if it just has a getter,
    then it’s known as a read-only property because it will only return the computed
    properties value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering if this is a computed read-only property, where are
    the getter and return keywords? Well, this code is actually the shorthand version
    of a computed property. It’s optional to write out the longhand version, but we
    could if we wanted more readable and descriptive code; if we did, it would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the same thing as before: it returns the `get` and `return`.
    Again, they are optional, so you will see the shorthand version in most cases,
    because less code is, well, less code, which makes life easier. Still, many developers
    prefer the clarity of adding those keywords... it’s up to you.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another curious bit of syntax here and that’s the `some View` keyword.
    The `some` keyword indicates that an opaque type will be returned, and `View`
    is the opaque type in this instance. Opaque refers to something that’s not clear
    or not easily understood. So, what’s not clear? That would be the type that this
    view will return. That’s because, being an opaque type, it hides the type and
    its implementation from us. All it cares about is that a single view will be returned,
    which is important because only one view can be returned to satisfy the `some`
    keyword’s requirements. The view’s type that will be returned is determined by
    what we put into the body of the computed property. In the code, there is a `Text`
    view there, so that’s the type that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: When we create custom views, we just have to make sure that it conforms to the
    `View` protocol. To do that, we just need to implement the required `body` computed
    property, then we can add whatever view we want to display, things such as buttons,
    toggles, pickers, shapes, colors, and so on, but again, just one view.
  prefs: []
  type: TYPE_NORMAL
- en: Another bit of syntax to look at is `.padding()`, called a layout modifier –
    it modifies the layout of the text view by placing 20 points of padding (that’s
    the default amount when we don’t choose a value) all around the text view. Many
    different modifiers are grouped into different categories, such as text modifiers,
    image modifiers, list modifiers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Have a play around and experiment with them by clicking on the plus button on
    the top right in Xcode and then selecting the **Modifiers** tab. You will quickly
    get to know the many different modifiers as you start building the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to the organizational layout of these views on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember I said that the `some View` protocol has one requirement, and that
    is to return just one view when we run the code. That’s fine in very simple apps,
    but more often than not, we need to return more than one view – several views
    might need to be displayed on the screen for the user to interact with in fact,
    such as a button, a text field, some images, text, and so on. We need to organize
    these views vertically and horizontally on the screen, as well as on the *z*-axis
    (placing views on top of each other).
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, SwiftUI gives us vertical, horizontal, and zed stacks, or `VStack`,
    `HStack`, and `ZStack` for short. These are container views that can hold 10 views
    inside them. The views inside them are know as **child views**. Let’s look at
    each now.
  prefs: []
  type: TYPE_NORMAL
- en: VStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Text` view, and it displays **Hello World!** on the user’s screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to have more than one view returned from inside the body
    computed property? Maybe we want to have a `Button` *and* a `Text` view on the
    screen, as in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we press *Command* + *B* to build this code, it builds cleanly and error-free.
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though this code is error-free, nothing appears in the previews, so
    it won’t do anything when we press the play button to run it. The code won’t do
    anything because there are two views inside the body computed property: a `Text`
    view and a `Button` view. This violates the `View` protocol, which only wants
    `some View` returned (singular), not `some` `Views` (plural).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the same code with a minor change made to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I have put all of the code inside the `VStack`. Now, when we run it, everything
    works as expected, and the two views can coexist inside the `body` computed property
    without any issues. If we press the button, the text will change depending on
    the value in the `changeText` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: VStack ](img/B18674_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: VStack'
  prefs: []
  type: TYPE_NORMAL
- en: The `VStack` can hold 10 child views and is still considered to only return
    one view itself, so the `some View` protocol is satisfied. If you need more than
    10 children, you can nest VStacks inside each other to add even more views.
  prefs: []
  type: TYPE_NORMAL
- en: The `VStack`, as you might imagine, will stack all of its children vertically,
    but you can also set an optional alignment and spacing within the `VStack` initializer
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, everything in the `VStack` is center-aligned, but if you want all
    of its child views aligned to the leading edge or trailing edge, you can use the
    `alignment` parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All the child views are now aligned to the leading edge within the `VStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Leading alignment ](img/B18674_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Leading alignment'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also align the views to the trailing edge or the center. To do that,
    we use dot syntax to access those other `enumeration` values: `.leading`, `.trailing`,
    or `.center` are the options available for alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Spacing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The other parameter inside the `VStack` is the `spacing` option. This will
    put some space between all the child views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code puts 10 points of space between each child view, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: VStack spacing ](img/B18674_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: VStack spacing'
  prefs: []
  type: TYPE_NORMAL
- en: That’s how the `VStack` works; let’s continue and look at the `HStack` now.
  prefs: []
  type: TYPE_NORMAL
- en: HStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In contrast to a `VStack`, an **HStack** displays its children horizontally.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The number views are now all stacked horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: HStack ](img/B18674_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: HStack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a `font` modifier to the entire parent stack will affect all the children
    inside it, but to affect an individual child view, you need to place the modifier
    on it directly. Here is an example of doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the `Text` view number of `4` has now been altered to have a larger
    font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Modifying the child ](img/B18674_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Modifying the child'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another important stack, the `ZStack`.
  prefs: []
  type: TYPE_NORMAL
- en: ZStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **ZStack** is a stack that will overlay its children, one on top of another.
    With this stack, we can create a hierarchy of views, where the first view in the
    stack will be placed at the bottom, and subsequent views will be stacked up on
    top of each other in sequential order. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code contains two views:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `Image` view, which accepts images that you have imported into
    the Assets catalog, and makes it possible to display the images on the screen.
    By using the `systemName` parameter, we can choose a system image from Apple’s
    stock of pre-made images, from many different categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use a system image in your projects, download the `Image` parameter called
    `systemName`. For my example, I’ve used an image called `rectangle.inset.filled.and.person.filled`
    and have placed it at the beginning of the `ZStack`; any view added underneath
    it will be placed on top of that image.
  prefs: []
  type: TYPE_NORMAL
- en: The second view is a `Text` view, placed on top of the system image by the `ZStack`.
    Again, because the code for the `Text` view is added under the code that creates
    the `Image` view, it is placed on top of the `Image` view when we run the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, I use a little bit of padding, and we can position that text where we
    want it. You can also use the `offset` modifier to place views anywhere on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the result of the code in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: ZStack ](img/B18674_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: ZStack'
  prefs: []
  type: TYPE_NORMAL
- en: There are also three modifiers in this code that we will look at in more depth
    when we start building the projects – that’s the `renderingMode`, `resizable`,
    and `frame` modifiers. They are used here because we need to render and resize
    the image correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Combining stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have seen how the three stacks can be used to display multiple
    views and position them where we want them on the screen, let’s look at an example
    that combines all three stacks, and the child views inside them, to produce a
    varied layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down this code to get a clear understanding of what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: First is the `VStack`. This will be our main stack and will hold all of our
    code. Using the `VStack` in this way means we can squeeze 10 child views inside
    it, but we only need to place a couple of views inside for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `ZStack`. Inside are its two child views – a `Text` view and an
    `Image` view. Since the `Image` view comes first in the code, the `Text` view
    gets placed on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how each child view in the `ZStack` has its own set of modifiers that
    are indented; these are to style these child views with colors and sizes and to
    position them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The next stack is the `HStack`. Remember that this arranges its children horizontally,
    and it has two child views, including an `Image` view and `VStack`. Notice how
    we can nest stacks inside of other stacks as we are doing here, with this `VStack`
    inside of a `HStack`. The `HStack` places its first child view to the left – that’s
    the tornado image – and then places its second child view to the right – that’s
    the `VStack`. If we look inside the `VStack` now, it has two child views of its
    own. They will be placed vertically, with the smaller text on the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if this nesting of stacks seems a bit confusing at first; as we
    start building projects, you will train your brain to think and see in hierarchies,
    and this will become very natural to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'By nesting the different stacks, we can make all kinds of interesting layout
    scenes. Here is the result of our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Combining and nesting stacks ](img/B18674_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Combining and nesting stacks'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are great for helping to organize and lay our views out on the screen,
    but there is another container view we can use that offers even more flexibility.
    That’s the `GeometryReader` view. However, we will look at that at the end of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s look at a `Spacer` view – this is a view that helps with spacing
    out the layout in our UI design.
  prefs: []
  type: TYPE_NORMAL
- en: Spacer views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `HStack`, a `Spacer` view expands horizontally as much as the stack allows,
    moving sibling views out of the way within the limits of the stack’s size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `Spacer` initializer: `Spacer(minLength: CGFloat)`. This initializer
    creates a flexible space. The `minLength` argument sets the minimum size that
    the space can take. If the argument is left empty, the minimum length is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using a `Spacer` view in a `HStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a horizontal stack with `Spacer` view will take up all of
    the remaining space so that the two pieces of text are pushed to the edges of
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Spacer ](img/B18674_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Spacer'
  prefs: []
  type: TYPE_NORMAL
- en: The `Spacer` view can also be used in the `VStack`, and it will expand and push
    the child views apart vertically instead of horizontally. The `Spacer` view won’t
    do anything within the `ZStack` though, as that stack deals with the depth of
    a view on the *z*-axis, front to back.
  prefs: []
  type: TYPE_NORMAL
- en: Where `Spacer` separates views by creating space between them, another object
    called a `Divider` view separates views with a thin line, either vertically or
    horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Divider views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Divider view** is a visual element, a dividing line, that can be used to
    separate content either horizontally or vertically. You can also alter the divider’s
    thickness. Let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code creates a horizontal divider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have added a horizontal dividing line and set its color
    to black using the `background` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Divider ](img/B18674_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Divider'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to change the horizontal line to a vertical one, then we can pass
    the `width` parameter using a smaller number, and the `height` parameter using
    a larger number, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `offset` modifier lets us place the line anywhere on the screen,
    or on any view for that matter. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Vertical Divider view ](img/B18674_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Vertical Divider view'
  prefs: []
  type: TYPE_NORMAL
- en: Thickness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can change the thickness of the dividing line using the `frame` modifier,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by using the `height` and `width` parameters of the `frame` modifier,
    we can change the dimensions of the `Divider` view, so we can make a line as long
    and wide as we want. The result of our example can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Divider thickness ](img/B18674_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Divider thickness'
  prefs: []
  type: TYPE_NORMAL
- en: That’s pretty much all the configuring we can do with the `Divider` view. Let’s
    now look at one of the most frequently used modifiers in SwiftUI – the `padding`
    modifier.
  prefs: []
  type: TYPE_NORMAL
- en: The padding modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that we have used the **padding modifier** quite a bit
    already without really explaining it yet.
  prefs: []
  type: TYPE_NORMAL
- en: Every view has its own dimensions and space that it takes up on the screen.
    For example, we can place two views side by side and they will be very close to
    each other, separated by only a few points.
  prefs: []
  type: TYPE_NORMAL
- en: Points and pixels refer to different ways of measuring the size of the views
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Points** are used to specify the size of text and other UI elements, and
    they are independent of the resolution of the device’s screen. This means that
    a point will always be the same size on any device, regardless of the screen’s
    resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixels**, on the other hand, are the individual dots that make up the screen
    of an iPhone (or any other device). Pixels are used to measure the physical resolution
    of a device’s screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add a `padding` modifier to a view, it adds a small amount of empty
    space all around that view by default, and that space is measured in points. The
    `padding` modifier by default adds eight points of empty space around a view,
    but if you want to be more specific about the amount of space with which to pad
    your view, then you can pass in a value (an integer) for a custom amount of padding.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, there are four `Text` views inside the `VStack`. At the end of
    the VStack’s closing brace is a call to the `background` modifier, which will
    color the background yellow so that you can see the `padding` modifier at work.
    Next, I added the `padding` modifier and passed in `30` points, which will be
    applied around the `VStack` equally. Finally, I colored the padding red, again,
    using the `background` modifier, so you can see the padding directly. In the example,
    the padding will look like a red frame around `VStack`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Padding ](img/B18674_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Padding'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the other `padding` options. The modifier allows us to
    choose from predefined enum values if we only want to pad one side, as in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code pads only the `leading` edge of each `Text` view by `75` points of
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Padding options ](img/B18674_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Padding options'
  prefs: []
  type: TYPE_NORMAL
- en: We can also choose other padding options by typing in a dot for the `alignment`
    parameter and selecting from many different options, including `trailing`, `top`,
    `bottom`, `horizontal`, `infinity`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the previous code, notice the placement of the `padding` modifier;
    it has been put on the closing brace of the `VStack`. When placed like this, all
    the children inside the `VStack` have the padding applied to them, but if we want
    to pad the child views individually, we can do so by placing modifiers directly
    on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can add modifiers to child views individually, styling
    them as you need for your layout. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18: Padding children ](img/B18674_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Padding children'
  prefs: []
  type: TYPE_NORMAL
- en: Each child view now has its own padding, either `leading` or `trailing`, which
    alters its placement on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up this chapter by looking at closures, which is essentially a
    function without a name, and then another container view that offers some more
    flexibility than the other stacks we previously looked at – the `GeometryReader`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the easy definition of a **closure**: a closure is a function without
    a name. Remember a function is a block of code that runs whatever code statements
    are in its body when it is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s look at a more detailed definition of a closure: a closure is a self-contained
    block of code that can be passed around and executed at a later time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures are not exactly functions, but they are similar, with some key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Closures can be stored as variables and passed as arguments to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures can capture and store references to any variables or constants from
    the context in which they are defined, which allows them to maintain the state
    and preserve data between invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures don’t have a name as a function would
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In SwiftUI, closures are often used as a way to respond to user input or other
    events. For example, you might use a closure as the action for a button, or to
    provide a block of code to be executed when a view appears or disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a closure being used as the action for a button in SwiftUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the closure is defined using the `{ }` syntax and is passed
    as the `action` parameter to the `Button` view. Yes, that’s right, the `Button`
    action is a closure, and when the button is pressed, the code inside the closure
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures can also be used to provide custom behavior for views in SwiftUI.
    For example, you might use a closure to perform some custom animation when a view
    appears or disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `onAppear` modifier is called on the `Text` view and is
    passed a closure that will be executed when the view appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We also have trailing closures. A trailing closure is a closure that is written
    after the function or method it is passed to. The closure is “trailing” because
    it comes after the function or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a function that takes a closure as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you would call this function and pass a closure as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the closure is written after the `doSomething` function and
    is therefore a trailing closure. In SwiftUI, you can use trailing closures to
    provide custom behavior for views. For example, you might use a trailing closure
    to perform some custom animation when a view appears or disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `onAppear` method is called on the `Text` view and is passed
    a trailing closure that will be executed when the view appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you haven’t quite grasped how closures work yet; they are not
    as complicated as they appear, and you will understand them better as we progress
    throughout the book. For now, let’s move on to `GeometryReader`.
  prefs: []
  type: TYPE_NORMAL
- en: GeometryReader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GeometryReader` will contain the position and size of the view we are working
    with, and we can then alter or place that view however we want with the values
    that are returned by `GeometryReader`’s proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Using these values, we can make the child views dynamically update their position
    depending on the device size and position when the orientation changes to either
    landscape or portrait. This all will become clearer when we see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how to create `GeometryReader`. The following is the initializer
    used to create the `GeometryReader` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `content` parameter is a closure that receives a geometry proxy value with
    the view’s position and dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve those values, we use the following properties and method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `size` property will return the width and height of the `GeometryReader`
    view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `safeAreaInsets` property will return an `EdgeInsets` value with the insets
    for the safe area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `frame(in: )` method returns the position and size of the `GeometryReader`
    view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code to create an empty `GeometryReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is what we see when we run the code. Notice how it pushes itself out to
    occupy all the space on the screen; the yellow background shows all the areas
    of this empty `GeometryReader`, which is the entire screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: GeometryReader ](img/B18674_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: GeometryReader'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default behavior of `GeometryReader` is to align its children in the upper-left
    corner and place them on top of each other. In this next example, the code places
    three views inside `GeometryReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, notice that only one tornado image is visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: GeometryReader default child alignment ](img/B18674_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.20: GeometryReader default child alignment'
  prefs: []
  type: TYPE_NORMAL
- en: There are actually three tornado images in this example, but you can only see
    one because the default behavior is to place them on top of each other in the
    upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We obviously don’t want all the child views stacked on one another, so we will
    explore the following concepts to really utilize `GeometryReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: Sizing a view to accommodate rotating the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning a view anywhere on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a view’s position in terms of its global and local space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at these now.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first look at the property that is used to access the `GeometryReader`’s
    size... aptly named, the `size` property. This will return the width and height
    of the `GeometryReader` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of adding an image inside the `GeometryReader` view, and
    seeing how it adapts its size when the device is rotated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the size of the image in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: GeometryReader size property (portrait) ](img/B18674_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.21: GeometryReader size property (portrait)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In portrait mode, the image is bigger, but when the device is rotated to landscape,
    the image scales down to adapt to the screen change, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: GeometryReader size property (landscape) ](img/B18674_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.22: GeometryReader size property (landscape)'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added an `Image` view within a `GeometryReader` view. I
    defined the `Proxy` parameter as `geometryProxy`, but you can call it anything
    you want. `geometryProxy` holds the information about `GeometryReader`’s dimensions
    and position. Using this `Proxy` object, the size of the image is changed when
    we rotate the device. The image will be half the width of the container, and the
    height will be a quarter of the height of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Using `geometryProxy.size` lets us access the height and width of `GeometryReader`.
    The `Image` view will adapt when the device is rotated. I’m also using the `scaledToFit`
    modifier so that we can keep the correct aspect ratio for the image.
  prefs: []
  type: TYPE_NORMAL
- en: I set the `Image` view’s background to gray so that you can see the space that’s
    available in both portrait and landscape modes. When it’s in landscape mode, there’s
    much more space available around the `Image` view because it scales down.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the image is positioned in the top-left corner of the `GeometryReader`
    view. Again, that’s the default location for its child views; they will simply
    stack up on each other in that area.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at positioning those child views anywhere we want within
    the `GeometryReader` container.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve seen how `GeometryReader` can dynamically change the size of a view as
    it’s rotated, but it can also position the views within it. The positioning information
    is returned by the `geometryProxy` closure, and we can pass that information into
    the `x` and `y` parameters of the `position` modifier via the `size` property.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code here has two VStacks within `GeometryReader`, and each `VStack` has
    the `position` modifier on its closing brace, so everything within the VStacks
    will be positioned according to the values in the `position` modifier’s `x` and
    `y` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result when running this code is the placement of the `Image` and `Text`
    views according to the `size.width` and `size.height` values, as shown in this
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: GeometryReader positioning views ](img/B18674_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.23: GeometryReader positioning views'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with `GeometryReader` and see how we can read the values of its
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we need to get the position of the `GeometryReader` view in terms of its
    `coordinate` location, again, we can use the `geometryProxy` object and pass its
    information into the `frame()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two coordinate spaces in SwiftUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global space**: The coordinates of the entire screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local space**: The coordinates of individual views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When reading the values of the local coordinate space of the `GeometryReader`
    view, we will always see `0,0` for `x` and `y`. That’s because `GeometryReader`
    always starts at that position, `0,0`, the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get the position of the views in relation to where they are on the screen,
    we need to use the global coordinates. Here is an example that gets and displays
    the local and global values for the `GeometryReader` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the values are being formatted using a format specifier: `%.f`.
    This format specifier will truncate some of the decimal places so it displays
    fewer zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code will display the `x` and `y` coordinate values for both the
    global and local space for the views, when the device is in portrait mode, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24: Reading the position (portrait) ](img/B18674_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.24: Reading the position (portrait)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotating the device into landscape mode changes the global values to reflect
    the new location of the `Image` and `Text` views, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25: Reading the position (landscape) ](img/B18674_01_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.25: Reading the position (landscape)'
  prefs: []
  type: TYPE_NORMAL
- en: The code in this example demonstrates the difference between the global and
    local coordinate spaces. The values for the local coordinate space always return
    `0,0` because that is the starting position of `GeometryReader`, but the values
    for the global coordinate space are the origin of the `geometryProxy` frame within
    the entire screen. So, the global values change as the device is rotated because
    the view’s position has changed. The local values do not change as they reflect
    the screen’s upper-left corner, `0,0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI also offers properties to get the minimum, middle, and maximum coordinate
    positions from within `GeometryReader`’s frame for both the global and local spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We use these properties with dot syntax, right at the end of the `frame` method.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will return the minimum, the middle, and the maximum `x` and `y`
    coordinates for `GeometryReader`’s frame and display them on the screen for both
    local and global spaces in portrait mode, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.26: Using the min, mid, and max properties (portrait) ](img/B18674_01_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.26: Using the min, mid, and max properties (portrait)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the device is rotated, those values will adjust to new values that reflect
    the change in the screen’s orientation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.27: Using the min, mid, and max properties (landscape) ](img/B18674_01_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.27: Using the min, mid, and max properties (landscape)'
  prefs: []
  type: TYPE_NORMAL
- en: The SwiftUI structures you have just learned about will be the building blocks
    for the programs we will write going forward. Rather than listing all the structures
    in one chapter, which can be a lot to take in, I will introduce new ones in different
    projects throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up what we learned in this chapter, we introduced SwiftUI and saw the
    difference between the two programming paradigms, imperative and declarative.
    After that, we explored the Xcode interface. Then, we covered the important function
    of the state, and finally looked at the building blocks of SwiftUI – these are
    fundamentals that you will use throughout this book and are an essential first
    step toward creating beautiful animations in SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore animations, how they work, and the kinds
    of properties that can be animated.
  prefs: []
  type: TYPE_NORMAL
