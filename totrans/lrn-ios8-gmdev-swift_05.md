# 第5章 动画与粒子

在上一章中，我们创建了一个基本游戏。在本章中，我们将使游戏更加生动，角色更加逼真。我们将添加动画，而不是仅仅静态图像。我们还将探讨SpriteKit内置的粒子效果创建器。

对于角色动画，我们将探讨SpriteKit如何创建动画，以及一个名为**Texture Packer**的外部工具，由Code'n'Web开发。我们将了解它是如何简化动画过程的。我们还将介绍一个称为**精灵表**的概念，这是基础性的，用于优化游戏性能。

我们首先将了解SpriteKit如何获取内置的精灵表生成器，使动画过程更加简单。然后我们将探讨Texture Packer，它进一步简化了这一过程。所以，让我们看看什么是精灵表。

本章涵盖的主题如下：

+   精灵表动画

+   基本SpriteKit动画

+   Texture Packer

+   创建英雄精灵表

+   动画英雄

+   粒子系统

+   粒子设计师

+   创建粒子效果

+   将粒子系统添加到游戏中

# 精灵表动画

到目前为止，我们所做的是使用单个文件来存储玩家、敌人、火箭和子弹。每次我们创建一个新的火箭，游戏就会去获取内存，找到并检索图像。每次创建子弹时，这个过程都会重复。对于像我们这样的简单游戏来说，这没问题，但后来，当我们开始创建包含更多敌人类型和子弹的更复杂游戏时，这个过程将对设备造成很大的负担，并影响游戏性能。

为了解决这个问题，我们使用了精灵表。精灵表包含我们在游戏中将使用的所有图像，存储在一个单独的文件中，而不是在10个不同的内存位置存储10个图像。精灵表图像文件还将附带一个数据文件，其中包含精灵表中每个图像的位置和大小。在游戏开始时，精灵表图像和数据文件被一次性加载到缓存中。然后，每次调用火箭或子弹时，游戏就知道精灵表的位置，并简单地从其中加载图像。

精灵表文件需要尽可能紧凑，因此图像可能会被旋转以使其更紧凑。数据文件将跟踪这一点，并在游戏中创建帧时，将图像恢复为直立。

![精灵表动画](img/B04014_05_01.jpg)

在游戏中进行动画时，对应动画的每一帧都将存储在数组中，并以特定的预定义速度循环。

幸运的是，在SpriteKit中，我们只需要提供帧。在运行时，SpriteKit会自动创建精灵表，我们可以在游戏中使用它。我们将使用SpriteKit内置的精灵表创建器来创建敌人动画。稍后，我们将使用Texture Packer创建玩家动画。

# 基本SpriteKit动画

要创建敌人动画，我们首先必须将图像提供给 SpriteKit。由于我们必须为每个帧提供 **1x** 和 **2x** 图像，我们可以创建四个图像集；命名为 `enemy1`、`enemy2`、`enemy3` 和 `enemy4`；然后为每个集拖动 **1x** 和 **2x**。虽然以这种方式做是完全可能的，但非常繁琐。有一种更简单的方法。在命名每个帧时，对于帧的 **1x** 图像，您可以在文件末尾添加数字 `1`、`2`、`3` 和 `4` 以显示帧名称。对于帧的 **2x** 版本，您需要在文件末尾添加 `@2x` 以告诉 SpriteKit 此文件是原始图像版本的两倍大小。因此，对于第一帧，**1x** 文件将是 `enemy_1.png`，而帧的 **2x** 版本的文件名将是 `enemy_1@2x.png`（在这里，我使用下划线是因为我们在上一章中使用的常规敌人图像已经命名为 `enemy1.png`）。

`@2x` 位是关键字，所以请确保您不要将图像常规命名为 `@2x`，因为这可能会导致一些意外的结果。这种命名约定仅在您有一个图像的 **1x** 版本时使用。为了告诉 SpriteKit 哪个图像是 **2x** 版本，您需要在文件末尾添加 `@2x` 以表明此图像是另一个图像的两倍大小。

因此，为了创建敌人动画，我们将有四个动画帧。因此，我们将为每个帧有一个图像。此外，对于 **2x** 版本，我们还需要四个额外的图像，它们的大小是两倍，文件名以 `@2x` 结尾。

敌人动画的帧在此章节的 `Resources` 文件夹中提供。获取所有图像并将它们放置在桌面上的一个新文件夹中。现在，为了告诉 Xcode 必须从提供的图像创建精灵表，点击包含所有图像的文件夹，并将其重命名为 `enemyAnim.atlas`。这非常重要；如果您不这样做，则不会创建精灵表。文件夹应如图所示：

![基本 SpriteKit 动画](img/B04014_05_02.jpg)

将文件夹拖放到项目文件夹中。当窗口打开时，如图所示，请确保已勾选 **Copy items if needed** 复选框，并且当前项目是目标：

![基本 SpriteKit 动画](img/B04014_05_03.jpg)

点击 **完成** 继续操作。现在文件夹将位于项目中，我们可以开始添加代码来动画化敌人角色。当敌人被创建时，我们不会使用静态图像，而是更改 `addEnemy` 函数，如下所示。

首先，让我们检查我之前所说的是否正确。如果我们用第一帧的图像名称替换敌人变量，游戏应该仍然可以工作。因此，在创建敌人的地方，我们不会传递敌人图像集，而是将动画的第一帧传递给`enemyNode`变量。在`addEnemy`函数中将创建敌人节点的行更改为以下内容：

[PRE0]

这不会使角色动画化，因为它仍然只取动画的第一帧并显示它。但至少，我们可以确信帧正在正确加载。在传递名称时不需要添加扩展名，因此不需要`.png`。你也不需要说`@2x`来加载更高分辨率的图像，因为SpriteKit会自动将`@2x`的缺失视为**1x**分辨率，并为**2x**分辨率获取`@2`图像文件名。

现在，让我们继续加载其他帧，以便我们可以为敌人动画。在`addChild(enemyNode)`行之后，在`addEnemy`函数中添加以下代码行：

[PRE1]

首先，我们使用SpriteKit中的**纹理图集**类在名为`textureAtlas`的常量中加载精灵表。等等！什么是纹理图集？嗯，它只是精灵表的另一个名字。你可以叫它任何名字，但它们的意思是相同的。

在加载精灵表后，我们创建一个数组来存储所有纹理，即动画的帧。

由于我们需要加载四个动画帧，即`enemy_1`、`enemy_2`、`enemy_3`和`enemy_4`，我们创建一个`for`循环并从`1`迭代到`4`。像任何数组一样，我们将这四个文件追加到我们创建的`textureArray`变量中。我们使用`SkTextureAtlas`类的`textureNamed`函数为每个纹理分配。类似于我们在屏幕上记录事物或动态更改文本的方式，我们使用`\()`运算符提供四个文件的名字。一旦图像存储在数组中，我们创建一个动作，以便我们可以以一定的速度遍历这些帧。SKAction的`animateWithTextures`函数接受一个纹理数组以及每个帧应在屏幕上显示的持续时间。因此，在这里，我们提供了存储所有纹理的`textureArray`变量，并给出0.2秒或200毫秒作为每个帧将显示的时间。然而，这将只运行一次动画。为了让动画反复运行，我们使用`repeatForever`动作。因此，我们创建一个新的常量`animate`，并通过传递动画将其存储在其中。最后，我们在`enemyNode`变量上运行这个动作。现在你可以构建并运行，以查看敌人角色正在动画化。

这一切都很不错，但有一个更简单的方法，这样我们就不必为 **1x** 和 **2x** 分辨率的游戏创建单独的帧集。此外，在创建纹理数组时，我们需要事先知道动画中需要循环多少帧。对于敌人来说，我们知道动画中有四帧，所以我们从 `1` 循环到 `4`。如果我们不知道这个信息怎么办？如果我们循环的帧数少于或超过动画的总帧数，可能会导致错误或动画看起来不流畅。

因此，为了动画化玩家，我们将使用 Texture Packer 的动画方式。

# 探索 Texture Packer

Texture Packer 是一款非常受欢迎的软件，被迪士尼、Zynga 和 WG Games 等行业专业人士用于创建精灵图集。您可以从 [https://www.codeandweb.com/](https://www.codeandweb.com/) 下载它。

![探索 Texture Packer](img/B04014_05_04.jpg)

这与我们在创建敌人动画时创建图像的方式相似。要使用 Texture Packer 创建精灵图集动画，您也必须首先在 Photoshop 或 Illustrator 中创建单个帧。我已经制作好了，每个单独帧的图像都已经准备好了。

您可以使用 Texture Packer 的试用版来跟随教程。下载时，请选择适合您操作系统的版本。幸运的是，Texture Packer 可用于所有主要操作系统，包括 Linux。

### 小贴士

下载 Texture Packer 后，您有三个选项：您可以点击尝试完整版一周，购买许可证，或者点击 **基本版本** 使用试用版。在试用版中，一些专业功能被禁用，所以我建议您尝试一周的专业功能。

点击选项后，您应该会看到以下截图所示的界面：

![探索 Texture Packer](img/B04014_05_05.jpg)

在这里，您可以通过点击屏幕左下角的 **打开项目** 按钮来打开一个现有项目，或者选择您希望创建精灵图集的框架。

如您所见，Texture Packer 支持广泛的框架和格式，包括 Cocos2d、Unity、Corona、Swift 以及更多。我们需要从列表中选择 **Swift** 并点击 **创建项目**。

### 注意

Texture Packer有三个面板；让我们从左侧开始。左侧面板将显示您为创建精灵表而选定的所有图像的名称。在这里，您可以拖放单个图像或包含您的资源的完整文件夹。中间面板是一个预览窗口。它显示了图像是如何打包的。右侧面板提供了选择您希望存储打包纹理和数据文件的位置以及打包图像格式的选项。布局部分为在纹理打包器中设置单个图像提供了很多灵活性。最后，我们有不同的模式来优化精灵表。

让我们来看看右侧设置面板中的关键项：

![探索纹理打包器](img/B04014_05_06.jpg)

## 数据

在**数据**下，我们定义了有关要导出数据文件的所有信息。这包括**数据格式**、**图集包**和**Swift类文件**。以下是对每个字段的解释：

+   **数据格式**：如我们之前所见，每个导出的文件都会创建一个包含图像集合和数据文件的精灵表，该数据文件跟踪精灵表上的位置。数据格式通常取决于您选择的框架或引擎。由于我们最初选择了SpriteKit并选择了**Swift**作为语言，因此格式为`swift`类型。假设我们正在使用Objective-C语言，那么也有一个针对该语言的单独选项。因此，在选择格式时要小心，否则如果您希望为另一种格式开发精灵表，您将不得不从头开始。

+   **图集包**：这是您希望导出的图像和数据文件保存的位置。因此，一旦文件发布，您将获得一个`.png`图像文件和一个包含精灵表信息的`.plist`数据文件。

+   **Swift类文件**：除了图像和数据文件外，Texture Packer还会创建一个包含信息的辅助类，这些信息将与图像和数据文件一起导入，以使动画代码更加简单。

## 纹理

在**纹理**部分，我们将指定精灵表图像的文件细节。这包括有关**纹理格式**、**Png Opt Level**和**像素格式**的详细信息。以下是对这些字段的解释：

+   **纹理格式**：默认设置为`.png`，但也支持其他格式。除了PNG之外，您还可以使用PVR格式。这种格式用于数据保护，因为它更容易从常规PNG文件中复制数据。此外，PVR格式提供了优越的图像压缩。但是，请注意，它只能在苹果设备上使用。

+   **Png Opt Level**：用于设置PNG文件的质量。

+   **像素格式**：这设置了要使用的RGB格式。通常，您希望将其设置为默认值。

## 布局

在这里，我们指定精灵表图像的布局。以下字段可以在**布局**部分看到：

+   **最大尺寸**: 您可以根据框架指定精灵图集的最大宽度和高度。通常，所有框架都允许最大为4092 x 4092，但这主要取决于框架，因此在创建精灵图集之前，请检查框架允许的最大尺寸。

+   **尺寸约束**: 一些框架更喜欢精灵图集以POT格式（或2的幂）存在，即32 x 32、64 x 64、256 x 256等。如果是这种情况，那么您需要相应地选择。否则，您可以选择**任意尺寸**。

+   **缩放变体**: 这用于放大或缩小图像。如果您打算为不同的分辨率创建图像，例如**1x**、**2x**和**3x**，那么此选项允许您根据您为不同分辨率开发的游戏创建资源。此外，您无需进入图形软件，分别缩小图像并重新打包所有分辨率的图像。

+   **算法**: 这是用于创建精灵图集的代码逻辑，并确保图像以最有效的方式打包。在基本版本中，您必须从下拉菜单中选择**基本**，与专业版本不同，在专业版本中，您可以选择**MaxRects**。

+   **多包**: 如果PNG图像文件超过最大尺寸，则Texture Packer将自动为之前无法包含到精灵图集中的图像创建额外的精灵图集和数据文件。

## 精灵

在这里，我们指定对精灵图集中的单个精灵的任何特殊处理。本节中有一个字段：

+   **裁剪模式**: 移除围绕每个图像的额外透明度，使精灵图集更加紧凑，从而进一步减小文件大小。

# 创建英雄精灵图集

在本章节的`Resources`文件夹中有一个名为`heroAnim`的文件夹。此文件夹包含另一个文件夹，其中包含英雄空闲动画的单独帧。将`heroAnim`文件夹拖放到Texture Packer的左侧面板中。

您将在这里看到`heroAnim`文件夹的文件夹结构。在其下，您将看到`idle`文件夹，其中包含帧的单独文件。在预览窗格中，您将看到从提供的图像创建的精灵图集的预览。

在**布局**部分，点击**缩放变体**按钮。从预设的下拉列表中选择**SpriteKit @2x/@1x**。这将自动创建**2x**和**1x**分辨率的精灵图集，通过将图像缩小50%并保存为**1x**模式。

![创建英雄精灵图集](img/B04014_05_07.jpg)

接下来，在数据标题下，选择您想要保存精灵图集图像和数据文件的存储位置。这些文件将保存在具有`.atlasc`扩展名的文件夹内部的位置，并且这个文件夹将包含图像和数据文件。接下来，选择要保存类文件的位置。您可以将其保存到任何您想要的位置，但请确保您记得保存的位置，因为稍后需要用到它。

还请确保将当前文件保存在某个位置，这样如果您稍后想要对文件进行修改，您将能够轻松地打开它并进行修改。需要注意的是，如果您更改`heroAnim`文件夹的位置，那么引用将会丢失，您将需要重新导入图像。请将图像、精灵图集、类和Texture Packer文件保存在单独的文件夹中，以便所有相关数据都在同一目录下。

最后，要创建精灵图集，请点击顶部的**发布精灵图集**按钮。现在我们可以为英雄动画了。

# 为英雄动画

要在游戏中为英雄动画，将`.atlasc`文件夹和Swift类文件拖入项目。然后，在`init`函数中，在将英雄添加到场景后立即添加以下代码：

[PRE2]

就这样！您可以为游戏构建和运行，以查看英雄的动画效果。

在这里，我们首先创建对在Texture Packer中创建的Swift类的引用。然后，我们创建一个名为`heroIdleArray`的常量，并将`heroAnim.swift`类中已创建的空闲动画数组分配给它。如果没有这个，我们就必须手动创建一个数组并存储帧，就像我们为敌人做的那样。接下来的三个步骤与创建敌人动画的方法完全相同。我们创建一个动画常量，传递数组和我们想要为每个帧设置的延迟，然后创建另一个动作来重复动画，最后运行英雄的动画。

因此，我们看到我们不必创建两套图像，因为Texture Packer为我们创建了它们，而且我们也不必为空闲动画创建数组。如果我们后来需要创建跑步、行走、跳跃或攻击动画，这一点尤为重要。我们不能每次都创建数组。实际上，在其他框架中，如果我们想要创建不同的动画，就需要这样做。使用Texture Packer为SpriteKit创建这个过程要容易得多。

让我们看看Texture Packer创建的Swift类，以便您更好地理解正在发生的事情以及数组是如何创建的。所以，打开`heroAnim.swift`文件：

[PRE3]

在Texture Packer中创建文件时，我将其命名为`heroAnim`，这就是为什么类的名称和我命名的一样。其次，你会注意到我们用来创建精灵图的四个图像分别命名为`hero_idle_1`、`hero_idle_2`、`hero_idle_3`和`hero_idle_4`。因此，在类的开始处，它会自动为这四个文件名创建等于字符串名称的常量。

然后，类创建了一个名为`textureAtlas`的`SKTextureAtlas`常量。这个纹理图集是从`heroAnim.atlasc`文件夹创建的。所以，尽管名称与类的名称相同，但这实际上是精灵图文件；不要混淆。

在获取纹理图集后，创建了四个函数来获取之前定义的常量名称中存储在纹理图集中的四个图像。然后最终创建了一个新函数，该函数将四个图像添加到数组中并返回该数组。这个函数的命名方式与我们命名用于创建动画的图像文件的方式相似。这使得在创建动画动作时知道要调用的函数名称变得方便。还要记住，所有这些都是在Texture Packer中自动完成的。

除了空闲动画之外，如果我们有两个用于跑步周期的图像，分别命名为`heroRun1.png`和`heroRun2.png`，那么将返回`run`数组的函数将被命名为`heroRun()`。记住这个方法的一个简单方式是将任何数字替换为开闭括号以获取函数名和帧数组。

### 小贴士

还有一点很重要：在为创建动画帧所需的图像命名时，确保你为所有帧使用相同的命名约定，就像命名帧的情况一样。例如，在为动画命名帧时，我通常将文件命名为`name_action_number`的形式。它也可以像我们命名跑步动画示例那样，命名为`nameActionNumber`，但请确保你保持一致性。

还很重要的一点是要确保文件的编号顺序是你想要动画播放的顺序。这是因为当播放动画时，首先播放帧1，然后是帧2，然后是帧3，依此类推。如果你的图像编号不正确，动画将按此顺序播放，播放时可能会显得有些奇怪。

这些是你需要注意的唯一事项。如果你在文件命名和编号上保持一致，那么在Texture Packer中正确创建动画将变得非常容易。Texture Packer为你做了大部分脏活，并且没有留下出错的空间，因为它主要为你自动化了这个过程。

现在我们来看看如何在游戏中创建粒子。

# 粒子系统

**粒子系统**是一组精灵或粒子。每个粒子系统都有一个发射器，粒子将从那里产生。粒子系统还决定了系统中粒子的行为。因此，可以说粒子是创建粒子系统的最小实体。

粒子系统的一个非常简单的例子是雨。**雨**是一个粒子系统，其中每一滴雨都是粒子，而云有大量的发射器，从这些发射器中产生水滴或粒子。

我们创建一个粒子系统而不是创建单个粒子，因为使用粒子系统，我们可以使用相同的粒子创建不同类型的特效。例如，我们看到了雨，这是一个粒子系统。如果我们想有另一个效果，比如水从水龙头流出呢？在这里，粒子是相同的——水滴，但雨滴的行为不同。当水从水龙头落下时，每一滴都带有力量落下，并且由单个发射器——水龙头出口——创建。因此，我们可以将粒子系统更改为只有一个发射器，并给粒子一个初始向下的力。这样，我们将有相同的粒子以不同的方式表现，而不是从头开始编码系统。

在 SpriteKit 中，就像在其他任何框架中一样，每个粒子都是一个由粒子系统控制的图像，该粒子系统有一个或多个发射器。**发射器**控制粒子系统的生成、移动和销毁。

为了渲染粒子系统，创建了一个**SpriteKit 粒子文件**（`.sks`）。它可以包含任何大小的粒子系统，并允许整个粒子系统旋转和缩放。

## 设计粒子

SpriteKit 有一个内置的粒子设计器。这个设计器有一个相当不错的用户界面，可以用来创建您自己的粒子系统。SpriteKit 还包括一些默认的粒子系统，这些系统已经内置，可以通过从下拉菜单中选择您想要用于游戏的粒子系统来创建。

要创建一个新的粒子系统，请前往**文件**并选择**新建文件**。您也可以通过在项目的根文件夹上右键单击来创建一个新的文件。在左侧的**iOS**面板中，选择**资源**，然后选择**SpriteKit 粒子文件**，并点击**下一步**。

![设计粒子](img/B04014_05_08.jpg)

现在，从下拉菜单中，您可以从 SpriteKit 内置的八个默认粒子系统中进行选择。您可以从**波纹**、**火焰**、**萤火虫**、**魔法**、**雨**、**烟雾**、**雪**和**火花**中进行选择：

![设计粒子](img/B04014_05_09.jpg)

在这个例子中，我选择了**火焰**。一旦您选择了所需的粒子系统，请点击**下一步**。我们将必须给粒子系统起一个文件名，这样我们就可以在以后创建游戏中的效果时调用它，所以我将其命名为`fireParticle`。

![设计粒子](img/B04014_05_10.jpg)

完成后，你将在项目中看到创建的`fireParticle.sks`文件，编辑面板中的火粒子正在熊熊燃烧。默认情况下，它位于屏幕中央。在编辑面板的任何位置单击，火粒子系统将移动到该位置。你还可以单击并移动鼠标，以查看粒子系统随着鼠标箭头移动。

你还会看到**工具**面板已更改，出现了一堆可更改参数的变量。你可以更改这些参数来创建自己的自定义粒子系统。

让我们逐一了解这些基本参数，以便你可以了解每个变量做什么以及如何通过更改每个参数来改变粒子系统的行为。

![设计粒子](img/B04014_05_11.jpg)

### 名称

如果我们想在代码中通过名称引用粒子系统，我们可以在这里给它一个名称，这样我们就可以稍后引用它。类似于我们给`enemyNode`命名以检查传递给`movingSprite`类的节点是否是敌人，然后根据该信息执行某些功能。

### 背景

**背景**参数设置背景颜色。更改它不会影响粒子。这纯粹是为了可见性。如果你的粒子是黑色的，你可以将背景改为白色，这样你就可以清楚地看到粒子的外观和行为。

### 粒子纹理

**粒子纹理**参数是每个粒子将显示的纹理或图像。目前使用`spark.png`作为纹理。如果你想的话，可以将其更改为敌人、子弹、火箭或英雄图像。

### 粒子

**粒子**参数控制粒子发射的速度以及你希望发射器发射的粒子数量。要控制速度，你可以增加或减少出生率参数。我们可以通过降低出生率来降低发射率，或者如果我们想让粒子更快地发射，我们可以增加它。要限制粒子数量，我们将最大值更改为我们希望发射器发射的粒子数量。如果我们想让发射器持续发射粒子，我们保持该值为0。

### 寿命

当粒子被创建时，**寿命**决定了它在屏幕上停留多长时间后才被删除。在这里，每个粒子在屏幕上停留2.5秒。**范围**用于在粒子的行为中引入一些随机性。假设我们将此范围值更改为1。那么一些粒子将在屏幕上停留2.0秒，而其他粒子将停留3.0秒，然后被删除。因此，创建的随机值是范围值的一半加上初始值。

这就是**范围**的工作原理：它取第一个值，然后通过从它中加上或减去范围值的一半来得到一个值，这样看起来就像每个粒子都有不同的寿命，就像生活中，不是所有粒子都以相同的方式表现。

### 位置范围

默认位置在屏幕中央。通过查看变量名称中的**位置范围**关键字，你可能已经猜到我们输入的值是范围值。在这里，`x`的值是`55.65`，这意味着当一个粒子被生成时，它将在从中心向`x`方向的`-27.825`到`+27.825`之间随机生成。发射点在编辑器视图中用一个小的绿色点表示。`y`的值是`5`，这意味着从中心开始，粒子将在`y`方向的`-2.5`到`+2.5`之间随机生成。如果你将`X`和`Y`的值改为`0`，你会看到所有粒子都从绿色点发射出来。

### 角度

**角度**参数决定了粒子生成的角度。由于我们希望火焰在这种情况下向上移动，所以角度大约是90度。你也可以将其值改为`45`，这样看起来就像有风吹拂着火焰。为了给初始角度添加一些随机性，范围保持在`20`。否则，所有粒子都将直接向上移动，这看起来非常不自然。

### 速度

这是粒子在创建时开始移动的速度。在这里，它们以平均速度100开始移动。有一个范围是50，这意味着一些粒子将以最小速度75移动，而其他粒子将以最大速度125移动。

### 加速度

我们可以在`x`和`y`方向上加速一个粒子，例如，在喷气发动机或彗星的情况下。为了创建这种效果，你必须将`X`位置的范围改为`5`，并将`Y`加速度增加到大约`500`。

![加速度](img/B04014_05_12.jpg)

### Alpha

这定义了每个粒子的不透明度或透明度级别。如果**Alpha**的值为零，则粒子将完全透明，而`1`表示它将完全可见。还有一个你可以指定的**范围**值。**速度**参数决定了每个粒子的**Alpha**值每秒变化的速率。因此，粒子一旦创建就会变得可见，然后在一段时间后，随着**Alpha**值的降低，它变得透明。

### 缩放

与**Alpha**类似，**缩放**值范围从`0`到`1`。在`0`时，图像完全不可见；在`1`时，它恢复到原始大小。因此，在`0.5`时，对象将是原来的一半大小；在`2.0`时，它在`x`和`y`方向上将是原来大小的两倍。在这里，对象的起始值为`0.5`，范围为`0.4`。因此，任何粒子的初始起始大小将在`0.3`和`0.7`之间。由于**速度**为`-0.5`，它将在生成后的一段时间内逐渐变小。

### 旋转

一旦创建了一个粒子，我们可以通过给它一个起始值和范围来生成随机旋转速度，使其旋转。我们还可以通过改变**速度**参数在一段时间内增加或减少旋转速度。

### 颜色混合

颜色混合用于将一种颜色与另一种颜色混合。在这里，初始因子为`1`，**范围**为`0`，所以我们使用分配的原始颜色。由于我们不是进行颜色混合，我们已将**速度**值保持为`0`。我们可以将速度更改为`-0.125`，以看到颜色逐渐混合到白色，颜色在粒子生命周期的末尾变得更浅。

### 颜色渐变

在这里，我们可以指定要生成的粒子的颜色。粒子纹理图像始终保持白色，这样我们就可以在代码中随时更改对象的颜色。所以在这里，尽管纹理或图像颜色是白色，但火焰的颜色是橙色的。

我们还可以在不同的生命周期阶段为粒子分配不同的颜色。

![颜色渐变](img/B04014_05_13.jpg)

其他四个变量——**混合模式**、**场掩码**、**自定义着色器**和**自定义着色器统一变量**——与着色器和着色器编程有关，这超出了本书的范围。使用着色器，你可以为粒子创建自定义效果和行为。

如果你了解其工作原理，可以稍微玩一下**混合模式**，因为它与你在Photoshop中看到的东西非常相似。如果你了解Photoshop，你会熟悉**添加**、**减去**、**乘以**、**屏幕**、**替换**和**Alpha**。你可以选择这些中的每一个，并查看它对粒子系统产生的影响。

现在我们需要的信息已经足够来设计我们自己的游戏粒子系统了。现在，让我们创建我们将要在游戏中使用的粒子系统。

# 创建粒子效果

对于游戏，我们将创建一个非常简单的爆炸粒子系统，并且每次英雄发射火箭时都会显示。我们将使用我们自己的自定义精灵图像。所以，转到该章节的资源文件夹，将`smoke.png`图像拖放到项目中。别忘了将其添加为副本，并确保当前游戏是目标。

现在创建一个新的粒子系统，将文件命名为`explosionParticle`，并将其保存到你的项目中。你可以使用火焰、烟雾或任何默认的粒子系统。这无关紧要，因为我们无论如何都会更改这些值以符合我们的规格。

![创建粒子效果](img/B04014_05_14.jpg)

在前面的截图上，你可以看到我使用默认粒子作为基础创建的粒子系统的参数。

我将其命名为`explosionParticle`以防我需要在代码中引用粒子系统。然后我将背景保持为默认设置，因为我仍然能够清楚地看到粒子。

我将纹理更改为之前导入的烟雾图像文件，并用它替换了默认图像。对于**出生率**，我将其值保持在约`65`；你可以根据你的需求进行更改。我将粒子数的最大值保持在`12`，这样在创建了12个粒子后，发射器将停止创建任何新的粒子。

**寿命**参数保持在约`8`，**范围**保持在约`16`。你可能会说有些粒子可能一创建就被销毁。好吧，这是真的，而且这同样适用于烟雾粒子。当枪被发射时，有些烟雾中的粒子我们甚至看不到，所以即使看起来像卡通，行为也会更真实。

**位置范围**参数在`x`方向上约为`4`，在`y`方向上约为`9`。这只是为了在指定的初始位置周围随机创建粒子，这样所有的粒子看起来就不会像是从同一个点出现的。

**角度**参数保持在`0`到`360`之间，因为我们希望烟雾粒子在它们被创建的点周围的所有方向移动。

每个粒子在开始时的**速度**参数保持在约`48`，**范围**约为`90`。这将使得一些粒子移动较慢，而其他粒子则移动得很快。事实上，一些粒子可能根本不会移动或移动得非常慢，从而使行为再次更真实。

**加速度**参数在**X**和**Y**方向上均保持在`0`，因为这不必要，但你也可以调整这些值来看看你是否喜欢效果。

由于我们希望烟雾粒子缓慢消失，我们赋予一个初始值和范围，并通过逐渐增加**速度**参数到`-1`来缓慢减少alpha值。由于图像的大小非常大，我将它缩放到`0.25`以使其更小，并赋予一个范围，使得大小是随机的。我将速度值更改为`-0.125`，这样每个粒子的尺寸就会在一段时间内缓慢减小。

粒子一旦被创建就需要旋转，所以我给它赋予了一个初始值和**范围**。我将**速度**参数增加，使得粒子在一段时间内旋转得更快。

由于我没有进行颜色混合，我将因子保持在`1`，范围和速度在`0`。我将粒子的颜色改为浅蓝色，使其看起来更卡通化。黑色可能会显得有点太暗，更真实。

最后，我将**混合模式**更改为**Alpha**，因为我不想使用加法混合模式。您可以对您的粒子文件进行必要的更改，然后按*command* + *S*保存文件。

# 将粒子系统添加到游戏中

粒子系统文件现在已准备好被调用到游戏中。因此，打开`GameplayScene.swift`文件，在`addRocket`函数中，在我们将火箭添加到场景后立即添加以下代码：

[PRE4]

在这里，我们创建了一个名为`explosionParticle`的新常量，其类型为`SKEmitterNode`，并传递我们之前创建的粒子系统的文件名。每次您想要创建粒子系统时，都必须使用`SKEmitterNode`。

接下来，我们将粒子系统放置在英雄火箭筒的喷嘴处。这与我们放置英雄火箭的方式类似。最后，我们将粒子添加到场景中。

我们不必担心移除每个粒子，因为粒子系统会自动处理这一点。当每个粒子达到其生命周期的末端时，它会自动从场景中移除。

现在，您可以构建并运行游戏，但您会发现粒子系统创建粒子需要一点时间。为了使其看起来像是瞬间创建的，我们在将粒子添加到场景后，将以下突出显示的代码添加进去：

[PRE5]

这行代码将模拟快速推进到粒子创建后的0.25秒，看起来就像粒子是瞬间被创建出来的。再次构建并运行游戏，以查看粒子的效果。

![将粒子系统添加到游戏中](img/B04014_05_15.jpg)

粒子设计师中还有一些额外的参数和属性，例如`advanceSimuationTime`，只能在代码中调用和修改。但最好通过设计师设计大部分粒子，然后在将其添加到场景后通过代码进行微调。

现在，如果您愿意，可以使用代码创建粒子系统，并通过代码单独定义参数，如下面的代码片段所示，这将产生相同的结果：

[PRE6]

这些确实是相同的变量和参数。唯一的区别是这里它是代码格式。显然，使用设计师创建粒子更方便。

在苹果开发者门户中，有一些额外的命令可用于粒子系统，方便您使用。如果您感兴趣，可以查看并尝试一下。

# 摘要

在本章中，我们学习了如何使用动作和精灵表来创建游戏中的动画。我们查看了SpriteKit内置的精灵表生成器，并使用了一个名为Texture Packer的专业工具来创建精灵表。我们还看到了使用这个专业工具生成精灵表和动画是多么容易。

除了这些，我们还看到了SpriteKit粒子设计器的介绍，并在游戏中创建并实现了粒子系统。

然而，游戏中仍然缺少一些东西，那就是音效和字体定制。我们将在下一章中探讨这个问题，包括如何为游戏添加最后的修饰。
