- en: Setting Up the Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the introduction about system programming in the last chapter, we need
    to set up a development environment first before we can go further. We need to
    know how to build and test **Android Open Source Project** (**AOSP**) while we
    explore various Android system programming topics in this book. We will cover
    the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Android SDK and setting up an Android Virtual Device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the AOSP build environment and building a testing image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own source code repository mirror
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary of Android versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will use Android emulator as one of the virtual hardware platforms,
    we need to use one particular Android version throughout this book. At the time
    of writing, the latest Android version is Android 7 (Nougat). We will use Android
    7 throughout the book. I started work on this book with Android 6, so the source
    code for Android 6 is also available in my GitHub repository at [https://github.com/shugaoye](https://github.com/shugaoye).
  prefs: []
  type: TYPE_NORMAL
- en: From the first release to Android 7, both the development environment and the
    AOSP source code have been changed a lot. We will have a brief look at various
    Android versions first before we talk about the development environment setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the AOSP build environment, there are two things that you need to
    pay special attention to the host environment and Java SDK. Even though the recommended
    host environment is Ubuntu running on Intel architecture, the hardware architecture
    and Ubuntu versions have changed from release to release. You can always refer
    to the following URL at Google for the latest AOSP build environment setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://source.android.com/source/index.html](https://source.android.com/source/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: For Gingerbread (2.3.x) and above, a 64-bit build environment is required. For
    older versions, the build environment is 32-bit systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Ubuntu versions used range from Ubuntu 10.04 to 14.04, but for each release
    there is a recommended Ubuntu version. If it is a new setup, it is suggested to
    use the recommended Ubuntu version to make the job easier. However, there are
    no hard requirements here. You should be able to use any Ubuntu version higher
    than the recommended Ubuntu version. There are also many articles about how to
    set up the AOSP build using a different Linux distribution such as RedHat or Debain.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle JDK was used to build AOSP until Lollipop. From Lollipop and the above,
    OpenJDK was used instead of Oracle JDK.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes all Android releases, required hosts, and JDK
    environments until Nougat; you can refer to it for full details.
  prefs: []
  type: TYPE_NORMAL
- en: '**AOSP releases**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Nickname** | **AOSP** | **SDK API level** | **Host** | **JDK** | **OS/Ubuntu**
    | **Goldfish** | **Ranchu** |'
  prefs: []
  type: TYPE_TB
- en: '| Cupcake | 1.5 | 3 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Donut | 1.6 | 4 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Eclair | 2.0/2.1 | 5 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Eclair | 2.0.1 | 6 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Eclair | 2.1 | 7 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Froyo | 2.2 | 8 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Gingerbread | 2.3.1 | 9 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Gingerbread | 2.3.3 | 10 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Honeycomb | 3.0 | 11 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Honeycomb | 3.1 | 12 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Honeycomb | 3.2 | 13 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Ice Cream Sandwich | 4.0 | 14 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Ice Cream Sandwich | 4.0.3 | 15 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Jelly Bean | 4.1.2 | 16 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Jelly Bean | 4.2.2 | 17 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| Jelly Bean | 4.3.1 | 18 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  prefs: []
  type: TYPE_TB
- en: '| KitKat | 4.4.2 | 19 | x64 | Oracle JDK 6 | 12.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| KitKat | 4.4W.2 | 20 | x64 | Oracle JDK 6 | 12.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| Lollipop | 5.0.1 | 21 | x64 | Open JDK 7 | 12.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| Lollipop | 5.1.1 | 22 | x64 | Open JDK 7 | 12.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| Mashmallow | 6.0 | 23 | x64 | Open JDK 7 | 14.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| Nougat | 7.0.x | 24 | x64 | Open JDK 8 | 14.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| Nougat | 7.1.1 | 25 | x64 | Open JDK 8 | 14.04 | x | x |'
  prefs: []
  type: TYPE_TB
- en: From the preceding table, you can see that the ranchu emulator is supported
    by KitKat and the others. If you install and download the system image of Kitkat
    or the others on Android SDK, you should be able to find two kernel files, `kernel-qemu`
    and `kernel-ranchu`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two API levels in the Nougat releases. Android 7.0.0 and 7.1.0 are
    API level 24\. Android 7.1.1 and 7.1.2 are API level 25\. All source code in this
    book can support up to API level 25.
  prefs: []
  type: TYPE_NORMAL
- en: The code name of the original Android emulator is goldfish. It is based on an
    older version of QEMU. A new Android emulator version was released based on QEMU
    2.x in 2016\. The code name of this new emulator is ranchu. It is supported by
    KitKat and the others.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android SDK and setting up an Android Virtual Device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, if you have an AOSP build environment, you can build everything including
    Android SDK from scratch. However, it is much more convenient to have an Android
    SDK installation to help with virtual device creation or running emulator images.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always download the latest Android SDK from the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/index.html](https://developer.android.com/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The host environment that we use in this book is Ubuntu 14.04\. Download the
    Android SDK for Linux and decompress it to a folder in your `Home` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The tools in Android SDK have been changed since API level 25\. You may use
    an older version of Android SDK or the latest Android SDK so I gave the instructions
    for both cases here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AVD in an older version of SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the older version of SDK, such as `android-sdk_r24.4.1-linux.tgz`, it includes
    all necessary components and we can use it after decompression. We can find the
    following contents after decompressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can add the `platform-tools` and `tools` directory to your `PATH` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a virtual device based on API level 25 in this book to test our
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a virtual device, we can launch **Android Virtual Device** (**AVD**)
    Manager using the following command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/image_02_001.png)'
  prefs: []
  type: TYPE_IMG
- en: AVD Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the Create... button in AVD Manager and create a new virtual device named
    `a25x86` with the following configuration, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Android 7.1.1 - API level 25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1024 MB RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 400 MB SD card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 400 MB internal storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Display size at 480 x 800: hdpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_02_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Android Virtual Device a25x86
  prefs: []
  type: TYPE_NORMAL
- en: Creating AVD in the latest version of SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the newer versions, there is only SDK command-line tools available for
    download. For example, if you download the command-line tools for r25, such as
    `tools_r25.2.3-linux.zip`, you can find the `tools` folder only. In this case,
    you need to use Android SDK Manager at `tools/bin/sdkmanager` to download the
    rest of SDK components. To download the rest of SDK components, you can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the latest version of Android SDK, you may get the following error
    message, if you follow the previous instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you can create AVD using the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Testing the goldfish emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android 7, both the ranchu and goldfish emulators are supported. Let''s
    test the goldfish emulator first. We can run this virtual device in the goldfish
    emulator using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To monitor the status of a virtual device, we can use the following Android
    emulator options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-verbose`: Shows the emulator debug information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-show-kernel`: Shows kernel debug information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-shell`: Uses `stdio` as the command line prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-engine`: Selects the emulator engine. The choice can be `auto`, `classic`,
    or `qemu2`. The `classic` option is to use the goldfish emulator and the `qemu2`
    option is to use the ranchu emulator. If the option is `auto` or without the `engine`
    option, the system will check the environment and try to launch ranchu first.
    If it fails, it will fall back to goldfish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding log, we can see that the `kernel-qemu` kernel file is used
    for the goldfish emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Both the ranchu and goldfish emulators are developed on top of QEMU, but they
    use different kernel and QEMU versions. We can verify the QEMU version used for
    either goldfish or ranchu using the following emulator commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the QEMU version used by goldfish, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that QEMU version 0.10.50 is used for
    the goldfish emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the latest emulator version, it seems there is a bug with regard to handling
    the classic engine. You may get the following error message, when you execute
    the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The emulator command is a wrapper for QEMU. Any command-line options after `-qemu`
    are passed to QEMU as the command lines of QEMU directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the emulator version, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ emulator -version**` The following command will show the QEMU version:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ emulator -qemu -version**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Android device has started successfully, from the Android UI, we
    can go to Settings -> About Phone and see the screen shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Android kernel version of goldfish
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the following information on the About Phone screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android version: 7.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel version: 3.4.67'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build number: sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see from the preceding information, the kernel version is `3.4.67`
    and the filesystem build number is `sdk_google_phone_x86-userdebug 7.1 NPF26K
    3479480 test-keys` for goldfish emulator. In the next section, we can see that
    ranchu emulator uses a different kernel version, even though both emulators share
    the same filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android system build includes two parts: the AOSP system and an Android-compatible
    Linux kernel. The build result of the AOSP system includes all image files for
    the Android system except the kernel image. They are built separately and are
    also under difference licenses. The preferred license for the AOSP is the Apache
    Software License, while the Linux kernel is under the GPLv2 License. Be aware
    of this difference. It also means that the AOSP build doesn''t include the kernel
    build. We have to build the kernel separately. We can also use different kernel
    images with the same filesystem as in the test of the goldfish and ranchu emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about the Android version, we have to look into the details of
    the kernel version and filesystem build number.
  prefs: []
  type: TYPE_NORMAL
- en: Testing ranchu emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test ranchu emulator as well with the same virtual device. We can use
    a similar command without the `-engine` option or with the `-engine qemu2` option
    to start ranchu emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding log, we can see that the kernel file `kernel-ranchu` is used
    in ranchu emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also verify the QEMU version used by ranchu emulator using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that ranchu uses a much newer QEMU version that can support many
    new features, which we will discuss later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s review the version information in Settings as we did for goldfish
    emulator; refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Android kernel version of ranchu
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the ranchu emulator uses the kernel version 3.10.0, which is
    different from the goldfish emulator. The filesystem build is the same as for
    the goldfish emulator.
  prefs: []
  type: TYPE_NORMAL
- en: The AOSP build environment and the Android emulator build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create our own Android system, we have to set up the AOSP build
    environment and build our own AOSP target for the Android emulator. Since Android
    is under rapid development, the build process and environment setup can change
    from time to time. You can always refer to Google's website for the latest information,
    [https://source.android.com/source/building.html](https://source.android.com/source/building.html).
  prefs: []
  type: TYPE_NORMAL
- en: While the Google website and other sources can give general guidelines and procedures
    about the AOSP build, in this section we will look specifically at how to build
    AOSP for Android emulator image for API level 25.
  prefs: []
  type: TYPE_NORMAL
- en: The AOSP build environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we want to set up a build environment for API level 25, you can refer
    to the table of AOSP releases for the basic requirements about the host and JDK.
    It is recommended to use the Ubuntu 14.04 64-bit host with Open JDK 8\. For the
    hardware requirement, you may want to have a powerful enough computer with at
    least 8 GB RAM and 500 GB hard disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the Ubuntu 14.04 64-bit version as our host operating system. After
    installing Ubuntu 14.04, the first thing you have to do is to install all necessary
    software packages as follows. If you use a different Linux distribution, you can
    refer to Google''s website or search on the Internet for the relevant setup procedures.
    Let''s execute the following commands to install all necessary packages for Ubuntu
    14.04:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Installing Open JDK 7 and 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will install both Open JDK 7 and 8 so we can build both Android 6 and 7 in
    our build environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build Android API level 23, we need to install OpenJDK 7\. We can execute
    the following commands from the Linux console to install OpenJDK 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For Android 7, we need to use OpenJDK 8 to build. There are no available supported
    OpenJDK 8 packages for Ubuntu 14.04 yet, but the Ubuntu 15.04 OpenJDK 8 packages
    have been used successfully with Ubuntu 14.04\. We need to install OpenJDK 8 on
    Ubuntu 14.04 using the following instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `.deb` packages for 64-bit architecture from [archive.ubuntu.com](http://archive.ubuntu.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Optionally, confirm the checksums of the downloaded files against the SHA256
    string listed with each preceding package.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with the *sha256sum* tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `dpkg` for each of the `.deb` files you downloaded. It may produce errors
    due to missing dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix missing dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With both OpenJDK 7 and 8 installed, we can update the default Java version
    by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have a build environment ready now. You may want to refer to Google's website
    to set up other things. For example, we may want to use cache to speed up the
    build or set up a separate output directory out of the AOSP tree.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the AOSP source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a build environment ready, we need to get the AOSP source code.
    Again, refer to Google's website or the Internet to get more information.
  prefs: []
  type: TYPE_NORMAL
- en: You need to download the Android 7 source code from [source.android.com](https://source.android.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing repo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AOSP consists of a large number of Git repositories, and we have to use the
    repo tool to manage these Git repositories. To download and install repo, we can
    use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Initializing a repo client and downloading the AOSP source tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have the repo tool, we can initialize the repo and download the AOSP
    source tree by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the AOSP tag `android-7.1.1_r4` here. This is the version of
    AOSP source code that we use throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take quite a long time to get the AOSP source tree. After we get the
    source tree, let''s take a look at the top level folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I won't explore the details about the source tree here; we will cover this in
    [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml), *Discovering Kernel,
    HAL, and Virtual Hardware*.
  prefs: []
  type: TYPE_NORMAL
- en: Building AOSP Android emulator images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we will use x86-based emulators. The x86-based emulator can use
    virtualization technology on the host, so it is much faster than the ARM emulator.
    We want to build the one that comes with the AOSP source code first. To create
    an Android emulator build, we can execute the following commands from the AOSP
    top-level folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We set up the environment variables first using the startup script `envsetup.sh`.
    After that, we execute the command `lunch` to choose a build target. To build
    for the Android-x86 emulator, we can choose the target `aosp_x86-eng`, which will
    build an Android emulator version for x86\. To learn more about the script file
    `envsetup.sh` and command `lunch`, refer to the Google website at [https://source.android.com](https://source.android.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual build is started after we execute the following `make` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The entire build time is dependent on your hardware configuration. Even on a
    high-end CORE i7 Intel processor, it may take about 40 minutes. The option `-j4`
    starts the parallel build using four processor cores. You can choose the number
    according to your computer hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Testing AOSP images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the build is completed, we find all images in the output folder, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Build output of generic_x86
  prefs: []
  type: TYPE_NORMAL
- en: The AOSP build output is stored under the `$AOSP/out` folder. This folder includes
    the build results for both target and host. The build results for different devices
    are stored separately at `$AOSP/out/target/product/{device name}`. In our case,
    it is `$AOSP/out/target/product/generic_x86`.
  prefs: []
  type: TYPE_NORMAL
- en: The images `system.img`, `userdata.img`, and `ramdisk.img` are necessary to
    run the emulator, but as you can see there is no kernel image. We will discuss
    kernel builds later in this book. For now, we will use the kernel image from Android
    SDK to test our AOSP build.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test using our AOSP images, we can create a script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put this script `test_aosp.sh` in the `$HOME/bin` folder. Usually, we
    can add `$HOME/bin` to the executable search `path` variable so that we can run
    this script `test_aosp.sh` from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you test your AOSP build using Android 6 or earlier, you need to use classic
    engines instead of ranchu. The ranchu build has a problem in the Android 6 AOSP
    build, but this issue has been fixed in the Android 7 build. To support ranchu
    in the 6.0.1 AOSP build, we have to change the manifest to include the latest
    emulator device. The Android SDK release doesn't have this issue. Google fixed
    this issue internally, but didn't publish the fixes until Android 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the emulator starts, we can check the version information as we did before.
    In the following screenshot, we can see the version information in AOSP images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Android version of AOSP image
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, kernel version 3.10.0 is used; this is because we use the ranchu
    emulator. Let's compare the information with SDK images that we tested before.
    From the following table, we can see that the model number is AOSP on IA Emulator
    instead of sdk. The Android version is 7.1 for SDK and 7.1.1 for AOSP. The AOSP
    image build number is the build target `aosp_x86-eng`, which we chose previously,
    and this also includes the date and time of the build.
  prefs: []
  type: TYPE_NORMAL
- en: '**SDK and AOSP versions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **SDK (goldfish)** | **SDK (ranchu)** | **AOSP** |'
  prefs: []
  type: TYPE_TB
- en: '| Model | sdk | sdk | AOSP on IA Emulator |'
  prefs: []
  type: TYPE_TB
- en: '| Android version | 7.1 | 7.1 | 7.1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel version | 3.4.67 | 3.10.0 | 3.10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Build number | sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys
    | sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys | aosp_x86-eng 7.1.1
    NMF26O eng.sgye 20170126.183237 test-keys |'
  prefs: []
  type: TYPE_TB
- en: Creating your own repository mirror
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It usually takes a very long time to download the AOSP source code. After you
    have downloaded the AOSP source code, you have actually downloaded a specific
    version of the AOSP source code from the remote repository. You may have to test
    different configurations or versions in your development work. It is a very time-consuming
    task to switch to a different version or create a new copy of the AOSP source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the AOSP source code as the base for our development.
    To reuse some of the existing open source projects that are not included in AOSP,
    we have to modify the repo manifest from time to time. This involves changing
    the repo configuration. To work more efficiently, we can use a local mirror. It
    can save a lot of time to create a local mirror instead of downloading source
    code from remote repositories for all configuration changes. It may take hours
    to change a configuration from a remote repository, but it will need just a few
    minutes with the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with open source projects, the server to host the project may change
    from time to time. It is always good to have your own mirror so that we won't
    rely too much on the remote repositories. With a local mirror, we can still work
    without too much impact even though the remote server may be not available for
    a certain period. This is exactly the issue that I face when I try to integrate
    Android-x86 projects in the later part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: I will explain how to create a mixed local mirror of AOSP, Android-x86, and
    GitHub in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Repo and manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create and manage repository mirrors, we need to understand the `repo` command
    and the directory structure managed by `repo` a little more. The `repo` command
    deals with a XML file manifest and it stores everything in a folder called `.repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we run the `repo init` command as we did in the previous section, a `.repo`
    folder is created under the current folder. If we take a look at the `.repo` folder,
    we can see the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Three folders and a symbolic link are created. The following is an explanation
    of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`manifests`: This is a working copy of the Git repository of the manifest itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests.git`: This is the Git repository of the manifest. The manifest itself
    is under the version control using Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifest.xml`: This is a symbolic link to the file `.repo/manifests/default.xml`.
    This file is the main configuration file used by `repo`. We will look into the
    details later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repo`: The repo tool itself is written in the Python language. Python scripts
    are stored in this folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we run the `repo init` command to initialize the repo data structure,
    we can run the `repo sync` command to retrieve a working copy. If we look at the
    `.repo` folder again after the `repo sync` command, we can see that there are
    two project related folders created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an explanation of the newly created file and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`project.list`: This is a list of all projects downloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project-objects`: This is a copy of the remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projects`: This is the repository hierarchy matching the working copy. The
    path may be rearranged after a repository is copied to local. The contents in
    this folder are symbolic links to the items in `project-objects`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important file in the `.repo` folder is `.repo/manifests/default.xml`
    or its symbolic link `manifest.xml`. The detailed specification of this file can
    be found in the document under the `.repo` folder at `.repo/repo/docs/manifest-format.txt`.
    We won't go into any details, but let's take look at the most commonly used elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we can see that there are three XML elements
    inside manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remote`: The `remote` element provides the details about remote repository.
    We can give it a name such as `aosp`. The URL of the remote repository can be
    specified in the `fetch` field. It can be a relative path or a full path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: There are multiple `remote` elements that can be specified in manifest.
    The `default` element defines which `remote` is the default one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project`: Each `project` element defines a Git repository. The `path` field
    supplies the local path after it is downloaded. The `name` field supplies the
    remote path of the Git repository. The `revision` field supplies the branch that
    we want to get and the `remote` field tells us which remote server we use to get
    the Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other XML elements that can be used in manifest as well. You can find
    out what they are by looking at the preceding specification yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Using a local mirror for AOSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you refer to the article from the Google website about downloading the source,
    you can find a section called *Using a local mirror*. It reveals that if you need
    two different configurations of the AOSP build environment, the download for two
    clients is larger than the size of a full mirror of the repository. It is very
    simple to set up a mirror as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding commands, we can see that we actually use a different manifest
    to create a mirror. If we look at the content of the manifest for a mirror, we
    can see the following XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can see that for all projects, there are only the project names without other
    information in each project item. This is because we actually copy each Git repository
    to the local as a bare Git repository. We won't check out a working copy, so we
    don't need to worry about the version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the manifest to check out a working copy, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It includes more items than the one to create a mirror. The `name` field specifies
    the path at the remote repository and the `path` field specifies the local path
    after the repository is downloaded to the local. We also need to specify `revision`
    that we want to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have a mirror, we can check out a copy of the AOSP source from that
    mirror as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you need, you can check out multiple copies from the local mirror. No matter
    if you check out multiple copies or you change to a different version, you can
    save a lot of time compared to checking out from a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: When you work on a system-level project, you may need projects out of the AOSP
    source. For example, in this book, we use multiple projects from CyanogenMod,
    Android-x86, and my own projects in GitHub. In this case, we can actually create
    our own manifest to mix all projects that we need together from our local mirror.
    Our local mirror will become a superset of the public mirror. We can create branches
    and tags from time to time in local repositories, but we only push the baselines
    that we want to release to the public repositories. This is exactly what the Google
    development team does in their private repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own mirror of GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All source code used in this book is stored in GitHub. We also use source from
    other projects in GitHub, because many open source projects are hosted on GitHub,
    such as CyanogenMod, OmniROM, Team Win Recovery, and so on. We can create a mirror
    for all projects that we have used in local storage so that we can commit any
    changes and create our own baselines. If you want to make changes to any projects
    that are not owned by yourself, you can create your own copy using the Fork function
    of GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own manifest for GitHub, you can create a repository in GitHub,
    call it `mirror`, and then add an XML file called `default.xml` to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding `default.xml`, we can see that we actually fetch multiple
    projects from CyanogenMod, TWRP, OmniROM, and our own GitHub repositories using
    a single XML file. We put all of them together to form our own GitHub local mirror.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the local mirror, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the local mirror, we can check what we have downloaded
    via the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Content of the local mirror
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that all Git repositories that we
    specified in `default.xml` are copied to our local storage. The manifest file
    for the local mirror that I use in this book can be found at [https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Git repositories outside GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see from the preceding example, we created our manifest repository
    for the GitHub mirror. After that, we use it to initialize our mirror repo. Then
    we use the `repo sync` command to fetch all Git repositories from GitHub to our
    local mirror.
  prefs: []
  type: TYPE_NORMAL
- en: How about repositories that we don't have write access to? In this book, we
    use a lot of projects from Android-x86\. However, we don't have write permission
    to Android-x86 repositories. The Android-x86 project also doesn't have a mirror
    manifest available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually create a mirror manifest file from the original Android-x86
    manifest. We can refer to the document at the following link for how to get Android-x86
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.android-x86.org/getsourcecode](http://www.android-x86.org/getsourcecode)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous document mentioned that we can use the following command to initialize
    and sync repo from the Android-x86 repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can clone the preceding Android-x86 manifest repository to a folder and
    analyze it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After we clone it, we can find the preceding two files. `default.xml` is used
    to initialize the Android-x86 repo and `cm.xml` is used to initialize Android-x86
    for the CyanogenMod build.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the content of `default.xml`, we can see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Android-x86 manifest includes two parts. The first part
    is Android-x86, its own repositories, and the rest are the original AOSP repositories.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the first part and compose a mirror manifest for Android-x86\.
    Where should we put this file? We can put it in a branch of the same mirror manifest
    repository in our GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the working copy of our GitHub mirror repository, we can create a branch
    called `android-x86`. We can replace `default.xml` in our GitHub mirror with the
    first part in Android-x86 manifest and we get the one in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding listing, we removed unnecessary fields such
    as `path` or `groups`, and so on. With this manifest for the Android-x86 mirror,
    we can create a local mirror for Android-x86 now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After we download all Git repositories, we can see the content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_008.png)'
  prefs: []
  type: TYPE_IMG
- en: Local mirror of android-x86
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own manifest for client download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all local mirrors, we can create our own manifest to check out our source
    code now. We can put it in our GitHub in a new repository called `manifests`.
    In this repository, we can create an XML file, `default.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding listing, this is a manifest modified based on the AOSP release
    `android-7.1.1_r4` manifest. In this file, we combined multiple projects from
    AOSP, Android-x86, TWRP, and our own GitHub projects into one. Usually, we have
    to do this using `local_manifests` to fetch all non-AOSP projects into our local
    copy. This approach usually takes a very long time and it is difficult to create
    baselines for our own configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The `local_manifests` file can be used to overwrite the configuration of the
    manifest file temporarily. You can refer to *Appendix B* of *Embedded Programming
    with Android* to find out more details.
  prefs: []
  type: TYPE_NORMAL
- en: With a local mirror and our own manifest, we can find a clean way to do this.
    When you have one copy for AOSP and one copy for Android-x86, you have a lot of
    duplicated projects in your storage because Android-x86 manifests include many
    original projects from AOSP. With the preceding setup, there are no duplicated
    projects in your local mirror.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out a working copy, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to check out a build of Android-x86, it becomes a different configuration
    instead of a totally different repository now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we have our own local mirror, we can use the `sync-c="true"` option in
    the manifest, as we can see in the previous listing. With this option, the `repo`
    command will only check out the version we need in our working copy instead of
    creating the Git repositories with all revisions. This can save a lot of space
    for the working copy. However, this is not recommended without a local mirror,
    because it will take even longer when you switch to a different version.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the manifest to check out a working copy at my GitHub [https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests).
  prefs: []
  type: TYPE_NORMAL
- en: We will use this to manage all different build configurations in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'I introduced two kinds of manifest files here:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a local mirror, you can refer to the manifest file at [https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check out a working copy, you can refer to the manifest file at [https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up the environment for SDK and AOSP. We built the Android
    emulator images for AOSP. We also tested and compared the Android images in Android
    SDK and AOSP. All these steps are necessary before we continue exploring how to
    create our own Android system later. We also spent some time discussing how to
    set up our own repo mirror. This tip can help us later, when we start to create
    projects from multiple open source projects. In the next chapter, we will start
    to explore the architecture of Android. We will look into the details of layers
    related to the porting and customization of the Android system.
  prefs: []
  type: TYPE_NORMAL
