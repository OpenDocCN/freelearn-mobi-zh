<html><head></head><body>
  <div><h1 class="chapterNumber">15</h1>
    <h1 id="_idParaDest-251" class="chapterTitle">Advanced and Custom Operators</h1>
    <p class="normal">When I started learning how to program computers, one of the first things I learned was how to use operators. These include basic operators like assignment and arithmetic operators, which were covered in <em class="chapterRef">Chapter 3</em>, <em class="italic">Learning about Variables, Constants, Strings, and Operators</em>. It wasn't until much later, when I learned how to program in the C language, that I learned about advanced operators such as bitwise operators. While the advanced operators are not as popular as the basic operators, they can be very powerful when used correctly. Advanced operators are especially useful if you are planning on writing applications that use low-level C-based libraries.</p>
    <p class="normal">In this chapter, you will learn:</p>
    <ul>
      <li class="bullet">How to use bitwise operators</li>
      <li class="bullet">What overflow operators are for</li>
      <li class="bullet">How to write operator methods</li>
      <li class="bullet">How to create your own custom operator</li>
    </ul>
    <p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">Learning about Variables, Constants, Strings, and Operators</em>, we looked at the most common operators, like assignment, comparison, and arithmetic operators. While these operators are used in virtually every useful application, there are some additional operators that aren't used as often but can be very powerful when you know how to use them. We will look at some of these more advanced operators in this chapter, starting with bitwise operators, but first, we need to understand what bits and bytes are.</p>
    <h1 id="_idParaDest-252" class="title">Bits and bytes</h1>
    <p class="normal">A computer thinks in terms of binary digits. These digits are <a id="_idIndexMarker598"/>called <strong class="keyword">bits</strong> and can have only two values: <em class="italic">0</em> or <em class="italic">1</em>, which represent <em class="italic">on</em> or <em class="italic">off</em> in electrical terms. Bits are very small and have limited usefulness on their own outside of using them for true/false flags. They are grouped together into groups of 4, 8, 16, 32, or 64 to form data that a computer can use.</p>
    <p class="normal">A <strong class="keyword">byte</strong> in computer <a id="_idIndexMarker599"/>terms is a group of 8 bits. If we think in terms of a byte, the number 42 is represented like this, where the least significant bit is to the right and the most significant bit is to the left:</p>
    <figure class="mediaobject"><img src="img/B16683_15_01.png" alt="A screen shot of a clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.1: The number 42 represented in bits</p>
    <p class="normal">The top row in <em class="italic">Figure 15.1</em> shows the value, on or off, of each bit for an 8-bit byte that equals the number <strong class="keyword">42</strong>. The second row shows you the value represented by each bit in the byte. We can see that for the number <strong class="keyword">42</strong>, the bits for the values of <strong class="keyword">32</strong>, <strong class="keyword">8</strong>, and <strong class="keyword">2</strong> are set. We can then add up those values and see that they equal 42: 32+8+2 = 42. This means that the value of the 8-bit byte is 42.</p>
    <p class="normal">By default, Swift uses 64-bit numbers; as an example, the standard <code class="Code-In-Text--PACKT-">Int</code> type is 64 bits. In this chapter we will mostly use the <code class="Code-In-Text--PACKT-">UInt8</code> type, which is an unsigned integer that has only 8 bits or 1 byte. Keep in mind that the 64-bit types store bits in the same way as a byte; they just contain more bits.</p>
    <p class="normal">In the previous example, the least significant bit is to the right while the most significant is to the left. This is the way that bits are usually represented when shown in diagrams. However, in real-world computer architectures, the bits may be stored in memory, where either the most significant bit or the least significant bit is stored in the lowest memory address. Let's take a look at what this means.</p>
    <h1 id="_idParaDest-253" class="title">Endianness</h1>
    <p class="normal">In computer terms, the <strong class="keyword">endianness</strong> of an <a id="_idIndexMarker600"/>architecture is the order in which bits are stored in the memory. Endianness is expressed as big-endian or little-endian. In an architecture that is considered little-endian, the least significant bit is stored in the lowest memory address, while in architectures that are considered big-endian, the most significant bit is stored in the lowest memory address.</p>
    <p class="normal">When working with the Swift standard library, and for the most part when working solely within the Swift language itself, you do not need to worry about how the bits are stored. If you need to work with low-level C libraries, across multiple architectures, then you may need to understand how information is stored within the system because you may be dealing with pointers to memory locations.</p>
    <p class="normal">For the times when you need to worry about the endianness of the architecture, like when we need to interact with low-level C libraries, Swift does have built-in instance properties for integers named <code class="Code-In-Text--PACKT-">littleEndian</code> and <code class="Code-In-Text--PACKT-">bigEndian</code>. The following example shows how to use these properties:</p>
    <pre class="programlisting code"><code class="hljs-code">let en = 42
en.littleEndian
en.bigEndian
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">en.littleEndian</code> line would return the little-endian representation of the number 42, while the <code class="Code-In-Text--PACKT-">en.bigEndian</code> line would return the big-endian representation of the number 42.</p>
    <p class="normal">The endianness of both Intel processors and Apple's own A processors is little-endian; therefore, in this chapter, we will assume that everything is little-endian.</p>
    <p class="normal">Let's look at what bitwise operators are and how we can use them.</p>
    <h1 id="_idParaDest-254" class="title">Bitwise operators</h1>
    <p class="normal"><strong class="keyword">Bitwise operators</strong> enable us <a id="_idIndexMarker601"/>to manipulate the individual bits of a value. One of the advantages of bitwise operators is that they are directly supported by the processor and so can be significantly faster than basic arithmetic operations like multiplication and division. We will see how to do basic multiplication and division using bitwise shift operators later in this chapter.</p>
    <p class="normal">Before we look at what we can do with bitwise operators, we will need to have the ability to show the binary representation of our variables in order to see what the operators are doing. Let's take a look at a couple of ways that we can do this.</p>
    <h2 id="_idParaDest-255" class="title">Printing binary numbers</h2>
    <p class="normal">Apple provides us with a generic initializer for the <code class="Code-In-Text--PACKT-">String</code> type that will provide us with the string representation <a id="_idIndexMarker602"/>of a given value. This initializer is <code class="Code-In-Text--PACKT-">init(_:radix:uppercase:)</code>. By default <code class="Code-In-Text--PACKT-">uppercase</code> is set to <code class="Code-In-Text--PACKT-">false</code> and <code class="Code-In-Text--PACKT-">radix</code> is set to <code class="Code-In-Text--PACKT-">10</code>. The <code class="Code-In-Text--PACKT-">radix</code> defines the number base that will be displayed, where the <code class="Code-In-Text--PACKT-">10</code> stands for base 10. In order to see the binary representation, we will need to set that to <code class="Code-In-Text--PACKT-">2</code>. We can use this initializer to show the binary representation of a value like this:</p>
    <pre class="programlisting code"><code class="hljs-code">let en = 42
print(String(en, radix:2))
print(String(53, radix:2))
</code></pre>
    <p class="normal">The previous code would display the following results:</p>
    <pre class="programlisting con"><code class="hljs-con">101010
110101
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">101010</code> is the binary representation of the number <code class="Code-In-Text--PACKT-">42</code> and <code class="Code-In-Text--PACKT-">110101</code> is the binary representation of the number <code class="Code-In-Text--PACKT-">53</code>. This works really well; however, it does not show leading zeros. For example, if we are comparing the binary representation of <code class="Code-In-Text--PACKT-">53</code> and <code class="Code-In-Text--PACKT-">123456</code>, like the following code shows:</p>
    <pre class="programlisting code"><code class="hljs-code">print(String(53, radix:2))
print(String(123456, radix:2))
</code></pre>
    <p class="normal">We end up with results that look like this:</p>
    <pre class="programlisting con"><code class="hljs-con">110101
11110001001000000
</code></pre>
    <p class="normal">This can be a lot harder to compare. When I need to easily see the binary representation of a number, I usually drop the following extension into my code base:</p>
    <pre class="programlisting code"><code class="hljs-code">extension BinaryInteger {
    func binaryFormat(_ nibbles: Int) -&gt; String {
        var number = self
        var binaryString = ""
        var counter = 0
        let totalBits = nibbles*4
        for _ in (1...totalBits).reversed() {
            binaryString.insert(contentsOf: "\(number &amp; 1)", at:
binaryString.startIndex)
            number &gt;&gt;= 1
            counter += 1
            if counter % 4 == 0 &amp;&amp; counter &lt; totalBits {
                binaryString.insert(contentsOf: " ", at: binaryString.startIndex)
            }
        }
        return binaryString
    }
}
</code></pre>
    <div><p class="Information-Box--PACKT-">It is OK if you do not understand how this code works at this time since bitwise shift operators have not been explained yet. Once they have been explained later in this chapter, you will be able to understand how it works.</p>
    </div>
    <p class="normal">This extension will take an integer and return the binary representation of the number, with the appropriate number of nibbles. Earlier in the chapter we mentioned that a byte has 8 bits; a nibble is <a id="_idIndexMarker603"/>half a byte or 4 bits. Within the string that is returned, this code will put a space between each nibble to make it easier to read. We can use this extension as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">print(53.binaryFormat(2))
print(230.binaryFormat(2))
</code></pre>
    <p class="normal">With this code we are displaying the binary representation of the numbers <code class="Code-In-Text--PACKT-">53</code> and <code class="Code-In-Text--PACKT-">230</code> in two nibbles. The following results show what would be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">0011 0101
1110 0110
</code></pre>
    <p class="normal">Now that we have a very basic idea of what bits, bytes, nibbles, and endianness are, and we are able to display numbers in binary format, let's look at bitwise operators, starting with the bitwise AND operator.</p>
    <h2 id="_idParaDest-256" class="title">The bitwise AND operator</h2>
    <p class="normal">The bitwise AND <a id="_idIndexMarker604"/>operator (<code class="Code-In-Text--PACKT-">&amp;</code>) takes two values and returns a new value where the bits in the new value are set to 1 only if the corresponding bits of both input values are set to 1. The AND operator can be read as: if the bit from the first value AND the bit of the second value are both 1, then set the corresponding bit of the resultant value to 1. Let's see how this works by seeing how we would do a bitwise AND operation on the numbers 42 and 11:</p>
    <figure class="mediaobject"><img src="img/B16683_15_02.png" alt="A close up of a keyboard  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.2: The AND operator</p>
    <p class="normal">As this diagram <a id="_idIndexMarker605"/>shows, the second and fourth bit from the right are both set to <strong class="keyword">1</strong>, therefore the results of the AND operation has those bits set, resulting in an output value of <strong class="keyword">10</strong>. Now let's see how this works in code:</p>
    <pre class="programlisting code"><code class="hljs-code">let numberOne: Int8 = 42
let numberTwo: Int8 = 11
print("\(numberOne) = \(numberOne.binaryFormat(2))")
print("\(numberTwo) = \(numberTwo.binaryFormat(2))")
let andResults = numberOne &amp; numberTwo
print("\(andResults) = \(andResults.binaryFormat(2))")
</code></pre>
    <p class="normal">The previous code sets two integers to <code class="Code-In-Text--PACKT-">42</code> and <code class="Code-In-Text--PACKT-">11</code>. It then prints the binary representation of the numbers, in two nibbles, using the <code class="Code-In-Text--PACKT-">binaryFormat</code> extension to the console. It then performs a bitwise AND operation on the integers and prints the binary representation of the results to the console. The following results will be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">42 = 0010 1010
11 = 0000 1011
10 = 0000 1010
</code></pre>
    <p class="normal">As we can see, the result from the code is the same as shown in the diagram, which has a result of <code class="Code-In-Text--PACKT-">10</code>. Now let's look at the bitwise OR operator.</p>
    <h2 id="_idParaDest-257" class="title">The bitwise OR operator</h2>
    <p class="normal">The bitwise OR operator (<code class="Code-In-Text--PACKT-">|</code>) takes two values and returns a new value where the bits of the results are set to 1 <a id="_idIndexMarker606"/>only if the corresponding bits of either or both values are set to 1. The OR operation reads as: if the bit from the first value OR the bit of the second value is 1, then set the bit in the results to 1. Let's see how this works by seeing how we would do a bitwise OR operation on the numbers 42 and 11:</p>
    <figure class="mediaobject"><img src="img/B16683_15_03.png" alt="A close up of a keyboard  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.3: The OR operator</p>
    <p class="normal">As this diagram shows, the first, second, fourth, and sixth bits from the right are set in one or both of the values, therefore the results of the OR operation have all of those bits set. Now let's see how this works in code:</p>
    <pre class="programlisting code"><code class="hljs-code">let numberOne: Int8 = 42
let numberTwo: Int8 = 11
print("\(numberOne) = \(numberOne.binaryFormat(2))")
print("\(numberTwo) = \(numberTwo.binaryFormat(2))")
let orResults = numberOne | numberTwo
print("\(orResults) = \(orResults.binaryFormat(2))")
</code></pre>
    <p class="normal">The previous code sets two integers to <code class="Code-In-Text--PACKT-">42</code> and <code class="Code-In-Text--PACKT-">11</code>. It then prints the binary representation of the numbers, in two nibbles, using the <code class="Code-In-Text--PACKT-">binaryFormat</code> extension to the console. It then performs a bitwise OR operation on the integers and prints the binary representation of the results. The following results will be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">42 = 0010 1010
11 = 0000 1011
43 = 0010 1011
</code></pre>
    <p class="normal">As we can see, the result from the code is the same as shown in <em class="italic">Figure 15.3</em>, which has a result of <code class="Code-In-Text--PACKT-">43</code>. Now let's <a id="_idIndexMarker607"/>look at the bitwise XOR operator.</p>
    <h2 id="_idParaDest-258" class="title">The bitwise XOR operator</h2>
    <p class="normal">The bitwise XOR operator (<code class="Code-In-Text--PACKT-">^</code>) takes two values and returns a new value where the bits of the new value are <a id="_idIndexMarker608"/>set to 1 only if the corresponding bits of either but not both input values are set to 1. The XOR operator reads: if the bit from the first value OR the bit of the second value is 1, but not both, then set the bit of the results to 1. Let's see how this works by seeing how we would do a bitwise OR operation on the numbers 42 and 11:</p>
    <figure class="mediaobject"><img src="img/B16683_15_04.png" alt="Chart, box and whisker chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.4: The XOR operator</p>
    <p class="normal">As this diagram shows, the second and fourth bits from the right are set to <strong class="keyword">1</strong> for both numbers, therefore in the results those bits are not set. However, the sixth bit in the number <strong class="keyword">42</strong> is set to <strong class="keyword">1</strong> and the first bit in the number <strong class="keyword">11</strong> is set to <strong class="keyword">1</strong>, therefore in the results those bits are set. Now let's see how this works in code:</p>
    <pre class="programlisting code"><code class="hljs-code">let numberOne: Int8 = 42
let numberTwo: Int8 = 11
print("\(numberOne) = \(numberOne.binaryFormat(2))")
print("\(numberTwo) = \(numberTwo.binaryFormat(2))")
let xorResults = numberOne ^ numberTwo
print("\(xorResults) = \(xorResults.binaryFormat(2))")
</code></pre>
    <p class="normal">The previous code sets two integers to <code class="Code-In-Text--PACKT-">42</code> and <code class="Code-In-Text--PACKT-">11</code>. It then prints the binary representation of the numbers to two nibbles using the <code class="Code-In-Text--PACKT-">binaryFormat</code> extension. It then performs a bitwise XOR operation on the integers and prints the binary representation of the results. The <a id="_idIndexMarker609"/>following results will be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">42 = 0010 1010
11 = 0000 1011
33 = 0010 0001
</code></pre>
    <p class="normal">As we can see, the result from the code is the same as shown in the diagram, which has a result of <code class="Code-In-Text--PACKT-">33</code>. Now let's look at the bitwise NOT operator.</p>
    <h2 id="_idParaDest-259" class="title">The bitwise NOT operator</h2>
    <p class="normal">The bitwise NOT operator (<code class="Code-In-Text--PACKT-">~</code>) is different from the other logical operators because it only takes one value. The <a id="_idIndexMarker610"/>bitwise NOT operator will return a value where all of the bits are reversed. What this means is that any bit on the input value that is set to 1 will be set to 0 on the resulting value, and any bit that is set to 0 on the input value will be set to 1 on the resulting value. Let's see how this would work given a value of 42:</p>
    <figure class="mediaobject"><img src="img/B16683_15_05.png" alt="A close up of a clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.5: The NOT operator</p>
    <p class="normal">The diagram illustrates that when we perform the bitwise NOT operation, all of the bits in the result's value will be the opposite of what they were in the original value. Let's see what this looks like in code:</p>
    <pre class="programlisting code"><code class="hljs-code">let numberOne: Int8 = 42
let notResults = ~numberOne
print("\(notResults) = \(notResults.binaryFormat(2))")
</code></pre>
    <p class="normal">The previous code performs the NOT operation on the value of the <code class="Code-In-Text--PACKT-">numberOne</code> variable. The following results will be printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">-43 = 1101 0101
</code></pre>
    <p class="normal">Notice the results are a negative number. The reason for this is an integer is a signed number. With signed numbers, the most significant bit designates whether the number is a positive number or a <a id="_idIndexMarker611"/>negative number. With all bits being reversed, with the NOT operation, a negative number will always turn into a positive number and a positive number will always turn into a negative number.</p>
    <p class="normal">Now that we have looked at the logical bitwise operators, let's look at the bitwise shifting operators.</p>
    <h2 id="_idParaDest-260" class="title">Bitwise shift operators</h2>
    <p class="normal">Swift provides two bitwise shift operators, the bitwise left shift operator (<code class="Code-In-Text--PACKT-">&lt;&lt;</code>) and the bitwise right shift operator (<code class="Code-In-Text--PACKT-">&gt;&gt;</code>). These operators shift all bits to the left or right by the number of <a id="_idIndexMarker612"/>places specified. The shift operators have the effect of multiplying (left shift operator) or dividing (right shift operator) by factors of two. By shifting the bits to the left by one, you are doubling the value, and shifting them to the right by one will halve the value. Let's see how these operators work, starting with the left shift operator:</p>
    <figure class="mediaobject"><img src="img/B16683_15_06.png" alt="A close up of a clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.6: The left shift operator</p>
    <p class="normal">With the left shift operator, all bits in the original value are shifted to the left by one, with the most significant bit falling off and not factoring into the final result. The least significant bit in the result will always be set to zero. Now let's look at the right shift operation:</p>
    <figure class="mediaobject"><img src="img/B16683_15_07.png" alt="A close up of a clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.7: The right shift operator</p>
    <p class="normal">With the right shift operator, all bits in the original value are shifted to the right one spot, with the least <a id="_idIndexMarker613"/>significant digit falling off. The most significant digit in the result will always be set to zero.</p>
    <p class="normal">Now let's see what this looks like in code:</p>
    <pre class="programlisting code"><code class="hljs-code">let numberOne: UInt8 = 24
let resultsLeft = numberOne &lt;&lt; 1
let resultsRight = numberOne &gt;&gt; 1
let resultsLeft3 = numberOne &lt;&lt; 3
let resultsRight4 = numberOne &gt;&gt; 4
print("24  \(numberOne.binaryFormat(2))")
print("&lt;&lt;1 \(resultsLeft.binaryFormat(2))")
print("&gt;&gt;1 \(resultsRight.binaryFormat(2))")
print("&lt;&lt;3 \(resultsLeft3.binaryFormat(2))")
print("&gt;&gt;4 \(resultsRight4.binaryFormat(2))")
</code></pre>
    <p class="normal">In this code, we start off by setting a variable to the number <code class="Code-In-Text--PACKT-">24</code>. We then use the left shift operator to shift the bits one spot to the left. The number after the shift operator defines how many spots to shift the numbers. The next line shifts the bits one spot to the right, then the next line shifts the bits three spots to the left, and the next line shifts the bits four spots to the right. The final five lines print out the results to the console. If you run this code, you should see the following results:</p>
    <pre class="programlisting con"><code class="hljs-con">24  0001 1000
&lt;&lt;1 0011 0000
&gt;&gt;1 0000 1100
&lt;&lt;3 1100 0000
&gt;&gt;4 0000 0001
</code></pre>
    <p class="normal">Looking at the results, we can see that the bits are shifted to the left or right depending on the shifting operator used. In the last line, we can see that when we shifted to the right four spaces, only one bit was set to <code class="Code-In-Text--PACKT-">1</code> rather than two. This is because the bit in the fourth spot from the <a id="_idIndexMarker614"/>right in the original number actually fell off. If we would have shifted to the right five spots, both bits that were set to one in the original number would have fallen off and we would have been left with all zeros.</p>
    <p class="normal">Now let's look at overflow operators.</p>
    <h1 id="_idParaDest-261" class="title">Overflow operators</h1>
    <p class="normal">Swift, at its core, is designed for safety. One of these safety mechanisms is the inability to insert a number <a id="_idIndexMarker615"/>into a variable when the variable type is too small to hold it. As an example, the following code will throw the following error: <code class="Code-In-Text--PACKT-">arithmetic operation '255 + 1' (on type 'UInt8') results in an overflow</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">let b: UInt8 = UInt8.max +1
</code></pre>
    <p class="normal">The reason an error is thrown is we are trying to add one to the maximum number that a <code class="Code-In-Text--PACKT-">UInt8</code> can hold. This error checking can help prevent unexpected and hard-to-trace issues in our applications. Let's take a second and look at what would happen if Swift did not throw an error when an overflow occurs. In a <code class="Code-In-Text--PACKT-">UInt8</code> variable, which is an 8-bit unsigned integer, the number 255 is stored like this, where all of the bits are set to 1:</p>
    <figure class="mediaobject"><img src="img/B16683_15_08.png" alt="A picture containing clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.8: The binary representation of 255</p>
    <p class="normal">Now if we add 1 to this number, the new number will be stored like this:</p>
    <figure class="mediaobject"><img src="img/B16683_15_09.png" alt="A close up of a clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.9: Overflow when trying to represent 256</p>
    <p class="normal">Notice that the 8 bits that represent the <code class="Code-In-Text--PACKT-">UInt8</code> number are all zeros, while the leading one falls off or overflows because we can only store 8 bits. In this case, when we add one to the number 255, the number stored in the results would be 0 if we did not have overflow error checking. This could lead to very unexpected behavior in our code that would be hard to track down.</p>
    <p class="normal">If this is the behavior that we want, Swift does offer three overflow operators that will allow us to opt into this behavior. These are the overflow addition operator (<code class="Code-In-Text--PACKT-">&amp;+</code>), the overflow <a id="_idIndexMarker616"/>subtraction operator (<code class="Code-In-Text--PACKT-">&amp;-</code>), and the overflow multiplication operator (<code class="Code-In-Text--PACKT-">&amp;*</code>). The following code shows how these operators work:</p>
    <pre class="programlisting code"><code class="hljs-code">let add: UInt8 = UInt8.max &amp;+ 1
let sub: UInt8 = UInt8.min &amp;- 1
let mul: UInt8 = 42 &amp;* 10
print("add: \(add): \(add.binaryFormat(2))")
print("sub: \(sub): \(sub.binaryFormat(2))")
print("mul: \(mul): \(mul.binaryFormat(2))")
</code></pre>
    <p class="normal">In this code, we add one to the maximum value of the <code class="Code-In-Text--PACKT-">UInt8</code> type, which is 255, subtract one from the <code class="Code-In-Text--PACKT-">UInt8</code> type minimum value, which is 0, and then multiply <code class="Code-In-Text--PACKT-">42</code> by <code class="Code-In-Text--PACKT-">10</code>, which has a result greater than the 255 maximum value of the <code class="Code-In-Text--PACKT-">UInt8</code> type. The results that are printed to the console are:</p>
    <pre class="programlisting con"><code class="hljs-con">add: 0: 0000 0000
sub: 255: 1111 1111
mul: 164: 1010 0100
</code></pre>
    <p class="normal">As we can see from the results, when we add 1 to the maximum value of the <code class="Code-In-Text--PACKT-">UInt8</code> type, the result is <code class="Code-In-Text--PACKT-">0</code>. When we subtract 1 from the minimum value of the <code class="Code-In-Text--PACKT-">UInt8</code> type, the result is <code class="Code-In-Text--PACKT-">255</code> (the maximum value of the <code class="Code-In-Text--PACKT-">UInt8</code> type). Finally, when we multiply <code class="Code-In-Text--PACKT-">42</code> by <code class="Code-In-Text--PACKT-">10</code>, which our arithmetic teachers would tell us is 420, we actually end up with <code class="Code-In-Text--PACKT-">164</code> because of the overflow.</p>
    <p class="normal">Now let's look at how we can use operator methods to add operators to our custom types.</p>
    <h1 id="_idParaDest-262" class="title">Operator methods</h1>
    <p class="normal">Operator methods enable us to add implementations of standard Swift operators to classes and structures. This is also known as <a id="_idIndexMarker617"/>overloading operators. This is a very useful feature because it <a id="_idIndexMarker618"/>enables us to provide common functionality to our custom types using known operators. We'll take a look at how to do this, but first, let's create a <a id="_idIndexMarker619"/>custom type called <code class="Code-In-Text--PACKT-">MyPoint</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">struct MyPoint {
    var x = 0
    var y = 0
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MyPoint</code> structure defines a two-dimensional point on a graph. Now let's add three operator methods to this type. The operators that we will add are the addition operator (<code class="Code-In-Text--PACKT-">+</code>), the addition assignment operator (<code class="Code-In-Text--PACKT-">+=</code>), and the inverse operator (<code class="Code-In-Text--PACKT-">-</code>). The addition operator and the addition assignment operator are infix operators because there is a left and right operand (value) to the operation, while the inverse operator is a prefix operator because it is used before a single value. We also have postfix operators, which are used at the end of a single value:</p>
    <pre class="programlisting code"><code class="hljs-code">extension MyPoint {
    static func + (left: MyPoint, right: MyPoint) -&gt; MyPoint {
        return MyPoint(x: left.x + right.x, y: left.y + right.y)
    }
    static func += (left: inout MyPoint, right: MyPoint) {
        left.x += right.x
        left.y += right.y
    }
    static prefix func -(point: MyPoint) -&gt; MyPoint {
        return MyPoint(x: -point.x, y: -point.y)
    }
}
</code></pre>
    <p class="normal">When we add operator methods to our types, we add them as static functions using the operator symbols as the method names. When we add prefix or postfix operators, we also include the <code class="Code-In-Text--PACKT-">prefix</code> or <code class="Code-In-Text--PACKT-">postfix</code> keyword before the function declaration. </p>
    <p class="normal">The addition operator is an infix operator; therefore, it takes two input parameters of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. One parameter is for the <code class="Code-In-Text--PACKT-">MyPoint</code> instance that is to the left side of the addition operator and the other parameter is for the <code class="Code-In-Text--PACKT-">MyPoint</code> instance that is to the right of the addition operator.</p>
    <p class="normal">The addition assignment operator is also an infix operator; therefore, it also takes two input parameters of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. The main difference from the addition operator is that the resulting value of the addition operation is assigned to the <code class="Code-In-Text--PACKT-">MyPoint</code> instance that is to the left side of the <a id="_idIndexMarker620"/>addition assignment operator. Therefore, this parameter is designated as an <code class="Code-In-Text--PACKT-">inout</code> parameter so the results can be returned within that instance.</p>
    <p class="normal">The final operator method that we added is the inverse operator. This operator is a prefix operator and is used before an instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type; therefore, it only takes a single parameter of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. Let's see how these operators work:</p>
    <pre class="programlisting code"><code class="hljs-code">let firstPoint = MyPoint(x: 1, y: 4)
let secondPoint = MyPoint(x: 5, y: 10)
var combined = firstPoint + secondPoint
print("\(combined.x), \(combined.y)")
combined += firstPoint
print("\(combined.x), \(combined.y)")
let inverse = -combined
print("\(inverse.x), \(inverse.y)")
</code></pre>
    <p class="normal">In this code, we begin by defining two points and then adding them together using the addition operator that we created. The results of this operator are put in the new <code class="Code-In-Text--PACKT-">combined</code> instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. The <code class="Code-In-Text--PACKT-">combined</code> instance will contain the values of <code class="Code-In-Text--PACKT-">x</code> as 6 and <code class="Code-In-Text--PACKT-">y</code> as 14.</p>
    <p class="normal">We then use the addition assignment operator that we created to add the values in the <code class="Code-In-Text--PACKT-">firstPoint</code> instance to the values in the <code class="Code-In-Text--PACKT-">combined</code> instance. The result of this operation is put in the combined instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. The <code class="Code-In-Text--PACKT-">combined</code> instance now contains the values of <code class="Code-In-Text--PACKT-">x</code> as 7 and <code class="Code-In-Text--PACKT-">y</code> as 14.</p>
    <p class="normal">Finally, we use the inverse operator on the <code class="Code-In-Text--PACKT-">combined</code> instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type to reverse the values and save the new values in the <code class="Code-In-Text--PACKT-">inverse</code> instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. The <code class="Code-In-Text--PACKT-">inverse</code> instance contains the values of <code class="Code-In-Text--PACKT-">x</code> as -7 and <code class="Code-In-Text--PACKT-">y</code> as -18.</p>
    <p class="normal">We are not limited to <a id="_idIndexMarker621"/>using only current operators but can also create our own custom operators as well. Let's see how we can do this.</p>
    <h1 id="_idParaDest-263" class="title">Custom operators</h1>
    <p class="normal">Custom operators enable us to declare and implement our own operators outside of the standard operators provided <a id="_idIndexMarker622"/>by the Swift language. New operators must be declared globally using the <code class="Code-In-Text--PACKT-">operator</code> keyword. They must also be defined with the <code class="Code-In-Text--PACKT-">infix</code>, <code class="Code-In-Text--PACKT-">prefix</code>, or <code class="Code-In-Text--PACKT-">postfix</code> keywords. Once an operator is defined globally, we are then able to add it to our types using the operator methods as shown in the previous section. Let's take a look at this by adding two new operators: <code class="Code-In-Text--PACKT-">•</code>, which we will use to multiply two points together, and <code class="Code-In-Text--PACKT-">••</code>, which will be used to square a value. We will add these operators to the <code class="Code-In-Text--PACKT-">MyPoint</code> type that we created in the last section.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">•</code> symbol can be typed by holding down the <em class="italic">option</em> key and pressing the number <em class="italic">8</em> on a computer running macOS.</p>
    </div>
    <p class="normal">The first thing we need to do is to declare the operators globally. This can be done with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">infix operator •
prefix operator ••
</code></pre>
    <p class="normal">Notice that we define what type of operator it is (<code class="Code-In-Text--PACKT-">infix</code>, <code class="Code-In-Text--PACKT-">prefix</code>, or <code class="Code-In-Text--PACKT-">postfix</code>) followed by the <code class="Code-In-Text--PACKT-">operator</code> keyword and then the symbol(s) that will be used for the operator. Now we can use them exactly like we do normal operators with our <code class="Code-In-Text--PACKT-">MyPoint</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code">extension MyPoint {
    static func • (left: MyPoint, right: MyPoint) -&gt; MyPoint {
        return MyPoint(x: left.x * right.x, y: left.y * right.y)
    }
    
    static prefix func •• (point: MyPoint) -&gt; MyPoint {
        return MyPoint(x: point.x * point.x, y: point.y * point.y)
    }
}
</code></pre>
    <p class="normal">These new custom operators are added to the <code class="Code-In-Text--PACKT-">MyPoint</code> type exactly as we added standard operators, using static functions. We are now able to use these operators exactly like we would use standard operators:</p>
    <pre class="programlisting code"><code class="hljs-code">let firstPoint = MyPoint(x: 1, y: 4)
let secondPoint = MyPoint(x: 5, y: 10)
let multiplied = firstPoint • secondPoint
print("\(multiplied.x), \(multiplied.y)")
let squared = ••secondPoint
print("\(squared.x), \(squared.y)")
</code></pre>
    <p class="normal">In the first line we use the <code class="Code-In-Text--PACKT-">•</code> operator to multiply two instances of the <code class="Code-In-Text--PACKT-">MyPoint</code> type together. The results are put in the multiplied instance of the <code class="Code-In-Text--PACKT-">MyPoint</code> type. The multiplied instance will now contain the values of <code class="Code-In-Text--PACKT-">x</code> as 5 and <code class="Code-In-Text--PACKT-">y</code> as 40. </p>
    <p class="normal">We then use the <code class="Code-In-Text--PACKT-">••</code> operator to <a id="_idIndexMarker623"/>square the value of the <code class="Code-In-Text--PACKT-">secondPoint</code> instance and put the new value in the squared instance. The <code class="Code-In-Text--PACKT-">squared</code> instance will now contain the values of <code class="Code-In-Text--PACKT-">x</code> as 25 and <code class="Code-In-Text--PACKT-">y</code> as 100.</p>
    <h1 id="_idParaDest-264" class="title">Summary</h1>
    <p class="normal">In this chapter we looked at how we can use the advanced bitwise AND, OR, XOR, and NOT operators to manipulate the bits of values stored in variables. We also looked at how we can use the left and right shift operators to shift bits to the left and right. We then saw how we can use overflow operators to change the default behavior for addition, subtraction, and multiplication so errors are not thrown if operations return values above the maximum or below the minimum values for a type. </p>
    <p class="normal">In the second half of the chapter, we saw how we can add operator methods to types, which enables us to use the standard operators provided by Swift with our custom types. We also saw how we can create our own custom operators as well.</p>
    <p class="normal">In the next chapter, we will look at how we can use grand central dispatch and operation queues to add concurrency and parallelism to our applications' code.</p>
  </div>
</body></html>