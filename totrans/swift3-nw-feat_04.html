<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Changes to Swifts Core Will Have You Asking for More</h1></div></div></div><p>Many of the libraries have been touched to pull off this effort including-the Swift standard library, all of Cocoa and Cocoa Touch frameworks, Core Graphics, and Grand Central Dispatch. With the release of Swift 3, we can expect changes that reduce the awkwardness of the language's link to Objective-C, exuding way more <em>Swifty-ness</em>. The Swift team has introduced new API guidelines with the intention of giving the language its own character. The result is a huge renaming and refactoring effort that flows throughout the language. Swift 3 has undergone a huge facelift in terms of its interaction with Objective-C and C APIs. The Swift team is aiming to make your development experience feel more like Swift and less like directly dumping Objective-C into your code. Swift is its own language and should have its own feel just like any other programming language. Yet prior versions of Swift were heavily influenced by the need to interact with Objective-C and C APIs.</p><p>In this chapter, we will quickly highlight the philosophies for writing good Swift APIs. Afterward, we will spend the remaining chapter on language improvements for referencing and using Objective-C features in Swift 3 and importing code from Objective-C and C to Swift 3. Every language change to Swift 3 is covered by one or more Swift Evolution proposals. As we cover a new feature, I'll also provide the proposal number that documents the rationale behind the change. While knowing the actual rational for a new feature is not critical to your understanding of how to implement its code, I think it is interesting to know the efforts and sometimes debates behind why a particular change was implemented. The Swift Evolution repository contains tons of information on accepted and rejected proposals. If you are a careful observer, you will also see proposals that were accepted for the Swift 3 release but didn't get implemented in time for the release.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>The grand renaming</h1></div></div></div><p>Let's start with the proposals for the Swift API Design Guidelines. The Grand Renaming proposals represent, collectively, a very large undertaking and are covered by proposals <em>SE-0005</em>, <em>SE-0006</em>, <em>SE-0086</em>, and <em>SE-0088</em>. Implementing the API guidelines represents the largest change to the language for Swift 3. I couldn't possibly cover every API change resulting in the Grand Renaming proposals in this short book. Thankfully, you don't have to understand every line that changed in the libraries to be productive with Swift 3. You have two fantastic resources that will pay dividends with very little effort on your part. The first resource is the Swift migration tool which converts existing Swift projects to the latest syntax. When you use the Swift migrator, you can convert your Swift 2.2 projects to Swift 3 and receive most of the changes for free. The second extremely valuable resource is the Swift API Guidelines, which were developed to help make your code more <em>Swifty</em>. The Swift API Guidelines are based on the following principles as quoted on <a class="ulink" href="https://swift.org/documentation/api-design-guidelines/">https://swift.org/documentation/api-design-guidelines/</a>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Clarity at the point of use</strong>:This is your most important goal. Entities such as methods and properties are declared only once but used repeatedly. Design APIs to make those uses clear and concise. When evaluating a design, reading a declaration is seldom sufficient, always examine a use case to make sure it looks clear in context.</li><li class="listitem" style="list-style-type: disc"><strong>Clarity is more important than brevity</strong>:<strong> </strong> Although Swift code can be compact, it is a <em>non-goal</em> to enable the smallest possible code with the fewest characters. Brevity in Swift code, where it occurs, is a side-effect of the strong type system and features that naturally reduce the boilerplate.</li><li class="listitem" style="list-style-type: disc"><strong>Write a documentation comment</strong>: This for and every declaration. Insights gained by writing documentation can have a profound impact on your design, so don't put it off.</li></ul></div><p>For more details on adopting these guidelines, please refer to the WWDC 2016 lecture on Swift API Guidelines at <a class="ulink" href="https://developer.apple.com/videos/play/wwdc2016/403/">https://developer.apple.com/videos/play/wwdc2016/403/</a>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec9"/>Referencing Objective-C code in Swift 3</h2></div></div></div><p>With Swift 3, we get a slew of changes that make working with Objective-C and C APIs more enjoyable. We are going to cover the important changes that will make writing code more productive in Swift 3.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Referencing the Objective-C selector of property getters and setters - SE-0064</h2></div></div></div><p>In Objective-C, we can use a type called a <strong>selector</strong> to reference the name of a method. Swift 2.2 introduced <code class="literal">#selector</code> expressions to remove the error-prone nature of providing string literals as the selector name. In Swift 3, the language builds on #selector expressions by allowing you to reference getter and setter methods. This feature allows us to refer to getter and setter properties of objects. Let's look at an example to see how we could access the setter for one of the properties on our <code class="literal">ClassRoom</code> class:</p><pre class="programlisting">class ClassRoom: NSObject{ &#13;
    var roomNum: String &#13;
     &#13;
    init(roomNum: String){ &#13;
        self.roomNum = roomNum &#13;
    } &#13;
} &#13;
 &#13;
let classRoom = ClassRoom(roomNum: "1-D1") &#13;
classRoom.perform(#selector(setter: ClassRoom.roomNum), with: "2-D3")</pre><p>We can now access the setter for the <code class="literal">roomNum</code> using <code class="literal">#selector(setter: ClassRoom.roomNum)</code> or the getter using <code class="literal">#selector(getter: ClassRoom.roomNum)</code>. Once we have our reference, we can use any of the NSObject perform methods available in Objective-C.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md">https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md</a>
</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec0"/>Referencing Objective-C key paths [SE-0062]</h3></div></div></div><p>Similar to selectors, using Objective-C <em>keypaths</em> in Swift 2.2 required us to use string literals. Swift 3 introduces the <code class="literal">#keyPath</code> expressions to improve accuracy by replacing error-prone string literals with objects that can be checked at compile time. Our example below demonstrates how keypaths were done in Swift 2.2 and how referencing keypaths improves with Swift 3.</p><p>For Objective-C:</p><pre class="programlisting">class Employee: NSObject{ &#13;
    var firstName: String &#13;
    var lastName: String &#13;
    var boss: Employee? &#13;
     &#13;
    init(firstName: String, lastName: String, boss: Employee? = nil){ &#13;
        self.firstName = firstName &#13;
        self.lastName = lastName &#13;
        self.boss = boss &#13;
    } &#13;
} &#13;
 &#13;
let bossMan = Employee(firstName: "Jack", lastName: "Spark") &#13;
let rocko = Employee(firstName: "Rocky", lastName: "Jones", boss: bossMan) &#13;
</pre><p>For Swift 2.2:</p><pre class="programlisting">rocko.value(forKeyPath: "Employee.boss.firstName") &#13;
</pre><p>For Swift 3:</p><pre class="programlisting">#keyPath(Employee.boss) // =&gt; boss &#13;
rocko.value(forKeyPath: #keyPath(Employee.boss.firstName)) // =&gt; Jack &#13;
</pre><p>In our Swift 3 example above, we use the <code class="literal">#keyPath</code> expressions that are compile time checked that allow us to safely access values.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md">https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md</a>
</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Importing code from Objective-C and C APIs to Swift 3</h1></div></div></div><p>If you maintain Objective-C or C libraries and want to expose cleaner syntax for Swift, this section is for you! We now have the ability to provide more control over how constants, global functions, and generics are imported from Objective-C and C into Swift.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Importing Objective-C constants as Swift types [SE-0033]</h2></div></div></div><p>Constants with global scope, defined in header files, are imported with the same global scope in Swift. In many cases, it would be more helpful to have related constants grouped together. In Swift 3, you can now annotate your type declarations with <code class="literal">NS_STRING_ENUM</code> or <code class="literal">NS_EXTENSIBLE_STRING_ENUM </code>to have those declarations imported as members of a common type.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec1"/>Importing as Struct</h3></div></div></div><p>If you want your constants to be imported as members of a struct, then add <code class="literal">NS_EXTENSIBLE_STRING_ENUM</code> to the end of your constant type declaration. For more consistent importing into Swift, name your constants using the same type as a prefix. In our example, we created a <code class="literal">MPPlatformIdentifier</code> type that we use as a prefix to name our constants: <code class="literal">MPPlatformIdentifierIOS</code>, <code class="literal">MPPlatformIdentifierMacOS</code>.</p><p>For Objective-C:</p><pre class="programlisting">typedef NSString * MPPlatformIdentifier NS_EXTENSIBLE_STRING_ENUM; &#13;
MPPlatformIdentifier const MPPlatformIdentifierIOS; &#13;
MPPlatformIdentifier const MPPlatformIdentifierMacOS; &#13;
</pre><p>This imports into Swift as:</p><pre class="programlisting">struct MPPlatformIdentifier : RawRepresentable { &#13;
    typealias RawValue = String &#13;
             &#13;
    init(rawValue: RawValue) &#13;
    var rawValue: RawValue { get } &#13;
             &#13;
    static var IOS: MPPlatformIdentifier { get } &#13;
    static var macOS: MPPlatformIdentifier { get } &#13;
} &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec2"/>Importing as Enum</h3></div></div></div><p>Your other option is to have your constants imported as an enumeration type. Your constants are imported as an enum when you add <code class="literal">NS_STRING_ENUM</code> to the end of your type. Each constant that you define using this new type will be added to the enum in Swift.</p><p>For Objective-C:
</p><pre class="programlisting">typedef NSString * MPVersionEnum NS_STRING_ENUM; &#13;
MPVersionEnum const MPVersionEnumV1; &#13;
MPVersionEnum const MPVersionEnumV2; &#13;
MPVersionEnum const MPVersionEnumV3; &#13;
</pre><p>This imports into Swift as:</p><pre class="programlisting">enum MPVersionEnum: String{ &#13;
     case V1 &#13;
     case V2 &#13;
     case V3 &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note16"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md">https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md</a>
</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Importing Objective-C lightweight generics [SE-0057]</h2></div></div></div><p>In Swift 2, you could import and interact with Objective-C lightweight generics. While you could import lightweight generics of any form into Swift 2, only the Foundation types (<code class="literal">NSArray</code>, <code class="literal">NSSet</code>, and <code class="literal">NSDictionary</code>) preserved their type information after import.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>You can learn more about lightweight generics by reading the Swift documentation on the subject here:
<a class="ulink" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html</a>
</p></div></div><p>With Swift 3, you can import your own Objective-C generics without losing information on the type. In our example below, we have several property types defined using Foundation collection types and a custom generic class. Notice that in both Swift 2 and Swift 3, generics import their type information correctly for the Foundation collection types.</p><p>For Objective-C:</p><pre class="programlisting">@property NSArray&lt;MyClass *&gt; * myClasses; &#13;
@property NSDictionary&lt;NSString *, MyClass *&gt; * myClassDictionary; &#13;
@property NSSet&lt;MyClass *&gt; *mySet; &#13;
@property MyCollection&lt;MyClass *&gt; *myCollection; &#13;
 &#13;
@interface MyCollection&lt;__covariant ObjectType&gt; : NSObject &#13;
 -(void) addItem:(ObjectType)item; &#13;
@end</pre><p>Imports into Swift 2 as:
</p><pre class="programlisting">var myClasses: [MyClass] &#13;
var myClassDictionary:  [String : MyClass] &#13;
var mySet: Set&lt;MyClass&gt; &#13;
var myCollection: MyCollectionMyCollection Classfunc addItem(item: AnyObject!)</pre><p>Sadly, we lose the type information for our custom generic property <code class="literal">myCollection</code>, when importing into Swift 2. Swift rightly determines that the <code class="literal">myCollection</code> property is of <code class="literal">MyCollection</code> type, but the parameterized data is lost. Since we lost our type information on import, accessing <code class="literal">addItem()</code> of <code class="literal">myCollection</code> class results in a method signature that uses <code class="literal">AnyObject</code> for the parameter type. This is a subpar result as we expect the type to be <code class="literal">MyClass</code>, matching the Objective-C signature.</p><p>In Swift 3, this import issue is fixed. Our custom Objective-C generics are imported as expected. Examining our Swift 3 import, we can see that all of our generics keep their type information and our class methods will completely match their Objective-C counterparts for our custom generic classes.</p><p>Imports into Swift 3 as:</p><pre class="programlisting">var myClasses: [MyClass] &#13;
var myClassDictionary:  [String : MyClass] &#13;
var mySet: Set&lt;MyClass&gt; &#13;
var myCollection: MyCollection&lt;MyClass&gt;  &#13;
MyCollection Class &#13;
func addItem(_ item: MyClass)</pre><div><div><h3 class="title"><a id="note18"/>Note</h3><p>You can read the proposal at :
<a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md">https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md</a>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Importing as member [SE-0044]</h2></div></div></div><p>Many C APIs provide functions that allow you to create, access, and modify C structures. Importing these libraries as-is will add these functions to your global namespace in Swift. While this is fine in many cases, it might be preferable to group these imports under common types in Swift. Swift 3 allows us to use the <code class="literal">CF_SWIFT_NAME</code> macro to control how initializers, properties, and methods display in Swift. Let's look at how we can accomplish these tasks.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec3"/>Defining an initializer</h3></div></div></div><p>We can modify a C function to create a Swift initializer by appending a <code class="literal">CF_SWIFT_NAME</code> macro to the function definition in the header file. To tell Swift we want the function added as an initializer on a specific type, we need to provide the type (<code class="literal">MyPlatform</code>) followed by a dot and the <em>init</em> format we want (that is the parameters from the C function definition). Swift will import our new initializer as an extension on <code class="literal">MyPlatform</code>, representing our common type.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>The common type needs to exist for Swift to add any extensions. Swift will not create this type for you and will fail silently if no type exists.</p></div></div><p>For C:</p><pre class="programlisting">MyPlatform* MyPlatformWithIdentifier(MPPlatformIdentifier identifier) CF_SWIFT_NAME(MyPlatform.init(identifier:)); &#13;
</pre><p>This imports into Swift as:</p><pre class="programlisting">extension MyPlatform { init(identifier: MPPlatformIdentifier) }</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec4"/>Creating getters and setters</h3></div></div></div><p>In addition to initializers, we can also create computed properties. We can define the getters and setters that will be imported into Swift. For the property's getter, we need to add the <code class="literal">CF_SWIFT_NAME</code> macro to the end of the C function that will serve as the getter and provide a common type and a property name. Our setter will be similar in that we add the macro to the C function that serves as our setter property. See below for the syntax in action. In Swift 3, the getter and setter will be added to the common type <code class="literal">MyPlatform</code> using an extension.</p><p>For C:</p><pre class="programlisting">//getter &#13;
MPPlatformIdentifier MyPlatformGetIdentifier(MyPlatform *platform) CF_SWIFT_NAME(getter:MyPlatform.platformId(self:)); &#13;
 &#13;
//setter &#13;
Void MyPlatformSetIdentifier(MyPlatform *platform, MPPlatformIdentifier identifier) CF_SWIFT_NAME(setter:MyPlatform.platformId(self:newValue:)); &#13;
</pre><p>This imports into Swift as:
</p><pre class="programlisting">extension MyPlatform {  &#13;
var platformId: MPPlatformIdentifier { get set } &#13;
} &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec5"/>Adding methods</h3></div></div></div><p>We can group methods under a common type during our import into Swift 3. This is accomplished using the <code class="literal">CF_SWIFT_NAME</code> macro appended to the C function definition in our header file. You will need to provide the macro a common type and a method signature that uses the same number of variables as the C function. Swift will handle determining the parameter type. You just need to provide names you want to use as the signature in Swift.</p><p>For C:
</p><pre class="programlisting"> &#13;
MPPlatformIdentifier MyPlatformRetreiveId(MyPlatform *platform, MPPlatformIdentifier identifier) CF_SWIFT_NAME(MyPlatform.retreiveId(self:identifier:)); &#13;
</pre><p>This imports into Swift as:
</p><pre class="programlisting">extension MyPlatform { &#13;
   func retreiveId(identifier: MPPlatformIdentifier) -&gt; MPPlatformIdentifier &#13;
}</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec6"/>Creating static variables</h3></div></div></div><p>Finally, we can import global variables as static variables associated with a common type in Swift 3. We just need to provide a common type and variable name to our <code class="literal">CF_SWIFT_NAME</code> macro. Our static variable will be added to the common type in Swift via an extension.</p><p>For C:
</p><pre class="programlisting">extern const MPPlatformIdentifier *MyPlatformTVOS CF_SWIFT_NAME(MyPlatform.tvOS); &#13;
</pre><p>This imports into Swift as:
</p><pre class="programlisting">extension MyPlatform { static var tvOS: MPPlatformIdentifier } &#13;
</pre><div><div><h3 class="title"><a id="note20"/>Note</h3><p>You can read the proposal at:
<a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md">https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md</a>
</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>We just finished covering the principles of Swift's API Guidelines. In addition, I provided you with resources on how to find the Swift Evolution proposals that document the motivations for each change. We also covered new features to work with <code class="literal">#selector</code> and <code class="literal">#keyPath</code> expressions when working with Objective-C APIs in Swift. Finally, we explored working with C APIs and controlling how they are imported into Swift 3. In the next chapter, we will cover more language changes. Stay tuned as we still a have a lot of new things to cover!</p></div></body></html>