- en: Chapter 4. Creating Build Variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are developing an app, you usually have a few different versions.
    The most common scenario is that you have a staging version that is used to manually
    test the app and assure its quality, and a production version. These versions
    usually have different settings. For example, the URL of the staging API can be
    different from the production API. In addition, you may have a free basic version
    of your app, and a paid version that has some extra features. In that case, you
    are already dealing with four different versions: staging free, staging paid,
    production free, and production paid. Having different configurations for every
    version can easily get very complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle has some convenient and extensible concepts to address this common issue.
    We already mentioned the `debug` and `release` build types that are created by
    Android Studio for every new project. There is another concept called product
    flavors, which adds even more possibilities for managing several versions of an
    app or library. Build types and product flavors are always combined, and make
    it easy to handle the scenario with free and paid versions of staging and production
    apps. The result of combining a build type and a product flavor is called a build
    variant.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by looking at build types, what they can do to make
    a developer's life easier, and how to make the most of them. Then, we will discuss
    the difference between build types and product flavors and how both are used.
    We will also take a look at signing configurations, which is a necessity to publish
    apps, and how we can set a different signing configuration for every build variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Build types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product flavors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Android plugin for Gradle, a build type is used to define how an app
    or library should be built. Every build type can specify whether the debug symbols
    should be included, what the application ID has to be, whether unused resources
    should be removed, and so on. You can define build types within a `buildTypes`
    block. This is what a standard `buildTypes` block looks like in a build file created
    by Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The default `build.gradle` file for a new module configures a build type called
    `release`. This build type does nothing more than disabling removal of unused
    resources (by setting `minifyEnabled` to `false`) and defining the location of
    the default ProGuard configuration file. This is to make it straightforward for
    developers to start using ProGuard for their production build, whenever they are
    ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: The `release` build type is not the only build type that is already created
    for your project, though. By default, every module has a `debug` build type. It
    is set to sensible defaults, but you can change its configuration by including
    it in the `buildTypes` block, and overriding the properties you want to change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `debug` build type has its own default settings to make it easy to debug.
    When you create your own build type, different defaults apply. For example, the
    `debuggable` property is set to `true` for the `debug` build type, but is set
    to `false` in any other build type you create.
  prefs: []
  type: TYPE_NORMAL
- en: Creating build types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the default settings are not enough, it is easy to create your own custom
    build types. All that is required for a new build type is a new object within
    the `buildTypes` block. Here is an example of a custom build type called `staging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `staging` build type defines a new suffix for the application ID, making
    it different from the application ID of the debug and release versions. Assuming
    you have the default build configuration, plus the staging build type, the application
    IDs for the build types look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug: `com.package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Release: `com.package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Staging: `com.package.staging`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that you will be able to install both the staging version and the
    release version on the same device without causing any conflicts. The `staging`
    build type also has a version name suffix, which is useful to differentiate several
    versions of the app on the same device. The `buildConfigField` property defines
    a custom URL for the API, using a build configuration field, as we saw in [Chapter
    2](ch02.html "Chapter 2. Basic Build Customization"), *Basic Build Customization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not always have to start from scratch when creating a new build type.
    It is possible to initialize a build type that copies the properties of another
    build type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `initWith()` method creates a new build type and copies all properties from
    an existing build type to the newly created one. It is possible to override properties
    or define extra properties by simply defining them in the new build type object.
  prefs: []
  type: TYPE_NORMAL
- en: Source sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new build type, Gradle also creates a new source set. By default,
    the source set directory is assumed to have the same name as the build type. The
    directory is not automatically created when you define a new build type, though.
    You have to create the source set directory yourself before you can use custom
    source code and resources for a build type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the directory structure can look like with the standard `debug`
    and `release` build type, plus an extra staging build type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These source sets open up a world of possibilities. For example, you can override
    certain properties for specific build types, add custom code to certain build
    types, and add customized layouts or strings to different build types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding Java classes to build types, it is important to keep in mind that
    this process is mutually exclusive. This means that if you add class `CustomLogic.java`
    to the staging source set, you will be able to add the same class to the debug
    and release source sets, but not to the main source set. The class would then
    be defined twice, throwing an exception when you try to build.
  prefs: []
  type: TYPE_NORMAL
- en: Resources are handled in a special way when using different source sets. Drawables
    and layout files will completely override the resources with the same name in
    the main source set, but files in the `values` directory (such as `strings.xml`)
    will not. Gradle will instead merge the content of the build type resources with
    the main resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a `strings.xml` file in the main source set that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you have a `strings.xml` file in the `staging` build type source set
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the merged `strings.xml` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you build a build type that is not staging, the final `strings.xml` file
    will just be the `strings.xml` file from the main source set.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for manifest files. If you create a manifest file for a build
    type, you do not need to copy the entire manifest file from the main source set;
    you can just add the tags you need. The Android plugin will merge the manifests
    together.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about merging in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every build type can have its own dependencies. Gradle automatically creates
    new dependency configurations for every build type. If you want to add a logging
    framework only for `debug` builds, for example, you can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can combine any build type with any dependency configuration in this manner.
    This gives you the possibility to get very specific with dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Product flavors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As opposed to build types, which are used to configure several different builds
    of the same app or library, product flavors are used to create different versions
    of the same app. The typical example is an app that has a free and a paid version.
    Another common scenario is an agency that builds apps that have the same functionality
    for several clients, where only the branding changes. This is very common in the
    taxi industry or with banking apps, where one company creates an app that can
    be reused for all clients in the same category. The only things that change are
    the main colors, the logo, and the URL of the backend. Product flavors greatly
    simplify the process of having different versions of an app based on the same
    code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure whether you need a new build type, or a new product flavor,
    you should ask yourself if you want to create a new build of the same app for
    internal use, or a new APK to publish to Google Play. If you need an entirely
    new app that needs to be published separately from what you already have, then
    product flavors are the way to go. Otherwise, you should stick to using build
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating product flavors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating product flavors is very similar to creating build types. You can create
    a new product flavor by adding it to the `productFlavor` block, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Product flavors have different properties than build types. That is because
    product flavors are objects of the `ProductFlavor` class, just like the `defaultConfig`
    object that is present in all build scripts. This means that `defaultConfig` and
    all your product flavors share the same properties.
  prefs: []
  type: TYPE_NORMAL
- en: Source sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with build types, product flavors can have their own source set directories.
    Creating a folder for a specific flavor is as easy as creating a folder with the
    flavor name. You can even go one step further and create a folder specifically
    for a combination of a certain build type and flavor. The name of the folder would
    then be the flavor name followed by the build type name. For example, if you want
    to have a different app icon specifically for the release version of the blue
    flavor, the folder would have to be called `blueRelease`. The components of the
    combined folder will have a higher priority than the components from both the
    build type folder and the product flavor folder.
  prefs: []
  type: TYPE_NORMAL
- en: Multiflavor variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, you might want to take it further and create combinations of
    product flavors. For example, client A and client B might each want free and paid
    versions of their app, which is based on the same code base, but has different
    branding. Creating four different flavors would mean having several duplicate
    settings, so that is not the way to go. Combining flavors in an efficient way
    is possible using flavor dimensions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you add the flavor dimensions, Gradle expects you to specify a dimension
    for each flavor. If you forget, you will get a build error with a message explaining
    the issue. The `flavorDimensions` array defines the dimensions, and the order
    of the dimensions is very important. When combining two flavors, they might have
    defined the same properties or resources. In that case, the order of the flavor
    dimensions array determines which flavor configuration overrides the other. In
    the earlier example, the color dimension overrides the price dimension. The order
    also determines the name of the build variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the default build configuration with the debug and release build types,
    defining the flavors as shown in the previous example will generate all of these
    build variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blueFreeDebug` and `blueFreeRelease`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bluePaidDebug` and `bluePaidRelease`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redFreeDebug` and `redFreeRelease`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redPaidDebug` and `redPaidRelease`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build variants are simply the result of combining build types and product flavors.
    Whenever you create a build type or product flavor, new variants are created as
    well. For example, if you have the standard `debug` and `release` build types,
    and you create a red and blue product flavor, the following build variants will
    be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build variants](img/B01061_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the **Build Variants** tool window in Android Studio.
    You can find the tool window in the bottom-left corner of the editor, or open
    it from **View** | **Tool Windows** | **Build Variants**. This tool window lists
    all the build variants, but also allows you to switch between them. Changing the
    selected build variant here will affect which variant runs when the **Run** button
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no product flavors, variants will simply consist of build types.
    It is impossible to not have any build types. Even if you do not define any build
    types yourself, the Android plugin for Gradle always creates a debug build type
    for your app or library.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android plugin for Gradle will create tasks for every build variant you
    configure. A new Android app has `debug` and `release` build types by default,
    so you already have `assembleDebug` and `assembleRelease` to build both APKs separately,
    and `assemble` to create both with a single command. When you add a new build
    type, a new task will be created as well. As soon as you start adding flavors
    into the mix, a whole new range of tasks is created, because the tasks for every
    build type are combined with tasks for every product flavor. This means that for
    a simple setup with one build type and one flavor, you already have three tasks
    to build all the variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assembleBlue` uses the blue flavor configuration and assembles both `BlueRelease`
    and `BlueDebug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assembleDebug` uses the debug build type configuration and assembles a debug
    version for every product flavor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assembleBlueDebug` combines the flavor configuration with the build type configuration,
    and the flavor settings override the build type settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New tasks are created for every build type, for every product flavor, and for
    every combination of build type and product flavor.
  prefs: []
  type: TYPE_NORMAL
- en: Source sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build variants that are a combination of a build type and one or more product
    flavors can also have their own source set directories. For example, the variant
    created from the `debug` build type, the blue flavor and the free flavor, can
    have its own source set in `src/blueFreeDebug/java/`. It is possible to override
    the location for the directory using the `sourceSets` block, which we saw in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Gradle and Android Studio"), *Getting
    Started with Gradle and Android Studio*.
  prefs: []
  type: TYPE_NORMAL
- en: Resource and manifest merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of source sets adds extra complexity to the build process.
    The Android plugin for Gradle needs to merge the main source set and the build
    type source sets together before packaging the app. In addition, library projects
    can also provide extra resources, and those need to be merged in as well. The
    same goes for manifest files. You may need extra Android permissions in the debug
    variant of your app to store log files, for example. You do not want to declare
    this permission on the main source set because that might scare potential users.
    Instead, you would add an extra manifest file in the `debug` build type source
    set to declare the extra permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The priority order for resources and manifests looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resource and manifest merging](img/B01061_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a resource is declared in a flavor and in the main source set, the one from
    the flavor will be given a higher priority. In this case, the resource in the
    flavor source set will be packaged, and not the one in the main source set. Resources
    declared in library projects always have the lowest priority.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a lot more to learn about resource and manifest merging. It is an incredibly
    complicated subject, and if we were to explain its details, we would need to dedicate
    an entire chapter to it. Instead, if you want to learn more, it is a good idea
    to read the official documentation on the topic at [http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger](http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger).
  prefs: []
  type: TYPE_NORMAL
- en: Creating build variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle makes it easy to handle the complexity of build variants. Even when
    creating and configuring two build types and two product flavors, the build file
    is still concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created four different build variants: `blueDebug`,
    `blueStaging`, `redDebug`, and `redStaging`. Each variant has its own combination
    of API URL and flavor color. This is what `blueDebug` looks like on a phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating build variants](img/B01061_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is the `redStaging` variant of the same app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating build variants](img/B01061_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first screenshot shows the `blueDebug` variant, which uses the URL defined
    in the `debug` build type, and makes its text blue, based on `flavor_color` defined
    for the blue product flavor. The second screenshot shows `redStaging`, with the
    staging URL and red text. The red staging version also has a different app icon,
    because the drawable folders in the source set for the `staging` build type have
    their own app icon images.
  prefs: []
  type: TYPE_NORMAL
- en: Variant filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to entirely ignore certain variants in your build. This way,
    you can speed up the process of building all variants with the general `assemble`
    command, and your list of tasks will not be polluted with tasks that should not
    be executed. This also ensures that the build variant does not show up in the
    Android Studio build variants switcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter out variants, using this code in the root level of the `build.gradle`
    file of your app or library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first check if the variant's build type has the name `release`.
    Then, we extract the names of all the product flavors. When using flavors without
    dimensions, there is only one product flavor in the flavors array. As soon as
    you start applying flavor dimensions, the flavor array will hold as many flavors
    as there are dimensions. In the example script, we check for the blue product
    flavor, and tell the build script to ignore this particular variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result of the variant filter in the build variant switcher in Android
    Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variant filters](img/B01061_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the two blue release variants (`blueFreeRelease` and `bluePaidRelease`)
    are filtered out of the list of build variants. If you were to run `gradlew tasks`
    now, you would notice that all the tasks related to those variants do not exist
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Signing configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can publish an app on Google Play or any other app store, you need
    to sign it with a private key. If you have a paid and free version or different
    apps for different clients, you need to sign every flavor with a different key.
    This is where signing configurations come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signing configurations can be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create two different signing configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The debug configuration is automatically set up by the Android plugin and makes
    use of a general keystore with a known password, so it is not necessary to create
    a signing configuration for this build type.
  prefs: []
  type: TYPE_NORMAL
- en: The staging configuration in the example uses `initWith()`, which copies all
    properties from another signing configuration. This means that the staging builds
    are signed with the debug key, instead of defining its own.
  prefs: []
  type: TYPE_NORMAL
- en: The release configuration uses `storeFile` to specify the path of the keystore
    file and then defines the key alias and both passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, it is not a good idea to store credentials in the build
    configuration file. A better idea would be to use a Gradle properties file. In
    [Chapter 7](ch07.html "Chapter 7. Creating Tasks and Plugins"), *Creating Tasks
    and Plugins*, there is an entire section dedicated to a task to deal with signing
    configuration passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you define the signing configurations, you need to apply them to your
    build types or flavors. Build types and flavors both have a property called `signingConfig`,
    which can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example uses build types, but if you want to use different certificates
    for every flavor you create, you need to create different signing configurations.
    You can define those in the exact same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using signing configurations this way leads to problems though. When assigning
    a configuration to a flavor, you are actually overriding the signing configurations
    for the build types. What you want to do instead, when using flavors, is to have
    a different key per build type per flavor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The example shows how to use different signing configurations for the red and
    blue flavors that use the release build type, without influencing the debug and
    staging build types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about build types, product flavors, and all their
    possible combinations. These are very powerful tools that can be used in any application.
    From a simple setup with different URLs and keys to more complicated apps that
    share the same source code and resources but have different branding and several
    versions; build types and product flavors can make your life considerably easier.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about signing configurations and applying them, and mentioned
    a common pitfall when signing product flavors.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be introduced to multimodule builds. These are useful when you
    want to extract code into a library or a library project, or when you want to
    include, for example, an Android Wear module into your app.
  prefs: []
  type: TYPE_NORMAL
