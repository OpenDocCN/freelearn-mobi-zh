- en: Chapter 3. High-end Graphics for Android Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primarily, this chapter will explore how to enhance the quality of games and
    applications using different techniques and physically-based shaders. In this
    chapter, firstly we will examine the different techniques of lighting that are
    often used in game development and production stages. Secondly, this chapter will
    describe global illumination in Unity 5\. At the end of the chapter, the reader
    will optimize a shader code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Physically-based shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global illumination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing in shader optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physically-based shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity makes it very easy to use ready shaders or write your own shaders using
    the Cg language or the surface shaders framework. Surface shaders are written
    in Cg, but they do a large amount of work that you do not have to write every
    time when you create a new shader. The surface shader language uses a component-based
    approach, or in other words a more abstract approach that facilitates writing
    complex shaders using a sophisticated lighting model. While using the surface
    shaders framework, graphics programmers do not have to keep reprocessed texture
    coordinates and matrix transformations. In this chapter, we will describe the
    different techniques and methods of writing performance-friendly shaders in great
    detail with nice visual quality effects used in a variety of games and applications
    developed throughout the world.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start with the basic principles and concepts of a shaders. A shader
    is a pre-compiled program for one of the number of stages of the graphics pipeline
    used in three-dimensional graphics to determine the final parameters of the object
    or image. It may include a description of arbitrary complexity absorption and
    scattering of light, texture mapping, reflection and refraction, shading, surface
    displacement, and postprocessing effects.
  prefs: []
  type: TYPE_NORMAL
- en: Basic shader concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmable shaders are flexible and effective. Seemingly complex surfaces
    can be visualized with simple geometric forms. For example, the shaders can be
    used to draw a three-dimensional surface of the ceramic tiles on a completely
    flat surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, shaders are divided into three types: **vertex**, **geometry**, and
    **fragment (pixel)**.'
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **vertex shader** manipulates data mapped to the vertices of polyhedra.
    This data corresponds to the coordinates of the vertices in space, texture coordinates,
    a tangent vector, a bi-normal vector, and a normal vector. The vertex shader can
    be used for perspective vertices transformation, for generating texture coordinates,
    for lighting calculations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The geometry shader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **geometry shader**, in contrast to the vertex shader, is able to handle
    not only one vertex, but also a whole primitive with a set of vertexes (triangles,
    quads, and so on). It can be cut (two vertices) and triangular (three vertices),
    and the information on adjacent vertices (adjacency) can be processed for up to
    six vertices of the triangular primitive. Furthermore, the geometry shader can
    generate primitives "on the fly," without using a central processor. They were
    first used on the *Nvidia 8* series.
  prefs: []
  type: TYPE_NORMAL
- en: The pixel/fragment shader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **pixel shader** works with fragments of the bitmap. A pixel shader is used
    in the last stage of the graphics pipeline to generate a fragment of the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Shading languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shading languages usually contain special data types such as matrices, samplers,
    vectors, and a set of built-in variables and constants for easy integration with
    different 3D libraries. As computer graphics have many application areas, to meet
    the different needs of the market, developers created a large number of shader
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: These shading languages are focused on delivering the highest quality image.
    Describing the properties of materials made at the highest abstract level to work
    do not need any special skills or knowledge of programming hardware. Such shaders
    are usually created by artists in order to ensure "the right kind" such as texture
    mapping, light sources, and other aspects of art and science at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Processing these shaders is usually a resource-intensive task. The aggregate
    computing power needed for this work can be very high, as it is used to create
    photo-realistic images. The main part of the similar computation is performed
    by a visualization of large computer clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Cg
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Cg shading language developed by Nvidia in conjunction with Microsoft (essentially
    the same language from Microsoft is called **HLSL**, and is included in DirectX
    9). Cg is used in Unity and stands as **C for Graphics**. The language is very
    similar to C and it uses similar data types (`int`, `float`, and a special 16-bit
    floating point type—`half`). Cg also supports functions and structures. The language
    has peculiar optimizations like packed arrays—type declarations like `float a
    [4]` and `float4 a` are different types. The second announcement is a **packed
    array**. The packed array operations are faster than conventional operations.
    Despite the fact that the language was developed by Nvidia, it works without problems
    with other graphics cards (for example, ATI cards). However, please note that
    all the shader programs have their own peculiarities, which can be obtained from
    specialized sources.
  prefs: []
  type: TYPE_NORMAL
- en: Unity shaders in Cg
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition, you should know that Unity 5 comes with built-in shaders, which
    are very useful, especially for some basic stuff required in many different games.
    Now let's start our wonderful journey into the world of Unity shaders in Cg language.
    Typically, shaders use diffuse components or a lighting model. First, you must
    understand what should be optimized in your shaders well. Basically, you should
    try to avoid complicated calculations and labor-intensive functions. In this chapter,
    firstly, we will examine the different techniques of lighting models that are
    so often used in game development and production stages. Lighting is one of the
    fundamental aspects of the shader. Therefore, programmers often use their approximate
    calculations for lighting to speed up performance.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, computer graphics were used as a fixed-function lighting model, which
    was not a very flexible solution, since it gave graphics programmers only a single
    lighting model that could only be adjusted by setting a finite set of parameters
    and textures. Unlike before, where a single fixed-lighting model was used, today,
    developers use a very flexible programmable approach to create different lighting
    models with the help of the Cg shader language, especially from the wonderful
    surface shaders in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The diffuse component in the shader will often specify exactly how the rays
    of light reflect from the surface in all directions. You may find that it is very
    similar to the work of a mirror that reflects the sun's rays at different angles
    and in all directions. However, it is not so, and we'll show you this difference
    in as much detail as possible later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is that a reflective surface like a mirror reflects the
    image of the surrounding environment, while the diffuse lighting model reflects
    sunlight back into the field of view.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a simple and basic diffuse lighting model, you will need
    to create a shader that will contain an emissive color, an ambient color, and
    of course the total accumulation of color from all light sources. Techniques and
    tricks that we will show you in the following code will help you create your own
    lighting models, as well as explore various industry tricks to help you understand
    the basic ideas to create more complex lighting models using only the textures
    that will give a huge increase to your productivity. In other words, the use of
    premade textures to create lighting models can greatly increase your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest example of our surface shader as shown in the
    following code. The code was generated by the Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider the `Properties` block in more detail. The properties are some
    of the very important elements while writing shaders. The properties allow the
    artist to set their own textures or other settings to customize the visual effects.
    You can tune the properties of the selected shader through Unity materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity parses each shader code in order to find built-in structures. The `Properties`
    block is one of these built-in structures that Unity is looking for. Here is an
    example of the structure of the `Properties` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time you create a new property, you will need to name your variable. The
    variable name is used in the code of your shader, while the inspector GUI name
    will be shown in the Unity Editor. The type can be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Range (min, max)`: These are real numbers in the form of a slider from `min`
    to `max`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Color`: This opens the color picker in the Unity inspector for choosing the
    desired color value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2D`: This is used for adding textures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rect`: This is a nonpower of two textures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cube`: This is a cube map texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float:` These are real values without the slider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector`: This is a four-component vector with real numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the `Properties` structure, we specified the default value.
  prefs: []
  type: TYPE_NORMAL
- en: A custom diffuse lighting model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you write your own diffuse lighting model, we will consider our new
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to declare these new properties in our shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After the announcement of the properties in the shader code, we can use these
    variables as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you should have a shader as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to create your own diffuse lighting model. In most cases, no built-in
    lighting is well-suited for specific tasks in the game or application. Specific
    optimization problems require unique solutions. In order to override the built-in
    lighting functions you need to register, the `SubShader` block in the next line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can describe our custom lighting function as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s systematically look at the fundamental elements. The `#pragma`
    directive specifies the name of the function to be used for lighting. We used
    the built-in feature called **Lambert** defined in the `Lighting.cginc` file,
    and now we specified the name of our function for future use. In establishing
    this lighting function, it is necessary to remember that the name of the function
    will eventually be formed using the first word of `Lighting + <Your Function Name>`,
    that is, for example if you decide to call a function `SunShine`, then the name
    of your lighting function will be `LightingSunShine`. There are three options
    to create your custom lighting functions that differ from each other by their
    input parameters as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float
    attenuation) {}`: You should use this function for forward rendering, when you
    don''t need the view direction value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float3
    viewDirection, float attenuation) {}`: You should use this function for forward
    rendering, when you need the view direction value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float4 Lighting<YourName>_PrePass (SurfaceOutput surface, float4 light) {}`:
    You should use this function for deferred rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ultimately, you should get a shader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A basic reflection environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s look at other ideas and techniques widely known in professional
    circles around the world that are used to write performance friendly shaders with
    nice visual effects. The following examples are based on environment reflections
    on your surface. A simple source code of this shader is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Masked texture reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next new shader implements a new technique that uses a texture to mask
    the reflection of your environment, and it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lighting model techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider a variety of techniques and methods of implementation of the
    lighting model, which, like the previous shaders, are used worldwide in the game
    industry as well as in movies and cartoons.
  prefs: []
  type: TYPE_NORMAL
- en: The Lit sphere model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, we would like to consider the `LitSphere` lighting model. The idea
    is very simple and straightforward—we should just use a 2D texture in order to
    completely bake our light. Alternatively, it is necessary to take into account
    and not forget that this technique is static and does not change the lighting
    up until the texture used for baking light is changed. This technique gives very
    high-quality lighting and is optimized enough, but it is not dynamic. In other
    words, it does not depend on the angle or distance from the camera or from the
    viewer that can be changed in real time, because this technique does not depend
    on the lighting in the scene. Let''s explore this shader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are many different techniques and approaches to create lighting models
    and other visual effects; we cannot put all the ideas and techniques into this
    book, as it is beyond the scope of this book. You can also implement your own
    new ideas and techniques; it depends on your imagination. The previous examples
    of different approaches for writing shaders are widely used by developers around
    the world to create high-quality rendering in real time, and for optimization.
    Also, you can write shaders that work with the model vertices, so you can very
    simply create shader that will play the waves animation from the primitive plane.
  prefs: []
  type: TYPE_NORMAL
- en: Realistic rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marcos Fajardo of *Solid Angle*—the company behind the renderer *Arnold*—noted
    that more and more production studios in the world have either already come to
    that, or are in the process of transition with the following quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The process is going on in the entire industry, and it''s something. I''ve
    been working with this for the past ten years or so, and I''m really glad to see
    that this is happening at last."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fajardo can be called one of the greatest defenders and activists of global
    change in the industry. Solid Angle is really at the forefront of the large-scale
    movement to the path-traced GI with physically-plausible materials and lighting
    for production decisions (that is, when the budget is smaller and the time frame
    is more compressed).
  prefs: []
  type: TYPE_NORMAL
- en: The basis of the popularity of the "honest" method is the desire to "catch two
    rabbits at once," simplify the lives of artists around the world and to achieve
    a more realistic picture.
  prefs: []
  type: TYPE_NORMAL
- en: With some older technology chains, artists can get the scene with a few hundred
    light sources (where each source is needed to fulfill its role, one for the highlight
    of a material and the second for the specular reflection on this material, the
    third and fourth for the glare and reflections on the second material, plus ten
    to simulate global illumination, and so on), with very complex shaders written
    by the developer with C++, the code was full of tricks and tweaks. Lighting designers
    often just sit, turning on and off lights, one after the other—it is easy to understand
    why some of them are so necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Most companies do not count the fact that the introduction of natural light
    sources and materials make a quick render itself, but there is an expectation
    that this will greatly facilitate the work of the artist. An hour of work which,
    to be honest, is a few tens of times more expensive than an hour rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Global illumination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the, *Game Developers Conference* in 2014, which started on March 17
    in San Francisco, the company Unity Technologies introduced the fifth generation
    of its popular game engine Unity. One of the most important features that distinguishes
    it from the previous edition is a new system of global illumination in real time—Enlighten—implemented
    with the participation of experts from the British company, *Geomerics*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Global illumination](img/9191OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unity 5 is presented with support from WebGL standard web module optimization
    `asm.js`, physics engine NVIDIA PhysX 3.3, the system of creation and animation
    vegetation—SpeedTree, an advanced shader system, the preview function light maps
    in real time, and a cross-processed audio advertising network in Unity Cloud that
    facilitates the promotion of mobile games. In addition, the fifth version of the
    engine will be able to run in a 64-bit environment that significantly simplifies
    the workflow through a new multi-threaded scheduler, and provides you with the
    opportunity to make changes in real time and improve the system to create game
    resources (assets list) and an intuitive interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Global illumination](img/9191OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The latest version of this toolkit, traditionally the best-selling in small
    teams of developers, is designed including large companies. This makes it a competitor
    to other high-tech new generation of game engines such as CryEngine and Unreal
    Engine 4\. Along with the fourth generation engine from Epic Games, it has recently
    signed another agreement with Mozilla, where Unity 5 can be used by developers
    of three-dimensional and two-dimensional games for browsers and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Global illumination](img/9191OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Unity 5, developers will be able to view the coverage maps in real time using
    the ray tracing PowerVR from the company *Imagination Technologies*. This technique
    reduces the processing time, which gives a very good performance. Developers will
    be able to create a variety of materials from the real world with the new shader
    system in Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global illumination** is the name of a series of algorithms used in three-dimensional
    graphics for more realistic simulation of light. These algorithms take into account
    not only the direct light from the source (direct illumination), but also reflected
    light from various surfaces (indirect illumination).'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, *reflection*, *refraction*, and *shadows* are examples of global
    illumination, because for them it is necessary to consider the effect of the simulation
    of one object to the other (in contrast to the case when the object is exposed
    to direct light). In practice, however, the simulation of diffuse reflection or
    caustics is called global illumination.
  prefs: []
  type: TYPE_NORMAL
- en: Images obtained by the application of global illumination algorithms often appear
    more realistic than those in the rendering process that apply only direct illumination
    algorithms. However, to calculate global illumination requires much more time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure was processed only by direct illumination algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global illumination](img/9191OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following figure was processed by global illumination algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global illumination](img/9191OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Practicing in shader optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to discuss how we can optimize our shaders. Alternatively, it
    is time to consider the other methods, such as optimizing built-in data types,
    which can significantly reduce the overhead of the Unity shaders' memory. We consider
    Unity shaders optimization for all supported platforms without any exclusions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very often, you will need to optimize shaders to achieve the same visual effect,
    but with a smaller number of textures for example. Primarily, when optimizing
    shader code, we would like to direct your attention to the types of variables.
    If you are willing to sacrifice the accuracy of calculations in order to decrease
    the quality to improve performance, then you should use the `half` or `fixed`
    variable types instead of `float`. As an example, you can use a `half` type of
    variable everywhere in your shader code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also replace `float` with `half` in the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`float`: These variables have 32 bits precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`half`: These variables have 16 bits precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixed`: These variables have 11 bits precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s optimize our previous shader code `CarVehicle.shader` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how to develop shaders faster and better, you must understand
    that this can only be achieved by full optimization, using a variety of techniques
    and approaches. Let''s divide our shader optimization process into the following
    three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization of memory used for variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization of the number and size of used textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization of computational algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the mentioned points have been already discussed. Some of the ideas of how
    to optimize your shaders have been already considered earlier in this chapter,
    and we will show some more interesting approaches and techniques. We hope that
    most of the methods, techniques, approaches, and ideas of this book will greatly
    help you in production to achieve the desired quality and performance at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Also, while optimizing shaders you need to remember and know that the code should
    be as small as possible. This means that nothing unnecessary should be in your
    code. Many of the ideas described in the previous chapters, especially in the
    preceding fourth chapter, which talked about code optimization in C# and JavaScript,
    are well suited to optimize your shader code. Also, we want you to note that the
    frequency of execution of your shader code greatly affects the performance. Very
    often, shader developers use very good techniques in order to optimize their shaders.
    They prefer using vertex shaders instead of pixel shaders; this will greatly improve
    your performance in most cases, as there are significantly more pixels than vertices.
    Hence, processing the pixel shader frequency of the execution code will be much
    greater than for vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also consider the directives that may well optimize your shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`approxview`: This approximation is good enough in many cases. You should use
    this directive when you need to get the normalized view direction per vertex instead
    of per pixel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`halfasview`: This will be computed and normalized per vertex halfway between
    view and light directions (half vector), and the lighting function will receive
    a `half` vector as a parameter instead of view vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noforwardadd`: In the event of rendering shaders in one pass, even with multiple
    lights, and in the event of making your shader smaller, this directive is the
    best choice for you. The shader will support only one directional light in forward
    rendering. The rest of the lights can still have an effect like vertex lights
    or spherical harmonics. The rest of the lights can be used for spherical harmonics
    or for vertex light effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exclude_path:prepass`: The shader that uses this directive will not accept
    any custom lighting from the deferred renderer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noambient`: This directive should be used in the event of deactivating spherical
    harmonics and ambient lights on your shader. This can slightly enhance your performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nolightmap`: This directive disables Unity''s internal light mapping system.
    In other words, it does not perform a light mapping check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha testing** on mobile devices is very expensive, so you should use transparent
    shaders on mobile devices very accurately. You must use the alpha testing only
    when necessary. For example, let''s cover optimized shader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Best case practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After our journey into the world of diverse ideas, approaches, and techniques
    in the field of lighting calculations, let's look at the best practice in order
    to maintain many different shaders easily. Let's consider the possibility of reusability
    of our shader code; for example, various lighting functions in Unity. In order
    to avoid writing the same code for the same lighting function each time for a
    new shader, it's best to write the code lighting function once and then just use
    this in any shader if necessary, as programmers use different frameworks and libraries.
    This practice will help you create a framework for your shaders, which will greatly
    facilitate easy development and effortless shader maintenance. In the previous
    examples, we used built-in `CgIncludes` files such as `Lambert` and `BlinnPhong`
    lighting functions. Unity created these lighting models for us. Unity helps us
    reduce our efforts while writing performance-friendly and nice quality shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the code embedded in Unity built-in `CgIncludes` files, which
    are located inside a directory called `CgIncludes`. Without these files, it will
    be much harder to write shaders in Unity. That''s why Unity surface shaders are
    so efficient. Let''s create our own `CgInclude` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s consider the code for the next shader as follows, where you can
    see how to use your `CgInclude` file with your lighting function, and how you
    can declare your variable `_YourColorVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Thus, you can create a proper framework of your own shaders. Also, you can use
    examples from this chapter and place all your code in the form of `CgIncludes`
    files. This will greatly help you avoid repetitions in the code, which will greatly
    simplify the development of shaders and also facilitate their optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot about writing shaders and their optimization.
    We started with a simple shader code and examined the fundamental elements in
    Unity surface shaders. Next, we wrote our custom diffuse lighting model. Also,
    we examined global illumination. We explored the various optimization techniques
    by changing the shader variable types, as well as by writing specific directives.
    Towards the end of this chapter, we covered the best case practice while developing
    shaders using `CgIncludes` files, and learned how to use its code.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover legacy and Mecanim animation systems in Unity 5\.
    You will also develop a simple custom sprite animation system and explore how
    to import, set up, and play audio files inside your scripts in Unity 5\. At the
    end of the next chapter, you will explore the physics and particle systems in
    Unity 5.
  prefs: []
  type: TYPE_NORMAL
