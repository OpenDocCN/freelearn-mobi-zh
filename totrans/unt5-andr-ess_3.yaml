- en: Chapter 3. High-end Graphics for Android Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. Android设备的高端图形
- en: Primarily, this chapter will explore how to enhance the quality of games and
    applications using different techniques and physically-based shaders. In this
    chapter, firstly we will examine the different techniques of lighting that are
    often used in game development and production stages. Secondly, this chapter will
    describe global illumination in Unity 5\. At the end of the chapter, the reader
    will optimize a shader code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，本章将探讨如何使用不同的技术和基于物理的着色器来提高游戏和应用程序的质量。在本章中，首先我们将检查在游戏开发和生产阶段经常使用的不同照明技术。其次，本章将描述Unity
    5中的全局照明。在章节的结尾，读者将优化一段着色器代码。
- en: 'The topics that will be covered in the chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Physically-based shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物理的着色器
- en: Global illumination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局照明
- en: Practicing in shader optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器优化实践
- en: Physically-based shaders
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物理的着色器
- en: Unity makes it very easy to use ready shaders or write your own shaders using
    the Cg language or the surface shaders framework. Surface shaders are written
    in Cg, but they do a large amount of work that you do not have to write every
    time when you create a new shader. The surface shader language uses a component-based
    approach, or in other words a more abstract approach that facilitates writing
    complex shaders using a sophisticated lighting model. While using the surface
    shaders framework, graphics programmers do not have to keep reprocessed texture
    coordinates and matrix transformations. In this chapter, we will describe the
    different techniques and methods of writing performance-friendly shaders in great
    detail with nice visual quality effects used in a variety of games and applications
    developed throughout the world.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使得使用现成的着色器或使用Cg语言或表面着色器框架编写自己的着色器变得非常容易。表面着色器是用Cg编写的，但它们执行了大量工作，你不必在每次创建新着色器时都编写。表面着色器语言使用基于组件的方法，或者说是一种更抽象的方法，它通过使用复杂的照明模型来简化复杂着色器的编写。在使用表面着色器框架时，图形程序员不需要反复处理纹理坐标和矩阵变换。在本章中，我们将详细描述编写性能友好的着色器的不同技术和方法，并展示在全世界开发的各种游戏和应用中使用的良好视觉质量效果。
- en: First, let's start with the basic principles and concepts of a shaders. A shader
    is a pre-compiled program for one of the number of stages of the graphics pipeline
    used in three-dimensional graphics to determine the final parameters of the object
    or image. It may include a description of arbitrary complexity absorption and
    scattering of light, texture mapping, reflection and refraction, shading, surface
    displacement, and postprocessing effects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从着色器的基本原理和概念开始。着色器是为三维图形中使用的图形管道的多个阶段之一预编译的程序，用于确定对象或图像的最终参数。它可能包括对任意复杂性的光吸收和散射、纹理映射、反射和折射、着色、表面位移和后期处理效果的描述。
- en: Basic shader concepts
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本着色器概念
- en: Programmable shaders are flexible and effective. Seemingly complex surfaces
    can be visualized with simple geometric forms. For example, the shaders can be
    used to draw a three-dimensional surface of the ceramic tiles on a completely
    flat surface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程着色器灵活且有效。看似复杂的表面可以用简单的几何形状来可视化。例如，着色器可以用来在完全平坦的表面上绘制陶瓷瓷砖的三维表面。
- en: 'In Unity, shaders are divided into three types: **vertex**, **geometry**, and
    **fragment (pixel)**.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，着色器分为三种类型：**顶点**、**几何**和**片段（像素）**。
- en: The vertex shader
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The **vertex shader** manipulates data mapped to the vertices of polyhedra.
    This data corresponds to the coordinates of the vertices in space, texture coordinates,
    a tangent vector, a bi-normal vector, and a normal vector. The vertex shader can
    be used for perspective vertices transformation, for generating texture coordinates,
    for lighting calculations, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点着色器**处理映射到多边形顶点上的数据。这些数据对应于空间中顶点的坐标、纹理坐标、切线向量、双法线向量和法线向量。顶点着色器可用于透视顶点变换、生成纹理坐标、进行光照计算等。'
- en: The geometry shader
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几何着色器
- en: The **geometry shader**, in contrast to the vertex shader, is able to handle
    not only one vertex, but also a whole primitive with a set of vertexes (triangles,
    quads, and so on). It can be cut (two vertices) and triangular (three vertices),
    and the information on adjacent vertices (adjacency) can be processed for up to
    six vertices of the triangular primitive. Furthermore, the geometry shader can
    generate primitives "on the fly," without using a central processor. They were
    first used on the *Nvidia 8* series.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点着色器相比，**几何着色器**能够处理不仅是一个顶点，而且是一组顶点（三角形、四边形等）构成的整个原始形状。它可以被切割（两个顶点）和三角化（三个顶点），并且可以处理三角形原始形状的相邻顶点（相邻性）信息，最多可达六个顶点。此外，几何着色器可以“即时”生成原始形状，而不需要使用中央处理器。它们最初被用于*Nvidia
    8*系列。
- en: The pixel/fragment shader
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素/片段着色器
- en: The **pixel shader** works with fragments of the bitmap. A pixel shader is used
    in the last stage of the graphics pipeline to generate a fragment of the picture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**像素着色器**与位图的片段一起工作。像素着色器在图形管道的最后阶段使用，用于生成图片的片段。'
- en: Shading languages
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色语言
- en: Shading languages usually contain special data types such as matrices, samplers,
    vectors, and a set of built-in variables and constants for easy integration with
    different 3D libraries. As computer graphics have many application areas, to meet
    the different needs of the market, developers created a large number of shader
    languages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 着色语言通常包含特殊的数据类型，如矩阵、采样器、向量和一组内置变量和常量，以便于与不同的3D库集成。由于计算机图形学有许多应用领域，为了满足市场的不同需求，开发者创建了大量的着色语言。
- en: These shading languages are focused on delivering the highest quality image.
    Describing the properties of materials made at the highest abstract level to work
    do not need any special skills or knowledge of programming hardware. Such shaders
    are usually created by artists in order to ensure "the right kind" such as texture
    mapping, light sources, and other aspects of art and science at the same time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些着色语言专注于提供最高质量的图像。在最高抽象级别描述材料属性，以便工作不需要任何特殊技能或对编程硬件的了解。这类着色器通常由艺术家创建，以确保“正确类型”的纹理映射、光源和其他艺术和科学方面的同时实现。
- en: Processing these shaders is usually a resource-intensive task. The aggregate
    computing power needed for this work can be very high, as it is used to create
    photo-realistic images. The main part of the similar computation is performed
    by a visualization of large computer clusters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些着色器通常是一个资源密集型任务。为此工作所需的总体计算能力可以非常高，因为它用于创建逼真的图像。这类相似计算的主要部分是通过大型计算机集群的可视化来完成的。
- en: Cg
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cg
- en: The Cg shading language developed by Nvidia in conjunction with Microsoft (essentially
    the same language from Microsoft is called **HLSL**, and is included in DirectX
    9). Cg is used in Unity and stands as **C for Graphics**. The language is very
    similar to C and it uses similar data types (`int`, `float`, and a special 16-bit
    floating point type—`half`). Cg also supports functions and structures. The language
    has peculiar optimizations like packed arrays—type declarations like `float a
    [4]` and `float4 a` are different types. The second announcement is a **packed
    array**. The packed array operations are faster than conventional operations.
    Despite the fact that the language was developed by Nvidia, it works without problems
    with other graphics cards (for example, ATI cards). However, please note that
    all the shader programs have their own peculiarities, which can be obtained from
    specialized sources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由Nvidia与Microsoft共同开发的Cg着色语言（实际上，Microsoft的相同语言被称为**HLSL**，并包含在DirectX 9中）。Cg在Unity中使用，代表**C
    for Graphics**。该语言与C非常相似，并使用类似的数据类型（`int`、`float`和特殊的16位浮点类型—`half`）。Cg还支持函数和结构。该语言具有独特的优化，如打包数组——类型声明如`float
    a [4]`和`float4 a`是不同的类型。第二个声明是**打包数组**。打包数组操作比传统操作更快。尽管该语言由Nvidia开发，但它与其他图形卡（例如ATI卡）没有问题。然而，请注意，所有着色程序都有其独特的特性，可以从专业来源获得。
- en: Unity shaders in Cg
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity中的Cg着色器
- en: In addition, you should know that Unity 5 comes with built-in shaders, which
    are very useful, especially for some basic stuff required in many different games.
    Now let's start our wonderful journey into the world of Unity shaders in Cg language.
    Typically, shaders use diffuse components or a lighting model. First, you must
    understand what should be optimized in your shaders well. Basically, you should
    try to avoid complicated calculations and labor-intensive functions. In this chapter,
    firstly, we will examine the different techniques of lighting models that are
    so often used in game development and production stages. Lighting is one of the
    fundamental aspects of the shader. Therefore, programmers often use their approximate
    calculations for lighting to speed up performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该知道Unity 5自带内置的着色器，这些着色器非常有用，尤其是在许多不同游戏中所需的一些基本内容方面。现在，让我们开始我们的奇妙之旅，进入Unity着色器的Cg语言世界。通常，着色器使用漫反射组件或照明模型。首先，您必须很好地理解在您的着色器中应该优化什么。基本上，您应该尽量避免复杂的计算和劳动密集型函数。在本章中，首先，我们将检查在游戏开发和生产阶段经常使用的不同照明模型技术。照明是着色器的一个基本方面。因此，程序员经常使用他们的大致计算来加速性能。
- en: Earlier, computer graphics were used as a fixed-function lighting model, which
    was not a very flexible solution, since it gave graphics programmers only a single
    lighting model that could only be adjusted by setting a finite set of parameters
    and textures. Unlike before, where a single fixed-lighting model was used, today,
    developers use a very flexible programmable approach to create different lighting
    models with the help of the Cg shader language, especially from the wonderful
    surface shaders in Unity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，计算机图形学使用的是固定功能的照明模型，这并不是一个非常灵活的解决方案，因为它只给图形程序员提供了一个单一的照明模型，而这个模型只能通过设置有限的一组参数和纹理来调整。与之前使用单一固定照明模型不同，如今，开发者使用非常灵活的可编程方法，借助Cg着色语言，特别是Unity中出色的表面着色器，来创建不同的照明模型。
- en: The diffuse component in the shader will often specify exactly how the rays
    of light reflect from the surface in all directions. You may find that it is very
    similar to the work of a mirror that reflects the sun's rays at different angles
    and in all directions. However, it is not so, and we'll show you this difference
    in as much detail as possible later on in the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器中的漫反射部分通常会指定光线以所有方向从表面反射的确切方式。您可能会发现这非常类似于镜子反射太阳光以不同角度和所有方向的工作。然而，事实并非如此，我们将在本章稍后尽可能详细地展示这种差异。
- en: The main difference is that a reflective surface like a mirror reflects the
    image of the surrounding environment, while the diffuse lighting model reflects
    sunlight back into the field of view.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，像镜子这样的反射表面会反射周围环境的图像，而漫反射照明模型会将阳光反射回视野中。
- en: In order to create a simple and basic diffuse lighting model, you will need
    to create a shader that will contain an emissive color, an ambient color, and
    of course the total accumulation of color from all light sources. Techniques and
    tricks that we will show you in the following code will help you create your own
    lighting models, as well as explore various industry tricks to help you understand
    the basic ideas to create more complex lighting models using only the textures
    that will give a huge increase to your productivity. In other words, the use of
    premade textures to create lighting models can greatly increase your productivity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单且基本的漫反射照明模型，你需要创建一个包含发射颜色、环境颜色以及当然是从所有光源来的颜色总积累的着色器。在接下来的代码中，我们将向您展示的技术和技巧将帮助您创建自己的照明模型，以及探索各种行业技巧，帮助您理解仅使用纹理创建更复杂照明模型的基本思想，这将极大地提高您的生产力。换句话说，使用预制的纹理来创建照明模型可以大大提高您的生产力。
- en: 'Let''s start with the simplest example of our surface shader as shown in the
    following code. The code was generated by the Unity Editor:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下代码中显示的最简单的表面着色器示例开始。此代码由Unity编辑器生成：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's consider the `Properties` block in more detail. The properties are some
    of the very important elements while writing shaders. The properties allow the
    artist to set their own textures or other settings to customize the visual effects.
    You can tune the properties of the selected shader through Unity materials.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑`Properties`块。在编写着色器时，属性是一些非常重要的元素。属性允许艺术家设置他们自己的纹理或其他设置以自定义视觉效果。您可以通过Unity材质调整所选着色器的属性。
- en: 'Unity parses each shader code in order to find built-in structures. The `Properties`
    block is one of these built-in structures that Unity is looking for. Here is an
    example of the structure of the `Properties` block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unity会按顺序解析每个着色器代码，以查找内置结构。`Properties`块是Unity正在寻找的这些内置结构之一。以下是一个`Properties`块结构的示例：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each time you create a new property, you will need to name your variable. The
    variable name is used in the code of your shader, while the inspector GUI name
    will be shown in the Unity Editor. The type can be any one of the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你创建一个新属性时，你都需要给你的变量命名。变量名用于你的着色器代码中，而检查器GUI名称将在Unity编辑器中显示。类型可以是以下任何一个：
- en: '`Range (min, max)`: These are real numbers in the form of a slider from `min`
    to `max`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range (min, max)`: 这些是从`min`到`max`形式的滑块实数值'
- en: '`Color`: This opens the color picker in the Unity inspector for choosing the
    desired color value'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Color`: 这将在Unity检查器中打开颜色选择器，以便选择所需的颜色值'
- en: '`2D`: This is used for adding textures'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2D`: 这用于添加纹理'
- en: '`Rect`: This is a nonpower of two textures'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rect`: 这是一个非2的幂纹理'
- en: '`Cube`: This is a cube map texture'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cube`: 这是一个立方体贴图纹理'
- en: '`Float:` These are real values without the slider'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float:` 这些是没有滑块的实数值'
- en: '`Vector`: This is a four-component vector with real numbers'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector`: 这是一个包含实数的四分量向量'
- en: At the end of the `Properties` structure, we specified the default value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Properties`结构的末尾，我们指定了默认值。
- en: A custom diffuse lighting model
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个自定义的漫反射光照模型
- en: 'Before you write your own diffuse lighting model, we will consider our new
    properties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写自己的漫反射光照模型之前，我们将考虑我们的新属性：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to declare these new properties in our shader:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的着色器中声明这些新属性：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the announcement of the properties in the shader code, we can use these
    variables as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器代码中宣布属性之后，我们可以像以下示例中那样使用这些变量：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a result, you should have a shader as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该有一个如下的着色器：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s time to create your own diffuse lighting model. In most cases, no built-in
    lighting is well-suited for specific tasks in the game or application. Specific
    optimization problems require unique solutions. In order to override the built-in
    lighting functions you need to register, the `SubShader` block in the next line
    of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建你自己的漫反射光照模型了。在大多数情况下，内置的光照并不适合游戏或应用中的特定任务。特定的优化问题需要独特的解决方案。为了覆盖内置的光照函数，你需要注册，下一行代码中的`SubShader`块：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can describe our custom lighting function as shown in the following
    example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像以下示例中那样描述我们的自定义光照函数：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s systematically look at the fundamental elements. The `#pragma`
    directive specifies the name of the function to be used for lighting. We used
    the built-in feature called **Lambert** defined in the `Lighting.cginc` file,
    and now we specified the name of our function for future use. In establishing
    this lighting function, it is necessary to remember that the name of the function
    will eventually be formed using the first word of `Lighting + <Your Function Name>`,
    that is, for example if you decide to call a function `SunShine`, then the name
    of your lighting function will be `LightingSunShine`. There are three options
    to create your custom lighting functions that differ from each other by their
    input parameters as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们系统地查看基本元素。`#pragma`指令指定了用于光照的函数名称。我们使用了在`Lighting.cginc`文件中定义的内置功能**Lambert**，现在我们指定了我们的函数名称以供将来使用。在建立这个光照函数时，有必要记住，函数的名称最终将使用`Lighting
    + <Your Function Name>`的第一个单词来形成，例如，如果你决定将函数命名为`SunShine`，那么你的光照函数名称将是`LightingSunShine`。有三种创建自定义光照函数的方法，它们通过输入参数的不同而不同，如下所示：
- en: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float
    attenuation) {}`: You should use this function for forward rendering, when you
    don''t need the view direction value'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float
    attenuation) {}`: 当你不需要视图方向值时，你应该使用这个函数进行前向渲染'
- en: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float3
    viewDirection, float attenuation) {}`: You should use this function for forward
    rendering, when you need the view direction value'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float4 Lighting<YourName> (SurfaceOutput surface, float3 lightDirection, float3
    viewDirection, float attenuation) {}`: 当你需要视图方向值时，你应该使用这个函数进行前向渲染'
- en: '`float4 Lighting<YourName>_PrePass (SurfaceOutput surface, float4 light) {}`:
    You should use this function for deferred rendering'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float4 Lighting<YourName>_PrePass (SurfaceOutput surface, float4 light) {}`:
    你应该使用这个函数进行延迟渲染'
- en: 'Ultimately, you should get a shader as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您应该得到以下着色器：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A basic reflection environment
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本反射环境
- en: 'Next, let''s look at other ideas and techniques widely known in professional
    circles around the world that are used to write performance friendly shaders with
    nice visual effects. The following examples are based on environment reflections
    on your surface. A simple source code of this shader is shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在全世界专业圈子里广为人知的一些想法和技术，这些想法和技术被用来编写具有良好视觉效果的性能友好型着色器。以下示例基于您表面的环境反射。这个着色器的简单源代码如下：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Masked texture reflection
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遮罩纹理反射
- en: 'The next new shader implements a new technique that uses a texture to mask
    the reflection of your environment, and it is shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新着色器实现了一种新技术，它使用纹理来遮罩您环境的反射，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lighting model techniques
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灯光模型技术
- en: Let's consider a variety of techniques and methods of implementation of the
    lighting model, which, like the previous shaders, are used worldwide in the game
    industry as well as in movies and cartoons.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑各种灯光模型实现技术和方法，这些技术和方法，就像之前的着色器一样，在全球游戏产业以及电影和卡通中被广泛使用。
- en: The Lit sphere model
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 照明球体模型
- en: 'To begin, we would like to consider the `LitSphere` lighting model. The idea
    is very simple and straightforward—we should just use a 2D texture in order to
    completely bake our light. Alternatively, it is necessary to take into account
    and not forget that this technique is static and does not change the lighting
    up until the texture used for baking light is changed. This technique gives very
    high-quality lighting and is optimized enough, but it is not dynamic. In other
    words, it does not depend on the angle or distance from the camera or from the
    viewer that can be changed in real time, because this technique does not depend
    on the lighting in the scene. Let''s explore this shader as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想考虑`LitSphere`灯光模型。这个想法非常简单直接——我们只需使用一个2D纹理来完全烘焙我们的灯光。或者，有必要考虑到并不要忘记这个技术是静态的，并且不会改变灯光，直到用于烘焙灯光的纹理被更改。这项技术提供了非常高质量的灯光，并且优化得足够好，但它不是动态的。换句话说，它不依赖于可以实时改变的角度或距离（从摄像机或观众），因为这项技术不依赖于场景中的灯光。让我们按照以下方式探索这个着色器：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are many different techniques and approaches to create lighting models
    and other visual effects; we cannot put all the ideas and techniques into this
    book, as it is beyond the scope of this book. You can also implement your own
    new ideas and techniques; it depends on your imagination. The previous examples
    of different approaches for writing shaders are widely used by developers around
    the world to create high-quality rendering in real time, and for optimization.
    Also, you can write shaders that work with the model vertices, so you can very
    simply create shader that will play the waves animation from the primitive plane.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建灯光模型和其他视觉效果有许多不同的技术和方法；我们无法将所有想法和技术都放入这本书中，因为这超出了本书的范围。您也可以实现自己的新想法和技术；这取决于您的想象力。之前不同方法编写着色器的示例被世界各地的开发者广泛用于创建高质量的实时渲染，以及优化。此外，您还可以编写与模型顶点一起工作的着色器，这样您就可以非常简单地创建一个从原始平面播放波浪动画的着色器。
- en: Realistic rendering
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实感渲染
- en: 'Marcos Fajardo of *Solid Angle*—the company behind the renderer *Arnold*—noted
    that more and more production studios in the world have either already come to
    that, or are in the process of transition with the following quote:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Solid Angle*的Marcos Fajardo——这家公司是渲染器*Arnold*背后的公司——指出，世界上的越来越多的制作工作室要么已经到达那里，要么正在过渡到以下引言：'
- en: '*"The process is going on in the entire industry, and it''s something. I''ve
    been working with this for the past ten years or so, and I''m really glad to see
    that this is happening at last."*'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"整个行业都在进行这个过程，这是一件大事。我过去十年左右一直在做这件事，看到它最终发生我真的很高兴。"*'
- en: Fajardo can be called one of the greatest defenders and activists of global
    change in the industry. Solid Angle is really at the forefront of the large-scale
    movement to the path-traced GI with physically-plausible materials and lighting
    for production decisions (that is, when the budget is smaller and the time frame
    is more compressed).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Fajardo 可以被称为该行业全球变革最伟大的捍卫者和活动家之一。Solid Angle 真的是大规模运动的前沿，该运动将基于物理的材质和灯光的路径追踪GI用于生产决策（即，当预算较小且时间框架更紧凑时）。
- en: The basis of the popularity of the "honest" method is the desire to "catch two
    rabbits at once," simplify the lives of artists around the world and to achieve
    a more realistic picture.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “诚实”方法流行的基础是希望“一石二鸟”，简化全世界艺术家的生活，并实现更逼真的画面。
- en: With some older technology chains, artists can get the scene with a few hundred
    light sources (where each source is needed to fulfill its role, one for the highlight
    of a material and the second for the specular reflection on this material, the
    third and fourth for the glare and reflections on the second material, plus ten
    to simulate global illumination, and so on), with very complex shaders written
    by the developer with C++, the code was full of tricks and tweaks. Lighting designers
    often just sit, turning on and off lights, one after the other—it is easy to understand
    why some of them are so necessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些较老的技术链，艺术家可以通过几百个光源（其中每个光源都需要完成其角色，一个用于材料的突出显示，另一个用于该材料的镜面反射，第三个和第四个用于第二个材料的眩光和反射，再加上十个来模拟全局照明，等等）获得场景，开发者用C++编写了非常复杂的着色器，代码充满了技巧和调整。照明设计师通常只是坐着，依次打开和关闭灯光——很容易理解为什么他们中的一些人是如此必要的。
- en: Most companies do not count the fact that the introduction of natural light
    sources and materials make a quick render itself, but there is an expectation
    that this will greatly facilitate the work of the artist. An hour of work which,
    to be honest, is a few tens of times more expensive than an hour rendering.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公司并没有计算到引入自然光源和材料本身就能快速渲染的事实，但人们期望这将极大地简化艺术家的工作。实际上，一小时的这种工作比一小时的渲染要贵几十倍。
- en: Global illumination
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局照明
- en: During the, *Game Developers Conference* in 2014, which started on March 17
    in San Francisco, the company Unity Technologies introduced the fifth generation
    of its popular game engine Unity. One of the most important features that distinguishes
    it from the previous edition is a new system of global illumination in real time—Enlighten—implemented
    with the participation of experts from the British company, *Geomerics*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年3月17日于旧金山开始的*游戏开发者大会*期间，Unity Technologies公司推出了其流行的游戏引擎Unity的第五代产品。与上一版本相比，其中一个最重要的特点是实时全局照明的新系统——Enlighten，该系统由来自英国公司*Geomerics*的专家参与实施。
- en: '![Global illumination](img/9191OT_03_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![全局照明](img/9191OT_03_01.jpg)'
- en: Unity 5 is presented with support from WebGL standard web module optimization
    `asm.js`, physics engine NVIDIA PhysX 3.3, the system of creation and animation
    vegetation—SpeedTree, an advanced shader system, the preview function light maps
    in real time, and a cross-processed audio advertising network in Unity Cloud that
    facilitates the promotion of mobile games. In addition, the fifth version of the
    engine will be able to run in a 64-bit environment that significantly simplifies
    the workflow through a new multi-threaded scheduler, and provides you with the
    opportunity to make changes in real time and improve the system to create game
    resources (assets list) and an intuitive interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5展示了支持WebGL标准网络模块优化`asm.js`、物理引擎NVIDIA PhysX 3.3、植被创建和动画系统SpeedTree、高级着色器系统、实时预览光图功能，以及Unity
    Cloud中的跨平台音频广告网络，这有助于移动游戏的推广。此外，第五代引擎将能够在64位环境中运行，通过新的多线程调度器显著简化工作流程，并为你提供实时更改和改进创建游戏资源（资产列表）和直观界面的机会。
- en: '![Global illumination](img/9191OT_03_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![全局照明](img/9191OT_03_02.jpg)'
- en: The latest version of this toolkit, traditionally the best-selling in small
    teams of developers, is designed including large companies. This makes it a competitor
    to other high-tech new generation of game engines such as CryEngine and Unreal
    Engine 4\. Along with the fourth generation engine from Epic Games, it has recently
    signed another agreement with Mozilla, where Unity 5 can be used by developers
    of three-dimensional and two-dimensional games for browsers and mobile devices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本工具包的最新版本，传统上在小型开发者团队中是最畅销的，现在设计时也考虑到了大型公司。这使得它成为了CryEngine和Unreal Engine 4等高科技新一代游戏引擎的竞争对手。随着Epic
    Games的第四代引擎，它最近还与Mozilla签署了另一项协议，允许浏览器和移动设备上的三维和二维游戏开发者使用Unity 5。
- en: '![Global illumination](img/9191OT_03_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![全局照明](img/9191OT_03_03.jpg)'
- en: In Unity 5, developers will be able to view the coverage maps in real time using
    the ray tracing PowerVR from the company *Imagination Technologies*. This technique
    reduces the processing time, which gives a very good performance. Developers will
    be able to create a variety of materials from the real world with the new shader
    system in Unity 5.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 5中，开发者将能够使用来自公司*Imagination Technologies*的实时光线追踪PowerVR查看覆盖率图。这项技术减少了处理时间，从而提供了非常好的性能。开发者将能够使用Unity
    5中新的着色器系统从现实世界中创建各种材料。
- en: '**Global illumination** is the name of a series of algorithms used in three-dimensional
    graphics for more realistic simulation of light. These algorithms take into account
    not only the direct light from the source (direct illumination), but also reflected
    light from various surfaces (indirect illumination).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局照明**是用于三维图形中更真实地模拟光的一系列算法的名称。这些算法不仅考虑来自光源的直接光线（直接照明），还考虑来自各种表面的反射光线（间接照明）。'
- en: In theory, *reflection*, *refraction*, and *shadows* are examples of global
    illumination, because for them it is necessary to consider the effect of the simulation
    of one object to the other (in contrast to the case when the object is exposed
    to direct light). In practice, however, the simulation of diffuse reflection or
    caustics is called global illumination.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，*反射*、*折射*和*阴影*是全球照明的例子，因为对于它们来说，必须考虑一个对象对另一个对象模拟的影响（与对象暴露在直接光线下的情况相比）。然而，在实践中，漫反射或全息的模拟被称为全局照明。
- en: Images obtained by the application of global illumination algorithms often appear
    more realistic than those in the rendering process that apply only direct illumination
    algorithms. However, to calculate global illumination requires much more time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用全局照明算法获得的图像通常比仅应用直接照明算法的渲染过程中的图像更真实。然而，计算全局照明需要更多的时间。
- en: 'The following figure was processed only by direct illumination algorithms:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下图仅由直接照明算法处理：
- en: '![Global illumination](img/9191OT_03_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![全局照明](img/9191OT_03_04.jpg)'
- en: 'The following figure was processed by global illumination algorithms:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是通过全局照明算法处理的：
- en: '![Global illumination](img/9191OT_03_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![全局照明](img/9191OT_03_05.jpg)'
- en: Practicing in shader optimization
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器优化实践
- en: Now, it is time to discuss how we can optimize our shaders. Alternatively, it
    is time to consider the other methods, such as optimizing built-in data types,
    which can significantly reduce the overhead of the Unity shaders' memory. We consider
    Unity shaders optimization for all supported platforms without any exclusions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候讨论我们如何优化我们的着色器了。或者，是时候考虑其他方法了，例如优化内置数据类型，这可以显著减少Unity着色器内存的开销。我们考虑对所有支持的平台进行Unity着色器优化，没有任何排除。
- en: 'Very often, you will need to optimize shaders to achieve the same visual effect,
    but with a smaller number of textures for example. Primarily, when optimizing
    shader code, we would like to direct your attention to the types of variables.
    If you are willing to sacrifice the accuracy of calculations in order to decrease
    the quality to improve performance, then you should use the `half` or `fixed`
    variable types instead of `float`. As an example, you can use a `half` type of
    variable everywhere in your shader code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，你需要优化着色器以实现相同的效果，但使用更少的纹理，例如。首先，当优化着色器代码时，我们希望将你的注意力引向变量的类型。如果你愿意牺牲计算的精度以降低质量来提高性能，那么你应该使用`half`或`fixed`变量类型而不是`float`。例如，你可以在你的着色器代码的任何地方使用`half`类型的变量：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also replace `float` with `half` in the following statement:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在以下语句中将`float`替换为`half`：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`float`: These variables have 32 bits precision'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这些变量具有32位精度'
- en: '`half`: These variables have 16 bits precision'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`half`：这些变量具有16位精度'
- en: '`fixed`: These variables have 11 bits precision'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed`：这些变量具有11位精度'
- en: 'For example, let''s optimize our previous shader code `CarVehicle.shader` as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们按照以下方式优化我们之前的着色器代码`CarVehicle.shader`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To understand how to develop shaders faster and better, you must understand
    that this can only be achieved by full optimization, using a variety of techniques
    and approaches. Let''s divide our shader optimization process into the following
    three categories:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何更快、更好地开发着色器，你必须明白这只能通过全面优化，使用各种技术和方法来实现。让我们将我们的着色器优化过程分为以下三个类别：
- en: Optimization of memory used for variables
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量内存优化
- en: Optimization of the number and size of used textures
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化使用的纹理的数量和大小
- en: Optimization of computational algorithms
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算算法优化
- en: All the mentioned points have been already discussed. Some of the ideas of how
    to optimize your shaders have been already considered earlier in this chapter,
    and we will show some more interesting approaches and techniques. We hope that
    most of the methods, techniques, approaches, and ideas of this book will greatly
    help you in production to achieve the desired quality and performance at the same
    time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的所有点都已经讨论过了。关于如何优化你的着色器的一些想法已经在本章前面考虑过了，我们将展示一些更有趣的方法和技术。我们希望这本书中的大多数方法、技术、方法和想法将极大地帮助你在生产中同时实现所需的质量和性能。
- en: Also, while optimizing shaders you need to remember and know that the code should
    be as small as possible. This means that nothing unnecessary should be in your
    code. Many of the ideas described in the previous chapters, especially in the
    preceding fourth chapter, which talked about code optimization in C# and JavaScript,
    are well suited to optimize your shader code. Also, we want you to note that the
    frequency of execution of your shader code greatly affects the performance. Very
    often, shader developers use very good techniques in order to optimize their shaders.
    They prefer using vertex shaders instead of pixel shaders; this will greatly improve
    your performance in most cases, as there are significantly more pixels than vertices.
    Hence, processing the pixel shader frequency of the execution code will be much
    greater than for vertices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在优化着色器时，你需要记住并知道代码应该尽可能小。这意味着你的代码中不应该有任何不必要的部分。前几章中描述的许多想法，尤其是在前面第四章中关于C#和JavaScript代码优化的讨论，非常适合优化你的着色器代码。此外，我们希望你注意，你的着色器代码的执行频率极大地影响了性能。非常常见的是，着色器开发者使用非常好的技术来优化他们的着色器。他们更倾向于使用顶点着色器而不是像素着色器；这在大多数情况下会大大提高你的性能，因为像素的数量远多于顶点。因此，处理像素着色器执行频率的代码将远大于顶点。
- en: 'Let''s also consider the directives that may well optimize your shaders:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑可能优化你的着色器的指令：
- en: '`approxview`: This approximation is good enough in many cases. You should use
    this directive when you need to get the normalized view direction per vertex instead
    of per pixel.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`approxview`: 在许多情况下，这种近似已经足够好了。当你需要获取每个顶点的归一化视图方向而不是每个像素的视图方向时，你应该使用这个指令。'
- en: '`halfasview`: This will be computed and normalized per vertex halfway between
    view and light directions (half vector), and the lighting function will receive
    a `half` vector as a parameter instead of view vector.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`halfasview`: 这将在视图和光源方向之间（半向量）计算并归一化，并且光照函数将接收一个`half`向量作为参数而不是视图向量。'
- en: '`noforwardadd`: In the event of rendering shaders in one pass, even with multiple
    lights, and in the event of making your shader smaller, this directive is the
    best choice for you. The shader will support only one directional light in forward
    rendering. The rest of the lights can still have an effect like vertex lights
    or spherical harmonics. The rest of the lights can be used for spherical harmonics
    or for vertex light effects.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noforwardadd`: 在单次渲染着色器的情况下，即使有多个光源，以及当你想要使着色器更小的时候，这个指令是你最好的选择。这个着色器将只支持前向渲染中的单一方向光。其余的光源仍然可以像顶点光或球谐函数那样产生影响。其余的光源可以用于球谐函数或顶点光效果。'
- en: '`exclude_path:prepass`: The shader that uses this directive will not accept
    any custom lighting from the deferred renderer.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclude_path:prepass`: 使用这个指令的着色器将不接受来自延迟渲染器的任何自定义光照。'
- en: '`noambient`: This directive should be used in the event of deactivating spherical
    harmonics and ambient lights on your shader. This can slightly enhance your performance.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noambient`: 当你在着色器中禁用球谐函数和环境光时，应该使用这个指令。这可以略微提高你的性能。'
- en: '`nolightmap`: This directive disables Unity''s internal light mapping system.
    In other words, it does not perform a light mapping check.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nolightmap`: 这个指令禁用了Unity的内部光照贴图系统。换句话说，它不会执行光照贴图检查。'
- en: '**Alpha testing** on mobile devices is very expensive, so you should use transparent
    shaders on mobile devices very accurately. You must use the alpha testing only
    when necessary. For example, let''s cover optimized shader as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Alpha测试**在移动设备上非常昂贵，因此你应该在移动设备上非常精确地使用透明着色器。你必须只在必要时使用Alpha测试。例如，让我们这样覆盖优化的着色器：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Best case practice
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: After our journey into the world of diverse ideas, approaches, and techniques
    in the field of lighting calculations, let's look at the best practice in order
    to maintain many different shaders easily. Let's consider the possibility of reusability
    of our shader code; for example, various lighting functions in Unity. In order
    to avoid writing the same code for the same lighting function each time for a
    new shader, it's best to write the code lighting function once and then just use
    this in any shader if necessary, as programmers use different frameworks and libraries.
    This practice will help you create a framework for your shaders, which will greatly
    facilitate easy development and effortless shader maintenance. In the previous
    examples, we used built-in `CgIncludes` files such as `Lambert` and `BlinnPhong`
    lighting functions. Unity created these lighting models for us. Unity helps us
    reduce our efforts while writing performance-friendly and nice quality shaders.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索了照明计算领域中的各种想法、方法和技术之后，让我们来看看最佳实践，以便轻松维护许多不同的着色器。让我们考虑我们的着色器代码的可重用性；例如，Unity
    中的各种照明函数。为了避免每次为新的着色器编写相同的照明函数代码，最好是将照明函数代码编写一次，并在必要时在任何着色器中使用它，因为程序员使用不同的框架和库。这种做法将帮助您为您的着色器创建一个框架，这将极大地促进轻松开发和轻松的着色器维护。在前面的示例中，我们使用了内置的
    `CgIncludes` 文件，如 `Lambert` 和 `BlinnPhong` 照明函数。Unity 为我们创建了这些照明模型。Unity 帮助我们减少编写性能友好且质量上乘的着色器的努力。
- en: 'You can view the code embedded in Unity built-in `CgIncludes` files, which
    are located inside a directory called `CgIncludes`. Without these files, it will
    be much harder to write shaders in Unity. That''s why Unity surface shaders are
    so efficient. Let''s create our own `CgInclude` file as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看 Unity 内置 `CgIncludes` 文件中嵌入的代码，这些文件位于名为 `CgIncludes` 的目录中。没有这些文件，在 Unity
    中编写着色器将会困难得多。这就是为什么 Unity 表面着色器如此高效。让我们按照以下方式创建自己的 `CgInclude` 文件：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s consider the code for the next shader as follows, where you can
    see how to use your `CgInclude` file with your lighting function, and how you
    can declare your variable `_YourColorVariable`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑下一个着色器的代码如下，您可以看到如何使用您的 `CgInclude` 文件与照明函数一起使用，以及您如何声明变量 `_YourColorVariable`：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thus, you can create a proper framework of your own shaders. Also, you can use
    examples from this chapter and place all your code in the form of `CgIncludes`
    files. This will greatly help you avoid repetitions in the code, which will greatly
    simplify the development of shaders and also facilitate their optimization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以创建自己的着色器框架。您还可以使用本章中的示例，并将所有代码以 `CgIncludes` 文件的形式放置。这将极大地帮助您避免代码重复，极大地简化着色器开发，并促进它们的优化。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a lot about writing shaders and their optimization.
    We started with a simple shader code and examined the fundamental elements in
    Unity surface shaders. Next, we wrote our custom diffuse lighting model. Also,
    we examined global illumination. We explored the various optimization techniques
    by changing the shader variable types, as well as by writing specific directives.
    Towards the end of this chapter, we covered the best case practice while developing
    shaders using `CgIncludes` files, and learned how to use its code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了大量关于编写着色器和它们的优化知识。我们从简单的着色器代码开始，检查了 Unity 表面着色器中的基本元素。接下来，我们编写了自己的自定义漫反射照明模型。我们还探讨了全局照明。我们通过更改着色器变量类型以及编写特定指令来探索各种优化技术。在本章的结尾，我们介绍了使用
    `CgIncludes` 文件开发着色器的最佳实践，并学习了如何使用其代码。
- en: The next chapter will cover legacy and Mecanim animation systems in Unity 5\.
    You will also develop a simple custom sprite animation system and explore how
    to import, set up, and play audio files inside your scripts in Unity 5\. At the
    end of the next chapter, you will explore the physics and particle systems in
    Unity 5.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Unity 5 中的传统和 Mecanim 动画系统。你还将开发一个简单的自定义精灵动画系统，并探索如何在 Unity 5 中导入、设置和播放音频文件。在下一章的结尾，你将了解
    Unity 5 中的物理和粒子系统。
