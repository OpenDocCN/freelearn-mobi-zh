["```swift\nUIView.animate(withDuration: 0.8) {\n    self.cell.familyNameLabel.alpha = 1.0\n}\n```", "```swift\n@IBOutlet weak var contactImageView: UIImageView! {\n    didSet {\n        contactImageView.alpha = 0\n    }\n}\n```", "```swift\nUIView.animate(withDuration: 0.8) {\n    self.contactImageView.alpha = 1\n}\n```", "```swift\nguard let cell = collectionView.cellForItem(at: indexPath) as? ContactCell else {\n    return\n}\n```", "```swift\nUIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {\n    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)\n})\n```", "```swift\nUIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {\n    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)\n}, completion: { finished in\n    UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {\n        cell.conatctImageView.transform = CGAffineTransform.identity\n    })\n})\n```", "```swift\nUIView.animate(withDuration: 0.1, delay:       0, options: [.curveEaseOut], animations: {\n    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)\n}, completion: { finished in\n    UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseIn], animations: {\n        cell.conatctImageView.transform = CGAffineTransform.identity\n    }, completion: { [weak self] finished in\n        self?.performSegue(withIdentifier: \"detailViewSegue\", sender:self)\n    })\n})\n```", "```swift\nlet downAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeOut) {\n    cell.conatctImageView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)\n}\n\nlet upAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeIn) {\n    cell.conatctImageView.transform = CGAffineTransform.identity\n}\n\ndownAnimator.addCompletion { _ in\n    upAnimator.startAnimation()\n}\n\nupAnimator.addCompletion { [weak self] _ in\n    self?.performSegue(withIdentifier: \"detailViewSegue\", sender: self)\n}\n\ndownAnimator.startAnimation()\n```", "```swift\n@IBOutlet var drawer: UIView!\nvar isDrawerOpen = false\nvar drawerPanStart: CGFloat = 0\nvar animator: UIViewPropertyAnimator?\n```", "```swift\nextension DetailsViewController {\n    @IBAction func toggleDrawerTapped() {\n    }\n}\n```", "```swift\nlet panRecognizer = UIPanGestureRecognizer(target: self, action:#selector(didPanOnDrawer(recognizer:)))\ndrawer.addGestureRecognizer(panRecognizer)\n```", "```swift\n@objc func didPanOnDrawer(recognizer: UIPanGestureRecognizer) {\n}\n```", "```swift\nanimator = UIViewPropertyAnimator(duration: 1, curve: .easeOut) { [unowned self] in\n    if self.isDrawerOpen {\n        self.drawer.transform = CGAffineTransform.identity\n    } else {\n        self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)\n    }\n}\n\nanimator?.addCompletion { [unowned self] _ in \n    self.animator = nil\n    self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)\n}\n\nanimator?.startAnimation()\n```", "```swift\nprivate func setUpAnimation() {\n\n    guard animator == nil || animator?.isRunning == false else { return }\n\n        animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut) { [unowned self] in\n        if self.isDrawerOpen {\n            self.drawer.transform = CGAffineTransform.identity\n        } else {\n            self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)\n        }\n    }\n\n    animator?.addCompletion { [unowned self] _ in \n        self.animator = nil\n        self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)\n    }\n}\n```", "```swift\n@IBAction func toggleDrawerTapped() {\n    setUpAnimation()\n    animator?.startAnimation()\n}\n```", "```swift\nswitch recognizer.state {\ncase .began:\n    setUpAnimation()\n    animator?.pauseAnimation()\n    drawerPanStart = animator?.fractionComplete ?? 0\ncase .changed:\n    if self.isDrawerOpen {\n        animator?.fractionComplete = (recognizer.translation(in: drawer).y / 305) + drawerPanStart\n    } else {\n        animator?.fractionComplete = (recognizer.translation(in: drawer).y / -305) + drawerPanStart\n    }\ndefault:\n    drawerPanStart = 0\n    let timing = UICubicTimingParameters(animationCurve: .easeOut)\n    animator?.continueAnimation(withTimingParameters: timing, durationFactor: 0)\n\n    let isSwipingDown = recognizer.velocity(in: drawer).y > 0\n    if isSwipingDown == !isDrawerOpen {\n        animator?.isReversed = true\n    }\n}\n```", "```swift\nguard animator == nil || animator?.isRunning == false else {\n    return\n}\n\nlet spring: UISpringTimingParameters\nif self.isDrawerOpen {\n    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: 10))\n} else {\n    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: -10))\n}\n\nanimator = UIViewPropertyAnimator(duration: 1, timingParameters: spring)\n\nanimator?.addAnimations { [unowned self] in\n    if self.isDrawerOpen {\n        self.drawer.transform = CGAffineTransform.identity\n    } else {\n        self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)\n    }\n}\nanimator?.addCompletion { [unowned self] _ in self.animator = nil\n    self.isDrawerOpen = !(self.drawer.transform == CGAffineTransform.identity)\n}\n```", "```swift\ndrawerPanStart = 0\nlet currentVelocity = recognizer.velocity(in: drawer)\nlet spring = UISpringTimingParameters(dampingRatio: 0.8,\ninitialVelocity: CGVector(dx: 0, dy: currentVelocity.y))\n\nanimator?.continueAnimation(withTimingParameters: spring, durationFactor: 0)\nlet isSwipingDown = currentVelocity.y > 0\nif isSwipingDown == !isDrawerOpen {\n    animator?.isReversed = true\n}\n```", "```swift\nvar animator: UIDynamicAnimator?\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    let balls: [UIDynamicItem] = [ball1, ball2, ball3]\n    animator = UIDynamicAnimator(referenceView: view)\n\n    let gravity = UIGravityBehavior(items: balls)\n    animator?.addBehavior(gravity)\n}\n```", "```swift\nvar nextAnchorX = 250\n\nfor ball in balls {\n    let anchorPoint = CGPoint(x: nextAnchorX, y: 0)\n    nextAnchorX -= 30\n    let attachment = UIAttachmentBehavior(item: ball, attachedToAnchor: anchorPoint)\n    attachment.damping = 0.7\n    animator?.addBehavior(attachment)\n}\n```", "```swift\nlet collisions = UICollisionBehavior(items: balls)\nanimator?.addBehavior(collisions)\n```", "```swift\nlet dynamicBehavior = UIDynamicItemBehavior()\ndynamicBehavior.addItem(ball)\ndynamicBehavior.density = CGFloat(arc4random_uniform(3) + 1)\ndynamicBehavior.elasticity = 0.8\nanimator?.addBehavior(dynamicBehavior)\n```", "```swift\n@IBOutlet weak var ball1: UIView! {\n    didSet {\n\n    // Make a ball\n    ball1.layer.cornerRadius = ball1.frame.size.width/2\n    ball1.clipsToBounds = true\n\n    // Cool gradient effect!\n    let gradient = CAGradientLayer()\n    gradient.frame = ball1.bounds\n    gradient.colors = [UIColor.systemBlue.cgColor, UIColor.systemTeal.cgColor]\n    ball1.layer.insertSublayer(gradient, at: 0)\n\n    }\n}\t\n```", "```swift\n    extension CustomAnimator: UIViewControllerAnimatedTransitioning {\n    }\n    ```", "```swift\nfunc transitionDuration(using transitionContext:   UIViewControllerContextTransitioning?) -> TimeInterval {\n    return 0.6\n}\n```", "```swift\nfunc animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n\n    // 1\n    guard let toViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) else {\n        return        \n    }\n    // 2\n    let transitionContainer = transitionContext.containerView\n\n    // 3\n    var transform = CGAffineTransform.identity\n    transform = transform.concatenating(CGAffineTransform(scaleX: 0.6, y: 0.6))\n    transform = transform.concatenating(CGAffineTransform(translationX: 0, y: -200))\n\n    toViewController.view.transform = transform\n    toViewController.view.alpha = 0\n\n    // 4\n    transitionContainer.addSubview(toViewController.view)\n\n    // 5\n    let animationTiming = UISpringTimingParameters(dampingRatio: 0.5,\n                                                   initialVelocity: CGVector(dx: 1, dy: 0))\n\n    let animator = UIViewPropertyAnimator(duration: transitionDuration(using: transitionContext), timingParameters: animationTiming)\n\n    animator.addAnimations {\n        toViewController.view.transform = CGAffineTransform.identity\n        toViewController.view.alpha = 1\n    }\n\n    // 6\n    animator.addCompletion { finished in\n        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)\n    }\n\n    // 7\n    animator.startAnimation()\n\n}\n```", "```swift\nextension TransitionViewController: UIViewControllerTransitioningDelegate {\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return CustomAnimator()\n    }\n\n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return nil\n    }\n}\n```", "```swift\n    public required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n        transitioningDelegate = self\n    }\n```"]