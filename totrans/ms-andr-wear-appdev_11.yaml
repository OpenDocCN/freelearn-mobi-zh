- en: Chapter 11.  Advanced Features and Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 高级特性和概念
- en: '*"Man is a genius when he is dreaming."                                    
              - Akira Kurosawa*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"当人做梦时，他就是天才。" —— 黑泽明'
- en: In this chapter, we introduce the design concerns and API features related to
    making apps run as if they were always on. We develop an activity to demonstrate
    the always-on capability. We then touch upon debugging wear apps over Bluetooth
    connections and conclude with a preview of Android Wear 2.0.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与使应用始终运行相关的设计关注点和API功能。我们开发了一个活动来演示始终在线的能力。然后我们简要介绍了通过蓝牙连接调试可穿戴应用，并以Android
    Wear 2.0的预览结束。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code accompanying this chapter is available for reference on GitHub ([https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11)).
    Note that for the sake of brevity, code snippets are only included as needed.
    The reader is encouraged to download the referenced code from GitHub and follow
    along as they progress through the chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上参考（[https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11)）。请注意，为了简洁起见，代码片段仅按需包含。鼓励读者从GitHub下载引用的代码，并在阅读本章时跟随进度。
- en: Keeping the watch running
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持手表运行
- en: You may recall our discussion of watch faces in the previous chapter wherein
    a watch face starts out running in interactive mode. As the screen times out,
    the watch face continues to run as the device goes into its power-saving ambient
    mode.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们在上一章中关于表盘的讨论，其中表盘最初以交互模式运行。当屏幕超时后，表盘将继续运行，因为设备进入了省电的环境模式。
- en: While this feature, meaning the watch face's always-on capability, is inherent
    to watch faces—we don't want our watch to slack off when we want the time—it is
    not necessarily inherent to all wearable apps. For instance, if we had our `todo`
    app or `Step counter` app active, it would only be a matter of time before the
    screen timed out and rendered the watch face. If we then wanted to return to our
    app, we would have to interact with our wearable device to snap it out of ambient
    mode and bring up our last used activity or app. We can imagine scenarios where
    this can be a source of user frustration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个功能，即表盘的始终在线能力，是表盘固有的——我们不希望在我们需要看时间时，我们的手表偷懒——但这并不一定适用于所有可穿戴应用。例如，如果我们有一个`todo`应用或`Step
    counter`应用处于活动状态，那么屏幕超时并使表盘失效只是时间问题。如果我们想回到我们的应用，我们就必须与我们的可穿戴设备交互，将其从环境模式中唤醒，并显示我们最后使用的活动或应用。我们可以想象出这种情况可能会成为用户挫败感的来源。
- en: Fortunately, if our devices are running Android version 5.1 or higher, we can
    harness the power of the Android Wear APIs to conserve power during the execution
    of our wearable apps. These devices allow apps to remain in the foreground while
    still conserving battery power. Apps can be coded to control what is displayed
    in ambient mode even as they continue fulfilling their primary purpose, whatever
    that may be. Such apps are, in effect, always on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果我们的设备正在运行Android版本5.1或更高版本，我们可以利用Android Wear API在执行我们的可穿戴应用期间节省电量。这些设备允许应用在保持前台的同时仍然节省电量。应用可以被编码来控制即使在继续履行其主要目的的同时，在环境模式中显示的内容。这样的应用实际上就是始终在线的。
- en: Making an app to stay always on
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作始终在线的应用
- en: 'Here are some of the things we need to do and/or keep in mind when looking
    to enable ambient mode for our wearable apps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为我们的可穿戴应用启用环境模式时，以下是一些我们需要做和/或需要注意的事情：
- en: Our SDK should be updated to include the Android 5.1 or higher platform as this
    version provides activities with ambient mode support. See the *Android SDK Packages*
    section in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2.  Setting up the Development
    Environment"), *Setting up Development Environment on Android Studio*, for more
    information.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的SDK应该更新到包括Android 5.1或更高版本的平台，因为这个版本为活动提供了环境模式支持。有关更多信息，请参阅[第2章](part0020.xhtml#aid-J2B81
    "第2章. 在Android Studio上设置开发环境")中的*Android SDK包*部分，*在Android Studio上设置开发环境*。
- en: We must set our manifest `targetSdkVersion` to API level 22 or higher (that
    is, version 5.1).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须将我们的清单`targetSdkVersion`设置为API级别22或更高（即版本5.1）。
- en: We may choose to provide backward compatibility for devices running an Android
    version prior to 5.1 by specifying a `minSdkVersion` attribute. By doing so, the
    activities that support ambient mode will automatically fall back by returning
    to the home screen and exit the activity.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择通过指定`minSdkVersion`属性为设备运行Android 5.1之前版本提供向后兼容性。这样做的话，支持环境模式的活动将自动回退到主屏幕并退出活动。
- en: Our activities should extend the `WearableActivity` API class so as to inherit
    all the methods needed to enable ambient mode.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的活动应该扩展`WearableActivity` API类，以便继承启用环境模式所需的所有方法。
- en: We should invoke the `setAmbientEnabled()` method in the`onCreate()` listener
    of our activity.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在活动的`onCreate()`监听器中调用`setAmbientEnabled()`方法。
- en: We should have a clear understanding of the transitions between interactive
    and ambient mode and the relevant listeners that are called during those transitions,
    as shown in the figure at the end of this section.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该清楚地理解交互式和环境模式之间的转换以及在这些转换期间调用的相关监听器，如图中本节末尾所示。
- en: We should pay special attention to updating the activity UI in the ambient mode
    to use a basic layout and a minimal palette of colors to maximize better power
    conservation.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该特别注意在环境模式下更新活动UI，使用基本布局和最小化的颜色调色板，以最大限度地节约电力。
- en: We should try to update the activity UI using a consistent layout so that the
    transition between interactive and ambient modes appears as seamless as possible
    to the user.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该尝试使用一致的布局来更新活动UI，以便用户在交互式和环境模式之间的转换看起来尽可能无缝。
- en: We should exercise care not to update the screen too frequently when in ambient
    mode. Remember that the whole point of the ambient mode is to save power. Updating
    the activity UI more frequently than 10 seconds can be a source of power drainage
    and be counter-productive to enabling ambient mode altogether. If it does become
    necessary to perform more frequent updates due to the nature of the app (as with
    mapping or fitness), consider the use of the API's `AlarmManager` class ([https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境模式下，我们应该小心不要过于频繁地更新屏幕。记住，环境模式的全局目标就是节省电力。如果更新活动UI的频率超过10秒，可能会成为电力消耗的来源，并且对启用环境模式整体上起到反作用。如果由于应用性质（如地图或健身）需要更频繁地更新，可以考虑使用API的`AlarmManager`类（[https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)）。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth repeating that devices running a version of Android prior to 5.1
    (API Level 22) may not have access to the always-on capabilities of the newer
    APIs, but they should still run these apps without errors provided we specify
    a `minSdkVersion` attribute of 20 or higher in the manifest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重复的是，运行Android 5.1（API级别22）之前版本的设备可能无法访问新API的始终开启功能，但只要我们在清单中指定`minSdkVersion`属性为20或更高，它们仍然可以无错误地运行这些应用。
- en: 'Consider the following diagram, depicting the update in the UI activity of
    the screen:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表，展示了屏幕UI活动更新的情况：
- en: '![Making an app to stay always on](img/image00223.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![制作始终开启的应用](img/image00223.jpeg)'
- en: An always running step counter
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终运行计步器
- en: Now, let's demonstrate everything we presented in the previous section in practice
    by augmenting our step counter from [Chapter 7](part0051.xhtml#aid-1GKCM1 "Chapter 7. 
    Voice Interactions, Sensors, and Tracking"), *Voice Interactions, Sensors, and
    Tracking*, to be always on. Let's dive right in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将我们的计步器从[第7章](part0051.xhtml#aid-1GKCM1 "第7章。语音交互、传感器和追踪")，*语音交互、传感器和追踪*，增强为始终开启，来实际演示之前章节中介绍的所有内容。让我们直接进入正题。
- en: The Android manifest file
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android清单文件
- en: 'The first thing to do is to update the `AndroidManifest.xml` file and set up
    the `StepCounterActivity` class to have its `launchMode` set to `singleInstance`.
    This is necessary in order to update the screen more than once per minute in ambient
    mode. Not doing so will cause the `AlarmManager` class to launch an intent to
    open a new activity every time the alarm is triggered rather than reusing the
    same (already active) activity. Here is the snippet from the file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是更新`AndroidManifest.xml`文件，并将`StepCounterActivity`类的`launchMode`设置为`singleInstance`。这是在环境模式下每分钟更新屏幕多次所必需的。如果不这样做，`AlarmManager`类会在每次闹钟触发时启动一个意图来打开一个新的活动，而不是重用同一个（已经激活的）活动。以下是文件中的片段：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As soon as we launch our step counter, we see a colorful background image and
    a display showing the number of steps taken so far since a reboot of the device,
    as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动计步器，我们就会看到一个多彩的背景图像和一个显示自设备重启以来所走的步数的显示屏，如下面的截图所示：
- en: '![The Android manifest file](img/image00224.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Android清单文件](img/image00224.jpeg)'
- en: The StepCounterActivity class
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StepCounterActivity类
- en: This activity does the bulk of the work for our step counter. We modify the
    `onCreate()` method with a call to the `setAmbientEnabled()` method setting it
    to true. We also define a helper method, `refreshDisplayAndSetNextUpdate()`, that
    we call from our `onCreate()` listener, as well as the `onEnterAmbient()` and
    `onUpdateAmbient()` listeners. A call to the `isAmbient()` method determines whether
    we use the value from the ambient interval or the active interval. Furthermore,
    in ambient mode, we remove the background, make the pixels black, and paint the
    data with a white foreground. Maximizing the use of black and minimizing the use
    of white directly contributes to battery power conservation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动为我们计步器做了大部分工作。我们通过调用`setAmbientEnabled()`方法将`onCreate()`方法修改为将其设置为true。我们还定义了一个辅助方法`refreshDisplayAndSetNextUpdate()`，我们从`onCreate()`监听器以及`onEnterAmbient()`和`onUpdateAmbient()`监听器中调用它。对`isAmbient()`方法的调用确定我们是否使用环境间隔值或活动间隔值。此外，在环境模式下，我们移除背景，使像素变黑，并用白色前景绘制数据。最大化使用黑色并最小化使用白色直接有助于节省电池电量。
- en: 'The following code listing presents the `StepCounterActivity` class for our
    step counter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表展示了我们的计步器`StepCounterActivity`类：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As a result of the preceding changes, this is how the step counter shows up
    in ambient mode now:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的更改，计步器现在在环境模式下的显示如下：
- en: '![The StepCounterActivity class](img/image00225.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![StepCounterActivity类](img/image00225.jpeg)'
- en: Debugging wearable apps
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试可穿戴应用
- en: 'An important and extremely useful tool available to developers is the ability
    to set up debugging for our wearable apps running on our wearable device. We have
    the ability to run debug commands from our development machine to troubleshoot
    our wearable apps and have any debug output from the wearable be sent over to
    the handheld, which in turn must be connected to the development machine. Some
    setup is required in order to accomplish this. The general connectivity between
    devices is as shown in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用的一个重要且极其有用的工具是设置我们运行在可穿戴设备上的可穿戴应用的调试。我们有从我们的开发机器运行调试命令的能力，以排除我们的可穿戴应用的故障，并将任何调试输出发送到手持设备，然后手持设备必须连接到开发机器。为了完成此操作，需要进行一些设置。设备之间的一般连接性如下所示：
- en: '![Debugging wearable apps](img/image00226.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![调试可穿戴应用](img/image00226.jpeg)'
- en: The greatest payoff here is that we don't need to run two separate USB connections
    from the development machine—one to the handheld and the other to the wearable
    device. Instead, we can deploy and debug code straight to the handheld device
    from the development machine using a Bluetooth connection. This becomes especially
    helpful when such troubleshooting needs to be performed repetitively during development.
    Without this feature, we would have to endure the clutter of too many cables,
    and we know we can do without that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的好处是我们不需要从开发机器运行两个独立的USB连接——一个连接到手持设备，另一个连接到可穿戴设备。相反，我们可以通过蓝牙连接直接从开发机器部署和调试代码到手持设备。这在开发过程中需要重复进行故障排除时特别有帮助。没有这个功能，我们就必须忍受过多电缆的混乱，而我们知道我们可以没有这些。
- en: Device setup
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备设置
- en: Debugging must be set up on the companion handheld as well as the wearable device,
    albeit a bit differently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 调试必须在伴侣手持设备和可穿戴设备上设置，尽管设置方式略有不同。
- en: USB debugging on the handheld app
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手持应用上的USB调试
- en: 'Follow the steps mentioned to perform the debugging on the handheld app:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在手持应用上执行调试：
- en: Launch the **Settings** screen in the handheld device and make sure the USB
    debugging is turned on in **Developer** **options**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手持设备上启动**设置**屏幕，并确保在**开发者**选项中已开启**USB调试**。
- en: Locate and launch the **Developer options**. Alternatively, you may have to
    tap the **About Phone** menu, scroll down the build number and tap it seven times
    to activate the **Developer Options** menu item. Tap it once it is available.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并启动**开发者选项**。或者，你可能需要点击**关于手机**菜单，向下滚动到构建号并点击它七次以激活**开发者选项**菜单项。一旦可用，点击一次。
- en: 'Choose to enable **USB debugging**, as shown in the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，选择启用**USB调试**：
- en: '![USB debugging on the handheld app](img/image00227.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的USB调试](img/image00227.jpeg)'
- en: Bluetooth debugging on the wearable app
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可穿戴应用上的蓝牙调试
- en: 'Follow the steps mentioned here to perform debugging on the wearable app using
    Bluetooth:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此处提到的步骤，使用蓝牙在可穿戴应用上进行调试：
- en: Launch the **Wear** menu by tapping the home screen twice.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击主屏幕两次来启动**Wear**菜单。
- en: Launch **Settings**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动**设置**。
- en: Locate and launch **Developer Options**. Alternatively, you may have to tap
    **About Phone**, scroll down the build number and tap it seven times to activate
    the **Developer Options** menu item. Tap it once it is available.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并启动**开发者选项**。或者，你可能需要点击**关于手机**，向下滚动到构建号并点击它七次以激活**开发者选项**菜单项。一旦可用，点击一次。
- en: Choose to enable **Debugging over Bluetooth** option.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择启用**通过蓝牙进行调试**选项。
- en: Session setup on the handhelds apps
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手持设备应用上的会话设置
- en: 'Perform the following steps to set up the session in handheld apps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在手持设备应用中设置会话：
- en: Launch the Android Wear companion app on the handheld.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手持设备上启动Android Wear伴侣应用。
- en: Launch **Settings** from the menu in the top-right corner:![Session setup on
    the handhelds apps](img/image00228.jpeg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右上角的菜单中选择**设置**：![手持设备应用上的会话设置](img/image00228.jpeg)
- en: 'Choose to enable the **Debugging over Bluetooth** option. Note that the following
    message shows up on your handheld under that option:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择启用**通过蓝牙进行调试**选项。注意，在手持设备上该选项下会显示以下消息：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Session setup on the handhelds apps](img/image00229.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的会话设置](img/image00229.jpeg)'
- en: This is because we are yet to connect your handheld to your development machine.
    Let's do that next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们尚未将你的手持设备连接到你的开发机器。让我们接下来做这件事。
- en: 'Let''s now connect the handheld to our development machine using a USB cable,
    and type the following at the `adb` command prompt. We use an arbitrary port `4444`,
    we could use any available port:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用USB线将手持设备连接到我们的开发机器，并在`adb`命令提示符下输入以下内容。我们使用一个任意的端口`4444`，我们可以使用任何可用的端口：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the companion app on the handheld, you should now see the following under
    the **Debugging over Bluetooth** option:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在手持设备的伴侣应用中，你现在应该在**通过蓝牙进行调试**选项下看到以下内容：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Session setup on the handhelds apps](img/image00230.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的会话设置](img/image00230.jpeg)'
- en: 'We have thus completed setting up a debugging session for our wearable. After
    the successful connection, we see a notification shown as follows on the wearable
    device:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了为我们的可穿戴设备设置调试会话。在成功连接后，我们在可穿戴设备上看到如下通知：
- en: '![Session setup on the handhelds apps](img/image00231.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的会话设置](img/image00231.jpeg)'
- en: Now, let's test it all out by executing some debug commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行一些调试命令来测试一下。
- en: 'Note that if we execute the `adb devices` command at the `adb` command prompt,
    we should see our wearable device show up as `localhost:4444`. We can now execute
    the `adb` commands to debug our application, using the following format:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想在`adb`命令提示符下执行`adb devices`命令，我们应该看到我们的可穿戴设备显示为`localhost:4444`。现在我们可以使用以下格式执行`adb`命令来调试我们的应用程序：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider following command, for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下命令：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the developer options in the wearable device, we can see that the **ADB
    debugging** and **Debug over Bluetooth** options are enabled:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在可穿戴设备中的开发者选项中，我们可以看到**ADB调试**和**通过蓝牙调试**选项已启用：
- en: '![Session setup on the handhelds apps](img/image00232.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的会话设置](img/image00232.jpeg)'
- en: 'Now that we have established a successful connection between the development
    machine, handheld device and wearable device, we will be able to deploy and debug
    our code straight from Android Studio to the wearable device using the Bluetooth
    connection. The watch will show up as a deployment target, depicted in the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在开发机器、手持设备和可穿戴设备之间建立了成功的连接，我们将能够直接从Android Studio通过蓝牙连接部署和调试我们的代码。手表将显示为部署目标，如下截图所示：
- en: '![Session setup on the handhelds apps](img/image00233.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![手持设备应用上的会话设置](img/image00233.jpeg)'
- en: The way forward - reviewing Android Wear 2.0
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前进之路 - 回顾Android Wear 2.0
- en: Back when we began work on this book, Android Wear 2.0 was well past ideation
    and into design. The Android Wear preview API was still in the works, being scheduled
    for release about the time we rounded a corner taking us past the halfway point
    of our first draft. Although the 2.0 APIs are still being fleshed out and development
    is underway, interested developers can try it out as part of the Android Wear
    2.0 developer preview edition of the API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写这本书时，Android Wear 2.0 已经超越了构思阶段，进入了设计阶段。Android Wear 预览 API 仍在开发中，预计将在我们完成第一稿的一半时发布。尽管
    2.0 API 仍在完善中，开发工作正在进行，但感兴趣的开发商可以尝试作为 Android Wear 2.0 开发者预览版 API 的一部分。
- en: In this section, we are going to highlight some of the key new features being
    baked into the 2.0 APIs, with an eye on what we've seen in the previous chapters
    of this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将突出一些被整合到 2.0 API 中的关键新特性，同时关注本书前几章中我们所看到的内容。
- en: Watch face complications
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表盘复杂功能
- en: In our discussion of watch faces, we had advanced the idea of interactive watch
    faces whereby we made available limited user interaction with the watch face primarily
    through tap gestures. Android Wear 2.0 formalizes such additional display complexity
    into the idea of a complication. A complication is essentially any feature that
    displays data beyond the time, that is, the hours and minutes. Version 2.0 offers
    a watch face complications API that lets watch faces display extra information
    without requiring underlying plumbing to get the data. Instead, the provision
    of data—be it a battery level indicator, or weather information—is externalized
    through the complications API to a complication data provider, which then takes
    control of how the data is rendered on the watch face. The watch face that consumes
    data from such a complication data provider is still responsible for drawing the
    complications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论表盘时，我们提出了交互式表盘的概念，我们通过点击手势提供了与表盘的有限用户交互。Android Wear 2.0 将这种额外的显示复杂性正式化为复杂功能的概念。复杂功能本质上是指显示时间之外的数据的任何功能，即小时和分钟。2.0
    版本提供了一个表盘复杂功能 API，允许表盘显示额外信息，而无需底层管道获取数据。相反，数据的提供——无论是电池电量指示器还是天气信息——通过复杂功能 API
    外部化到一个复杂功能数据提供者，然后该提供者控制数据在表盘上的显示方式。从这种复杂功能数据提供者消耗数据的表盘仍然负责绘制复杂功能。
- en: Navigation and action drawers
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航和操作抽屉
- en: Android Wear 2.0 API is heavily based on material design from top to bottom,
    and we see the realization of its design principles in the core components and
    stock widgets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 2.0 API 从上到下都基于材料设计，我们在核心组件和内置小部件中看到了其设计原则的实现。
- en: We introduced the navigation and action drawers back in [Chapter 9](part0063.xhtml#aid-1S2JE2
    "Chapter 9.  Material Design"), *Material Design*, in the course of a discussion
    on material design. Android Wear 2.0 has further solidified the alignment of these
    widgets with material design concepts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 9 章](part0063.xhtml#aid-1S2JE2 "第 9 章。材料设计") 中介绍了导航和操作抽屉，在讨论材料设计的过程中。Android
    Wear 2.0 进一步巩固了这些小部件与材料设计概念的协调一致。
- en: There is additional support for drawer peeking so that users may access these
    drawers as they scroll. Also, the peek view and navigation drawer closure operations
    have been automated with the added ability to show the first action in the `WearableActionDrawer`
    API's peek view. These drawer widgets are also extensible in the new 2.0 APIs
    with support to create custom drawers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有额外的抽屉预览支持，以便用户在滚动时可以访问这些抽屉。此外，预览视图和导航抽屉关闭操作已通过添加在 `WearableActionDrawer` API
    的预览视图中显示第一个操作的能力而自动化。这些抽屉小部件在新 2.0 API 中也是可扩展的，支持创建自定义抽屉。
- en: Expanded and messaging style notifications
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和消息样式通知
- en: Android Wear 2.0 has made significant changes to notifications and the visual
    interactions with them. Users can get an improved experience through what are
    called expanded notifications. When we specify additional content pages and actions
    for a notification, they become available to the user in an expanded notification.
    Each expanded notification follows material design principles. The user can view
    the expanded notification by simply tapping on a notification. However, the notification
    would have to be generated by an app on the paired companion handheld, and it
    should not have a `Notification.contentIntent` class set for it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 2.0对通知及其视觉交互进行了重大改进。用户可以通过所谓的扩展通知获得改进的体验。当我们为通知指定额外的内容页面和操作时，它们会在扩展通知中向用户开放。每个扩展通知都遵循材料设计原则。用户可以通过简单地点击通知来查看扩展通知。然而，通知必须由配对的伴侣手持设备上的应用程序生成，并且不应为其设置`Notification.contentIntent`类。
- en: The 2.0 version also offers a `Notification.MessagingStyle` class, which uses
    chat messages included in a `MessagingStyle` notification. The result is an enhanced
    app-like experience in the expanded notification.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本还提供了一个`Notification.MessagingStyle`类，它使用包含在`MessagingStyle`通知中的聊天消息。结果是扩展通知中增强了类似应用程序的体验。
- en: The Input Method Framework
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入法框架
- en: Android's **Input Method Framework** (**IMF**) allows users to enter text using
    the system's default IME or third-party IMEs. The input may be accomplished through
    tapping individual keys or by gesture typing. Android Wear 2.0 extends these same
    capabilities to wearable devices. Users will have the ability to enable more than
    one IME from a list of installed IMEs with one of them set as the default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Android的**输入法框架**（**IMF**）允许用户使用系统的默认输入法或第三方输入法输入文本。输入可以通过点击单个键或通过手势输入来完成。Android
    Wear 2.0将这些相同的功能扩展到了可穿戴设备上。用户将能够从已安装的输入法列表中选择多个输入法，并设置其中一个为默认输入法。
- en: Remote input and smart reply
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程输入和智能回复
- en: Wear 2.0 allows users to choose from a range of input options through the remote
    input API. These include dictation, emoji, smart reply, a developer-provided list
    of canned response, and the default IME.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0允许用户通过远程输入API从一系列输入选项中进行选择。这些包括语音输入、表情符号、智能回复、开发者提供的预设回复列表以及默认输入法。
- en: In addition, developers can enable a *smart reply* feature for their notifications
    whereby users get a fast and reliable means to respond to chat messages. Contextually-relevant
    choices can be made to appear in expanded notifications, as well as in remote
    input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发者可以为他们的通知启用一个**智能回复**功能，让用户获得快速可靠的回复聊天消息的方式。与上下文相关的选项可以出现在扩展通知以及远程输入中。
- en: Wrist gestures
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手腕手势
- en: Imagine being able to interact with our wearable device through a mere flick
    of our wrist. That is exactly what the designers of the Wear 2.0 APIs had in mind
    when they provided for the enablement of two wrist gestures for use by apps—the
    *Flick Wrist Out* and the *Flick Wrist In* gestures. A typical use case for this
    would be scrolling through a list of notifications or news articles while doing
    anything that forces you to interact with one hand only, for instance, when there
    is a large cup of coffee in the other hand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，只需轻轻一挥手腕就能与我们的可穿戴设备交互。这正是Wear 2.0 API的设计师在提供两个手腕手势（*外翻手腕*和*内翻手腕*手势）供应用程序使用时所考虑的。这种典型用例可能是在一只手必须进行交互的情况下滚动通知列表或新闻文章，例如当另一只手拿着一杯大咖啡时。
- en: Wrist gestures in 2.0 can be enabled/disabled by going to **Settings** | **Gestures**
    | **Wrist Gestures**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中，可以通过前往**设置** | **手势** | **手腕手势**来启用/禁用手腕手势。
- en: Bridging mode
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Notifications are, by default, shared (also known as bridged) from an app on
    a companion handheld to wearable device. If there is also a standalone wearable
    app issuing the same notifications, then this can be a source of annoyance, as
    the same notification appears from the standalone app as well as from the companion
    handheld, owing to the bridging.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通知是从伴侣手持设备上的应用程序共享到可穿戴设备的（也称为桥接）。如果还有独立的应用程序发出相同的通知，那么这可能会引起烦恼，因为相同的通知会从独立的应用程序以及伴侣手持设备上出现，这是由于桥接的原因。
- en: To ameliorate this issue, the Android Wear 2.0 Preview edition includes a feature
    called **bridging mode**. This mode allows the standalone app to turn on or off,
    through its manifest, the bridging of notifications from the companion handheld
    app. Further, the APIs permit notification dismissals to be synchronized across
    devices through the declaration of dismissal IDs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善这个问题，Android Wear 2.0预览版包含了一个名为**桥接模式**的功能。此模式允许独立应用通过其清单来开启或关闭从伴侣手持应用桥接通知的功能。此外，API允许通过声明取消ID来在不同设备间同步通知取消。
- en: Standalone wearables
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的可穿戴设备
- en: This was inevitable. The companion handheld is a valuable design metaphor in
    making the apps smart with respect to resource usage. But with perpetual strides
    in concentrating power and memory into small-form devices, the possibility of
    reducing dependence on companion handhelds, or even doing away with them, is becoming
    more and more real.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可避免的。伴侣手持设备在使应用智能使用资源方面是一个有价值的设计隐喻。但随着将计算能力和内存集中到小型设备中的持续进步，减少对伴侣手持设备的依赖，甚至完全淘汰它们的可能性正在变得越来越现实。
- en: Standalone devices will let wearable apps work independently of companion apps.
    Rather than having an Android Wear app be embedded in its corresponding companion
    app (as is currently the case), the use of multi-APK delivery method will allow
    developers to release Android Wear apps independently of their corresponding companion
    apps.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 独立设备将使可穿戴应用能够在没有伴侣应用的情况下独立工作。而不是像目前那样将Android Wear应用嵌入到相应的伴侣应用中，使用多APK交付方法将允许开发者独立于相应的伴侣应用发布Android
    Wear应用。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: APK is the Android file format used for installation to the Android operating
    system. We'll talk more about this in the next chapter. For now, suffice it to
    understand that Google Play offers multi-APK support that lets us publish different
    APKs for our apps, each targeting a different device configuration. Thus, each
    APK is an independent version of the app, even though they may share the same
    application listing and package name on Google Play. Each APK is also signed with
    the same release key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: APK是用于安装到Android操作系统的Android文件格式。我们将在下一章中详细讨论这个问题。现在，只需理解Google Play提供了多APK支持，这使我们能够为我们的应用发布不同的APK，每个APK针对不同的设备配置。因此，每个APK都是应用的独立版本，尽管它们在Google
    Play上可能共享相同的应用列表和包名。每个APK也使用相同的发布密钥进行签名。
- en: 'Eliminating dependence on the companion app, in turn, eliminates the need for
    a wearable data layer API. Android Wear apps will be able to make network requests
    directly. Furthermore, direct access to network resources opens up new ways for
    Wear apps to authenticate. These ways include the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消除对伴侣应用的依赖，反过来，也消除了对可穿戴数据层API的需求。Android Wear应用将能够直接进行网络请求。此外，直接访问网络资源为Wear应用提供了新的认证方式。以下是一些方式：
- en: Using the standard Google keyboard for direct text entry
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准Google键盘进行直接文本输入
- en: Using the `android.accounts.AccountManager` API class to sync and store account
    data
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`android.accounts.AccountManager` API类同步和存储账户数据
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter with a discussion of how to keep our apps running when
    our wearable device goes into ambient mode. We then augmented our step counter
    activity using our `Today` app from [Chapter 7](part0051.xhtml#aid-1GKCM1 "Chapter 7. 
    Voice Interactions, Sensors, and Tracking"), *Voice Interaction, Sensors, and
    Tracking*, to make it always on, thereby getting up close to the parts of the
    Android Wear API that let us enable ambient mode for our apps. We then concluded
    with a brief note on debugging wearable apps over Bluetooth before proving a sneak
    preview of Android Wear 2.0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的开头讨论了当我们的可穿戴设备进入环境模式时如何保持我们的应用运行。然后，我们使用来自[第7章](part0051.xhtml#aid-1GKCM1
    "第7章。语音交互、传感器和追踪")的“Today”应用增强了我们的步数计数器活动，使其始终开启，从而接近Android Wear API中允许我们为应用启用环境模式的那些部分。然后，我们在展示Android
    Wear 2.0的预览版之前，简要地提到了在蓝牙上调试可穿戴应用。
