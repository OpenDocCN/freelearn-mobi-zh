- en: Chapter 11.  Advanced Features and Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Man is a genius when he is dreaming."                                    
              - Akira Kurosawa*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we introduce the design concerns and API features related to
    making apps run as if they were always on. We develop an activity to demonstrate
    the always-on capability. We then touch upon debugging wear apps over Bluetooth
    connections and conclude with a preview of Android Wear 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code accompanying this chapter is available for reference on GitHub ([https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11)).
    Note that for the sake of brevity, code snippets are only included as needed.
    The reader is encouraged to download the referenced code from GitHub and follow
    along as they progress through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the watch running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall our discussion of watch faces in the previous chapter wherein
    a watch face starts out running in interactive mode. As the screen times out,
    the watch face continues to run as the device goes into its power-saving ambient
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: While this feature, meaning the watch face's always-on capability, is inherent
    to watch faces—we don't want our watch to slack off when we want the time—it is
    not necessarily inherent to all wearable apps. For instance, if we had our `todo`
    app or `Step counter` app active, it would only be a matter of time before the
    screen timed out and rendered the watch face. If we then wanted to return to our
    app, we would have to interact with our wearable device to snap it out of ambient
    mode and bring up our last used activity or app. We can imagine scenarios where
    this can be a source of user frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, if our devices are running Android version 5.1 or higher, we can
    harness the power of the Android Wear APIs to conserve power during the execution
    of our wearable apps. These devices allow apps to remain in the foreground while
    still conserving battery power. Apps can be coded to control what is displayed
    in ambient mode even as they continue fulfilling their primary purpose, whatever
    that may be. Such apps are, in effect, always on.
  prefs: []
  type: TYPE_NORMAL
- en: Making an app to stay always on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the things we need to do and/or keep in mind when looking
    to enable ambient mode for our wearable apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Our SDK should be updated to include the Android 5.1 or higher platform as this
    version provides activities with ambient mode support. See the *Android SDK Packages*
    section in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2.  Setting up the Development
    Environment"), *Setting up Development Environment on Android Studio*, for more
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must set our manifest `targetSdkVersion` to API level 22 or higher (that
    is, version 5.1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may choose to provide backward compatibility for devices running an Android
    version prior to 5.1 by specifying a `minSdkVersion` attribute. By doing so, the
    activities that support ambient mode will automatically fall back by returning
    to the home screen and exit the activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our activities should extend the `WearableActivity` API class so as to inherit
    all the methods needed to enable ambient mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should invoke the `setAmbientEnabled()` method in the`onCreate()` listener
    of our activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should have a clear understanding of the transitions between interactive
    and ambient mode and the relevant listeners that are called during those transitions,
    as shown in the figure at the end of this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should pay special attention to updating the activity UI in the ambient mode
    to use a basic layout and a minimal palette of colors to maximize better power
    conservation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should try to update the activity UI using a consistent layout so that the
    transition between interactive and ambient modes appears as seamless as possible
    to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should exercise care not to update the screen too frequently when in ambient
    mode. Remember that the whole point of the ambient mode is to save power. Updating
    the activity UI more frequently than 10 seconds can be a source of power drainage
    and be counter-productive to enabling ambient mode altogether. If it does become
    necessary to perform more frequent updates due to the nature of the app (as with
    mapping or fitness), consider the use of the API's `AlarmManager` class ([https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth repeating that devices running a version of Android prior to 5.1
    (API Level 22) may not have access to the always-on capabilities of the newer
    APIs, but they should still run these apps without errors provided we specify
    a `minSdkVersion` attribute of 20 or higher in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram, depicting the update in the UI activity of
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making an app to stay always on](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An always running step counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's demonstrate everything we presented in the previous section in practice
    by augmenting our step counter from [Chapter 7](part0051.xhtml#aid-1GKCM1 "Chapter 7. 
    Voice Interactions, Sensors, and Tracking"), *Voice Interactions, Sensors, and
    Tracking*, to be always on. Let's dive right in.
  prefs: []
  type: TYPE_NORMAL
- en: The Android manifest file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is to update the `AndroidManifest.xml` file and set up
    the `StepCounterActivity` class to have its `launchMode` set to `singleInstance`.
    This is necessary in order to update the screen more than once per minute in ambient
    mode. Not doing so will cause the `AlarmManager` class to launch an intent to
    open a new activity every time the alarm is triggered rather than reusing the
    same (already active) activity. Here is the snippet from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we launch our step counter, we see a colorful background image and
    a display showing the number of steps taken so far since a reboot of the device,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Android manifest file](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The StepCounterActivity class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This activity does the bulk of the work for our step counter. We modify the
    `onCreate()` method with a call to the `setAmbientEnabled()` method setting it
    to true. We also define a helper method, `refreshDisplayAndSetNextUpdate()`, that
    we call from our `onCreate()` listener, as well as the `onEnterAmbient()` and
    `onUpdateAmbient()` listeners. A call to the `isAmbient()` method determines whether
    we use the value from the ambient interval or the active interval. Furthermore,
    in ambient mode, we remove the background, make the pixels black, and paint the
    data with a white foreground. Maximizing the use of black and minimizing the use
    of white directly contributes to battery power conservation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code listing presents the `StepCounterActivity` class for our
    step counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the preceding changes, this is how the step counter shows up
    in ambient mode now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The StepCounterActivity class](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging wearable apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important and extremely useful tool available to developers is the ability
    to set up debugging for our wearable apps running on our wearable device. We have
    the ability to run debug commands from our development machine to troubleshoot
    our wearable apps and have any debug output from the wearable be sent over to
    the handheld, which in turn must be connected to the development machine. Some
    setup is required in order to accomplish this. The general connectivity between
    devices is as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging wearable apps](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The greatest payoff here is that we don't need to run two separate USB connections
    from the development machine—one to the handheld and the other to the wearable
    device. Instead, we can deploy and debug code straight to the handheld device
    from the development machine using a Bluetooth connection. This becomes especially
    helpful when such troubleshooting needs to be performed repetitively during development.
    Without this feature, we would have to endure the clutter of too many cables,
    and we know we can do without that.
  prefs: []
  type: TYPE_NORMAL
- en: Device setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging must be set up on the companion handheld as well as the wearable device,
    albeit a bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: USB debugging on the handheld app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow the steps mentioned to perform the debugging on the handheld app:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the **Settings** screen in the handheld device and make sure the USB
    debugging is turned on in **Developer** **options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and launch the **Developer options**. Alternatively, you may have to
    tap the **About Phone** menu, scroll down the build number and tap it seven times
    to activate the **Developer Options** menu item. Tap it once it is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose to enable **USB debugging**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![USB debugging on the handheld app](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bluetooth debugging on the wearable app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow the steps mentioned here to perform debugging on the wearable app using
    Bluetooth:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the **Wear** menu by tapping the home screen twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and launch **Developer Options**. Alternatively, you may have to tap
    **About Phone**, scroll down the build number and tap it seven times to activate
    the **Developer Options** menu item. Tap it once it is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose to enable **Debugging over Bluetooth** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Session setup on the handhelds apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up the session in handheld apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Android Wear companion app on the handheld.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch **Settings** from the menu in the top-right corner:![Session setup on
    the handhelds apps](img/image00228.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose to enable the **Debugging over Bluetooth** option. Note that the following
    message shows up on your handheld under that option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Session setup on the handhelds apps](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is because we are yet to connect your handheld to your development machine.
    Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now connect the handheld to our development machine using a USB cable,
    and type the following at the `adb` command prompt. We use an arbitrary port `4444`,
    we could use any available port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the companion app on the handheld, you should now see the following under
    the **Debugging over Bluetooth** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Session setup on the handhelds apps](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have thus completed setting up a debugging session for our wearable. After
    the successful connection, we see a notification shown as follows on the wearable
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session setup on the handhelds apps](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's test it all out by executing some debug commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if we execute the `adb devices` command at the `adb` command prompt,
    we should see our wearable device show up as `localhost:4444`. We can now execute
    the `adb` commands to debug our application, using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider following command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the developer options in the wearable device, we can see that the **ADB
    debugging** and **Debug over Bluetooth** options are enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session setup on the handhelds apps](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have established a successful connection between the development
    machine, handheld device and wearable device, we will be able to deploy and debug
    our code straight from Android Studio to the wearable device using the Bluetooth
    connection. The watch will show up as a deployment target, depicted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session setup on the handhelds apps](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The way forward - reviewing Android Wear 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back when we began work on this book, Android Wear 2.0 was well past ideation
    and into design. The Android Wear preview API was still in the works, being scheduled
    for release about the time we rounded a corner taking us past the halfway point
    of our first draft. Although the 2.0 APIs are still being fleshed out and development
    is underway, interested developers can try it out as part of the Android Wear
    2.0 developer preview edition of the API.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to highlight some of the key new features being
    baked into the 2.0 APIs, with an eye on what we've seen in the previous chapters
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Watch face complications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our discussion of watch faces, we had advanced the idea of interactive watch
    faces whereby we made available limited user interaction with the watch face primarily
    through tap gestures. Android Wear 2.0 formalizes such additional display complexity
    into the idea of a complication. A complication is essentially any feature that
    displays data beyond the time, that is, the hours and minutes. Version 2.0 offers
    a watch face complications API that lets watch faces display extra information
    without requiring underlying plumbing to get the data. Instead, the provision
    of data—be it a battery level indicator, or weather information—is externalized
    through the complications API to a complication data provider, which then takes
    control of how the data is rendered on the watch face. The watch face that consumes
    data from such a complication data provider is still responsible for drawing the
    complications.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation and action drawers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Wear 2.0 API is heavily based on material design from top to bottom,
    and we see the realization of its design principles in the core components and
    stock widgets.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the navigation and action drawers back in [Chapter 9](part0063.xhtml#aid-1S2JE2
    "Chapter 9.  Material Design"), *Material Design*, in the course of a discussion
    on material design. Android Wear 2.0 has further solidified the alignment of these
    widgets with material design concepts.
  prefs: []
  type: TYPE_NORMAL
- en: There is additional support for drawer peeking so that users may access these
    drawers as they scroll. Also, the peek view and navigation drawer closure operations
    have been automated with the added ability to show the first action in the `WearableActionDrawer`
    API's peek view. These drawer widgets are also extensible in the new 2.0 APIs
    with support to create custom drawers.
  prefs: []
  type: TYPE_NORMAL
- en: Expanded and messaging style notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Wear 2.0 has made significant changes to notifications and the visual
    interactions with them. Users can get an improved experience through what are
    called expanded notifications. When we specify additional content pages and actions
    for a notification, they become available to the user in an expanded notification.
    Each expanded notification follows material design principles. The user can view
    the expanded notification by simply tapping on a notification. However, the notification
    would have to be generated by an app on the paired companion handheld, and it
    should not have a `Notification.contentIntent` class set for it.
  prefs: []
  type: TYPE_NORMAL
- en: The 2.0 version also offers a `Notification.MessagingStyle` class, which uses
    chat messages included in a `MessagingStyle` notification. The result is an enhanced
    app-like experience in the expanded notification.
  prefs: []
  type: TYPE_NORMAL
- en: The Input Method Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android's **Input Method Framework** (**IMF**) allows users to enter text using
    the system's default IME or third-party IMEs. The input may be accomplished through
    tapping individual keys or by gesture typing. Android Wear 2.0 extends these same
    capabilities to wearable devices. Users will have the ability to enable more than
    one IME from a list of installed IMEs with one of them set as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Remote input and smart reply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wear 2.0 allows users to choose from a range of input options through the remote
    input API. These include dictation, emoji, smart reply, a developer-provided list
    of canned response, and the default IME.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, developers can enable a *smart reply* feature for their notifications
    whereby users get a fast and reliable means to respond to chat messages. Contextually-relevant
    choices can be made to appear in expanded notifications, as well as in remote
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Wrist gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine being able to interact with our wearable device through a mere flick
    of our wrist. That is exactly what the designers of the Wear 2.0 APIs had in mind
    when they provided for the enablement of two wrist gestures for use by apps—the
    *Flick Wrist Out* and the *Flick Wrist In* gestures. A typical use case for this
    would be scrolling through a list of notifications or news articles while doing
    anything that forces you to interact with one hand only, for instance, when there
    is a large cup of coffee in the other hand.
  prefs: []
  type: TYPE_NORMAL
- en: Wrist gestures in 2.0 can be enabled/disabled by going to **Settings** | **Gestures**
    | **Wrist Gestures**.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notifications are, by default, shared (also known as bridged) from an app on
    a companion handheld to wearable device. If there is also a standalone wearable
    app issuing the same notifications, then this can be a source of annoyance, as
    the same notification appears from the standalone app as well as from the companion
    handheld, owing to the bridging.
  prefs: []
  type: TYPE_NORMAL
- en: To ameliorate this issue, the Android Wear 2.0 Preview edition includes a feature
    called **bridging mode**. This mode allows the standalone app to turn on or off,
    through its manifest, the bridging of notifications from the companion handheld
    app. Further, the APIs permit notification dismissals to be synchronized across
    devices through the declaration of dismissal IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone wearables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was inevitable. The companion handheld is a valuable design metaphor in
    making the apps smart with respect to resource usage. But with perpetual strides
    in concentrating power and memory into small-form devices, the possibility of
    reducing dependence on companion handhelds, or even doing away with them, is becoming
    more and more real.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone devices will let wearable apps work independently of companion apps.
    Rather than having an Android Wear app be embedded in its corresponding companion
    app (as is currently the case), the use of multi-APK delivery method will allow
    developers to release Android Wear apps independently of their corresponding companion
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: APK is the Android file format used for installation to the Android operating
    system. We'll talk more about this in the next chapter. For now, suffice it to
    understand that Google Play offers multi-APK support that lets us publish different
    APKs for our apps, each targeting a different device configuration. Thus, each
    APK is an independent version of the app, even though they may share the same
    application listing and package name on Google Play. Each APK is also signed with
    the same release key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eliminating dependence on the companion app, in turn, eliminates the need for
    a wearable data layer API. Android Wear apps will be able to make network requests
    directly. Furthermore, direct access to network resources opens up new ways for
    Wear apps to authenticate. These ways include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard Google keyboard for direct text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `android.accounts.AccountManager` API class to sync and store account
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter with a discussion of how to keep our apps running when
    our wearable device goes into ambient mode. We then augmented our step counter
    activity using our `Today` app from [Chapter 7](part0051.xhtml#aid-1GKCM1 "Chapter 7. 
    Voice Interactions, Sensors, and Tracking"), *Voice Interaction, Sensors, and
    Tracking*, to make it always on, thereby getting up close to the parts of the
    Android Wear API that let us enable ambient mode for our apps. We then concluded
    with a brief note on debugging wearable apps over Bluetooth before proving a sneak
    preview of Android Wear 2.0.
  prefs: []
  type: TYPE_NORMAL
