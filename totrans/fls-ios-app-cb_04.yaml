- en: Chapter 4. Porting Flash Projects to iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling user interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening the display list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting vectors to bitmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing bitmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with external SWFs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple prohibits the installation of third-party plugins on iOS, preventing Safari
    or any other browser from running Flash content. Unfortunately, this prevents
    those using iOS devices from accessing the thousands of popular web-based Flash
    games and applications that are out there.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, the growing popularity of iOS had left Flash developers, who
    were wishing to deliver their existing content to Apple's platform, in a difficult
    position. The only realistic solution was to completely rewrite their projects
    for iOS using Objective-C, while continuing to maintain the existing ActionScript
    codebase for web users on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: However, one of the primary advantages of AIR for iOS is that developers can
    re-publish their existing Flash-enabled content as native iOS apps while leaving
    much of the project's codebase untouched. Adobe's multi-platform goal for the
    Flash Platform has meant that Flash developers can target iOS while using the
    same development environment that they are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will take you through recipes that will aid you when porting existing
    Flash projects to the iOS platform. These should get you started on the right
    foot and help you grow in confidence as you continue to work with AIR for iOS.
    And remember, what you will learn here isn't just applicable when porting existing
    content; you should also apply the same techniques and principles to any new applications
    you plan to create.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this chapter alone won't guarantee that your Flash projects can be
    successfully ported, but the recipes selected should give you a flavor of what
    is required if you are to succeed. The limitations of mobile platforms can make
    development daunting. However, as your knowledge of AIR for iOS grows, so will
    your ability to identify areas within your applications that can be optimized
    to fit those constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mouse interaction allows a level of accuracy that is impossible to achieve with
    a finger. Take for example a simple button within a menu screen. With a mouse,
    the user will be able to make a selection with almost pixel-perfect precision.
    A finger, however, obscures parts of the screen, including the item being selected,
    and also makes contact with a larger area.
  prefs: []
  type: TYPE_NORMAL
- en: If your existing Flash applications are designed primarily for mouse interaction,
    then you will need to redesign your user interface to accommodate touch. The most
    beneficial changes you can make are to increase the size of your buttons and create
    larger hit targets around them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already done so, download this book's code bundle from its companion
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Open `chapter4\recipe1\recipe.fla` into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Within its library are bitmaps that you will use to create a button. Also, its
    AIR for iOS settings have already been applied, saving you the time and effort
    when you eventually need to build and deploy the recipe to a device.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, a starting FLA will be provided for all recipes, with the majority
    of AIR for iOS settings for each being pre-configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will split this recipe into two parts. First we will create a movie clip
    representing the button, before writing and linking a custom class to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the button movie clip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start by creating the movie clip:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Insert** | **New Symbol** *(Ctrl + F8* | *Cmd* + *F8)*. From the **Create
    New Symbol** panel, enter `Start Button` into the **Name** field and select **Movie
    Clip** from the **Type** field's drop-down box. Click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An empty movie-clip symbol will be created within the library and you will be
    moved to its timeline.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Drag the **button-normal.png** bitmap from the library to the stage. From the
    **Properties** panel, expand the **POSITION AND SIZE** section and position the
    bitmap at (0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on frame 2 of the timeline and select **Insert** | **Timeline** | **Blank
    Keyframe**. Also drag **button-select.png** from the library to the stage and
    position it at (0,0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layer on the timeline by selecting **Insert** | **Timeline** |
    **Layer** from Flash Professional's drop-down menu. The layer will be named **Layer
    2** by default and will sit on top of **Layer 1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Tools** panel, select the **Rectangle Tool (R).** On **Layer 2**,
    draw a rectangle that has a width of 290 pixels and a height of 77 pixels. Position
    it at (-28,-14). The rectangle should span across both frames of the timeline
    and represents the button's hit region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the rectangle by double-clicking on it, then from the **Properties**
    panel set the alpha for both the rectangle's fill and stroke to **0%**, making
    it invisible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have a button movie clip that has a timeline identical to the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating the button movie clip](img/1383_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Move out of the **Start Button** movie-clip symbol and back to your FLA's root
    timeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linking a class to the button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the button''s visual taken care of, it is time to add some interactivity
    using ActionScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **New** and create a new **ActionScript 3.0 Class**. Name
    the class as `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class as `Button.as` to the same location as your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to your FLA. Now you can link the class to your button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the **Library**, right-click on the **Start Button** movie-clip symbol
    and select **Properties**. Check on the **Export for ActionScript** checkbox.
    Enter `StartButton` into the **Class** field and `Button` into the **Base Class**
    field. Click on the **OK** button. Flash will inform you that a definition for
    the `StartButton` class will be generated. Click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag an instance of the **Start Button** movie-clip symbol from the **Library**
    onto the stage. Position it at (43,217).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your FLA using ADL *(Ctrl + Enter* | *Cmd* + *Enter)* to ensure that there
    are no compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally publish your app for iOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The FLA will be compiled and a file named `c4-r1.ipa` will be created. Deploy
    the file to your device and test it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remaining recipes within this book will follow a convention for the naming
    of their IPA file. The IPA's name will contain the chapter number that the recipe
    belongs to, followed by the recipe's position within the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, this recipe belongs to Chapter 4 (c4) and is the chapter's first
    recipe (r1). Therefore, the IPA file generated by this recipe's FLA will be named
    `c4-r1.ipa`. To ensure you can easily find your installed apps on your device,
    each app's name will reflect that of the IPA. You will find the preceding recipe's
    example app listed on your home screen as `c4 r1.`
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With some simple timeline work and a small amount of ActionScript, you have
    constructed a two-state button that is suitable for use on an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Being large in size and having a generous rectangular hit target makes the button
    an easy target. Even those who operate their device with one hand and make selections
    with their thumb should have no problems.
  prefs: []
  type: TYPE_NORMAL
- en: The `Button.as` class simply manages the timeline movement between the button's
    two states. When not being pressed, the first frame of the timeline is shown.
    When the user's finger touches the button, the second frame of its timeline is
    shown. Its state is also updated in response to the user's finger rolling onto
    or out of the button.
  prefs: []
  type: TYPE_NORMAL
- en: A strong user experience is vital to the success of your app. When porting your
    existing Flash projects to iOS, spend the necessary time adapting your buttons
    and other UI elements to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are a few more points of interest regarding user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Re-using the button class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can re-use the class provided with this recipe, linking it to any button
    within the library of your own projects. The class simply updates your button's
    visual state but you can easily add an event listener to any of your button instances
    in order to respond to a successful user selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick example, name the button instance on your stage as `startButton`.
    Now, create a document class for your FLA. Name the class `Main` and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code above simply listens for the `startButton` instance dispatching a `MouseEvent.MOUSE_UP`
    event. When it does, the `buttonPressed()` handler is called, which hides the
    button from view. Of course, for your own applications you will add your own functionality
    to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Handling keyboard controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as mouse interaction, many Flash-enabled projects designed for the web
    expect the presence of a physical keyboard to control the application in some
    way or form. While iOS devices do support a virtual keyboard, it is only present
    when a text field is being edited. Your application should not rely on keyboard
    events as a control mechanism. You may need to redesign how users interact with
    the app before porting it to iOS.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a basic document class Chapter 3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing applications for iOS, you should anticipate that the app may at
    any point be closed. This can happen for a number of reasons such as the user
    deliberately exiting from the app, an incoming call being received, or iOS closing
    the app due to memory constraints.
  prefs: []
  type: TYPE_NORMAL
- en: When an app is closed unexpectedly, the user will expect it to resume from its
    previous state when they eventually return to it. For any Flash projects you are
    porting to iOS, it is important you add functionality to save the app's state
    at convenient points throughout its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will take you through the steps required to maintain the state of
    an application. We will use Flash's `SharedObject` class to save data locally
    to your device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter4\recipe2\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: On the stage, you will find a dynamic text field, and a movie clip that represents
    a button. A minimal document class has been written that increments a counter
    every time the button is pressed and shows its value within the text field.
  prefs: []
  type: TYPE_NORMAL
- en: The movie clip's library symbol is linked to a class named `Button`, which was
    introduced in the previous recipe, Handling user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Test the application using ADL *(Ctrl + Enter* | *Cmd* + *Enter)*. Increment
    the counter a few times by clicking on the button and then close the window. If
    you test the application again, then you will notice that the counter has reset
    to zero—the application does not yet remember its state.
  prefs: []
  type: TYPE_NORMAL
- en: The document class, `Main.as`, can be found in the same location as the FLA.
    Open it and familiarize yourself with the code.
  prefs: []
  type: TYPE_NORMAL
- en: A `MOUSE_UP` event listener has been added to the button on the stage. Its handler
    function simply increments a `counter` member variable and then writes the value
    to the dynamic text field.
  prefs: []
  type: TYPE_NORMAL
- en: Let us update the document class to allow it to manage your application's state.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will require the use of the `SharedObject` class for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `Main.as` add an import statement for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a member variable that will be used to store a reference to the shared
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a private method that either initializes the shared object or retrieves
    any data already stored by it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a call to `initSharedObject()` within the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a private method that saves the value of the `counter` member variable
    to the shared object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `buttonPressed()` event handler, make a call to the `saveSharedObject()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your FLA using ADL. When you close the window and re-test the FLA, you
    will see that the counter's value has been successfully restored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish your app for iOS and deploy it to your device. Increment the counter
    and then close the app. If your device is using iOS 4.0 or above, then you will
    also need to forcibly kill the app from iOS's app switcher. When you re-launch
    it, the counter's value will be restored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To access the fast app switcher, double-press on the home button. To kill an
    app, tap and hold its icon until the minus symbol appears at the icon's corner.
    Tap the minus symbol and the app will be removed from the background. The app
    switcher is available on devices running iOS 4 or above.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A local shared object is a data file that is stored locally on your device.
    The `SharedObject` class provides an API that can be used to easily save and retrieve
    data from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can use a shared object, you must obtain a `SharedObject` instance
    by making a call to the static `getLocal()` method. If the shared object doesn''t
    already exist, then one is created. When you call `getLocal()`, you must pass
    it a string that is used to name the data file that is written to the device''s
    file system. This was done within the recipe''s `initSharedObject()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a reference to a `SharedObject` you can add or retrieve attributes
    through its `data` property. Each attribute represents data you would like to
    save and can be an object of any ActionScript type including `Array, ByteArray`,
    and `XML`. You can even save an instance of a custom class by first registering
    it using the `flash.net.registerClassAlias()` package-level function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We stored the `counter` member variable''s value by creating an attribute named
    `counter` and setting it to the value of the member variable. This was done within
    our `initSharedObject()` method to initialize the persistent data, and again within
    `saveSharedObject()` to store the counter''s latest value. The following line
    of code is used to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also useful to know if your shared object contains data or has just been
    created. You can determine this by simply checking for the existence of one of
    your known attributes. This was done within `initSharedObject()` where we checked
    to see if the `counter` attribute was `null`. If it was, then we set it to the
    `counter` member variable''s current default value; otherwise we used the stored
    value to actually set the `counter` member variable. The following is the code
    again as a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Setting attributes within the data object doesn't actually save them. You must
    explicitly do this by making a call to the `flush()` method, which was done within
    our `saveSharedObject()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Making calls to `flush()` can be expensive as data must be written to the file
    system. For this recipe's example code, it is acceptable to repeatedly make calls
    to `flush()` when the application's state changes. However, for real-world apps,
    you should attempt to save data as often as possible but without degrading the
    performance of your app. Try to find convenient moments to save, for example,
    between levels or during periods of user inactivity.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the `SharedObject` class, perform a search for
    `flash.net.SharedObject` within Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling multitasking, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exiting gracefully from an app, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening the display list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flash's drawing tools and rendering engine makes it convenient to create a deeply
    nested display list. When examining artwork created in Flash, it is fairly common
    to have to drill down into the top-level clip for several levels and navigate
    through a complex hierarchical structure until you find your target display object.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, while a desktop computer will be able to easily render complex
    scenes, the same content running on an iOS device may degrade performance. Deeply
    nested display lists also cause long event chains that can further hurt the performance.
    A touch event, for example, must traverse the display list in order to determine
    the display objects that are to receive the event.
  prefs: []
  type: TYPE_NORMAL
- en: When porting to iOS, rendering is often the biggest performance bottleneck.
    Consider flattening your display list in order to keep your application's frame
    rate as high as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how this is done by completely flattening an example nested display
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter4\recipe3\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: The FLA's scene should look familiar. It is the same content that was used in
    Chapter 2 and 3's example Bubbles application, except the assets in this FLA have
    been arranged in a hierarchical structure.
  prefs: []
  type: TYPE_NORMAL
- en: At the top level is a single container movie clip named `bubbles` that holds
    all the bubble clips. Within `bubbles` are four additional container clips named
    `small, medium, large`, and `huge`. These containers are used to store collections
    of bubbles by size. For example, all the small bubbles are held inside the `small`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the full hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1383_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Explore the display list within Flash Professional. It isn't too dissimilar
    to how scenes are constructed in most Flash-based websites and games.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now flatten this display list by breaking apart movie clips.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure you are on the root timeline and walk through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Selection Tool (V)** , click on the `bubbles` movie clip that is
    sitting on the stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Modify** | **Break Apart** *(Ctrl + B* | *Cmd* + *B).*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `small, medium, large` , and huge movie clips will now be ungrouped from
    bubbles, which will now have been removed from the display list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the `small` movie clip container by clicking on any of the small bubbles
    sitting on the stage. Now select **Modify** | **Break Apart** *(Ctrl + B* | *Cmd*
    + *B)* to break apart the `small` movie clip container, ungrouping the **Bubble
    Small** instances that are held within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step to break apart the `medium, large`, and `huge` container
    clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now need to rename each of the bubble instances to ensure they all
    have unique names. This wasn't a problem when the clips were grouped within containers
    but now that they all sit on the same level their names need to be unique. Starting
    with the small bubbles and working your way to the largest, name the movie clip
    instances `bubble1` to `bubble9`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, remove symbols from the library that are no longer required. To do
    this, move to the **Library** panel and click on **Select Unused Items** from
    the panel menu. Right-click on one of the highlighted symbols in the library and
    select **Delete**. All the highlighted symbols will be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The library's panel menu is represented by a small icon on the top-right corner
    of the panel. Clicking it reveals a drop-down list of options.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breaking apart movie-clip instances is an ideal way to flatten the display list.
    Of course, you can reduce the display list's depth rather than completely flatten
    it. How far you want to take it really depends on the performance you are after
    and the complexity of the scene you wish to render.
  prefs: []
  type: TYPE_NORMAL
- en: Instance naming, however, can become a little trickier. A hierarchical structure
    allows several clips with the same name to co-exist. For example, both the `small`
    and `medium` movie clips from this recipe's example contained a clip named `bubble1`.
    Although both clips shared the same name, they belonged to different parent clips,
    avoiding a naming conflict. However, once flattened, we were left with several
    clips sitting on the stage that shared the same name.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to flatten your display list, then consider carefully the impact
    this will have on your code. Any target path references will have to be updated
    and you will need to spend time renaming display object instances to avoid potential
    naming conflicts. Flattening the display list will also affect the relative `x`
    and `y` position of display objects. However, if the application you are porting
    requires a consistent and high frame rate, then it may be your only choice, especially
    when targeting older devices.
  prefs: []
  type: TYPE_NORMAL
- en: Converting vectors to bitmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Flash projects take full advantage of Flash's vector rendering engine and
    timeline animation system. Rendering vector content, however, can be computationally
    expensive, particularly with complex vector shapes that contain a large number
    of control points, gradients, and alpha transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Although even a modest desktop computer can easily render the vector graphics
    found in most Flash projects; mobile devices are optimized for bitmap graphics
    meaning compromises need to be made sometimes. Drawing bitmaps is typically less
    expensive than vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Where performance is critical, consider converting complex vector artwork into
    bitmaps. If your project already contains existing vector content, then you can
    use Flash Professional to produce bitmaps from each library symbol. You can then
    replace your vector content with the bitmap renditions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter4\recipe4\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: You will be working with assets from the previous chapter's example Bubbles
    application. Although the application previously used bitmaps, the bubble assets
    within this FLA's library are now represented by vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the **Library** panel, you will find a movie-clip symbol named **Bubble
    Vector**. This is a master clip that is used and resized within the four bubble
    types— **Bubble Small, Bubble Medium, Bubble Large**, and **Bubble Huge**.
  prefs: []
  type: TYPE_NORMAL
- en: We will now use Flash Professional to convert the vector representation of each
    bubble into a bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start by converting **Bubble Small** to a bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Library** panel, double-click on **Bubble Small**. This will move
    you to that symbol's timeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** | **Export** | **Export Image** from Flash Professional's drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A file-browser window will appear.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the browser window, navigate to your FLA's root folder. Within the **Save
    as type** field, select **PNG** and enter **bubble-small.png** into the **File
    name** field. Click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An **Export PNG** dialog box will appear providing export options for the PNG
    that Flash is about to create as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1383_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: For the **Include** field, select **Minimum Image Area** from the drop-down
    box. Ensure that the **Colors** field is set to **24 bit with alpha channel**
    and that the **Filter** field is set to **None**. In addition, ensure that the
    **Smooth** checkbox is unchecked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to export the PNG.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, double-click on **Bubble Medium** from the **Library** panel. Again, select
    **File** | **Export** | **Export Image** and enter a file name of **bubble-medium.png**.
    From the **Export PNG** panel, use the same settings as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process for **Bubble Large** and **Bubble Huge**, exporting them
    as **bubble-large.png** and **bubble-huge.png** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have four bitmap images—one for each bubble—that you can import into
    your FLA and replace the vector versions with.
  prefs: []
  type: TYPE_NORMAL
- en: The **Graphics Processing Units (GPU)** found on mobile devices, such as the
    iPhone, are optimized for rendering bitmaps; for many situations you should see
    a significant performance increase if you opt to use bitmaps instead of vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Your bitmap images will also look consistent whether you use CPU or GPU rendering
    modes, and with the exception of smoothing will remain relatively unaffected by
    the stage's render quality. This is in stark contrast to vectors, which are affected
    by both the rendering mode and stage quality.
  prefs: []
  type: TYPE_NORMAL
- en: Using CPU render mode utilizes the same software renderer used by the Flash
    Player installed on desktop computers and also produces the same high quality
    results. However, this comes at the cost of performance compared to using the
    GPU rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Although fast, rendering vectors using the GPU will always result in an approximation
    of your source artwork. For fast moving content, this may be acceptable but for
    stationary objects the differences may be noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially each rendering path will produce different results when dealing
    with vectors. CPU rendering is accurate but slower, while the GPU is faster but
    inaccurate. Both options, however, are typically more computationally expensive
    than using bitmaps.
  prefs: []
  type: TYPE_NORMAL
- en: Where appropriate, replace your complex vector artwork with bitmaps. However,
    be aware that bitmaps can significantly increase the size of your final `.ipa`
    file compared to vectors. The larger your IPA becomes, the longer your app will
    take to load and the more memory it will consume. Increased memory consumption
    itself can lead to degradation in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Apple currently imposes an over-the-air download limit of 20 MB.
    It is important your IPA doesn't exceed this limit as it prevents users from downloading
    your app over carrier networks and may affect sales.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at `chapter4\recipe4-final\recipe.fla` to see the exported PNGs
    being used in place of the original vector artwork.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intelligent use of bitmaps is vital in order to maximize the performance of
    your app. You may find the following options and information helpful in achieving
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Export as Bitmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those using Flash Professional CS5.5, a more convenient option is available
    that allows you to instruct Flash to export bitmap representations of vector movie
    clips during publication. This not only provides you with optimized bitmap content
    for your app but also maintains the original vector artwork within the FLA.
  prefs: []
  type: TYPE_NORMAL
- en: To export a symbol as a bitmap, first select the symbol from the stage. Then
    from the **Properties** panel, expand the **DISPLAY** section and select **Export
    as Bitmap** from the **Render** field's drop-down box. If your clip requires transparency,
    then also ensure that the drop-down box directly beneath is set to **Transparent**.
  prefs: []
  type: TYPE_NORMAL
- en: Export as Bitmap is not available in Flash CS5.
  prefs: []
  type: TYPE_NORMAL
- en: Convert to Bitmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An additional option named **Convert to Bitmap** is available from Flash Professional
    CS5.5 that converts vector symbols to bitmaps. Although **Export as Bitmap** does
    not alter your FLA's display list, this option replaces instances on the stage
    with a bitmap representation. The new bitmap representation is added to the library
    allowing you to make further edits using an image editor such as Adobe Photoshop.
  prefs: []
  type: TYPE_NORMAL
- en: To convert a symbol to a bitmap, simply right-click on an instance of it on
    the stage and select **Convert to Bitmap** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: Convert to Bitmap is not available in Flash CS5.
  prefs: []
  type: TYPE_NORMAL
- en: Working with timeline animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vector-based timeline animations may further impact performance. This is especially
    true of complex tweens, which can be extremely expensive operations. On lower-end
    devices, such as the first and second generation iPhones and iPod touches, even
    relatively simple tweens can perform poorly. However, with the huge rendering
    improvements made since AIR 2.6 combined with the ever increasing hardware specification
    of each new generation of iOS device, this is becoming less of an issue. Remember,
    Apple itself no longer supports first and second generation devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you are experiencing performance issues with a timeline animation, then consider
    exporting each frame of your animation as a PNG. Its length will be an important
    factor as bitmap-based animation can consume considerable memory and increase
    load time. In such cases you may need to make-do with a vector implementation
    or consider re-working the animation to make it suitable for mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting multiple screen sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The screen resolution varies across iOS devices. For example, the iPhone 3GS
    has a resolution of 320x480 whereas the iPhone 4 supports 640x960 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: When targeting multiple screen sizes, consider creating different sized versions
    of your bitmaps—one for each screen resolution. This will avoid image quality
    degradation due to bitmap scaling and will also prevent any performance issues
    associated with scaling content.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple versions of each bitmap will increase the final file size
    of your IPA but if performance is a priority, then it is likely to be worth the
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: If you would rather avoid the overheads of bundling multiple bitmaps within
    your application, then it is also possible to scale vector artwork at runtime
    before storing a bitmap representation of it in memory. This technique is know
    as bitmap caching and is explored in detail in [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration").
  prefs: []
  type: TYPE_NORMAL
- en: Pre-rendering filters and blends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filters are often used in Flash projects to add visual effects such as drop
    shadows, beveled edges, and blur to display objects. Although filters can add
    impact to your application, they can seriously affect performance. This is especially
    true on iOS devices where the CPU speeds are limited compared to desktop computers.
    Additionally, in Flash Professional CS5.5, filters are no longer supported when
    using the GPU rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you pre-render the graphical effects into the artwork,
    rather than applying filters at runtime using Flash. This will aid device performance
    and also ensure your effects work across both CPU and GPU rendering modes.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using an image editor to completely recreate the effects from scratch,
    you can use Flash Professional to create a bitmap representation of any filters
    applied to display objects on the stage. There are various ways to do this, including
    setting the instance's render property to **Export as Bitmap**, converting the
    whole library clip to a bitmap, or exporting a PNG image before re-importing it
    into Flash.
  prefs: []
  type: TYPE_NORMAL
- en: Non-normal blend modes are also expensive operations and should be 'baked' into
    your artwork in a similar fashion to filters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding content to the stage, [Chapter 2](ch02.html "Chapter 2. Building iOS
    Apps Using Flash")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparing vector and bitmap graphics, [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap, [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware
    Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Targeting the Retina display, [Chapter 8](ch08.html "Chapter 8. Screen Resolution
    and Orientation Changes")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Supporting multiple resolutions, [Chapter 8](ch08.html "Chapter 8. Screen
    Resolution and Orientation Changes")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing bitmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common occurrence to see scaling being applied to bitmaps unnecessarily
    within Flash projects. Resizing bitmaps at runtime can be computationally expensive
    and degrades the image quality. Doing so can also result in a larger IPA file
    if the included artwork is actually larger than its intended display size.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how to resize existing bitmap artwork within Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter4\recipe5\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you will be working with the familiar visuals from Chapter 2 and 3's
    example Bubbles application. The assets for this recipe are made up of both vectors
    and bitmaps. The bubbles themselves are vectors, whereas the background image
    and the Flash logo are bitmaps. The bitmaps have been scaled to fit the screen.
    To see the comparison in size between the scaled instances on the stage and the
    original bitmaps stored in the library, you may want to drag both **background.png**
    and **flash-logo.png** onto the stage. Delete both from the stage before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Let us use Flash Professional to resize the bitmaps stored within the library,
    preventing the need for Flash to do this at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resize the bitmaps by following the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Library** panel, double-click on **Bubble Huge**. This will move
    you to that symbol's timeline where you will see an instance of the **Huge Bubble
    with Logo** symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move inside this symbol by again double-clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On its timeline you will see two layers—**Bubble** and **Logo**. The **Logo**
    layer contains a bitmap representation of the Flash logo. This clip has been scaled
    down from 894x894 pixels to 200x200 pixels. Let us create a new version of this
    bitmap that is already scaled to the correct size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the **Library**, right-click on **flash-logo.png** and select **Edit with**
    from the context menu. When prompted, browse to and select an external editor
    such as Adobe Photoshop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within your editor, resize the image to 200x200 pixels and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to Flash Professional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see the new version of the logo within the bubble, however, the
    logo will now be significantly smaller than the intended size. This is because
    the scale transformation that was originally applied to the 894x894 version is
    still being applied to the new bitmap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lock the **Bubble** layer and click on the bitmap sitting on the **Logo** layer.
    From the **Properties** panel, change the width and height settings to the source
    bitmap's exact dimensions of 200x200.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the library, double-click on the **Background** movie-clip symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This clip uses a bitmap named **background.png**, which is actually 640x960
    pixels scaled down to 320x480\. Again let us resize this bitmap within an image
    editor, preventing the need for it to be scaled within your app at runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find **background.png** within the library. Right-click on it and select to
    edit the bitmap using the image editor of your choice. Resize the image to 320x480
    and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to Flash Professional. Using the **Selection Tool (V)** , click on
    **background.png** sitting within the **Background** movie-clip symbol and set
    its width to 320 and its height to 480.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully replaced the FLA's existing bitmaps with new versions
    that have been pre-rendered to the size they are intended to be viewed at. This
    will save valuable CPU cycles as there is no need to scale down the bitmaps at
    runtime. Resizing bitmaps can also reduce the overall size of your SWF significantly
    as long as those bitmaps were originally being scaled-down at runtime rather than
    being increased in size.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at `chapter4\recipe5-final\recipe.fla` to see the resized bitmaps
    being used in place of the original oversized bitmaps. When running on a more
    recent device, it may be difficult to notice any discernable difference in performance
    between the original version `(recipe5\recipe.fla)` and the final version `(recipe5-final\recipe.fla)`,
    but for lower-end devices or more demanding projects, the gains can be significant.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following information will also be of benefit to you when resizing or optimizing
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting multiple screen sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The screen resolution varies across iOS devices. For example, the iPhone 3GS
    has a resolution of 320x480 whereas the iPhone 4 supports 640x960 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: When writing apps that target multiple screen sizes, you could be tempted to
    simply scale your bitmap content at runtime to fit each resolution. If you take
    this approach, then be aware that you may experience performance issues if your
    app attempts to render complex scenes at high frame rates. Additionally, the quality
    of your bitmaps will suffer as they are scaled.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, consider creating different versions of each asset—one for each screen
    size you wish to support. Of course, having multiple versions of each asset will
    increase the final file size of your IPA but the end result will likely be worth
    the effort.
  prefs: []
  type: TYPE_NORMAL
- en: If you must resize your images at runtime, then you can take advantage of hardware
    acceleration to scale bitmaps with less impact on performance. You can find out
    more in [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware Acceleration").
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing vector shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this recipe has focused primarily on bitmaps, it is all too easy to create
    unnecessarily detailed vector content, which impacts rendering time and also bloats
    the size of your `.ipa` file.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the number of calculations required to draw your vector artwork, spend
    time removing unnecessary control points. With intelligent use of the **Subselection
    Tool (A)** and the **Delete Anchor Point Tool (-)** , you can simplify the paths
    within your assets without any perceptual reduction in image quality.
  prefs: []
  type: TYPE_NORMAL
- en: The screen's pixel density makes it harder for a user to see much of the detail
    they would normally notice on a standard monitor. Removing unnecessary control
    points reduces the final size of your IPA and also improves rendering performance.
  prefs: []
  type: TYPE_NORMAL
- en: Stage quality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can further increase performance by reducing the stage render quality used
    by your app. At present there are three quality settings available for iOS—low,
    medium, and high (AIR 2.0-2.7 supports only low and medium). By default, AIR for
    iOS uses the medium setting but you can change this in ActionScript by setting
    the `Stage.quality` property to one of the constants provided by the `flash.display.StageQuality`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, adding the following line of code to your document class will
    use the lowest render quality setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The stage render quality is a global setting and is applied to all vector content
    within your application. However, bitmaps remain relatively unaffected and, with
    the exception of smoothing, will look identical across all quality settings. This
    conveniently allows you to get the highest level of performance from your vector
    assets without compromising the quality of any bitmaps within your application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Converting vectors to bitmaps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparing vector and bitmap graphics, [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Targeting the Retina display, [Chapter 8](ch08.html "Chapter 8. Screen Resolution
    and Orientation Changes")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Supporting multiple resolutions, [Chapter 8](ch08.html "Chapter 8. Screen
    Resolution and Orientation Changes")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mask layers are frequently used throughout Flash projects to partially reveal
    content sitting on layers directly beneath the mask. The mask itself can be a
    filled shape, text, an instance of a graphic symbol, or a movie clip. Dynamic
    effects can even be created by applying shape or motion tweening to your masks.
  prefs: []
  type: TYPE_NORMAL
- en: This level of flexibility and sophistication can place a lot of demand on the
    CPU, leading to a drop in frame rate. Although desktop computers can handle most
    masking operations, the same effects will degrade the performance of your iOS
    apps. Wherever possible, limit your use of masks. For existing projects, rather
    than use masks, obscure your content with other clips that sit on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will do just that; removing a mask layer and instead using
    two movie clips to obscure the content that was previously clipped by the mask.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter4\recipe6\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: The FLA shows a credits screen from a game. A mask layer is used to clip the
    credits text as it scrolls vertically upwards, ensuring that only text within
    a rectangular region in the center of the screen is shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the masked area for yourself, unlock the **Mask** layer within the FLA''s
    timeline. Any text that scrolls into this region will be rendered on screen. Text
    that falls outside this region will be hidden. The text itself is a movie clip
    that sits on the **Credits** layer and is attached directly below the mask layer.
    Lock the layer again to re-apply the mask. The following screenshot shows the
    mask region and how the screen will look when the mask is applied to the credits
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1383_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test the FLA in ADL by selecting **Control** | **Test Movie** | **in AIR Debug
    Launcher (Mobile)** *(Ctrl + Enter* | *Cmd* + *Enter).*
  prefs: []
  type: TYPE_NORMAL
- en: Now publish the FLA for iOS and deploy the resulting IPA to your device. On
    older iOS devices such as first and second generation iPhones and iPod touches,
    you may find that the performance is seriously impaired. Masks are particularly
    problematic on older hardware. Remove the app from your device before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now go through the steps required to remove the mask and instead obscure
    the credits text using movie clips.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by removing the mask layer.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Mask** layer on the timeline and select **Delete Layers**
    from the context menu.![How to do it...](img/1383_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let us copy some new library symbols into your FLA.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **File** | **Open** and browse to `chapter4\recipe6\resources\resources.fla`.
    Click on **Open** to load the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy all the library symbols from `resources.fla` and paste them into the library
    of `recipe.fla`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two new movie-clip symbols you copied—**Background Top** and **Background
    Bottom**—will be used to obscure any credits text that is outside the rectangular
    region that was previously defined by the mask.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new layer directly above the **Credits** layer and name it **Background
    Front**.![How to do it...](img/1383_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of **Background Top** from the library onto the **Background
    Front** layer. From the **Properties** panel, assign the position of x and y to
    `0` for the instance. If you are using Flash Professional CS5, then you should
    also expand the **DISPLAY** section and check the **Cache as bitmap** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, drag an instance of **Background Bottom** from the library onto the **Background
    Front** layer. Set its x position to `0` and its y position to `385`. Again, if
    you are using Flash Professional CS5, then within the **DISPLAY** section, check
    the **Cache as bitmap** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA and test using ADL *(Ctrl + Enter* | *Cmd* + *Enter).*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, publish and deploy to your device. If you are using an older generation
    device, then the performance improvement will be significant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the implementation is different, the end result should be identical
    to the original mask layer implementation. However, using movie clips to obscure
    content is less computationally expensive compared to clipping with masks.
  prefs: []
  type: TYPE_NORMAL
- en: Obscuring is a fairly simple technique. In this example, two new clips were
    used that contained bitmap content from the FLA's background image. The credits
    text was then sandwiched between the original background image and the two new
    clips, giving the illusion that a mask was being applied to the text.
  prefs: []
  type: TYPE_NORMAL
- en: You may not be familiar with the **Cache as bitmap** render option. It is used
    in this example to take advantage of GPU acceleration for apps built using Flash
    Professional CS5\. Cache as Bitmap and GPU acceleration will be covered in more
    detail in [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware Acceleration").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap, [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware
    Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with external SWFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To reduce the initial load time, web-based Flash projects often keep resources
    such as graphics in separate `.swf` files that are loaded on demand. For example,
    a game that is split across multiple levels may have an external SWF for each
    level. When the player completes a level, the SWF containing the next level's
    resources is loaded at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Due to restrictions put in place by Apple, iOS applications cannot run interpreted
    code from an external source. This causes a problem for anyone hoping to load
    external SWFs that contain class files or ActionScript embedded within the timelines
    of library symbols. There is currently no way to create an external SWF that contains
    native ARM machine code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are attempting to port a Flash project that loads external SWFs that
    contain ActionScript, then you will need to include the resources directly within
    your iOS app instead. Any resource files need to be published as SWC files rather
    than SWFs, allowing them to be statically linked and compiled with your iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will require the use of various files from the book's accompanying code bundle.
    A resources FLA has been provided at `chapter4\recipe7\resources\assets.fla`.
    It is this FLA that we will publish as a `.swc` file and statically link to a
    second FLA, `chapter4\recipe7\recipe.fla.`
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is broken into two main steps. First, we will publish a SWC from
    the resources FLA, then we will statically link the SWC to our application's FLA.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a SWC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us begin by creating a SWC from `assets.fla.`
  prefs: []
  type: TYPE_NORMAL
- en: Open `chapter4\recipe7\resources\assets.fla` into Flash Professional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This FLA contains a collection of resources intended to be loaded and used by
    `recipe.fla`. The FLA's stage is empty but within its library you will find movie-clip
    symbols with linkage IDs, allowing them to be instantiated and added to the display
    list at runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let us configure the FLA's publish settings, allowing a `.swc` file to be
    exported from its SWF.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **File** | **Publish Settings** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How you proceed depends on the version of Flash Professional that you are using.
    For Flash CS5.5, uncheck the **Flash (.swf)** checkbox and check on the **SWC**
    checkbox within the **PUBLISH** section. If you are using CS5, then click on the
    **Flash** tab before clicking on the **Export SWC** checkbox from the **SWF Settings**
    section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **OK** to set the changes and close the **Publish Settings** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to the FLA and then publish it by selecting **File** | **Publish**
    *(Alt + Shift* + *F12* | *Shift* + *Cmd* + *F12)* from the drop-down menu. A file
    named `assets.swc` will be output to the same folder as your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Statically linking the SWC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let us write a simple iOS app and statically link the assets SWC to it.
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening `chapter4\recipe7\recipe.fla` into Flash Professional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a document class. Name the class `Main` and add the following code to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the document class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to your FLA and select **File** | **ActionScript Settings** from the
    drop-down menu. This will open the **Advanced ActionScript 3.0 Settings** panel
    where you can statically link `assets.swc` to your app.![Statically linking the
    SWC](img/1383_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, first click on the **Library path** tab, then click on the **Add
    New Path** icon, which is represented by a **+** symbol. Now click on the **Browse
    to SWC file** icon. Browse to and select your `assets.swc` file. It will be added
    to a list of SWC files to be included with your app when published. Expand the
    assets SWC entry by clicking on the icon to the left of its path. Ensure that
    its **Link Type** is set to **Merged into code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **Advanced ActionScript 3.0 Settings** panel by clicking on the **OK**
    button at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish and test your FLA within ADL *(Ctrl + Enter* | *Cmd* + *Enter)*. The
    app should instantiate and add to its display list the **Background** and **Bubble
    Huge** symbols from the `assets.swc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, publish and deploy the app for iOS and ensure that it works as expected
    on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a SWC file from the assets FLA and statically linked it to our iOS
    app. A SWC file is a package containing precompiled Flash symbols and ActionScript
    code. While SWC files can normally be loaded at runtime, you must statically link
    SWCs when writing apps that target iOS. This guarantees that Flash Professional
    compiles the SWC's ActionScript bytecode into native ARM machine code.
  prefs: []
  type: TYPE_NORMAL
- en: The document class in this recipe's example simply uses the linkage IDs associated
    with the assets SWC's library symbols to instantiate and add objects to the app's
    display list. Specifically the class creates and displays an instance of `Background`
    and an instance of `BubbleHuge` from `assets.swc`.
  prefs: []
  type: TYPE_NORMAL
- en: You should consider the total size of the resource files you will have to link
    to your iOS app. All statically linked content must be loaded up-front and will
    impact your app's initial load time and the amount of memory it consumes. With
    large projects, you run the risk of the app being closed by iOS if memory consumption
    is too high. The memory threshold will vary from device to device and will also
    depend upon the number of apps held in the background.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loading external SWF files isn't impossible but you are limited in what you
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: The SWF cannot contain any ActionScript, including the assignment of linkage
    IDs to library symbols. This prevents you from being able to dynamically instantiate
    any of the SWF's library symbols from within your app. It is also not possible
    to lace ActionScript within your SWF's timeline to perform simple programmatic
    control of your animations.
  prefs: []
  type: TYPE_NORMAL
- en: You can however, place content on the SWF's stage; load the SWF into your app;
    then add the SWF to the display list. You can also embed sound within the external
    SWF's timeline and have it played back. Additionally, ActionScript calls can be
    made from your app to the external SWF, allowing programmatic control of instances
    within its display list. It is limited compared to what many Flash developers
    are used to but there are still uses for external SWFs in your iOS projects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a basic document class, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
