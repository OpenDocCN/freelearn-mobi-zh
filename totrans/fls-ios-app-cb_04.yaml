- en: Chapter 4. Porting Flash Projects to iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 将Flash项目移植到iOS
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Handling user interaction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户交互
- en: Saving application state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存应用程序状态
- en: Flattening the display list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示列表扁平化
- en: Converting vectors to bitmaps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矢量图转换为位图
- en: Resizing bitmaps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整位图大小
- en: Masking content
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遮罩内容
- en: Working with external SWFs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部SWF文件一起工作
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Apple prohibits the installation of third-party plugins on iOS, preventing Safari
    or any other browser from running Flash content. Unfortunately, this prevents
    those using iOS devices from accessing the thousands of popular web-based Flash
    games and applications that are out there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果禁止在iOS上安装第三方插件，这阻止了Safari或其他任何浏览器运行Flash内容。不幸的是，这阻止了使用iOS设备的用户访问那些流行的基于Web的Flash游戏和应用。
- en: Until recently, the growing popularity of iOS had left Flash developers, who
    were wishing to deliver their existing content to Apple's platform, in a difficult
    position. The only realistic solution was to completely rewrite their projects
    for iOS using Objective-C, while continuing to maintain the existing ActionScript
    codebase for web users on other platforms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，iOS日益增长的流行度让希望将现有内容发布到苹果平台的Flash开发者处于困境之中。唯一现实的解决方案是完全用Objective-C重写他们的项目以适应iOS，同时继续维护其他平台上的Web用户现有的ActionScript代码库。
- en: However, one of the primary advantages of AIR for iOS is that developers can
    re-publish their existing Flash-enabled content as native iOS apps while leaving
    much of the project's codebase untouched. Adobe's multi-platform goal for the
    Flash Platform has meant that Flash developers can target iOS while using the
    same development environment that they are comfortable with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AIR for iOS的一个主要优势是开发者可以将现有的Flash内容重新发布为原生iOS应用，同时保留项目的大部分代码库不变。Adobe对Flash平台的跨平台目标意味着Flash开发者可以在使用他们熟悉的相同开发环境的同时针对iOS。
- en: This chapter will take you through recipes that will aid you when porting existing
    Flash projects to the iOS platform. These should get you started on the right
    foot and help you grow in confidence as you continue to work with AIR for iOS.
    And remember, what you will learn here isn't just applicable when porting existing
    content; you should also apply the same techniques and principles to any new applications
    you plan to create.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你了解在将现有Flash项目移植到iOS平台时将帮助你的菜谱。这些应该让你迈出正确的步伐，并在继续使用iOS AIR工作时增强你的信心。记住，这里学到的不仅仅是适用于移植现有内容；你也应该将相同的技巧和原则应用到任何你计划创建的新应用程序中。
- en: Of course, this chapter alone won't guarantee that your Flash projects can be
    successfully ported, but the recipes selected should give you a flavor of what
    is required if you are to succeed. The limitations of mobile platforms can make
    development daunting. However, as your knowledge of AIR for iOS grows, so will
    your ability to identify areas within your applications that can be optimized
    to fit those constraints.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅凭本章内容并不能保证你的Flash项目能够成功移植，但选定的菜谱应该能给你一个成功的味道。移动平台的限制可能会使开发变得令人畏惧。然而，随着你对iOS
    AIR的了解不断增长，你识别应用程序中可以优化以适应这些限制的区域的技能也会提高。
- en: Handling user interaction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户交互
- en: Mouse interaction allows a level of accuracy that is impossible to achieve with
    a finger. Take for example a simple button within a menu screen. With a mouse,
    the user will be able to make a selection with almost pixel-perfect precision.
    A finger, however, obscures parts of the screen, including the item being selected,
    and also makes contact with a larger area.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标交互允许达到手指无法实现的精确度。以菜单屏幕中的一个简单按钮为例。使用鼠标，用户将能够以几乎像素级的精确度进行选择。然而，手指会遮挡屏幕的一部分，包括被选中的项目，并且还会与更大的区域接触。
- en: If your existing Flash applications are designed primarily for mouse interaction,
    then you will need to redesign your user interface to accommodate touch. The most
    beneficial changes you can make are to increase the size of your buttons and create
    larger hit targets around them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的现有Flash应用程序主要是为鼠标交互设计的，那么你需要重新设计你的用户界面以适应触摸。你可以做出的最有益的更改是增加按钮的大小，并在它们周围创建更大的点击目标。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供FLA文件作为本菜谱的起点。
- en: If you haven't already done so, download this book's code bundle from its companion
    website.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请从本书的配套网站下载这本书的代码包。
- en: Open `chapter4\recipe1\recipe.fla` into Flash Professional.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将`chapter4\recipe1\recipe.fla`打开到Flash Professional中。
- en: Within its library are bitmaps that you will use to create a button. Also, its
    AIR for iOS settings have already been applied, saving you the time and effort
    when you eventually need to build and deploy the recipe to a device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在其库中包含您将用于创建按钮的位图。此外，其AIR for iOS设置已应用，节省了您在最终需要将菜谱构建和部署到设备时的时间和精力。
- en: Going forward, a starting FLA will be provided for all recipes, with the majority
    of AIR for iOS settings for each being pre-configured.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，将为所有菜谱提供一个起始FLA，其中每个菜谱的大多数AIR for iOS设置已预先配置。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will split this recipe into two parts. First we will create a movie clip
    representing the button, before writing and linking a custom class to it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个菜谱分成两部分。首先，我们将创建一个代表按钮的电影剪辑，然后再编写并链接一个自定义类。
- en: Creating the button movie clip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建按钮电影剪辑
- en: 'Let us start by creating the movie clip:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建电影剪辑开始：
- en: Select **Insert** | **New Symbol** *(Ctrl + F8* | *Cmd* + *F8)*. From the **Create
    New Symbol** panel, enter `Start Button` into the **Name** field and select **Movie
    Clip** from the **Type** field's drop-down box. Click on the **OK** button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**插入** | **新符号** *(Ctrl + F8* | *Cmd* + *F8)*。在**创建新符号**面板中，将`Start Button`输入到**名称**字段，并从**类型**字段的下拉框中选择**电影剪辑**。点击**确定**按钮。
- en: An empty movie-clip symbol will be created within the library and you will be
    moved to its timeline.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在库中创建一个空的电影剪辑符号，并将您移动到其时间轴。
- en: Drag the **button-normal.png** bitmap from the library to the stage. From the
    **Properties** panel, expand the **POSITION AND SIZE** section and position the
    bitmap at (0, 0).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**button-normal.png**位图从库拖动到舞台。从**属性**面板中展开**位置和大小**部分，并将位图定位在(0, 0)。
- en: Click on frame 2 of the timeline and select **Insert** | **Timeline** | **Blank
    Keyframe**. Also drag **button-select.png** from the library to the stage and
    position it at (0,0).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击时间轴的第2帧，选择**插入** | **时间轴** | **空白关键帧**。同时将**button-select.png**从库拖动到舞台，并定位在(0,0)。
- en: Create a new layer on the timeline by selecting **Insert** | **Timeline** |
    **Layer** from Flash Professional's drop-down menu. The layer will be named **Layer
    2** by default and will sit on top of **Layer 1**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从Flash Professional的下拉菜单中选择**插入** | **时间轴** | **层**来在时间轴上创建一个新层。该层默认命名为**层2**，并位于**层1**之上。
- en: From the **Tools** panel, select the **Rectangle Tool (R).** On **Layer 2**,
    draw a rectangle that has a width of 290 pixels and a height of 77 pixels. Position
    it at (-28,-14). The rectangle should span across both frames of the timeline
    and represents the button's hit region.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**工具**面板中选择**矩形工具 (R)**。在**层2**上绘制一个宽度为290像素、高度为77像素的矩形。将其定位在(-28,-14)。该矩形应跨越时间轴的两个帧，代表按钮的点击区域。
- en: Finally, select the rectangle by double-clicking on it, then from the **Properties**
    panel set the alpha for both the rectangle's fill and stroke to **0%**, making
    it invisible.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过双击矩形来选择它，然后从**属性**面板将矩形填充和描边的alpha设置为**0%**，使其不可见。
- en: 'You should now have a button movie clip that has a timeline identical to the
    following screenshot:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在应该有一个按钮电影剪辑，其时间轴与以下截图相同：
- en: '![Creating the button movie clip](img/1383_04_01.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建按钮电影剪辑](img/1383_04_01.jpg)'
- en: Move out of the **Start Button** movie-clip symbol and back to your FLA's root
    timeline.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Start Button**电影剪辑符号中移出，回到您的FLA根时间轴。
- en: Save the FLA.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存FLA。
- en: Linking a class to the button
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将类链接到按钮
- en: 'With the button''s visual taken care of, it is time to add some interactivity
    using ActionScript:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完按钮的视觉后，是时候添加一些使用ActionScript的交互性了：
- en: Select **File** | **New** and create a new **ActionScript 3.0 Class**. Name
    the class as `Button`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **新建**并创建一个新的**ActionScript 3.0类**。将类命名为`Button`。
- en: 'Add the following code to the class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the class as `Button.as` to the same location as your FLA.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类保存为`Button.as`到与您的FLA相同的目录。
- en: Move back to your FLA. Now you can link the class to your button.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的FLA。现在您可以将类链接到您的按钮。
- en: Within the **Library**, right-click on the **Start Button** movie-clip symbol
    and select **Properties**. Check on the **Export for ActionScript** checkbox.
    Enter `StartButton` into the **Class** field and `Button` into the **Base Class**
    field. Click on the **OK** button. Flash will inform you that a definition for
    the `StartButton` class will be generated. Click on the **OK** button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **库** 中，右键单击 **Start Button** 电影剪辑符号并选择 **属性**。勾选 **导出为 ActionScript** 复选框。在
    **类** 字段中输入 `StartButton`，在 **基类** 字段中输入 `Button`。单击 **确定** 按钮。Flash 将通知您将生成 `StartButton`
    类的定义。单击 **确定** 按钮。
- en: Now, drag an instance of the **Start Button** movie-clip symbol from the **Library**
    onto the stage. Position it at (43,217).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 **Start Button** 电影剪辑符号实例从 **库** 拖到舞台。将其定位在 (43,217)。
- en: Test your FLA using ADL *(Ctrl + Enter* | *Cmd* + *Enter)* to ensure that there
    are no compiler errors.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ADL 测试您的 FLA 以确保没有编译错误。（Ctrl + Enter | Cmd + Enter）
- en: Finally publish your app for iOS.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后发布您的 iOS 应用。
- en: The FLA will be compiled and a file named `c4-r1.ipa` will be created. Deploy
    the file to your device and test it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FLA 将被编译，并创建一个名为 `c4-r1.ipa` 的文件。将文件部署到您的设备上并测试它。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The remaining recipes within this book will follow a convention for the naming
    of their IPA file. The IPA's name will contain the chapter number that the recipe
    belongs to, followed by the recipe's position within the chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余的食谱将遵循其 IPA 文件命名的约定。IPA 的名称将包含食谱所属的章节编号，后跟该食谱在章节中的位置。
- en: For example, this recipe belongs to Chapter 4 (c4) and is the chapter's first
    recipe (r1). Therefore, the IPA file generated by this recipe's FLA will be named
    `c4-r1.ipa`. To ensure you can easily find your installed apps on your device,
    each app's name will reflect that of the IPA. You will find the preceding recipe's
    example app listed on your home screen as `c4 r1.`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此食谱属于第 4 章（c4）并且是该章节的第一个食谱（r1）。因此，由该食谱的 FLA 生成的 IPA 文件将命名为 `c4-r1.ipa`。为了确保您可以在设备上轻松找到已安装的应用，每个应用的名字都将反映
    IPA 的名字。您将在主屏幕上找到前一个食谱的示例应用，名为 `c4 r1`。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With some simple timeline work and a small amount of ActionScript, you have
    constructed a two-state button that is suitable for use on an iOS device.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些简单的时间轴工作和少量 ActionScript，您已经构建了一个适用于 iOS 设备的双状态按钮。
- en: Being large in size and having a generous rectangular hit target makes the button
    an easy target. Even those who operate their device with one hand and make selections
    with their thumb should have no problems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尺寸较大且具有宽裕的矩形点击目标，按钮易于点击。即使那些用一只手操作设备并用拇指进行选择的人也应该没有问题。
- en: The `Button.as` class simply manages the timeline movement between the button's
    two states. When not being pressed, the first frame of the timeline is shown.
    When the user's finger touches the button, the second frame of its timeline is
    shown. Its state is also updated in response to the user's finger rolling onto
    or out of the button.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button.as` 类仅管理按钮两个状态之间的时间轴移动。当按钮未被按下时，显示时间轴的第一帧。当用户的指尖触摸按钮时，显示其时间轴的第二帧。其状态也会根据用户的指尖在按钮上或离开按钮时进行更新。'
- en: A strong user experience is vital to the success of your app. When porting your
    existing Flash projects to iOS, spend the necessary time adapting your buttons
    and other UI elements to the platform.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈的用户体验对您应用的成功至关重要。当将现有的 Flash 项目移植到 iOS 时，请花费必要的时间调整您的按钮和其他 UI 元素以适应该平台。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following are a few more points of interest regarding user interaction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于用户交互的更多有趣点。
- en: Re-using the button class
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新使用按钮类
- en: You can re-use the class provided with this recipe, linking it to any button
    within the library of your own projects. The class simply updates your button's
    visual state but you can easily add an event listener to any of your button instances
    in order to respond to a successful user selection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重新使用此食谱中提供的类，将其链接到您自己的项目库中的任何按钮。该类仅更新按钮的视觉状态，但您可以轻松地为任何按钮实例添加事件监听器以响应用户的选择。
- en: 'As a quick example, name the button instance on your stage as `startButton`.
    Now, create a document class for your FLA. Name the class `Main` and add the following
    code to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速示例，将您舞台上的按钮实例命名为 `startButton`。现在，为您的 FLA 创建一个文档类。将类命名为 `Main` 并向其中添加以下代码：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code above simply listens for the `startButton` instance dispatching a `MouseEvent.MOUSE_UP`
    event. When it does, the `buttonPressed()` handler is called, which hides the
    button from view. Of course, for your own applications you will add your own functionality
    to the handler.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是监听 `startButton` 实例分发 `MouseEvent.MOUSE_UP` 事件。当它这样做时，`buttonPressed()`
    处理程序被调用，该程序将按钮从视图中隐藏。当然，对于你自己的应用程序，你将在处理程序中添加自己的功能。
- en: Handling keyboard controls
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理键盘控制
- en: As well as mouse interaction, many Flash-enabled projects designed for the web
    expect the presence of a physical keyboard to control the application in some
    way or form. While iOS devices do support a virtual keyboard, it is only present
    when a text field is being edited. Your application should not rely on keyboard
    events as a control mechanism. You may need to redesign how users interact with
    the app before porting it to iOS.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了鼠标交互之外，许多为网络设计的启用 Flash 的项目还期望存在物理键盘以某种方式或形式控制应用程序。虽然 iOS 设备支持虚拟键盘，但它仅在文本字段被编辑时才出现。你的应用程序不应依赖于键盘事件作为控制机制。在将其移植到
    iOS 之前，你可能需要重新设计用户与应用程序交互的方式。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类链接到电影剪辑符号，[第 3 章](ch03.html "第 3 章。编写你的第一个应用程序")*'
- en: '*Creating a basic document class Chapter 3*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建基本文档类第 3 章*'
- en: Saving application state
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存应用程序状态
- en: When writing applications for iOS, you should anticipate that the app may at
    any point be closed. This can happen for a number of reasons such as the user
    deliberately exiting from the app, an incoming call being received, or iOS closing
    the app due to memory constraints.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当为 iOS 编写应用程序时，你应该预计应用程序可能在任何时候被关闭。这可能是由于多种原因，例如用户故意退出应用程序、接收到来电或 iOS 由于内存限制而关闭应用程序。
- en: When an app is closed unexpectedly, the user will expect it to resume from its
    previous state when they eventually return to it. For any Flash projects you are
    porting to iOS, it is important you add functionality to save the app's state
    at convenient points throughout its lifetime.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序意外关闭时，用户会期望它在他们最终返回时从其先前状态恢复。对于你正在将其移植到 iOS 的任何 Flash 项目，在应用程序的生命周期中方便的点上添加保存应用程序状态的功能非常重要。
- en: This recipe will take you through the steps required to maintain the state of
    an application. We will use Flash's `SharedObject` class to save data locally
    to your device.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将指导你完成维护应用程序状态所需的步骤。我们将使用 Flash 的 `SharedObject` 类将数据本地保存到您的设备。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter4\recipe2\recipe.fla`
    into Flash Professional.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter4\recipe2\recipe.fla` 打开到 Flash Professional 中。
- en: On the stage, you will find a dynamic text field, and a movie clip that represents
    a button. A minimal document class has been written that increments a counter
    every time the button is pressed and shows its value within the text field.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上，你会找到一个动态文本字段和一个代表按钮的电影剪辑。已经编写了一个最小的文档类，每次按钮被按下时都会增加计数器，并在文本字段中显示其值。
- en: The movie clip's library symbol is linked to a class named `Button`, which was
    introduced in the previous recipe, Handling user interaction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 电影剪辑的库符号链接到一个名为 `Button` 的类，该类在先前的菜谱中介绍，即处理用户交互。
- en: Test the application using ADL *(Ctrl + Enter* | *Cmd* + *Enter)*. Increment
    the counter a few times by clicking on the button and then close the window. If
    you test the application again, then you will notice that the counter has reset
    to zero—the application does not yet remember its state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ADL 测试应用程序 *(Ctrl + Enter* | *Cmd* + *Enter)*。通过点击按钮几次来增加计数器几次，然后关闭窗口。如果你再次测试应用程序，你会注意到计数器已重置为零——应用程序尚未记住其状态。
- en: The document class, `Main.as`, can be found in the same location as the FLA.
    Open it and familiarize yourself with the code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 文档类 `Main.as` 可以在 FLA 的同一位置找到。打开它，熟悉代码。
- en: A `MOUSE_UP` event listener has been added to the button on the stage. Its handler
    function simply increments a `counter` member variable and then writes the value
    to the dynamic text field.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在舞台上的按钮上添加了一个 `MOUSE_UP` 事件监听器。其处理函数简单地增加一个 `counter` 成员变量，然后将值写入动态文本字段。
- en: Let us update the document class to allow it to manage your application's state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新文档类，使其能够管理应用程序的状态。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: You will require the use of the `SharedObject` class for this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要使用 `SharedObject` 类来完成此菜谱。
- en: 'Within `Main.as` add an import statement for it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main.as` 中添加一个导入语句：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare a member variable that will be used to store a reference to the shared
    object:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个成员变量，该变量将用于存储对共享对象的引用：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, add a private method that either initializes the shared object or retrieves
    any data already stored by it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个私有方法，用于初始化共享对象或检索它已存储的任何数据：
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make a call to `initSharedObject()` within the constructor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中调用`initSharedObject()`：
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a private method that saves the value of the `counter` member variable
    to the shared object:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有方法，将`counter`成员变量的值保存到共享对象中：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the `buttonPressed()` event handler, make a call to the `saveSharedObject()`
    method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`buttonPressed()`事件处理程序中，调用`saveSharedObject()`方法：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save your class file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的类文件。
- en: Test your FLA using ADL. When you close the window and re-test the FLA, you
    will see that the counter's value has been successfully restored.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ADL测试您的FLA。当您关闭窗口并重新测试FLA时，您将看到计数器的值已成功恢复。
- en: Publish your app for iOS and deploy it to your device. Increment the counter
    and then close the app. If your device is using iOS 4.0 or above, then you will
    also need to forcibly kill the app from iOS's app switcher. When you re-launch
    it, the counter's value will be restored.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序发布到iOS并部署到您的设备。增加计数器然后关闭应用程序。如果您的设备正在使用iOS 4.0或更高版本，那么您还需要从iOS的应用程序切换器中强制关闭应用程序。当您重新启动它时，计数器的值将恢复。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To access the fast app switcher, double-press on the home button. To kill an
    app, tap and hold its icon until the minus symbol appears at the icon's corner.
    Tap the minus symbol and the app will be removed from the background. The app
    switcher is available on devices running iOS 4 or above.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问快速应用程序切换器，请双击主按钮。要关闭应用程序，请轻触并保持其图标，直到图标角落出现减号符号。轻触减号符号，应用程序将从后台移除。应用程序切换器适用于运行iOS
    4或更高版本的设备。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A local shared object is a data file that is stored locally on your device.
    The `SharedObject` class provides an API that can be used to easily save and retrieve
    data from the file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本地共享对象是存储在您的设备上的数据文件。`SharedObject`类提供了一个API，可以用来轻松地将数据保存到文件并从中检索数据。
- en: 'Before you can use a shared object, you must obtain a `SharedObject` instance
    by making a call to the static `getLocal()` method. If the shared object doesn''t
    already exist, then one is created. When you call `getLocal()`, you must pass
    it a string that is used to name the data file that is written to the device''s
    file system. This was done within the recipe''s `initSharedObject()` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用共享对象之前，您必须通过调用静态`getLocal()`方法来获取`SharedObject`实例。如果共享对象尚不存在，则创建一个。当您调用`getLocal()`时，您必须传递一个字符串，该字符串用于命名写入设备文件系统的数据文件。这已在配方中的`initSharedObject()`方法中完成：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you have a reference to a `SharedObject` you can add or retrieve attributes
    through its `data` property. Each attribute represents data you would like to
    save and can be an object of any ActionScript type including `Array, ByteArray`,
    and `XML`. You can even save an instance of a custom class by first registering
    it using the `flash.net.registerClassAlias()` package-level function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了`SharedObject`的引用，您可以通过其`data`属性添加或检索属性。每个属性代表您想要保存的数据，可以是任何ActionScript类型的对象，包括`Array,
    ByteArray`和`XML`。您甚至可以通过使用`flash.net.registerClassAlias()`包级函数首先注册它来保存自定义类的实例。
- en: 'We stored the `counter` member variable''s value by creating an attribute named
    `counter` and setting it to the value of the member variable. This was done within
    our `initSharedObject()` method to initialize the persistent data, and again within
    `saveSharedObject()` to store the counter''s latest value. The following line
    of code is used to implement this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个名为`counter`的属性并将其设置为成员变量的值来存储`counter`成员变量的值。这是在`initSharedObject()`方法中初始化持久数据时完成的，并在`saveSharedObject()`中再次完成以存储计数器的最新值。以下代码行用于实现此操作：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also useful to know if your shared object contains data or has just been
    created. You can determine this by simply checking for the existence of one of
    your known attributes. This was done within `initSharedObject()` where we checked
    to see if the `counter` attribute was `null`. If it was, then we set it to the
    `counter` member variable''s current default value; otherwise we used the stored
    value to actually set the `counter` member variable. The following is the code
    again as a reminder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的共享对象是否包含数据或刚刚被创建也是有用的。你可以通过简单地检查你已知属性的存在来确定这一点。这是在`initSharedObject()`中完成的，我们检查了`counter`属性是否为`null`。如果是，我们就将其设置为`counter`成员变量的当前默认值；否则，我们使用存储的值来实际设置`counter`成员变量。以下代码再次作为提醒：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Setting attributes within the data object doesn't actually save them. You must
    explicitly do this by making a call to the `flush()` method, which was done within
    our `saveSharedObject()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据对象内设置属性实际上并不会保存它们。你必须通过调用`flush()`方法来显式地这样做，这是在我们的`saveSharedObject()`方法中完成的。
- en: Making calls to `flush()` can be expensive as data must be written to the file
    system. For this recipe's example code, it is acceptable to repeatedly make calls
    to `flush()` when the application's state changes. However, for real-world apps,
    you should attempt to save data as often as possible but without degrading the
    performance of your app. Try to find convenient moments to save, for example,
    between levels or during periods of user inactivity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`flush()`可能会很昂贵，因为数据必须写入文件系统。对于本食谱的示例代码，当应用程序的状态改变时，重复调用`flush()`是可以接受的。然而，对于现实世界的应用程序，你应该尽可能频繁地保存数据，但不要降低应用程序的性能。尝试找到方便的时刻来保存，例如，在关卡之间或用户不活跃期间。
- en: For more information regarding the `SharedObject` class, perform a search for
    `flash.net.SharedObject` within Adobe Community Help.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SharedObject`类的更多信息，请在Adobe社区帮助中搜索`flash.net.SharedObject`。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Handling multitasking, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理多任务，[第3章](ch03.html "第3章。编写你的第一个应用程序")*'
- en: '*Exiting gracefully from an app, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优雅地退出应用程序，[第3章](ch03.html "第3章。编写你的第一个应用程序")*'
- en: Flattening the display list
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展平显示列表
- en: Flash's drawing tools and rendering engine makes it convenient to create a deeply
    nested display list. When examining artwork created in Flash, it is fairly common
    to have to drill down into the top-level clip for several levels and navigate
    through a complex hierarchical structure until you find your target display object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Flash的绘图工具和渲染引擎使得创建一个深度嵌套的显示列表变得方便。当检查在Flash中创建的艺术作品时，通常需要深入到顶级剪辑的几个层级，并通过复杂的层次结构导航，直到找到目标显示对象。
- en: Unfortunately, while a desktop computer will be able to easily render complex
    scenes, the same content running on an iOS device may degrade performance. Deeply
    nested display lists also cause long event chains that can further hurt the performance.
    A touch event, for example, must traverse the display list in order to determine
    the display objects that are to receive the event.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，虽然台式电脑可以轻松渲染复杂场景，但在iOS设备上运行相同的内容可能会降低性能。深度嵌套的显示列表也会导致长事件链，这可能会进一步损害性能。例如，一个触摸事件必须遍历显示列表，以确定要接收事件的显示对象。
- en: When porting to iOS, rendering is often the biggest performance bottleneck.
    Consider flattening your display list in order to keep your application's frame
    rate as high as possible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当移植到iOS时，渲染通常是最大的性能瓶颈。考虑展平你的显示列表，以保持你的应用程序的帧率尽可能高。
- en: We will see how this is done by completely flattening an example nested display
    list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过完全展平一个示例嵌套显示列表来了解这是如何完成的。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter4\recipe3\recipe.fla`
    into Flash Professional.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将`chapter4\recipe3\recipe.fla`打开到Flash Professional中。
- en: The FLA's scene should look familiar. It is the same content that was used in
    Chapter 2 and 3's example Bubbles application, except the assets in this FLA have
    been arranged in a hierarchical structure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: FLA的场景应该很熟悉。它是第2章和第3章示例气泡应用程序中使用的内容，除了这个FLA中的资产已经被安排在层次结构中。
- en: At the top level is a single container movie clip named `bubbles` that holds
    all the bubble clips. Within `bubbles` are four additional container clips named
    `small, medium, large`, and `huge`. These containers are used to store collections
    of bubbles by size. For example, all the small bubbles are held inside the `small`
    container.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶级是一个名为`bubbles`的单个容器电影剪辑，它包含所有气泡剪辑。在`bubbles`内部有四个额外的容器剪辑，分别命名为`small`、`medium`、`large`和`huge`。这些容器用于按大小存储气泡集合。例如，所有小气泡都包含在`small`容器中。
- en: 'The following diagram shows the full hierarchy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了完整的层次结构：
- en: '![Getting ready](img/1383_04_02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1383_04_02.jpg)'
- en: Explore the display list within Flash Professional. It isn't too dissimilar
    to how scenes are constructed in most Flash-based websites and games.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Flash Professional中的显示列表。它与大多数基于Flash的网站和游戏中的场景构建方式并不太相似。
- en: Let us now flatten this display list by breaking apart movie clips.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过分解电影剪辑来简化这个显示列表。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Ensure you are on the root timeline and walk through the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您处于根时间轴上，并按照以下步骤操作：
- en: Using the **Selection Tool (V)** , click on the `bubbles` movie clip that is
    sitting on the stage.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**选择工具 (V**)，点击舞台上坐着的`bubbles`电影剪辑。
- en: Select **Modify** | **Break Apart** *(Ctrl + B* | *Cmd* + *B).*
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**修改** | **分解** *(Ctrl + B* | *Cmd* + *B)*。
- en: The `small, medium, large` , and huge movie clips will now be ungrouped from
    bubbles, which will now have been removed from the display list.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，`small`、`medium`、`large`和巨大的电影剪辑将从`bubbles`中取消组合，`bubbles`现在将从显示列表中移除。
- en: Select the `small` movie clip container by clicking on any of the small bubbles
    sitting on the stage. Now select **Modify** | **Break Apart** *(Ctrl + B* | *Cmd*
    + *B)* to break apart the `small` movie clip container, ungrouping the **Bubble
    Small** instances that are held within it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击舞台上坐着的任何小气泡来选择`small`电影剪辑容器。现在选择**修改** | **分解** *(Ctrl + B* | *Cmd* + *B)*来分解`small`电影剪辑容器，取消组合其中包含的**Bubble
    Small**实例。
- en: Repeat the previous step to break apart the `medium, large`, and `huge` container
    clips.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤来分解`medium`、`large`和`huge`容器剪辑。
- en: You will now need to rename each of the bubble instances to ensure they all
    have unique names. This wasn't a problem when the clips were grouped within containers
    but now that they all sit on the same level their names need to be unique. Starting
    with the small bubbles and working your way to the largest, name the movie clip
    instances `bubble1` to `bubble9`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将每个气泡实例重命名，以确保它们都具有唯一的名称。当剪辑在容器内分组时，这不是问题，但现在它们都处于同一级别，它们的名称需要是唯一的。从小的气泡开始，一直工作到最大的，将电影剪辑实例命名为`bubble1`到`bubble9`。
- en: Finally, remove symbols from the library that are no longer required. To do
    this, move to the **Library** panel and click on **Select Unused Items** from
    the panel menu. Right-click on one of the highlighted symbols in the library and
    select **Delete**. All the highlighted symbols will be removed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从库中删除不再需要的符号。为此，转到**库**面板，并从面板菜单中选择**选择未使用项**。在库中右键单击一个突出显示的符号，并选择**删除**。所有突出显示的符号都将被删除。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The library's panel menu is represented by a small icon on the top-right corner
    of the panel. Clicking it reveals a drop-down list of options.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 库的面板菜单由面板右上角的小图标表示。单击它将显示一个选项的下拉列表。
- en: Save your FLA.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的FLA文件。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Breaking apart movie-clip instances is an ideal way to flatten the display list.
    Of course, you can reduce the display list's depth rather than completely flatten
    it. How far you want to take it really depends on the performance you are after
    and the complexity of the scene you wish to render.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 分解电影剪辑实例是简化显示列表的理想方式。当然，您可以减少显示列表的深度，而不是完全简化它。您希望走多远，实际上取决于您追求的性能和您希望渲染的场景的复杂性。
- en: Instance naming, however, can become a little trickier. A hierarchical structure
    allows several clips with the same name to co-exist. For example, both the `small`
    and `medium` movie clips from this recipe's example contained a clip named `bubble1`.
    Although both clips shared the same name, they belonged to different parent clips,
    avoiding a naming conflict. However, once flattened, we were left with several
    clips sitting on the stage that shared the same name.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实例命名可能会变得稍微复杂一些。分层结构允许具有相同名称的多个剪辑共存。例如，这个示例中的`small`和`medium`电影剪辑都包含一个名为`bubble1`的剪辑。尽管这两个剪辑具有相同的名称，但它们属于不同的父剪辑，避免了命名冲突。然而，一旦展开，我们留下了几个具有相同名称的剪辑坐在舞台上。
- en: If you decide to flatten your display list, then consider carefully the impact
    this will have on your code. Any target path references will have to be updated
    and you will need to spend time renaming display object instances to avoid potential
    naming conflicts. Flattening the display list will also affect the relative `x`
    and `y` position of display objects. However, if the application you are porting
    requires a consistent and high frame rate, then it may be your only choice, especially
    when targeting older devices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定合并你的显示列表，那么仔细考虑这将对你的代码产生的影响。任何目标路径引用都需要更新，并且你需要花费时间重命名显示对象实例以避免潜在的命名冲突。合并显示列表也会影响显示对象的相对
    `x` 和 `y` 位置。然而，如果你正在移植的应用程序需要一致且高帧率的性能，那么这可能是你的唯一选择，尤其是在针对旧设备时。
- en: Converting vectors to bitmaps
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将矢量转换为位图
- en: Most Flash projects take full advantage of Flash's vector rendering engine and
    timeline animation system. Rendering vector content, however, can be computationally
    expensive, particularly with complex vector shapes that contain a large number
    of control points, gradients, and alpha transparency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Flash 项目都充分利用了 Flash 的矢量渲染引擎和时间轴动画系统。然而，渲染矢量内容可能会计算成本高昂，尤其是包含大量控制点、渐变和 alpha
    透明度的复杂矢量形状。
- en: Although even a modest desktop computer can easily render the vector graphics
    found in most Flash projects; mobile devices are optimized for bitmap graphics
    meaning compromises need to be made sometimes. Drawing bitmaps is typically less
    expensive than vectors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管即使是普通的台式电脑也能轻松渲染大多数 Flash 项目中找到的矢量图形；但移动设备优化了位图图形，这意味着有时需要做出妥协。绘制位图通常比矢量便宜。
- en: Where performance is critical, consider converting complex vector artwork into
    bitmaps. If your project already contains existing vector content, then you can
    use Flash Professional to produce bitmaps from each library symbol. You can then
    replace your vector content with the bitmap renditions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能至关重要的地方，考虑将复杂的矢量艺术品转换为位图。如果你的项目已经包含现有的矢量内容，那么你可以使用 Flash Professional 从每个库符号生成位图。然后你可以用位图渲染版本替换你的矢量内容。
- en: Let us see how this is done.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何操作的。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供 FLA 文件作为本菜谱的起点。
- en: From Flash Professional, open `chapter4\recipe4\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flash Professional，从书籍的配套代码包中打开 `chapter4\recipe4\recipe.fla`。
- en: You will be working with assets from the previous chapter's example Bubbles
    application. Although the application previously used bitmaps, the bubble assets
    within this FLA's library are now represented by vectors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用上一章示例 Bubbles 应用程序中的资源。尽管该应用程序之前使用了位图，但此 FLA 库中的气泡资源现在由矢量表示。
- en: Inside the **Library** panel, you will find a movie-clip symbol named **Bubble
    Vector**. This is a master clip that is used and resized within the four bubble
    types— **Bubble Small, Bubble Medium, Bubble Large**, and **Bubble Huge**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **库** 面板中，你会找到一个名为 **Bubble Vector** 的电影剪辑符号。这是一个在四种气泡类型（**Bubble Small、Bubble
    Medium、Bubble Large** 和 **Bubble Huge**）中使用并调整大小的母剪辑。
- en: We will now use Flash Professional to convert the vector representation of each
    bubble into a bitmap.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Flash Professional 将每个气泡的矢量表示转换为位图。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us start by converting **Bubble Small** to a bitmap:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从将 **Bubble Small** 转换为位图开始：
- en: From the **Library** panel, double-click on **Bubble Small**. This will move
    you to that symbol's timeline.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **库** 面板中，双击 **Bubble Small**。这将把你带到该符号的时间轴。
- en: Select **File** | **Export** | **Export Image** from Flash Professional's drop-down
    menu.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash Professional 的下拉菜单中选择 **文件** | **导出** | **导出图像**。
- en: A file-browser window will appear.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将出现一个文件浏览器窗口。
- en: Using the browser window, navigate to your FLA's root folder. Within the **Save
    as type** field, select **PNG** and enter **bubble-small.png** into the **File
    name** field. Click on the **Save** button.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器窗口，导航到你的 FLA 的根文件夹。在 **保存类型** 字段中，选择 **PNG** 并在 **文件名** 字段中输入 **bubble-small.png**。点击
    **保存** 按钮。
- en: 'An **Export PNG** dialog box will appear providing export options for the PNG
    that Flash is about to create as shown in the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将出现一个 **导出 PNG** 对话框，提供 Flash 即将创建的 PNG 的导出选项，如下截图所示：
- en: '![How to do it...](img/1383_04_03.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1383_04_03.jpg)'
- en: For the **Include** field, select **Minimum Image Area** from the drop-down
    box. Ensure that the **Colors** field is set to **24 bit with alpha channel**
    and that the **Filter** field is set to **None**. In addition, ensure that the
    **Smooth** checkbox is unchecked.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**包含**字段，从下拉框中选择**最小图像区域**。确保**颜色**字段设置为**24位带alpha通道**，并且**过滤器**字段设置为**无**。此外，确保**平滑**复选框未选中。
- en: Click on **OK** to export the PNG.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以导出PNG。
- en: Now, double-click on **Bubble Medium** from the **Library** panel. Again, select
    **File** | **Export** | **Export Image** and enter a file name of **bubble-medium.png**.
    From the **Export PNG** panel, use the same settings as before.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**库**面板中双击**Bubble Medium**。再次，选择**文件** | **导出** | **导出图像**，并输入文件名为**bubble-medium.png**。在**导出
    PNG**面板中，使用之前的相同设置。
- en: Repeat the process for **Bubble Large** and **Bubble Huge**, exporting them
    as **bubble-large.png** and **bubble-huge.png** respectively.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，对于**Bubble Large**和**Bubble Huge**，分别导出为**bubble-large.png**和**bubble-huge.png**。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You now have four bitmap images—one for each bubble—that you can import into
    your FLA and replace the vector versions with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有四个位图图像——每个气泡一个——可以导入到您的FLA中，并用它们替换矢量版本。
- en: The **Graphics Processing Units (GPU)** found on mobile devices, such as the
    iPhone, are optimized for rendering bitmaps; for many situations you should see
    a significant performance increase if you opt to use bitmaps instead of vectors.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上，如iPhone上发现的**图形处理单元（GPU）**，针对渲染位图进行了优化；在许多情况下，如果您选择使用位图而不是矢量，您应该会看到显著的性能提升。
- en: Your bitmap images will also look consistent whether you use CPU or GPU rendering
    modes, and with the exception of smoothing will remain relatively unaffected by
    the stage's render quality. This is in stark contrast to vectors, which are affected
    by both the rendering mode and stage quality.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用CPU还是GPU渲染模式，您的位图图像看起来都将保持一致，除了平滑处理外，它们将相对不受舞台渲染质量的影响。这与矢量形成鲜明对比，矢量会受到渲染模式和舞台质量的双重影响。
- en: Using CPU render mode utilizes the same software renderer used by the Flash
    Player installed on desktop computers and also produces the same high quality
    results. However, this comes at the cost of performance compared to using the
    GPU rendering pipeline.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CPU渲染模式利用与安装在桌面计算机上的Flash Player相同的软件渲染器，并产生相同的高质量结果。然而，这是以性能为代价的，与使用GPU渲染管道相比。
- en: Although fast, rendering vectors using the GPU will always result in an approximation
    of your source artwork. For fast moving content, this may be acceptable but for
    stationary objects the differences may be noticeable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然渲染矢量使用GPU很快，但总是会得到源艺术作品的近似值。对于快速移动的内容，这可能是可以接受的，但对于静止物体，差异可能很明显。
- en: Essentially each rendering path will produce different results when dealing
    with vectors. CPU rendering is accurate but slower, while the GPU is faster but
    inaccurate. Both options, however, are typically more computationally expensive
    than using bitmaps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每种渲染路径在处理矢量时都会产生不同的结果。CPU渲染准确但较慢，而GPU渲染速度快但不够准确。然而，这两种选项通常比使用位图计算成本更高。
- en: Where appropriate, replace your complex vector artwork with bitmaps. However,
    be aware that bitmaps can significantly increase the size of your final `.ipa`
    file compared to vectors. The larger your IPA becomes, the longer your app will
    take to load and the more memory it will consume. Increased memory consumption
    itself can lead to degradation in performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的情况下，将您的复杂矢量艺术品替换为位图。然而，请注意，与矢量相比，位图可能会显著增加您的最终`.ipa`文件的大小。您的IPA越大，您的应用加载所需的时间就越长，消耗的内存就越多。内存消耗的增加本身可能会导致性能下降。
- en: Additionally, Apple currently imposes an over-the-air download limit of 20 MB.
    It is important your IPA doesn't exceed this limit as it prevents users from downloading
    your app over carrier networks and may affect sales.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，苹果目前对空中下载设置了20 MB的限制。确保您的IPA不超过此限制，因为它会阻止用户通过运营商网络下载您的应用，并可能影响销售。
- en: Take a look at `chapter4\recipe4-final\recipe.fla` to see the exported PNGs
    being used in place of the original vector artwork.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`chapter4\recipe4-final\recipe.fla`，以查看导出的PNG文件正在替代原始矢量艺术品使用。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Intelligent use of bitmaps is vital in order to maximize the performance of
    your app. You may find the following options and information helpful in achieving
    this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 智能使用位图对于最大化您应用的性能至关重要。您可能会发现以下选项和信息有助于实现这一点。
- en: Export as Bitmap
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出为位图
- en: For those using Flash Professional CS5.5, a more convenient option is available
    that allows you to instruct Flash to export bitmap representations of vector movie
    clips during publication. This not only provides you with optimized bitmap content
    for your app but also maintains the original vector artwork within the FLA.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Flash Professional CS5.5的用户，有一个更方便的选项，允许您在发布时指示Flash导出矢量电影剪辑的位图表示。这不仅为您提供了针对应用的优化位图内容，而且还在FLA中保留了原始矢量图形。
- en: To export a symbol as a bitmap, first select the symbol from the stage. Then
    from the **Properties** panel, expand the **DISPLAY** section and select **Export
    as Bitmap** from the **Render** field's drop-down box. If your clip requires transparency,
    then also ensure that the drop-down box directly beneath is set to **Transparent**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号导出为位图，首先从舞台中选择符号。然后从**属性**面板，展开**显示**部分，并从**渲染**字段的下拉菜单中选择**导出为位图**。如果您的剪辑需要透明度，请确保位于下拉菜单下方的选项设置为**透明**。
- en: Export as Bitmap is not available in Flash CS5.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash CS5中不可用**导出为位图**。
- en: Convert to Bitmap
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为位图
- en: An additional option named **Convert to Bitmap** is available from Flash Professional
    CS5.5 that converts vector symbols to bitmaps. Although **Export as Bitmap** does
    not alter your FLA's display list, this option replaces instances on the stage
    with a bitmap representation. The new bitmap representation is added to the library
    allowing you to make further edits using an image editor such as Adobe Photoshop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flash Professional CS5.5中提供了一个名为**转换为位图**的附加选项，该选项将矢量符号转换为位图。尽管**导出为位图**不会更改FLA的显示列表，但此选项将舞台上的实例替换为位图表示。新的位图表示将添加到库中，允许您使用Adobe
    Photoshop等图像编辑器进行进一步编辑。
- en: To convert a symbol to a bitmap, simply right-click on an instance of it on
    the stage and select **Convert to Bitmap** from the context menu.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号转换为位图，只需在舞台上的实例上右键单击，然后从上下文菜单中选择**转换为位图**。
- en: Convert to Bitmap is not available in Flash CS5.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash CS5中不可用**转换为位图**。
- en: Working with timeline animation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与时间轴动画一起工作
- en: Vector-based timeline animations may further impact performance. This is especially
    true of complex tweens, which can be extremely expensive operations. On lower-end
    devices, such as the first and second generation iPhones and iPod touches, even
    relatively simple tweens can perform poorly. However, with the huge rendering
    improvements made since AIR 2.6 combined with the ever increasing hardware specification
    of each new generation of iOS device, this is becoming less of an issue. Remember,
    Apple itself no longer supports first and second generation devices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于矢量的时间轴动画可能会进一步影响性能。这尤其适用于复杂的补间动画，这些操作可能非常昂贵。在低端设备上，如第一代和第二代iPhone和iPod touch，即使是相对简单的补间也可能表现不佳。然而，随着从AIR
    2.6以来的巨大渲染改进以及每一代iOS设备硬件规格的不断提高，这个问题正在逐渐减少。记住，苹果公司本身也不再支持第一代和第二代设备。
- en: If you are experiencing performance issues with a timeline animation, then consider
    exporting each frame of your animation as a PNG. Its length will be an important
    factor as bitmap-based animation can consume considerable memory and increase
    load time. In such cases you may need to make-do with a vector implementation
    or consider re-working the animation to make it suitable for mobile.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用时间轴动画时遇到性能问题，那么考虑将动画的每一帧导出为PNG格式。其长度将是一个重要因素，因为基于位图的动画可能会消耗大量内存并增加加载时间。在这种情况下，您可能需要使用矢量实现，或者考虑重新设计动画以使其适合移动设备。
- en: Targeting multiple screen sizes
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对多个屏幕尺寸
- en: The screen resolution varies across iOS devices. For example, the iPhone 3GS
    has a resolution of 320x480 whereas the iPhone 4 supports 640x960 pixels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕分辨率在iOS设备之间有所不同。例如，iPhone 3GS的分辨率为320x480，而iPhone 4支持640x960像素。
- en: When targeting multiple screen sizes, consider creating different sized versions
    of your bitmaps—one for each screen resolution. This will avoid image quality
    degradation due to bitmap scaling and will also prevent any performance issues
    associated with scaling content.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当针对多个屏幕尺寸时，考虑创建不同尺寸的位图版本——每个屏幕分辨率一个。这将避免由于位图缩放导致的图像质量下降，并防止与内容缩放相关的任何性能问题。
- en: Creating multiple versions of each bitmap will increase the final file size
    of your IPA but if performance is a priority, then it is likely to be worth the
    effort.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个位图的多个版本将增加IPA的最终文件大小，但如果性能是首要考虑，那么这可能值得付出努力。
- en: If you would rather avoid the overheads of bundling multiple bitmaps within
    your application, then it is also possible to scale vector artwork at runtime
    before storing a bitmap representation of it in memory. This technique is know
    as bitmap caching and is explored in detail in [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望避免在应用程序中捆绑多个位图的额外开销，那么在将位图表示存储在内存中之前，也可以在运行时缩放矢量艺术作品。这种技术被称为位图缓存，在第6章（ch06.html
    "第6章. 图形和硬件加速"）中详细探讨。
- en: Pre-rendering filters and blends
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预渲染滤镜和混合
- en: Filters are often used in Flash projects to add visual effects such as drop
    shadows, beveled edges, and blur to display objects. Although filters can add
    impact to your application, they can seriously affect performance. This is especially
    true on iOS devices where the CPU speeds are limited compared to desktop computers.
    Additionally, in Flash Professional CS5.5, filters are no longer supported when
    using the GPU rendering pipeline.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 滤镜通常在Flash项目中用于向显示对象添加视觉效果，如阴影、斜边和模糊。虽然滤镜可以为你的应用程序增添影响，但它们可能会严重影响性能。这在iOS设备上尤其如此，因为与桌面计算机相比，CPU速度有限。此外，在Flash
    Professional CS5.5中，当使用GPU渲染管道时，滤镜不再受支持。
- en: It is recommended that you pre-render the graphical effects into the artwork,
    rather than applying filters at runtime using Flash. This will aid device performance
    and also ensure your effects work across both CPU and GPU rendering modes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你将图形效果预渲染到艺术作品中，而不是使用Flash在运行时应用滤镜。这将有助于设备性能，并确保你的效果在CPU和GPU渲染模式下都能正常工作。
- en: Rather than using an image editor to completely recreate the effects from scratch,
    you can use Flash Professional to create a bitmap representation of any filters
    applied to display objects on the stage. There are various ways to do this, including
    setting the instance's render property to **Export as Bitmap**, converting the
    whole library clip to a bitmap, or exporting a PNG image before re-importing it
    into Flash.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与从头开始完全重新创建效果的图像编辑器相比，你可以使用Flash Professional创建舞台上显示对象应用到的任何滤镜的位图表示。有各种方法可以做到这一点，包括将实例的渲染属性设置为**导出为位图**，将整个库剪辑转换为位图，或者导出PNG图像后再将其重新导入Flash。
- en: Non-normal blend modes are also expensive operations and should be 'baked' into
    your artwork in a similar fashion to filters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 非正常混合模式也是昂贵的操作，应该以类似滤镜的方式将其'烘焙'到你的艺术作品中。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Adding content to the stage, [Chapter 2](ch02.html "Chapter 2. Building iOS
    Apps Using Flash")*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在舞台上添加内容，[第2章](ch02.html "第2章. 使用Flash构建iOS应用")*'
- en: '*Comparing vector and bitmap graphics, [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration")*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较矢量图形和位图图形，[第6章](ch06.html "第6章. 图形和硬件加速")*'
- en: '*Using Cache as Bitmap, [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware
    Acceleration")*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图，[第6章](ch06.html "第6章. 图形和硬件加速")*'
- en: '*Targeting the Retina display, [Chapter 8](ch08.html "Chapter 8. Screen Resolution
    and Orientation Changes")*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*针对Retina显示屏，[第8章](ch08.html "第8章. 屏幕分辨率和方向变化")*'
- en: '*Supporting multiple resolutions, [Chapter 8](ch08.html "Chapter 8. Screen
    Resolution and Orientation Changes")*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支持多分辨率，[第8章](ch08.html "第8章. 屏幕分辨率和方向变化")*'
- en: Resizing bitmaps
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整位图大小
- en: It is a common occurrence to see scaling being applied to bitmaps unnecessarily
    within Flash projects. Resizing bitmaps at runtime can be computationally expensive
    and degrades the image quality. Doing so can also result in a larger IPA file
    if the included artwork is actually larger than its intended display size.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash项目中，常见到不必要地对位图进行缩放的情况。在运行时调整位图大小可能会消耗大量计算资源并降低图像质量。这样做还可能导致包含的艺术作品实际大小超过预期显示尺寸时，IPA文件变得更大。
- en: Let us see how to resize existing bitmap artwork within Flash Professional.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Flash Professional中调整现有的位图艺术作品的大小。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From Flash Professional, open `chapter4\recipe5\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flash Professional中，打开书籍附带代码包中的`chapter4\recipe5\recipe.fla`。
- en: Again, you will be working with the familiar visuals from Chapter 2 and 3's
    example Bubbles application. The assets for this recipe are made up of both vectors
    and bitmaps. The bubbles themselves are vectors, whereas the background image
    and the Flash logo are bitmaps. The bitmaps have been scaled to fit the screen.
    To see the comparison in size between the scaled instances on the stage and the
    original bitmaps stored in the library, you may want to drag both **background.png**
    and **flash-logo.png** onto the stage. Delete both from the stage before continuing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你将使用第 2 章和第 3 章示例 Bubbles 应用程序的熟悉视觉元素。这个食谱的资产由矢量和位图组成。气泡本身是矢量，而背景图像和 Flash
    标志是位图。位图已缩放以适应屏幕。为了比较舞台上的缩放实例和库中存储的原始位图的大小，你可能想要将**background.png**和**flash-logo.png**都拖到舞台上。在继续之前，从舞台上删除这两个文件。
- en: Let us use Flash Professional to resize the bitmaps stored within the library,
    preventing the need for Flash to do this at runtime.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Flash Professional 调整库中存储的位图的大小，以防止 Flash 在运行时进行此操作。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Resize the bitmaps by following the steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤调整位图大小：
- en: From the **Library** panel, double-click on **Bubble Huge**. This will move
    you to that symbol's timeline where you will see an instance of the **Huge Bubble
    with Logo** symbol.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**库**面板中，双击**Bubble Huge**。这将把你带到该符号的时间轴，在那里你会看到一个**带有标志的巨型气泡**符号的实例。
- en: Move inside this symbol by again double-clicking on it.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次双击此符号以进入其中。
- en: On its timeline you will see two layers—**Bubble** and **Logo**. The **Logo**
    layer contains a bitmap representation of the Flash logo. This clip has been scaled
    down from 894x894 pixels to 200x200 pixels. Let us create a new version of this
    bitmap that is already scaled to the correct size.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其时间轴上，你会看到两个图层——**Bubble**和**Logo**。**Logo**层包含 Flash 标志的位图表示。此剪辑已从 894x894
    像素缩小到 200x200 像素。让我们创建一个已经缩放到正确大小的位图的新版本。
- en: From the **Library**, right-click on **flash-logo.png** and select **Edit with**
    from the context menu. When prompted, browse to and select an external editor
    such as Adobe Photoshop.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**库**中，右键单击**flash-logo.png**，从上下文菜单中选择**使用**编辑。当提示时，浏览并选择一个外部编辑器，例如 Adobe
    Photoshop。
- en: Within your editor, resize the image to 200x200 pixels and save it.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中，将图像大小调整为 200x200 像素并保存。
- en: Move back to Flash Professional.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Flash Professional。
- en: You should now see the new version of the logo within the bubble, however, the
    logo will now be significantly smaller than the intended size. This is because
    the scale transformation that was originally applied to the 894x894 version is
    still being applied to the new bitmap.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该能在气泡中看到新版本的标志，然而，标志现在将比预期的大小小得多。这是因为最初应用于 894x894 版本的缩放变换现在仍然应用于新的位图。
- en: Lock the **Bubble** layer and click on the bitmap sitting on the **Logo** layer.
    From the **Properties** panel, change the width and height settings to the source
    bitmap's exact dimensions of 200x200.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定**Bubble**层，然后单击位于**Logo**层上的位图。从**属性**面板，更改宽度和高度设置到源位图的精确尺寸 200x200。
- en: From the library, double-click on the **Background** movie-clip symbol.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库中双击**Background**电影剪辑符号。
- en: This clip uses a bitmap named **background.png**, which is actually 640x960
    pixels scaled down to 320x480\. Again let us resize this bitmap within an image
    editor, preventing the need for it to be scaled within your app at runtime.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此剪辑使用名为**background.png**的位图，实际上它是 640x960 像素缩小到 320x480。再次让我们在图像编辑器中调整此位图的大小，以防止在应用程序运行时对其进行缩放。
- en: Find **background.png** within the library. Right-click on it and select to
    edit the bitmap using the image editor of your choice. Resize the image to 320x480
    and save it.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库中找到**background.png**。右键单击它，并选择使用您选择的图像编辑器编辑位图。将图像大小调整为 320x480 并保存。
- en: Move back to Flash Professional. Using the **Selection Tool (V)** , click on
    **background.png** sitting within the **Background** movie-clip symbol and set
    its width to 320 and its height to 480.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Flash Professional。使用**选择工具 (V**)，单击位于**背景**电影剪辑符号中的**background.png**，并将其宽度设置为
    320，高度设置为 480。
- en: Save your FLA.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的 FLA 文件。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have successfully replaced the FLA's existing bitmaps with new versions
    that have been pre-rendered to the size they are intended to be viewed at. This
    will save valuable CPU cycles as there is no need to scale down the bitmaps at
    runtime. Resizing bitmaps can also reduce the overall size of your SWF significantly
    as long as those bitmaps were originally being scaled-down at runtime rather than
    being increased in size.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功用预渲染到预期观看大小的版本替换了FLA中现有的位图。这将节省宝贵的CPU周期，因为不需要在运行时缩放位图。只要这些位图最初是在运行时缩小而不是增大，调整位图大小也可以显著减小你的SWF的整体大小。
- en: Take a look at `chapter4\recipe5-final\recipe.fla` to see the resized bitmaps
    being used in place of the original oversized bitmaps. When running on a more
    recent device, it may be difficult to notice any discernable difference in performance
    between the original version `(recipe5\recipe.fla)` and the final version `(recipe5-final\recipe.fla)`,
    but for lower-end devices or more demanding projects, the gains can be significant.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`chapter4\recipe5-final\recipe.fla`，以了解正在使用的调整大小的位图替代原始过大的位图。在较新的设备上运行时，可能难以察觉原始版本（`recipe5\recipe.fla`）和最终版本（`recipe5-final\recipe.fla`）之间在性能上的任何明显差异，但对于低端设备或更复杂的项目，这种改进可能是显著的。
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following information will also be of benefit to you when resizing or optimizing
    assets.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息在调整或优化资源时也会对你有所帮助。
- en: Targeting multiple screen sizes
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对多个屏幕尺寸
- en: The screen resolution varies across iOS devices. For example, the iPhone 3GS
    has a resolution of 320x480 whereas the iPhone 4 supports 640x960 pixels.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备的屏幕分辨率各不相同。例如，iPhone 3GS的分辨率为320x480，而iPhone 4支持640x960像素。
- en: When writing apps that target multiple screen sizes, you could be tempted to
    simply scale your bitmap content at runtime to fit each resolution. If you take
    this approach, then be aware that you may experience performance issues if your
    app attempts to render complex scenes at high frame rates. Additionally, the quality
    of your bitmaps will suffer as they are scaled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写针对多个屏幕尺寸的应用程序时，你可能倾向于简单地通过运行时缩放位图内容来适应每个分辨率。如果你采取这种方法，那么请注意，如果你的应用程序尝试以高帧率渲染复杂场景，你可能会遇到性能问题。此外，随着位图的缩放，其质量也会受到影响。
- en: Instead, consider creating different versions of each asset—one for each screen
    size you wish to support. Of course, having multiple versions of each asset will
    increase the final file size of your IPA but the end result will likely be worth
    the effort.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，考虑为每个资产创建不同的版本——每个你希望支持的屏幕尺寸一个。当然，拥有每个资产的多个版本会增加你IPA的最终文件大小，但最终结果可能值得付出的努力。
- en: If you must resize your images at runtime, then you can take advantage of hardware
    acceleration to scale bitmaps with less impact on performance. You can find out
    more in [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware Acceleration").
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在运行时调整图像大小，那么你可以利用硬件加速来缩放位图，从而对性能的影响更小。你可以在[第6章](ch06.html "第6章。图形和硬件加速")中了解更多信息。
- en: Optimizing vector shapes
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化矢量形状
- en: While this recipe has focused primarily on bitmaps, it is all too easy to create
    unnecessarily detailed vector content, which impacts rendering time and also bloats
    the size of your `.ipa` file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个配方主要关注位图，但很容易创建不必要的详细矢量内容，这会影响渲染时间，并使你的`.ipa`文件体积膨胀。
- en: To reduce the number of calculations required to draw your vector artwork, spend
    time removing unnecessary control points. With intelligent use of the **Subselection
    Tool (A)** and the **Delete Anchor Point Tool (-)** , you can simplify the paths
    within your assets without any perceptual reduction in image quality.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少绘制矢量艺术品所需的计算量，花时间移除不必要的控制点。通过智能使用**子选择工具（A）**和**删除锚点工具（-）**，你可以在不降低图像质量的情况下简化资产内的路径。
- en: The screen's pixel density makes it harder for a user to see much of the detail
    they would normally notice on a standard monitor. Removing unnecessary control
    points reduces the final size of your IPA and also improves rendering performance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的像素密度使得用户难以看到他们在标准显示器上通常能注意到的许多细节。移除不必要的控制点可以减少你的IPA最终大小，并提高渲染性能。
- en: Stage quality
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阶段质量
- en: You can further increase performance by reducing the stage render quality used
    by your app. At present there are three quality settings available for iOS—low,
    medium, and high (AIR 2.0-2.7 supports only low and medium). By default, AIR for
    iOS uses the medium setting but you can change this in ActionScript by setting
    the `Stage.quality` property to one of the constants provided by the `flash.display.StageQuality`
    class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过降低应用程序使用的阶段渲染质量来进一步提高性能。目前iOS提供了三种质量设置——低、中、高（AIR 2.0-2.7仅支持低和中）。默认情况下，AIR
    for iOS使用中等设置，但您可以通过在ActionScript中设置`Stage.quality`属性为`flash.display.StageQuality`类提供的常量之一来更改此设置。
- en: 'For example, adding the following line of code to your document class will
    use the lowest render quality setting:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将以下代码行添加到您的文档类中，将使用最低的渲染质量设置：
- en: '[PRE11]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The stage render quality is a global setting and is applied to all vector content
    within your application. However, bitmaps remain relatively unaffected and, with
    the exception of smoothing, will look identical across all quality settings. This
    conveniently allows you to get the highest level of performance from your vector
    assets without compromising the quality of any bitmaps within your application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段渲染质量是一个全局设置，并应用于应用程序中的所有矢量内容。然而，位图相对不受影响，除了平滑处理外，在所有质量设置下看起来都相同。这方便地让您在不影响应用程序中任何位图质量的情况下，从矢量资产中获得最高性能。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Converting vectors to bitmaps*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将矢量转换为位图*'
- en: '*Comparing vector and bitmap graphics, [Chapter 6](ch06.html "Chapter 6. Graphics
    and Hardware Acceleration")*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较矢量图形和位图图形，[第6章](ch06.html "第6章. 图形和硬件加速")*'
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图矩阵，[第6章](ch06.html "第6章. 图形和硬件加速")*'
- en: '*Targeting the Retina display, [Chapter 8](ch08.html "Chapter 8. Screen Resolution
    and Orientation Changes")*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*针对视网膜显示屏，[第8章](ch08.html "第8章. 屏幕分辨率和方向变化")*'
- en: '*Supporting multiple resolutions, [Chapter 8](ch08.html "Chapter 8. Screen
    Resolution and Orientation Changes")*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支持多分辨率，[第8章](ch08.html "第8章. 屏幕分辨率和方向变化")*'
- en: Masking content
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙版内容
- en: Mask layers are frequently used throughout Flash projects to partially reveal
    content sitting on layers directly beneath the mask. The mask itself can be a
    filled shape, text, an instance of a graphic symbol, or a movie clip. Dynamic
    effects can even be created by applying shape or motion tweening to your masks.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个Flash项目中，蒙版层经常被用来部分显示位于蒙版层直接下方的图层上的内容。蒙版本身可以是填充形状、文本、图形符号的实例或电影剪辑。甚至可以通过对蒙版应用形状或运动补间来创建动态效果。
- en: This level of flexibility and sophistication can place a lot of demand on the
    CPU, leading to a drop in frame rate. Although desktop computers can handle most
    masking operations, the same effects will degrade the performance of your iOS
    apps. Wherever possible, limit your use of masks. For existing projects, rather
    than use masks, obscure your content with other clips that sit on top of it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性和复杂性可能会对CPU提出很高的要求，导致帧率下降。尽管桌面计算机可以处理大多数蒙版操作，但相同的效果会降低您的iOS应用程序的性能。在可能的情况下，限制您对蒙版的用途。对于现有项目，而不是使用蒙版，可以用位于其上的其他剪辑来遮蔽内容。
- en: In this recipe we will do just that; removing a mask layer and instead using
    two movie clips to obscure the content that was previously clipped by the mask.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将做的是；移除蒙版层，而是使用两个电影剪辑来遮蔽之前由蒙版剪辑的内容。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter4\recipe6\recipe.fla`
    into Flash Professional.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将`chapter4\recipe6\recipe.fla`打开到Flash Professional中。
- en: The FLA shows a credits screen from a game. A mask layer is used to clip the
    credits text as it scrolls vertically upwards, ensuring that only text within
    a rectangular region in the center of the screen is shown.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FLA显示了一个游戏的信用屏幕。使用蒙版层来剪辑滚动向上的信用文本，确保只显示屏幕中央矩形区域内的文本。
- en: 'To see the masked area for yourself, unlock the **Mask** layer within the FLA''s
    timeline. Any text that scrolls into this region will be rendered on screen. Text
    that falls outside this region will be hidden. The text itself is a movie clip
    that sits on the **Credits** layer and is attached directly below the mask layer.
    Lock the layer again to re-apply the mask. The following screenshot shows the
    mask region and how the screen will look when the mask is applied to the credits
    text:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己查看被遮罩的区域，请解锁 FLA 时间轴中的**遮罩**层。任何滚动进入此区域的文本都将显示在屏幕上。位于此区域之外的文本将被隐藏。文本本身是一个位于**字幕**层上的电影剪辑，并直接位于遮罩层下方。再次锁定图层以重新应用遮罩。以下截图显示了遮罩区域以及当遮罩应用于字幕文本时屏幕将呈现的样子：
- en: '![Getting ready](img/1383_04_04.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1383_04_04.jpg)'
- en: Test the FLA in ADL by selecting **Control** | **Test Movie** | **in AIR Debug
    Launcher (Mobile)** *(Ctrl + Enter* | *Cmd* + *Enter).*
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**控制** | **测试影片** | **在 AIR 调试启动器（移动）** *(Ctrl + Enter* | *Cmd* + *Enter)*
    来测试 FLA 在 ADL 中的效果。
- en: Now publish the FLA for iOS and deploy the resulting IPA to your device. On
    older iOS devices such as first and second generation iPhones and iPod touches,
    you may find that the performance is seriously impaired. Masks are particularly
    problematic on older hardware. Remove the app from your device before proceeding.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发布 FLA 以供 iOS 使用，并将生成的 IPA 部署到你的设备上。在旧款 iOS 设备，如第一代和第二代 iPhone 以及 iPod touch
    上，你可能发现性能严重受损。遮罩在旧硬件上尤其有问题。在继续之前，请从你的设备上删除该应用。
- en: Let us now go through the steps required to remove the mask and instead obscure
    the credits text using movie clips.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步说明如何移除遮罩，并使用电影剪辑来遮挡字幕文本。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will start by removing the mask layer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先移除遮罩层。
- en: Right-click on the **Mask** layer on the timeline and select **Delete Layers**
    from the context menu.![How to do it...](img/1383_04_05.jpg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间轴上右键点击**遮罩**层，然后从上下文菜单中选择**删除图层**。![如何操作...](img/1383_04_05.jpg)
- en: Now let us copy some new library symbols into your FLA.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们将复制一些新的库符号到你的 FLA 中。
- en: Select **File** | **Open** and browse to `chapter4\recipe6\resources\resources.fla`.
    Click on **Open** to load the FLA.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **打开**，浏览到 `chapter4\recipe6\resources\resources.fla`。点击**打开**以加载
    FLA。
- en: Copy all the library symbols from `resources.fla` and paste them into the library
    of `recipe.fla`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `resources.fla` 复制所有库符号并将其粘贴到 `recipe.fla` 的库中。
- en: The two new movie-clip symbols you copied—**Background Top** and **Background
    Bottom**—will be used to obscure any credits text that is outside the rectangular
    region that was previously defined by the mask.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你复制的两个新的电影剪辑符号——**背景顶部**和**背景底部**——将被用来遮挡任何位于之前由遮罩定义的矩形区域之外的字幕文本。
- en: Create a new layer directly above the **Credits** layer and name it **Background
    Front**.![How to do it...](img/1383_04_06.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字幕**层上方直接创建一个新图层，并将其命名为**背景前**。![如何操作...](img/1383_04_06.jpg)
- en: Drag an instance of **Background Top** from the library onto the **Background
    Front** layer. From the **Properties** panel, assign the position of x and y to
    `0` for the instance. If you are using Flash Professional CS5, then you should
    also expand the **DISPLAY** section and check the **Cache as bitmap** checkbox.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从库中将**背景顶部**的一个实例拖动到**背景前**图层上。从**属性**面板中，将实例的 x 和 y 位置分别设置为 `0`。如果你使用的是 Flash
    Professional CS5，那么你也应该展开**显示**部分并勾选**缓存为位图**复选框。
- en: Also, drag an instance of **Background Bottom** from the library onto the **Background
    Front** layer. Set its x position to `0` and its y position to `385`. Again, if
    you are using Flash Professional CS5, then within the **DISPLAY** section, check
    the **Cache as bitmap** checkbox.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从库中将**背景底部**的一个实例拖动到**背景前**图层上。将其 x 位置设置为 `0`，y 位置设置为 `385`。再次提醒，如果你使用的是
    Flash Professional CS5，那么在**显示**部分，请勾选**缓存为位图**复选框。
- en: Save your FLA and test using ADL *(Ctrl + Enter* | *Cmd* + *Enter).*
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的 FLA 并使用 ADL 测试 *(Ctrl + Enter* | *Cmd* + *Enter)*。
- en: Finally, publish and deploy to your device. If you are using an older generation
    device, then the performance improvement will be significant.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布并部署到你的设备上。如果你使用的是旧一代设备，那么性能提升将会非常显著。
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although the implementation is different, the end result should be identical
    to the original mask layer implementation. However, using movie clips to obscure
    content is less computationally expensive compared to clipping with masks.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现方式不同，但最终结果应该与原始遮罩层实现相同。然而，使用电影剪辑来遮挡内容相比使用遮罩裁剪要计算成本低。
- en: Obscuring is a fairly simple technique. In this example, two new clips were
    used that contained bitmap content from the FLA's background image. The credits
    text was then sandwiched between the original background image and the two new
    clips, giving the illusion that a mask was being applied to the text.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏是一个相当简单的技术。在本例中，使用了两个包含FLA背景图像位图内容的新剪辑。然后，将字幕文本夹在原始背景图像和两个新剪辑之间，给人一种正在对文本应用遮罩的错觉。
- en: You may not be familiar with the **Cache as bitmap** render option. It is used
    in this example to take advantage of GPU acceleration for apps built using Flash
    Professional CS5\. Cache as Bitmap and GPU acceleration will be covered in more
    detail in [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware Acceleration").
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不熟悉**缓存为位图**渲染选项。在本例中，它用于利用Flash Professional CS5构建的应用程序的GPU加速。缓存为位图和GPU加速将在[第6章](ch06.html
    "第6章。图形和硬件加速")中更详细地介绍。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using Cache as Bitmap, [Chapter 6](ch06.html "Chapter 6. Graphics and Hardware
    Acceleration")*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图，[第6章](ch06.html "第6章。图形和硬件加速")*'
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图矩阵，[第6章](ch06.html "第6章。图形和硬件加速")*'
- en: Working with external SWFs
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部SWF
- en: To reduce the initial load time, web-based Flash projects often keep resources
    such as graphics in separate `.swf` files that are loaded on demand. For example,
    a game that is split across multiple levels may have an external SWF for each
    level. When the player completes a level, the SWF containing the next level's
    resources is loaded at runtime.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少初始加载时间，基于Web的Flash项目通常将资源（如图形）保存在单独的`.swf`文件中，这些文件在需要时加载。例如，跨越多个级别的游戏可能每个级别都有一个外部SWF。当玩家完成一个级别时，包含下一个级别资源的SWF将在运行时加载。
- en: Due to restrictions put in place by Apple, iOS applications cannot run interpreted
    code from an external source. This causes a problem for anyone hoping to load
    external SWFs that contain class files or ActionScript embedded within the timelines
    of library symbols. There is currently no way to create an external SWF that contains
    native ARM machine code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于苹果公司实施的限制，iOS应用程序不能从外部源运行解释代码。这给希望加载包含类文件或嵌入在库符号时间线中的ActionScript的外部SWF的人带来了问题。目前还没有创建包含原生ARM机器代码的外部SWF的方法。
- en: If you are attempting to port a Flash project that loads external SWFs that
    contain ActionScript, then you will need to include the resources directly within
    your iOS app instead. Any resource files need to be published as SWC files rather
    than SWFs, allowing them to be statically linked and compiled with your iOS app.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在尝试移植加载包含ActionScript的外部SWF的Flash项目，那么您需要将资源直接包含在您的iOS应用程序中。任何资源文件都需要作为SWC文件发布，而不是SWF，以便它们可以静态链接并与您的iOS应用程序编译。
- en: Let us see how to do that.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the use of various files from the book's accompanying code bundle.
    A resources FLA has been provided at `chapter4\recipe7\resources\assets.fla`.
    It is this FLA that we will publish as a `.swc` file and statically link to a
    second FLA, `chapter4\recipe7\recipe.fla.`
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要使用书籍配套代码包中的各种文件。在`chapter4\recipe7\resources\assets.fla`中提供了一个资源FLA。我们将将其发布为`.swc`文件，并将其静态链接到第二个FLA，即`chapter4\recipe7\recipe.fla`。
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe is broken into two main steps. First, we will publish a SWC from
    the resources FLA, then we will statically link the SWC to our application's FLA.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱分为两个主要步骤。首先，我们将从资源FLA发布一个SWC，然后我们将静态链接SWC到我们的应用程序FLA。
- en: Publishing a SWC
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布SWC
- en: Let us begin by creating a SWC from `assets.fla.`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建`assets.fla`的SWC开始。
- en: Open `chapter4\recipe7\resources\assets.fla` into Flash Professional.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter4\recipe7\resources\assets.fla`导入到Flash Professional中。
- en: This FLA contains a collection of resources intended to be loaded and used by
    `recipe.fla`. The FLA's stage is empty but within its library you will find movie-clip
    symbols with linkage IDs, allowing them to be instantiated and added to the display
    list at runtime.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本FLA包含一组资源，旨在由`recipe.fla`加载和使用。FLA的舞台是空的，但在其库中您将找到具有链接ID的电影剪辑符号，允许它们在运行时实例化并添加到显示列表中。
- en: Now let us configure the FLA's publish settings, allowing a `.swc` file to be
    exported from its SWF.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们配置FLA的发布设置，允许从其SWF导出`.swc`文件。
- en: Select **File** | **Publish Settings** from the drop-down menu.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**文件** | **发布设置**。
- en: How you proceed depends on the version of Flash Professional that you are using.
    For Flash CS5.5, uncheck the **Flash (.swf)** checkbox and check on the **SWC**
    checkbox within the **PUBLISH** section. If you are using CS5, then click on the
    **Flash** tab before clicking on the **Export SWC** checkbox from the **SWF Settings**
    section.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的下一步取决于您使用的 Flash Professional 版本。对于 Flash CS5.5，取消选择 **Flash (.swf)** 复选框，并在
    **发布** 部分内选中 **SWC** 复选框。如果您使用的是 CS5，则在点击 **SWF 设置** 部分的 **导出 SWC** 复选框之前，先点击
    **Flash** 选项卡。
- en: Click on **OK** to set the changes and close the **Publish Settings** panel.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定** 以设置更改并关闭 **发布设置** 面板。
- en: Save the changes to the FLA and then publish it by selecting **File** | **Publish**
    *(Alt + Shift* + *F12* | *Shift* + *Cmd* + *F12)* from the drop-down menu. A file
    named `assets.swc` will be output to the same folder as your FLA.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA 的更改，然后通过从下拉菜单中选择 **文件** | **发布** *(Alt + Shift* + *F12* | *Shift* + *Cmd*
    + *F12)* 来发布它。一个名为 `assets.swc` 的文件将被输出到与您的 FLA 相同的文件夹中。
- en: Statically linking the SWC
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态链接 SWC 文件
- en: Now, let us write a simple iOS app and statically link the assets SWC to it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个简单的 iOS 应用程序，并将资产 SWC 静态链接到它。
- en: Start by opening `chapter4\recipe7\recipe.fla` into Flash Professional.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Flash Professional 中打开 `chapter4\recipe7\recipe.fla`。
- en: 'Create a document class. Name the class `Main` and add the following code to
    it:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类。将类命名为 `Main` 并向其中添加以下代码：
- en: '[PRE12]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save the document class.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档类。
- en: Move back to your FLA and select **File** | **ActionScript Settings** from the
    drop-down menu. This will open the **Advanced ActionScript 3.0 Settings** panel
    where you can statically link `assets.swc` to your app.![Statically linking the
    SWC](img/1383_04_07.jpg)
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 FLA 文件，从下拉菜单中选择 **文件** | **动作脚本设置**。这将打开 **高级动作脚本 3.0 设置** 面板，您可以在其中将 `assets.swc`
    静态链接到您的应用程序。![静态链接 SWC](img/1383_04_07.jpg)
- en: To do this, first click on the **Library path** tab, then click on the **Add
    New Path** icon, which is represented by a **+** symbol. Now click on the **Browse
    to SWC file** icon. Browse to and select your `assets.swc` file. It will be added
    to a list of SWC files to be included with your app when published. Expand the
    assets SWC entry by clicking on the icon to the left of its path. Ensure that
    its **Link Type** is set to **Merged into code**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，首先点击 **库路径** 选项卡，然后点击表示为 **+** 符号的 **添加新路径** 图标。现在点击 **浏览到 SWC 文件** 图标。浏览并选择您的
    `assets.swc` 文件。它将被添加到要随应用程序发布的 SWC 文件列表中。通过点击其路径左侧的图标展开资产 SWC 条目。确保其 **链接类型**
    设置为 **合并到代码**。
- en: Close the **Advanced ActionScript 3.0 Settings** panel by clicking on the **OK**
    button at the bottom.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击底部的 **确定** 按钮关闭 **高级动作脚本 3.0 设置** 面板。
- en: Save your FLA.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的 FLA。
- en: Publish and test your FLA within ADL *(Ctrl + Enter* | *Cmd* + *Enter)*. The
    app should instantiate and add to its display list the **Background** and **Bubble
    Huge** symbols from the `assets.swc`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ADL 中发布并测试您的 FLA *(Ctrl + Enter* | *Cmd* + *Enter)*。应用程序应该实例化并将 `assets.swc`
    中的 **Background** 和 **Bubble Huge** 符号添加到其显示列表中。
- en: Finally, publish and deploy the app for iOS and ensure that it works as expected
    on your device.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布并部署应用程序到 iOS，并确保它在您的设备上按预期工作。
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a SWC file from the assets FLA and statically linked it to our iOS
    app. A SWC file is a package containing precompiled Flash symbols and ActionScript
    code. While SWC files can normally be loaded at runtime, you must statically link
    SWCs when writing apps that target iOS. This guarantees that Flash Professional
    compiles the SWC's ActionScript bytecode into native ARM machine code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从资产 FLA 创建了一个 SWC 文件，并将其静态链接到我们的 iOS 应用程序。SWC 文件是一个包含预编译的 Flash 符号和动作脚本代码的包。虽然
    SWC 文件通常可以在运行时加载，但在编写针对 iOS 的应用程序时，您必须静态链接 SWC 文件。这保证了 Flash Professional 将 SWC
    的动作脚本字节码编译成本机 ARM 机器代码。
- en: The document class in this recipe's example simply uses the linkage IDs associated
    with the assets SWC's library symbols to instantiate and add objects to the app's
    display list. Specifically the class creates and displays an instance of `Background`
    and an instance of `BubbleHuge` from `assets.swc`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱示例中的文档类简单地使用与资产 SWC 库符号关联的链接 ID 来实例化和向应用程序的显示列表添加对象。具体来说，该类创建并显示 `Background`
    和 `BubbleHuge` 的实例，它们来自 `assets.swc`。
- en: You should consider the total size of the resource files you will have to link
    to your iOS app. All statically linked content must be loaded up-front and will
    impact your app's initial load time and the amount of memory it consumes. With
    large projects, you run the risk of the app being closed by iOS if memory consumption
    is too high. The memory threshold will vary from device to device and will also
    depend upon the number of apps held in the background.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑您将链接到您的iOS应用中的资源文件的总大小。所有静态链接的内容都必须预先加载，这将影响您应用的初始加载时间和它消耗的内存量。在大型项目中，如果内存消耗过高，iOS可能会关闭应用。内存阈值会因设备而异，并且还取决于后台保留的应用数量。
- en: There's more...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Loading external SWF files isn't impossible but you are limited in what you
    can do.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 加载外部SWF文件并非不可能，但您能做的事情有限。
- en: The SWF cannot contain any ActionScript, including the assignment of linkage
    IDs to library symbols. This prevents you from being able to dynamically instantiate
    any of the SWF's library symbols from within your app. It is also not possible
    to lace ActionScript within your SWF's timeline to perform simple programmatic
    control of your animations.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: SWF文件不能包含任何ActionScript，包括将链接ID分配给库符号。这阻止了您从您的应用中动态实例化SWF的任何库符号。同样，您也无法在SWF的时间线上嵌入ActionScript以执行简单的程序控制您的动画。
- en: You can however, place content on the SWF's stage; load the SWF into your app;
    then add the SWF to the display list. You can also embed sound within the external
    SWF's timeline and have it played back. Additionally, ActionScript calls can be
    made from your app to the external SWF, allowing programmatic control of instances
    within its display list. It is limited compared to what many Flash developers
    are used to but there are still uses for external SWFs in your iOS projects.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以在SWF的舞台上放置内容；将SWF加载到您的应用中；然后将SWF添加到显示列表中。您还可以在外部SWF的时间线上嵌入声音并播放它。此外，您可以从您的应用中调用ActionScript到外部SWF，允许对显示列表中的实例进行程序控制。与许多Flash开发者习惯的相比，这有限制，但在iOS项目中仍然有外部SWF的用途。
- en: See also
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a basic document class, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建基本文档类，[第3章](ch03.html "第3章。编写您的第一个应用")*'
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类链接到电影剪辑符号，[第3章](ch03.html "第3章。编写您的第一个应用")*'
