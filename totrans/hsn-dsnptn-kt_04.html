<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting Familiar with Behavioral Patterns</h1>
                
            
            
                
<p class="calibre2">This chapter discusses behavioral patterns with Kotlin. Behavioral patterns deal with how objects interact with one another.<br class="calibre6"/></p>
<p class="calibre2">We'll see how an object can behave in a totally different manner based on the situation, how objects can communicate without knowledge of one another, and how we can iterate over complex structures easily.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Strategy</li>
<li class="calibre12">Iterator</li>
<li class="calibre12">State</li>
<li class="calibre12">Command</li>
<li class="calibre12">Chain of responsibility</li>
<li class="calibre12">Interpreter</li>
<li class="calibre12">Mediator</li>
<li class="calibre12">Memento</li>
<li class="calibre12">Visitor</li>
<li class="calibre12">Template method</li>
<li class="calibre12">Observer</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Strategy</h1>
                
            
            
                
<p class="calibre2">Remember <em class="calibre14">Maronic,</em> the platformer we were designing in <a href="part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 3</a>, <em class="calibre14">Understanding Structural Patterns</em>, while discussing the <strong class="calibre5">Facade</strong> design pattern?</p>
<p class="calibre2">Well, canary Michael, who acts as a game designer in our small indie game development company, came up with a great idea. What if we were to give our hero an arsenal of weapons to protect us from those horrible carnivorous snails?</p>
<p class="calibre2">Weapons all shoot projectiles (you don't want to get close to those dangerous snails) in the direction our hero is facing:</p>
<pre class="calibre18">enum class Direction {<br class="title-page-name"/>    LEFT, RIGHT<br class="title-page-name"/>}</pre>
<p class="calibre2">All projectiles should have a pair of coordinates (our game is 2D, remember?) and a direction:</p>
<pre class="calibre18">abstract class Projectile(private val x: Int,<br class="title-page-name"/>                          private val y: Int,<br class="title-page-name"/>                          private val direction: Direction)</pre>
<p class="calibre2">If we were to shoot only one type of projectile, that would be simple, since we already covered the <strong class="calibre5">Factory</strong> pattern in <a href="part0054.html#1JFUC0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 2</a>, <em class="calibre14">Working with Creational Patterns</em>:</p>
<pre class="calibre18">class OurHero {<br class="title-page-name"/>    private var direction = Direction.LEFT<br class="title-page-name"/>    private var x: Int = 42<br class="title-page-name"/>    private var y: Int = 173<br class="title-page-name"/><br class="title-page-name"/>    fun shoot(): Projectile {<br class="title-page-name"/>        return object : Projectile(x, y, direction) {<br class="title-page-name"/>            // Draw and animate projectile here<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">But Michael wants our hero to have at least three different weapons:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Peashooter</strong>: Shoots small peas that fly straight. Our hero starts with it.</li>
<li class="calibre12"><strong class="calibre1">Pomegranate</strong>: Explodes when hitting an enemy, much like a grenade.</li>
<li class="calibre12"><strong class="calibre1">Banana</strong>: Returns like a boomerang when it reaches the end of the screen.</li>
</ul>
<p class="calibre2">Come on, Michael, give us some slack! Can't you just stick with regular guns that all work the same?!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fruit arsenal</h1>
                
            
            
                
<p class="calibre2">First, let's discuss how we could solve this in <em class="calibre14">the Java way</em>.</p>
<p class="calibre2">In Java, we would have created an interface, that abstracts the changes. In our case, what changes is our hero's weapon:</p>
<pre class="calibre18">interface Weapon {<br class="title-page-name"/>    fun shoot(x: Int,<br class="title-page-name"/>              y: Int,<br class="title-page-name"/>              direction: Direction): Projectile<br class="title-page-name"/>}</pre>
<p class="calibre2">Then all other weapons would implement this interface:</p>
<pre class="calibre18">class Peashooter : Weapon {<br class="title-page-name"/>    override fun shoot(x: Int,<br class="title-page-name"/>                       y: Int,<br class="title-page-name"/>                       direction: Direction) = <br class="title-page-name"/>                        object : Projectile(x, y, direction) {<br class="title-page-name"/>        // Fly straight<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Pomegranate : Weapon {<br class="title-page-name"/>    override fun shoot(x: Int,<br class="title-page-name"/>                       y: Int,<br class="title-page-name"/>                       direction: Direction)  = <br class="title-page-name"/>                        object : Projectile(x, y, direction) {<br class="title-page-name"/>        // Explode when you hit first enemy<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Banana : Weapon {<br class="title-page-name"/>    override fun shoot(x: Int,<br class="title-page-name"/>                       y: Int,<br class="title-page-name"/>                       direction: Direction)  = <br class="title-page-name"/>                        object : Projectile(x, y, direction) {<br class="title-page-name"/>        // Return when you hit screen border<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Then our hero would hold a reference to a weapon (<kbd class="calibre13">Peashooter</kbd> at the beginning):</p>
<pre class="calibre18">private var currentWeapon : Weapon = Peashooter()</pre>
<p class="calibre2">It would delegate the actual shooting process to it:</p>
<pre class="calibre18">fun shoot(): Projectile = currentWeapon.shoot(x, y, direction)</pre>
<p class="calibre2">What's left is the ability to equip another weapon:</p>
<pre class="calibre18">fun equip(weapon: Weapon) {<br class="title-page-name"/>    currentWeapon = weapon<br class="title-page-name"/>}</pre>
<p class="calibre2">And that's what the <strong class="calibre5">Strategy</strong> design pattern is all about. Now, our algorithms (Maronic's weapons, in that case) are interchangeable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Citizen function</h1>
                
            
            
                
<p class="calibre2">With Kotlin, there's a more efficient way to implement the same functionality using fewer classes. That's thanks to the fact that functions in Kotlin are <em class="calibre14">first-class citizens</em>.</p>
<p class="calibre2">What does that mean? </p>
<p class="calibre2">For one, we can assign functions to the variables of our class, like any other normal value. </p>
<p class="calibre2">It makes sense that you can assign a primitive value to your variable:</p>
<pre class="calibre18">val x = 7</pre>
<p class="calibre2">You could either assign an object to it:</p>
<pre class="calibre18">var myPet = Canary("Michael")</pre>
<p class="calibre2">So, why should you be able to assign a function to your variable? As follows:</p>
<pre class="calibre18">val square = fun (x: Int): Long {<br class="title-page-name"/>    return (x * x).toLong()<br class="title-page-name"/>}</pre>
<p class="calibre2">With Kotlin, this is totally valid. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Switching sides</h1>
                
            
            
                
<p class="calibre2">So, how do higher-order functions help us here?</p>
<p class="calibre2">First, we'll define a namespace for all our weapons. This is not mandatory, but helps to keep everything in check:</p>
<pre class="calibre18">object Weapons {<br class="title-page-name"/>    // Functions we'll be there soon<br class="title-page-name"/>}</pre>
<p class="calibre2">Then, instead of classes, each of our weapons will become a function:</p>
<pre class="calibre18">val peashooter = fun(x: Int, y: Int, direction: Direction):             Projectile {<br class="title-page-name"/>        // Fly straight<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val banana = fun(x: Int, y: Int, direction: Direction): <br class="title-page-name"/>    Projectile {<br class="title-page-name"/>        // Return when you hit screen border<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val pomegranate = fun(x: Int, y: Int, direction: Direction):             Projectile {<br class="title-page-name"/>        // Explode when you hit first enemy<br class="title-page-name"/>}    </pre>
<p class="calibre2">The most interesting part is our hero. It now holds two functions:</p>
<pre class="calibre18">class OurHero {<br class="title-page-name"/>    // As before<br class="title-page-name"/>    var currentWeapon = Weapons.peashooter<br class="title-page-name"/><br class="title-page-name"/>    val shoot = fun() {<br class="title-page-name"/>        currentWeapon(x, y, direction)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The interchangeable part is <kbd class="calibre13">currentWeapon</kbd>, while <kbd class="calibre13">shoot</kbd> is now an anonymous function that wraps it.</p>
<p class="calibre2">To test that our idea works, we can shoot the default weapon once, then switch to <kbd class="calibre13">Banana</kbd> and shoot it again:</p>
<pre class="calibre18">val h = OurHero()<br class="title-page-name"/>h.shoot()<br class="title-page-name"/>h.currentWeapon = Weapons.banana<br class="title-page-name"/>h.shoot()</pre>
<p class="calibre2">Notice that this dramatically reduces the number of classes we have to write, while keeping the functionality the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Iterator</h1>
                
            
            
                
<p class="calibre2">When we were discussing the <strong class="calibre5">Composite</strong> design pattern in the previous chapter, we noted that the design pattern felt a bit incomplete. Now is the time to reunite the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito, they're very different, but complement each other well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">One, two... many</h1>
                
            
            
                
<p class="calibre2">We're back to our squads and platoons in our <em class="calibre14">CatsCraft 2: Revenge of the Dogs</em> strategy game.</p>
<p class="calibre2">As you may remember from the previous chapter, <kbd class="calibre13">Squad</kbd> consists of <kbd class="calibre13">InfantryUnits</kbd>:</p>
<pre class="calibre18">interface InfantryUnit<br class="title-page-name"/><br class="title-page-name"/>class Squad(val infantryUnits: MutableList&lt;InfantryUnit&gt; =         mutableListOf()) {   <br class="title-page-name"/>}</pre>
<p class="calibre2">Each squad should also get a commander now. </p>
<p class="calibre2">The commander of a squad called <kbd class="calibre13">Sergeant</kbd> is also an <kbd class="calibre13">InfantryUnit</kbd>:</p>
<pre class="calibre18">class Squad(...) {<br class="title-page-name"/>    val commander = Sergeant()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Sergeant: InfantryUnit</pre>
<p class="calibre2">Please disregard the fact that our sergeant doesn't have a name and gets created on the fly. We're two days short of releasing this game and beating the competition. Names are not important now.</p>
<p class="calibre2">The platoon is a collection of squads, and it also has a commander, called <kbd class="calibre13">Lieutenant</kbd>:</p>
<pre class="calibre18">class Platoon(val squads: MutableList&lt;Squad&gt; = mutableListOf()) {<br class="title-page-name"/>    val commander = Lieutenant()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Lieutenant: InfantryUnit</pre>
<p class="calibre2">What our CEO wants is a platoon, and to be able to know which units it consists of.</p>
<p class="calibre2">So, when we have the following lines in our code:</p>
<pre class="calibre18">val rangers = Squad("Josh", "Ew    an", "Tom")<br class="title-page-name"/>val deltaForce = Squad("Sam", "Eric", "William")<br class="title-page-name"/>val blackHawk = Platoon(rangers, deltaForce)<br class="title-page-name"/><br class="title-page-name"/>for (u in blackHawk) {<br class="title-page-name"/>    println(u)<br class="title-page-name"/>}</pre>
<p class="calibre2">We would print by order of seniority:</p>
<pre class="calibre18">Lieutenant, Sergeant, Josh, Ewan, Tom, ...</pre>
<p class="calibre2">Nowadays, this task may seem trivial to you, especially if you come from the Java world. But back in '94, data structures were mostly arrays of primitive types. Yes, <kbd class="calibre13">Array&lt;Int&gt;</kbd>, I'm looking at you.</p>
<p class="calibre2">Iterating over an array wouldn't be that hard, even in Java:</p>
<pre class="calibre18">int[] array = new int[] {1, 2, 3};<br class="title-page-name"/>        <br class="title-page-name"/>for (int i = 0; i &lt; array.length; i++) {<br class="title-page-name"/>    System.out.println(i);<br class="title-page-name"/>}</pre>
<p class="calibre2">What are we to do with something much more complex?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Running through the values</h1>
                
            
            
                
<p class="calibre2">If you're using an IDE such as IntelliJ, it will give you a hint on what the problem may be:</p>
<pre class="calibre18">for (u in blackHawk) { &lt;== <strong class="calibre1">For-loop range must have an 'iterator()'                            method</strong><br class="title-page-name"/>    // Wanted to do something here<br class="title-page-name"/>}</pre>
<p class="calibre2">So, our Platoon needs to have a function called <kbd class="calibre13">iterator()</kbd>. And since it's a special function, we'll need to use the <kbd class="calibre13">operator</kbd> keyword.</p>
<pre class="calibre18">operator fun iterator() = ...</pre>
<p class="calibre2">What our function returns is an anonymous object that implements the <kbd class="calibre13">Iterator&lt;T&gt;</kbd> interface:</p>
<pre class="calibre18">... = object: Iterator&lt;InfantryUnit&gt; {<br class="title-page-name"/>    override fun hasNext(): Boolean {<br class="title-page-name"/>        // Are there more objects to iterate over?<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun next(): InfantryUnit {<br class="title-page-name"/>        // Return next InfantryUnit<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The idea behind the iterator design pattern is to separate how the object stores data (in our case, it's something like a tree) and how we can go over this data. As you may know, trees can be iterated in one of two ways:</p>
<ul class="calibre11">
<li class="calibre12">depth-first (also known as <strong class="calibre1">depth-first search</strong> (<strong class="calibre1">DFS</strong>))</li>
<li class="calibre12">breadth-first (also known as <strong class="calibre1">breadth-first search</strong> (<strong class="calibre1">BFS</strong>))</li>
</ul>
<p class="calibre2">But do we really care when we need to fetch all the elements?</p>
<p class="calibre2">So, we separate these two concerns: storage aside, repeating aside.</p>
<p class="calibre2">To go over all the elements, we need to implement two methods, one to fetch the next element, and one to let the loop know when to stop.</p>
<p class="calibre2">As an example, we'll implement this object for <kbd class="calibre13">Squad</kbd>. For Platoon, the logic would be similar, but requires a bit more math.</p>
<p class="calibre2">First, we need a state for our iterator. It will remember that the last element is returned:</p>
<pre class="calibre18">operator fun iterator() = object: Iterator&lt;InfantryUnit&gt; {<br class="title-page-name"/>    var i = 0<br class="title-page-name"/>    // More code here<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, we need to tell it when to stop. In our case, the total number of elements is all the units of the squad, plus the sergeant:</p>
<pre class="calibre18">override fun hasNext(): Boolean {<br class="title-page-name"/>    return i &lt; infantryUnits.size + 1<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, we need to know which unit to return. If that was the first call, we'll return the sergeant. The next calls will return one of the squad members:</p>
<pre class="calibre18">override fun next() =<br class="title-page-name"/>    when (i) {<br class="title-page-name"/>        0 -&gt; commander<br class="title-page-name"/>        else -&gt; infantryUnits[i - 1]<br class="title-page-name"/>    }.also { i++ }</pre>
<p>Note that we want to return the next unit, but also to increase our counter.<br class="calibre21"/>
For that, we use the also <kbd class="calibre20">{}</kbd> block.</p>
<p class="calibre2">That's only one of the usages of this pattern.</p>
<p class="calibre2">The same object may also have more than one iterator. For example, we could have the second iterator for our squad that would go over elements in reverse order. </p>
<p class="calibre2">To use it, we'll need to call it by name:</p>
<pre class="calibre18">for (u in deltaForce<strong class="calibre1">.reverseIterator()</strong>) {<br class="title-page-name"/>    println(u)<br class="title-page-name"/>}</pre>
<p class="calibre2">Since it's just a simple function that returns an iterator now, we don't need the <kbd class="calibre13">operator</kbd> keyword:</p>
<pre class="calibre18">fun reverseIterator() = object: Iterator&lt;InfantryUnit&gt; {<br class="title-page-name"/>    // hasNext() is same as before<br class="title-page-name"/>}</pre>
<p class="calibre2">The only changes are coming in the <kbd class="calibre13">next()</kbd> method:</p>
<pre class="calibre18">override fun next() =<br class="title-page-name"/>        when (i) {<br class="title-page-name"/>            infantryUnits.size -&gt; commander<br class="title-page-name"/>            else -&gt; infantryUnits[infantryUnits.size - i - 1]<br class="title-page-name"/>        }.also { i++ }</pre>
<p class="calibre2">Sometimes, it also makes sense to receive an iterator as a parameter for a function:</p>
<pre class="calibre18">fun &lt;T&gt; printAll(iter: Iterator&lt;T&gt;) {<br class="title-page-name"/>    while (iter.hasNext()) {<br class="title-page-name"/>        println(iter.next())<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This function will iterate over anything that supplies an iterator:</p>
<pre class="calibre18">printAll(deltaForce.iterator())<br class="title-page-name"/>printAll(deltaForce.reverseIterator())</pre>
<p class="calibre2">This will print our squad members twice, once in regular and once in reverse order.</p>
<p class="calibre2">As a regular developer who doesn't invent new data structures for his or her living, you may now implement iterators often. But it's important to know how they work behind the scenes nevertheless. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">State</h1>
                
            
            
                
<p class="calibre2">You can think of the <strong class="calibre5">State</strong> design pattern as an opinionated Strategy, which we discuss at the beginning of this chapter. But while Strategy is changed from the outside, by the <em class="calibre14">client</em>, the State may change internally, based solely on the input it gets.</p>
<p class="calibre2">Look at this dialog a client wrote with Strategy:</p>
<p>Client: Here’s a new thing to do, start doing it from now on.</p>
<p>Strategy: OK, no problem.</p>
<p>Client: What I like about you is that you never argue with me.</p>
<p class="calibre2">Compare it with this one:</p>
<p>Client: Here’s some new input I got from you.</p>
<p>State: Oh, I don't know. Maybe I'll start doing something differently. Maybe not.</p>
<p class="calibre2">The client should also expect that the State may even reject some of its inputs:</p>
<p>Client: Here's something for you to ponder, State.</p>
<p>State: I don't know what it is! Don't you see I'm busy? Go bother some Strategy with this!</p>
<p class="calibre2">So, why do clients still tolerate that State of ours? Well, State is really good at keeping everything under control.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fifty shades of State</h1>
                
            
            
                
<p class="calibre2">Carnivorous snails have had enough of this Maronic hero. He throws peas and bananas at them, only to get to another sorry castle. Now they shall act!</p>
<p class="calibre2">By default, the snail should stand still to conserve snail energy. But when the hero gets close, it dashes towards him aggressively. </p>
<p class="calibre2">If the hero manages to injure it, it should retreat to lick its wounds. Then it will repeat attacking, until one of them is dead.</p>
<p class="calibre2">First, we'll declare what can happen during a snail's life:</p>
<pre class="calibre18">interface WhatCanHappen {<br class="title-page-name"/>    fun seeHero()<br class="title-page-name"/><br class="title-page-name"/>    fun getHit(pointsOfDamage: Int)<br class="title-page-name"/><br class="title-page-name"/>    fun calmAgain()<br class="title-page-name"/>}</pre>
<p class="calibre2">Our snail implements this interface, so it can get notified of anything that may happen to it and act accordingly:</p>
<pre class="calibre18">class Snail : WhatCanHappen {<br class="title-page-name"/>    private var healthPoints = 10<br class="title-page-name"/><br class="title-page-name"/>    override fun seeHero() {<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun getHit(pointsOfDamage: Int) {<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun timePassed() {<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we declare the <kbd class="calibre13">Mood</kbd> class, which we mark with the <kbd class="calibre13">sealed</kbd> keyword:</p>
<pre class="calibre18">sealed class Mood {<br class="title-page-name"/>   // Some abstract methods here, like draw(), for example<br class="title-page-name"/>}</pre>
<p class="calibre2">Sealed classes are abstract and cannot be instantiated. We'll see the benefit of using them in a moment. But before that, let's declare other states:</p>
<pre class="calibre18">class Still : Mood() <br class="title-page-name"/><br class="title-page-name"/>class Aggressive : Mood()<br class="title-page-name"/><br class="title-page-name"/>class Retreating : Mood()<br class="title-page-name"/><br class="title-page-name"/>class Dead : Mood()</pre>
<p class="calibre2">Those are all different states, sorry, moods, of our snail.</p>
<p class="calibre2">In State design pattern terms, <kbd class="calibre13">Snail</kbd> is the context. It holds the state. So, we declare a member for it:</p>
<pre class="calibre18">class Snail : WhatCanHappen {<br class="title-page-name"/>    private var mood: Mood = Still()<br class="title-page-name"/>    // As before<br class="title-page-name"/>}</pre>
<p class="calibre2">Now let's define what <kbd class="calibre13">Snail</kbd> should do when it sees our hero:</p>
<pre class="calibre18">override fun seeHero() {<br class="title-page-name"/>        mood = when(mood) {<br class="title-page-name"/>            is Still -&gt; Aggressive()<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Compilation error! Well, that's where the <kbd class="calibre13">sealed</kbd> class comes into play. Much like with an <kbd class="calibre13">enum</kbd>, Kotlin knows that there's a finite number of classes that extend from it. So, it requires that our <kbd class="calibre13">when</kbd> is exhaustive and specifies all different cases in it. </p>
<p>If you're using IntelliJ as your IDE, it will even suggest you "add remaining branches" automatically.</p>
<p class="calibre2">Let's describe our state:</p>
<pre class="calibre18">override fun seeHero() {<br class="title-page-name"/>    mood = when(mood) {<br class="title-page-name"/>        is Still -&gt; Aggressive()<br class="title-page-name"/>        is Aggressive -&gt; mood<br class="title-page-name"/>        is Retreating -&gt; mood<br class="title-page-name"/>        is Dead -&gt; mood<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Of course, <kbd class="calibre13">else</kbd> still works:</p>
<pre class="calibre18">override fun timePassed() {<br class="title-page-name"/>    mood = when(mood) {<br class="title-page-name"/>        is Retreating -&gt; Aggressive()<br class="title-page-name"/>        else -&gt; mood<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">When the snail gets hit, we need to decide if it's dead or not. For that, we can use <kbd class="calibre13">when</kbd> without an argument:</p>
<pre class="calibre18">override fun getHit(pointsOfDamage: Int) {<br class="title-page-name"/>    healthPoints -= pointsOfDamage<br class="title-page-name"/>    <br class="title-page-name"/>    mood = when {<br class="title-page-name"/>        (healthPoints &lt;= 0) -&gt; Dead()<br class="title-page-name"/>        mood is Aggressive -&gt; Retreating()<br class="title-page-name"/>        else -&gt; mood<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we use the <kbd class="calibre13">is</kbd> keyword, which is the same as <kbd class="calibre13">instanceof</kbd> in Java, but more concise. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">State of the Nation</h1>
                
            
            
                
<p class="calibre2">The previous approach has most of the logic in our <em class="calibre14">context</em>. You may sometimes see a different approach, which is valid as your <em class="calibre14">context</em> grows bigger.</p>
<p class="calibre2">In this approach, <kbd class="calibre13">Snail</kbd> would become really thin:</p>
<pre class="calibre18">class Snail {<br class="title-page-name"/>    <strong class="calibre1">internal</strong> var mood: Mood = Still(this)<br class="title-page-name"/><br class="title-page-name"/>    private var healthPoints = 10<br class="title-page-name"/>    // That's all!<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we marked <kbd class="calibre13">mood</kbd> as <kbd class="calibre13">internal</kbd>. That lets other classes in that package alter it.</p>
<p class="calibre2">Instead of <kbd class="calibre13">Snail</kbd> implementing <kbd class="calibre13">WhatCanHappen</kbd>, our Mood will:</p>
<pre class="calibre18">sealed class Mood : WhatCanHappen</pre>
<p class="calibre2">And now the logic resides within our state objects:</p>
<pre class="calibre18">class Still(private val snail: Snail) : Mood() {<br class="title-page-name"/>    override fun seeHero() = snail.mood.run {<br class="title-page-name"/>            Aggressive(snail)<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>    override fun getHit(pointsOfDamage: Int) = this<br class="title-page-name"/>    override fun timePassed() = this<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that our state objects now receive a reference to their context in the constructor.</p>
<p class="calibre2">That's the first time we've met the <kbd class="calibre13">run</kbd> extension function. It's equivalent would be:</p>
<pre class="calibre18">override fun seeHero(): Mood {<br class="title-page-name"/>    snail.mood = Aggressive(snail)<br class="title-page-name"/>    return snail.mood<br class="title-page-name"/>}</pre>
<p class="calibre2">By using run, we can preserve the same logic, but omit the function body.</p>
<p class="calibre2">You'll need to decide what approach to use. In our example, this will actually produce much more code, will have to implement all the methods by itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Command</h1>
                
            
            
                
<p class="calibre2">This design pattern allows you to encapsulate action inside an object to be executed sometime later. </p>
<p class="calibre2">Furthermore, if we can execute one action later on, why not execute many? Why not schedule exactly when to execute? </p>
<p class="calibre2">That's exactly what we need to do in our <em class="calibre14">CatsCraft 2: Revenge of the Dogs</em> game now<em class="calibre14">. </em>Dave, a new developer that we've hired lately, was working hard the whole weekend, while no one was allowed to bother him. He implemented the following abstract methods for our furry soldiers:</p>
<pre class="calibre18">class Soldier(...)... {<br class="title-page-name"/>    fun attack(x: Long, y: Long) {<br class="title-page-name"/>        println("Attacking ($x, $y)")<br class="title-page-name"/>        // Actual code here<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun move(x: Long, y: Long) {<br class="title-page-name"/>        println("Moving to ($x, $y)")<br class="title-page-name"/>        // Actual code here<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">He probably even used the <strong class="calibre5">Bridge</strong> design pattern from the previous chapter to do that. </p>
<p class="calibre2">The problem we need to solve now is that the soldier can remember exactly one <em class="calibre14">command</em>. That's it. If he starts at <kbd class="calibre13">(0, 0)</kbd>, the top of the screen, we first tell him to <kbd class="calibre13">move(20, 0)</kbd>, that's 20 steps right, and then to <kbd class="calibre13">move(20, 20)</kbd>, so he'll move straight to <kbd class="calibre13">(20, 20)</kbd>, and will probably get totally destroyed, because there are dog enemies to avoid at all costs:</p>
<pre class="calibre18">[cat](0, 0) ⇒  good direction  ⇒    (20, 0)<br class="title-page-name"/><br class="title-page-name"/>          [dog] [dog]                   ⇓<br class="title-page-name"/>        [dog] [dog] [dog]               ⇓<br class="title-page-name"/>           [dog] [dog]<br class="title-page-name"/>            (5, 20)                  (20, 20)</pre>
<p class="calibre2">If you've been following this book from the start, or at least joined at <a href="part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 3</a>, <em class="calibre14">Understanding Structural Patterns</em>, you probably have an idea of what we need to do, since we already discussed the concept of <em class="calibre14">functions as first-class citizens</em> in the language. </p>
<p class="calibre2">But even if you decided to just figure out how the Command design pattern should work in Kotlin, or opened this book randomly to this section, we'll give you a brief explanation on how that dog obstacle could be solved.</p>
<p class="calibre2">Let's sketch a skeleton for that. We know that we want to hold a list of objects, but we don't know yet what type they should be. So we'll use <kbd class="calibre13">Any</kbd> for now:</p>
<pre class="calibre18">class Soldier {<br class="title-page-name"/>    private val orders = mutableListOf&lt;Any&gt;() <br class="title-page-name"/><br class="title-page-name"/>    fun anotherOrder(action: Any) {<br class="title-page-name"/>        this.orders.add(command)<br class="title-page-name"/>    }<br class="title-page-name"/>    // More code here<br class="title-page-name"/>}</pre>
<p class="calibre2">Then, we want to iterate over the list and execute the orders we have:</p>
<pre class="calibre18">class Soldier {<br class="title-page-name"/>    ...<br class="title-page-name"/>    // This will be triggered from the outside once in a while<br class="title-page-name"/>    fun execute() {<br class="title-page-name"/>        while (!orders.isEmpty()) {<br class="title-page-name"/>            val action = orders.removeAt(0)<br class="title-page-name"/>            action.execute() // Compile error for now<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">So, even if you're not familiar with the Command design pattern, you can guess that we can define an interface with a single method, <kbd class="calibre13">execute()</kbd>:</p>
<pre class="calibre18">interface Command {<br class="title-page-name"/>    fun execute()<br class="title-page-name"/>}</pre>
<p class="calibre2">And then hold a list of the same time in a member property:</p>
<pre class="calibre18">private val commands = mutableListOf&lt;Command&gt;()</pre>
<p class="calibre2">Implement this interface as needed. That's basically what the Java implementation of this pattern would suggest in most cases. But isn't there a better way? </p>
<p class="calibre2">Let's look at the Command again. Its <kbd class="calibre13">execute()</kbd> method receives nothing, returns nothing, and does something. It's the same as writing the following code then:</p>
<pre class="calibre18">fun command(): Unit {<br class="title-page-name"/>  // Some code here<br class="title-page-name"/>}</pre>
<p class="calibre2">It's not different at all. We could simplify this further:</p>
<pre class="calibre18">() -&gt; Unit</pre>
<p class="calibre2">Instead of having an interface for that called <kbd class="calibre13">Command</kbd>, we'll have a <kbd class="calibre13">typealias</kbd>:</p>
<pre class="calibre18">typealias Command = ()-&gt;Unit</pre>
<p class="calibre2">Now, this line stops compiling again:</p>
<pre class="calibre18">command.execute() // Unresolved reference: execute </pre>
<p class="calibre2">Well, that's because <kbd class="calibre13">execute()</kbd> is just some name we invented. In Kotlin, functions use <kbd class="calibre13">invoke()</kbd>:</p>
<pre class="calibre18">command.invoke() // Compiles</pre>
<p class="calibre2">That's nice, but the functions Dave wrote receive arguments, and our function has no parameters at all. </p>
<p class="calibre2">One option would be to change the signature of our <kbd class="calibre13">Command</kbd> to receive two parameters: </p>
<pre class="calibre18">(x: Int, y: Int)-&gt;Unit</pre>
<p class="calibre2">But what if some commands receive no arguments, or only one, or more than two? We also need to remember what to pass to <kbd class="calibre13">invoke()</kbd> at each step.</p>
<p class="calibre2">A much better way is to have a function generator. That is, a function that returns another function.</p>
<p class="calibre2">If you ever worked with JavaScript language, that's a common practice to use closures to limit the scope and <em class="calibre14">remember</em> stuff. We'll do the same:</p>
<pre class="calibre18">val moveGenerator = fun(s: Soldier,<br class="title-page-name"/>                        x: Int,<br class="title-page-name"/>                        y: Int): Command {<br class="title-page-name"/>    return fun() {<br class="title-page-name"/>        s.move(x, y)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">When called with proper arguments, <kbd class="calibre13">moveGenerator</kbd> will return a new function. That function can be invoked whenever we find it suitable, and it will <em class="calibre14">remember</em>:</p>
<ul class="calibre11">
<li class="calibre12">What method to call</li>
<li class="calibre12">With which arguments</li>
<li class="calibre12">On which object</li>
</ul>
<p class="calibre2">Now, our <kbd class="calibre13">Soldier</kbd> may have a method like this:</p>
<pre class="calibre18">fun appendMove(x: Int, y: Int) = apply {<br class="title-page-name"/>        commands.add(moveGenerator(this, x, y))<br class="title-page-name"/>}</pre>
<p class="calibre2">It provides us with a nice fluent syntax:</p>
<pre class="calibre18">val s = Soldier()<br class="title-page-name"/>s.appendMove(20, 0)<br class="title-page-name"/>    .appendMove(20, 20)<br class="title-page-name"/>    .appendMove(5, 20)<br class="title-page-name"/>    .execute()</pre>
<p class="calibre2">This code will print the following:</p>
<pre class="calibre18"><strong class="calibre1">Moving to (20, 0)</strong><br class="title-page-name"/><strong class="calibre1">Moving to (20, 20)</strong><br class="title-page-name"/><strong class="calibre1">Moving to (5, 20)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Undoing commands</h1>
                
            
            
                
<p class="calibre2">While not directly related, one of the advantages of the Command design pattern is the ability to undo commands. What if we wanted to support such a functionality?</p>
<p class="calibre2">Undoing is usually very tricky, because it involves one of the following:</p>
<ul class="calibre11">
<li class="calibre12">Returning to the previous state (impossible if there's more than one client, requires a lot of memory)</li>
<li class="calibre12">Computing deltas (tricky to implement)</li>
<li class="calibre12">Defining opposite operations (not always possible)</li>
</ul>
<p class="calibre2">In our case, the opposite of the command <em class="calibre14">move from (0,0) to (0, 20)</em> would be <em class="calibre14">move from wherever you're now to (0,0)</em>. This could be achieved by storing a pair of commands:</p>
<pre class="calibre18">private val commands = mutableListOf&lt;Pair&lt;Command, Command&gt;&gt;()</pre>
<p class="calibre2">You can also add pairs of commands:</p>
<pre class="calibre18">fun appendMove(x: Int, y: Int) = apply {<br class="title-page-name"/>    val oppositeMove = /* If it's the first command, generate move to current location. Otherwise, get the previous command */<br class="title-page-name"/>    commands.add(moveGenerator(this, x, y) to oppositeMove)<br class="title-page-name"/>}</pre>
<p class="calibre2">Actually, computing the opposite move is quite complex, as we don't save the position of our soldier currently (it was something Dave should have implemented anyway), and we'll also have to deal with some edge cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Chain of responsibility</h1>
                
            
            
                
<p class="calibre2">I'm a horrible software architect, and I don't like to speak with people. Hence, while sitting in The Ivory Tower (that's the name of the cafe I often visit), I wrote a small web application. If a developer has a question, he shouldn't approach me directly, oh no. He'll need to send me a proper request through this system, and I shall answer him only if I deem this request worthy.</p>
<p class="calibre2">A filter chain is a very common concept in web servers. Usually, when a request reaches to you, it's expected that:</p>
<ul class="calibre11">
<li class="calibre12">Its parameters are already validated</li>
<li class="calibre12">The user is already authenticated, if possible</li>
<li class="calibre12">User roles and permissions are known, and the user is authorized to perform an action</li>
</ul>
<p class="calibre2">So, the code I initially wrote looked something like this:</p>
<pre class="calibre18">fun handleRequest(r: Request) {<br class="title-page-name"/>    // Validate<br class="title-page-name"/>    if (r.email.isEmpty() || r.question.isEmpty()) {<br class="title-page-name"/>        return<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    // Authenticate<br class="title-page-name"/>    // Make sure that you know whos is this user<br class="title-page-name"/>    if (r.email.isKnownEmail()) {<br class="title-page-name"/>        return<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    // Authorize<br class="title-page-name"/>    // Requests from juniors are automatically ignored by architects<br class="title-page-name"/>    if (r.email.isJuniorDeveloper()) {<br class="title-page-name"/>        return<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println("I don't know. Did you check StackOverflow?")<br class="title-page-name"/>}</pre>
<p class="calibre2">A bit messy, but it works.</p>
<p class="calibre2">Then I noticed that some developers decide they can send me two questions at once. Gotta add some more logic to this function. But wait, I'm an architect, after all. Isn't there a better way to <em class="calibre14">delegate</em> this?</p>
<p class="calibre2">This time, we won't learn new Kotlin tricks, but use those that we already learned. We could start with implementing an interface such as this one:</p>
<pre class="calibre18">interface Handler {<br class="title-page-name"/>    fun handle(request: Request): Response<br class="title-page-name"/>}</pre>
<p class="calibre2">We never discussed what my response to one of the developers looked like. That's because I keep my chain of responsibility so long and complex that usually, they tend to solve problems by themselves. I've never had to answer one of them, quite frankly. But at least we know what their requests look like:</p>
<pre class="calibre18">data class Request(val email: String, val question: String)<br class="title-page-name"/><br class="title-page-name"/>data class Response(val answer: String)</pre>
<p class="calibre2">Then we could do it the Java way, and start implementing each piece of logic inside its own handler:</p>
<pre class="calibre18">class BasicValidationHandler(private val next: Handler) : Handler {<br class="title-page-name"/>    override fun handle(request: Request): Response {<br class="title-page-name"/>        if (request.email.isEmpty() || request.question.isEmpty()) {<br class="title-page-name"/>            throw IllegalArgumentException()<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        return next.handle(request)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Other filters would look very similar to this one. We can compose them in any order we want:</p>
<pre class="calibre18">val req = Request("developer@company.com", <br class="title-page-name"/>        "Who broke my build?")<br class="title-page-name"/><br class="title-page-name"/>val chain = AuthenticationHandler(<br class="title-page-name"/>                BasicValidationHandler(<br class="title-page-name"/>                    FinalResponseHandler()))<br class="title-page-name"/><br class="title-page-name"/>val res = chain.handle(req)<br class="title-page-name"/><br class="title-page-name"/>println(res) </pre>
<p class="calibre2">But I won't even ask you the rhetoric question this time about better ways. Of course there's a better way, we're in the Kotlin world now. And we've seen the usage of functions in the previous section. So, we'll define a function for that task:</p>
<pre class="calibre18">typealias Handler = (request: Request) -&gt; Response</pre>
<p class="calibre2">Why have a separate class and interface for something that receives a request and returns a response in a nutshell:</p>
<pre class="calibre18">val authentication = fun(next: Handler) =<br class="title-page-name"/>    fun(request: Request): Response {<br class="title-page-name"/>        if (!request.email.isKnownEmail()) {<br class="title-page-name"/>            throw IllegalArgumentException()<br class="title-page-name"/>        }<br class="title-page-name"/>        return next(request)<br class="title-page-name"/>    }</pre>
<p class="calibre2">Here, <kbd class="calibre13">authentication</kbd> is a function that literally receives a function and returns a function. </p>
<p class="calibre2">Again, we can compose those functions:</p>
<pre class="calibre18">val req = Request("developer@company.com", <br class="title-page-name"/>    "Why do we need Software Architects?")<br class="title-page-name"/><br class="title-page-name"/>val chain = basicValidation(authentication(finalResponse()))<br class="title-page-name"/><br class="title-page-name"/>val res = chain(req)<br class="title-page-name"/><br class="title-page-name"/>println(res)</pre>
<p class="calibre2">It's up to you which method you choose. Using interfaces is more explicit, and would better suit you if you're creating your own library or framework that others may want to extend.</p>
<p class="calibre2">Using functions is more concise, and if you just want to split your code in a more manageable way, it may be the better choice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Interpreter</h1>
                
            
            
                
<p class="calibre2">This design pattern may seem very simple or very hard, all based on how much background you have in computer science. Some books that discuss classical software design patterns even decide to omit it altogether, or put it somewhere at the end, for curious readers only.</p>
<p class="calibre2">The reason behind this is that the interpreter design pattern deals with translating certain languages. But why would we need that? Don't we have compilers to do that anyway? </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">We need to go deeper</h1>
                
            
            
                
<p class="calibre2">In this section we discuss that all developers have to speak many languages or sub-languages. Even as regular developers, we use more than one language. Think of tools that build your projects, like Maven or Gradle. You can consider their configuration files, <strong class="calibre5">build scripts</strong>, as languages with specific grammar. If you put elements out of order, your project won't be built correctly. And that's because such projects have interpreters to analyze configuration files and act upon them.</p>
<p class="calibre2">Other examples would be <strong class="calibre5">query languages</strong>, be it one of the SQL variations or one of the languages specific to NoSQL databases. </p>
<p class="calibre2">If you're an Android developer, you may think of XML layouts as such languages too. Even HTML could be considered a language that defines <strong class="calibre5">user interfaces</strong>. And there are others, of course.</p>
<p class="calibre2">Maybe you've worked with one of the <strong class="calibre5">testing frameworks</strong> that define a custom language for testing, such as Cucumber: <a href="https://github.com/cucumber" class="calibre10">github.com/cucumber</a>.</p>
<p class="calibre2">Each of these examples can be called a <strong class="calibre5">Domain Specific Language</strong> (<strong class="calibre5">DSL</strong>). A language inside a language. We'll discuss how it works in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A language of your own</h1>
                
            
            
                
<p class="calibre2">In this section, we'll define a simple DSL-for-SQL language. We won't define the format or grammar for it, but only an example of what it should look like:</p>
<pre class="calibre18">val sql = select("name, age", {<br class="title-page-name"/>              from("users", {<br class="title-page-name"/>                  where("age &gt; 25")<br class="title-page-name"/>              }) // Closes from<br class="title-page-name"/>          }) // Closes select<br class="title-page-name"/><br class="title-page-name"/>println(sql) // "SELECT name, age FROM users WHERE age &gt; 25"</pre>
<p class="calibre2">The goal of our language is to improve readability and prevent some common SQL mistakes, such as typos (like FORM instead of FROM). We'll get compile time validations and autocompletion along the way.</p>
<p class="calibre2">We'll start with the easiest part—<kbd class="calibre13">select</kbd>:</p>
<pre class="calibre18">fun select(columns: String, from: SelectClause.()-&gt;Unit): <br class="title-page-name"/>    SelectClause {<br class="title-page-name"/>    return SelectClause(columns).apply(from)<br class="title-page-name"/>}</pre>
<p>We could write this using single expression notation, but we use the more verbose version for clarity of the example.</p>
<p class="calibre2">This is a function that has two parameters. The first is a <kbd class="calibre13">String</kbd>, which is simple. The second is another function that receives nothing and returns nothing.</p>
<p class="calibre2">The most interesting part is that we specify the receiver for our lambda: </p>
<pre class="calibre18"><strong class="calibre1">SelectClause</strong>.()-&gt;Unit</pre>
<p class="calibre2">This is a very smart trick, so be sure to follow along:</p>
<pre class="calibre18"><strong class="calibre1">SelectClause</strong>.()-&gt;Unit == (<strong class="calibre1">SelectClause</strong>)-&gt;Unit</pre>
<p class="calibre2">Although it may seem that this lambda receives nothing, it actually receives one argument, an object of type <kbd class="calibre13">SelectClause</kbd>.</p>
<p class="calibre2">The second trick lies in the usage of the <kbd class="calibre13">apply()</kbd> function we've seen before.</p>
<p class="calibre2">Look at this:</p>
<pre class="calibre18">SelectClause(columns).apply(from)</pre>
<p class="calibre2">It translates to this:</p>
<pre class="calibre18">val selectClause = SelectClause(columns)<br class="title-page-name"/>from(selectClause)<br class="title-page-name"/>return selectClause</pre>
<p class="calibre2">Here are the steps the preceding code will perform:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Initialize <kbd class="calibre13">SelectClause</kbd>, which is a simple object that receives one argument in its constructor.</li>
<li value="2" class="calibre12">Call the <kbd class="calibre13">from()</kbd> function with an instance of <kbd class="calibre13">SelectClause</kbd> as its only argument.</li>
<li value="3" class="calibre12">Return an instance of <kbd class="calibre13">SelectClause</kbd>.</li>
</ol>
<p class="calibre2">That code only makes sense if <kbd class="calibre13">from()</kbd> does something useful with <kbd class="calibre13">SelectClause</kbd>.</p>
<p class="calibre2">Let's look at our DSL example again:</p>
<pre class="calibre18">select("name, age", {<br class="title-page-name"/><strong class="calibre1">    this@select.</strong>from("users", {<br class="title-page-name"/>        where("age &gt; 25")<br class="title-page-name"/>    })<br class="title-page-name"/>})</pre>
<p class="calibre2">We've made the receiver explicit now, meaning that the <kbd class="calibre13">from()</kbd> function will call the <kbd class="calibre13">from()</kbd> method on the <kbd class="calibre13">SelectClause</kbd> object.</p>
<p class="calibre2">You can start guessing what this method looks like. It clearly receives a <kbd class="calibre13">String</kbd> as its first argument, and another lambda as its second:</p>
<pre class="calibre18">class SelectClause(private val columns: String) {<br class="title-page-name"/>    private lateinit var from : FromClause<br class="title-page-name"/>    fun <strong class="calibre1">from</strong>(table: String, where: FromClause.()-&gt;Unit): FromClause {<br class="title-page-name"/>        this.from = FromClause(table)<br class="title-page-name"/>        return this.from.apply(where)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p>This could again be shortened, but then we'd need to use <kbd class="calibre20">apply()</kbd> within <kbd class="calibre20">apply()</kbd>, which may seem confusing at this point.</p>
<p class="calibre2">That's the first time we've met the <kbd class="calibre13">lateinit</kbd> keyword. This keyword is quite dangerous, so use it with some restraint. Remember that the Kotlin compiler is very serious about null safety. If we omit <kbd class="calibre13">lateinit</kbd>, it will require us to initialize the variable with a default value. But since we'll know it only at a later time, we ask the compiler to relax a bit. Note that if we don't make good on our promises and forget to initialize it, we'll get <kbd class="calibre13">UninitializedPropertyAccessException</kbd> when first accessing it.</p>
<p class="calibre2">Back to our code; all we do is:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create an instance of <kbd class="calibre13">FromClause</kbd></li>
<li value="2" class="calibre12">Store it as a member of <kbd class="calibre13">SelectClause</kbd></li>
<li value="3" class="calibre12">Pass an instance of <kbd class="calibre13">FromClause</kbd> to the <kbd class="calibre13">where</kbd> lambda</li>
<li value="4" class="calibre12">Return an instance of <kbd class="calibre13">FromClause</kbd></li>
</ol>
<p class="calibre2">Hopefully, you're starting to get the gist of it:</p>
<pre class="calibre18">select("name, age", {<br class="title-page-name"/>    this@select.from("users", {<br class="title-page-name"/><strong class="calibre1">        this@from.</strong>where("age &gt; 25")<br class="title-page-name"/>    })<br class="title-page-name"/>})</pre>
<p class="calibre2">What does it mean? After understanding the <kbd class="calibre13">from()</kbd> method, this should be much simpler. The <kbd class="calibre13">FromClause</kbd> must have a method called <kbd class="calibre13">where()</kbd> that receives one argument, of the <kbd class="calibre13">String</kbd> type:</p>
<pre class="calibre18">class FromClause(private val table: String) {<br class="title-page-name"/>    private lateinit var where: WhereClause<br class="title-page-name"/><br class="title-page-name"/>    fun <strong class="calibre1">where</strong>(conditions: String) = this.apply {<br class="title-page-name"/>        where = WhereClause(conditions)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we made good on our promise and shortened the method this time.</p>
<p class="calibre2">We initialized an instance of <kbd class="calibre13">WhereClause</kbd> with the string we received, and returned it. Simple as that:</p>
<pre class="calibre18">class WhereClause(private val conditions: String) {<br class="title-page-name"/>    override fun toString(): String {<br class="title-page-name"/>        return "WHERE $conditions"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">WhereClause</kbd> only prints the word <kbd class="calibre13">WHERE</kbd> and the conditions it received:</p>
<pre class="calibre18">class FromClause(private val table: String) {<br class="title-page-name"/>    // More code here...<br class="title-page-name"/>    override fun toString(): String {<br class="title-page-name"/>        return "FROM $table ${this.where}"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">FromClause</kbd> prints the word <kbd class="calibre13">FROM</kbd> as well as the table name it received, and everything <kbd class="calibre13">WhereClause</kbd> printed:</p>
<pre class="calibre18">class SelectClause(private val columns: String) {<br class="title-page-name"/>    // More code here...<br class="title-page-name"/>    override fun toString(): String {<br class="title-page-name"/>        return "SELECT $columns ${this.from}"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">SelectClause</kbd> prints the word <kbd class="calibre13">SELECT</kbd>, the columns it got, and whatever <kbd class="calibre13">FromClause</kbd> printed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Taking a break</h1>
                
            
            
                
<p class="calibre2">Kotlin provides beautiful capabilities to create readable and type-safe DSLs. But the interpreter design pattern is one of the hardest in the toolbox. If you didn't get it from the get-go, take some time to debug this code. Understand what <kbd class="calibre13">this</kbd> means at each step, as well as when we call a function and when we call a method of an object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Call suffix</h1>
                
            
            
                
<p class="calibre2">In order not to confuse you, we left out one last notion of Kotlin DSL until the end of this section.</p>
<p class="calibre2">Look at this DSL:</p>
<pre class="calibre18">val sql = select("name, age", {<br class="title-page-name"/>              from("users", {<br class="title-page-name"/>                  where("age &gt; 25")<br class="title-page-name"/>              }) // Closes from<br class="title-page-name"/>          }) // Closes select</pre>
<p class="calibre2">It could be rewritten as:</p>
<pre class="calibre18">val sql = select<strong class="calibre1">(</strong>"name, age"<strong class="calibre1">)</strong> {<br class="title-page-name"/>              from("users") {<br class="title-page-name"/>                  where("age &gt; 25")<br class="title-page-name"/>              } // Closes from<br class="title-page-name"/>          } // Closes select</pre>
<p class="calibre2">This is common practice in Kotlin. If our function receives another function as its last argument, we can pass it out of parentheses. </p>
<p class="calibre2">This results in a much clearer DSL, but may be confusing at first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mediator</h1>
                
            
            
                
<p class="calibre2">There's no way around it. The <strong class="calibre5">Mediator</strong> design pattern is simply a control freak. It doesn't like it when one object speaks to the other directly. It gets mad sometimes when that happens. No, everybody should speak only through him. What's his explanation? It reduces coupling between objects. Instead of knowing some other objects, everybody should know only him, the Mediator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Trouble in the Jungle</h1>
                
            
            
                
<p class="calibre2">Architectural jokes aside, we, the <em class="calibre14">Maronic</em> development team, have some real problems. And they're not related to code directly. As you may remember, our little indie company consists of only me, a canary named Michael that acts as a product manager, and two cat designers that sleep most of the day, but do produce some decent mockups from time to time. We have no QA (that's quality assurance guys) whatsoever. Maybe that's one of the reasons our game keeps crashing all the time.</p>
<p class="calibre2">Lately, Michael has introduced me to a parrot named <kbd class="calibre13">Kenny</kbd>, who happens to be QA:</p>
<pre class="calibre18">interface QA {<br class="title-page-name"/>    fun doesMyCodeWork(): Boolean<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>interface Parrot {<br class="title-page-name"/>    fun isEating(): Boolean<br class="title-page-name"/>    fun isSleeping(): Boolean<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>object Kenny : QA, Parrot {<br class="title-page-name"/>    // Implements interface methods based on parrot schedule<br class="title-page-name"/>}</pre>
<p>This section will use objects for the sake of simplicity.</p>
<p class="calibre2">Parrot QAs are very motivated. They're ready to test the latest version of my game any time. But they really don't like to be bothered when they are either sleeping or eating:</p>
<pre class="calibre18">class MyMind {<br class="title-page-name"/>    val qa = Kenny<br class="title-page-name"/><br class="title-page-name"/>    fun taskCompleted() {<br class="title-page-name"/>        if (!qa.isEating() &amp;&amp; !qa.isSleeping()) {<br class="title-page-name"/>            println(qa.doesMyCodeWork())<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In case <kbd class="calibre13">Kenny</kbd> had any questions, I gave him my direct number:</p>
<pre class="calibre18">object Kenny : ... {<br class="title-page-name"/>    val developer = Me<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">Kenny</kbd> was a hard-working parrot. But we had so many bugs that we also had to hire a second parrot QA, Brad. If <kbd class="calibre13">Kenny</kbd> is free, I give the job to him, as he's more acquainted with our project. But if he's busy, I check if Brad is free, and give this task to him:</p>
<pre class="calibre18">class MyMind {<br class="title-page-name"/>    ...<br class="title-page-name"/>    val qa2 = Brad<br class="title-page-name"/><br class="title-page-name"/>    fun taskCompleted() {<br class="title-page-name"/>        ...<br class="title-page-name"/>        else if (!qa2.isEating() &amp;&amp; !qa2.isSleeping()) {<br class="title-page-name"/>            println(qa2.doesMyCodeWork())<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">Brad</kbd>, being more junior, usually checks up with <kbd class="calibre13">Kenny</kbd> first. And <kbd class="calibre13">Kenny</kbd> also gave my number to him:</p>
<pre class="calibre18">object Brad : QA, Parrot {<br class="title-page-name"/>    val senior = Kenny<br class="title-page-name"/>    val developer = Me<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Then Brad introduces me to <kbd class="calibre13">George</kbd>. <kbd class="calibre13">George</kbd> is an owl, so he sleeps at different times than <kbd class="calibre13">Kenny</kbd> and Brad. That means that he can check my code at night. The problem is, <kbd class="calibre13">George</kbd> is an avid football fan. So before calling him, we need to check if he's watching a game now:</p>
<pre class="calibre18">class MyMind {<br class="title-page-name"/>    ...<br class="title-page-name"/>    val qa3 = George<br class="title-page-name"/><br class="title-page-name"/>    fun taskCompleted() {<br class="title-page-name"/>        ...<br class="title-page-name"/>        else if (!qa3.isWatchingFootball()) {<br class="title-page-name"/>            println(qa3.doesMyCodeWork())<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">Kenny</kbd> as a habit checks with <kbd class="calibre13">George</kbd> too, because <kbd class="calibre13">George</kbd> is a very knowledgeable owl:</p>
<pre class="calibre18">object Kenny : QA, Parrot {<br class="title-page-name"/>    val peer = George<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">And <kbd class="calibre13">George</kbd> checks with <kbd class="calibre13">Kenny</kbd>, because <kbd class="calibre13">Kenny</kbd> is also into football, it seems:</p>
<pre class="calibre18"><br class="title-page-name"/>object George : QA, Owl {<br class="title-page-name"/>    val mate = Kenny<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">George</kbd> loves to call me during the night with his questions:</p>
<pre class="calibre18">object George : QA, Owl {<br class="title-page-name"/>    val developer = Me<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Then there's <kbd class="calibre13">Sandra</kbd>. She's a different kind of bird, because she's not a QA, but a copywriter:</p>
<pre class="calibre18">interface Copywriter {<br class="title-page-name"/>    fun areAllTextsCorrect(): Boolean<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>interface Kiwi<br class="title-page-name"/><br class="title-page-name"/>object Sandra : Copywriter, Kiwi {<br class="title-page-name"/>    override fun areAllTextsCorrect(): Boolean {<br class="title-page-name"/>        return ...<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"> I try not to bother her, unless it's a major release:</p>
<pre class="calibre18">class MyMind {<br class="title-page-name"/>    ...<br class="title-page-name"/>    val translator = Sandra<br class="title-page-name"/><br class="title-page-name"/>    fun taskCompleted(isMajorRelease: Boolean) {<br class="title-page-name"/>        ...<br class="title-page-name"/>        if (isMajorRelease) {<br class="title-page-name"/>            println(translator.areAllTranslationsCorrect())<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">OK, now I have a few problems:</p>
<ul class="calibre11">
<li class="calibre12">First, my mind almost explodes trying to remember all those names. So might yours.</li>
<li class="calibre12">Second, I also need to remember how to interact with each one. I'm the one doing all the checks before calling them.</li>
<li class="calibre12">Third, notice how George tries to confirm everything with Kenny, and Kenny with George? Luckily, up until now, George is always watching a football game when Kenny calls him. And Kenny is asleep when George needs to confirm something with him. Otherwise, they would get stuck on the phone for eternity...</li>
<li class="calibre12">Fourth, and what bothers me the most, is that Kenny plans to leave soon to open his own startup, ParrotPi. Imagine all the code we'll have to change now!</li>
</ul>
<p class="calibre2">All I want to do is to check if everything is alright with my code. Someone else should do all this talking!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The middleman</h1>
                
            
            
                
<p class="calibre2">So, I decided that Michael should manage all those processes:</p>
<pre class="calibre18">interface Manager {<br class="title-page-name"/>    fun isAllGood(majorRelease: Boolean): Boolean<br class="title-page-name"/>}</pre>
<p class="calibre2">Only he will know all the other <em class="calibre14">birds</em>:</p>
<pre class="calibre18">object Michael: Canary, Manager {<br class="title-page-name"/>    private val kenny = Kenny(this)<br class="title-page-name"/>    // And all the others<br class="title-page-name"/>    ...<br class="title-page-name"/><br class="title-page-name"/>    override fun isAllGood(majorRelease: Boolean): Boolean {<br class="title-page-name"/>        if (!kenny.isEating() &amp;&amp; !kenny.isSleeping()) {<br class="title-page-name"/>            println(kenny.doesMyCodeWork())<br class="title-page-name"/>        }<br class="title-page-name"/>        // And all the other logic I had in MyMind<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">I'll remember only him, and he'll do the rest:</p>
<pre class="calibre18">class MyPeacefulMind(private val manager: Manager) {<br class="title-page-name"/>    fun taskCompleted(isMajorRelease: Boolean) {<br class="title-page-name"/>        println(manager.isAllGood(isMajorRelease))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">I'll also change my phone number, and make sure that everybody gets only Michael's:</p>
<pre class="calibre18"><br class="title-page-name"/>class Brad(private val manager: Manager) : ... {<br class="title-page-name"/>   // No reference to Me here<br class="title-page-name"/>   ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, if somebody needs somebody else's opinion, they need to go through Michael first.</p>
<pre class="calibre18">class Kenny(private val manager: Manager) : ... {<br class="title-page-name"/>   // No reference to George, or anyone else<br class="title-page-name"/>   ...<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Flavors</h1>
                
            
            
                
<p class="calibre2">There are two <em class="calibre14">flavors</em> to Mediator. We'll call them <em class="calibre14">strict</em> and <em class="calibre14">loose</em>. The strict version we've seen previously. We tell Mediator exactly what to do, and expect an answer from it.</p>
<p class="calibre2">The <em class="calibre14">loose</em> version will expect us to notify Mediator of what happened, but not to expect an immediate answer. Instead, if he needs to notify us in return, he should call us instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caveats</h1>
                
            
            
                
<p class="calibre2">Michael suddenly becomes ever so important. Everybody knows only him, and only he can manage their interactions. He may even become a <em class="calibre14">God Object</em>, all-knowing and almighty, which is an antipattern from <a href="part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 9</a>, <em class="calibre14">Designed for Concurrency</em>. Even if he's so important, be sure to define what this Mediator should, and, even more importantly, what it shouldn't, do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Memento</h1>
                
            
            
                
<p class="calibre2">Since Michael became a manager, it's been very hard to catch him if I have a question. And when I do ask him something, he just throws something and runs to the next meeting.</p>
<p class="calibre2">Yesterday, I asked him what the next weapon we would introduce in our <em class="calibre14">Maronic</em> game should be. He told me it should be a Coconut Cannon, clear as day. But today, when I presented him with this feature, he chirped at me angrily! He said he told me to implement a Pineapple Launcher instead. I'm lucky he's just a canary still...</p>
<p class="calibre2">But it would be great if I could just record him, and when we have another meeting that goes awry because he's not paying full attention, I would just replay everything he said.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Remembrance</h1>
                
            
            
                
<p class="calibre2">Summing up my problems first—Michael's thoughts are his and his only:</p>
<pre class="calibre18">class Manager {<br class="title-page-name"/>    private var lastThought = "Should get some coffee"<br class="title-page-name"/>    private var repeatThat = 3<br class="title-page-name"/>    private var thenHesitate = "Or maybe tea?"<br class="title-page-name"/>    private var secretThought = "No, coffee it is"<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Moreover, they're quite complex and scattered. I have no access to them, but only to their byproduct:</p>
<pre class="calibre18">class Manager {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun whatAreYouThinking() {<br class="title-page-name"/>        for (i in 1..repeatThat) {<br class="title-page-name"/>            println(lastThought)<br class="title-page-name"/>        }<br class="title-page-name"/>        println(thenHesitate)<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Even recording what he says is quite hard (because he doesn't return anything).</p>
<p class="calibre2">And even if I did record him, Michael can claim it's what he said, not what he meant:</p>
<p>Why did you bring me tea? I wanted coffee!</p>
<p class="calibre2">The solution may seem quite obvious. Let's use an inner class, thought, that will capture this last thought:</p>
<pre class="calibre18">class Manager {<br class="title-page-name"/>    ...<br class="title-page-name"/>    class Thought {<br class="title-page-name"/>        fun captureThought(): CapturedThought {<br class="title-page-name"/>            return CapturedThought(lastThought, <br class="title-page-name"/>                                   repeatThat,                              <br class="title-page-name"/>                                   thenHesitate, <br class="title-page-name"/>                                   secretThought)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    data class CapturedThought(val thought: String, <br class="title-page-name"/>                               val repeat: Int, <br class="title-page-name"/>                               val hesitate: String,<br class="title-page-name"/>                               val secret: String)<br class="title-page-name"/>}</pre>
<p class="calibre2">The only problem is that this code doesn't compile. It's because we're missing a new keyword, <kbd class="calibre13">inner</kbd>, to mark our class. If we omit this keyword, the class is called <kbd class="calibre13">Nested</kbd>, and is similar to the static nested class from Java.</p>
<p class="calibre2">Now we can <em class="calibre14">record</em> what Michael says at this moment:</p>
<pre class="calibre18">val michael = Manager()<br class="title-page-name"/><br class="title-page-name"/>val captured = michael.Thought().captureThought()</pre>
<p class="calibre2">Let's assume that Michael changes his mind at some point. We'll add another function for that:</p>
<pre class="calibre18">class Manager {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun anotherThought() {<br class="title-page-name"/>        lastThought = "Tea would be better"<br class="title-page-name"/>        repeatThat = 2<br class="title-page-name"/>        thenHesitate = "But coffee is also nice"<br class="title-page-name"/>        secretThought = "Big latte would be great"<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>michael.anotherThought()</pre>
<p class="calibre2">We can always repeat the thought that we captured:</p>
<pre class="calibre18">michael.whatAreYouThinking()</pre>
<p class="calibre2">This will print:</p>
<pre class="calibre18"><strong class="calibre1">Tea would be better</strong><br class="title-page-name"/><strong class="calibre1">Tea would be better</strong><br class="title-page-name"/><strong class="calibre1">But coffee is also nice</strong></pre>
<p class="calibre2">Let's check what we've captured:</p>
<pre class="calibre18">println(captured)</pre>
<p class="calibre2">This will print:</p>
<pre class="calibre18">CapturedThought(thought=Should get some coffee, repeat=3, hesitate=Or maybe tea?, secret=No, coffee it is)</pre>
<p class="calibre2">We can even rewind Michael's thoughts if he would allow it:</p>
<pre class="calibre18">class Manager {<br class="title-page-name"/>    ...<br class="title-page-name"/>    inner class Thought {<br class="title-page-name"/>        ...<br class="title-page-name"/>        fun rewindThought(val previousThought: CapturedThought) {<br class="title-page-name"/>            with(previousThought) {<br class="title-page-name"/>                lastThought = thought<br class="title-page-name"/>                repeatThat = repeat<br class="title-page-name"/>                thenHesitate = hesitate<br class="title-page-name"/>                secretThought = secret<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Note how here we use the <kbd class="calibre13">with</kbd> standard function to avoid repeating <kbd class="calibre13">previousThought</kbd> on each line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Visitor</h1>
                
            
            
                
<p class="calibre2">This design pattern is usually a close friend of the <strong class="calibre5">Composite</strong> design pattern that we discussed in <a href="part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 3</a>, <em class="calibre14">Understanding Structural Patterns</em>. It can either extract data from a complex tree-like structure or add behavior to each node of the tree, much like the <strong class="calibre5">Decorator</strong> design pattern.</p>
<p class="calibre2">So, my plan, being a lazy software architect, worked out quite well. Both my mail-sending system from <strong class="calibre5">Builder</strong> and my request-answering system from <strong class="calibre5">Chain of Responsibility</strong> worked quite well. But some developers still begin to suspect that I'm a bit of a fraud.</p>
<p class="calibre2">To confuse them, I plan to produce weekly emails with links to all the latest buzzword articles. Of course, I don't plan to read them myself, just collect them from some popular technology sites.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Writing a crawler</h1>
                
            
            
                
<p class="calibre2">Let's look at the following structure, which is very similar to what we had when discussing the <strong class="calibre5">Iterator</strong> design pattern:</p>
<pre class="calibre18">Page(Container(Image(),<br class="title-page-name"/>               Link(),<br class="title-page-name"/>               Image()),<br class="title-page-name"/>     Table(),<br class="title-page-name"/>     Link(),<br class="title-page-name"/>     Container(Table(),<br class="title-page-name"/>               Link()),<br class="title-page-name"/>     Container(Image(),<br class="title-page-name"/>               Container(Image(),<br class="title-page-name"/>                         Link())))</pre>
<p class="calibre2">The <kbd class="calibre13">Page</kbd> is a container for other <kbd class="calibre13">HtmlElements</kbd>, but not <kbd class="calibre13">HtmlElement</kbd> by itself. <kbd class="calibre13">Container</kbd> holds other containers, tables, links, and images. <kbd class="calibre13">Image</kbd> holds its link in the <kbd class="calibre13">src</kbd> attribute. <kbd class="calibre13">Link</kbd> has the <kbd class="calibre13">href</kbd> attribute instead.</p>
<p class="calibre2">We start by creating a function that will receive the root of our object tree, a <kbd class="calibre13">Page</kbd> in this case, and return a list of all available links:</p>
<pre class="calibre18">fun collectLinks(page: Page): List&lt;String&gt; {<br class="title-page-name"/>    // No need for intermediate variable there<br class="title-page-name"/>    return LinksCrawler().run {<br class="title-page-name"/>        page.accept(this)<br class="title-page-name"/>        this.links<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Using <kbd class="calibre13">run</kbd> allows us to control what we return from the block body. In this case, we would return the <kbd class="calibre13">links</kbd> we've gathered.</p>
<p class="calibre2">In Java, the suggested way to implement the <strong class="calibre5">Visitor</strong> design pattern is to add a method for each class that would accept our new functionality. We'll do the same, but not for all classes. Instead, we'll define this method only for container elements:</p>
<pre class="calibre18">private fun Container.accept(feature: LinksCrawler) {<br class="title-page-name"/>    feature.visit(this)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Same as above but shorter<br class="title-page-name"/>private fun Page.accept(feature: LinksCrawler) = feature.visit(this)</pre>
<p class="calibre2">Our feature will need to hold a collection internally, and expose it only for read purposes. In Java, we would specify only the getter and no setter for that member. In Kotlin, we can specify the value without a backing field:</p>
<pre class="calibre18">class LinksCrawler {<br class="title-page-name"/>    private var _links = mutableListOf&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/>    val links<br class="title-page-name"/>        get()= _links.toList()<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">We wish for our data structure to be immutable. That's the reason we're calling <kbd class="calibre13">toList()</kbd> on it.</p>
<p>The functions that iterate over branches could be further simplified if we use the <strong class="calibre26">Iterator</strong> design pattern.</p>
<p class="calibre2">For containers, we simply pass their elements further:</p>
<pre class="calibre18">class LinksCrawler {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun visit(page: Page) {<br class="title-page-name"/>        visit(page.elements)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun visit(container: Container) = visit(container.elements)<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Specifying the parent class as <kbd class="calibre13">sealed</kbd> helps the compiler further:</p>
<pre class="calibre18">sealed class HtmlElement<br class="title-page-name"/><br class="title-page-name"/>class Container(...) : HtmlElement(){<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Image(...) : HtmlElement() {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Link(...) : HtmlElement() {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Table : HtmlElement()</pre>
<p class="calibre2">The most interesting logic is in the leaves:</p>
<pre class="calibre18">class LinksCrawler {<br class="title-page-name"/>    ...<br class="title-page-name"/>    private fun visit(elements: List&lt;HtmlElement&gt;) {<br class="title-page-name"/>        for (e in elements) {<br class="title-page-name"/>            when (e) {<br class="title-page-name"/>                is Container -&gt; e.accept(this)<br class="title-page-name"/>                is Link -&gt; _links.add(e.href)<br class="title-page-name"/>                is Image -&gt; _links.add(e.src)<br class="title-page-name"/>                else -&gt; {}<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that in some cases, we don't want to do anything. That's specified by an empty block in our else: <kbd class="calibre13">else -&gt; {}</kbd>.</p>
<p class="calibre2">That's the first time we've seen <strong class="calibre5">smart casts</strong> in Kotlin. </p>
<p class="calibre2">Notice that after we checked that the element is a <kbd class="calibre13">Link</kbd>, we gained type-safe access to its <kbd class="calibre13">href</kbd> attribute. That's because the compiler is doing the casts for us. The same holds true for the <kbd class="calibre13">Image</kbd> element as well.</p>
<p class="calibre2">Although we achieved our goals, the usability of this pattern can be argued. As you can see, it's one of the more verbose elements, and introduces tight coupling between classes receiving additional behavior and Visitor itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Template method</h1>
                
            
            
                
<p class="calibre2">Some lazy people make art out of their laziness. Take me for example. Here's my daily schedule:</p>
<ol class="calibre15">
<li value="1" class="calibre12">8:00–9:00: Arrive at the office</li>
<li value="2" class="calibre12">9:00–10:00: Drink coffee</li>
<li value="3" class="calibre12">10:00–12:00: Attend some meetings or review code</li>
<li value="4" class="calibre12">12:00–13:00: Go out for lunch</li>
<li value="5" class="calibre12">13:00–16:00: Attend some meetings or review code</li>
<li value="6" class="calibre12">16:00: Sneak out home</li>
</ol>
<p class="calibre2">As you can see, some of the parts of the schedule never change, and some do. At first, I thought I could <em class="calibre14">decorate</em> my changing schedule with that <kbd class="calibre13">setup</kbd> and <kbd class="calibre13">teardown</kbd> logic, which happens <em class="calibre14">before</em> and <em class="calibre14">after</em>. But then there's lunch, which is holy for architects and happens <em class="calibre14">in between</em>. </p>
<p class="calibre2">Java is pretty clear on what you should do. First, you create an abstract class. All methods that you want to implement by yourself you mark as private:</p>
<pre class="calibre18">abstract class DayRoutine {<br class="title-page-name"/>    private fun arriveToWork() {<br class="title-page-name"/>        println("Hi boss! I appear in the office sometimes!")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    private fun drinkCoffee() {<br class="title-page-name"/>        println("Coffee is delicious today")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    ...<br class="title-page-name"/><br class="title-page-name"/>    private fun goToLunch() {<br class="title-page-name"/>        println("Hamburger and chips, please!")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    ...<br class="title-page-name"/><br class="title-page-name"/>    private fun goHome() {<br class="title-page-name"/>        // Very important no one notices me<br class="title-page-name"/>        println()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">For all methods that are changing from day to day, you define an abstract:</p>
<pre class="calibre18">abstract class DayRoutine {<br class="title-page-name"/>    ...<br class="title-page-name"/>    abstract fun doBeforeLunch()<br class="title-page-name"/>    ...<br class="title-page-name"/>    abstract fun doAfterLunch()<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">If you allow the changing of a method, but want to provide a default implementation, you leave it public:</p>
<pre class="calibre18">abstract class DayRoutine {<br class="title-page-name"/>    ...<br class="title-page-name"/>    open fun bossHook() {<br class="title-page-name"/>        // Hope he doesn't hook me there<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, you have a method that executes your algorithm. It's final by default:</p>
<pre class="calibre18">abstract class DayRoutine {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun runSchedule() {<br class="title-page-name"/>        arriveToWork()<br class="title-page-name"/>        drinkCoffee()<br class="title-page-name"/>        doAfterLunch()<br class="title-page-name"/>        goToLunch()<br class="title-page-name"/>        doAfterLunch()<br class="title-page-name"/>        goHome()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">If we now want to have a schedule for Monday, we simply implement the missing parts:</p>
<pre class="calibre18">class MondaySchedule : DayRoutine() {<br class="title-page-name"/>    override fun doBeforeLunch() {<br class="title-page-name"/>        println("Some pointless meeting")<br class="title-page-name"/>        println("Code review. What this does?")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun doAfterLunch() {<br class="title-page-name"/>        println("Meeting with Ralf")<br class="title-page-name"/>        println("Telling jokes to other architects")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun bossHook() {<br class="title-page-name"/>        println("Hey, can I have you for a sec in my office?")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">What does Kotlin add on top of that? What it usually does—conciseness. As we've seen previously, this can be achieved through functions.</p>
<p class="calibre2">We have three <em class="calibre14">moving parts</em>—two mandatory activities (the software architect must do something before and after lunch) and one optional (the boss may stop him before he sneaks off home or not):</p>
<pre class="calibre18">fun runSchedule(beforeLunch: ()-&gt;Unit,<br class="title-page-name"/>                afterLunch: ()-&gt;Unit,<br class="title-page-name"/>                bossHook: (()-&gt;Unit)? = fun() { println() }) {<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">We'll have a function that accepts up to three other functions as its arguments. The first two are mandatory, and the third may not be supplied at all, or assigned with <kbd class="calibre13">null</kbd> to explicitly state that we don't want that function to happen:</p>
<pre class="calibre18">fun runSchedule(...) {<br class="title-page-name"/>    ...<br class="title-page-name"/>    arriveToWork()<br class="title-page-name"/>    drinkCoffee()<br class="title-page-name"/>    <strong class="calibre1">beforeLunch()</strong><br class="title-page-name"/>    goToLunch()<br class="title-page-name"/>    <strong class="calibre1">afterLunch()</strong><br class="title-page-name"/>    <strong class="calibre1">bossHook?.let { it() </strong><strong class="calibre1">}</strong><br class="title-page-name"/>    goHome()<br class="title-page-name"/>}</pre>
<p class="calibre2">Inside this function, we'll have our algorithm. Invocations of <kbd class="calibre13">beforeLunch()</kbd> and <kbd class="calibre13">afterLunch()</kbd> should be clear; after all, those are the functions that are passed to us as arguments. The third one, bossHook, may be null, so we execute it only if it's not: <kbd class="calibre13">?.let { it() }</kbd>.</p>
<p class="calibre2">But what about the other functions, those we want to always implement by ourselves? Kotlin has a notion of local functions. Those are functions that reside in other functions:</p>
<pre class="calibre18">fun runSchedule(...) {<br class="title-page-name"/>    fun arriveToWork(){<br class="title-page-name"/>        println("How are you all?")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    val drinkCoffee = { println("Did someone left the milk out?") }<br class="title-page-name"/><br class="title-page-name"/>    fun goToLunch() = println("I would like something italian")<br class="title-page-name"/><br class="title-page-name"/>    val goHome = fun () {<br class="title-page-name"/>        println("Finally some rest")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    arriveToWork()<br class="title-page-name"/>    drinkCoffee()<br class="title-page-name"/>    ...<br class="title-page-name"/>    goToLunch()<br class="title-page-name"/>    ...<br class="title-page-name"/>    goHome()<br class="title-page-name"/>}</pre>
<p class="calibre2">Those are all valid ways to declare a local function. No matter how you define them, they're invoked in the same way.</p>
<p class="calibre2">We're left with the same result, as you can see. Define the algorithm structure, but let others decide what to do at some points: that's what the Template Method is all about.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Observer </h1>
                
            
            
                
<p class="calibre2">Probably one of the highlights of this chapter, this design pattern will provide us with a bridge to the following chapters, dedicated to functional programming. </p>
<p class="calibre2">So, what is Observer pattern about? You have one <em class="calibre14">publisher</em>, which may also be called a <em class="calibre14">subject</em>, that may have many <em class="calibre14">subscribers</em>, which may also be called <em class="calibre14">observers</em>. Each time something interesting happens with the publisher, it should update all of its subscribers.</p>
<p class="calibre2">This may look a lot like the Mediator design pattern, but there's a twist. Subscribers should be able to register or unregister themselves at runtime.</p>
<p class="calibre2">In the classical implementation, all subscribers/observers need to implement a certain interface in order for the publisher to be able to update them. But since Kotlin has higher-order functions, we can omit this part. The publisher will still have to provide means for observers to be able to subscribe and unsubscribe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Animal Choir</h1>
                
            
            
                
<p class="calibre2">So, animals have decided to have a choir of their own. The cat was elected as the conductor of the choir (it didn't like to sing anyway).</p>
<p class="calibre2">The problem is that animals escaped from the Java world, and don't have a common interface. Instead, each has a different method to make a sound:</p>
<pre class="calibre18">class Bat {<br class="title-page-name"/>    fun screech() {<br class="title-page-name"/>        println("Eeeeeee")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Turkey {<br class="title-page-name"/>    fun gobble() {<br class="title-page-name"/>        println("Gob-gob")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Dog {<br class="title-page-name"/>    fun bark() {<br class="title-page-name"/>        println("Woof")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun howl() {<br class="title-page-name"/>        println("Auuuu")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Luckily, the cat was elected not only because it was vocally challenged, but also because it was smart enough to follow this chapter until now. So it knows that in the Kotlin world, it can accept functions:</p>
<pre class="calibre18">class Cat {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun joinChoir(whatToCall: ()-&gt;Unit) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun leaveChoir(whatNotToCall: ()-&gt;Unit) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Previously, we've seen how to pass a new function as an argument, as well as passing a literal function. But how do we pass a reference to a member function?</p>
<p class="calibre2">That's what member reference operator is for—<kbd class="calibre13">::</kbd>:</p>
<pre class="calibre18">val catTheConductor = Cat()<br class="title-page-name"/><br class="title-page-name"/>val bat = Bat()<br class="title-page-name"/>val dog = Dog()<br class="title-page-name"/>val turkey = Turkey()<br class="title-page-name"/><br class="title-page-name"/>catTheConductor.joinChoir(bat::screech)<br class="title-page-name"/>catTheConductor.joinChoir(dog::howl)<br class="title-page-name"/>catTheConductor.joinChoir(dog::bark)<br class="title-page-name"/>catTheConductor.joinChoir(turkey::gobble)</pre>
<p class="calibre2">Now the cat needs to save all those subscribers somehow. Luckily, we can put them on a map. What would be the key? It could be the function itself:</p>
<pre class="calibre18">class Cat {<br class="title-page-name"/>    private val participants = mutableMapOf&lt;()-&gt;Unit, ()-&gt;Unit&gt;()<br class="title-page-name"/><br class="title-page-name"/>    fun joinChoir(whatToCall: ()-&gt;Unit) {<br class="title-page-name"/>        participants.put(whatToCall, whatToCall)<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p>If all those <kbd class="calibre20">()-&gt;Unit</kbd> instances are making you dizzy, be sure to use <kbd class="calibre20">typealias</kbd> to give them more semantic meaning, such as subscriber.<br class="calibre21"/>
<br class="calibre21"/></p>
<p class="calibre2">The bat decides to leave the choir. After all, no one is able to hear its beautiful singing anyway:</p>
<pre class="calibre18">class Cat {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun leaveChoir(whatNotToCall: ()-&gt;Unit) {<br class="title-page-name"/>        participants.remove(whatNotToCall)<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">All <kbd class="calibre13">Bat</kbd> needs to do is to pass its subscriber function again:</p>
<pre class="calibre18">catTheConductor.leaveChoir(bat::screech)</pre>
<p class="calibre2">That's the reason we used the map in the first place. Now <kbd class="calibre13">Cat</kbd> can call all its choir members and tell them to sing. Well, produce sounds:</p>
<pre class="calibre18">typealias Times = Int<br class="title-page-name"/><br class="title-page-name"/>class Cat {<br class="title-page-name"/>    ...<br class="title-page-name"/>    fun conduct(n: Times) {<br class="title-page-name"/>        for (p in participants.values) {<br class="title-page-name"/>            for (i in 1..n) {<br class="title-page-name"/>                p()<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The rehearsal went well. But <kbd class="calibre13">Cat</kbd> feels very tired after doing all those loops. It would rather delegate the job to choir members. That's not a problem at all:</p>
<pre class="calibre18">class Cat {<br class="title-page-name"/>    private val participants = mutableMapOf&lt;(Int)-&gt;Unit, (Int)-&gt;Unit&gt;()<br class="title-page-name"/><br class="title-page-name"/>    fun joinChoir(whatToCall: (Int)-&gt;Unit) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun leaveChoir(whatNotToCall: (Int)-&gt;Unit) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun conduct(n: Times) {<br class="title-page-name"/>        for (p in participants.values) {<br class="title-page-name"/>            p(n)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Our subscribers all look like turkeys here:</p>
<pre class="calibre18">class Turkey {<br class="title-page-name"/>    fun gobble(repeat: Times) {<br class="title-page-name"/>        for (i in 1..repeat) {<br class="title-page-name"/>            println("Gob-gob")<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Actually, it is a bit of a problem. What if the <kbd class="calibre13">Cat</kbd> was to tell each animal what sound to make: high or low? We'll have to change all subscribers again, and the <kbd class="calibre13">Cat</kbd> too.</p>
<p class="calibre2">While designing your publisher, pass single data classes with many properties, instead of sets of data classes or other types. That way, you'll have to refactor your subscribers less, in case new properties are added:</p>
<pre class="calibre18">enum class SoundPitch {HIGH, LOW}<br class="title-page-name"/>data class Message(val repeat: Times, val pitch: SoundPitch)<br class="title-page-name"/><br class="title-page-name"/>class Bat {<br class="title-page-name"/>    fun screech(message: Message) {<br class="title-page-name"/>        for (i in 1..message.repeat) {<br class="title-page-name"/>            println("${message.pitch} Eeeeeee")<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p>Make sure that your messages are immutable. Otherwise, you may experience strange behavior!</p>
<p class="calibre2">What if you have sets of different messages you're sending from the same publisher?</p>
<p class="calibre2">Use smart casts:</p>
<pre class="calibre18">interface Message {<br class="title-page-name"/>    val repeat: Times<br class="title-page-name"/>    val pitch: SoundPitch <br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>data class LowMessage(override val repeat: Times) : Message {<br class="title-page-name"/>    override val pitch = SoundPitch.LOW<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>data class HighMessage(override val repeat: Times) : Message {<br class="title-page-name"/>    override val pitch = SoundPitch.HIGH<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Bat {<br class="title-page-name"/>    fun screech(message: Message) {<br class="title-page-name"/>        when (message) {<br class="title-page-name"/>            is HighMessage -&gt; {<br class="title-page-name"/>                for (i in 1..message.repeat) {<br class="title-page-name"/>                    println("${message.pitch} Eeeeeee")<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>            else -&gt; println("Can't :(")<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">That was a long chapter. But we've also learned a lot. We finished covering all classical design patterns, including eleven behavioral ones. In Kotlin, functions can be passed to other functions, returned from functions, and assigned to variables. That's what the "functions as first-class citizens" concept is all about. If your class is all about behavior, it often makes sense to replace it with a function. Iterator is yet another <kbd class="calibre13">operator</kbd> in the language. Sealed classes help in making <kbd class="calibre13">when</kbd> statements exhaustive. The <kbd class="calibre13">run</kbd> extension function allows for controlling what will be returned from it. A lambda with a receiver allows more clear syntax in your DSLs. Another keyword, <kbd class="calibre13">lateinit</kbd>, tells the compiler to relax a bit in its null safety checks. Use with care! And finally, we covered how to reference an existing method with <kbd class="calibre13">::</kbd>.</p>
<p class="calibre2">In the next chapter, we'll move on from an object-oriented programming paradigm with its well-known design patterns to another paradigm—functional programming.</p>


            

            
        
    </body></html>