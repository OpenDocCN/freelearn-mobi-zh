["```swift\npublic protocol Publisher {\n    //1\n    associatedtype Output\n    //2\n    associatedtype Failure : Error\n    //3\n    public func subscribe<S>(_ subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input\n}\n```", "```swift\npublic protocol Subscriber : CustomCombineIdentifierConvertible {\n    //1\n    associatedtype Input\n    //2\n    associatedtype Failure : Error\n    //3\n    func receive(subscription: Subscription)\n    //4\n    func receive(_ input: Self.Input) -> Subscribers.Demand\n    //5\n    func receive(completion: Subscribers.Completion<Self.Failure>)\n}\n```", "```swift\nimport Cocoa\nimport Combine\n//1\nlet publisher = [1,2,3,4].publisher\n//2\nlet subscriber = publisher.sink { element in\n  print(element)\n}\n```", "```swift\n1\n2\n3\n4\n```", "```swift\nimport Cocoa\nimport Combine\nlet publisher = [1,2,3,4].publisher\nlet subscriber = publisher\n  .filter { $0 % 2 == 0}\n  .sink { print($0) }\n```", "```swift\n2\n4\n```", "```swift\nlet publisher = [1,2,3,4].publisher\nlet subscriber = publisher\n  .map { return User(id: $0)}\n  .sink { print($0.description()) }\n```", "```swift\nimport Combine\nlet reduceExample = [1,2,3,4].publisher\n  .reduce(1, { $0 * $1 })\n  .sink(receiveValue: { print (\"\\($0)\", terminator: \" \") })\n```", "```swift\n24\n```", "```swift\nimport Combine\nlet scanExample = [1,2,3,4].publisher\n  .scan(1, { $0 * $1 })\n  .sink(receiveValue: { print (\"\\($0)\", terminator: \" \") })\n```", "```swift\n1 2 6 24\n```", "```swift\nimport Combine\nlet chars = PassthroughSubject<String, Never>()\nlet numbers = PassthroughSubject<Int, Never>()\nlet cancellable = chars.combineLatest(numbers)\n    .sink { print(\"Result: \\($0).\") }\nchars.send(\"a\")\nnumbers.send(1)\nchars.send(\"b\")\nchars.send(\"c\")\nnumbers.send(2)\nnumbers.send(3)\n```", "```swift\nResult: (\"a\", 1).\nResult: (\"b\", 1).\nResult: (\"c\", 1).\nResult: (\"c\", 2).\nResult: (\"c\", 3).\n```", "```swift\nimport Combine\nlet oddNumbers = PassthroughSubject<Int, Never>()\nlet evenNumbers = PassthroughSubject<Int, Never>()\nlet cancellable = oddNumbers.merge(with: evenNumbers)\n    .sink { print(\"Result: \\($0).\") }\noddNumbers.send(1)\nevenNumbers.send(2)\noddNumbers.send(3)\n```", "```swift\nResult: 1.\nResult: 2.\nResult: 3.\n```", "```swift\nimport Combine\nlet chars = PassthroughSubject<String, Never>()\nlet numbers = PassthroughSubject<Int, Never>()\nlet cancellable = chars.zip(numbers)\n    .sink { print(\"Result: \\($0).\") }\nchars.send(\"a\")\nnumbers.send(1)\n// combineLatest output:  (a,1)\n// zip output:            (a, 1)\nchars.send(\"b\")\n// combineLatest output:  (b,1)\n// zip output:            nothing\nchars.send(\"c\")\n// combineLatest output:  (c,1)\n// zip output:            nothing\nnumbers.send(2)\n// combineLatest output:  (c,2)\n// zip output:            (b,2)\nnumbers.send(3)\n// combineLatest output:  (c,3)\n// zip output:            (c,3)\n```", "```swift\nimport Combine\nlet currentValueSubject = CurrentValueSubject<String, Never>(\"first value\")\nlet subscriber = currentValueSubject.sink { print(\"received: \\($0)\") }\ncurrentValueSubject.send(\"second value\")\n```", "```swift\nreceived: first value\nreceived: second value\n```", "```swift\nimport Combine\nlet passthroughSubject = PassthroughSubject<String, Never>()\npassthroughSubject.send(\"first value\")\nlet subscriber = passthroughSubject.sink { print(\"received: \\($0)\")}\npassthroughSubject.send(\"second value\")\n```", "```swift\nreceived: second value\n```", "```swift\n@Published var initialEmail: String = \"\"\n@Published var repeatedEmail: String = \"\"\n```", "```swift\n@IBAction func emailChanged(_ sender: UITextField) {\n  initialEmail = sender.text ?? \"\"\n}\n@IBAction func repeatedEmailChanged(_ sender: UITextField) {\n  repeatedEmail = sender.text ?? \"\"\n}\n```", "```swift\nvar validatedEmail: AnyPublisher<String?, Never> {\n  return Publishers\n    .CombineLatest($initialEmail, $repeatedEmail) //1\n    .map { (email, repeatedEmail) -> String? in  //2\n      guard email == repeatedEmail, email.contains(\"@\"), email.count > 5 else { return nil }\n      return email\n    }\n    .eraseToAnyPublisher() //3\n}\nvar cancellable: AnyCancellable? //4\n```", "```swift\ncancellable = validatedEmail.sink { print($0) }\n```", "```swift\nvar isNewEmail: AnyPublisher<Bool, Never> { //1\n  return $initialEmail //2\n    .debounce(for: 1, scheduler: RunLoop.main) //3\n    .removeDuplicates() //4\n    .flatMap { email in //5\n      return Future { promise in\n        self.emailAvailable(email) { available in\n          promise(.success(available))\n        }\n      }\n    }\n    .eraseToAnyPublisher()\n}\n```", "```swift\nvar finalEmail: AnyPublisher<String?, Never> {\n  return Publishers.CombineLatest(validatedEmail, isNewEmail).map { (email, isNew) -> String? in\n    guard isNew else { return nil }\n    return email\n  }\n  .eraseToAnyPublisher()\n}\n```", "```swift\nsignupButtonCancellable = finalEmail\n  .map { $0 != nil }\n  .receive(on: RunLoop.main)\n  .assign(to: \\.isEnabled, on: signupButton)\n```", "```swift\nstruct User: Codable {\n  let id: String\n  static var unknown: User {\n    return User(id: \"-1\")\n  }\n}\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  postNotification()\n}\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  //1\n  let publisher = NotificationCenter.default.publisher(for: Notification.Name(\"networkResult\"))\n  //2\n  cancellable = publisher.sink { item in\n    print(item)\n  }\n  //3\n  postNotification()\n}\n```", "```swift\nname = networkResult, object = Optional(<7b226964 223a2231 3233227d>), userInfo = nil\n```", "```swift\nlet publisher = NotificationCenter.default.publisher(for: Notification.Name(\"networkResult\"))\n  .map { notification in return notification.object as! Data }\n```", "```swift\n12 bytes\n```", "```swift\nlet publisher = NotificationCenter.default.publisher(for: Notification.Name(\"networkResult\"))\n  .map { notification in return notification.object as! Data }\n  .decode(type: User.self, decoder: JSONDecoder())\n```", "```swift\nReferencing instance method 'sink(receiveValue:)' on 'Publisher' requires the types' Publishers.Decode<Publishers.Map<NotificationCenter.Publisher, JSONDecoder.Input>, User, JSONDecoder>.Failure' (aka 'Error') and 'Never' be equivalent\n```", "```swift\nextension Publisher where Self.Failure == Never\n```", "```swift\nlet publisher = NotificationCenter.default.publisher(for: Notification.Name(\"networkResult\"))\n  .map { notification in return notification.object as! Data }\n  .decode(type: User.self, decoder: JSONDecoder())\n  .catch {_ in\n    return Just(User.unknown)\n  }\n```", "```swift\npostNotificationThatFails()\n```", "```swift\nUser(id: \"123\")\nUser(id: \"-1\")\n```", "```swift\npostNotification()\n```", "```swift\nUser(id: \"123\")\nUser(id: \"-1\")\n```", "```swift\nlet publisher = NotificationCenter.default.publisher(for: Notification.Name(\"networkResult\"))\n  .map { notification in return notification.object as! Data }\n  .flatMap { data in\n    return Just(data)\n      .decode(type: User.self, decoder: JSONDecoder())\n      .catch {_ in\n        return Just(User.unknown)\n      }\n  }\n```", "```swift\n.flatMap { data in\n    return Just(data)\n      .decode(type: User.self, decoder: JSONDecoder())\n      .catch {_ in\n        return Just(User.unknown)\n      }\n  }\n```", "```swift\nUser(id: \"123\")\nUser(id: \"-1\")\nUser(id: \"123\")\n```"]