["```kt\n    fun main(args: Array<String>) { \n      var number = 4 \n      var isEven = isEven(number) \n      println(\"The number is \" + (if (isEven) \"Even\" else \"Odd\")) \n      number = 9 \n      println(\"The number is \" + (if (isEven) \"Even\" else \"Odd\")) \n    } \n\n    fun isEven(n:Int):Boolean = ((n % 2) == 0) \n```", "```kt\n$ git clone https://github.com/ReactiveX/RxKotlin.git\n$ cd RxKotlin/\n$ ./gradlew build\n```", "```kt\ncompile 'io.reactivex.rxjava2:rxkotlin:2.x.y' \n```", "```kt\n    <dependency> \n      <groupId>io.reactivex.rxjava2</groupId> \n      <artifactId>rxkotlin</artifactId> \n      <version>2.x.y</version> \n    </dependency> \n```", "```kt\n    fun main(args: Array<String>) { \n      var list:List<Any> = listOf(\"One\", 2, \"Three\", \"Four\", 4.5,\n      \"Five\", 6.0f) // 1 \n      var iterator = list.iterator() // 2 \n      while (iterator.hasNext()) { // 3 \n        println(iterator.next()) // Prints each element 4 \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      var list:List<Any> = listOf(\"One\", 2, \"Three\",\n      \"Four\", 4.5, \"Five\", 6.0f) // 1 \n      var observable: Observable<Any> = list.toObservable(); \n\n       observable.subscribeBy( // named arguments for\n       lambda Subscribers \n         onNext = { println(it) }, \n         onError =  { it.printStackTrace() }, \n         onComplete = { println(\"Done!\") } \n      ) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      var subject:Subject<Int> = PublishSubject.create() \n\n      subject.map({ isEven(it) }).subscribe({println\n      (\"The number is ${(if (it) \"Even\" else \"Odd\")}\" )}) \n\n      subject.onNext(4) \n      subject.onNext(9) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      println(\"Initial Out put with a = 15, b = 10\") \n      var calculator:ReactiveCalculator = ReactiveCalculator(15,10) \n      println(\"Enter a = <number> or b = <number> in separate\n      lines\\nexit to exit the program\") \n      var line:String? \n      do { \n        line = readLine(); \n        calculator.handleInput(line) \n      } while (line!= null && !line.toLowerCase().contains(\"exit\")) \n    } \n```", "```kt\n    class ReactiveCalculator(a:Int, b:Int) { \n      internal val subjectAdd: Subject<Pair<Int,Int>> = \n        PublishSubject.create() \n      internal val subjectSub: Subject<Pair<Int,Int>> =\n        PublishSubject.create() \n      internal val subjectMult: Subject<Pair<Int,Int>> =\n        PublishSubject.create() \n      internal val subjectDiv: Subject<Pair<Int,Int>> =\n        PublishSubject.create() \n\n      internal val subjectCalc:Subject<ReactiveCalculator> =\n        PublishSubject.create() \n\n      internal var nums:Pair<Int,Int> = Pair(0,0) \n\n      init{ \n        nums = Pair(a,b) \n\n        subjectAdd.map({ it.first+it.second }).subscribe\n        ({println(\"Add = $it\")} ) \n        subjectSub.map({ it.first-it.second }).subscribe\n        ({println(\"Substract = $it\")} ) \n        subjectMult.map({ it.first*it.second }).subscribe\n        ({println(\"Multiply = $it\")} ) \n        subjectDiv.map({ it.first/(it.second*1.0) }).subscribe\n        ({println(\"Divide = $it\")} ) \n\n        subjectCalc.subscribe({ \n          with(it) { \n            calculateAddition() \n            calculateSubstraction() \n            calculateMultiplication() \n            calculateDivision() \n          } \n         }) \n\n         subjectCalc.onNext(this) \n        } \n\n        fun calculateAddition() { \n          subjectAdd.onNext(nums) \n        } \n\n        fun calculateSubstraction() { \n          subjectSub.onNext(nums) \n        } \n\n        fun calculateMultiplication() { \n          subjectMult.onNext(nums) \n        } \n\n        fun calculateDivision() { \n          subjectDiv.onNext(nums) \n        } \n\n        fun modifyNumbers (a:Int = nums.first, b: Int = nums.second) { \n          nums = Pair(a,b) \n          subjectCalc.onNext(this) \n       } \n\n       fun handleInput(inputLine:String?) { \n        if(!inputLine.equals(\"exit\")) { \n            val pattern: Pattern = Pattern.compile\n            (\"([a|b])(?:\\\\s)?=(?:\\\\s)?(\\\\d*)\"); \n\n            var a: Int? = null \n            var b: Int? = null \n\n            val matcher: Matcher = pattern.matcher(inputLine) \n\n            if (matcher.matches() && matcher.group(1) != null \n            &&  matcher.group(2) != null) { \n              if(matcher.group(1).toLowerCase().equals(\"a\")){ \n                 a = matcher.group(2).toInt() \n              } else if(matcher.group(1).toLowerCase().equals(\"b\")){ \n                 b = matcher.group(2).toInt() \n               } \n            } \n\n            when { \n              a != null && b != null -> modifyNumbers(a, b) \n              a != null -> modifyNumbers(a = a) \n              b != null -> modifyNumbers(b = b) \n              else -> println(\"Invalid Input\") \n           } \n        } \n      } \n    }      \n```"]