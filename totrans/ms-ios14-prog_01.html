<html><head></head><body>
		<div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: What's New in iOS 14?</h1>
			<p>During WWDC 2020, Apple introduced the new features and improvements included in iOS 14. Using the latest features in your apps can make a huge difference for users in terms of engagement, positive reviews, and overall user experience. It can also lead to other benefits, such as being featured by Apple in the App Store, and having an advantage over competitors' apps in the same category.</p>
			<p>Apple made Swift 5.2 available for developers on March 24, 2020. Later in the year, Apple released Swift 5.3. These versions focus on quality and performance improvements, new language features, and increased support for Windows platforms and Linux distributions.</p>
			<p>There was another big announcement during WWDC 2020: Apple Silicon. Apple introduced its own processors to the world. Developers can start building apps and ship them by the end of 2020, starting a transition that will last two years. This transition will establish a common architecture across all Apple products. With a common architecture, it will be easier to create apps for the entire Apple ecosystem.</p>
			<p>In this chapter, you will learn the basics of two of the most significant new features on iOS 14: App Clips and widgets. We will also cover the latest additions to augmented reality, machine learning, and user privacy. At the end of the chapter, you will learn about the new additions to the Swift language with some code examples.</p>
			<p>In this chapter, we're going to cover the following main topics of iOS 14, Swift 5.2, and Swift 5.3:</p>
			<ul>
				<li>Introducing App Clips</li>
				<li>Introducing WidgetKit</li>
				<li>Improvements in augmented reality</li>
				<li>Improvements in machine learning</li>
				<li>Improvements in user privacy</li>
				<li>Introducing Swift 5.2</li>
				<li>Introducing Swift 5.3</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New</a>.</p>
			<p>If you want to try out Swift 5.2 features as you read through the chapter, you need to install Xcode version 11.4 or later: <a href="https://itunes.apple.com/app/xcode/id497799835">https://itunes.apple.com/app/xcode/id497799835</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Introducing App Clips</h1>
			<p><strong class="bold">App Clips</strong> allow users<a id="_idIndexMarker000"/> to discover your app in a fast and lightweight manner. With App Clips, a user can quickly use a feature of your app even without having the app installed on their phone. Let's see an example of what an App Clip looks like:</p>
			<div><div><img src="img/Figure_1.01_B14717.jpg" alt="Figure 1.1 − App Clip UI &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 − App Clip UI </p>
			<p>App Clips should be lightweight, brief, and finish a user task in seconds. Let's see some use cases of App<a id="_idIndexMarker001"/> Clips:</p>
			<ul>
				<li>An App Clip to order coffee when you pass by the coffee shop door and tap on an NFC tag.</li>
				<li>An App Clip to rent an electric bike parked in the street, just by scanning a QR code on it. Also, you can use Sign in with Apple and Apple Pay to avoid forms and interface complexities, allowing you to rent the bike in seconds.</li>
				<li>An App Clip to pre-order from the menu in a restaurant and save time while you wait to be seated.</li>
				<li>An App Clip that triggers when you tap around NFC spots in an art gallery or a museum and displays augmented reality scenes on your iPhone.</li>
			</ul>
			<p>As you can see, the <a id="_idIndexMarker002"/>possibilities with App Clips are endless. Now that we have covered what an App Clip is, we are going to explain the user's journey using an App Clip (from the invocation to the end). We will cover the invocation methods (how to trigger an App Clip to appear). Finally, we will explore the recommended guidelines when building an App Clip.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>App Clip user journey</h2>
			<p>Let's now explore <a id="_idIndexMarker003"/>the whole process and steps in more detail, starting from when the user discovers your App Clip to when the user finishes the App Clip journey.</p>
			<p>Let's imagine that we have an app to rent electric bikes on the street. There are several stages involved in the App Clip process:</p>
			<div><div><img src="img/Figure_1.02_B14717.jpg" alt="Figure 1.2 − App Clip process and steps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 − App Clip process and steps</p>
			<p>The steps of an AppClip are as follows:</p>
			<ol>
				<li><strong class="bold">Invocation method</strong>: The App Clip invocation method is how the user can trigger and open an App Clip. For our example with the electric bike rental, a user scans a QR code placed in the bike with their device camera, and the App Clip opens on the home screen. The invocation method, in this case, is the QR code. We will explore<a id="_idIndexMarker004"/> more of them later in the chapter.</li>
				<li><strong class="bold">User Journey</strong>: After the invocation, the App Clip presents some options for the user to choose from (for example, 1-hour rental for $2 and 24-hour rental for $5). The user makes the desired selections inside the App Clip.</li>
				<li><strong class="bold">Accounts and Payment</strong>: In our rental bike example, our App Clip needs to identify which user is renting the bike, and the user needs to pay for the service. Some App Clips will not require a registered user account nor payment to work; this step is optional.</li>
				<li><strong class="bold">Full app recommendation</strong>: When the rental of the bike is settled and ready, your App Clip can recommend the user to download your complete app, so the next time the user can <a id="_idIndexMarker005"/>use it instead of the App Clip. Suggesting the entire app is an optional step, but it is very much recommended.</li>
			</ol>
			<p>Now that we have an<a id="_idIndexMarker006"/> overview of the high-level steps of an App Clip, let's review some parts in more detail.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>App Clips invocation methods</h2>
			<p>We have seen that in<a id="_idIndexMarker007"/> order to display an App Clip, the user needs to invoke it or discover it. We discussed before that it could be invoked by a QR code, an NFC tag, or a link in a message. Here is a summary of the options available:</p>
			<ul>
				<li>App Clip codes: Each App Clip code includes a QR code and an NFC tag so that a user can scan it with their camera or tap on it. It also works with individual NFC tags and QR codes.</li>
				<li>Safari App Banner</li>
				<li>Links in messages</li>
				<li>Place cards in Maps</li>
				<li>The recently used App Clips category in the new App Library on iOS 14</li>
			</ul>
			<p>Let's discuss now the recommended guidelines from Apple when designing and developing your App Clip.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>App Clips guidelines</h2>
			<p>In order to make App<a id="_idIndexMarker008"/> Clips effective, lightweight, and easy to use for the user, Apple has several guidelines:</p>
			<ul>
				<li>Focus on the essential task of your app: Suppose that you have a coffee shop app with lots of different features, including allowing the user to collect points, order coffee, save user preferences, buy coffee gift cards, and so on. Your app should not display such a big set of functionalities all at once. The App Clip should only provide the most important task (for this example, just the feature to order coffee). If the user needs more features, they can download the full app.</li>
				<li>App Clips should be fast and easy to use from the start to the end of the process. Avoid using complex UIs, too many menus, detailed views, and other elements that can cause the user to spend too much time on it.</li>
				<li>App Clips should be small in size, so fast to download. Include all the assets necessary inside the App Clip but avoid big downloads.</li>
				<li>Avoid complex user account creation processes in your App Clip. Just '<strong class="bold">Sign in with Apple</strong>'.</li>
				<li>Avoid requiring the user to enter complex and error-prone credit card forms and details. When necessary, try using Apple Pay.</li>
				<li>When users finish with the App Clip task, they can't go back to it. Your App Clip can suggest the user install the full app to keep users engaged later on. But do it in a non-intrusive, polite way, for example, after the user journey finishes and without making it mandatory.</li>
				<li>App Clips provide<a id="_idIndexMarker009"/> the option to send or schedule notifications up to 8 hours after launch in order to fulfil any required tasks. But it is not recommended to use this feature for purely marketing purposes.</li>
			</ul>
			<p>In this section, you have learned what an App Clip is, the journey that a user will go through while using it, the different invocation methods, and the recommended guidelines when building an App Clip for your app. In <a href="B14717_14_Final_ASB_ePub.xhtml#_idTextAnchor457"><em class="italic">Chapter 14</em></a>, <em class="italic">Creating an App Clip for Your App</em>, we will create an App Clip for an existing app to see a practical example.</p>
			<p>Now, let's jump into another exciting new feature that comes with iOS 14: WidgetKit.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Introducing WidgetKit</h1>
			<p>Users and developers <a id="_idIndexMarker010"/>have been requesting a particular feature for years: they all wanted to be able to have widgets on their home screen. Widgets allow users to configure, personalize, and consume little pieces of relevant data from their home screen. They also allow developers to offer users glanceable content and create added value for their apps. </p>
			<p>Here is a preview of how a <strong class="bold">widget</strong> (in this case Calendar and Reminders widgets) looks on the home screen on the iPhone:</p>
			<div><div><img src="img/Figure_1.03_B14717.jpg" alt="Figure 1.3 − iOS Home screen with Widgets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 − iOS Home screen with Widgets</p>
			<p>Now it is possible on iOS 14, macOS 11, and later versions. Developers can create widgets across iOS, iPadOS and <a id="_idIndexMarker011"/>macOS using <strong class="bold">WidgetKit</strong> and the new <strong class="bold">widget API</strong> for SwiftUI.</p>
			<p>The <strong class="bold">Smart Stack</strong> on iOS 14 <a id="_idIndexMarker012"/>contains a set of different widgets, including the ones that the user opens frequently. If the user enables <strong class="bold">Smart Rotate</strong>, Siri can highlight relevant widgets within custom stacks.</p>
			<p class="callout-heading">Widgets created on iOS 13 and earlier</p>
			<p class="callout">Widgets created before iOS 14 can't be placed on the home screen, but they are still available on the Today View and macOS Notification Center.</p>
			<p>After this introduction to the new widgets, let's see what options we have when building a widget and look at the design guidelines from Apple.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Widgets options</h2>
			<p>Users can place <a id="_idIndexMarker013"/>widgets on the home screen or the Today View on iOS, or the Today View on iPad and the Notification Center on macOS. </p>
			<p>Widgets come in three sizes: small, medium, and large. Each size should have a different purpose. This means that a bigger version of a widget should not be just the same as the small one but with bigger font and images. The idea of having different sizes for a widget is that the bigger the size, the more information it should contain. For example, a weather widget will provide just the current temperature in the small version, but it will also include a weekly forecast in the medium one.</p>
			<p>Users can arrange widgets in different parts of their screen, and even create stack widgets to group them.</p>
			<p>In order to develop a widget, developers need to create a new extension for their app: a <strong class="bold">widget extension</strong>. They <a id="_idIndexMarker014"/>can configure the widget with a timeline provider. A timeline provider updates the widget information when needed.</p>
			<p>If a widget needs some configuration (for example, selecting a default city in a weather app, or multiple cities to display in a large weather widget), developers should add a custom Siri intent to the widget extension. Doing so automatically provides the widget with a customization interface for the user.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Widget guidelines</h2>
			<p>When creating a widget <a id="_idIndexMarker015"/>for iOS 14 or macOS 11, take into account the following design guidelines:</p>
			<ul>
				<li>Focus your widget on the feature of your app. If your app is about the stock market, your widget can display the total value of the user's portfolio.</li>
				<li>Each widget size should display a different amount of information. If your cycling tracker widget displays the current calories burned today in the small widget, it can also display the calories per day of the week in the medium widget and add extra information such as km/miles traveled in the large widget.</li>
				<li>Prefer dynamic information that changes during the day to fixed information; it will make your widget more appealing to the user.</li>
				<li>Prefer simple widgets with fewer configuration options, compared to complex widgets with more options.</li>
				<li>Widgets offer tap target and detection, letting the user select and tap on them to open detailed information in the app. Small widgets support a single tap target, medium and large widgets support multiple targets. Try to keep it simple.</li>
				<li>Support dark mode. Also, consider using SF Pro as the font and SF Symbols if needed.</li>
			</ul>
			<p>In this section, we have had an introduction to the new widgets and WidgetKit. We have covered the different <a id="_idIndexMarker016"/>options available and the design guidelines when building a widget. In the next section, we are going to cover the new improvements and additions to augmented reality in iOS 14.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Improvements in augmented reality </h1>
			<p>In the new ARKit 4 for iOS 14<a id="_idIndexMarker017"/> and iPadOS 14, there are four big new features: </p>
			<ul>
				<li><strong class="bold">Location Anchors</strong> allow developers to place AR scenes at geographic coordinates. Location Anchors enable users to display those AR experiences at specific locations, landmarks, and places around the world.</li>
				<li><strong class="bold">Extended Face</strong> tracking support allows AR experiences accessible via the front camera in devices with the A12 Bionic chip or a later version.</li>
				<li><strong class="bold">RealityKit</strong> will enable developers to add video textures to any part of the AR scene or AR object. Video textures also include spatialized audio.</li>
				<li><code>ARView</code> – <code>Environment</code> object. Scene Understanding contains four options: <strong class="bold">Occlusion</strong>, where real-world objects occlude virtual objects; <strong class="bold">Receives Lighting</strong>, which allows virtual objects to cast shadows on real-world objects; <strong class="bold">Physics</strong>, which enables virtual objects to interact with the real world physically; and <strong class="bold">Collision</strong>, which enables collisions between virtual objects and real-world objects.<p class="callout-heading">Note</p><p class="callout">Activating the <strong class="bold">Receives Lighting</strong> option automatically turns on <strong class="bold">Occlusion</strong>. Activating the <strong class="bold">Physics</strong> option automatically turns on <strong class="bold">Collision</strong>.</p></li>
			</ul>
			<p>In this section, we have<a id="_idIndexMarker018"/> seen the improvements in augmented reality. Let's now review what's new in machine learning.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Improvements in machine learning</h1>
			<p>Improvements to Core ML <a id="_idIndexMarker019"/>presented during WWDC2020 will help developers with the development of their machine learning apps, with improvements that upgrade your app models, secure them, and group them in targeted collections. We are going to cover in this section the new Core ML Model Deployment, the new model collections with targeted deployments, and the new model encryption.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Core ML Model Deployment, collections, and targeted deployments</h2>
			<p>One of the most <a id="_idIndexMarker020"/>significant features introduced in WWDC 2020 for Core ML is <code>mlmodel</code> file from the cloud.</p>
			<p>Developers will be<a id="_idIndexMarker021"/> able to create <strong class="bold">machine learning model collections</strong> on the cloud and update them on CloudKit. Apps will download those collections and stay up to date, with no version upgrading process in the middle. However, developers don't control the download process. The app will detect that there is a new model version available and will download it when the system decides it's appropriate (for example, in the background while the phone is locked and charging on a Wi-Fi connection). So, developers should take into account that the model update may or may not be fast or in real time. The operating system will have the last word.</p>
			<p>A useful feature of model collections is that they can be targeted to different users (for example, users on devices with varying capabilities, such as iPhones vs iPads). Assigning different models to different <a id="_idIndexMarker022"/>users can be done with <strong class="bold">targeted deployments</strong> applied to collections. There are six options available to configure and target the model that the device will deploy: language code, device class, operating system, operating system version, region code, and app version. </p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Model encryption</h2>
			<p>Starting on iOS 14<a id="_idIndexMarker023"/> and macOS 11, Core ML can automatically encrypt the Core ML models.</p>
			<p>Xcode will encrypt the compiled model, <code>mlmodelc</code> (not the original <code>mlmodel</code>). The decryption happens when the app is instantiated and occurs on the device. Moreover, the decryption result is not stored anywhere; it is just loaded into memory.</p>
			<p>More good news on this: Xcode will help you to create an encryption key, associate it with your developer account, and it will be stored in the Apple servers automatically. You can always download a local copy for yourself, but the process is not seamless. </p>
			<p>When the encryption key is stored in Apple servers, the file is <code>.mlmodelkey.</code> When you want to encrypt your model, you just need to add <code>--encrypt {YourModel}.mlmodelkey</code> to the compiler flags. If you prefer using CloudKit, you just need to provide the encryption key when creating the model archive.</p>
			<p>The drawback of this process is this: when the app instantiates, it needs to have an internet connection with the Apple servers to download the encryption key and decrypt your model. If for any reason there is no connectivity, you need to implement your fallback process inside the completion errors of the new <code>{YourModel}.load()</code> method. The completion handler will throw a <code>modelKeyFetch</code> error if the encryption key is not available, and you can act accordingly.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You should not include the encryption key in your app bundle. It is not necessary, and it can compromise your data.</p>
			<p>In this section, we have discovered how we can upgrade our machine learning models without updating our apps, how we can group models into collections and assign them to a different type of users/devices, and how we can have our models encrypted and keep our machine<a id="_idIndexMarker024"/> learning data safe with no effort. In the next section, we are going to cover the additions to user privacy.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Improvements in user privacy</h1>
			<p>With iOS 14, Apple is<a id="_idIndexMarker025"/> giving users more control over their privacy and personal data in different ways:</p>
			<ul>
				<li>The App Store will show the privacy practices of every app, so the user will be able to check them before downloading the app.</li>
				<li>When an app is using the camera or the microphone, an indicator will appear in the top-right corner of the phone indicating it. The Control Center will keep a history of which apps have used them recently.</li>
				<li>Apps can offer users to keep the account they already have but integrate it with <strong class="bold">Sign in with Apple</strong>.</li>
				<li><strong class="bold">Approximate Location</strong> is a new option for location services that gives a less accurate location for apps that shouldn't need your exact location.</li>
				<li>Limited Photos library access: users can now grant access to selected photos only instead of to the entire library.</li>
			</ul>
			<p>In each new version of iOS, Apple is giving users and developers more and more control over the privacy settings. In this section, we have seen new additions that keep the user location and their photos more private, improvements on letting the user know when an app is using the camera or the microphone, and the addition of extra information about an app's usage of data and privacy on its App Store page. The next section focuses on the changes that Swift 5.2 introduces in the language.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Introducing Swift 5.2</h1>
			<p>Introduced by<a id="_idIndexMarker026"/> Apple (on March 24, 2020), Swift 5.2 has handy features focused on improving the developer experience and providing additional language features. Some of the new language features seem to be oriented toward enhancing the functional<a id="_idIndexMarker027"/> programming style. Let's review these new features with some code examples.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Key path expressions as functions</h2>
			<p>This new feature<a id="_idIndexMarker028"/> allows developers to use key path expressions such as <code>\Root.value</code> wherever <code>(Root) -&gt; Value</code> functions are allowed. Let's see it in action.</p>
			<p>Let's create a <code>Car</code> struct with two properties, <code>brand</code> and <code>isElectric</code>: </p>
			<pre>struct Car {
    let brand: String
    let isElectric: Bool
}</pre>
			<p>Then, let's instantiate an array of <code>Car</code> structs with two cars, one that's electric and one that's not electric:</p>
			<pre>let aCar = Car(brand: "Ford", isElectric: false)
let anElectricCar = Car(brand: "Tesla", isElectric: true)
let cars = [aCar, anElectricCar]</pre>
			<p>Now, if we want to filter this <code>cars</code> array and get only the electric cars in it, we used to do it like this:</p>
			<pre>let onlyElectricCars = cars.filter { $0.isElectric }</pre>
			<p>We could also do it this way:</p>
			<pre>let onlyElectricCarsAgain = cars.filter { $0[keyPath: \Car.isElectric] }</pre>
			<p>Now, with Swift 5.2, we are able to do this more briefly:</p>
			<pre>let onlyElectricCarsNewWay = cars.filter<strong class="bold">(\.isElectric</strong>)</pre>
			<p>If you print the results, you will see that the output is the same:</p>
			<pre>print(onlyElectricCars)
print(onlyElectricCarsAgain)
print(onlyElectricCarsNewWay)</pre>
			<p>The output is as follows:</p>
			<pre>[__lldb_expr_5.Car(brand: "Tesla", isElectric: true)]
[__lldb_e xpr_5.Car(brand: "Tesla", isElectric: true)]
[__lldb_expr_5.Car(brand: "Tesla", isElectric: true)]</pre>
			<p>Note that this applies to more cases, such as <code>map</code>, <code>compactMap</code>, and wherever the <code>(Root) -&gt; Value</code> function is allowed.</p>
			<p>The <strong class="bold">SE-0249</strong> proposal contains all the details behind this change. For additional reference and the <a id="_idIndexMarker029"/>motivation behind the proposal, you can check the original document at <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md">https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md</a>.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Callable values of user-defined nominal types</h2>
			<p>This new feature<a id="_idIndexMarker030"/> allows values that have a method whose base name is <code>callAsFunction</code> to be called like a function. </p>
			<p>It is easier to explain this concept with a simple example. Let's create a struct called <code>MyPow</code> that helps us to calculate the power of a number, given the base number:</p>
			<pre>import Foundation
struct MyPow {
    let base: Double
    func callAsFunction(_ x: Double) -&gt; Double {
        return pow(base, x)
    }
}</pre>
			<p>Now, we can calculate the <code>pow</code> of the <code>base</code> just by doing the following:</p>
			<pre>let base2Pow = MyPow(base: 2)
print(base2Pow.callAsFunction(3)) </pre>
			<p>This <code>print</code> statement will have the following result:</p>
			<pre>8.0</pre>
			<p>Now, with Swift 5.2, we can calculate the <code>pow</code> of the base but using this method instead:</p>
			<pre>print(<strong class="bold">base2Pow(3)</strong>)</pre>
			<p>This results in the same output:</p>
			<pre>8.0</pre>
			<p>The Swift <strong class="bold">SE-0253</strong> proposal document contains all the details behind this change. For additional reference and the<a id="_idIndexMarker031"/> motivation behind the proposal, you can check the original document at <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md">https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md</a>.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Subscripts can now declare default arguments</h2>
			<p>When declaring a<a id="_idIndexMarker032"/> subscript, we are now able to assign a default value for an argument.</p>
			<p>Let's see it in action with an example. We create a <code>Building</code> struct that contains an array of <code>String</code> representing floor names. We add a subscript to get the name of a floor with a given index. If the index doesn't exist, we want to get the default value, <code>Unknown</code>:</p>
			<pre>struct Building {
    var floors: [String]
    subscript(index: Int, default default: String = "Unknown") -&gt; String {
        if index &gt;= 0 &amp;&amp; index &lt; floors.count {
            return floors[index]
        } else {
            return `default`
        }
    }
}
let building = Building(floors: ["Ground Floor", "1st", "2nd", "3rd"])</pre>
			<p>We can see in the following output that when we access index <code>0</code> with <code>building[0]</code>, we return the value <code>Ground Floor</code>:</p>
			<pre>print(building[0])</pre>
			<p>The console output is as follows:</p>
			<pre>Ground Floor</pre>
			<p>And in the following scenario, when we access the index <code>5</code> with <code>building[5]</code>, we return the <a id="_idIndexMarker033"/>value <code>Unknown</code>:</p>
			<pre>print(building[5])</pre>
			<p>The console output is as follows:</p>
			<pre>Unknown</pre>
			<p>This code example shows how we can make use of default arguments when using subscripts and how it can be helpful to tackle edge cases.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Lazy filtering order is now reversed</h2>
			<p>When working with a<a id="_idIndexMarker034"/> lazy array and filter, there is a new change in the order of the operations applied to the filters chain. Take a look at the following code:</p>
			<pre>let numbers = [1,2,3,4,5]
    .lazy
    .filter { $0 % 2 == 0 }
    .filter { print($0); return true }
_ = numbers.count</pre>
			<p>In Swift 5.2, this code will print the following:</p>
			<pre>2
4</pre>
			<p>This is because the <code>.filter { $0 % 2 == 0 }</code> statement is applied before the <code>.filter { print($0); return true }</code> statement.</p>
			<p>However, if we execute this code in a Swift version prior to 5.2, we will notice that the order will be the opposite. First, we will print all the numbers; then, we will filter and get only the even ones. The <code>.filter</code> statements will execute from bottom to top.</p>
			<p>This behavior will change again if we remove <code>.lazy</code> from the code. Then, regardless of the Swift version, we will see the output as only <code>2</code> and <code>4</code>. The filters will be applied from top to bottom, as <a id="_idIndexMarker035"/>expected.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This change can break your code and the logic of your app. Make sure you review for any similar scenario when updating your code to Swift 5.2 or later.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>New and improved diagnostics</h2>
			<p>In Swift 5.2, error <a id="_idIndexMarker036"/>messages have improved in quality and precision. In the previous version, the compiler tried to guess the exact location of an error by breaking down expressions into smaller pieces. But this method left some errors out there.</p>
			<p>Now the compiler, when encountering failures while trying to infer a type, records the location of those elements. These recordings allow the compiler to detect the exact error later on if needed.</p>
			<p>Let's see an example compiled in Swift 5.1 versus Swift 5.2 and the output on each version. Look at this code which contains an error:</p>
			<pre>enum Test { case a, b }
func check(t: Test) {
  if t != .c {
    print("okay")
  }
}</pre>
			<p>In Swift 5.2, we get a clear error in the exact location where it happens, and with an accurate reason:</p>
			<pre>error: Chapter 1.5.playground:14:12: error: type 'Test' has no member 'c'
  if t != .c {
          ~^</pre>
			<p>As you can see, the compiler is telling us that we are trying to use a member of the enum that doesn't exist, <code>c</code>.</p>
			<p>If we try to compile the same code in Swift 5.1, we will see a different (and incorrect) error message:</p>
			<pre>error: binary operator '!=' cannot be applied to operands of type 'Test' and '_'
  if t != .c {
     ~ ^  ~~~~~~</pre>
			<p>The improvements in the <a id="_idIndexMarker037"/>compiler errors make iOS developers' day-to-day debugging much more comfortable.</p>
			<p>In this section, you have learned about the latest additions to the language and the improved diagnostics on Swift 5.2 with code examples. Now, let's jump into the features of Swift 5.3.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Introducing Swift 5.3</h1>
			<p>Introduced by <a id="_idIndexMarker038"/>Apple during 2020, the main goal in Swift 5.3 is to enhance quality and performance and to expand the number of platforms on which Swift is available by adding support for Windows and additional Linux distributions.</p>
			<p>Now, let's review some of the new language features.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Multi-pattern catch clauses</h2>
			<p>With this new<a id="_idIndexMarker039"/> feature, Swift will allow multiple error-handling blocks inside a <code>do catch</code> clause. Take a look at the following example.</p>
			<p>Imagine that we have a <code>performTask()</code> function that can throw different types of <code>TaskError</code> errors:</p>
			<pre>enum TaskError: Error {
  case someRecoverableError
  case someFailure(msg: String)
  case anotherFailure(msg: String)
}
func performTask() throws -&gt; String {
  throw TaskError.someFailure(msg: "Some Error")
}
func recover() {}</pre>
			<p>Prior to Swift 5.3, if we want to handle different <code>TaskError</code> cases inside a <code>do catch</code> block, we need to add a <code>switch</code> statement inside the <code>catch</code> clause, complicating the code, as follows:</p>
			<pre>do {
  try performTask()
} catch let error as TaskError {
  <strong class="bold">switch error {</strong>
<strong class="bold">  case TaskError.someRecoverableError:</strong>
<strong class="bold">    recover()</strong>
<strong class="bold">  case TaskError.someFailure(let msg),</strong>
<strong class="bold">       TaskError.anotherFailure(let msg):</strong>
<strong class="bold">    print(msg)</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Now Swift 5.3 allows us to define multiple <code>catch</code> blocks so we can make our code more readable, as in the following example:</p>
			<pre>do {
  try performTask()
} <strong class="bold">catch TaskError.someRecoverableError {</strong>
<strong class="bold">  recover()</strong>
<strong class="bold">} catch TaskError.someFailure(let msg),</strong>
<strong class="bold">        TaskError.anotherFailure(let msg) {</strong>
<strong class="bold">  print(msg)</strong>
<strong class="bold">}</strong></pre>
			<p>We no longer <a id="_idIndexMarker040"/>need the <code>switch</code> inside the <code>catch</code> block.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Multiple trailing closures</h2>
			<p>Since the beginning<a id="_idIndexMarker041"/> of Swift, it has supported trailing closures syntax. See this classic example when using the <code>UIView.animate</code> method:</p>
			<pre>UIView.animate(withDuration: 0.3, animations: {
  self.view.alpha = 0
}, completion: { _ in
  self.view.removeFromSuperview()
})</pre>
			<p>Here, we were able to apply the trailing closure syntax to the <code>completion</code> block to make our code shorter and more readable by extracting <code>completion</code> from the parentheses and removing its label:</p>
			<pre>UIView.animate(withDuration: 0.3, animations: {
  self.view.alpha = 0
}) <strong class="bold">{ _ in</strong>
<strong class="bold">  self.view.removeFromSuperview()</strong>
<strong class="bold">}</strong></pre>
			<p>This closure syntax has some side-effects too. It can make our code hard to read if a developer is not used to our methods (think about our own API library that is not as well known as UIKit methods). It also makes the code a bit unstructured.</p>
			<p>With Swift 5.3, when we have multiple closures in the same method, we can now extract and label all <a id="_idIndexMarker042"/>of them after the first unlabeled parameter:</p>
			<pre>UIView.animate(withDuration: 0.3) <strong class="bold">{</strong>
<strong class="bold">  self.view.alpha = 0</strong>
<strong class="bold">} completion: { _ in</strong>
<strong class="bold">  self.view.removeFromSuperview()</strong>
<strong class="bold">}</strong></pre>
			<p>Notice how now we have both closures outside of the parentheses, <code>UIView.animate(withDuration: 0.3)</code>. Also notice how labeling the <code>completion</code> method makes it easier to understand, and how the code now looks more symmetrical in terms of structure, with all the closures written in the same way.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Synthesized comparable conformance for enum types</h2>
			<p>Swift 5.3 <a id="_idIndexMarker043"/>allow <code>enum</code> types with no associated values or with only <code>Comparable</code> values to be eligible for synthetized conformance. Let's see an example. Before Swift 5.3, if we wanted to compare the values of an <code>enum</code>, we needed to conform to <code>Comparable</code>, and we needed to implement <code>&lt;</code> and <code>minimum</code> methods (among other ways to achieve this):</p>
			<pre>enum Volume: Comparable {
    case low
    case medium
    case high
    private static func minimum(_ lhs: Self, _ rhs: Self) -&gt; Self {
        switch (lhs, rhs) {
        case (.low,    _), (_, .low   ):
            return .low
        case (.medium, _), (_, .medium):
            return .medium
        case (.high,   _), (_, .high  ):
            return .high
        }
    }
    static func &lt; (lhs: Self, rhs: Self) -&gt; Bool {
        return (lhs != rhs) &amp;&amp; (lhs == Self.minimum(lhs, rhs))
    }
}</pre>
			<p>This code is hard to <a id="_idIndexMarker044"/>maintain; as soon as we add more values to the <code>enum</code>, we need to update the methods again and again.</p>
			<p>With Swift 5.3, as long as the enum doesn't have an associated value or it only has a <code>Comparable</code> associated value, the implementation is synthesized for us. Check out the following example, in which we define an enum called <code>Size</code>, and we are able to sort an array of <code>Size</code> instances (without any further implementation of <code>Comparable</code> methods):</p>
			<pre>enum Size: Comparable {
  case small(Int)
  case medium
  case large(Int)
}
let sizes: [Size] = [.medium, .small(1), .small(2), .large(0)]</pre>
			<p>If we print the array with <code>print(sizes.sorted())</code>, we will get this in the console:</p>
			<pre>[.small(1), .small(2), .medium, .large(0)]</pre>
			<p>Note how the <a id="_idIndexMarker045"/>order of sorting is the same as the order in which we define our cases, assuming it is an increasing order: <code>.small</code> appears before <code>.large</code> when we sort the values. For instances of the same case that contain associated values (such as <code>.small(Int)</code> and <code>.large(Int)</code>) we apply the same principle when ordering: <code>.small(1)</code> appears before <code>.small(2)</code>.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Increase availability of implicit self in escaping closures when reference cycles are unlikely to occur</h2>
			<p>Sometimes the <a id="_idIndexMarker046"/>rule that forced all uses of <code>self</code> in escaping closures to be explicit was adding boilerplate code. One example is when we are using closures within a <code>Struct</code> (where the reference cycle is unlikely to occur). With this new change in Swift 5.3, we can omit <code>self</code>, like in this example:</p>
			<pre>struct SomeStruct {
    var x = 0
    func doSomething(_ task: @escaping () -&gt; Void) {
      task()
    }
    func test() {
      doSomething { 
        x += 1 // note no self.x
      }
    }
}</pre>
			<p>There is also a new way to use <code>self</code> in the capture list (just by adding <code>[self] in</code>) when <a id="_idIndexMarker047"/>needed so that we can avoid using <code>self</code> again and again inside the closures. See the following example:</p>
			<pre>class SomeClass {
    var x = 0
    func doSomething(_ task: @escaping () -&gt; Void) {
      task()
    }
    func test() {
      doSomething { [self] in
        x += 1 // instead of self.x += 1
        x = x * 5 // instead of self.x = self.x * 5
      }
    }
}</pre>
			<p>This change<a id="_idIndexMarker048"/> reduces the use of <code>self</code> in many situations and omits it completely when it is not needed.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Type-based program entry points – @main</h2>
			<p>Up until now, when<a id="_idIndexMarker049"/> developing a Swift program (such as a terminal app), we needed to define the program startup point in a <code>main.swift</code> file. Now we are able to mark a struct or a base class (in any file) with <code>@main</code> and a <code>static func main()</code> method on it, and it will be triggered automatically when the program starts:</p>
			<pre><strong class="bold">@main</strong>
struct TerminalApp {
    <strong class="bold">static func main()</strong> {
        print("Hello Swift 5.3!")
    }
}</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Take into consideration the following about <code>@main</code>: it should not be used if a <code>main.swift</code> file already exists, it should be used in a base class (or struct), and it should only be defined once.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Use where clauses on contextually generic declarations</h2>
			<p>We can<a id="_idIndexMarker050"/> use <code>where</code> clauses in functions with generic types and extensions. For example, look at the following code:</p>
			<pre>struct Stack&lt;Element&gt; {
    private var array = [Element]()
    mutating func push(_ item: Element) {
        array.append(item)
    }
    mutating func pop() -&gt; Element? {
        array.popLast()
    }
}
extension Stack {
    func sorted() -&gt; [Element] where Element: Comparable {
        array.sorted()
    }
}</pre>
			<p>We constrained the <code>sorted()</code> method on the extension of this <code>Stack</code> struct to elements that are <code>Comparable</code>.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Enum cases as protocol witnesses</h2>
			<p>This proposal<a id="_idIndexMarker051"/> aims to lift an existing restriction, which is that enum cases cannot participate in protocol witness matching. This was causing problems when conforming enums to protocol requirements. See the following example of a protocol that defines a <code>maxValue</code> variable:</p>
			<pre>protocol Maximizable {
    static var maxValue: Self { get }
}</pre>
			<p>We can make <code>Int</code> conform to <code>Maximizable</code> like this:</p>
			<pre>extension Int: Maximizable {
  static var maxValue: Int { Int.max }
}</pre>
			<p>But if we try<a id="_idIndexMarker052"/> the same with an enum, we will have compile issues. Now it is possible to do this:</p>
			<pre>enum Priority: <strong class="bold">Maximizable</strong> {
    case minValue
    case someValue(Int)
    <strong class="bold">case maxValue</strong>
}</pre>
			<p>This code now compiles properly with Swift 5.3.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Refine didSet semantics</h2>
			<p>This is a very <a id="_idIndexMarker053"/>straightforward change, according to the Swift proposal:</p>
			<ul>
				<li>If a <code>didSet</code> observer does not reference the <code>oldValue</code> in its body, then the call to fetch the <code>oldValue</code> will be skipped. We refer to this as a "simple" <code>didSet</code>.</li>
				<li>If we have a "simple" <code>didSet</code> and no <code>willSet</code>, then we could allow modifications to happen in-place.</li>
			</ul>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Float16</h2>
			<p>Float16 has been <a id="_idIndexMarker054"/>added <a id="_idIndexMarker055"/>to the standard library. Float16 is a half-precision (16b) floating-point value type. Before Swift 5.3, we had Float32, Float64, and Float80.</p>
			<p>In this section, you have learned about the latest additions to the language in Swift 5.3 with code examples. Now, let's finish with the chapter summary.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Summary</h1>
			<p>In this chapter, we've covered new features on iOS 14, Swift 5.2, and Swift 5.3. We started by introducing App Clips and the fantastic possibilities they bring to iOS and macOS. We listed some real-world examples and we have learned the different ways to invoke them. We looked at the design guidelines and the streamlined process by using Sign in with Apple and Apple Pay. Later, we jumped into widgets with WidgetKit. We have described how you can create widgets of three different sizes and looked at their design guidelines. We have discovered the new features and improvements in augmented reality and machine learning. Privacy also gets some updates, allowing end users to control what they share in more detail. Finally, we also learned about new language features of Swift 5.2 and Swift 5.3. </p>
			<p>In our next chapter, we'll take a look at Dark Mode in iOS 14, covering everything you need to know about it and putting it into practice.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Further reading</h1>
			<ul>
				<li>Apple Human Interface Guidelines (App Clips): <a href="https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></li>
				<li>Apple Human Interface Guidelines (Widgets): <a href="https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/">https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/</a></li>
			</ul>
		</div>
	</body></html>