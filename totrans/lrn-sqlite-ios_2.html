<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Database Design Concepts</h1></div></div></div><p>In this chapter, you will learn about SQLite's database concepts. Just as with most databases, SQLite too can add data using the SQL command called <code class="literal">INSERT</code>. It can also modify data using the <code class="literal">UPDATE</code> command and remove data using the <code class="literal">DELETE</code> command. It can also retrieve data using the <code class="literal">SELECT</code> command.</p><p>These four commands form the base line for any SQL database RDMS in the market. This set of commands manipulate the data, and this type of searching is called a <a class="indexterm" id="id58"/>
<strong>query</strong>.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Database essentials</h1></div></div></div><p>This persistent and structured way of <a class="indexterm" id="id59"/>storing data is simply called a database, and the data itself is stored using tables. Each table consists of columns and rows, with a look and feel similar to <a class="indexterm" id="id60"/>
<strong>Microsoft Excel</strong>.</p><p>SQLite<a class="indexterm" id="id61"/> is based on the C language and a related API (RDBMS) in the market. The C language, for example, is easy to understand and is based on the fundamentals of database design with RDBMS. However, learning the actual API will benefit your skills and understanding.</p><p>In order to understand the API, you will have to learn the components that make up the database to improve your knowledge. Understanding data structures, SQL transactions, concurrency, and data-locking mechanisms, and creating good optimized queries will help you design great database systems.</p><p>Lastly, you need to put this understanding into some software code for the app you write and see how it is integrated and executed. The API language extension will be discussed further in this chapter.</p><p>The design objective of SQLite was to keep the role of administration and operation easy to use and simple to manage. SQLite is <a class="indexterm" id="id62"/>
<strong>ACID</strong> (<strong>atomicity</strong>, <strong>consistency</strong>, <strong>isolation</strong>, and <strong>durability</strong>) compliant, and is fully transactional using <a class="indexterm" id="id63"/>
<strong>T-SQL</strong>.</p><p>As a part of the design, the SQLite database has a variety of datatypes like most databases. One of the types is the <code class="literal">INTEGER</code> type that has 64 bit numeric values. This database uses 64 bit numeric values and the data is stored in 1, 2, 3, 4, 5, 6, or 8 bytes. The <code class="literal">TEXT</code> type encoding uses UTF-8 for storing it in the database. The <code class="literal">BLOB</code> datatype can be stored directly, with a default size of 1,000,000,000 bytes.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>SQLite also uses the <code class="literal">REAL</code> type, which is a 64 bit floating point value, and there is the standard <code class="literal">NULL</code> value as well. The <code class="literal">REAL</code> type will be applied to the <code class="literal">FLOAT</code>, <code class="literal">DOUBLE</code>, and <code class="literal">REAL</code> datatypes. The <code class="literal">TEXT</code> type applies to the <code class="literal">NCHAR</code>, <code class="literal">NVARCHAR</code>, <code class="literal">TEXT</code>, and <code class="literal">VARCHAR</code> datatypes. The <code class="literal">NUMERIC</code> type applies to <code class="literal">DATE</code>, <code class="literal">DATETIME</code>, and <code class="literal">BOOLEAN</code>. SQLite also uses <strong>CRUD</strong> (<strong>Create, Read</strong>, <strong>Update</strong>, and <strong>Delete</strong>), and this database is <em>not</em> case sensitive.</p></div></div><p>The statements are<a class="indexterm" id="id64"/> shown as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">CREATE</code> statement<a class="indexterm" id="id65"/> is used to create new tables in the SQLite database. The basic syntax and a simple example of <code class="literal">CREATE TABLE</code> is shown here. The <code class="literal">CREATE TABLE</code> statement has a database name that is fixed. It is followed by a table name, which has a start and close bracket. Within this statement, there is a list of column(s) to be created, starting with their names and datatypes, as shown in the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CREATE table database-name. table-name( column1 datatype, column2 datatype, column3, datatype, PRIMARY KEY column1);</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">INSERT</code> statement<a class="indexterm" id="id66"/> will have a table name followed by a set of columns on the first half. The second half will have the variables, where the data coming from that will be inserted into the table. It is important to ensure that the programmer uses the same datatype as the column created; otherwise, there will be an error or a warning:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">INSERT into table-name(column1,column2,column3) VALUES(variable1,variable2,variable3);</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">UPDATE</code> statement<a class="indexterm" id="id67"/> is used to update records or rows within a table. The <code class="literal">UPDATE</code> statement will have a table name, followed by a set of columns to update on the left-hand side, and some data variables on the right-hand side, as shown in the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UPDATE table-name SET column1=variable1, column2=variable2, column3=variable3) [where variable4 = 10];</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">SELECT</code> statement<a class="indexterm" id="id68"/> is used to select information, records, or rows within a table. This is shown in <em>Figure 7</em>. The <code class="literal">SELECT</code> statement will have a set of columns on the first half, followed by a table name and a condition, as shown here:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SELECT column1, column2, column3 FROM table-name WHERE column1 &gt; 10;</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">DELETE</code> statement<a class="indexterm" id="id69"/> is used to delete records or rows within a table. This is shown here. The <code class="literal">DELETE</code> statement will have a set of columns on the first half, followed by a table and any condition:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE from table-name where column1 &gt;10;</code></li></ul></div></li></ul></div><p>The extension and<a class="indexterm" id="id70"/> core APIs are the sections that form the API made with the C language. The core database carries out functions such as processing SQL syntax and connecting to the database. Other tasks, such as error trapping and string formatting, are also dealt with the core API. As mentioned earlier, the extension API allows programmers to add or extend the current API with a new functionality that will add the functionality that does not exist presently or as a current definition with the SQLite program.</p><p>Although data structures are outlined, as mentioned previously, using the tokenizer or parser, their importance is reduced, since coders are interested in other parts, such as the connectivity syntax, parameters, or current functions, and not the internals of the products. In order to write some good code, programmers must be clued up on SQLite locks, transactions, and the API itself.</p><p>Although not a part of the API itself, the <strong>pager</strong><a class="indexterm" id="id71"/> and <strong>B tree</strong><a class="indexterm" id="id72"/> parts of the SQLite system contribute heavily as a part of locking and transactions mechanisms.</p><p>There are eight methods and two objects that make up the C/C++ interface part of the SQLite database system. The two objects are: <code class="literal">sqlite3</code>, which is the actual database connection object, and <code class="literal">sqlite3_stmt</code>, which is the <code class="literal">prepare</code> statement object.</p><p>The eight methods comprise the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_exec()</code>: This is a<a class="indexterm" id="id73"/> wrapper function</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_close()</code>: This is a <a class="indexterm" id="id74"/>destructor for <code class="literal">sqlite3</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_finalize()</code>:This is a <a class="indexterm" id="id75"/>destructor for <code class="literal">sqlite3_stmt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_column()</code>: This<a class="indexterm" id="id76"/> holds the column values for <code class="literal">sqlite3_stmt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_step()</code>:This<a class="indexterm" id="id77"/> allows you to step to the next result row and is an advancement of <code class="literal">sqlite3_stmt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_bind()</code>: This is <a class="indexterm" id="id78"/>how SQL is broken down into parameters from the stored application data</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_prepare()</code>:This<a class="indexterm" id="id79"/> is a part of the constructor for <code class="literal">sqlite3_stmt</code>, where byte code is produced from SQL that has been compiled, so it can carry out the SQL statements (<code class="literal">SELECT</code>, <code class="literal">UPDATE</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_open()</code>: This <a class="indexterm" id="id80"/>is the constructor of <code class="literal">sqlite3</code>, which allows a connection to an existing or a new SQLite database</li></ul></div><p>Initially, SQLite was easy to learn and had only five C/C++ interfaces, but now, it has grown in size, functionality, and interfaces to over 200 APIs. It can be daunting to use 200 APIs, but SQLite has been designed in such a way that you only use the API, but now, it has grown in size and function.</p><p>These six core interfaces, once <a class="indexterm" id="id81"/>mastered, will give programmers a great understanding of SQLite. They are listed here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_open()</code>: This function makes a connection to the SQLite database and, once successful, a <a class="indexterm" id="id82"/>database connection object will be returned. None of the other interfaces will be available until the <code class="literal">SQLite3_open()</code> interface has been set up. They require a starting point, or a reference to a database, and a database connection object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_prepare()</code>: This function will convert and set up SQL statements into a formatted object, and the<a class="indexterm" id="id83"/> output will be a pointer that will be stored in reference to that object. In order to progress, this interface requires a database connection object produced by the <code class="literal">SQLite3_open()</code> function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_column()</code>: This <a class="indexterm" id="id84"/>interface does not interrogate the SQL, it just produces a prepared statement. This interface is now not the preferred choice for new applications, but the alternative <code class="literal">SQLite3_prepare_V2()</code> interface must be used.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_step()</code>: This interface will look at the prepared statement as set up by the <code class="literal">SQLite3_prepare()</code> function<a class="indexterm" id="id85"/> and will return a single column from the current record set. This is not purely a function, but a placeholder for the type of functions that return values with different datatypes. These form a part of the results set. There are other functions that are a part of the <code class="literal">sqlite3_column()</code> setup, and they are, <code class="literal">sqlite3_column_blob()</code>, <code class="literal">sqlite3_column_bytes()</code>, <code class="literal">sqlite3_column_bytes16()</code>, <code class="literal">sqlite3_column_count()</code>, <code class="literal">sqlite3_column_double()</code>, <code class="literal">sqlite3_column_int()</code>, <code class="literal">sqlite3_column_int64()</code>, <code class="literal">sqlite3_column_text()</code>, <code class="literal">sqlite3_column_type()</code>, and <code class="literal">sqlite3_column_value()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_finalize()</code>: This<a class="indexterm" id="id86"/> function is the interface that destroys the prepared statement to stop any memory leaks in the system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SQLite3_close()</code>: This<a class="indexterm" id="id87"/> interface will shut any database connection and prepared statements before closing or ceasing operations.</li></ul></div><p>There are other routines, such as <code class="literal">sqlite3_bind()</code> and <code class="literal">sqlite3_reset()</code>, that enable prior statements to be used again and again. Usually, statements are created, prepared, and destroyed once, but the aforementioned routines can be used at multiple instances.</p><p>SQLite has the <code class="literal">sqlite3_config()</code> interface that is first selected before any connections to the database <a class="indexterm" id="id88"/>are initiated. This interface will have the ability to set global changes for the database. It can also allocate memory, set up allocators for real-time embedded systems, and page caching for a predefined application usage. It can also make adjustments for different treading models.</p><p>This database system is flexible, and using <code class="literal">sqlite3_create_collation()</code>, <code class="literal">sqlite3_create_function()</code>, <code class="literal">sqlite3_create_module()</code>, and <code class="literal">sqlite3_vfs_register()</code> functions will allow the SQLite system to have a new proprietary functionality on the RDBMS. For example, the <code class="literal">sql_create_function()</code> function will create additional functionality for aggregate or scalar purposes. These are <code class="literal">sqlite3_agreegate_context()</code>, <code class="literal">sqlite3_result()</code>, <code class="literal">sqlite3_user_data()</code>, and <code class="literal">sqlite3_value()</code>.</p><p>These are the standard built-in functionalities of the SQLite system that prove how flexible the system can be to programmers. It is this flexibility, together with the technology that has helped it grow and cultivate to a place where it has become the best SQL database for mobiles today.</p><p>In addition, there are many other interfaces and functions that are too many to include in this book. They can be found under the C/C++ interface specification of this product.</p><p>SQLite, by default, will do most of the tasks required by programmers, users, or DBAs. Programmers are always looking to go beyond the normal bounds of the relational database system, or take advantage of these extensions to fulfill their solution requirements.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Reasons for using SQLite</h1></div></div></div><p>There are many features<a class="indexterm" id="id89"/> that make SQLite a great database for mobile technologies. For example, there is no administration or configuration involved, the transactions are atomic, the database is self-contained in a single cross-platform file, and it holds advanced features, such as table expressions and partial indexes. The reasons for using SQLite are listed here:</p><p>It has a small, versatile, and easy-to-use API. It is very standard-compliant and is written using the ANSI-C compliant. There are no external dependencies on any external programs or services, and the code is well commented. The source code is in the public domain and has a standalone <strong>CLI</strong> (<strong>command-line interface</strong>) at its disposal. It is cross-platform compliant, works with Mac, Linux, BSD, Android, Solaris, VxWorks, and Windows (WinCE, Win32, WinRT).</p><p>Its code footprint is very small, less than 500 kB when configured. The amount of application range that uses this database is huge. Almost all the products can have or have the need for a database that SQLite can handle.</p><p>It may not have all the bells and whistles of an enterprise system, but it is very flexible and easily available. SQLite is used by a variety of companies such as Adobe, Dropbox, Skype, and many more users.</p><p>SQLite is tested independently with its own test facilities and criteria. There are tests for memory usage, crash and power loss, fuzz tests boundary value and disable optimization tests, regression tests, and behavior checks among others. The test harnesses are also independently developed and verified.</p><p>The testing process for SQLite is well tested and matured, and the TCL tests are built using the TCL Scripting language. The test harnesses are made using the C code that creates the TCL interface. There are over 800 files of test scripts that hold over 10 gigabytes of data and over 30,000 test cases.</p><p>There are also SQL logic tests that run SQL statements against other database engines, such as SQL Server, PostgreSQL, Oracle, and SQLite itself. These form a part of the SLT (SQL Logic Test) that runs over 7 million queries and 1 gigabyte of test data as a part of the testing load.</p><p>Also, there are many types of stress and performance testing, including anomaly tests, which include the behavior of SQLite on a variety of checks and see how it performs when errors occur. All the tests are run on all the platforms that SQLite works with. There is a subset of testing scripts that are used as a quick test; however, over 200,000 test cases—enough to capture any errors, or misfit code—can still be executed quickly.</p><p>There are also tests for checking the memory usage that look at memory allocation and the use of the <code class="literal">malloc()</code> function. All the SQL databases use the <code class="literal">malloc()</code> function to allocate and release memory. Since SQLite is heavily used in embedded systems, it is required to handle errors in a graceful manner.</p><p>I/O testing is carried out to ensure that I/O errors are handled and dealt with properly. These issues maybe with regard to network errors, configuration, disk issues, or permissions. Errors are created to see their effects and to see how the software handles them.</p><p>A <strong>virtual file system</strong> (<strong>VFS</strong>)<a class="indexterm" id="id90"/> is also used to simulate the database crashing as part of the testing procedures. There are also simulations using power failures, so any measurement can be recorded. The crash test processes are completed separately.</p><p>There are also fuzz<a class="indexterm" id="id91"/> tests that take care to see that SQLite works with odd and different inputs and all the results are checked. Processes are spawned and the VFS is used to simulate crashes. In addition to the standard fuzz test, there are fuzz tests for SQL that look at the syntax and inputting to the database to check the responses and results. These form a part of the TCL testing, and there are over 100,000 fuzz tests. All the results are recorded and analyzed.</p><p>All branch tests for this database are 100% tested and measured. There are also measurements and tests to ensure that any automatic resource leaks are detected, noted, and dealt with. Usually, resource leaks occur when, in certain circumstances, resources are allocated by the <code class="literal">malloc()</code> function; but they are not released when other processes may require the same resource or some form of shared resource. When the resource is not freed or released as instructed, then it leads to resource leakage.</p><p>SQLite also has dynamic analysis that checks the internal and external SQLite code while the code is being executed or is in use online. This type of analysis is used to ensure that SQLite has the best availability and quality for users.</p><p><strong>Valgrind</strong><a class="indexterm" id="id92"/> is the simulator of the Linux binary and x86 environments. As a simulator, it is much slower, but it is effective. <strong>Memsys2</strong> <a class="indexterm" id="id93"/>has a memory allocation system that is pluggable; it uses the <code class="literal">malloc()</code> and <code class="literal">free()</code> functions. If SQLite is compiled with the <code class="literal">SQLite_MEMDEBUG</code> compile-time option, then, as a part of the debugging memory allocator, a larger wrapper is used around the <code class="literal">malloc()</code>, <code class="literal">realloc()</code>, and <code class="literal">free()</code> functions. If Memsys2 is used, it looks for memory allocation errors at runtime.</p><p>There are the <code class="literal">mutex</code> subsystems in SQLite that use the <code class="literal">sqlite3_mutex_held()</code> and <code class="literal">sqlite3_mutex_ notheld()</code> function. This is a pluggable subsystem, and these two interfaces detect whether a <code class="literal">mutex</code> subsystem has a particular thread. SQLite uses the <code class="literal">assert()</code> set of functions to ensure that multithreaded applications work correctly within the database system.</p><p>SQLite uses a <a class="indexterm" id="id94"/>rollback journal to ensure that all the changes on the database are recorded before actually making changes to the database. SQLite has to work with different conditions so that it does not conflict or cause undetermined or odd behavior that must be managed. Since the code is developed in C, it may work with many implementations and libraries during development, but in the production area, it must confirm and may not work sometimes.</p><p>So, checks such as a shifting using a negative number may be tried, or trying the <code class="literal">memcpy()</code> function to copy buffers that are overlapping and checking that unsigned or signed variables apply to <code class="literal">char</code> datatypes. To cope with, and cater for these issues, the compiler (<strong>GCC</strong>) may use the <code class="literal">-fraction</code> to within the test suites.</p><p>Before the code is released, it goes through a ping and checks that unsigned or signed, or analyzed and compile time errors will be checked before going forward. Both the connections—<strong>Connection 1</strong> and <strong>Connection 2</strong>—are shown as follows:</p><p> </p><div><img alt="Reasons for using SQLite" src="img/B04725_02_01.jpg"/><div><p>Figure 9: SQLite object model with C API</p></div></div><p><em>Figure 9</em> outlines the views that a programmer will look at—B-tree and pager, rather than components such as tokenizers or parser. <em>Figure 9</em> outlines the relationship between the components. To know SQLite properly, programmers must understand the locks, API, and transactions of SQLite.</p><p>As <em>Figure 9</em> illustrates, pager <a class="indexterm" id="id95"/>and B-tree access is forbidden, but important within locks and transactions. The connection to the database and SQL statements is most important when the API has many data structures. For example, a connection to any SQLite database is held as one transaction and also as one connection to the RDMS. A SQL statement is internally represented in the form of a <strong>virtual database of engine</strong> (<strong>VDBE</strong>)<a class="indexterm" id="id96"/> byte code.</p><p>With the B-tree and pager components of SQLite, it will support many database objects within each connection, as shown in <em>Figure 9</em>. Every database object has a B-tree object, which has a relationship with a pager object. The SQL code (SQL statements) within each connection are shown in <em>Figure 9</em>. Every database object has a B-tree object, which has a relationship.</p><p>When B-tree requires information, it prompts the pager component to get the data from the database. The pager component will move the data into its memory buffer, and the B-tree component will then associate it via its cursor to retrieve and view the data.</p><p>Executing SQL statements and commands is a part of the main piece of the API that has two methods, which are either prepared or wrapped queries. If the page is modified by the cursor, the original page/data must be kept just in case of a database rollback. The pager is very important and has to deal with write and read events to and from the RDBMS.</p><p>A transaction is set up once an operation is in place. For example, a database connection setup will effectively be considered as one transaction. Also remember that a connection cannot have more than one transaction open or available at any given time.</p><p>Therefore, SQL statements from a standard connection will work on the same transaction. If the conditions of your program require more than one statement in different transactions, you have to engage in using multiple connections, as illustrated in <em>Figure 9</em>.</p><p>It is very important to know how to set up a database connection from the application to the SQLite database. If there is no connection, then any of the commands used to retrieve, update, or insert data are useless. The connection statement will define the data process and its name and will set up a transaction to allow the data to pass to the database and back. Once a connection is made, the rest of the process sets up the database interactivity. It is not a difficult task to complete, but setting up a database is important to learn, because it is the starting point of all database activities and applications.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Database connections</h1></div></div></div><p>The <code class="literal">sqlite3_open()</code> C API function<a class="indexterm" id="id97"/> is used to open a connection to the database and is held in a single operating system file. This function actually opens the file, and thus, a secure connection is made that is not shared. If the memory option is used, then the database will be created in<a class="indexterm" id="id98"/> <strong>random access memory</strong> (<strong>RAM</strong>), once the connection is established. The database will then be removed and deleted from RAM when the connection closed.</p><p>SQLite will attempt to open an existing database, and if an entered database name does not exist, then it will assume that the programmer wants to create one. SQLite is clever if you want to create a database and then close it without any operation, such as creating a table: it will not actually spend resources creating the database, only an empty file will exist:</p><div><pre class="programlisting">sqlite3 aFile.db "create table aTable(field1 int); drop table aTable;"</pre></div><p>The preceding statement will create the required default file with a table and will then drop/delete it, leaving a clean database without any tables. This is possibly the neatest way to show an empty database.</p><p>When opening the SQLite database, the programmer or database administrator can specify the size of the page in different ranges from 512 to 32,768 bytes. By default, SQLite will use a 1,024 byte page size. For a better performance, the developer may consider a page size of his SQLite database equal to the operating system's page size, which will make operations much more efficient.</p><p>It all depends on the <a class="indexterm" id="id99"/>type of application you are going to design; paying attention to the detail on the type of columns, sizes, and types, which will gear a table and database design to be more efficient and perform well. If the application you are dealing with has large binary data for example, the database page size will increase to match the loading or selecting of data. The <code class="literal">page_size</code> parameter is used as a part of the database page sizing for each database.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Preparing queries</h1></div></div></div><p>These are the eight methods and<a class="indexterm" id="id100"/> two objects that form the SQLite interface. These are the basic list of functions that each user/reader must be aware of when using SQLite in code. These statements don't change, nor does their functionality. These are the key statements to ensure that users are aware of the name, format, and where these functions are used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3</code>: Database <a class="indexterm" id="id101"/>connection  object, made by <code class="literal">sqlite3_open()</code>, killed by <code class="literal">sqlite3_close</code>()</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_stmt</code>: Preparation<a class="indexterm" id="id102"/> statement object, made by <code class="literal">sqlite3_prepare()</code>, killed by <code class="literal">sqlite3_finalize()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_open()</code>: Opens<a class="indexterm" id="id103"/> the database (new or existing) and uses constructor <code class="literal">sqlite3</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_prepare()</code>: Compiles<a class="indexterm" id="id104"/> some SQL text into byte code to perform updating or querying tasks and is the constructor of <code class="literal">sqlite3_stmt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_bind()</code>: Application<a class="indexterm" id="id105"/> data is stored into the parameters of the original SQL</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_step()</code>: The further <a class="indexterm" id="id106"/>advancement of <code class="literal">sqlite3_stmt</code> onto the next row or completion</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_column()</code>: The current <a class="indexterm" id="id107"/>row result outlining column values for <code class="literal">sqlite3_stmt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_finalize()</code>: <code class="literal">sqlite3_stmt</code><a class="indexterm" id="id108"/> destructor</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_close()</code>: <code class="literal">sqlite3</code> <a class="indexterm" id="id109"/>destructor</li><li class="listitem" style="list-style-type: disc"><code class="literal">sqlite3_exec()</code>: A <a class="indexterm" id="id110"/>wrapper function that works for one or many SQL statements using <code class="literal">sqlite3_prepare()</code>, <code class="literal">sqlite3_step()</code>, <code class="literal">sqlite3_finalize()</code>, and <code class="literal">sqlite3_column()</code></li></ul></div><p>The <code class="literal">sqlite3_prepare_v2()</code> function is the one used to prepare and execute SQL statements. The prepare<a class="indexterm" id="id111"/> function is the method that SQLite uses as a part of the following three-stage process:</p><div><ol class="orderedlist arabic"><li class="listitem">First is the preparation stage, next the execution stage, and then the finalization stage. On the preparation side (first step), the components, as explained in <a class="link" href="ch01.html" title="Chapter 1. Introduction to SQL and SQLite">Chapter 1</a>, <em>Introduction to SQL and SQLite</em>, outline the parser, tokenizer, and code maker to investigate the SQL and make a statement using the <code class="literal">sqlite3_prepare_v2()</code> function working with the compiler. Then, a handle is created with byte code from the <code class="literal">sqlite3_stmt</code> function that collates and uses relevant resources for the statement to execute.</li><li class="listitem">Secondly, VDBE within SQLite will take the byte code and execute it using the C API. The <code class="literal">SQLite3_step()</code> will work with (VDBE) to go through the byte code looking at locking resources as required. Different statements will work differently in VDBE, but for the <code class="literal">SELECT</code> statements as an example, using <code class="literal">sqlite3_step()</code> as part of a result set, <code class="literal">SQLITE_ROW()</code> will be set and the process will go through the whole dataset until <code class="literal">SQLITE_DONE</code> is reached. Other statements in the set including <code class="literal">UPDATE</code>, <code class="literal">INSERT</code>, and <code class="literal">DELETE</code> will be directly executed within VDBE.</li><li class="listitem">The third step is the final one where the resources to VDBE are closed; the <code class="literal">sqlite3_finalize()</code>function does this. Once the <code class="literal">sqlite3_finalize()</code> function is executed and resources are free, the program comes to an end via the VDBE and the <a class="indexterm" id="id112"/>statement handle is closed as well.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Parameterized SQL</h1></div></div></div><p>Using SQL within C code and the API <a class="indexterm" id="id113"/>will involve parameterized SQL—the way to include data placeholders in an SQL statement. These are the two types of parameterized binding: named and positional. See <em>Figure 10</em> for more details on how these types of parameterized binding are used. The first statement is positional where its position is located or marked by a question mark, and these positions are based on the number of columns.</p><p>The real variable names setup in the programmable language, such as C or Java, as shown in the second insert statement in <em>Figure 10</em>, outlines the named parameters that use a colon as a prefix to indicate it on an SQL statement. By default, <code class="literal">NULL</code> is used as a default value if there is no value for it to be bound to.</p><p>Once a statement is bound, you can call on it again more than once without wasting the performance or time to recompile it again.</p><p>The whole idea of using parameterized SQL is to reuse the same code with different parameters without recompiling. It saves on resources and time, and improves efficiency. This allows the existing code to be reused several times if the design allows it, to save on more code and improve efficiency. If you use quotes or characters for plurals as an example, SQLite, by default, will escape the characters and insert the right data and convert it properly.</p><p>It also stops SQL injections, SQL penetrations, and easy syntax issues or errors. The SQL injection to a company is a security vulnerability, which allows a hacker to trick the system into adding or modifying data where access is not granted. On a browser where the address of a website is seen, the data input is sometimes added without any encryption, or no data checking is carried out at the backend or frontend to allow penetration. SQL injections, as illustrated and explained in <em>Figure 12</em>, show that an open piece of code that relies on an input using a <code class="literal">%s</code> string, can be regarded as opened, and can impact the data in the database:</p><div><img alt="Parameterized SQL" src="img/4725_02_02.jpg"/><div><p>Figure 10: Using parameterized SQL</p></div></div><p>The following snippet shows how a statement can be compiled using one set of parameters; using the <code class="literal">function _reset()</code> method will allow the same compiled SQL code to be used<a class="indexterm" id="id114"/> again with different parameters:</p><div><pre class="programlisting">#  example of using reset  - START
db1= open('property.db')
sql_statement= db1.prepare('insert into property_info(id,property_id,desc) values(:id,:pr_id,:desc)')
sql_statement.bind('id','100')
sql_statement.bind('property_id','1')
sql_statement.bind('desc','this is a test')
sql_statement.step()
# Reuse existing compiled parameters
sql_statement.reset()
sql_statement.bind('id','200')
sql_statement.bind('property_id','2')
sql_statement.bind('desc','this is a test again')
# End
statement_sql.finalize()
db1.close()</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Error handling</h1></div></div></div><p>Handling errors is mandatory<a class="indexterm" id="id115"/> when writing systems, especially if it is for mobile devices; so, attention to detail and catching issues with code is vital. The <code class="literal">SQLITE_BUSY</code> and <code class="literal">SQLITE_ERROR</code> functions are used by programmers to notify and trap errors, and store them for a later analysis.</p><p>For example, <code class="literal">SQL_ERROR</code> is activated when resources such as locks cannot be granted or are not available, whereas the <code class="literal">SQL_BUSY</code> covers issues with transactions and related matters. Another function called <code class="literal">sqlite3_errcode()</code> will handle any general SQLite error. These methods and functions are the standard way of handling errors with SQLite.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Queries within the db.exec statement</h1></div></div></div><a class="indexterm" id="id116"/><p>The <code class="literal">sqlite3_get_table() </code>function is used to execute<a class="indexterm" id="id117"/> SQL statements that actually return data, such as the <code class="literal">SELECT</code> statement, but the <code class="literal">sqlite3_exec()</code> function is a one-way traffic execution and does not return any data, for example, the <code class="literal">INSERT</code> statement. See the following code for more information:</p><div><pre class="programlisting">db1= open('property.db')
sql_statement= db1.exec("insert into property_info(id,property_id,desc) values(1,2,'Property Description 1')")sql_statement= db1.exec("insert into property_info(id,property_id,desc) values(2,2,'Property Description 2')")</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>SQL injection attacks</h1></div></div></div><p>Another issue with SQLite and<a class="indexterm" id="id118"/> SQL statements generally is <strong>SQL injection attacks</strong>. These can deface websites, result in data corruption, and also affect the reputation of your website and its customers. If the input to SQL parameters is direct, then a weakness could be penetrable. SQL data input must be checked and filtered to allow no one to change the current statement with data elements or even replace SQL statements to perform corrupt acts. This can be done using this statement:</p><div><pre class="programlisting">
<code class="literal">SELECT * from property where property_name='%s';</code>
</pre></div><p>The preceding code shows that an injection can take place where <code class="literal">%s</code> is the input string, and it can be changed to be something else, thus changing the outcome result. To protect SQL, constrain the input, use parameters with stored procedures, and use parameters with dynamic SQL to reduce the threats.</p><p>To prevent your website from being used for <code class="literal">XSS</code> or <code class="literal">XSRF</code> attacks, disallow the HTML tags in text input provided by users by using functions to find and strip tags.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Creating user-defined functions</h1></div></div></div><p>The benefit of using <a class="indexterm" id="id119"/>SQLite over other small databases is its flexibility to engage with the extension API side by creating your own user-defined function. If you are familiar with creating your own function in a language such as Java or C, for example, then extending the natural SQLite database will not be difficult. The following code outlines how this can be done using the C API:</p><div><pre class="programlisting">void test_function(sqlite3_content* tmp_value, int tmp_assign, sqlite3_value** values)
{
/* Respond back Text or reply */
    const char *tmp_string ="Test String - Hello World";

/* Set value to be returned */
sqlite3_result_text(tmp_value,tmp_string,strlen(tmp_string),SQL_STATIC);
}
Execute it by creating function using - sqlite3_create_function(db1,"test_function", 0,test_function);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Transactions and locks</h1></div></div></div><p>Transactions <a class="indexterm" id="id120"/>and lock <a class="indexterm" id="id121"/>states form a part of the makeup of the API and its functions.</p><p>Although difficult to control in their entirety, locks and transactions are interlinked with queries within SQLite and most database systems. The key to better transactions involves the programmer writing good SQL code, ensuring that it will perform well, and catering for possible errors and issues during the journey so that the application does not crash or leave the user in the lurch. Another issue with locks will relate to which resources you need. Sometimes, it could be a badly written code that does not use <code class="literal">autocommit</code> or is holding an exclusive lock to a table and another part of your process, and you can't update it, as an example. So, it is very important for the programmer to gauge, learn the API, and understand how locking and transaction strategies will work to produce a smooth and good app.</p><p>By default, <code class="literal">autocommit</code> is used in SQLite where transactions cycles start and end, which are controlled by programmers and statements used for the app. Each SQL command will run in its own transaction since <code class="literal">autocommit</code> is used. However, within a transaction, especially using a begin command, the programmer has to manually call a rollback, or a commit to update the database. Sometimes, a locking strategy such as this may cause SQL violations or errors, which has to be handled by the error handling code within the app.</p><p>In terms of passwords, as a programmer or designer, do not store password, such as database passwords, in any clear text or script that may be accessed by any user. For example, in a directory to a web server, a source file can be compromised.</p><p>Application authentication should be done on two levels with heavy type password formats so that access is not compromised, especially with technology, such as spyware that looks into compromising your system. The data can be encrypted when database authorization provisions do not offer sufficient protection, which is initially required.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Transactions – reading/writing</h1></div></div></div><p>When a <code class="literal">SELECT</code> statement is used within SQLite, it moves from a default status of <code class="literal">UNLOCKED</code> to <code class="literal">SHARED</code>, and once the statement is committed, it reverts to <code class="literal">UNLOCKED</code>. There are several states for<a class="indexterm" id="id122"/> transaction lock states and locking works when there<a class="indexterm" id="id123"/> is <code class="literal">autocommit</code> on or transactional control with <code class="literal">autocommit</code> off within a begin/end statement arrangement. When there is some contention, the transactional locking states may alter from <code class="literal">UNLOCKED</code> to <code class="literal">SHARED</code>, <code class="literal">RESERVED</code>, or <code class="literal">EXCLUSIVE</code>.</p><p>If an update is to take place, the programmer may code it so that an <code class="literal">EXCLUSIVE</code> lock is used. This stops updates from other processes, just until the job has been done and the lock is released. In this case, the programmer must also code and put up a message or write to the log file; if this happens, auditors or database administrators will have an audit trail of events during the lifetime of an application. It is a very good practice to do so.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Designing for SQLite</h1></div></div></div><p>Generally, programmers will think that <a class="indexterm" id="id124"/>because database systems are huge or work best in enterprise, it will be the same for SQLite and the mobile environment. Remember when the app is released; ensure that SQLite is built in with some basic data for the user to start. Ensure that the data can be dynamically populated easily. This will form a part of a great data access strategy and format, which should be replicated across all of your applications.</p><p>As mentioned previously, security to your data is mandatory, and requirements around privacy and access, including a form of encryption, must be considered to protect information.</p><p>Another important factor in designing a good database for SQLite is the performance and the ability of the software to work efficiently and quickly among the operating system on a small device and app that has more demands on it today.</p><p>Testing both, manual and automatic, using products such as <strong>Appium</strong><a class="indexterm" id="id125"/> for mobiles, is a must, because it can find out relevant bugs, issues, and problems, that manual testing may not have uncovered. The usage of SQLite in your application can be as complicated or as simple as you require, and the freedom and accessibility of code and experts are plentiful, to ensure that your app delivers what it sets out to achieve.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, you learned how to design a database system for an application using SQLite. You learned the details of how to approach the design and outline certain concepts. The next chapter will show you how to administer an SQLite database and make use of this functionality.</p></div></body></html>