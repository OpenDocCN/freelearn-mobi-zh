<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Understanding Structural Patterns</h1>
                
            
            
                
<p class="calibre2">This chapter covers structural patterns in Kotlin. In general, structural patterns deal with relationships between objects. </p>
<p class="calibre2">We'll discuss how to extend the functionality of our objects without producing complex class hierarchies and how to adapt to changes in the future or how to fix some of the decisions taken in the past, as well as how to reduce the memory footprint of our program.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Decorator</li>
<li class="calibre12">Adapter</li>
<li class="calibre12">Bridge</li>
<li class="calibre12">Composite</li>
<li class="calibre12">Facade</li>
<li class="calibre12">Flyweight</li>
<li class="calibre12">Proxy</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Decorator</h1>
                
            
            
                
<p class="calibre2">In the previous chapter, we discussed the <strong class="calibre5">Prototype</strong> design pattern, which allowed for creating instances of classes with slightly (or not so slightly) different data.</p>
<p class="calibre2">What if we would like to create a set of classes with slightly different behavior though? Well, since functions in Kotlin are first-class citizens (more on that in a bit), you could use the Prototype design pattern to achieve that. After all, that's what JavaScript does successfully. But the goal of this chapter is to discuss another approach to the same problem. After all, design patterns are all about approaches.</p>
<p class="calibre2">By implementing this design pattern, we allow the user of our code to specify which abilities he or she wants to add.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Enhancing a class</h1>
                
            
            
                
<p class="calibre2">Your boss—sorry, scrum master—came to you yesterday with an urgent requirement. From now on, all map data structures in your system are to become <kbd class="calibre13">HappyMaps</kbd>. </p>
<p class="calibre2">What, you don't know what <kbd class="calibre13">HappyMaps</kbd> are? They are the hottest stuff going around right now. They are just like the regular <kbd class="calibre13">HashMap</kbd>, but when you override an existing value, they print the following output:</p>
<pre class="calibre18"><strong class="calibre1">Yay! Very useful</strong></pre>
<p class="calibre2">So, what you do is type the following code in your editor:</p>
<pre class="calibre18">class HappyMap&lt;K, V&gt;: HashMap&lt;K, V&gt;() {<br class="title-page-name"/>    override fun put(key: K, value: V): V? {<br class="title-page-name"/>        return super.put(key, value).apply {<br class="title-page-name"/>            this?.let {<br class="title-page-name"/>                println("Yay! $key")<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We've seen <kbd class="calibre13">apply()</kbd> already when we discussed the <strong class="calibre5">Builder</strong> design pattern in the previous chapter and <kbd class="calibre13">this?.let { ... }</kbd>  is a nicer way of saying <kbd class="calibre13">if (this != null) { ... }</kbd>.</p>
<p class="calibre2">We can test our solution using the following code:</p>
<pre class="calibre18">fun main(args : Array&lt;String&gt;) {<br class="title-page-name"/>    val happy = HappyMap&lt;String, String&gt;()<br class="title-page-name"/>    happy["one"] = "one"<br class="title-page-name"/>    happy["two"] = "two"<br class="title-page-name"/>    happy["two"] = "three"<br class="title-page-name"/>}</pre>
<p class="calibre2">The preceding code prints the following output as expected:</p>
<pre class="calibre18"><strong class="calibre1">Yay! two</strong></pre>
<p class="calibre2">That was the only overridden key.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Operator overloading</h1>
                
            
            
                
<p class="calibre2">Hold on a second, how do square brackets keep working when we extended a map? Aren't they some kind of magic? </p>
<p class="calibre2">Well, actually no. No magic there. As you may have guessed by the title of this section, Kotlin supports operator overloading. Operator overloading means that the same operator acts differently, depending on the type of arguments it receives. </p>
<p class="calibre2">If you've ever worked with Java, you're familiar with operator overloading already. Think of how the plus operator works. Let take a look at the example given here:</p>
<pre class="calibre18">System.out.println(1 + 1); // 2<br class="title-page-name"/>System.out.println("1" + "1") // 11</pre>
<p class="calibre2">Based on whether two arguments are either strings or integers, the <kbd class="calibre13">+</kbd> sign acts differently. </p>
<p class="calibre2">But, in the Java world, this is something that only the language itself is allowed to do. The following code won't compile, no matter how hard we try:</p>
<pre class="calibre18">List&lt;String&gt; a = Arrays.asList("a");<br class="title-page-name"/>List&lt;String&gt; b = Collections.singletonList("b"); // Same for one argument<br class="title-page-name"/>List&lt;String&gt; c = a + b;</pre>
<p>In Java 9, there's also <kbd class="calibre20">List.of()</kbd>, which serves a similar purpose to <kbd class="calibre20">Arrays.asList()</kbd>.</p>
<p class="calibre2">In Kotlin, the same code prints <kbd class="calibre13">[a, b]</kbd>:</p>
<pre class="calibre18">val a = listOf("a")<br class="title-page-name"/>val b = listOf("b")<br class="title-page-name"/>println(a + b)</pre>
<p class="calibre2">Well, that makes a lot of sense, but maybe it's just a language feature:</p>
<pre class="calibre18">data class Json(val j: String)<br class="title-page-name"/>val j1 = Json("""{"a": "b"}""")<br class="title-page-name"/>val j2 = Json("""{"c": "d"}""")<br class="title-page-name"/>println(j1 + j2) // Compilation error!</pre>
<p class="calibre2">Told you it was magic! You cannot simply join two arbitrary classes together.</p>
<p class="calibre2">But wait. What if we create an extension function for our <kbd class="calibre13">Json</kbd> class, <kbd class="calibre13">plus()</kbd>, as follows:</p>
<pre class="calibre18">operator fun Json.plus(j2: Json): Json {<br class="title-page-name"/>   // Code comes here<br class="title-page-name"/>}</pre>
<p class="calibre2">Everything but the first keyword, <kbd class="calibre13">operator</kbd>, should look familiar to you. We extend the <kbd class="calibre13">Json</kbd> object with a new function that gets another <kbd class="calibre13">Json</kbd> and returns <kbd class="calibre13">Json</kbd>.</p>
<p class="calibre2">We implement the function body like this:</p>
<pre class="calibre18">val jsonFields = this.j.split(":") + j2.j.split(":")<br class="title-page-name"/>val s = (jsonFields).joinToString(":")<br class="title-page-name"/>return Json ("""{$s}""")</pre>
<p class="calibre2">This isn't really joining any JSON, but it joins <kbd class="calibre13">Json</kbd> in our example. We take values from our <kbd class="calibre13">Json</kbd>, values from the other <kbd class="calibre13">Json</kbd>, then join them together and put some curly brackets around them.</p>
<p class="calibre2">Now look at this line:</p>
<pre class="calibre18">println(j1 + j2)</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18">{{"a": "b"}:{"c": "d"}}</pre>
<p class="calibre2">Actually, it will print: <kbd class="calibre13">Json(j={{"a": "b"}:{"c": "d"}})</kbd>. This is because we didn't override the <kbd class="calibre13">toString()</kbd> method in our example for brevity.</p>
<p class="calibre2">So, what's this <kbd class="calibre13">operator</kbd> keyword about?</p>
<p class="calibre2">Unlike some other languages, you cannot override every operator that exists in Kotlin languages, just a chosen few.</p>
<p>Albeit limited, the list of all operators that can be overridden is quite long, so we'll not list it here. You can refer to it in the official documentation: <br class="calibre21"/>
<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" class="calibre19">https://kotlinlang.org/docs/reference/operator-overloading.html</a>.</p>
<p class="calibre2">Try renaming your extension method to:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">prus()</kbd>: Just a name with a typo</li>
<li class="calibre12"><kbd class="calibre13">minus()</kbd>: The existing function that correlates with the <kbd class="calibre13">-</kbd> sign</li>
</ul>
<p class="calibre2">You will see that your code stops compiling. </p>
<p class="calibre2">The square brackets that we started with are called <strong class="calibre5">indexed access operators </strong>and correlate to the <kbd class="calibre13">get(x)</kbd> and <kbd class="calibre13">set(x, y)</kbd> methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Dude, where's my map?</h1>
                
            
            
                
<p class="calibre2">The next day, your product manager reaches out to you. Apparently, they want a <kbd class="calibre13">SadMap</kbd> now, which gets <em class="calibre14">sad</em> each time a key is removed from it. Following the previous pattern, you extend the map again:</p>
<pre class="calibre18">class SadMap&lt;K, V&gt;: HashMap&lt;K, V&gt;() {<br class="title-page-name"/>    override fun remove(key: K): V? {<br class="title-page-name"/>        println("Okay...")<br class="title-page-name"/>        return super.remove(key)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">But then the chief architect asks that in some cases, a map would be happy and sad at the same time. The CTO already has a great idea for a <kbd class="calibre13">SuperSadMap</kbd> that will print the following output twice:</p>
<pre class="calibre18"><strong class="calibre1">Okay...</strong></pre>
<p class="calibre2">So, what we need is the ability to combine the behaviors of our objects. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The great combinator</h1>
                
            
            
                
<p class="calibre2">We'll start a bit differently this time. Instead of composing our solution piece by piece, we'll look at the complete solution and decompose it. The code here will help you understand why:</p>
<pre class="calibre18">class HappyMap&lt;K, V&gt;(private val map: MutableMap&lt;K, V&gt; =                                        mutableMapOf()) : <br class="title-page-name"/>      MutableMap&lt;K, V&gt; by map {<br class="title-page-name"/><br class="title-page-name"/>    override fun put(key: K, value: V): V? {<br class="title-page-name"/>        return map.put(key, value).apply {<br class="title-page-name"/>            this?.let { println("Yay! $key") }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The hardest part here is to understand the signature. What we need in the Decorator pattern is:</p>
<ul class="calibre11">
<li class="calibre12">To be able to receive the object we're decorating</li>
<li class="calibre12">To keep a reference to it</li>
<li class="calibre12">When our Decorator is called, we decide if we would like to change the behavior of the object we're holding, or to delegate the call</li>
</ul>
<p class="calibre2">Since we need to actually do a lot of stuff, this declaration is quite complex. After all, it does a lot of stuff in one line, which should be quite impressive. Let's break it down line by line:</p>
<pre class="calibre18">class HappyMap&lt;K, V&gt;(...</pre>
<p class="calibre2">Our class is named <kbd class="calibre13">HappyMap</kbd> and has two type arguments, <kbd class="calibre13">K</kbd> and <kbd class="calibre13">V</kbd>, which stand for <strong class="calibre5">key</strong> and <strong class="calibre5">value</strong>:</p>
<pre class="calibre18">... (private val map: MutableMap&lt;K, V&gt; ...</pre>
<p class="calibre2">In our constructor, we receive <kbd class="calibre13">MutableMap</kbd>, with types <kbd class="calibre13">K</kbd> and <kbd class="calibre13">V</kbd>, the same as ours:</p>
<pre class="calibre18">... = mutableMapOf()) ...</pre>
<p class="calibre2">If no map was passed, we initialize our property with the default argument value, which is an empty mutable map:</p>
<pre class="calibre18">... : MutableMap&lt;K, V&gt; ...</pre>
<p class="calibre2">Our class extends the <kbd class="calibre13">MutableMap</kbd> interface:</p>
<pre class="calibre18">... by map</pre>
<p class="calibre2">It also <strong class="calibre5">delegates </strong>all methods that weren't overridden to the object that we will wrap, in our case a map.</p>
<p>The code for <kbd class="calibre20">SadMap</kbd> using delegate is omitted, but you can easily reproduce it by combining the declaration of <kbd class="calibre20">HappyMap</kbd> and the previous implementation of <kbd class="calibre20">SadMap</kbd>.</p>
<p class="calibre2">Let's compose our <kbd class="calibre13">SadHappyMap</kbd> now, to please the chief architect:</p>
<pre class="calibre18">val sadHappy = SadMap(HappyMap&lt;String, String&gt;())<br class="title-page-name"/>sadHappy["one"] = "one"<br class="title-page-name"/>sadHappy["two"] = "two"<br class="title-page-name"/></pre>
<pre class="calibre18">sadHappy["two"] = "three"<br class="title-page-name"/>sadHappy["a"] = "b"<br class="title-page-name"/>sadHappy.remove("a")</pre>
<p class="calibre2">We get the following output:</p>
<pre class="calibre18"><strong class="calibre1">Yay! two // Because it delegates to HappyMap</strong><br class="title-page-name"/><strong class="calibre1">Okay...  // Because it is a SadMap</strong></pre>
<p class="calibre2">In the same way, we can now create <kbd class="calibre13">SuperSadMap</kbd>:</p>
<pre class="calibre18">val superSad = SadMap(HappyMap&lt;String, String&gt;())</pre>
<p class="calibre2">And we can please the CTO too.</p>
<p>The Decorator design pattern is widely used in the <kbd class="calibre20">java.io.*</kbd> package, with classes such as reader and writer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caveats</h1>
                
            
            
                
<p class="calibre2">The Decorator design pattern is great because it lets us compose objects <em class="calibre14">on the fly</em>. Using Kotlin's <kbd class="calibre13">by</kbd> keyword will make it simple to implement. But there are still limitations that you need to take care of.</p>
<p class="calibre2">First, you cannot see <em class="calibre14">inside</em> of the Decorator:</p>
<pre class="calibre18">println(sadHappy is SadMap&lt;*, *&gt;) // True</pre>
<p class="calibre2">That's the top wrapper, so no problem there:</p>
<pre class="calibre18">println(sadHappy is MutableMap&lt;*, *&gt;) // True</pre>
<p class="calibre2">That's the interface we implement, so the compiler knows about it:</p>
<pre class="calibre18">println(sadHappy is HappyMap&lt;*, *&gt;) // False</pre>
<p class="calibre2">Although <kbd class="calibre13">SadMap</kbd> contains <kbd class="calibre13">HappyMap</kbd> and may behave like it, it is not a <kbd class="calibre13">HappyMap</kbd>! Keep that in mind while performing casts and type checks.</p>
<p class="calibre2">Second, which is related to the first point, is the fact that since Decorator is usually not aware directly of which class it wraps, it's hard to do optimizations. Imagine that our CTO requested <kbd class="calibre13">SuperSadMap</kbd> to print <kbd class="calibre13">Okay... Okay...</kbd> and that's it, on the same line. For that, we would need to either capture the entire output, or investigate all the classes that we will wrap, which are quite complex tasks. </p>
<p class="calibre2">Keep these points in mind when you use this powerful design pattern. It allows for adding new responsibilities to an object dynamically (in our case, printing <kbd class="calibre13">Yay</kbd> is a responsibility), instead of subclassing the object. Each new responsibility is a new wrapping layer you add.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adapter</h1>
                
            
            
                
<p class="calibre2">The main goal of an Adapter, or Wrapper, as it's sometimes called, is to convert one interface to another interface. In the physical world, the best example would be an electrical plug Adapter, or a USB Adapter.</p>
<p class="calibre2">Imagine yourself in a hotel room in the late evening, with 7% battery left on your phone. Your phone charger was left in the office, at the other end of the city. You only have an EU plug charger with a USB mini cable. But your phone is USB type-C, because you had to upgrade. And you're in New York, so all of your outlets are of course US type-A. What do you do? Oh, it's easy. You look for a USB mini to USB Type-C Adapter in the middle of the night and hope you also don't forget to bring that EU to US plug Adapter while you're at it. Only 5% battery left. Time is running out.</p>
<p class="calibre2">So, now that we understand a bit better what adapters are for in the physical world, let's see how we can apply the same in code.</p>
<p class="calibre2">Let's start with interfaces:</p>
<pre class="calibre18">interface UsbTypeC<br class="title-page-name"/>interface UsbMini<br class="title-page-name"/><br class="title-page-name"/>interface EUPlug<br class="title-page-name"/>interface USPlug</pre>
<p class="calibre2">Now we can declare a phone and a power outlet:</p>
<pre class="calibre18">// Power outlet exposes USPlug interface<br class="title-page-name"/>fun powerOutlet() : USPlug {<br class="title-page-name"/>    return object : USPlug {}<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<pre class="calibre18">fun cellPhone(chargeCable: UsbTypeC) {<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">Our charger is wrong in every way, of course:</p>
<pre class="calibre18">// Charger accepts EUPlug interface and exposes UsbMini interface<br class="title-page-name"/>fun charger(plug: EUPlug) : UsbMini {<br class="title-page-name"/>    return object : UsbMini {}<br class="title-page-name"/>}</pre>
<p class="calibre2">Here we get the following errors:</p>
<pre class="calibre18">Type mismatch: required EUPlug, found USPlug: charger(powerOutlet())<br class="title-page-name"/><br class="title-page-name"/>Type mismatch: required UsbTypeC, found UsbMini: cellPhone(charger(powerOutlet()))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Different adapters</h1>
                
            
            
                
<p class="calibre2">So, we need two types of adapters.</p>
<p class="calibre2">In Java, you would usually create a pair of classes for that purpose. In Kotlin, we can replace those with extension functions.</p>
<p class="calibre2">We could adopt the US plug to work with the EU plug by using the following extension function:</p>
<pre class="calibre18">fun USPlug.toEUPlug() : EUPlug {<br class="title-page-name"/>    return object : EUPlug {<br class="title-page-name"/>        // Do something to convert <br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can create a USB Adapter between mini USB and type-C USB in a similar way:</p>
<pre class="calibre18">fun UsbMini.toUsbTypeC() : UsbTypeC {<br class="title-page-name"/>    return object : UsbTypeC {<br class="title-page-name"/>        // Do something to convert<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, we get back online by combining all those adapters together:</p>
<pre class="calibre18">cellPhone(<br class="title-page-name"/>    charger(<br class="title-page-name"/>        powerOutlet().toEUPlug()<br class="title-page-name"/>    ).toUsbTypeC()<br class="title-page-name"/>)</pre>
<p class="calibre2">As you can see, we don't need to compose one object inside the other to adapt them. Nor, luckily, do we need to inherit both interface and implementation. With Kotlin, our code stays short and to the point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adapters in the real world</h1>
                
            
            
                
<p class="calibre2">You've probably encountered those adapters too. Mostly, they adapt between <em class="calibre14">concepts</em> and <em class="calibre14">implementations</em>. For example, let's take the concept of <em class="calibre14">collection</em> versus the concept of a <em class="calibre14">stream</em>:</p>
<pre class="calibre18">val l = listOf("a", "b", "c")<br class="title-page-name"/><br class="title-page-name"/>fun &lt;T&gt; streamProcessing(stream: Stream&lt;T&gt;) { <br class="title-page-name"/>    // Do something with stream<br class="title-page-name"/>}</pre>
<p class="calibre2">You cannot simply pass a collection to a function that receives a stream, even though it may make sense:</p>
<pre class="calibre18">streamProcessing(l) // Doesn't compile</pre>
<p class="calibre2">Luckily, collections provide us with the <kbd class="calibre13">.stream()</kbd> method:</p>
<pre class="calibre18">streamProcessing(l.stream()) // Adapted successfully</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caveats of using adapters</h1>
                
            
            
                
<p class="calibre2">Did you ever plug a 110v US appliance into a 220v EU socket through an Adapter, and fry it totally? </p>
<p class="calibre2">That's something that may also happen to your code, if you're not careful.  The following example, which uses another Adapter, compiles well:</p>
<pre class="calibre18">fun &lt;T&gt; collectionProcessing(c: Collection&lt;T&gt;) {<br class="title-page-name"/>    for (e in c) {<br class="title-page-name"/>        println(e)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val s = Stream.generate { 42 }<br class="title-page-name"/>collectionProcessing(s.toList())</pre>
<p class="calibre2">But it never completes, because <kbd class="calibre13">Stream.generate()</kbd> produces an infinite list of integers. So, be careful, and adapt this pattern wisely.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Bridge</h1>
                
            
            
                
<p class="calibre2">Unlike some other design patterns we've met, Bridge is less about a smart way to compose objects, and more about guidelines on how not to abuse inheritance. The way it works is actually very simple.</p>
<p class="calibre2">Let's go back to the strategy game we're building. We have an interface for all our infantry units:</p>
<pre class="calibre18">interface Infantry {<br class="title-page-name"/>    fun move(x: Long, y: Long)<br class="title-page-name"/><br class="title-page-name"/>    fun attack(x: Long, y: Long)<br class="title-page-name"/>}</pre>
<p class="calibre2">We have the concrete implementations:</p>
<pre class="calibre18">open class Rifleman : Infantry {<br class="title-page-name"/>    override fun attack(x: Long, y: Long) {<br class="title-page-name"/>        // Shoot<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun move(x: Long, y: Long) {<br class="title-page-name"/>        // Move at its own pace<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>open class Grenadier : Infantry {<br class="title-page-name"/>    override fun attack(x: Long, y: Long) {<br class="title-page-name"/>        // Throw grenades<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun move(x: Long, y: Long) {<br class="title-page-name"/>        // Moves slowly, grenades are heavy<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">What if we want to have the ability to upgrade our units? </p>
<p class="calibre2">Upgraded units should have twice the damage, but move at the same pace:</p>
<pre class="calibre18">class UpgradedRifleman : Rifleman() {<br class="title-page-name"/>    override fun attack(x: Long, y: Long) {<br class="title-page-name"/>        // Shoot twice as much<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class UpgradedGrenadier : Grenadier() {<br class="title-page-name"/>    override fun attack(x: Long, y: Long) {<br class="title-page-name"/>        // Throw pack of grenades<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, our game designer has decided that we also need a light version of those units. That is, they attack in the same way as regular units, but move at twice the speed:</p>
<pre class="calibre18">class LightRifleman : Rifleman() {<br class="title-page-name"/>    override fun move(x: Long, y: Long) {<br class="title-page-name"/>        // Running with rifle<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class LightGrenadier : Grenadier() {<br class="title-page-name"/>    override fun move(x: Long, y: Long) {<br class="title-page-name"/>        // I've been to gym, pack of grenades is no problem<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Since design patterns are all about adapting to change, here comes our dear designer, and asks that all infantry units be able to shout, that is, to proclaim their unit name loud and clear:</p>
<pre class="calibre18">interface Infantry {<br class="title-page-name"/>    // As before, move() and attack() functions<br class="title-page-name"/><br class="title-page-name"/>    fun shout() // Here comes the change<br class="title-page-name"/>}</pre>
<p class="calibre2">What are we to do now? </p>
<p class="calibre2">We go and change the implementation of six different classes, feeling lucky that there are only six and not sixteen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Bridging changes</h1>
                
            
            
                
<p class="calibre2">Depending on the way you look at it, the <strong class="calibre5">Bridge</strong> design pattern may resemble Adapter, which we already discussed, or <strong class="calibre5">Strategy</strong>, which we'll discuss in the next chapter.</p>
<p class="calibre2">The idea behind the Bridge design pattern is to flatten the class hierarchy, which is currently three levels deep:</p>
<pre class="calibre18">Infantry --&gt; Rifleman  --&gt; Upgraded Rifleman                                                                           --&gt; Light Rifleman             <br class="title-page-name"/>         --&gt; Grenadier --&gt; Upgraded Grenadier       <br class="title-page-name"/>                       --&gt; Light Grenadier</pre>
<p class="calibre2">Why do we have this complex hierarchy?</p>
<p class="calibre2">It's because we have three orthogonal properties: weapon type, weapon strength, and movement speed.</p>
<p class="calibre2">Say instead, we were to pass those properties to the constructor of a class that implements the same interface we were using all along:</p>
<pre class="calibre18">class Soldier(private val weapon: Weapon,<br class="title-page-name"/>              private val legs: Legs) : Infantry {<br class="title-page-name"/>    override fun attack(x: Long, y: Long) {<br class="title-page-name"/>        // Find target<br class="title-page-name"/>        // Shoot<br class="title-page-name"/>        weapon.causeDamage()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun move(x: Long, y: Long) {<br class="title-page-name"/>        // Compute direction<br class="title-page-name"/>        // Move at its own pace<br class="title-page-name"/>        legs.move()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The properties that <kbd class="calibre13">Soldier</kbd> receives should be interfaces, so we could choose their implementation later:</p>
<pre class="calibre18">interface Weapon {<br class="title-page-name"/>    fun causeDamage(): PointsOfDamage<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>interface Legs {<br class="title-page-name"/>    fun move(): Meters<br class="title-page-name"/>}</pre>
<p class="calibre2">But what are <kbd class="calibre13">Meters</kbd> and <kbd class="calibre13">PointsOfDamage</kbd>? Are those classes or interfaces we declared somewhere?</p>
<p class="calibre2">Let's take a short detour.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Type aliases</h1>
                
            
            
                
<p class="calibre2">First, we'll look at how they're declared:</p>
<pre class="calibre18">typealias PointsOfDamage = Long<br class="title-page-name"/>typealias Meters = Int</pre>
<p class="calibre2">We use a new keyword here, <kbd class="calibre13">typealias</kbd>.  From now on, we can use <kbd class="calibre13">Meters</kbd> instead of plain old <kbd class="calibre13">Int</kbd> to return from our <kbd class="calibre13">move()</kbd> method.  They aren't new types. The Kotlin compiler will always translate <kbd class="calibre13">PointsOfDamage</kbd> to <kbd class="calibre13">Long</kbd> during compilation. Using them provides two advantages:</p>
<ul class="calibre11">
<li class="calibre12">Better semantics, as in our case. We can tell exactly what the meaning of the value we're returning is.</li>
<li class="calibre12">One of the main goals of Kotlin is to be concise. Type aliases allow us to hide complex generic expressions. We'll expand on this in the following sections.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">You're in the army now</h1>
                
            
            
                
<p class="calibre2">Back to our <kbd class="calibre13">Soldier</kbd> class. We want it to be as adaptable as possible, right? He knows he can move or use his weapon for greater good. But how exactly is he going to do that?</p>
<p class="calibre2">We totally forgot to implement those parts! Let's start with our weapons:</p>
<pre class="calibre18">class Grenade : Weapon {<br class="title-page-name"/>    override fun causeDamage() = GRENADE_DAMAGE<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class GrenadePack : Weapon {<br class="title-page-name"/>    override fun causeDamage() = GRENADE_DAMAGE * 3<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Rifle : Weapon {<br class="title-page-name"/>    override fun causeDamage() = RIFLE_DAMAGE<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<pre class="calibre18">class MachineGun : Weapon {<br class="title-page-name"/>    override fun causeDamage() = RIFLE_DAMAGE * 2<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, let's look at how we can move:</p>
<pre class="calibre18">class RegularLegs : Legs {<br class="title-page-name"/>    override fun move() = REGULAR_SPEED<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class AthleticLegs : Legs {<br class="title-page-name"/>    override fun move() = REGULAR_SPEED * 2<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Constants</h1>
                
            
            
                
<p class="calibre2">We define all parameters as constants:</p>
<pre class="calibre18">const val GRENADE_DAMAGE : PointsOfDamage = 5L<br class="title-page-name"/>const val RIFLE_DAMAGE = 3L<br class="title-page-name"/>const val REGULAR_SPEED : Meters = 1</pre>
<p class="calibre2">Those values are very effective, since they are known during compilation.</p>
<p class="calibre2">Unlike <kbd class="calibre13">static final</kbd> variables in Java, they cannot be placed inside a class. You should place them either at the top level of your package or nest them inside <kbd class="calibre13">object</kbd>.</p>
<p>Note that although Kotlin has type inference, we can specify the types of our constants explicitly, and even use type aliases. How about having <kbd class="calibre20">DEFAULT_TIMEOUT : Seconds = 60</kbd> instead of<br class="calibre21"/>
<kbd class="calibre20">DEFAULT_TIMEOUT_SECONDS = 60</kbd> in your code? </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A lethal weapon</h1>
                
            
            
                
<p class="calibre2">What is left for us is to see that with the new hierarchy, we can still do the exact same things:</p>
<pre class="calibre18">val rifleman = Soldier(Rifle(), RegularLegs())<br class="title-page-name"/>val grenadier = Soldier(Grenade(), RegularLegs())<br class="title-page-name"/>val upgradedGrenadier = Soldier(GrenadePack(), RegularLegs())<br class="title-page-name"/>val upgradedRifleman = Soldier(MachineGun(), RegularLegs())<br class="title-page-name"/>val lightRifleman = Soldier(Rifle(), AthleticLegs())<br class="title-page-name"/>val lightGrenadier = Soldier(Grenade(), AthleticLegs())</pre>
<p class="calibre2">Now, our hierarchy looks like this:</p>
<pre class="calibre18">Infantry --&gt; Soldier<br class="title-page-name"/><br class="title-page-name"/>Weapon --&gt; Rifle<br class="title-page-name"/>       --&gt; MachineGun<br class="title-page-name"/>       --&gt; Grenade<br class="title-page-name"/>       --&gt; GrenadePack <br class="title-page-name"/><br class="title-page-name"/>Legs --&gt; RegularLegs<br class="title-page-name"/>     --&gt; AthleticLegs</pre>
<p class="calibre2">Much simpler to extend and also to comprehend. Unlike some other design patterns we discussed before, we didn't use any special language feature we didn't know about, just some engineering best practices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Composite</h1>
                
            
            
                
<p class="calibre2">You may finish this section with a lingering feeling that this pattern is a bit awkward. That's because it has a soul mate, it's accompanying pattern, <strong class="calibre5">Iterator</strong>, which we'll discuss in the next chapter. When both are combined, that's where they really shine. So, if you're feeling confused, come back to this pattern after you have got acquainted with <strong class="calibre5">Iterator</strong> too.</p>
<p class="calibre2">Having said that, we can start analyzing this pattern. It may look a bit strange to have a <strong class="calibre5">Composite</strong> design pattern. After all, aren't all <strong class="calibre5">Structural Patterns</strong> about composing objects? </p>
<p class="calibre2">Much like in the case of the Bridge design pattern, the name may not reflect its true benefits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Get together</h1>
                
            
            
                
<p class="calibre2">Going back to our strategy game, we have a new concept: a squad. A squad consists of zero or more infantry units. This would be a good example of a somewhat complex data structure.</p>
<p class="calibre2">Here are the interfaces and classes we have:</p>
<pre class="calibre18">interface InfantryUnit<br class="title-page-name"/><br class="title-page-name"/>class Rifleman : InfantryUnit<br class="title-page-name"/><br class="title-page-name"/>class Sniper : InfantryUnit</pre>
<p class="calibre2">How would you implement that? We'll see it in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Squad</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre13">Squad</kbd>, clearly, must be a collection of infantry units. So, it should be easy:</p>
<pre class="calibre18">class Squad(val infantryUnits: MutableList&lt;InfantryUnit&gt; =         mutableListOf())</pre>
<p class="calibre2">We even set up a default parameter value, so the other programmer won't need to pass his own list of soldiers unless he really needs too. <kbd class="calibre13">MutableList</kbd> suits us well here, since we may add units later.</p>
<p class="calibre2">To make sure it works, we'll create three soldiers and put them inside:</p>
<pre class="calibre18">val miller = Rifleman()<br class="title-page-name"/>val caparzo = Rifleman()<br class="title-page-name"/>val jackson = Sniper()<br class="title-page-name"/><br class="title-page-name"/>val squad = Squad()<br class="title-page-name"/><br class="title-page-name"/>squad.infantryUnits.add(miller)<br class="title-page-name"/>squad.infantryUnits.add(caparzo)<br class="title-page-name"/>squad.infantryUnits.add(jackson)<br class="title-page-name"/><br class="title-page-name"/>println(squad.infantryUnits.size) // Prints 3</pre>
<p class="calibre2">But the next day, Dave, that's the other programmer, comes to us with a new requirement. He thinks it consists of too many lines of code to add soldiers one by one, or even to use <kbd class="calibre13">mutableListOf()</kbd> to pass them. </p>
<p class="calibre2">He would like to initialize squads like this:</p>
<pre class="calibre18">val squad = Squad(miller, caparzo, jackson)</pre>
<p class="calibre2">That looks nice, but how in the name of all the squads are we going to do that? </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Varargs and secondary constructors</h1>
                
            
            
                
<p class="calibre2">Up until now, we were always using the primary constructor of the class. That's the one declared after the class name. But in Java, we can define more than one constructor for a class. Why does Kotlin limit us to only one? </p>
<p class="calibre2">Actually, it doesn't. We can define secondary constructors for a class using the <kbd class="calibre13">constructor</kbd> keyword:</p>
<pre class="calibre18">class Squad(val infantryUnits: MutableList&lt;InfantryUnit&gt; = mutableListOf()) {<br class="title-page-name"/>    constructor(first: InfantryUnit) : this(mutableListOf()) {<br class="title-page-name"/>        this.infantryUnits.add(first)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    constructor(first: InfantryUnit, <br class="title-page-name"/>                second: InfantryUnit) : this(first) {<br class="title-page-name"/>        this.infantryUnits.add(second)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    constructor(first: InfantryUnit, <br class="title-page-name"/>                second: InfantryUnit, <br class="title-page-name"/>                third: InfantryUnit) : <br class="title-page-name"/>        this(first, second) {<br class="title-page-name"/>        this.infantryUnits.add(third)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note how we delegate one constructor to another:</p>
<pre class="calibre18">    constructor(first: InfantryUnit) : this(mutableListOf()) {<br class="title-page-name"/>    }                                     ⇑<br class="title-page-name"/>                                          ⇑<br class="title-page-name"/>    constructor(first: InfantryUnit,      ⇑ // Delegating<br class="title-page-name"/>                second: InfantryUnit) : this(first) {    <br class="title-page-name"/>    }</pre>
<p class="calibre2">But this is clearly not the way to go, since we cannot predict how many more elements Dave may pass us. If you come from Java, you have probably thought about variadic functions already, which can take an arbitrary number of arguments of the same type. In Java, you would declare the parameter as <kbd class="calibre13">InfantryUnit... units</kbd>.</p>
<p class="calibre2">Kotlin provides us with the <kbd class="calibre13">vararg</kbd> keyword for the same purposes. Combining those two approaches, we get the following nice piece of code:</p>
<pre class="calibre18">class Squad(val infantryUnits: MutableList&lt;InfantryUnit&gt; =     mutableListOf()) {<br class="title-page-name"/><br class="title-page-name"/>    constructor(vararg units: InfantryUnit) : this(mutableListOf()) {<br class="title-page-name"/>        for (u in units) {<br class="title-page-name"/>            this.infantryUnits.add(u)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Counting bullets</h1>
                
            
            
                
<p class="calibre2">The game designer catches you in the evening, when you are about to go home of course. He wants to add the ammo count for the entire squad so each squad will be able to report how much ammo it has left:</p>
<pre class="calibre18">fun bulletsLeft(): Long {<br class="title-page-name"/>    // Do your job<br class="title-page-name"/>}</pre>
<p class="calibre2">Where's the catch?</p>
<p class="calibre2">Well, you see, snipers have ammo as separate bullets:</p>
<pre class="calibre18">class Bullet</pre>
<p class="calibre2">Riflemen hold their bullets in magazines:</p>
<pre class="calibre18">class Magazine(capacity: Int) {<br class="title-page-name"/>    private val bullets = List(capacity) { Bullet() }<br class="title-page-name"/>}</pre>
<p class="calibre2">Luckily, you don't have <em class="calibre14">machine gunners</em> on your squad yet, because they carry their ammo in belts...</p>
<p class="calibre2">So, you have a complex structure, which may or may not be nested. And you need to perform a certain operation on this structure as a whole. Here's where the Composite design pattern truly comes into play.</p>
<p class="calibre2">You see, the name is a bit confusing. Composite is not so much about composing objects, but more about treating different type objects as nodes of the same tree. For that, they should all implement the same interface. </p>
<p class="calibre2">It may not be that obvious at first. After all, a <em class="calibre14">rifleman</em> is clearly not a <em class="calibre14">squad</em>. But instead of looking at an interface as an <em class="calibre14">is-a</em> relationship, we should look at it as an <em class="calibre14">ability enabler</em>. Android, for example, adopts this pattern often.</p>
<p class="calibre2">Our ability is to count bullets:</p>
<pre class="calibre18">interface CanCountBullets {<br class="title-page-name"/>    fun bulletsLeft(): Int<br class="title-page-name"/>}</pre>
<p class="calibre2">Both <kbd class="calibre13">Squad</kbd> and <kbd class="calibre13">InfantryUnit</kbd> should implement this interface:</p>
<pre class="calibre18">interface InfantryUnit : <strong class="calibre1">CanCountBullets</strong><br class="title-page-name"/><br class="title-page-name"/>class Squad(...) : <strong class="calibre1">CanCountBullets</strong> {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Magazine(...): <strong class="calibre1">CanCountBullets</strong> {<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">And now, since everybody has the same ability, no matter how deep the nesting, we can ask the top-level object to query everything beneath it.</p>
<p class="calibre2"><kbd class="calibre13">Magazine</kbd> and <kbd class="calibre13">Sniper</kbd> simply count the bullets they contain. The following example shows how we can keep a track of the number of bullets in <kbd class="calibre13">Magazines</kbd>:</p>
<pre class="calibre18">class Magazine(...): CanCountBullets {<br class="title-page-name"/>    ...<br class="title-page-name"/>    override fun bulletsLeft() = bullets.size<br class="title-page-name"/>}</pre>
<p class="calibre2">The following example shows how we can keep a track of the number of bullets <kbd class="calibre13">Sniper</kbd> has:</p>
<pre class="calibre18">class Sniper(initalBullets: Int = 50) : InfantryUnit {<br class="title-page-name"/>    private val bullets = List(initalBullets) { Bullet () }<br class="title-page-name"/>    override fun bulletsLeft() = bullets.size<br class="title-page-name"/>}</pre>
<p class="calibre2">For <kbd class="calibre13">Rifleman</kbd>, we can go over their <kbd class="calibre13">Magazines</kbd> and check how many bullets they contain:</p>
<pre class="calibre18">class Rifleman(initialMagazines: Int = 3) : InfantryUnit {<br class="title-page-name"/>    private val magazines = List&lt;Magazine&gt;(initialMagazines) {<br class="title-page-name"/>        Magazine(5)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun bulletsLeft(): Int {<br class="title-page-name"/>        return magazines.sumBy { it.bulletsLeft() }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, for the squad, we count the sum of counts of all the units squad contains:</p>
<pre class="calibre18">override fun bulletsLeft(): Int {<br class="title-page-name"/>    return infantryUnits.sumBy { it.bulletsLeft() }<br class="title-page-name"/>}</pre>
<p class="calibre2">Tomorrow, when your product manager discovers suddenly that he needs to implement a platoon (that's a collection of squads), you'll be armed and ready.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Facade</h1>
                
            
            
                
<p class="calibre2">In different implementations and approaches, <strong class="calibre5">Facade</strong> may resemble either an <strong class="calibre5">Adapter</strong> or an <strong class="calibre5">Abstract Factory</strong>. </p>
<p class="calibre2">Its goal seems straightforward—to simplify interacting with another class or a family of classes:</p>
<ul class="calibre11">
<li class="calibre12">When we think about <em class="calibre25">simplifying</em>, we usually think of the <strong class="calibre1">Adapter</strong> design pattern</li>
<li class="calibre12">When we think about the <em class="calibre25">family of classes</em>, we usually think of an <strong class="calibre1">Abstract Factory</strong></li>
</ul>
<p class="calibre2">That's where all the confusion usually comes from. To better understand it, let's go back to the example we used for the Abstract Factory design pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Keep it simple</h1>
                
            
            
                
<p class="calibre2">Let's say that we would like to implement the <kbd class="calibre13">loadGame()</kbd> method. This method would take a file we already created (we'll discuss how later), or, at the least, the following will be required:</p>
<ol class="calibre15">
<li value="1" class="calibre12">At least two HQs will fave to be created (otherwise, the game is already won)</li>
<li value="2" class="calibre12">Each HQ will have to produce the buildings it had</li>
<li value="3" class="calibre12">Each building will have to produce the units it had</li>
<li value="4" class="calibre12">All units will have to magically teleport to the positions they were at when the game was saved</li>
<li value="5" class="calibre12">If there were any commands given to units (like <em class="calibre25">obliterating all enemy bases</em>), they should resume executing them</li>
</ol>
<p>We'll discuss how we actually give commands to our units in the next chapter, with the <strong class="calibre26">Command</strong> design pattern. Stay tuned.</p>
<p class="calibre2">Now, usually, it's not just one person working on a game unless it's <strong class="calibre5">Minecraft (TM)</strong>. There's that other guy, Dave, who deals with all the command logic. He's not much into constructing buildings. But in his role, he also needs to load saved games quite often.</p>
<p class="calibre2">As the developer of all those bases that belong to you, you could give him a set of instructions you've written on how the game should be properly loaded. He may or may not follow this set of instructions. Maybe he'll forget to move the units, or build buildings. And the game will crash. You could use the Facade design pattern to simplify the job for him.</p>
<p class="calibre2">What's the main problem Dave has right now? </p>
<p class="calibre2">To load a game, he needs to interact with at least three different interfaces:</p>
<ul class="calibre11">
<li class="calibre12">HQ</li>
<li class="calibre12">Building</li>
<li class="calibre12">Unit</li>
</ul>
<p class="calibre2">What he would like is to have only one interface, something like:</p>
<pre class="calibre18">interface GameWorld</pre>
<p class="calibre2">That has exactly the methods he needs:</p>
<pre class="calibre18">fun loadGame(file: File) GameWorld</pre>
<p class="calibre2">Hey, but that looks like a Static Factory Method there! </p>
<p class="calibre2">Yep, sometimes, design patterns are embedded into one another. We use the Static Factory Method to create our class, but its goal is to be a Facade for other more complex classes. Using a Facade doesn't mean we don't expose interfaces our facade hides behind to the client. Dave can still use every small unit to issue orders after the game is loaded successfully. </p>
<p class="calibre2">Simple, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Flyweight</h1>
                
            
            
                
<p class="calibre2">Flyweight is an object without any state. The name comes from <em class="calibre14">being very light</em>.</p>
<p class="calibre2">If you've been reading either one of the two previous chapters, you may already think of a type of object that should be very light: a <kbd class="calibre13">data</kbd> class. But a <kbd class="calibre13">data</kbd> class is all about state. So, is it related to the Flyweight design pattern at all?</p>
<p class="calibre2">To understand this pattern better, we need to jump back in time some twenty years.</p>
<p class="calibre2">Back in '94, when the original <em class="calibre14">Design Patterns</em> book was published, your regular PC had 4 MB of RAM. One of the main goals was to save that precious RAM because you could fit only so much into it.</p>
<p class="calibre2">Nowadays, some cell phones have 4 GB of RAM. Bear that fact in mind when we discuss what the Flyweight design pattern is all about.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Being conservative</h1>
                
            
            
                
<p class="calibre2">Imagine we're building a 2D side-scrolling arcade platformer. That is, you have your character, which you control with arrow keys or a gamepad. Your character can move left, right, and jump.</p>
<p class="calibre2">Since we're a really small indie company consisting of one developer (who is also a graphic designer, product manager, and sales representative), two cats, and a canary named Michael, we use only sixteen colors in our game. And our character is 64 pixels tall and 64 pixels wide. We call him <strong class="calibre5">Maronic</strong>, and that's also the name of our game.</p>
<p class="calibre2">Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian snails:</p>
<pre class="calibre18">class TansanianSnail</pre>
<p class="calibre2">Since it's a 2D game, each snail has only two directions of movement—left and right:</p>
<pre class="calibre18">enum class Direction {<br class="title-page-name"/>   LEFT,<br class="title-page-name"/>   RIGHT<br class="title-page-name"/>}</pre>
<p class="calibre2">Each snail holds a pair of images and a direction:</p>
<pre class="calibre18">class TansanianSnail() {<br class="title-page-name"/>   val directionFacing = Direction.LEFT<br class="title-page-name"/><br class="title-page-name"/>   val sprites = listOf(java.io.File("snail-left.jpg"), <br class="title-page-name"/>                        java.io.File("snail-right.jpg"))<br class="title-page-name"/>}</pre>
<p class="calibre2">We can get the current sprite that shows us which direction the snail is facing:</p>
<pre class="calibre18">    fun TansanianSnail.getCurrentSprite() : java.io.File {<br class="title-page-name"/>        return when (directionFacing) {<br class="title-page-name"/>            Direction.LEFT -&gt; sprites[0]<br class="title-page-name"/>            Direction.RIGHT -&gt; sprites[1]<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre2">We can draw it on the screen:</p>
<pre class="calibre18">      _____<br class="title-page-name"/>  \|_\___  \<br class="title-page-name"/>  /________/    &lt;-- With a bit of imagination you'll see it's a snail</pre>
<p class="calibre2">But when it moves, it basically just slides left or right. What we would like is to have three animated sprites to reproduce the snail's movments:</p>
<pre class="calibre18">---------------------------------------------------------------------<br class="title-page-name"/>     _____ |    _____ |    _____ |    _____ |    _____ |    _____        <br class="title-page-name"/> _|_/___∂ \|\|_/___∂ \|\/_/___∂ \|\|_/___∂ \|\|_/___∂ \|\|_/___∂ \<br class="title-page-name"/> /____\___/| \___\___/|/____\___/|/____\___/|/____\___/|/____\___/<br class="title-page-name"/>---------------------------------------------------------------------<br class="title-page-name"/>left-3      left-2     left-1     right-1    right-2    right-3      </pre>
<p class="calibre2">To have it in our code:</p>
<pre class="calibre18">    val sprites = List(8) { i -&gt;<br class="title-page-name"/>              java.io.File(when {<br class="title-page-name"/>                        i == 0 -&gt; "snail-left.jpg"<br class="title-page-name"/>                        i == 1 -&gt; "snail-right.jpg"<br class="title-page-name"/>                        i in 2..4 -&gt; "snail-move-left-${i-1}.jpg"<br class="title-page-name"/>                        else -&gt; "snail-move-right${(4-i)}.jpg"<br class="title-page-name"/>                    })<br class="title-page-name"/>            }</pre>
<p class="calibre2">We initialize a list of eight elements passing a <kbd class="calibre13">block</kbd> function as a constructor. For each element, we decide what image to get:</p>
<ul class="calibre11">
<li class="calibre12">Positions 0 and 1 are for still images</li>
<li class="calibre12">Positions 2 through 4 are for moving left</li>
<li class="calibre12">Positions 5 through 7 are for moving right</li>
</ul>
<p class="calibre2">Let's do some math now. Each snail is a 64 x 64 image. Assuming each color takes exactly one byte, single images take 4 KB of RAM in the memory. Since we have eight images for a snail, we need 32 KB of RAM for each, which allows us to fit only 32 snails into 1 MB of memory.</p>
<p class="calibre2">Since we want to have thousands of those dangerous and extremely fast creatures on screen, and to be able to run our game on a ten-year-old phone, we clearly need a better solution for that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Saving memory</h1>
                
            
            
                
<p class="calibre2">What's the problem wehave with our snails? They're actually quite fat, heavyweight snails.</p>
<p class="calibre2">We would like to put them on a diet. Each snail stores eight images within its snaily body.  But actually, those images are the same for each snail. </p>
<p class="calibre2">What if we extract those sprites:</p>
<pre class="calibre18">val sprites = List(8) { i -&gt;<br class="title-page-name"/>    java.io.File(when {<br class="title-page-name"/>        i == 0 -&gt; "snail-left.jpg"<br class="title-page-name"/>        i == 1 -&gt; "snail-right.jpg"<br class="title-page-name"/>        i in 2..4 -&gt; "snail-move-left-${i-1}.jpg"<br class="title-page-name"/>        else -&gt; "snail-move-right${(4-i)}.jpg"<br class="title-page-name"/>    })<br class="title-page-name"/>}</pre>
<p class="calibre2">Then we pass this list each time to the <kbd class="calibre13">getCurrentSprite()</kbd> function:</p>
<pre class="calibre18">fun TansanianSnail.getCurrentSprite(sprites: List&lt;java.io.File&gt;) :     java.io.File { ... }</pre>
<p class="calibre2">That way, we'll only consume 256 KB of memory, no matter how many snails we generate. We could generate millions of them without affecting the footprint of our program.</p>
<p class="calibre2">Of course, we should worry about the immutability of the data we pass. That means that at no point in time we should be able to assign <kbd class="calibre13">null</kbd> to our <kbd class="calibre13">sprites</kbd> variable as follows:</p>
<pre class="calibre18">sprites = null</pre>
<p class="calibre2">That would produce <kbd class="calibre13">NullPointerException</kbd>. Also, it would be disastrous if someone was to <kbd class="calibre13">clear()</kbd> this list:</p>
<pre class="calibre18">sprites.clear()</pre>
<p class="calibre2">Luckily, Kotlin handles this for us. Since we use <kbd class="calibre13">val</kbd>, the list is assigned exactly once. Also, since we use List, it produces an immutable list, which cannot be changed or cleared. </p>
<p class="calibre2">All of the preceding lines won't even compile:</p>
<pre class="calibre18">sprites.clear()<br class="title-page-name"/>sprites[0] = File("garbage")<br class="title-page-name"/>sprites[0] = null</pre>
<p class="calibre2">You still can argue about the usefulness of this pattern nowadays, when memory is plentiful. But, as we already said, the tools in the toolbox don't take much space, and having another design pattern under your belt may still prove useful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Proxy</h1>
                
            
            
                
<p class="calibre2">This is one misbehaving design pattern. Much like Decorator, it extends object functionality. But, unlike Decorator, which always does at it's told, having a <strong class="calibre5">Proxy </strong>may mean that when asked, the object will do something totally different instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A short detour into the RMI world</h1>
                
            
            
                
<p class="calibre2">While discussing Proxy, a lot of sources, mostly related to Java, diverge into discussing another concept, RMI.</p>
<p class="calibre2">RMI in the JVM world stands for Remote Method Invocation, which is a sort of <strong class="calibre5">Remote Procedure Call</strong> (<strong class="calibre5">RPC</strong>). What that means is that you're able to call some code that doesn't exist on your local machine, but sits on some remote machine.</p>
<p class="calibre2">Although a very clever solution, it's very JVM specific, and has become less popular in the era of microservices, where each piece of code may be written in a totally different programming language. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A replacement</h1>
                
            
            
                
<p class="calibre2">When we discussed Creational Patterns, we already discussed the idea of <em class="calibre14">expensive</em> objects. For example, an object that accesses network resources, or takes a lot of time to create.</p>
<p class="calibre2">We at <strong class="calibre5">Funny Cat App</strong> (name invented by the canary Michael; remember him from the Flyweight pattern?) provide our users with funny cat images on a daily basis. On our homepage and mobile application, each user sees a lot of thumbnails of funny cats. When he clicks or touches any of those images, it expands to its full-screen glory. </p>
<p class="calibre2">But fetching cat images over the network is very expensive, and it consumes a lot of memory, especially if those are images of cats that tend to indulge themselves in a second dessert after dinner. So, what we would like to do is to have a smart object, something that manages itself.</p>
<p class="calibre2">When the first user access this image, it will be fetched over the network. No way of avoiding that. </p>
<p class="calibre2">But when it's being accessed for the second time, by this or some other user, we would like to avoid going over the network again, and instead return the result that was cached. That's the <em class="calibre14">misbehaving</em> part, as we described. Instead of the expected behavior of going over the network each time, we're being a bit lazy, and returning the result that we already prepared. It's a bit like going into a cheap diner, ordering a hamburger, and getting it after only two minutes, but cold. Well, that's because someone else hated onions and returned it to the kitchen a while ago. True story.</p>
<p class="calibre2">That sounds like a lot of logic. But, as you've probably guessed, especially after meeting the Decorator design pattern, Kotlin can perform miracles by reducing the amount of boilerplate code you need to write to achieve your goals:</p>
<pre class="calibre18">data class CatImage(private val thumbnailUrl: String, <br class="title-page-name"/>                    private val url: String) {<br class="title-page-name"/>    val image: java.io.File by <strong class="calibre1">lazy</strong> {<br class="title-page-name"/>        // Actual fetch goes here<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As you may notice, we use the <kbd class="calibre13">by</kbd> keyword to delegate initialization of this field to a standard function called <kbd class="calibre13">lazy</kbd>.</p>
<p class="calibre2">The first call to <kbd class="calibre13">image</kbd> will execute a block of our code and save its results into the <kbd class="calibre13">image</kbd> property.</p>
<p class="calibre2">Sometimes, the Proxy design pattern is divided into three sub-patterns:</p>
<ul class="calibre11">
<li class="calibre12">Virtual proxy: Lazily caches the result</li>
<li class="calibre12">Remote proxy: Issues a call to the remote resource</li>
<li class="calibre12">Protection or access control proxy: denies access to unauthorized parties</li>
</ul>
<p class="calibre2">Depending on your views, you can regard our example as either a virtual proxy or a combination of virtual and remote proxies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lazy delegation</h1>
                
            
            
                
<p class="calibre2">You may wonder what happens if two threads try to initialize the image at the same time. By default, the <kbd class="calibre13">lazy()</kbd> function is synchronized. Only one thread will win, and others will wait until the image is ready.</p>
<p class="calibre2">If you don't mind two threads executing the <kbd class="calibre13">lazy</kbd> block (it's not that expensive, for example), you can use <kbd class="calibre13">by lazy(LazyThreadSafetyMode.PUBLICATION)</kbd>.</p>
<p class="calibre2">If performance is absolutely critical to you, and you're absolutely sure that two threads won't ever execute the same block simultaneously, you can use <kbd class="calibre13">LazyThreadSafetyMode.NONE</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we learned how structural design patterns help us to create more flexible code that can adapt to changes with ease, sometimes even at runtime. We've covered <strong class="calibre5">operator overloading</strong> in Kotlin and its limitations. You should know how to create a shortcut to a type name with <kbd class="calibre13">typealias</kbd> and how to define efficient constants with <kbd class="calibre13">const</kbd>.</p>
<p class="calibre2">We've covered how delegating to another class works in Kotlin, by implementing the same interface and using the <kbd class="calibre13">by</kbd> keyword.</p>
<p class="calibre2">In addition, we covered functions that can receive an <strong class="calibre5">arbitrary number of arguments</strong> with <kbd class="calibre13">vararg</kbd> and <strong class="calibre5">lazy initialization</strong> with <kbd class="calibre13">lazy</kbd>.</p>
<p class="calibre2">In the next chapter, we'll discuss the third family of classical design patterns: behavioral patterns.</p>


            

            
        
    </body></html>