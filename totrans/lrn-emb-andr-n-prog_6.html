<html><head></head><body>
		    <div class="readerChapterContent">
		      <div>
  <h1 class="Title-1"><span>Chapter 6. "Cooking" Your First ROM</span></h1>

  <p><span>In </span><a class="link" href="" title="Chapter 5. Customizing Kernel and Boot Sequence"><span>Chapter 5</span></a><span>, </span><span class="emphasis"><em><span>Customizing Kernel and Boot Sequence</span></em></span><span>, we took an amazing journey into the Linux kernel—now you know how to obtain the right version for your device and how to build it. We got great satisfaction customizing and building your own kernel version, specific for your device—we added new drivers for your hardware and removed those that were unnecessary. You finally learned about the boot sequence.</span></p>

  <p><span>In this chapter, we will enter the </span><span class="emphasis"><em><span>modding</span></em></span><span> world and we will move forward with your first customized ROM. You will learn how to set up the system and how to create a custom ROM. We will see an overview of the most popular ROMs, and all the tools you need and how to use them.</span></p>

  <p><span>The following topics will be covered in the chapter:</span></p>

  <ul>
    <li><span>History of Android modding (Cyanogenmod)</span></li>

    <li><span>Custom recovery</span></li>

    <li><span>Root access</span></li>

    <li><span>Kitchen and other tools</span></li>
  </ul>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>History of custom ROMs</span></h2>

  <p><span>First things first—What does "Custom ROM" mean?</span></p>

  <p><span>Most Android devices come with so-called </span><span class="emphasis"><em><span>NAND memories</span></em></span><span>. A NAND memory is a particular type of flash memory. A flash memory is based on transistors, instead of rotating disks, like in old hard drives. This type of memory is completely electrically managed—it can be written and erased and can store data indefinitely (not volatile). Knowing this, we may think that everything is writable on Android. Well, not exactly!</span></p>

  <p><span>The acronym ROM stands for Read-Only Memory. This type of memory is often used in embedded systems to safely store all those files that are part of the core system. In an effort to guarantee the highest system integrity possible, developers must be sure that the core system stays intact over device reboots and possible failures. That's why the core system is stored in a type of memory that can only be written once—Read-Only Memory, to be precise. With time, the Android hacking community took the acronym and transformed it. Nowadays, in saying Custom ROM, you are simply saying "My own custom Android system for this specific device," and this is the meaning we will use in the following pages.</span></p>

  <p><span>As for the Linux kernel, Android is one of the most popular open source projects currently developed. Free to use and customizable, used by millions of people, Android is the base element for hundreds of customized operating systems—most of them were experiments, some were custom versions fixing particular bugs for specific scenarios, and others were optimized versions of the original system.</span></p>

  <p><span>In the beginning, the modding community was very scattered—lots of lone wolves, hacking in their dark rooms. Over time, most of them converged into more social environments, combining their efforts in forums and communities, creating modding teams to provide users with better and more reliable ROMs.</span></p>

  <p><span>In </span><a class="link" href="" title="Chapter 5. Customizing Kernel and Boot Sequence"><span>Chapter 5</span></a><span>, </span><span class="emphasis"><em><span>Customizing Kernel and Boot Sequence</span></em></span><span>, we saw how to create a custom version of Android working with the source code. We were able to radically alter the original system to create our version, perfectly fitting our needs, so what's all this hype about modding? Why couldn't we just grab the source code and customize our system? The truth is that, unfortunately, Google is a needle in a haystack. Most of the other manufacturers play the whole open source game a bit differently and it is not always possible to rebuild a system from scratch, due to the lack of provided source code.</span></p>

  <p><span>Luckily for us, Android customization can be achieved by following a </span><span class="emphasis"><em><span>different path</span></em></span><span>—going straight to the system memory partition, decompiling the components, and making customizations, or so-called </span><span class="strong"><strong><span>surface modifications</span></strong></span><span>.</span></p>

  <p><span>A totally different game is played in the Linux kernel field. As you can remember, Android and the Linux kernel have different licenses—Android is distributed under the Apache License v2, while the Linux kernel is distributed under the GPL license. The GPL license is stricter about modification and redistribution and the manufacturers have a hard time keeping the kernel </span><span class="emphasis"><em><span>secret</span></em></span><span>. That's why the Linux kernel is always available and modders can add, remove, and improve whatever aspect they want—new drivers, improved power management, improved CPU management, and so on.</span></p>

  <p><span>When you look at the whole custom ROM idea, you end up thinking that you see custom ROMs everywhere and every day—manufacturer's ROM. If we think that the </span><span class="emphasis"><em><span>really pure</span></em></span><span> Android system is the one shipped with Nexus devices, we realize that manufacturers are the </span><span class="emphasis"><em><span>first modders</span></em></span><span>, turning the original system into something often completely different. Just think about Samsung or HTC custom UI. Those are huge modifications to the UI. Think about those devices that have an AM/FM radio—again, serious customization. Some manufacturers have gone so far with customizations over the years that they eventually made their device incompatible even with Google Play Store.</span></p>

  <p><span>In the following pages, we will see an overview of the most popular custom ROMs to try to understand why they are so loved by advanced users.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Cyanogenmod</span></h3>

  <p><span>One of the undisputedly most popular Android custom ROMs is Cyanogenmod. It's one of the oldest ones and it brings features and performance that cannot be found in the official Android system:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_89.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_89" style="max-width:831px;max-height:264px"/></div>

  <p><span>Since the beginning, just after the first public releases of Android open source code, the Cyanogen team started back-porting the latest Android version to old devices. They basically overcame manufacturers' </span><span class="emphasis"><em><span>business decisions</span></em></span><span> to leave old devices with old Android versions and made an effort to give new glory to so-called </span><span class="emphasis"><em><span>legacy devices</span></em></span><span>.</span></p>

  <p><span>During the years, the Cyanogenmod team added and tuned tons of features, and this approach attracted thousands of users. The improvements have been so good that often the official Google Android team merged them into the official Android source base, in the real open source community spirit.</span></p>

  <p><span>As said earlier, the Cyanogenmod team didn't start the project from scratch. They used the Android Open Source Project and enhanced it. Using a different approach to lots of other customizers, they decided that the whole project had to be available as open source code, allowing everybody to enjoy all the features, learn from the source code, and contribute to the project itself. Over the years, the community has grown significantly, and lots and lots of blog posts, tutorials, and practical guides have invaded the web-sphere, making Cyanogenmod one of the most popular custom ROMs currently available.</span></p>

  <p><span>This is a list of the most-loved features that Cyanogenmod currently provides:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Theming support</span></strong></span><span>: The whole system UI can be customized with user-made themes that can be applied to the system at runtime</span></li>

    <li><span class="strong"><strong><span>FLAC support</span></strong></span><span>: Free Lossless Audio Codec is one of the many audio codecs available on the system</span></li>

    <li><span class="strong"><strong><span>Bigger APN (Access Point Network) list</span></strong></span><span>: Lots of different APNs have been added over time, making it easy to quickly set up an Internet connection on a multitude of devices</span></li>

    <li><span class="strong"><strong><span>OpenVPN client</span></strong></span><span>: The popular VPN software is available and ready to be used</span></li>

    <li><span class="strong"><strong><span>Enriched Power Off menu</span></strong></span><span>: The Power Off menu contains new actions such as Reboot, Recovery Mode Reboot, and so on</span></li>
  </ul>

  <p><span>Some other features include:</span></p>

  <ul>
    <li><span>Support for Wi-Fi, Bluetooth, and USB tethering</span></li>

    <li><span>CPU Overclock management and system-wide performance enhancements</span></li>

    <li><span>Advanced management of Soft Buttons</span></li>

    <li><span>New Toggle Buttons in the system notification menu such as GPS, Bluetooth, and Wi-Fi</span></li>

    <li><span>Advanced Application permissions management, for a meticulously secured system</span></li>

    <li><span>System-wide graphics enhancements</span></li>

    <li><span>Increased performance and reliability, as stated by the team, compared to any other Android system derived from the official Google vanilla one</span></li>
  </ul>

  <p><span>In April 2013, Cyanogenmod went from community project to an actual company. Despite this, the open source nature is still one of the main core values of the company. So far, it counts 17 employees working full-time on the project. In the last three years, they received a few donations from third-party partners, such as Benchmark Capital and Redpoint Ventures, pushing the development of an easier Cyanogenmod installation process.</span></p>

  <p><span>In 2014, Cyanogenmod announced a partnership with OnePlus, a smartphone manufacturer, to distribute their devices with a pre-installed Cyanogenmod. According to their analytics, Cyanogenmod is currently used by 50 million devices.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Building Cyanogenmod</span></h4>

  <p><span>Inspired by Google AOSP, Cyanogenmod provides an official website where you can download the project source code and access the support forum: </span><a class="ulink" href="http://www.cyanogenmod.org"><span>www.cyanogenmod.org</span></a><span>.</span></p>

  <p><span>The website also provides a complete list of every supported device. Unlike Google AOSP, which formally supports only Nexus devices, Cyanogenmod is available for dozens of different devices.</span></p>

  <p><span>The Cyanogenmod build system is the exact same one you already mastered in the previous chapters. Knowing that, we leave it as an exercise to download and build your own Cyanogenmod version to fully understand how far Android AOSP can be customized and improved.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Installing a pre-build version</span></h4>

  <p><span>Being an open source project, you could build Cyanogen from source. If you want a quicker solution, Cyanogenmod provides pre-built installable versions of the system for a plethora of devices. Just check the website and look for one of your devices—chances are that it's on the list of supported devices.</span></p>

  <p><span>Once you find that your device is supported, you can pick one of the many versions available. The release cycle is very different from Google's. One of the most </span><span class="emphasis"><em><span>adventurous</span></em></span><span> features of the whole Cyanogenmod world is the </span><span class="strong"><strong><span>nightly build</span></strong></span><span>—every night, an automatic system starts a new build with the latest contribution to the source code repository. These are tricky versions, which must be considered unstable, but will contain all the new things that the development team adds to the system daily—</span><span class="emphasis"><em><span>only for the brave!</span></em></span></p>

  <p><span>In addition to the different release cycle, Cyanogenmod also uses a different version naming convention. The team uses tags to specify the different versions of the ROM:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Nightly</span></strong></span><span>: As Already explained.</span></li>

    <li><span class="strong"><strong><span>Experimental</span></strong></span><span>: This is the version currently under testing.</span></li>

    <li><span class="strong"><strong><span>M Snapshot, or Milestone Snapshot</span></strong></span><span>: This is more stable than a nightly, but still to be considered unstable.</span></li>

    <li><span class="strong"><strong><span>Release Candidate</span></strong></span><span>: This is the final step before reaching the </span><span class="emphasis"><em><span>stable</span></em></span><span> state. This is the first release that it would be </span><span class="emphasis"><em><span>wise</span></em></span><span> to use on a daily basis on your device.</span></li>

    <li><span class="strong"><strong><span>Stable</span></strong></span><span>: This is the final state, targeting all users.</span></li>
  </ul>

  <h3 class="Title-2 sigil_not_in_toc"><span>The Android Open Kang Project</span></h3>

  <p><span>Android Open Kang Project, also known as AOKP, is an open source project born in 2011 with the goal of providing an alternative to official Google Android for smartphones and tablets:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_90.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_90" style="max-width:831px;max-height:290px"/></div>

  <p><span>As you can imagine, the Kang team didn't create the system from scratch. They used the Android Open Source Project by Google as a starting point, as Cyanogenmod did. This particular Android version targets high-end smartphones and tablets and improves a few aspects to make the system more efficient and customizable. These are some of its main pros, which are the reason why more and more users decide to switch to AOKP.</span></p>

  <p><span>One of the aspects that users love is that the AOKP team focused on making the system as light as possible. They stripped away every unnecessary app and basically left just the official Google apps, to create the smallest possible system.</span></p>

  <p><span>Most of the smartphones and tablets nowadays contain lots and lots of </span><span class="emphasis"><em><span>esthetical</span></em></span></p></div>
<div><p><span class="emphasis"/><span> features that could slow down the system and are heavy on the eye. These types of apps are called </span><span class="strong"><strong><span>bloatware</span></strong></span><span> and are usually pre-installed system apps that are impossible to remove from the system. AOKP made getting rid of these useless apps one of its main goals.</span></p>

  <p><span>The Kang team works very hard to guarantee the maximum level of customization for the user's system. AOKP provides a </span><span class="strong"><strong><span>ROM Control</span></strong></span><span> menu to customize lots of aspects of the system, from UI customization to behavior customizations. A large amount of energy has been spent in the gesture management domain, and one of the coolest features is the possibility to launch any desired app with a finger gesture instead of tapping on an icon.</span></p>

  <p><span>As with Cyanogenmod, AOKP also provides plenty of documentation and downloads on their website at </span><a class="ulink" href="http://aokp.co"><span>http://aokp.co</span></a><span>. Again, you can check out the source code and build it yourself, or try out an already built version.</span></p>

  <p><span>Here is a quick list of the goodies you can find in AOKP:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Vibration Pattern</span></strong></span><span>: Every contact can be associated to a particular vibration pattern</span></li>

    <li><span class="strong"><strong><span>Navigation Ring</span></strong></span><span>: The Android lock screen can be customized with user-chosen apps to quickly access them even with a locked device</span></li>

    <li><span class="strong"><strong><span>LED Control</span></strong></span><span>: The system LED behavior can be customized in terms of color, blinking, and duration to create custom notifications for your custom scenarios</span></li>

    <li><span class="strong"><strong><span>Custom Toggles</span></strong></span><span>: The notification area can be customized with different toggle buttons to create the perfect setup that fits your needs</span></li>
  </ul>

  <p><span>The following image shows two screenshots from the actual system:</span></p>

  <ul>
    <li><span>The first one shows how to customize the </span><span class="strong"><strong><span>Navigation Ring</span></strong></span></li>

    <li><span>The second one shows how to customize the </span><span class="strong"><strong><span>Vibration</span></strong></span><span> pattern



      </span><div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_91.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_91" style="max-width:900px;max-height:748px"/></div>
    </li>
  </ul>

  <h4 class="Title-3 sigil_not_in_toc"><span>Installing AOKP</span></h4>

  <p><span>AOKP versioning is different from Google's and Cyanogenmod's. AOKP provides only too versions:</span></p>

  <ul>
    <li><span>Nightlies</span></li>

    <li><span>Milestones</span></li>
  </ul>

  <p><span>Nightlies are the equivalent of Cyanogenmod's nightly build. Indeed, this is just a build automatically generated every night by the AOKP build system. This is to be considered highly unstable and only to be installed for testing purposes.</span></p>

  <p><span>By contrast, Milestones are stable builds, meant to be installed for stable daily usage.</span></p>

  <p><span>To keep the community engaged, the Kang team created </span><span class="strong"><strong><span>AOKP PUSH</span></strong></span><span>, an app that keeps the phone updated with new builds and also includes the ability to install a system update, when available. As a final note, like Cyanogenmod, AOKP is completely free and open to your contributions.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Minor ROMs</span></h3>

  <p><span>In the previous sections, we saw an overview of the two most popular custom ROMs available nowadays for Android smartphones and tablets. As you can imagine, this is just the tip of the iceberg—over the years, dozens of different custom ROMs have been developed and released. Lots of them target specific scenarios to solve specific issues or satisfy specific needs of their users, improving the Android system in their own way. Most of them are not built from scratch, but are based on already available systems that have been customized and redistributed.</span></p>

  <p><span>Most of the available custom ROMs target a specific device, to solve device-specific issues and improve usability and performance. </span><span class="strong"><strong><span>DroniX</span></strong></span><span> (project created by the authors of this very book, targeted a specific device, the Huawei Ideos U8150, a low-end device that became very popular at the time. The development team focused on performance and squeezed every available Megahertz from the Ideos CPU. With the Kernel source code available, we were able to improve CPU frequencies and governors. Better power management meant better battery management, with better performance and increased battery life.</span></p>

  <p><span>As always, be careful when you try out custom ROMs. Some of them could be very </span><span class="emphasis"><em><span>extreme</span></em></span><span> and could be dangerous for your devices. This is unfortunate, but it's a real scenario. There is no magic for </span><span class="emphasis"><em><span>cooking</span></em></span><span> a custom ROM, and there are a lot of things that can go wrong. Things like extreme overclocking, for instance, are dangerous, and a wise user should distrust ROMs that try to sell these kinds of features. Experimenting with Android can be fun, satisfying, and challenging, but it must be done with knowledge and wisdom.</span></p>

  <p><span>We can't list here every custom ROM available in the wild. What we can do is to point you in the right direction: </span><a class="ulink" href="http://www.xda-developers.com/"><span>http://www.xda-developers.com/</span></a><span>. This is probably the most famous forum to get the latest news and the latest crazy things.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Overview of OEM customizations</span></h3>

  <p><span>Even if they are not commonly considered custom ROMs, all the Android variants distributed by manufacturers can be considered to have heavy customizations. We witness these every day—every time you look at a Samsung device, you know that it's not pure Android.</span></p>

  <p><span>From the system launcher to the Settings menu, every single component of these systems is heavily customized by the OEM and very far from the official Google version. In some cases, the system is so different that the average user doesn't know that he is using the same Android 5 system, for instance.</span></p>

  <p><span>This is a list of the most popular OEM customizations to demonstrate how a system can be modified and how different the same Android version can look on devices by different manufactures.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Samsung – TouchWiz</span></h4>

  <p><span>TouchWiz is a graphical interface, optimized for touch interfaces. It has been developed by Samsung and its technical partners. Often, it's incorrectly defined as a "custom operating system", but technically speaking, it's just a heavy customization of the Android UI.</span></p>

  <p><span>The first version of TouchWiz was released in 2010, for Android 2.1 and BADA, an operating system created by Samsung for its smartphones and tablets. The current version is TouchWiz 5 and we can find lots of improvements, added over the years. In the beginning, TouchWiz was just a </span><span class="emphasis"><em><span>different UI</span></em></span><span>. Today, it's a collection of custom system applications, customized UI widgets, and lots of new settings and features, such as sound profiles, power management, toggles, and so on. The following screenshot shows the home screen and the applications drawer:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_92.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_92" style="max-width:831px;max-height:496px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Huawei EMUI</span></h4>

  <p><span>Under the influence of Samsung's work, Huawei also provides its own version of Android UI for its devices. As with Samsung, they started with a customized UI and added lots of features, such as theme customization—icons, colors, fonts, and lock screen. The notification area has been customized and improved, too.</span></p>

  <p><span>One of the most useful new features is definitely the advanced power management. It provides three possible setups: Ultra, Smart, and Normal. Ultra is the </span><span class="emphasis"><em><span>extreme</span></em></span><span> setup—one click, and you can turn off every sensor but the bare minimum ones, aiming to achieve the longest possible battery life. Smart tries to automatically manage the power usage as much as possible. Normal is all about performance—the battery won't last long, but the device will work at full speed.</span></p>

  <p><span>The following image shows the Hawei EMUI home screen:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_93.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_93" style="max-width:831px;max-height:495px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>HTC Sense</span></h4>

  <p><span>In 2009, HTC release the first version of its customized UI for smartphones. It targeted Android and Windows Mobile with a shared graphical user experience to not confuse users.</span></p>

  <p><span>The most popular feature in HTC is the big collection of home widgets, but there are other features that are just as interesting, such as a tracking system for use if the device is stolen. This system allows the user to make remote operations on the device to locate it or wipe the memory, or simply lock it. It's even possible to show a custom message on the lock screen, with an address or a reward to reobtain the device.</span></p>

  <p><span>The following screenshot shows the home screen of HTC Sense 7:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_94.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_94" style="max-width:831px;max-height:491px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>LG Optimus UI</span></h4>

  <p><span>LG, like others, provides a customized UI—user-picked images for the system icons, colors, and a few custom settings. An interesting feature is the </span><span class="strong"><strong><span>vocal command</span></strong></span><span> to take a picture and the ability to pick the best picture from a burst of photo photos.</span></p>

  <p><span>The following image shows the home screen and the customized notification area:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_95.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_95" style="max-width:831px;max-height:483px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Xiaomi MIUI</span></h4>

  <p><span>This is definitely the heaviest customized system and it has one specific feature that none of the previous ones have—it's open source! Xiaomi began to work on MIUI with Android 2.3.7 and Cyanogenmod 7—those two were the core of the system. Over the years, they created a custom ROM that is way more than just a customized UI, adding more and more features.</span></p>

  <p><span>In 2011, Xiaomi jumped into the market, switching from system customizer to device manufacturer, with high-end, low-cost devices, equipped with its MIUI system.</span></p>

  <p><span>The following image shows the MIUI home screen and app store:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_94.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_94" style="max-width:831px;max-height:491px"/></div>

  <p><span>Unfortunately, this is a popular trend—an easy method for branding and to assure customer loyalty, but it's not always the recommended way to go.</span></p>

  <p><span>There are other manufacturers that prefer to ship their devices with a vanilla Android—Motorola, for instance. Motorola's branding approach is to add just a couple of </span><span class="emphasis"><em><span>by Motorola</span></em></span><span> apps. These are usually utility apps, aiming to enrich the user experience while keeping the system clean.</span></p>

  <p><span>Motorola's strategy also has one big pro—a system very close to Google's original one means faster updates. Every time Google releases a new Android version, Motorola devices receive system updates as well in a few days. This is very unusual for most of the other manufacturers, somehow doomed to stay on old Android versions due to the huge amount of work necessary to update such a heavily customized system.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>An overview of Android recovery</span></h2>

  <p><span>One of the most important parts of the whole Android architecture is the </span><code class="literal"><span>Recovery</span></code><span> partition. A recovery partition is very common in embedded systems, and we saw an overview of it in previous chapters. As we know, the so-called </span><code class="literal"><span>Recovery</span></code><span> is a minimal runtime system, completely decoupled from the main Android system and totally self-sufficient. Its main goal is to guarantee system integrity and provide the necessary tools to fix common minor issues and restore a properly working system.</span></p>

  <p><span>With an Android vanilla </span><code class="literal"><span>Recovery</span></code><span>, we can:</span></p>

  <ul>
    <li><span>Update the Android system</span></li>

    <li><span>Wipe the data partition and the cache partition</span></li>
  </ul>

  <p><span>Wiping the data and cache partition is a common practice if we want to restore our device to the factory defaults, for instance, in order to have a clean system to start experimenting on something specific, or if we just want to sell it.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Diving into Android recovery</span></h3>

  <p><span>The Android </span><code class="literal"><span>Recovery</span></code><span> system is completely standalone. This means that whatever might happen to the main Android system, </span><code class="literal"><span>recovery</span></code><span> will be always able to restore a working system.</span></p>

  <p><span>To achieve this level of resilience, </span><code class="literal"><span>recovery</span></code><span> contains its own Linux kernel and its own </span><code class="literal"><span>rootfs</span></code><span>. The following screenshot shows how </span><code class="literal"><span>recovery</span></code><span> actually lives near the Android system, but is completely separate:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_97.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_97" style="max-width:475px;max-height:183px"/></div>

  <p><span>The previous screenshot shows how access to the </span><code class="literal"><span>recovery</span></code><span> is bound to the </span><code class="literal"><span>BootLoader</span></code><span>. The </span><code class="literal"><span>BootLoader</span></code><span> is unable to decide if the current boot sequence is going to end with a running </span><code class="literal"><span>recovery</span></code><span> or a running Android system.</span></p>

  <p><span>Recovery mode can be accessed with a button combination when the device is turned off. For our reference device, Google Nexus 6, you can take the following steps:</span></p>

  <ol>
    <li><span>Press and hold </span><span class="emphasis"><em><span>Volume Down</span></em></span><span>, </span><span class="emphasis"><em><span>Volume Up</span></em></span><span> and </span><span class="emphasis"><em><span>Power buttons</span></em></span><span> simultaneously.</span></li>

    <li><span>Release all buttons when the </span><code class="literal"><span>Fastboot Mode</span></code><span> menu appears.</span></li>

    <li><span>Use the </span><span class="emphasis"><em><span>Volume</span></em></span><span> buttons until the upper part of the screen displays the </span><code class="literal"><span>Recovery Mode</span></code><span> text.</span></li>

    <li><span>Press </span><span class="emphasis"><em><span>Power</span></em></span><span> to select </span><code class="literal"><span>Recovery Mode</span></code><span>—after that you will see an Android icon laid on its back.</span></li>

    <li><span>Press and hold the </span><span class="emphasis"><em><span>Power</span></em></span><span> button, then press the </span><span class="emphasis"><em><span>Volume Up</span></em></span><span> button once.</span></li>
  </ol>

  <p><span>Once you have landed on the recovery main screen, you can navigate using the </span><span class="emphasis"><em><span>Volume</span></em></span><span> buttons and confirm your choice using the </span><span class="emphasis"><em><span>Power</span></em></span><span> button.</span></p>

  <p><span>The options you will find in the recovery menu could vary, but an Android vanilla </span><code class="literal"><span>recovery</span></code><span> will definitely provide these options:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Reboot system now</span></strong></span><span>: This option will restart the system.</span></li>

    <li><span class="strong"><strong><span>Apply update from ADB</span></strong></span><span>: Android Debug Bridge can be used from a host computer to upload an official Google system update. Only certified updates can be uploaded and applied this way due to security measures enforced by the recovery to guarantee system integrity.</span></li>

    <li><span class="strong"><strong><span>Wipe cache partition</span></strong></span><span>: This option will erase the </span><span class="emphasis"><em><span>cache</span></em></span><span> partition. This partition usually contains the system's temporary data and app cache data. Deleting this file will free quite an amount of disk space, without losing user data or apps.</span></li>

    <li><span class="strong"><strong><span>Wipe data/factory reset</span></strong></span><span>: This option will erase the volatile memory and restore the original factory system. Everything that is not strictly system-related will be deleted: videos, music, documents, user apps, and so on. The cache partition will be erased as well.</span></li>
  </ul>

  <p><span>The following screenshot show a stock Android </span><code class="literal"><span>recovery</span></code><span>:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_98.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_98" style="max-width:827px;max-height:440px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Installing an alternative recovery</span></h3>

  <p><span>As with the whole Android system, even the </span><code class="literal"><span>recovery</span></code><span> source code is available for study and modifications and, over the years, the Android community has developed alternatives that can be used in place of the Android stock </span><code class="literal"><span>recovery</span></code><span>.</span></p>

  <p><span>All these alternatives aim to improve and add more features to the stock recovery. The most common features are:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Ability to save and restore system backups</span></strong></span><span>: NANDroid is extremely useful for experimenting with custom systems and adventurous configurations</span></li>

    <li><span class="strong"><strong><span>Ability to install custom ROMs</span></strong></span><span>: Probably the most important among the added features, from a custom ROM developer's point of view</span></li>

    <li><span class="strong"><strong><span>Enhanced UI and UXD</span></strong></span><span>: Some of these custom recoveries provide support for the touchscreen, instead of the default </span><span class="emphasis"><em><span>Volume</span></em></span><span>/</span><span class="emphasis"><em><span>Power</span></em></span><span> button navigation</span></li>
  </ul>

  <p><span>The most popular </span><code class="literal"><span>recovery</span></code><span> alternatives are:</span></p>

  <ul>
    <li><span>Clockworkmod</span></li>

    <li><span>4EXT</span></li>

    <li><span>Amon Ra Recovery</span></li>

    <li><span>Team Win Recovery Project (TWRP)</span></li>
  </ul>

  <p><span>Every one of them is different in some way—look and feel, advanced features, and so on, but all of them provide a clear way to allow the advanced user to install custom ROMs.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Clockworkmod</span></h4>

  <p><span>This is definitely one of the most popular custom recoveries in the game. It's often called </span><code class="literal"><span>CWM</span></code><span>, and has been developed by Koushik </span><span class="emphasis"><em><span>"Koush"</span></em></span><span> Dutta. He started with the ancient Android 2.1 recovery source code and, since then, he has kept on adding features.</span></p>

  <p><span>One of the main features is the NANDroid backup, which allows the user to safely save and restore the whole system structure. Another interesting feature is the ability to connect to the recovery shell from a computer, via ADB. A critically important feature is the ability to update the system using unofficial update packages. Unlike the stock recovery, Clockworkmod ignores all signature certificates, knowing that only an advanced user would try to flash a custom-made update package.</span></p>

  <p><span>Clockworkmod recovery can be easily installed using the specific app distributed via Google Play Store, or manually, as we will see.</span></p>

  <p><span>To install it manually on your trusted Nexus device, you can use </span><code class="literal"><span>fastboot</span></code><span>. Follow these steps to install Clockworkmod recovery:</span></p>

  <ol>
    <li><span>First thing to do—download it. The Clockworkmod website has a complete list of supported devices and specific download files: </span><a class="ulink" href="https://www.clockworkmod.com/rommanager"><span>https://www.clockworkmod.com/rommanager</span></a><span>.</span></li>

    <li><span>Once you have the file, decompress it and you will have a </span><code class="literal"><span>.img</span></code><span> file.</span></li>

    <li><span>Now, put your device in </span><code class="literal"><span>fastboot</span></code><span> mode, as we saw in previous chapters, fire up a terminal, and use the following command to flash the </span><code class="literal"><span>.img</span></code><span> file to the recovery partition:

      </span><pre><span class="strong"><strong>$~: sudo fastboot flash recovery recovery.img</strong></span>
</pre>
    </li>

    <li><span>Once the brand new recovery has been installed, you can reboot the device straight to recovery mode with the following command:

      </span><pre><span class="strong"><strong>$~: sudo fastboot reboot recovery</strong></span>
</pre>
    </li>
  </ol>

  <p><span>From this moment on, we can install custom ROMs or perform a total system backup.</span></p>

  <p><span>It's also possible to recompile the Clockworkmod source code from scratch, since the project is open source. You can also find a custom recovery source code in the custom Cyanogenmod ROM that we have discussed in previous paragraphs. Building Cyanogenmod from the source code follows the same steps you already followed to build official Android: the build system and the build setup are the same. Applying the same know-how as for vanilla Android, you can easily create a Cyanogenmod system image and a Clockworkmod custom recovery.</span></p>

  <p><span>Here's a screenshot of the Clockworkmod UI:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_99.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_99" style="max-width:382px;max-height:631px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>TWRP – Team Win Recovery Project</span></h4>

  <p><span>One alternative to the famous Clockworkmod recovery is TWRP, which stands for Team Win Recovery Project. One of the most important features of this recovery mod is support for touchscreens.</span></p>

  <p><span>In this way, you can interact with the recovery mod directly using the screen, like you normally do using Android, which is very convenient, especially if we compare it to the volume keys used in all the other recovery mods. The graphical interface is pretty usable, with big buttons that show all the various options (they are very similar to the ones in the Clockwork mod). Using TWRP, you can install unofficial ROMs and also perform a complete system backup.</span></p>

  <p><span>The project was born on 30th July 2011 and is an open source project— also, here you can either download a binary for your device or recompile from source code.</span></p>

  <p><span>You can find more information on the official website at </span><a class="ulink" href="http://teamw.in/"><span>http://teamw.in/</span></a><span>.</span></p>

  <p><span>Here are some screenshots of TWRP:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_100.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_100" style="max-width:830px;max-height:457px"/></div>

  <h4 class="Title-3 sigil_not_in_toc"><span>Connecting to the recovery shell using ADB</span></h4>

  <p><span>Custom recovery can be operated using their standard UI, as we saw, and using an ADB connection. This feature is not available in the stock recovery and will be very useful during our experiments.</span></p>

  <p><span>Once the custom recovery is installed, fire up a terminal and run the following command:</span></p>
  <pre><span class="strong"><strong>~$: adb devices</strong></span>
</pre>

  <p><span>ADB will list all the available devices, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_101.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_101" style="max-width:831px;max-height:153px"/></div>

  <p><span>Knowing that there is just a single device, we can simply use the following command to connect to the recovery shell:</span></p>
  <pre><span class="strong"><strong>~$: adb shell</strong></span>
</pre>

  <p><span>You will be prompted with a </span><code class="literal"><span>#</span></code><span> symbol, which lets you know that you have administrator powers as a </span><span class="emphasis"><em><span>root</span></em></span><span> user. Being a </span><span class="emphasis"><em><span>root</span></em></span><span> user gives you the opportunity to do advanced tasks, such as mount the </span><code class="literal"><span>system/</span></code><span> in </span><span class="emphasis"><em><span>read/write mode</span></em></span><span> and add or remove any file you want, without starting the whole Android system.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Device permissions</span></h2>

  <p><span>As we have seen in previous chapters, Android is based on Linux, so it also inherits the part that concerns user permissions. As with a standard Linux system, Android also manages everything through groups and users. In the default configuration, it's not possible to obtain administrator (root) access, in order to prevent tampering with the system. Also, with access to the whole operating system, it's easy to corrupt the system itself, accidentally or deliberately (for example, to steal user data using a virus).</span></p>

  <p><span>Every Android app, when installed on the system, generates a new user and group, and inter-app communications are performed according to Android SDK constraints and protocols. Sometimes, though, it's useful to have complete control over the device, like, for example, when installing apps that manage CPU frequency and the CPU governor.</span></p>

  <p><span>Now let's see how to obtain root access and what the implications of rooting the device are.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Root access</span></h3>

  <p><span>Root access enables the users of smartphones, tablets, and other devices with Android OS installed to obtain privileged access, also called root access, to the whole Android operating system. As we have already mentioned, Android uses a Linux kernel, so obtaining root access is very similar to obtaining administrator (superuser) access to a regular Linux or Unix-like OS, such as FreeBSD or Mac OS X.</span></p>

  <p><span>Often, the reason for obtaining root access is to overcome the limits imposed on the device by the hardware producers. As a root user, you have the ability to modify or replace system apps and change the settings. Also, you can use the apps that require root permissions themselves, enabling you to execute operations that would otherwise be inaccessible to normal Android users. Rooting the device, that is, obtaining root access, can also help if you want to totally remove the device OS and replace it with another, maybe more recent, one.</span></p>

  <p><span>In the following paragraphs, we will see how to obtain root access, which is the key precondition for installing the custom ROM.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>SuperSu</span></h4>

  <p><span>To use root permissions in Android apps, an independent developer known as Chainfir Jorrit Jongma has developed a library that enables you to use them from your app and therefore execute root-level operations. Everything is open source and you can explore the documentation regarding the API at the official website of the developer: </span><a class="ulink" href="https://su.chainfire.eu"><span>https://su.chainfire.eu</span></a><span>.</span></p>

  <p><span>If you would like to check out the library source code, you can find it (and contribute) here: </span><a class="ulink" href="https://github.com/Chainfire/libsuperuser"><span>https://github.com/Chainfire/libsuperuser</span></a><span>.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Obtaining root access</span></h4>

  <p><span>Now it's time to see how to obtain root permissions on our device in practice. Unfortunately, it's not that simple, and there are various ways to obtain root permissions on a device. Every device has its quirks, and hence a different procedure to execute in order to obtain root permissions. Generally, we can say that if there's a possibility of installing a recovery mod, then there's also a possibility of installing everything necessary to become root. We just need to copy the right files to the system partition that is mounted as read-only by default, so we can access it either by making an ad hoc system partition using the source files, or—in cases when we don't have the Android source code—by mounting the partition in read/write mode through one of the custom recovery mods we described previously.</span></p>

  <p><span>Up till now, we haven't talked about the legal issues regarding modifying the software present on the device. In general, it is not illegal to install custom ROMs onto our devices, except that there's the possibility of invalidating the device warranty. As far as the Nexus devices are concerned, there's no problem whatsoever; they are being sold for the purposes of software development, so the product warranty isn't tied to the software but to the hardware instead.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Chef toolkit</span></h2>

  <p><span>One of the main goals of this book is to help you realize your own version of a ROM customization. In the dictionary of modders, the act of modifying a version of Android in order to produce one's own ROM customization is often referred to with the verb </span><span class="emphasis"><em><span>to cook</span></em></span><span> and the word </span><span class="emphasis"><em><span>kitchen</span></em></span><span>.</span></p>

  <p><span>"Cooking one's own ROM" means to modify the stock version of Android installed on one's device, with the aim of creating a new one.</span></p>

  <p><span>For this reason, all the tools that might help to make the development of a ROM customization easier are called </span><span class="strong"><strong><span>Chef toolkit</span></strong></span><span>.</span></p>

  <p><span>As discussed in the previous chapters, it is indeed possible to create one's own ROM version starting from the source code, but this is not always possible, as some device manufacturers do not release their source code. In all those cases, we need to act on the system partitions, often directly on the binaries that build the internal core, both on the application framework and on the filesystem utilities.</span></p>

  <p><span>In the next paragraphs, we will learn how to cook a ROM starting from binary images, beginning from the environment and analyzing the development tools that will help us carry out our first ROM customization.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Preparing the environment</span></h3>

  <p><span>Before we can start developing the ROM, we most certainly need to prepare an adequate environment on our computer. Android can be used with basically all the most recent operating systems, from Windows, to Linux, to OS X.</span></p>

  <p><span>We always refer to Ubuntu, as we did in the previous chapters when we dealt with compiling Android from the source code. Therefore, all you need to start is a computer with a recent version of Ubuntu installed on it. Besides that, we suggest to also install a good text editor for developers—it could either be VIM from the command line, or graphic editors such as ATOM, SublimeText, and so on. We will mostly work from the console, using different scripts and tools in order to finalize our first custom ROM.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Android kitchen</span></h3>

  <p><span>One of the </span><span class="emphasis"><em><span>chef's</span></em></span><span> most important tools is undoubtedly the </span><code class="literal"><span>Kitchen</span></code><span>. Although we are stealing our analogies from the world of cooking, we are actually focusing on the preparation of our first Android customization—the first step is obtaining the system binary images.</span></p>

  <p><span>We refer to as the </span><code class="literal"><span>Android Kitchen</span></code><span> the set of tools that are usually used, such as the scripts to be used in a shell, and which help the developer perform automated tasks, such as decompressing and editing the system images that build a ROM, decompiling APK packets, sometimes adding the root privileges to the ROM, and so on.</span></p>

  <p><span>Of course, many different kitchens exist online, each one with its own peculiarities. We will study some of them and we will try to perform simple actions in order to get our first custom ROM ready to be flashed onto our device.</span></p>

  <p><span>One of the most popular </span><code class="literal"><span>Android Kitchens</span></code><span> is </span><span class="strong"><strong><span>dsixda</span></strong></span><span>. The project is formally "retired," but it has been forked by lots of users and the development is still ongoing. It's open source and you can download it or fork it and contribute to the project starting from </span><a class="ulink" href="https://github.com/dsixda/Android-Kitchen"><span>https://github.com/dsixda/Android-Kitchen</span></a><span>.</span></p>

  <p><span>The dsixda </span><code class="literal"><span>kitchen</span></code><span> is based on a suite of </span><code class="literal"><span>Bash</span></code><span> scripts and tools to provide an easy method to perform the most common </span><span class="emphasis"><em><span>cooking</span></em></span><span> operations:</span></p>

  <ul>
    <li><span>Add Busybox</span></li>

    <li><span>Add root permissions</span></li>

    <li><span>Customize the boot screen</span></li>
  </ul>

  <p><span>These are just few of the possible operations available in its console menu. This kitchen is compatible with Windows, Linux, and OS X. We are going to use it with our trusted Ubuntu. Once you have downloaded the kitchen (</span><a class="ulink" href="https://github.com/dsixda/Android-Kitchen/archive/0.224.zip"><span>https://github.com/dsixda/Android-Kitchen/archive/0.224.zip</span></a><span>), uncompress it into a folder, enter the folder, and run the following:</span></p>
  <pre><span class="strong"><strong>$: ./menu</strong></span>
</pre>

  <p><span>This command will fire up the main menu, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_102.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_102" style="max-width:644px;max-height:512px"/></div>

  <p><span>The dsixda kitchen manipulates two specific partitions—system and boot-respectively compressed in </span><code class="literal"><span>system.img</span></code><span> and </span><code class="literal"><span>boot.img</span></code><span> files. In the following sections, we will dig into extracting these partitions and customizing them.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Other developers' tools</span></h3>

  <p><span>Many other different tools could come in handy for the developer, of course strictly depending on one's specific needs. A </span><span class="strong"><strong><span>hexadecimal editor</span></strong></span><span> would certainly be very useful for the analysis of binary images, while simple graphics editing software would help when it comes to modifying icons or other graphical aspects of the ROM, as well as for preparing the whole environment for compiling the Linux kernel, and possibly Android applications to add to the ROM.</span></p>

  <p><span>We usually prepare the environment as if we had to compile Android from the source together with the Linux kernel, so that we definitely have all the necessary tools to build our custom ROM.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Manipulating DEX files with APKTool</span></h4>

  <p><span>Working with an Android system, it's quite common to need to manipulate DEX files. DEX stands for </span><span class="strong"><strong><span>Dalvik Executable</span></strong></span><span> and these files are used by Android Virtual Machine. To easily manipulate these files, you can use APKTool by Ryszard Wiśniewski and Connor Tumbleson. The tools are open source and you can download them at </span><a class="ulink" href="http://ibotpeaches.github.io/Apktool/"><span>http://ibotpeaches.github.io/Apktool/</span></a><span>.</span></p>

  <p><span>APKTool is written in Java, so you need a JVM to use it. Once you have the APKTool </span><code class="literal"><span>jar</span></code><span> file in place, fire up a terminal and run the following:</span></p>
  <pre><span class="strong"><strong>$: java –jar apktool_2.0.3.jar</strong></span>
</pre>

  <p><span>Replace the version with yours, if necessary. The following screenshot shows the initial help menu of the tool:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_103.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_103" style="max-width:564px;max-height:449px"/></div>

  <p><span>APKTool is based on two other tools—</span><code class="literal"><span>smali</span></code><span> and </span><code class="literal"><span>baksmali</span></code><span>, to assemble and disassemble the files. It requires an initial setup to work properly: </span><code class="literal"><span>framework-res.apk</span></code><span> position. You must specify where APKTool must look to obtain this file. </span><code class="literal"><span>framework-res.apk</span></code><span> is part of the Android system and can be extracted from a running Android device, using our trusted ADB:</span></p>
  <pre><span class="strong"><strong>~$ adb pull /system/framework/framework-res.apk .</strong></span>
</pre>

  <p><span>The previous command will copy the APK from the Android device into the current folder. Once we have the file in place, we can tell APKTool where to find it:</span></p>
  <pre><span class="strong"><strong>~$ apktool if {path to framework-res.apk}</strong></span>
</pre>

  <p><span>Now that everything is configured, we can try to decompile and customize an APK, using the following command:</span></p>
  <pre><span class="strong"><strong>~$ apktool d myapk.apk path_destination_decompilation</strong></span>
</pre>

  <p><span>The APK content will be placed in the destination folder we specified and we can edit any file we want. After all our modifications, we can </span><span class="emphasis"><em><span>recompress</span></em></span><span> the folder into an APK file with the following command:</span></p>
  <pre><span class="strong"><strong>~$ apktool b path_decompiled_files new_apk_mod.apk</strong></span>
</pre>

  <p><span>Once the new APK is ready, we can copy it to the device with a file transfer app or using </span><code class="literal"><span>ADB push</span></code><span>, as we saw in the previous chapters.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Cooking our first ROM</span></h2>

  <p><span>So far, we have seen an overview of the suite of tools we need to create a custom ROM from a binary system image. The most important of all is the </span><code class="literal"><span>kitchen</span></code><span>, and it needs </span><code class="literal"><span>system.img</span></code><span> and </span><code class="literal"><span>boot.img</span></code><span> partition files to properly do its job.</span></p>

  <p><span>If you are targeting Google devices, this is an easy game. Google provides system source code for its devices, so we can always build our </span><code class="literal"><span>.img</span></code><span> files from the source, as we learned in previous chapters. We can also grab the </span><code class="literal"><span>.img</span></code><span> files from the official system installation packages that Google also provides for its devices at every new release of the Android system.</span></p>

  <p><span>If you are targeting a device that's not a Nexus, things become more adventurous. Most of the time you don't have the system source code; often you don't even have the downloadable system images. As you will see in the next sections, there is always a way to obtain every last piece of the puzzle to create our custom ROM.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Gathering the ingredients</span></h3>

  <p><span>The list is quite short. All you need is:</span></p>

  <ul>
    <li><span>Kernel source code, if you want to customize the system at core level</span></li>

    <li><code class="literal"><span>system.img</span></code></li>

    <li><code class="literal"><span>boot.img</span></code></li>
  </ul>

  <p><span>The two </span><code class="literal"><span>.img</span></code><span> files may be provided by the manufacturer, like Google does, or can be manually dumped from a running device system memory. The first scenario is the </span><span class="emphasis"><em><span>lucky</span></em></span><span> one; the second one is more advanced and requires a bit of creativity. This is the scenario we are going to explore in greater depth, because, if you are lucky enough to have the manufactured system restore file, you simply need to decompress it into a folder and you will get the </span><code class="literal"><span>.img</span></code><span> files you are looking for.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Dumping system partitions</span></h4>

  <p><span>To create a dump of the system memory, you will need to access the system with root privileges. As we already know, there are a few ways to gain root privileges—device-specific rooting, installing a custom recovery, and so on. Pick the technique you prefer.</span></p>

  <p><span>Once you have root privileges, fire up a terminal and connect to your device shell with the following command:</span></p>
  <pre><span class="strong"><strong>~$: adb shell</strong></span>
</pre>

  <p><span>The system will welcome us with a </span><code class="literal"><span>#</span></code><span> symbol. We can now proceed with dumping the partitions. To get an overview of the partitions structure, you can use the following command:</span></p>
  <pre><span class="strong"><strong>~ # cat /proc/partitions</strong></span>
</pre>

  <p><span>The following screenshot shows the output for a standard Google Nexus 6 device:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_104.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_104" style="max-width:642px;max-height:773px"/></div>

  <p><span>The number of partitions is almost overwhelming, but we need to focus just on the system partition and the boot partition. We know that the partitions we are interested in are there, among all those listed partitions. Now, we have to figure out which of those partitions is actually </span><code class="literal"><span>system/</span></code><span> and which is </span><code class="literal"><span>boot/</span></code><span>.</span></p>

  <p><span>The relationship between a physical partition and its role in the Android architecture is shown with the following command:</span></p>
  <pre><span class="strong"><strong>~ # ls /dev/block/platform/msm_sdcc.1/by-name</strong></span>
</pre>

  <p><span>The previous command will show something like this:</span></p>
  <pre><span class="strong"><strong>~ # . . .</strong></span>
<span class="strong"><strong>~ # … recovery -&gt; /dev/block/mmcblk0p35</strong></span>
<span class="strong"><strong>~ # … system   -&gt; /dev/block/mmcblk0p41</strong></span>
<span class="strong"><strong>~ # … boot     -&gt; /dev/block/mmcblk0p37</strong></span>
<span class="strong"><strong>~ # … userdata -&gt; /dev/block/mmcblk0p42</strong></span>
<span class="strong"><strong>~ # . . .</strong></span>
</pre>

  <p><span>As you can see, it shows every relevant partition and its role. We can easily figure out that the physical </span><code class="literal"><span>mccblk0p41</span></code><span> will become our </span><code class="literal"><span>system.img</span></code><span> and </span><code class="literal"><span>mmcblk0p37</span></code><span> will become our </span><code class="literal"><span>boot.img</span></code><span> file.</span></p>

  <p><span>We will take advantage of the </span><code class="literal"><span>/sdcard</span></code><span> partition to store the dumps, and we will create the dumps using the utility </span><code class="literal"><span>dd</span></code><span>:</span></p>
  <pre><span class="strong"><strong>~ # dd if=/dev/block/mmcblk0p41 of=/sdcard/system.img</strong></span>
</pre>

  <p><span>With the previous command, you are copying the whole system partition into a single file on the SD card. This process can take a while—be patient. Once you have the </span><code class="literal"><span>system.img</span></code><span> file, you can move on to creating the </span><code class="literal"><span>boot.img</span></code><span> file, with the following command:</span></p>
  <pre><span class="strong"><strong>~ # dd if=/dev/block/mmcblk0p37 of=/sdcard/boot.img</strong></span>
</pre>

  <p><span>You now have the two most important files to create a custom ROM. Let's start customizing them.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Modifying an Android system binary image</span></h3>

  <p><span>Follow these steps to modify an Android system binary image:</span></p>

  <ol>
    <li><span>Let's start with </span><code class="literal"><span>system.img</span></code><span>. First of all, you need to bring it on to your host computer:

      </span><pre><span class="strong"><strong>~$ adb pull /sdcard/system.img .</strong></span>
</pre>
    </li>

    <li><span>Then, you need to create a mount point to mount the image into it:

      </span><pre><span class="strong"><strong>~$ mkdir system_mount_point</strong></span>
</pre>
    </li>

    <li><span>Now you can mount it as a common image file:

      </span><pre><span class="strong"><strong>~$ mount –o loop system.img system_mount_point</strong></span>
</pre>
    </li>
  </ol>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>On old devices, the filesystem used for </span><code class="literal"><span>system.img</span></code><span> was </span><code class="literal"><span>yaffs</span></code><span>. Over the years, the Android system migrated to an </span><code class="literal"><span>ext4</span></code><span> filesystem, also very common on lots of Linux systems. Chances are that you are working with an </span><code class="literal"><span>ext4</span></code><span> filesystem right now.</span></p>

  <p><span>Entering the mount point with </span><code class="literal"><span>cd</span></code><span> and listing the files with </span><code class="literal"><span>ls</span></code><span>, you will see a folder structure similar to the one in the next image:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_105.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_105" style="max-width:831px;max-height:412px"/></div>

  <p><span>You can now navigate the folders tree and study the structure, removing or adding the file you want. One interesting file to study is </span><code class="literal"><span>build.prop</span></code><span>. This file contains juicy information about the system and its configuration. It's a very hardware-specific file, due to the infinite possibilities for customizing an Android system, but most of the variants share common details, such as memory heap size, display density, device code name, manufacturer name, Android framework SDK version, Android system version, and so on. There is even information about the system build time and the default ringtone for notifications and calls. There are plenty of little customizations with which you can play and experiment. For heavier modifications, keep reading and get ready for what's coming in the next chapter.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Modifying an Android binary boot image</span></h3>

  <p><span>As you already learned from the previous chapters, the boot image is a bit different from a system image. First of all, it doesn't contain a filesystem we can mount on our host system: the boot image has to be </span><span class="emphasis"><em><span>decompressed</span></em></span><span>.</span></p>

  <p><span>To decompress the boot image, you are going to use the specific menu item in the </span><code class="literal"><span>Android Kitchen</span></code><span> from the previous pages. The boot image is a key component of a custom ROM: that's where the kernel is and where the </span><code class="literal"><span>init</span></code><span> scripts are. It's the perfect spot to place a system customization that must be applied before the Android system starts, such as the CPU governor setup.</span></p>

  <p><span>To start working with the boot image, just copy the file into the </span><code class="literal"><span>Kitchen</span></code><span> folder, fire up the menu, and start picking the options you want from the menu:</span></p>

  <ul>
    <li><span>Changing the ROM name can be the perfect first step</span></li>

    <li><span>Add root permissions</span></li>

    <li><code class="literal"><span>zipalign</span></code><span> the APK files for faster reading and loading</span></li>

    <li><code class="literal"><span>deodexk</span></code><span> the APK file for easy file manipulation, paying the price of slower loading</span></li>
  </ul>

  <p><span>Once you are satisfied with the modifications, use the </span><code class="literal"><span>kitchen</span></code><span> to generate an update file. This is a </span><code class="literal"><span>.zip</span></code><span> file that can be flashed to the device using the custom recovery and represents your first custom ROM—congratulations!</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Flashing our custom ROM</span></h2>

  <p><span>You have your </span><code class="literal"><span>.zip</span></code><span> file and your customized system partition, and you are thrilled to have flashed them to your device.</span></p>

  <p><span>To flash the system partition, we can use </span><code class="literal"><span>fastboot</span></code><span>. First, you must unmount the partition itself using the following command:</span></p>
  <pre><span class="strong"><strong>~$ umount system_mount_point</strong></span>
</pre>

  <p><span>Before we start experimenting with the system partition, it's always wise to do a system backup:</span></p>

  <p><span class="emphasis"><em><span>"Be prepared. You never know."</span></em></span></p>

  <p><span>Now, you can put the device in Fastboot mode, according to the specific sequence of your device. For our reference device, Google Nexus 6, the sequence is:</span></p>

  <ol>
    <li><span>Power off</span></li>

    <li><span>Press </span><span class="emphasis"><em><span>Volume Up</span></em></span><span>, </span><span class="emphasis"><em><span>Volume Down</span></em></span><span>, and </span><span class="emphasis"><em><span>Power</span></em></span><span> at the same time</span></li>

    <li><span>Release when the </span><code class="literal"><span>Fastboot</span></code><span> menu appears</span></li>
  </ol>

  <p><span>The device is now ready to receive the new system partition. Flash it with the following command:</span></p>
  <pre><span class="strong"><strong>~ $ fastboot flash system system.img</strong></span>
</pre>

  <p><span>Your brand new system partition is in place! If your modifications were very extreme and adventurous, you could end up in a </span><span class="emphasis"><em><span>bootloop</span></em></span><span>—the system keeps on rebooting and never ends the boot sequence. Stock system images distributed by manufacturers, or your own backups, come in very handy in this unfortunate scenario.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>If you are working with a Samsung device and you have a Windows system, you can check out </span><code class="literal"><span>Samsung Odin</span></code><span>, a GUI tool to flash your ROMs and root your devices.</span></p>

  <p><span>The final step is to flash the </span><code class="literal"><span>.zip</span></code><span> file you generated with the </span><code class="literal"><span>kitchen</span></code><span>. The file is generated according to a specific file structure and it's ready to be passed to your custom </span><code class="literal"><span>recovery</span></code><span>. The </span><code class="literal"><span>recovery</span></code><span> will treat it as a "system update" even if it's a completely brand new, customized system.</span></p>

  <p><span>First of all, reboot your system in recovery mode. You can do it with a button sequence or using ADB, with the following command:</span></p>
  <pre><span class="strong"><strong>$: adb reboot recovery</strong></span>
</pre>

  <p><span>Once the device is in recovery mode, navigate with the volume buttons and select </span><span class="strong"><strong><span>Apply update from ADB</span></strong></span><span>. This will put the device in waiting mode. Go back to your terminal and navigate to the </span><code class="literal"><span>.zip</span></code><span> file generated with the </span><code class="literal"><span>kitchen</span></code><span>. Finally, load the file to the device:</span></p>
  <pre><span class="strong"><strong>$: adb sideload filename.zip</strong></span>
</pre>

  <p><span>Congratulations! Your first custom ROM is </span><span class="emphasis"><em><span>live</span></em></span><span> on your device. Now, go back to customize it even more!</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Summary</span></h2>

  <p><span>This chapter taught us what a custom ROM is. We started from a description of the currently existing, most relevant projects, and we have proceeded deep into the details. We have also had a look at some very important components, such as </span><span class="emphasis"><em><span>Android Recovery</span></em></span><span>, both the stock ones and those that have been modified. Finally, as we did in the previous chapters, we have adopted a practical approach, learning how to prepare a suitable environment for Android customization. We have also studied the different tools that are generally used to perform this task, and, in the end, we have applied the concepts we just learned through a simple example of creating a custom ROM. In the next chapter, we will be diving deeper into every single aspect of a ROM, using practical examples to show how to customize and increase the performance of your ROM.</span></p>
</div>
		    </div>
		  </body></html>