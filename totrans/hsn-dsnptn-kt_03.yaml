- en: Understanding Structural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解结构型模式
- en: This chapter covers structural patterns in Kotlin. In general, structural patterns
    deal with relationships between objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Kotlin中的结构型模式。一般来说，结构型模式处理对象之间的关系。
- en: We'll discuss how to extend the functionality of our objects without producing
    complex class hierarchies and how to adapt to changes in the future or how to
    fix some of the decisions taken in the past, as well as how to reduce the memory
    footprint of our program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何在不产生复杂的类层次结构的情况下扩展我们对象的功能，以及如何适应未来的变化或如何修复过去所做的某些决定，以及如何减少我们程序的内存占用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Decorator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者
- en: Adapter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Facade
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Decorator
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者
- en: In the previous chapter, we discussed the **Prototype** design pattern, which
    allowed for creating instances of classes with slightly (or not so slightly) different
    data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**原型**设计模式，它允许创建具有略微（或不是那么略微）不同数据的类的实例。
- en: What if we would like to create a set of classes with slightly different behavior
    though? Well, since functions in Kotlin are first-class citizens (more on that
    in a bit), you could use the Prototype design pattern to achieve that. After all,
    that's what JavaScript does successfully. But the goal of this chapter is to discuss
    another approach to the same problem. After all, design patterns are all about
    approaches.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一组具有略微不同行为的类呢？好吧，由于Kotlin中的函数是一等公民（更多内容将在后面讨论），你可以使用原型设计模式来实现这一点。毕竟，这正是JavaScript成功做到的事情。但本章的目标是讨论解决同一问题的另一种方法。毕竟，设计模式都是关于方法的。
- en: By implementing this design pattern, we allow the user of our code to specify
    which abilities he or she wants to add.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个设计模式，我们允许我们的代码用户指定他们想要添加的能力。
- en: Enhancing a class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强类
- en: Your boss—sorry, scrum master—came to you yesterday with an urgent requirement.
    From now on, all map data structures in your system are to become `HappyMaps`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的老板——抱歉，敏捷大师——昨天向你提出了一个紧急要求。从现在开始，你系统中的所有映射数据结构都必须变成`HappyMaps`。
- en: 'What, you don''t know what `HappyMaps` are? They are the hottest stuff going
    around right now. They are just like the regular `HashMap`, but when you override
    an existing value, they print the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你不知道什么是`HappyMaps`吗？它们是目前最热门的东西。它们就像常规的`HashMap`一样，但是当你覆盖现有的值时，它们会打印出以下输出：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, what you do is type the following code in your editor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你在编辑器中输入以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've seen `apply()` already when we discussed the **Builder** design pattern
    in the previous chapter and `this?.let { ... }`  is a nicer way of saying `if
    (this != null) { ... }`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一章讨论**构建者**设计模式时已经看到了`apply()`，而`this?.let { ... }`是一个更优雅的方式来表达`if (this
    != null) { ... }`。
- en: 'We can test our solution using the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来测试我们的解决方案：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code prints the following output as expected:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码按预期打印以下输出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That was the only overridden key.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是唯一被重载的关键。
- en: Operator overloading
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Hold on a second, how do square brackets keep working when we extended a map?
    Aren't they some kind of magic?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下，当我们扩展一个映射时，方括号是如何继续工作的？它们不是某种魔法吗？
- en: Well, actually no. No magic there. As you may have guessed by the title of this
    section, Kotlin supports operator overloading. Operator overloading means that
    the same operator acts differently, depending on the type of arguments it receives.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上没有。这里没有魔法。正如你可能从本节标题猜到的，Kotlin支持运算符重载。运算符重载意味着同一个运算符根据它接收到的参数类型的不同而表现出不同的行为。
- en: 'If you''ve ever worked with Java, you''re familiar with operator overloading
    already. Think of how the plus operator works. Let take a look at the example
    given here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Java，你已经熟悉运算符重载了。想想加号运算符是如何工作的。让我们看看这里给出的例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Based on whether two arguments are either strings or integers, the `+` sign
    acts differently.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据两个参数是字符串还是整数，`+`符号的行为不同。
- en: 'But, in the Java world, this is something that only the language itself is
    allowed to do. The following code won''t compile, no matter how hard we try:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在Java的世界里，这只有语言本身才能做到。无论我们怎么尝试，以下代码都无法编译：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Java 9, there's also `List.of()`, which serves a similar purpose to `Arrays.asList()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，还有一个`List.of()`，它服务于与`Arrays.asList()`类似的目的。
- en: 'In Kotlin, the same code prints `[a, b]`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，相同的代码打印出`[a, b]`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Well, that makes a lot of sense, but maybe it''s just a language feature:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很有道理，但也许它只是语言特性：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Told you it was magic! You cannot simply join two arbitrary classes together.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉过您，这很神奇！您不能简单地将两个任意的类组合在一起。
- en: 'But wait. What if we create an extension function for our `Json` class, `plus()`,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。如果我们为我们的`Json`类创建一个扩展函数`plus()`，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Everything but the first keyword, `operator`, should look familiar to you. We
    extend the `Json` object with a new function that gets another `Json` and returns
    `Json`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个关键字`operator`之外，其他所有内容都应该对您很熟悉。我们通过添加一个新的函数来扩展`Json`对象，该函数获取另一个`Json`并返回`Json`。
- en: 'We implement the function body like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现函数体是这样的：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This isn't really joining any JSON, but it joins `Json` in our example. We take
    values from our `Json`, values from the other `Json`, then join them together
    and put some curly brackets around them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不是连接任何JSON，而是在我们的例子中连接`Json`。我们从我们的`Json`中取值，从另一个`Json`中取值，然后将它们连接起来，并在它们周围加上一些花括号。
- en: 'Now look at this line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这一行：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code prints the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会打印出以下输出：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Actually, it will print: `Json(j={{"a": "b"}:{"c": "d"}})`. This is because
    we didn''t override the `toString()` method in our example for brevity.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，它会打印出：`Json(j={{"a": "b"}}:{"c": "d"}})`。这是因为我们为了简洁起见，在示例中没有重写`toString()`方法。'
- en: So, what's this `operator` keyword about?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个`operator`关键字是什么意思呢？
- en: Unlike some other languages, you cannot override every operator that exists
    in Kotlin languages, just a chosen few.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些语言不同，您不能覆盖Kotlin语言中存在的每个操作符，而只能选择一些。
- en: 'Albeit limited, the list of all operators that can be overridden is quite long,
    so we''ll not list it here. You can refer to it in the official documentation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有限，但可以重写的所有操作符列表相当长，所以我们在这里不列出。您可以在官方文档中查阅：
- en: '[https://kotlinlang.org/docs/reference/operator-overloading.html](https://kotlinlang.org/docs/reference/operator-overloading.html).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kotlinlang.org/docs/reference/operator-overloading.html](https://kotlinlang.org/docs/reference/operator-overloading.html)。'
- en: 'Try renaming your extension method to:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将您的扩展方法重命名为：
- en: '`prus()`: Just a name with a typo'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prus()`: 只是一个打字错误的名称'
- en: '`minus()`: The existing function that correlates with the `-` sign'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minus()`: 与减号`-`相关联的现有函数'
- en: You will see that your code stops compiling.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现您的代码无法编译。
- en: The square brackets that we started with are called **indexed access operators **and
    correlate to the `get(x)` and `set(x, y)` methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始使用的方括号被称为**索引访问操作符**，与`get(x)`和`set(x, y)`方法相关联。
- en: Dude, where's my map?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嘿，我的映射在哪里？
- en: 'The next day, your product manager reaches out to you. Apparently, they want
    a `SadMap` now, which gets *sad* each time a key is removed from it. Following
    the previous pattern, you extend the map again:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，您的产品经理联系您。显然，他们现在想要一个`SadMap`，每次从其中删除一个键时，它都会变得**悲伤**。按照之前的模式，您再次扩展了映射：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But then the chief architect asks that in some cases, a map would be happy
    and sad at the same time. The CTO already has a great idea for a `SuperSadMap` that
    will print the following output twice:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后首席架构师要求在某些情况下，一个映射可以同时感到高兴和悲伤。CTO已经有一个关于`SuperSadMap`的伟大想法，它将打印出以下输出两次：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, what we need is the ability to combine the behaviors of our objects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要的是结合我们对象行为的能力。
- en: The great combinator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伟大的组合者
- en: 'We''ll start a bit differently this time. Instead of composing our solution
    piece by piece, we''ll look at the complete solution and decompose it. The code
    here will help you understand why:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将有所不同。我们不会逐个组合解决方案，而是先看完整的解决方案，然后分解它。这里的代码将帮助您理解原因：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The hardest part here is to understand the signature. What we need in the Decorator
    pattern is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的难点在于理解签名。在装饰器模式中，我们需要的是：
- en: To be able to receive the object we're decorating
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够接收我们正在装饰的对象
- en: To keep a reference to it
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留对其的引用
- en: When our Decorator is called, we decide if we would like to change the behavior
    of the object we're holding, or to delegate the call
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的装饰器被调用时，我们决定是否要改变我们持有的对象的行为，或者要委托调用
- en: 'Since we need to actually do a lot of stuff, this declaration is quite complex.
    After all, it does a lot of stuff in one line, which should be quite impressive.
    Let''s break it down line by line:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要实际做很多事情，这个声明相当复杂。毕竟，它在一行中做了很多事情，这应该相当令人印象深刻。让我们逐行分解：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our class is named `HappyMap` and has two type arguments, `K` and `V`, which
    stand for **key** and **value**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们班级的名字是`HappyMap`，它有两个类型参数，`K`和`V`，分别代表**键**和**值**：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our constructor, we receive `MutableMap`, with types `K` and `V`, the same
    as ours:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们接收带有类型`K`和`V`的`MutableMap`，与我们的相同：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If no map was passed, we initialize our property with the default argument
    value, which is an empty mutable map:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递映射，我们使用默认参数值初始化我们的属性，这个默认值是一个空的可变映射：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our class extends the `MutableMap` interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个类扩展了`MutableMap`接口：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It also **delegates **all methods that weren't overridden to the object that
    we will wrap, in our case a map.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它也将所有未重写的方法**委托**给我们将要包装的对象，在我们的例子中是一个映射。
- en: The code for `SadMap` using delegate is omitted, but you can easily reproduce
    it by combining the declaration of `HappyMap` and the previous implementation
    of `SadMap`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理的`SadMap`代码被省略了，但你可以通过组合`HappyMap`的声明和之前`SadMap`的实现轻松地重新生成它。
- en: 'Let''s compose our `SadHappyMap` now, to please the chief architect:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来组合我们的`SadHappyMap`，以取悦首席架构师：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We get the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the same way, we can now create `SuperSadMap`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们现在可以创建`SuperSadMap`：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And we can please the CTO too.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以取悦CTO。
- en: The Decorator design pattern is widely used in the `java.io.*` package, with
    classes such as reader and writer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式在`java.io.*`包中广泛使用，包括如reader和writer等类。
- en: Caveats
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: The Decorator design pattern is great because it lets us compose objects *on
    the fly*. Using Kotlin's `by` keyword will make it simple to implement. But there
    are still limitations that you need to take care of.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式很棒，因为它让我们可以**即时**组合对象。使用Kotlin的`by`关键字将使其简单易行。但仍然有一些限制，你需要注意。
- en: 'First, you cannot see *inside* of the Decorator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你无法看到装饰器的**内部**：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s the top wrapper, so no problem there:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那是顶层包装器，所以没问题：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That''s the interface we implement, so the compiler knows about it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们实现的接口，所以编译器知道它：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although `SadMap` contains `HappyMap` and may behave like it, it is not a `HappyMap`!
    Keep that in mind while performing casts and type checks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`SadMap`包含`HappyMap`并且可能表现得像它，但它并不是一个`HappyMap`！在执行类型转换和类型检查时，请记住这一点。
- en: Second, which is related to the first point, is the fact that since Decorator
    is usually not aware directly of which class it wraps, it's hard to do optimizations.
    Imagine that our CTO requested `SuperSadMap` to print `Okay... Okay...` and that's
    it, on the same line. For that, we would need to either capture the entire output,
    or investigate all the classes that we will wrap, which are quite complex tasks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点，与第一点相关，是装饰器通常不知道它直接包装的是哪个类，这很难进行优化。想象一下我们的CTO要求`SuperSadMap`打印`Okay... Okay...`然后就是它，在同一行。为了做到这一点，我们需要捕获整个输出，或者调查我们将要包装的所有类，这些任务相当复杂。
- en: Keep these points in mind when you use this powerful design pattern. It allows
    for adding new responsibilities to an object dynamically (in our case, printing
    `Yay` is a responsibility), instead of subclassing the object. Each new responsibility
    is a new wrapping layer you add.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个强大的设计模式时，请记住这些要点。它允许动态地向对象添加新责任（在我们的例子中，打印`Yay`是一种责任），而不是通过子类化对象。每个新的责任都是你添加的新包装层。
- en: Adapter
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: The main goal of an Adapter, or Wrapper, as it's sometimes called, is to convert
    one interface to another interface. In the physical world, the best example would
    be an electrical plug Adapter, or a USB Adapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器，或者有时被称为包装器，其主要目标是转换一个接口到另一个接口。在物理世界中，最好的例子就是一个电源插头适配器，或者一个USB适配器。
- en: Imagine yourself in a hotel room in the late evening, with 7% battery left on
    your phone. Your phone charger was left in the office, at the other end of the
    city. You only have an EU plug charger with a USB mini cable. But your phone is
    USB type-C, because you had to upgrade. And you're in New York, so all of your
    outlets are of course US type-A. What do you do? Oh, it's easy. You look for a
    USB mini to USB Type-C Adapter in the middle of the night and hope you also don't
    forget to bring that EU to US plug Adapter while you're at it. Only 5% battery
    left. Time is running out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自己在晚上很晚的时候，手机电量只剩下7%。你的手机充电器忘在了办公室，在城市的另一头。你只有一款欧盟插头充电器和一根USB迷你线。但你的手机是USB
    Type-C，因为你不得不升级。而且你人在纽约，所以所有的插座当然都是US Type-A。你该怎么办？哦，很简单。你在半夜找一根USB迷你转USB Type-C适配器，并希望在这个过程中也不要忘记带上那个欧盟转US插头适配器。电量只剩下5%，时间正在流逝。
- en: So, now that we understand a bit better what adapters are for in the physical
    world, let's see how we can apply the same in code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们更好地理解了适配器在物理世界中的作用，让我们看看我们如何在代码中应用同样的方法。
- en: 'Let''s start with interfaces:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从接口开始：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can declare a phone and a power outlet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明一个手机和一个电源插座：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our charger is wrong in every way, of course:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的充电器在各个方面都是错误的：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here we get the following errors:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们遇到了以下错误：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Different adapters
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的适配器
- en: So, we need two types of adapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要两种类型的适配器。
- en: In Java, you would usually create a pair of classes for that purpose. In Kotlin,
    we can replace those with extension functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你通常会为此创建一对类。在Kotlin中，我们可以用扩展函数来替换它们。
- en: 'We could adopt the US plug to work with the EU plug by using the following
    extension function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下扩展函数采用美国插头来与欧盟插头一起工作：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can create a USB Adapter between mini USB and type-C USB in a similar way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式创建一个迷你USB和type-C USB之间的USB适配器：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And finally, we get back online by combining all those adapters together:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将这些适配器组合在一起，我们重新上线：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we don't need to compose one object inside the other to adapt
    them. Nor, luckily, do we need to inherit both interface and implementation. With
    Kotlin, our code stays short and to the point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不需要在对象内部组合一个对象来适配它们。幸运的是，我们也不需要继承接口和实现。有了Kotlin，我们的代码保持简短而直接。
- en: Adapters in the real world
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器在现实世界中的应用
- en: 'You''ve probably encountered those adapters too. Mostly, they adapt between
    *concepts* and *implementations*. For example, let''s take the concept of *collection*
    versus the concept of a *stream*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也遇到过这些适配器。大多数情况下，它们在*概念*和*实现*之间进行适配。例如，让我们以*集合*的概念与*流*的概念为例：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You cannot simply pass a collection to a function that receives a stream, even
    though it may make sense:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样做在逻辑上可能合理，你也不能简单地将一个集合传递给接收流的功能：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Luckily, collections provide us with the `.stream()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，集合为我们提供了`.stream()`方法：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Caveats of using adapters
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用适配器的注意事项
- en: Did you ever plug a 110v US appliance into a 220v EU socket through an Adapter,
    and fry it totally?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有通过适配器将110v的美国电器插入220v的欧盟插座，然后完全烧毁过？
- en: 'That''s something that may also happen to your code, if you''re not careful. 
    The following example, which uses another Adapter, compiles well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心，这可能会发生在你的代码上。以下使用另一个适配器的示例可以编译：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But it never completes, because `Stream.generate()` produces an infinite list
    of integers. So, be careful, and adapt this pattern wisely.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它永远不会完成，因为`Stream.generate()`产生了一个无限整数列表。所以，要小心，并且明智地应用这个模式。
- en: Bridge
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接
- en: Unlike some other design patterns we've met, Bridge is less about a smart way
    to compose objects, and more about guidelines on how not to abuse inheritance.
    The way it works is actually very simple.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们遇到的其他设计模式不同，桥接模式更少关注于以智能方式组合对象，而是更多地关于如何不滥用继承的指导原则。它的工作方式实际上非常简单。
- en: 'Let''s go back to the strategy game we''re building. We have an interface for
    all our infantry units:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们正在构建的策略游戏。我们为所有的步兵单位都有一个接口：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have the concrete implementations:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有具体的实现：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What if we want to have the ability to upgrade our units?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要升级我们的单位的能力呢？
- en: 'Upgraded units should have twice the damage, but move at the same pace:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 升级后的单位应该有双倍的伤害，但移动速度保持不变：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, our game designer has decided that we also need a light version of those
    units. That is, they attack in the same way as regular units, but move at twice
    the speed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的游戏设计师决定我们也需要这些单位的轻量版。也就是说，它们以与常规单位相同的方式攻击，但移动速度是它们的两倍：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since design patterns are all about adapting to change, here comes our dear
    designer, and asks that all infantry units be able to shout, that is, to proclaim
    their unit name loud and clear:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计模式都是关于适应变化的，所以我们的设计师来了，并要求所有步兵单位都能够呼喊，也就是说，大声清晰地宣布他们的单位名称：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What are we to do now?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在该做什么呢？
- en: We go and change the implementation of six different classes, feeling lucky
    that there are only six and not sixteen.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去更改六个不同类的实现，幸运的是只有六个而不是十六个。
- en: Bridging changes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接变化
- en: Depending on the way you look at it, the **Bridge** design pattern may resemble
    Adapter, which we already discussed, or **Strategy**, which we'll discuss in the
    next chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的看法，**桥接**设计模式可能类似于我们已讨论的**适配器**，或者我们在下一章将要讨论的**策略**。
- en: 'The idea behind the Bridge design pattern is to flatten the class hierarchy,
    which is currently three levels deep:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式背后的想法是简化当前深度为三级的类层次结构：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Why do we have this complex hierarchy?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有这样一个复杂的层次结构？
- en: 'It''s because we have three orthogonal properties: weapon type, weapon strength,
    and movement speed.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们有三个正交属性：武器类型、武器强度和移动速度。
- en: 'Say instead, we were to pass those properties to the constructor of a class
    that implements the same interface we were using all along:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们把那些属性传递给一个实现我们一直使用的相同接口的类的构造函数：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The properties that `Soldier` receives should be interfaces, so we could choose
    their implementation later:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Soldier`接收的属性应该是接口，这样我们就可以稍后选择它们的实现：'
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But what are `Meters` and `PointsOfDamage`? Are those classes or interfaces
    we declared somewhere?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但`Meters`和`PointsOfDamage`是什么？它们是我们声明在某个地方的类或接口吗？
- en: Let's take a short detour.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们短暂地偏离一下。
- en: Type aliases
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'First, we''ll look at how they''re declared:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看它们是如何声明的：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We use a new keyword here, `typealias`.  From now on, we can use `Meters` instead
    of plain old `Int` to return from our `move()` method.  They aren''t new types.
    The Kotlin compiler will always translate `PointsOfDamage` to `Long` during compilation. Using
    them provides two advantages:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个新的关键字，`typealias`。从现在起，我们可以使用`Meters`而不是普通的`Int`来从我们的`move()`方法返回。它们不是新类型。Kotlin编译器在编译过程中始终会将`PointsOfDamage`转换为`Long`。使用它们提供了两个优点：
- en: Better semantics, as in our case. We can tell exactly what the meaning of the
    value we're returning is.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的语义，正如我们的情况。我们可以确切地知道我们返回的值的含义。
- en: One of the main goals of Kotlin is to be concise. Type aliases allow us to hide
    complex generic expressions. We'll expand on this in the following sections.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin的主要目标之一是简洁。类型别名允许我们隐藏复杂的泛型表达式。我们将在接下来的章节中展开讨论。
- en: You're in the army now
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你现在在军队里了
- en: Back to our `Soldier` class. We want it to be as adaptable as possible, right?
    He knows he can move or use his weapon for greater good. But how exactly is he
    going to do that?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`Soldier`类。我们希望它尽可能适应，对吧？他知道他可以移动或使用他的武器来做出更大的贡献。但他究竟会如何做呢？
- en: 'We totally forgot to implement those parts! Let''s start with our weapons:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全忘记了实现这些部分！让我们从我们的武器开始：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s look at how we can move:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何移动：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Constants
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'We define all parameters as constants:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有参数定义为常量：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Those values are very effective, since they are known during compilation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值非常有效，因为它们在编译时是已知的。
- en: Unlike `static final` variables in Java, they cannot be placed inside a class.
    You should place them either at the top level of your package or nest them inside
    `object`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java中的`static final`变量不同，它们不能放在类内部。你应该将它们放在你的包的顶层，或者嵌套在`object`内部。
- en: 'Note that although Kotlin has type inference, we can specify the types of our
    constants explicitly, and even use type aliases. How about having `DEFAULT_TIMEOUT
    : Seconds = 60` instead of'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，尽管Kotlin有类型推断，但我们仍然可以明确指定常量的类型，甚至可以使用类型别名。那么，在你的代码中使用`DEFAULT_TIMEOUT :
    Seconds = 60`而不是'
- en: '`DEFAULT_TIMEOUT_SECONDS = 60` in your code?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_TIMEOUT_SECONDS = 60`如何？'
- en: A lethal weapon
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种致命的武器
- en: 'What is left for us is to see that with the new hierarchy, we can still do
    the exact same things:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是让我们看到，在新层次结构中，我们仍然可以做完全相同的事情：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, our hierarchy looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的层次结构看起来是这样的：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Much simpler to extend and also to comprehend. Unlike some other design patterns
    we discussed before, we didn't use any special language feature we didn't know
    about, just some engineering best practices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地进行扩展和理解。与之前讨论的一些其他设计模式不同，我们没有使用任何我们不了解的特殊语言特性，只是使用了一些工程最佳实践。
- en: Composite
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: You may finish this section with a lingering feeling that this pattern is a
    bit awkward. That's because it has a soul mate, it's accompanying pattern, **Iterator**,
    which we'll discuss in the next chapter. When both are combined, that's where
    they really shine. So, if you're feeling confused, come back to this pattern after
    you have got acquainted with **Iterator** too.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在这个部分结束时会有一种这种感觉，这个模式有点尴尬。这是因为它有一个灵魂伴侣，它的伴随模式，**迭代器**，我们将在下一章讨论。当两者结合时，它们才能真正发光。所以，如果你感到困惑，在你熟悉了**迭代器**之后，再回到这个模式。
- en: Having said that, we can start analyzing this pattern. It may look a bit strange
    to have a **Composite** design pattern. After all, aren't all **Structural Patterns** about
    composing objects?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以开始分析这个模式。有一个**组合**设计模式可能看起来有点奇怪。毕竟，所有**结构模式**不都是关于组合对象吗？
- en: Much like in the case of the Bridge design pattern, the name may not reflect
    its true benefits.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与桥接设计模式的情况类似，名称可能并不反映其真正的优势。
- en: Get together
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一起
- en: 'Going back to our strategy game, we have a new concept: a squad. A squad consists
    of zero or more infantry units. This would be a good example of a somewhat complex
    data structure.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的策略游戏中，我们有一个新的概念：一个排。一个排由零个或多个步兵单位组成。这将是复杂数据结构的一个很好的例子。
- en: 'Here are the interfaces and classes we have:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们拥有的接口和类：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How would you implement that? We'll see it in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何实现它？我们将在下一节中看到。
- en: The Squad
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排
- en: '`Squad`, clearly, must be a collection of infantry units. So, it should be
    easy:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Squad`，显然，必须是一组步兵单位。所以，这应该很简单：'
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We even set up a default parameter value, so the other programmer won't need
    to pass his own list of soldiers unless he really needs too. `MutableList` suits
    us well here, since we may add units later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至设置了一个默认参数值，这样其他程序员就不需要传递他自己的士兵列表，除非他真的需要。
- en: 'To make sure it works, we''ll create three soldiers and put them inside:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它能够工作，我们将创建三个士兵并将他们放入其中：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: But the next day, Dave, that's the other programmer, comes to us with a new
    requirement. He thinks it consists of too many lines of code to add soldiers one
    by one, or even to use `mutableListOf()` to pass them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但第二天，Dave，那位程序员，带着新的要求来找我们。他认为添加士兵需要太多的代码行，甚至使用`mutableListOf()`传递它们。
- en: 'He would like to initialize squads like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 他希望像这样初始化排：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That looks nice, but how in the name of all the squads are we going to do that?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但究竟我们该如何做到这一点呢？
- en: Varargs and secondary constructors
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数和次要构造函数
- en: Up until now, we were always using the primary constructor of the class. That's
    the one declared after the class name. But in Java, we can define more than one
    constructor for a class. Why does Kotlin limit us to only one?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用类的默认构造函数。这是在类名之后声明的那个。但在Java中，我们可以为类定义多个构造函数。为什么Kotlin限制我们只能有一个？
- en: 'Actually, it doesn''t. We can define secondary constructors for a class using
    the `constructor` keyword:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，并不是这样。我们可以使用`constructor`关键字为类定义次要构造函数：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note how we delegate one constructor to another:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将一个构造函数委托给另一个：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: But this is clearly not the way to go, since we cannot predict how many more
    elements Dave may pass us. If you come from Java, you have probably thought about
    variadic functions already, which can take an arbitrary number of arguments of
    the same type. In Java, you would declare the parameter as `InfantryUnit... units`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但这显然不是正确的方法，因为我们无法预测Dave可能传递给我们多少个元素。如果你来自Java，你可能已经考虑过可变参数函数，它可以接受任意数量的相同类型的参数。在Java中，你会将参数声明为`InfantryUnit...
    units`。
- en: 'Kotlin provides us with the `vararg` keyword for the same purposes. Combining
    those two approaches, we get the following nice piece of code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为我们提供了`vararg`关键字来达到同样的目的。结合这两种方法，我们得到了以下这段不错的代码：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Counting bullets
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算子弹数量
- en: 'The game designer catches you in the evening, when you are about to go home
    of course. He wants to add the ammo count for the entire squad so each squad will
    be able to report how much ammo it has left:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计师在傍晚时分抓住你，当然是在你准备回家的那一刻。他想为整个排添加弹药计数，这样每个排都能报告它还剩下多少弹药：
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Where's the catch?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么问题吗？
- en: 'Well, you see, snipers have ammo as separate bullets:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你看，狙击手有单独的子弹作为弹药：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Riflemen hold their bullets in magazines:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 步兵将子弹存放在弹匣中：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Luckily, you don't have *machine gunners* on your squad yet, because they carry
    their ammo in belts...
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的排里还没有*机枪手*，因为他们携带弹药在弹带上...
- en: So, you have a complex structure, which may or may not be nested. And you need
    to perform a certain operation on this structure as a whole. Here's where the
    Composite design pattern truly comes into play.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你有一个可能嵌套也可能不嵌套的复杂结构。你需要对这个结构作为一个整体执行某些操作。这正是组合设计模式真正发挥作用的地方。
- en: You see, the name is a bit confusing. Composite is not so much about composing
    objects, but more about treating different type objects as nodes of the same tree.
    For that, they should all implement the same interface.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这个名字有点令人困惑。组合（Composite）与其说是关于组合对象，不如说是关于将不同类型的对象作为同一棵树的节点来处理。为此，它们都应该实现相同的接口。
- en: It may not be that obvious at first. After all, a *rifleman* is clearly not
    a *squad*. But instead of looking at an interface as an *is-a* relationship, we
    should look at it as an *ability enabler*. Android, for example, adopts this pattern
    often.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始并不明显。毕竟，一个*步兵*显然不是一个*排*。但与其将接口视为一种*is-a*关系，我们更应该将其视为一种*能力提供者*。例如，Android经常采用这种模式。
- en: 'Our ability is to count bullets:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的能力是计数子弹：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Both `Squad` and `InfantryUnit` should implement this interface:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Squad`和`InfantryUnit`都应该实现此接口：'
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: And now, since everybody has the same ability, no matter how deep the nesting,
    we can ask the top-level object to query everything beneath it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于每个人都有同样的能力，无论嵌套有多深，我们都可以要求顶层对象查询其下的一切。
- en: '`Magazine` and `Sniper` simply count the bullets they contain. The following
    example shows how we can keep a track of the number of bullets in `Magazines`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magazine`和`Sniper`简单地计数它们包含的子弹。以下示例展示了我们如何跟踪`Magazines`中的子弹数量：'
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following example shows how we can keep a track of the number of bullets `Sniper` has:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何跟踪狙击手`Sniper`拥有的子弹数量：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For `Rifleman`, we can go over their `Magazines` and check how many bullets
    they contain:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Rifleman`，我们可以检查他们的`Magazines`并查看它们包含多少子弹：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, for the squad, we count the sum of counts of all the units squad contains:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于小队，我们计算小队包含的所有单位的计数总和：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Tomorrow, when your product manager discovers suddenly that he needs to implement
    a platoon (that's a collection of squads), you'll be armed and ready.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 明天，当你的产品经理突然发现他需要实现一个排（这是一个小队的集合），你将装备齐全，准备就绪。
- en: Facade
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: In different implementations and approaches, **Facade** may resemble either
    an **Adapter** or an **Abstract Factory**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的实现和方案中，**外观**可能类似于**适配器**或**抽象工厂**。
- en: 'Its goal seems straightforward—to simplify interacting with another class or
    a family of classes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目标似乎很简单——简化与另一个类或类族交互：
- en: When we think about *simplifying*, we usually think of the **Adapter** design
    pattern
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想到*简化*时，我们通常想到**适配器**设计模式
- en: When we think about the *family of classes*, we usually think of an **Abstract
    Factory**
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想到*类族*时，我们通常想到**抽象工厂**
- en: That's where all the confusion usually comes from. To better understand it,
    let's go back to the example we used for the Abstract Factory design pattern.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有混淆通常都来自的地方。为了更好地理解它，让我们回到我们用于抽象工厂设计模式的示例。
- en: Keep it simple
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持简单
- en: 'Let''s say that we would like to implement the `loadGame()` method. This method
    would take a file we already created (we''ll discuss how later), or, at the least,
    the following will be required:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现`loadGame()`方法。这个方法将需要一个我们已创建的文件（我们稍后会讨论），或者至少需要以下内容：
- en: At least two HQs will fave to be created (otherwise, the game is already won)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少需要创建两个总部（否则游戏已经胜利）
- en: Each HQ will have to produce the buildings it had
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个总部都必须生产它拥有的建筑
- en: Each building will have to produce the units it had
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个建筑都必须生产它拥有的单位
- en: All units will have to magically teleport to the positions they were at when
    the game was saved
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有单位都必须神奇地传送到游戏保存时它们所在的位置
- en: If there were any commands given to units (like *obliterating all enemy bases*),
    they should resume executing them
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果给单位下达了任何命令（比如*摧毁所有敌方基地*），它们应该继续执行这些命令
- en: We'll discuss how we actually give commands to our units in the next chapter,
    with the **Command** design pattern. Stay tuned.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论我们实际上如何通过**命令**设计模式向我们的单位下达命令，敬请期待。
- en: Now, usually, it's not just one person working on a game unless it's **Minecraft
    (TM)**. There's that other guy, Dave, who deals with all the command logic. He's
    not much into constructing buildings. But in his role, he also needs to load saved
    games quite often.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通常情况下，除非是**Minecraft (TM**)，否则不会只有一个人在制作游戏。还有那个其他的人，Dave，他处理所有的命令逻辑。他对建造建筑不太感兴趣。但在他的角色中，他也需要经常加载保存的游戏。
- en: As the developer of all those bases that belong to you, you could give him a
    set of instructions you've written on how the game should be properly loaded.
    He may or may not follow this set of instructions. Maybe he'll forget to move
    the units, or build buildings. And the game will crash. You could use the Facade
    design pattern to simplify the job for him.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为所有属于你的基地的开发者，你可以给他一套你写的指令，说明游戏应该如何正确加载。他可能会或可能不会遵循这套指令。也许他会忘记移动单位或建造建筑。游戏可能会崩溃。你可以使用外观设计模式来简化他的工作。
- en: What's the main problem Dave has right now?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Dave现在面临的主要问题是什么？
- en: 'To load a game, he needs to interact with at least three different interfaces:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载游戏，他需要与至少三个不同的界面进行交互：
- en: HQ
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总部
- en: Building
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建筑物
- en: Unit
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位
- en: 'What he would like is to have only one interface, something like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 他希望只有一个接口，类似于：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'That has exactly the methods he needs:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 那正好是他需要的所有方法：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Hey, but that looks like a Static Factory Method there!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，但那看起来像是一个静态工厂方法！
- en: Yep, sometimes, design patterns are embedded into one another. We use the Static
    Factory Method to create our class, but its goal is to be a Facade for other more
    complex classes. Using a Facade doesn't mean we don't expose interfaces our facade
    hides behind to the client. Dave can still use every small unit to issue orders
    after the game is loaded successfully.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有时候，设计模式是相互嵌入的。我们使用静态工厂方法来创建我们的类，但它的目标是作为其他更复杂类的门面。使用门面并不意味着我们不向客户端暴露门面背后隐藏的接口。Dave在游戏加载成功后仍然可以使用每个小单元发出命令。
- en: Simple, right?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？
- en: Flyweight
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级模式
- en: Flyweight is an object without any state. The name comes from *being very light*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式是一个没有任何状态的对象。这个名字来源于*非常轻*。
- en: 'If you''ve been reading either one of the two previous chapters, you may already think
    of a type of object that should be very light: a `data` class. But a `data` class
    is all about state. So, is it related to the Flyweight design pattern at all?'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了前两章中的任意一章，你可能已经想到了一种应该非常轻的对象类型：`data`类。但`data`类完全是关于状态的。那么，它与轻量级设计模式有什么关系呢？
- en: To understand this pattern better, we need to jump back in time some twenty
    years.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个模式，我们需要回顾二十年前。
- en: Back in '94, when the original *Design Patterns* book was published, your regular
    PC had 4 MB of RAM. One of the main goals was to save that precious RAM because
    you could fit only so much into it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 回到1994年，当原始的《设计模式》一书出版时，你的普通PC有4 MB的RAM。其中一个主要目标就是节省那宝贵的RAM，因为你可以将其装入其中的内容是有限的。
- en: Nowadays, some cell phones have 4 GB of RAM. Bear that fact in mind when we
    discuss what the Flyweight design pattern is all about.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些手机有4 GB的RAM。当我们讨论轻量级设计模式时，请记住这个事实。
- en: Being conservative
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保守的做法
- en: Imagine we're building a 2D side-scrolling arcade platformer. That is, you have
    your character, which you control with arrow keys or a gamepad. Your character
    can move left, right, and jump.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们正在构建一个2D横向卷轴街机平台游戏。也就是说，你有你的角色，你可以用箭头键或游戏手柄来控制它。你的角色可以向左、向右移动，并且可以跳跃。
- en: Since we're a really small indie company consisting of one developer (who is
    also a graphic designer, product manager, and sales representative), two cats,
    and a canary named Michael, we use only sixteen colors in our game. And our character
    is 64 pixels tall and 64 pixels wide. We call him **Maronic**, and that's also
    the name of our game.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是一家由一名开发者（同时也是图形设计师、产品经理和销售代表）、两只猫和一只名叫迈克尔的金丝雀组成的小型独立公司，我们在游戏中只使用了十六种颜色。我们的角色高64像素，宽64像素。我们称他为**Maronic**，这也是我们游戏的名字。
- en: 'Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian
    snails:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色有很多敌人，主要由食肉性的坦桑尼亚蜗牛组成：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since it''s a 2D game, each snail has only two directions of movement—left
    and right:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个2D游戏，每个蜗牛只有两个移动方向——向左和向右：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Each snail holds a pair of images and a direction:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每个蜗牛持有一对图像和一个方向：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can get the current sprite that shows us which direction the snail is facing:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取当前显示蜗牛面向哪个方向的精灵：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can draw it on the screen:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在屏幕上绘制它：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But when it moves, it basically just slides left or right. What we would like
    is to have three animated sprites to reproduce the snail''s movments:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 但当它移动时，它基本上只是向左或向右滑动。我们希望有三个动画精灵来重现蜗牛的动作：
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To have it in our code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中实现它：
- en: '[PRE78]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We initialize a list of eight elements passing a `block` function as a constructor.
    For each element, we decide what image to get:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递一个`block`函数作为构造函数初始化一个包含八个元素的列表。对于每个元素，我们决定获取哪个图像：
- en: Positions 0 and 1 are for still images
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置0和1用于静止图像
- en: Positions 2 through 4 are for moving left
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置2到4用于向左移动
- en: Positions 5 through 7 are for moving right
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置5到7用于向右移动
- en: Let's do some math now. Each snail is a 64 x 64 image. Assuming each color takes
    exactly one byte, single images take 4 KB of RAM in the memory. Since we have
    eight images for a snail, we need 32 KB of RAM for each, which allows us to fit
    only 32 snails into 1 MB of memory.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来做一些数学计算。每个蜗牛是一个64 x 64的图像。假设每种颜色正好占用一个字节，单个图像在内存中占用4 KB的RAM。由于一个蜗牛有八个图像，我们需要为每个蜗牛分配32
    KB的RAM，这样我们才能在1 MB的内存中容纳32只蜗牛。
- en: Since we want to have thousands of those dangerous and extremely fast creatures
    on screen, and to be able to run our game on a ten-year-old phone, we clearly
    need a better solution for that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在屏幕上拥有成千上万这种危险且极快的生物，并且能够在十年前的手机上运行我们的游戏，因此我们显然需要一个更好的解决方案。
- en: Saving memory
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节省内存
- en: What's the problem wehave with our snails? They're actually quite fat, heavyweight
    snails.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们蜗牛的问题是什么？它们实际上相当胖，是重量级的蜗牛。
- en: We would like to put them on a diet. Each snail stores eight images within its
    snaily body.  But actually, those images are the same for each snail.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望把它们放在节食中。每个蜗牛在其蜗牛身体内存储了八张图片。但实际上，这些图片对每个蜗牛来说都是相同的。
- en: 'What if we extract those sprites:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提取那些精灵：
- en: '[PRE79]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then we pass this list each time to the `getCurrentSprite()` function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们每次都把这个列表传递给`getCurrentSprite()`函数：
- en: '[PRE80]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That way, we'll only consume 256 KB of memory, no matter how many snails we
    generate. We could generate millions of them without affecting the footprint of
    our program.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，无论我们生成多少蜗牛，我们只会消耗256 KB的内存。我们可以生成数百万个，而不会影响我们程序的大小。
- en: 'Of course, we should worry about the immutability of the data we pass. That
    means that at no point in time we should be able to assign `null` to our `sprites`
    variable as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该担心我们传递的数据的不可变性。这意味着在任何时候，我们都不能将`null`分配给我们的`sprites`变量，如下所示：
- en: '[PRE81]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'That would produce `NullPointerException`. Also, it would be disastrous if
    someone was to `clear()` this list:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会产生`NullPointerException`。而且，如果有人要`clear()`这个列表，那将会是灾难性的：
- en: '[PRE82]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Luckily, Kotlin handles this for us. Since we use `val`, the list is assigned
    exactly once. Also, since we use List, it produces an immutable list, which cannot
    be changed or cleared.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kotlin为我们处理了这个问题。因为我们使用了`val`，列表被精确地分配了一次。而且，因为我们使用了List，它产生了一个不可变列表，这个列表不能被更改或清除。
- en: 'All of the preceding lines won''t even compile:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述行甚至无法编译：
- en: '[PRE83]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You still can argue about the usefulness of this pattern nowadays, when memory
    is plentiful. But, as we already said, the tools in the toolbox don't take much
    space, and having another design pattern under your belt may still prove useful.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 即使现在内存很充足，你仍然可以争论这种模式的有用性。但，正如我们之前所说的，工具箱中的工具并不占多少空间，拥有另一个设计模式可能仍然是有用的。
- en: Proxy
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: This is one misbehaving design pattern. Much like Decorator, it extends object
    functionality. But, unlike Decorator, which always does at it's told, having a
    **Proxy **may mean that when asked, the object will do something totally different
    instead.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为不当的设计模式。就像装饰者一样，它扩展了对象的功能。但是，与总是按指示行事的装饰者不同，拥有一个**代理**可能意味着当被要求时，对象会做完全不同的事情。
- en: A short detour into the RMI world
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单地进入RMI世界
- en: While discussing Proxy, a lot of sources, mostly related to Java, diverge into
    discussing another concept, RMI.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论代理时，许多资料，尤其是与Java相关的资料，会转向讨论另一个概念，RMI。
- en: RMI in the JVM world stands for Remote Method Invocation, which is a sort of
    **Remote Procedure Call** (**RPC**). What that means is that you're able to call
    some code that doesn't exist on your local machine, but sits on some remote machine.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM世界中，RMI代表远程方法调用，这是一种远程过程调用（RPC）。这意味着你能够调用一些不在你本地机器上，而是在某个远程机器上的代码。
- en: Although a very clever solution, it's very JVM specific, and has become less
    popular in the era of microservices, where each piece of code may be written in
    a totally different programming language.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常聪明的解决方案，但它非常特定于JVM，在微服务时代已经变得不那么流行了，因为在微服务时代，每一块代码可能都是用完全不同的编程语言编写的。
- en: A replacement
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个替代方案
- en: When we discussed Creational Patterns, we already discussed the idea of *expensive*
    objects. For example, an object that accesses network resources, or takes a lot
    of time to create.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论创建型模式时，我们已经讨论了*昂贵*对象的想法。例如，访问网络资源的对象，或者创建需要花费很多时间的对象。
- en: We at **Funny Cat App** (name invented by the canary Michael; remember him from
    the Flyweight pattern?) provide our users with funny cat images on a daily basis.
    On our homepage and mobile application, each user sees a lot of thumbnails of
    funny cats. When he clicks or touches any of those images, it expands to its full-screen
    glory.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Funny Cat App**（由金丝雀Michael发明；还记得他从Flyweight模式中吗？）我们每天为用户提供有趣的猫图片。在我们的主页和移动应用程序上，每个用户都会看到很多有趣的猫缩略图。当他点击或触摸任何这些图片时，它就会扩展到全屏的辉煌。
- en: But fetching cat images over the network is very expensive, and it consumes
    a lot of memory, especially if those are images of cats that tend to indulge themselves
    in a second dessert after dinner. So, what we would like to do is to have a smart
    object, something that manages itself.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但在网络中获取猫的图片非常昂贵，并且消耗大量内存，尤其是如果这些是那些在晚餐后倾向于再来一份甜点的猫的图片。所以，我们想要做的是拥有一个智能对象，某种可以自我管理的对象。
- en: When the first user access this image, it will be fetched over the network.
    No way of avoiding that.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个用户访问此图像时，它将通过网络获取。没有避免的方法。
- en: But when it's being accessed for the second time, by this or some other user,
    we would like to avoid going over the network again, and instead return the result
    that was cached. That's the *misbehaving* part, as we described. Instead of the
    expected behavior of going over the network each time, we're being a bit lazy,
    and returning the result that we already prepared. It's a bit like going into
    a cheap diner, ordering a hamburger, and getting it after only two minutes, but
    cold. Well, that's because someone else hated onions and returned it to the kitchen
    a while ago. True story.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当它第二次被访问时，无论是通过这个还是其他用户，我们都希望避免再次访问网络，而是返回之前缓存的那个结果。这就是我们所说的 *行为不当* 部分。与每次都通过网络访问的预期行为不同，我们有点懒，返回我们已经准备好的结果。这有点像走进一家便宜的小餐馆，点了一份汉堡，两分钟后就拿到了，但却是冷的。嗯，这是因为有人不喜欢洋葱，所以之前就把它退回厨房了。这是真的。
- en: 'That sounds like a lot of logic. But, as you''ve probably guessed, especially
    after meeting the Decorator design pattern, Kotlin can perform miracles by reducing
    the amount of boilerplate code you need to write to achieve your goals:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像很多逻辑。但是，正如你可能猜到的，特别是在遇到装饰器设计模式之后，Kotlin 可以通过减少你需要编写的样板代码来达到你的目标，从而创造奇迹：
- en: '[PRE84]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you may notice, we use the `by` keyword to delegate initialization of this
    field to a standard function called `lazy`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们使用 `by` 关键字将此字段的初始化委托给一个名为 `lazy` 的标准函数。
- en: The first call to `image` will execute a block of our code and save its results
    into the `image` property.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `image` 将会执行我们的代码块并将结果保存到 `image` 属性中。
- en: 'Sometimes, the Proxy design pattern is divided into three sub-patterns:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，代理设计模式被分为三个子模式：
- en: 'Virtual proxy: Lazily caches the result'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟代理：懒加载结果
- en: 'Remote proxy: Issues a call to the remote resource'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程代理：向远程资源发出调用
- en: 'Protection or access control proxy: denies access to unauthorized parties'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护或访问控制代理：拒绝未经授权的访问
- en: Depending on your views, you can regard our example as either a virtual proxy
    or a combination of virtual and remote proxies.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的观点，你可以将我们的示例视为虚拟代理或虚拟和远程代理的组合。
- en: Lazy delegation
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载委托
- en: You may wonder what happens if two threads try to initialize the image at the
    same time. By default, the `lazy()` function is synchronized. Only one thread
    will win, and others will wait until the image is ready.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如果两个线程同时尝试初始化图像会发生什么。默认情况下，`lazy()` 函数是同步的。只有一个线程会获胜，其他线程将等待图像准备好。
- en: If you don't mind two threads executing the `lazy` block (it's not that expensive,
    for example), you can use `by lazy(LazyThreadSafetyMode.PUBLICATION)`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎两个线程执行 `lazy` 块（例如，它并不那么昂贵），你可以使用 `by lazy(LazyThreadSafetyMode.PUBLICATION)`。
- en: If performance is absolutely critical to you, and you're absolutely sure that
    two threads won't ever execute the same block simultaneously, you can use `LazyThreadSafetyMode.NONE`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绝对需要性能，并且你绝对确信两个线程永远不会同时执行相同的块，你可以使用 `LazyThreadSafetyMode.NONE`。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how structural design patterns help us to create
    more flexible code that can adapt to changes with ease, sometimes even at runtime.
    We've covered **operator overloading** in Kotlin and its limitations. You should
    know how to create a shortcut to a type name with `typealias` and how to define
    efficient constants with `const`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了结构型设计模式如何帮助我们创建更灵活的代码，这些代码可以轻松适应变化，有时甚至可以在运行时进行。我们已经介绍了 Kotlin 中的操作符重载及其局限性。你应该知道如何使用
    `typealias` 创建类型名的快捷方式，以及如何使用 `const` 定义有效的常量。
- en: We've covered how delegating to another class works in Kotlin, by implementing
    the same interface and using the `by` keyword.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在 Kotlin 中如何通过实现相同的接口并使用 `by` 关键字来实现委托给另一个类的工作方式。
- en: In addition, we covered functions that can receive an **arbitrary number of
    arguments** with `vararg` and **lazy initialization** with `lazy`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了可以使用 `vararg` 接收任意数量参数的函数，以及使用 `lazy` 进行懒初始化。
- en: 'In the next chapter, we''ll discuss the third family of classical design patterns:
    behavioral patterns.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论经典设计模式的第三组：行为模式。
