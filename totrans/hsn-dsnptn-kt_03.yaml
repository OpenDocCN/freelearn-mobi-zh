- en: Understanding Structural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers structural patterns in Kotlin. In general, structural patterns
    deal with relationships between objects.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss how to extend the functionality of our objects without producing
    complex class hierarchies and how to adapt to changes in the future or how to
    fix some of the decisions taken in the past, as well as how to reduce the memory
    footprint of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the **Prototype** design pattern, which
    allowed for creating instances of classes with slightly (or not so slightly) different
    data.
  prefs: []
  type: TYPE_NORMAL
- en: What if we would like to create a set of classes with slightly different behavior
    though? Well, since functions in Kotlin are first-class citizens (more on that
    in a bit), you could use the Prototype design pattern to achieve that. After all,
    that's what JavaScript does successfully. But the goal of this chapter is to discuss
    another approach to the same problem. After all, design patterns are all about
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing this design pattern, we allow the user of our code to specify
    which abilities he or she wants to add.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your boss—sorry, scrum master—came to you yesterday with an urgent requirement.
    From now on, all map data structures in your system are to become `HappyMaps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What, you don''t know what `HappyMaps` are? They are the hottest stuff going
    around right now. They are just like the regular `HashMap`, but when you override
    an existing value, they print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what you do is type the following code in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've seen `apply()` already when we discussed the **Builder** design pattern
    in the previous chapter and `this?.let { ... }`  is a nicer way of saying `if
    (this != null) { ... }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test our solution using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That was the only overridden key.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hold on a second, how do square brackets keep working when we extended a map?
    Aren't they some kind of magic?
  prefs: []
  type: TYPE_NORMAL
- en: Well, actually no. No magic there. As you may have guessed by the title of this
    section, Kotlin supports operator overloading. Operator overloading means that
    the same operator acts differently, depending on the type of arguments it receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve ever worked with Java, you''re familiar with operator overloading
    already. Think of how the plus operator works. Let take a look at the example
    given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Based on whether two arguments are either strings or integers, the `+` sign
    acts differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, in the Java world, this is something that only the language itself is
    allowed to do. The following code won''t compile, no matter how hard we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In Java 9, there's also `List.of()`, which serves a similar purpose to `Arrays.asList()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, the same code prints `[a, b]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that makes a lot of sense, but maybe it''s just a language feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Told you it was magic! You cannot simply join two arbitrary classes together.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait. What if we create an extension function for our `Json` class, `plus()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Everything but the first keyword, `operator`, should look familiar to you. We
    extend the `Json` object with a new function that gets another `Json` and returns
    `Json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement the function body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This isn't really joining any JSON, but it joins `Json` in our example. We take
    values from our `Json`, values from the other `Json`, then join them together
    and put some curly brackets around them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, it will print: `Json(j={{"a": "b"}:{"c": "d"}})`. This is because
    we didn''t override the `toString()` method in our example for brevity.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what's this `operator` keyword about?
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other languages, you cannot override every operator that exists
    in Kotlin languages, just a chosen few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Albeit limited, the list of all operators that can be overridden is quite long,
    so we''ll not list it here. You can refer to it in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kotlinlang.org/docs/reference/operator-overloading.html](https://kotlinlang.org/docs/reference/operator-overloading.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try renaming your extension method to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prus()`: Just a name with a typo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minus()`: The existing function that correlates with the `-` sign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see that your code stops compiling.
  prefs: []
  type: TYPE_NORMAL
- en: The square brackets that we started with are called **indexed access operators **and
    correlate to the `get(x)` and `set(x, y)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Dude, where's my map?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next day, your product manager reaches out to you. Apparently, they want
    a `SadMap` now, which gets *sad* each time a key is removed from it. Following
    the previous pattern, you extend the map again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But then the chief architect asks that in some cases, a map would be happy
    and sad at the same time. The CTO already has a great idea for a `SuperSadMap` that
    will print the following output twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, what we need is the ability to combine the behaviors of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: The great combinator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start a bit differently this time. Instead of composing our solution
    piece by piece, we''ll look at the complete solution and decompose it. The code
    here will help you understand why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The hardest part here is to understand the signature. What we need in the Decorator
    pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to receive the object we're decorating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep a reference to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our Decorator is called, we decide if we would like to change the behavior
    of the object we're holding, or to delegate the call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we need to actually do a lot of stuff, this declaration is quite complex.
    After all, it does a lot of stuff in one line, which should be quite impressive.
    Let''s break it down line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class is named `HappyMap` and has two type arguments, `K` and `V`, which
    stand for **key** and **value**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In our constructor, we receive `MutableMap`, with types `K` and `V`, the same
    as ours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If no map was passed, we initialize our property with the default argument
    value, which is an empty mutable map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class extends the `MutableMap` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It also **delegates **all methods that weren't overridden to the object that
    we will wrap, in our case a map.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `SadMap` using delegate is omitted, but you can easily reproduce
    it by combining the declaration of `HappyMap` and the previous implementation
    of `SadMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compose our `SadHappyMap` now, to please the chief architect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can now create `SuperSadMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And we can please the CTO too.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator design pattern is widely used in the `java.io.*` package, with
    classes such as reader and writer.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Decorator design pattern is great because it lets us compose objects *on
    the fly*. Using Kotlin's `by` keyword will make it simple to implement. But there
    are still limitations that you need to take care of.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you cannot see *inside* of the Decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the top wrapper, so no problem there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the interface we implement, so the compiler knows about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Although `SadMap` contains `HappyMap` and may behave like it, it is not a `HappyMap`!
    Keep that in mind while performing casts and type checks.
  prefs: []
  type: TYPE_NORMAL
- en: Second, which is related to the first point, is the fact that since Decorator
    is usually not aware directly of which class it wraps, it's hard to do optimizations.
    Imagine that our CTO requested `SuperSadMap` to print `Okay... Okay...` and that's
    it, on the same line. For that, we would need to either capture the entire output,
    or investigate all the classes that we will wrap, which are quite complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Keep these points in mind when you use this powerful design pattern. It allows
    for adding new responsibilities to an object dynamically (in our case, printing
    `Yay` is a responsibility), instead of subclassing the object. Each new responsibility
    is a new wrapping layer you add.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of an Adapter, or Wrapper, as it's sometimes called, is to convert
    one interface to another interface. In the physical world, the best example would
    be an electrical plug Adapter, or a USB Adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine yourself in a hotel room in the late evening, with 7% battery left on
    your phone. Your phone charger was left in the office, at the other end of the
    city. You only have an EU plug charger with a USB mini cable. But your phone is
    USB type-C, because you had to upgrade. And you're in New York, so all of your
    outlets are of course US type-A. What do you do? Oh, it's easy. You look for a
    USB mini to USB Type-C Adapter in the middle of the night and hope you also don't
    forget to bring that EU to US plug Adapter while you're at it. Only 5% battery
    left. Time is running out.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we understand a bit better what adapters are for in the physical
    world, let's see how we can apply the same in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare a phone and a power outlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our charger is wrong in every way, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we get the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Different adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we need two types of adapters.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you would usually create a pair of classes for that purpose. In Kotlin,
    we can replace those with extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could adopt the US plug to work with the EU plug by using the following
    extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a USB Adapter between mini USB and type-C USB in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we get back online by combining all those adapters together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't need to compose one object inside the other to adapt
    them. Nor, luckily, do we need to inherit both interface and implementation. With
    Kotlin, our code stays short and to the point.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve probably encountered those adapters too. Mostly, they adapt between
    *concepts* and *implementations*. For example, let''s take the concept of *collection*
    versus the concept of a *stream*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot simply pass a collection to a function that receives a stream, even
    though it may make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, collections provide us with the `.stream()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Caveats of using adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you ever plug a 110v US appliance into a 220v EU socket through an Adapter,
    and fry it totally?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s something that may also happen to your code, if you''re not careful. 
    The following example, which uses another Adapter, compiles well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: But it never completes, because `Stream.generate()` produces an infinite list
    of integers. So, be careful, and adapt this pattern wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike some other design patterns we've met, Bridge is less about a smart way
    to compose objects, and more about guidelines on how not to abuse inheritance.
    The way it works is actually very simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the strategy game we''re building. We have an interface for
    all our infantry units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the concrete implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to have the ability to upgrade our units?
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgraded units should have twice the damage, but move at the same pace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our game designer has decided that we also need a light version of those
    units. That is, they attack in the same way as regular units, but move at twice
    the speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since design patterns are all about adapting to change, here comes our dear
    designer, and asks that all infantry units be able to shout, that is, to proclaim
    their unit name loud and clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What are we to do now?
  prefs: []
  type: TYPE_NORMAL
- en: We go and change the implementation of six different classes, feeling lucky
    that there are only six and not sixteen.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the way you look at it, the **Bridge** design pattern may resemble
    Adapter, which we already discussed, or **Strategy**, which we'll discuss in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind the Bridge design pattern is to flatten the class hierarchy,
    which is currently three levels deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Why do we have this complex hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s because we have three orthogonal properties: weapon type, weapon strength,
    and movement speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say instead, we were to pass those properties to the constructor of a class
    that implements the same interface we were using all along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties that `Soldier` receives should be interfaces, so we could choose
    their implementation later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But what are `Meters` and `PointsOfDamage`? Are those classes or interfaces
    we declared somewhere?
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a short detour.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll look at how they''re declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a new keyword here, `typealias`.  From now on, we can use `Meters` instead
    of plain old `Int` to return from our `move()` method.  They aren''t new types.
    The Kotlin compiler will always translate `PointsOfDamage` to `Long` during compilation. Using
    them provides two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Better semantics, as in our case. We can tell exactly what the meaning of the
    value we're returning is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the main goals of Kotlin is to be concise. Type aliases allow us to hide
    complex generic expressions. We'll expand on this in the following sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You're in the army now
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back to our `Soldier` class. We want it to be as adaptable as possible, right?
    He knows he can move or use his weapon for greater good. But how exactly is he
    going to do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'We totally forgot to implement those parts! Let''s start with our weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how we can move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define all parameters as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Those values are very effective, since they are known during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `static final` variables in Java, they cannot be placed inside a class.
    You should place them either at the top level of your package or nest them inside
    `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that although Kotlin has type inference, we can specify the types of our
    constants explicitly, and even use type aliases. How about having `DEFAULT_TIMEOUT
    : Seconds = 60` instead of'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEFAULT_TIMEOUT_SECONDS = 60` in your code?'
  prefs: []
  type: TYPE_NORMAL
- en: A lethal weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is left for us is to see that with the new hierarchy, we can still do
    the exact same things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our hierarchy looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Much simpler to extend and also to comprehend. Unlike some other design patterns
    we discussed before, we didn't use any special language feature we didn't know
    about, just some engineering best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may finish this section with a lingering feeling that this pattern is a
    bit awkward. That's because it has a soul mate, it's accompanying pattern, **Iterator**,
    which we'll discuss in the next chapter. When both are combined, that's where
    they really shine. So, if you're feeling confused, come back to this pattern after
    you have got acquainted with **Iterator** too.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, we can start analyzing this pattern. It may look a bit strange
    to have a **Composite** design pattern. After all, aren't all **Structural Patterns** about
    composing objects?
  prefs: []
  type: TYPE_NORMAL
- en: Much like in the case of the Bridge design pattern, the name may not reflect
    its true benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Get together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to our strategy game, we have a new concept: a squad. A squad consists
    of zero or more infantry units. This would be a good example of a somewhat complex
    data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the interfaces and classes we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How would you implement that? We'll see it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Squad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Squad`, clearly, must be a collection of infantry units. So, it should be
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We even set up a default parameter value, so the other programmer won't need
    to pass his own list of soldiers unless he really needs too. `MutableList` suits
    us well here, since we may add units later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure it works, we''ll create three soldiers and put them inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: But the next day, Dave, that's the other programmer, comes to us with a new
    requirement. He thinks it consists of too many lines of code to add soldiers one
    by one, or even to use `mutableListOf()` to pass them.
  prefs: []
  type: TYPE_NORMAL
- en: 'He would like to initialize squads like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That looks nice, but how in the name of all the squads are we going to do that?
  prefs: []
  type: TYPE_NORMAL
- en: Varargs and secondary constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we were always using the primary constructor of the class. That's
    the one declared after the class name. But in Java, we can define more than one
    constructor for a class. Why does Kotlin limit us to only one?
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, it doesn''t. We can define secondary constructors for a class using
    the `constructor` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we delegate one constructor to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: But this is clearly not the way to go, since we cannot predict how many more
    elements Dave may pass us. If you come from Java, you have probably thought about
    variadic functions already, which can take an arbitrary number of arguments of
    the same type. In Java, you would declare the parameter as `InfantryUnit... units`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides us with the `vararg` keyword for the same purposes. Combining
    those two approaches, we get the following nice piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Counting bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game designer catches you in the evening, when you are about to go home
    of course. He wants to add the ammo count for the entire squad so each squad will
    be able to report how much ammo it has left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Where's the catch?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you see, snipers have ammo as separate bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Riflemen hold their bullets in magazines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, you don't have *machine gunners* on your squad yet, because they carry
    their ammo in belts...
  prefs: []
  type: TYPE_NORMAL
- en: So, you have a complex structure, which may or may not be nested. And you need
    to perform a certain operation on this structure as a whole. Here's where the
    Composite design pattern truly comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: You see, the name is a bit confusing. Composite is not so much about composing
    objects, but more about treating different type objects as nodes of the same tree.
    For that, they should all implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be that obvious at first. After all, a *rifleman* is clearly not
    a *squad*. But instead of looking at an interface as an *is-a* relationship, we
    should look at it as an *ability enabler*. Android, for example, adopts this pattern
    often.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ability is to count bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Squad` and `InfantryUnit` should implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: And now, since everybody has the same ability, no matter how deep the nesting,
    we can ask the top-level object to query everything beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Magazine` and `Sniper` simply count the bullets they contain. The following
    example shows how we can keep a track of the number of bullets in `Magazines`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how we can keep a track of the number of bullets `Sniper` has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Rifleman`, we can go over their `Magazines` and check how many bullets
    they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the squad, we count the sum of counts of all the units squad contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Tomorrow, when your product manager discovers suddenly that he needs to implement
    a platoon (that's a collection of squads), you'll be armed and ready.
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In different implementations and approaches, **Facade** may resemble either
    an **Adapter** or an **Abstract Factory**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its goal seems straightforward—to simplify interacting with another class or
    a family of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: When we think about *simplifying*, we usually think of the **Adapter** design
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we think about the *family of classes*, we usually think of an **Abstract
    Factory**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's where all the confusion usually comes from. To better understand it,
    let's go back to the example we used for the Abstract Factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Keep it simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we would like to implement the `loadGame()` method. This method
    would take a file we already created (we''ll discuss how later), or, at the least,
    the following will be required:'
  prefs: []
  type: TYPE_NORMAL
- en: At least two HQs will fave to be created (otherwise, the game is already won)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each HQ will have to produce the buildings it had
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each building will have to produce the units it had
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All units will have to magically teleport to the positions they were at when
    the game was saved
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there were any commands given to units (like *obliterating all enemy bases*),
    they should resume executing them
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll discuss how we actually give commands to our units in the next chapter,
    with the **Command** design pattern. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, usually, it's not just one person working on a game unless it's **Minecraft
    (TM)**. There's that other guy, Dave, who deals with all the command logic. He's
    not much into constructing buildings. But in his role, he also needs to load saved
    games quite often.
  prefs: []
  type: TYPE_NORMAL
- en: As the developer of all those bases that belong to you, you could give him a
    set of instructions you've written on how the game should be properly loaded.
    He may or may not follow this set of instructions. Maybe he'll forget to move
    the units, or build buildings. And the game will crash. You could use the Facade
    design pattern to simplify the job for him.
  prefs: []
  type: TYPE_NORMAL
- en: What's the main problem Dave has right now?
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a game, he needs to interact with at least three different interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: HQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What he would like is to have only one interface, something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'That has exactly the methods he needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Hey, but that looks like a Static Factory Method there!
  prefs: []
  type: TYPE_NORMAL
- en: Yep, sometimes, design patterns are embedded into one another. We use the Static
    Factory Method to create our class, but its goal is to be a Facade for other more
    complex classes. Using a Facade doesn't mean we don't expose interfaces our facade
    hides behind to the client. Dave can still use every small unit to issue orders
    after the game is loaded successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flyweight is an object without any state. The name comes from *being very light*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve been reading either one of the two previous chapters, you may already think
    of a type of object that should be very light: a `data` class. But a `data` class
    is all about state. So, is it related to the Flyweight design pattern at all?'
  prefs: []
  type: TYPE_NORMAL
- en: To understand this pattern better, we need to jump back in time some twenty
    years.
  prefs: []
  type: TYPE_NORMAL
- en: Back in '94, when the original *Design Patterns* book was published, your regular
    PC had 4 MB of RAM. One of the main goals was to save that precious RAM because
    you could fit only so much into it.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, some cell phones have 4 GB of RAM. Bear that fact in mind when we
    discuss what the Flyweight design pattern is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Being conservative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine we're building a 2D side-scrolling arcade platformer. That is, you have
    your character, which you control with arrow keys or a gamepad. Your character
    can move left, right, and jump.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're a really small indie company consisting of one developer (who is
    also a graphic designer, product manager, and sales representative), two cats,
    and a canary named Michael, we use only sixteen colors in our game. And our character
    is 64 pixels tall and 64 pixels wide. We call him **Maronic**, and that's also
    the name of our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian
    snails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s a 2D game, each snail has only two directions of movement—left
    and right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Each snail holds a pair of images and a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the current sprite that shows us which direction the snail is facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can draw it on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'But when it moves, it basically just slides left or right. What we would like
    is to have three animated sprites to reproduce the snail''s movments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To have it in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize a list of eight elements passing a `block` function as a constructor.
    For each element, we decide what image to get:'
  prefs: []
  type: TYPE_NORMAL
- en: Positions 0 and 1 are for still images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions 2 through 4 are for moving left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions 5 through 7 are for moving right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some math now. Each snail is a 64 x 64 image. Assuming each color takes
    exactly one byte, single images take 4 KB of RAM in the memory. Since we have
    eight images for a snail, we need 32 KB of RAM for each, which allows us to fit
    only 32 snails into 1 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to have thousands of those dangerous and extremely fast creatures
    on screen, and to be able to run our game on a ten-year-old phone, we clearly
    need a better solution for that.
  prefs: []
  type: TYPE_NORMAL
- en: Saving memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the problem wehave with our snails? They're actually quite fat, heavyweight
    snails.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to put them on a diet. Each snail stores eight images within its
    snaily body.  But actually, those images are the same for each snail.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we extract those sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we pass this list each time to the `getCurrentSprite()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: That way, we'll only consume 256 KB of memory, no matter how many snails we
    generate. We could generate millions of them without affecting the footprint of
    our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we should worry about the immutability of the data we pass. That
    means that at no point in time we should be able to assign `null` to our `sprites`
    variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'That would produce `NullPointerException`. Also, it would be disastrous if
    someone was to `clear()` this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, Kotlin handles this for us. Since we use `val`, the list is assigned
    exactly once. Also, since we use List, it produces an immutable list, which cannot
    be changed or cleared.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding lines won''t even compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You still can argue about the usefulness of this pattern nowadays, when memory
    is plentiful. But, as we already said, the tools in the toolbox don't take much
    space, and having another design pattern under your belt may still prove useful.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one misbehaving design pattern. Much like Decorator, it extends object
    functionality. But, unlike Decorator, which always does at it's told, having a
    **Proxy **may mean that when asked, the object will do something totally different
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: A short detour into the RMI world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While discussing Proxy, a lot of sources, mostly related to Java, diverge into
    discussing another concept, RMI.
  prefs: []
  type: TYPE_NORMAL
- en: RMI in the JVM world stands for Remote Method Invocation, which is a sort of
    **Remote Procedure Call** (**RPC**). What that means is that you're able to call
    some code that doesn't exist on your local machine, but sits on some remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Although a very clever solution, it's very JVM specific, and has become less
    popular in the era of microservices, where each piece of code may be written in
    a totally different programming language.
  prefs: []
  type: TYPE_NORMAL
- en: A replacement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discussed Creational Patterns, we already discussed the idea of *expensive*
    objects. For example, an object that accesses network resources, or takes a lot
    of time to create.
  prefs: []
  type: TYPE_NORMAL
- en: We at **Funny Cat App** (name invented by the canary Michael; remember him from
    the Flyweight pattern?) provide our users with funny cat images on a daily basis.
    On our homepage and mobile application, each user sees a lot of thumbnails of
    funny cats. When he clicks or touches any of those images, it expands to its full-screen
    glory.
  prefs: []
  type: TYPE_NORMAL
- en: But fetching cat images over the network is very expensive, and it consumes
    a lot of memory, especially if those are images of cats that tend to indulge themselves
    in a second dessert after dinner. So, what we would like to do is to have a smart
    object, something that manages itself.
  prefs: []
  type: TYPE_NORMAL
- en: When the first user access this image, it will be fetched over the network.
    No way of avoiding that.
  prefs: []
  type: TYPE_NORMAL
- en: But when it's being accessed for the second time, by this or some other user,
    we would like to avoid going over the network again, and instead return the result
    that was cached. That's the *misbehaving* part, as we described. Instead of the
    expected behavior of going over the network each time, we're being a bit lazy,
    and returning the result that we already prepared. It's a bit like going into
    a cheap diner, ordering a hamburger, and getting it after only two minutes, but
    cold. Well, that's because someone else hated onions and returned it to the kitchen
    a while ago. True story.
  prefs: []
  type: TYPE_NORMAL
- en: 'That sounds like a lot of logic. But, as you''ve probably guessed, especially
    after meeting the Decorator design pattern, Kotlin can perform miracles by reducing
    the amount of boilerplate code you need to write to achieve your goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, we use the `by` keyword to delegate initialization of this
    field to a standard function called `lazy`.
  prefs: []
  type: TYPE_NORMAL
- en: The first call to `image` will execute a block of our code and save its results
    into the `image` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the Proxy design pattern is divided into three sub-patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual proxy: Lazily caches the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remote proxy: Issues a call to the remote resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protection or access control proxy: denies access to unauthorized parties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your views, you can regard our example as either a virtual proxy
    or a combination of virtual and remote proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder what happens if two threads try to initialize the image at the
    same time. By default, the `lazy()` function is synchronized. Only one thread
    will win, and others will wait until the image is ready.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't mind two threads executing the `lazy` block (it's not that expensive,
    for example), you can use `by lazy(LazyThreadSafetyMode.PUBLICATION)`.
  prefs: []
  type: TYPE_NORMAL
- en: If performance is absolutely critical to you, and you're absolutely sure that
    two threads won't ever execute the same block simultaneously, you can use `LazyThreadSafetyMode.NONE`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how structural design patterns help us to create
    more flexible code that can adapt to changes with ease, sometimes even at runtime.
    We've covered **operator overloading** in Kotlin and its limitations. You should
    know how to create a shortcut to a type name with `typealias` and how to define
    efficient constants with `const`.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered how delegating to another class works in Kotlin, by implementing
    the same interface and using the `by` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we covered functions that can receive an **arbitrary number of
    arguments** with `vararg` and **lazy initialization** with `lazy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll discuss the third family of classical design patterns:
    behavioral patterns.'
  prefs: []
  type: TYPE_NORMAL
