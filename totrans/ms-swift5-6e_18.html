<html><head></head><body>
  <div id="_idContainer106">
    <h1 class="chapterNumber">18</h1>
    <h1 id="_idParaDest-288" class="chapterTitle">Memory Management</h1>
    <p class="normal">For many years, the primary languages that I used were C and C-based object-oriented languages. These languages required a good handle on managing memory and knowing when to release memory. Luckily, modern languages like Swift take care of managing memory for us. However, it is a good idea to understand how this memory management works so we can avoid the pitfalls that cause this memory management to fail.</p>
    <p class="normal">In this chapter, we will learn:</p>
    <ul>
      <li class="bullet">How ARC works</li>
      <li class="bullet">What a strong reference cycle is</li>
      <li class="bullet">How to use weak and unowned references to prevent strong reference cycles</li>
    </ul>
    <p class="normal">As we saw in <em class="chapterRef">Chapter 17</em>, <em class="italic">Custom Value Types</em>, structures are value types and classes are reference types. What this means is that when we pass an instance of a structure within our application, such as a parameter of a method, we create a new instance ofÂ the structure in the memory. This new instance of the structure is only valid while the application is in the scope where the structure was created. Once the structure goes out of scope, the new instance of the structure is automatically destroyed, and the memory is released. This makes the memory management of structures very easy and painless.</p>
    <p class="normal">Classes, on the other hand, are reference types. This means that we allocate memory for the instance of the class only once, which is when it is initially created. When we pass an instance of the class within our application, either as a function argument or by assigning it to a variable, we are really passing a reference to where the instance is stored in memory. Since the instance of a class may be referenced in multiple scopes (unlike a structure), it cannot be automatically destroyed, and memory is not released when it goes out of scope because it may be referenced in another scope. Therefore, Swift needs some form of memory management to track and release the memory used by instances of classes when the class is no longer needed. Swift uses <strong class="keyword">Automatic Reference Counting</strong> (<strong class="keyword">ARC</strong>) to track and manage memory usage.</p>
    <p class="normal">With ARC, for the most part, memory management in Swift simply works. ARC will automatically track the references to instances of classes, and when an instance is no longer needed (when there are no references pointing to it), ARC will automatically destroy the instance and release the memory. There are a few instances where ARC requires additional information about relationships to properly manage memory. Before we look at the instances where ARC needs help, let's look at how ARC itself works.</p>
    <h1 id="_idParaDest-289" class="title">How ARC works</h1>
    <p class="normal">Whenever <a id="_idIndexMarker713"/>we create a new instance of a class, <strong class="keyword">ARC</strong> allocates the memory needed to store that instance. This ensures that there is enough <a id="_idIndexMarker714"/>memory to store the information associated with that instance of the class, and also locks the memory so that nothing overwrites it.</p>
    <p class="normal">When the instance of the class is no longer needed, ARC will release the memory allocated for the instance so that it can be used for other purposes. This ensures that we are not tying up <a id="_idIndexMarker715"/>memory that is no longer needed. It is known as a <strong class="keyword">memory leak</strong> when memory is reserved for instances that are no longer needed.</p>
    <p class="normal">If ARC were to release the memory for an instance of a class that is still needed, it would not be possible to retrieve the class information from memory. If we did try to access the instance of the class after the memory was released, there is a possibility that the application would crash or the data would be corrupted. To ensure memory is not released for an instance of a class that is still needed, ARC counts how many times the instance is referenced; that is, how many active properties, variables, or constants are pointing to the instance of the class. Once the reference count for an instance of a class equals zero (that is, nothing is referencing the instance), the memory is marked for release.</p>
    <p class="normal">All the previous examples run properly in a playground; however, the following examples will not. When we run sample code in a playground, ARC does not release objects that we create; this is by design so that we can see how the application runs and also the state of the objects at each step. Therefore, we will need to run these samples as an iOS or macOS project. Let's look at an example of how ARC works. We begin by creating a <code class="Code-In-Text--PACKT-">MyClass</code> class with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { 
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class with name \(self.name)"</span>)
    }
}
</code></pre>
    <p class="normal">In this class, we have a <code class="Code-In-Text--PACKT-">name</code> property that will be set by an initiator accepting a string value. This class also has a deinitializer that is called just before an instance of the class is destroyed and removed from memory. This deinitializer prints out a message to the console that lets us know that the instance of the class is about to be removed.</p>
    <p class="normal">Now, let's <a id="_idIndexMarker716"/>look at the code that shows how ARC creates and destroys instances of a class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> class1ref1: <span class="hljs-type">MyClass?</span> = <span class="hljs-type">MyClass</span>(name: <span class="hljs-string">"One"</span>)
<span class="hljs-keyword">var</span> class2ref1: <span class="hljs-type">MyClass?</span> = <span class="hljs-type">MyClass</span>(name: <span class="hljs-string">"Two"</span>)
<span class="hljs-keyword">var</span> class2ref2: <span class="hljs-type">MyClass?</span> = class2ref1
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Setting class1ref1 to nil"</span>)
class1ref1 = <span class="hljs-literal">nil</span>
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Setting class2ref1 to nil"</span>)
class2ref1 = <span class="hljs-literal">nil</span>
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Setting class2ref2 to nil"</span>)
class2ref2 = <span class="hljs-literal">nil</span>
</code></pre>
    <p class="normal">In the example, we begin by creating two instances of the <code class="Code-In-Text--PACKT-">MyClass</code> class named <code class="Code-In-Text--PACKT-">class1ref1</code> (which stands for class 1 reference 1) and <code class="Code-In-Text--PACKT-">class2ref1</code> (which stands for class 2 reference 1). We then create a second reference to <code class="Code-In-Text--PACKT-">class2ref1</code> named <code class="Code-In-Text--PACKT-">class2ref2</code>.</p>
    <p class="normal">Now, in order to see how ARC works, we need to begin setting the references to <code class="Code-In-Text--PACKT-">nil</code>. We start out by setting <code class="Code-In-Text--PACKT-">class1ref1</code> to <code class="Code-In-Text--PACKT-">nil</code>. Since there is only one reference to <code class="Code-In-Text--PACKT-">class1ref1</code>, the deinitializer will be called. Once the deinitializer completes its task, in our case it prints a message to the console letting us know that the instance of the class has been destroyed and the memory has been released.</p>
    <p class="normal">We then set <code class="Code-In-Text--PACKT-">class2ref1</code> to <code class="Code-In-Text--PACKT-">nil</code>, but there is a second reference to this class (<code class="Code-In-Text--PACKT-">class2ref2</code>) that prevents ARC from destroying the instance so that the deinitializer is not called.</p>
    <p class="normal">Finally, we set <code class="Code-In-Text--PACKT-">class2ref2</code> to <code class="Code-In-Text--PACKT-">nil</code>, which allows ARC to destroy this instance of the <code class="Code-In-Text--PACKT-">MyClass</code> class.</p>
    <p class="normal">If we run this code, we will see the following output, which illustrates how ARC works:</p>
    <pre class="programlisting con"><code class="hljs-con">Initializing class with name One
Initializing class with name Two
Setting class1ref1 to nil
Releasing class with name One
Setting class2ref1 to nil
Setting class2ref2 to nil
Releasing class with name Two
</code></pre>
    <p class="normal">From <a id="_idIndexMarker717"/>the example, it seems that ARC handles memory management very well. However, it is possible to write code that will prevent ARC from working properly.</p>
    <h1 id="_idParaDest-290" class="title">Strong reference cycles</h1>
    <p class="normal">A <strong class="keyword">strong reference cycle</strong>, or <strong class="keyword">strong retain cycle</strong>, is where the instances of two classes hold a <a id="_idIndexMarker718"/>strong reference to each other, preventing ARC from releasing <a id="_idIndexMarker719"/>either instance. Once again, we are not able to use a playground for this example, so we need to create an Xcode project. In this project, we start off by creating two classes named <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> and <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass1_Strong</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> class2: <span class="hljs-type">MyClass2_Strong?</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class1_Strong with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class1_Strong with name \(self.name)"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass2_Strong</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> class1: <span class="hljs-type">MyClass1_Strong?</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class1_Strong with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class1_Strong with name \(self.name)"</span>)
    }
}
</code></pre>
    <p class="normal">As we can see from the code, <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> contains an instance of <code class="Code-In-Text--PACKT-">MyClass2_Strong</code>, therefore the instance of <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> cannot be released until <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> is destroyed. We can also see from the code that <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> contains an instance of <code class="Code-In-Text--PACKT-">MyClass1_Strong</code>, therefore, the instance of <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> cannot be <a id="_idIndexMarker720"/>released until <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> is destroyed. This creates <a id="_idIndexMarker721"/>a cycle of dependency in which neither instance can be destroyed until the other one is destroyed.</p>
    <p class="normal">Let's see how this works by running the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> class1: <span class="hljs-type">MyClass1_Strong?</span> = <span class="hljs-type">MyClass1_Strong</span>(name: <span class="hljs-string">"Class1_Strong"</span>)
<span class="hljs-keyword">var</span> class2: <span class="hljs-type">MyClass2_Strong?</span> = <span class="hljs-type">MyClass2_Strong</span>(name: <span class="hljs-string">"Class2_Strong"</span>)
class1?.class2 = class2 
class2?.class1 = class1
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Setting classes to nil"</span>) 
class2 = <span class="hljs-literal">nil</span>
class1 = <span class="hljs-literal">nil</span>
</code></pre>
    <p class="normal">In this example, we create instances of both the <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> and <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> classes. We then set the <code class="Code-In-Text--PACKT-">class2</code> property of the <code class="Code-In-Text--PACKT-">class1</code> instance to the <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> instance. We also set the <code class="Code-In-Text--PACKT-">class1</code> property of the <code class="Code-In-Text--PACKT-">class2</code> instance to the <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> instance. This means that the <code class="Code-In-Text--PACKT-">MyClass1_Strong </code>instance cannot be destroyed until the <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> instance is destroyed. This means that the reference counters for each instance will never reach zero, therefore, ARC cannot destroy the instances, producing the following output in this case: </p>
    <pre class="programlisting con"><code class="hljs-con">Initializing class1_Strong with name Class1_Strong
Initializing class1_Strong with name Class2_Strong
Setting classes to nil
</code></pre>
    <p class="normal">This inability to destroy instances creates a memory leak, where an application continues to use memory and does not properly release it. This can cause an application to eventually crash.</p>
    <p class="normal">To resolve a strong reference cycle, we need to prevent one of the classes from keeping a strong hold on the instance of the other class, thereby allowing ARC to destroy them both. Swift provides two ways of doing this by letting us define the properties as either a weak or an unowned reference.</p>
    <p class="normal">The difference <a id="_idIndexMarker722"/>between a weak reference and an unowned reference is that the instance that a weak reference refers to can be <code class="Code-In-Text--PACKT-">nil</code>, whereas the <a id="_idIndexMarker723"/>instance that an unowned reference is referring to cannot be <code class="Code-In-Text--PACKT-">nil</code>. This means that when we use a weak reference, the property must be an optional property. Let's see how we would use unowned and weak references to resolve a strong reference cycle. Let's start by looking at the unowned reference.</p>
    <h2 id="_idParaDest-291" class="title">Unowned references</h2>
    <p class="normal">We <a id="_idIndexMarker724"/>begin by <a id="_idIndexMarker725"/>creating two more classes, <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> and <code class="Code-In-Text--PACKT-">MyClass2_Unowned</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass1_Unowned</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">let</span> class2: <span class="hljs-type">MyClass2_Unowned</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, class2: <span class="hljs-type">MyClass2_Unowned</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.class2 = class2
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class1_Unowned with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class1_Unowned with name \(self.name)"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass2_Unowned</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> class1: <span class="hljs-type">MyClass1_Unowned?</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class2_Unowned with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class2_Unowned with name \(self.name)"</span>)
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> class looks pretty similar to the <code class="Code-In-Text--PACKT-">MyClass1_Strong</code> and <code class="Code-In-Text--PACKT-">MyClass2_Strong</code> classes in the preceding example. The difference here is the <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> classâwe set the <code class="Code-In-Text--PACKT-">class2</code> property to <code class="Code-In-Text--PACKT-">unowned</code>, which means it cannot be <code class="Code-In-Text--PACKT-">nil</code> and it does not keep a strong reference to the instance that it is referring to. Since the <code class="Code-In-Text--PACKT-">class2</code> property cannot be nil, we also need to set it when the class is initialized.</p>
    <p class="normal">Let's see how we can initialize and deinitialize the instances of these classes with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> class2 = <span class="hljs-type">MyClass2_Unowned</span>(name: <span class="hljs-string">"Class2_Unowned"</span>) 
<span class="hljs-keyword">let</span> class1: <span class="hljs-type">MyClass1_Unowned?</span> = <span class="hljs-type">MyClass1_Unowned</span>(name: <span class="hljs-string">"class1_Unowned"</span>,class2: class2)
class2.class1 = class1 
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Classes going out of scope"</span>)
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker726"/>preceding code, we create an instance <a id="_idIndexMarker727"/>of the <code class="Code-In-Text--PACKT-">MyClass_Unowned</code> class and then use that instance to create an instance of the <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> class. We then set the <code class="Code-In-Text--PACKT-">class1</code> property of the <code class="Code-In-Text--PACKT-">MyClass2</code> instance to the <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> instance we just created.</p>
    <p class="normal">This creates a reference cycle of dependency between the two classes again, but this time, the <code class="Code-In-Text--PACKT-">MyClass1_Unowned</code> instance is not keeping a strong hold on the <code class="Code-In-Text--PACKT-">MyClass2_Unowned</code> instance, allowing ARC to release both instances when they are no longer needed.</p>
    <p class="normal">If we run this code, we see the following output, showing that both the <code class="Code-In-Text--PACKT-">class1</code> and <code class="Code-In-Text--PACKT-">class2</code> instances are released, and the memory is freed:</p>
    <pre class="programlisting con"><code class="hljs-con">Initializing class2_Unowned with name Class2_Unowned 
Initializing class1_Unowned with name class1_Unowned 
Classes going out of scope
Releasing class2_Unowned with name Class2_Unowned 
Releasing class1_Unowned with name class1_Unowned
</code></pre>
    <p class="normal">As we can see, both instances are properly released. Now let's look at how we would use a weak reference to prevent a strong reference cycle. </p>
    <h2 id="_idParaDest-292" class="title">Weak references</h2>
    <p class="normal">Once <a id="_idIndexMarker728"/>again, we begin by creating two new classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass1_Weak</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> class2: <span class="hljs-type">MyClass2_Weak?</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { 
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class1_Weak with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class1_Weak with name \(self.name)"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass2_Weak</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> class1: <span class="hljs-type">MyClass1_Weak?</span> 
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Initializing class2_Weak with name \(self.name)"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Releasing class2_Weak with name \(self.name)"</span>)
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MyClass1_Weak</code> and <code class="Code-In-Text--PACKT-">MyClass2_Weak</code> classes look very similar to the previous classes we created <a id="_idIndexMarker729"/>that showed how a strong reference cycle works. The difference is that we define the <code class="Code-In-Text--PACKT-">class1</code> property in the <code class="Code-In-Text--PACKT-">MyClass2_Weak</code> class as a weak reference.</p>
    <p class="normal">Now, let's see how we can initialize and deinitialize instances of these classes with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> class1: <span class="hljs-type">MyClass1_Weak?</span> = <span class="hljs-type">MyClass1_Weak</span>(name: <span class="hljs-string">"Class1_Weak"</span>)
<span class="hljs-keyword">let</span> class2: <span class="hljs-type">MyClass2_Weak?</span> = <span class="hljs-type">MyClass2_Weak</span>(name: <span class="hljs-string">"Class2_Weak"</span>)
class1?.class2 = class2 
class2?.class1 = class1 
<span class="hljs-built_i">print</span>(<span class="hljs-string">"Classes going out of scope"</span>)
</code></pre>
    <p class="normal">In the preceding code, we create instances of the <code class="Code-In-Text--PACKT-">MyClass1_Weak</code> and <code class="Code-In-Text--PACKT-">MyClass2_Weak</code> classes and then set the properties of those classes to point to the instance of the other class. Once again, this creates a cycle of dependency, but since we set the <code class="Code-In-Text--PACKT-">class1 </code>property of the <code class="Code-In-Text--PACKT-">MyClass2_Weak</code> class to weak, it does not create a strong reference, allowing both instances to be released.</p>
    <p class="normal">If we run the code, we will see the following output, showing that both the <code class="Code-In-Text--PACKT-">class1_Weak</code> and <code class="Code-In-Text--PACKT-">class2_Weak</code> instances are released and the memory is freed:</p>
    <pre class="programlisting con"><code class="hljs-con">Initializing class1_Weak with name Class1_Weak 
Initializing class2_Weak with name Class2_Weak 
Classes going out of scope
Releasing class1_Weak with name Class1_Weak 
Releasing class2_Weak with name Class2_Weak
</code></pre>
    <p class="normal">On an <a id="_idIndexMarker730"/>additional note, a retain cycle for a closure is exactly the same as a strong reference cycle; a closure actually is a strong reference by default. We would use <a id="_idIndexMarker731"/>weak and unowned references to prevent this exactly as explained in this chapter, simply by changing the variable that holds an instance of a class to hold an instance of a closure. </p>
    <p class="normal">It is recommended that you avoid creating circular dependencies, as shown in this section, but there are times when you may need them. For those times, remember that ARC needs some help to release them.</p>
    <h1 id="_idParaDest-293" class="title">Summary</h1>
    <p class="normal">In this chapter, we explained how ARC works to give you an understanding of how memory is managed in your application. We showed what a strong reference cycle is and explained how it can cause ARC to fail. We concluded the chapter by showing how we can use weak and unowned references to prevent strong reference cycles.</p>
    <p class="normal">In the next chapter, we will look at how to properly format our Swift code for consistency and readability.</p>
  </div>
</body></html>