["```kt\n    using UnityEngine;\n    public class PlayerBehaviour : MonoBehaviour\n    {\n        // A reference to the Rigidbody component\n        private Rigidbody rb;\n        // How fast the ball moves left/right\n        public float dodgeSpeed = 5;\n        // How fast the ball moves forward  automatically\n        public float rollSpeed = 5;\n        // Start is called before the first frame update\n        void Start()\n        {\n            // Get access to our Rigidbody component\n            rb = GetComponent<Rigidbody>();\n        }\n        // Update is called once per frame\n        void Update()\n        {\n            // Check if we're moving to the side\n            var horizontalSpeed =\n                Input.GetAxis(\"Horizontal\") * dodgeSpeed;\n            rb.AddForce(horizontalSpeed, 0, rollSpeed);\n        }\n    }\n    ```", "```kt\n[Tooltip(\"How fast the ball moves left/right\")]\npublic float dodgeSpeed = 5;\n[Tooltip(\"How fast the ball moves forward  automatically\")]\npublic float rollSpeed = 5;\n```", "```kt\n[Tooltip(\"How fast the ball moves forward  automatically\")]\n[Range(0, 10)]\npublic float rollSpeed = 5;\n```", "```kt\nusing UnityEngine;\n[RequireComponent(typeof(Rigidbody))]\npublic class PlayerBehaviour : MonoBehaviour\n```", "```kt\n/// <summary>\n/// A reference to the Rigidbody component\n/// </summary> \nprivate Rigidbody rb;\n```", "```kt\n/// <summary>\n/// FixedUpdate is a prime place to put physics\n/// calculations happening over a period of time.\n/// </summary>\nvoid FixedUpdate()\n{\n    // Check if we're moving to the side\n    var horizontalSpeed = Input.GetAxis(\"Horizontal\") *\n                           dodgeSpeed;\n    rb.AddForce(horizontalSpeed, 0, rollSpeed);\n}\n```", "```kt\nusing UnityEngine;\n/// <summary>\n/// Responsible for moving the player automatically and\n/// receiving input.\n/// </summary>\n[RequireComponent(typeof(Rigidbody))]\npublic class PlayerBehaviour : MonoBehaviour\n{\n    /// <summary>\n    /// A reference to the Rigidbody component\n    /// </summary>\n    private Rigidbody rb;\n    [Tooltip(\"How fast the ball moves left/right\")]\n    public float dodgeSpeed = 5;\n    [Tooltip(\"How fast the ball moves\n        forward  automatically\")]\n    [Range(0, 10)]\n    public float rollSpeed = 5;\n    // Start is called before the first frame update\n    public void Start()\n    {\n        // Get access to our Rigidbody component\n        rb = GetComponent<Rigidbody>();\n    }\n    /// <summary>\n    /// FixedUpdate is a prime place to put physics\n    /// calculations happening over a period of time.\n    /// </summary>\n    void FixedUpdate()\n    {\n        // Check if we're moving to the side\n        var horizontalSpeed = Input.GetAxis(\"Horizontal\") *\n                              dodgeSpeed;\n        rb.AddForce(horizontalSpeed, 0, rollSpeed);\n    }\n}\n```", "```kt\n    using UnityEngine;\n    /// <summary>\n    /// Will adjust the camera to follow and face a target\n    /// </summary>\n    public class CameraBehaviour : MonoBehaviour\n    {\n        [Tooltip(\"What object should the camera be looking\n            at\")]\n        public Transform target;\n        [Tooltip(\"How offset will the camera be to the\n            target\")]\n        public Vector3 offset = new Vector3(0, 3, -6);\n        /// <summary>\n        /// Update is called once per frame\n        /// </summary>\n        private void Update()\n        {\n            // Check if target is a valid object\n            if (target != null)\n            {\n                // Set our position to an offset of our\n                // target\n                transform.position = target.position +\n                    offset;\n                // Change the rotation to face target\n                transform.LookAt(target);\n            }\n        }\n    }\n    ```", "```kt\n    using UnityEngine;\n    /// <summary>\n    /// Manages the main gameplay of the game\n    /// </summary>\n    public class GameManager : MonoBehaviour\n    {\n        [Tooltip(\"A reference to the tile we want to\n            spawn\")]\n        public Transform tile;\n        [Tooltip(\"Where the first tile should be placed\n            at\")]\n        public Vector3 startPoint = new Vector3(0, 0, -5);\n        [Tooltip(\"How many tiles should we create in\n            advance\")]\n        [Range(1, 15)]\n        public int initSpawnNum = 10;\n        /// <summary>\n        /// Where the next tile should be spawned at.\n        /// </summary>\n        private Vector3 nextTileLocation;\n        /// <summary>\n        /// How should the next tile be rotated?\n        /// </summary>\n        private Quaternion nextTileRotation;\n        /// <summary>\n        /// Start is called before the first frame update\n        /// </summary>\n        private void Start()\n        {\n            // Set our starting point\n            nextTileLocation = startPoint;\n            nextTileRotation = Quaternion.identity;\n            for (int i = 0; i < initSpawnNum; ++i)\n            {\n                SpawnNextTile();\n            }\n        }\n        /// <summary>\n        /// Will spawn a tile at a certain location and\n        /// setup the next position\n        /// </summary>\n        public void SpawnNextTile()\n        {\n            var newTile = Instantiate(tile,\n                nextTileLocation, nextTileRotation);\n            // Figure out where and at what rotation we\n            /// should spawn the next item\n            var nextTile = newTile.Find(\"Next Spawn\n                Point\");\n            nextTileLocation = nextTile.position;\n            nextTileRotation = nextTile.rotation;\n        }\n    }\n    ```", "```kt\n    using UnityEngine;\n    /// <summary>\n    /// Handles spawning a new tile and destroying this\n    /// one upon the player reaching the end\n    /// </summary>\n    public class TileEndBehaviour : MonoBehaviour\n    {\n        [Tooltip(\"How much time to wait before destroying\n            \" + \"the tile after reaching the end\")]\n        public float destroyTime = 1.5f;\n        private void OnTriggerEnter(Collider other)\n        {\n            // First check if we collided with the player\n            if(other.gameObject.GetComponent\n            <PlayerBehaviour>())\n            {\n                // If we did, spawn a new tile\n                var gm = GameObject.FindObjectOfType\n                    <GameManager>();\n                gm.SpawnNextTile();\n                // And destroy this entire tile after a\n                // short delay\n                Destroy(transform.parent.gameObject,\n                    destroyTime);\n            }\n        }\n    }\n    ```", "```kt\n    using UnityEngine;\n    using UnityEngine.SceneManagement; // LoadScene\n    public class ObstacleBehaviour : MonoBehaviour\n    {\n        [Tooltip(\"How long to wait before restarting the\n            game\")]\n        public float waitTime = 2.0f;\n        private void OnCollisionEnter(Collision collision)\n        {\n            // First check if we collided with the player\n            if (collision.gameObject.GetComponent\n            <PlayerBehaviour>())\n            {\n                // Destroy the player\n                Destroy(collision.gameObject);\n                // Call the function ResetGame after\n                // waitTime has passed\n                Invoke(\"ResetGame\", waitTime);\n            }\n        }\n        /// <summary>\n        /// Will restart the currently loaded level\n        /// </summary>\n        private void ResetGame()\n        {\n            // Get the current level's name\n            string sceneName =\n                SceneManager.GetActiveScene().name;\n            // Restarts the current level\n            SceneManager.LoadScene(sceneName);\n        }\n    }\n    ```", "```kt\n    /// <summary>\n    /// Manages the main gameplay of the game\n    /// </summary>\n    public class GameManager : MonoBehaviour\n    {\n        [Tooltip(\"A reference to the tile we want to\n            spawn\")]\n        public Transform tile;\n        [Tooltip(\"A reference to the obstacle we want to\n            spawn\")]\n        public Transform obstacle;\n        [Tooltip(\"Where the first tile should be placed\n            at\")]\n        public Vector3 startPoint = new Vector3(0, 0, -5);\n        [Tooltip(\"How many tiles should we create in\n            advance\")]\n        [Range(1, 15)]\n        public int initSpawnNum = 10;\n        [Tooltip(\"How many tiles to spawn with no\n            obstacles\")]\n        public int initNoObstacles = 4;\n    ```", "```kt\n    /// <summary>\n    /// Will spawn a tile at a certain location and setup\n    /// the next position\n    /// </summary>\n    /// <param name=\"spawnObstacles\">If we should spawn an\n    /// obstacle</param>\n    public void SpawnNextTile(bool spawnObstacles = true)\n    {\n        var newTile = Instantiate(tile, nextTileLocation,\n                                  nextTileRotation);\n        // Figure out where and at what rotation we should\n        // spawn the next item\n        var nextTile = newTile.Find(\"Next Spawn Point\");\n        nextTileLocation = nextTile.position;\n        nextTileRotation = nextTile.rotation;\n        if (spawnObstacles)\n        {\n            SpawnObstacle(newTile);\n        }\n    }\n    ```", "```kt\n    using UnityEngine;\n    using System.Collections.Generic; // List\n    ```", "```kt\n    private void SpawnObstacle(Transform newTile)\n    {\n        // Now we need to get all of the possible places\n        // to spawn the obstacle\n        var obstacleSpawnPoints = new List<GameObject>();\n        // Go through each of the child game objects in\n        // our tile\n        foreach (Transform child in newTile)\n        {\n            // If it has the ObstacleSpawn tag\n            if (child.CompareTag(\"ObstacleSpawn\"))\n            {\n                // We add it as a possibility\n                obstacleSpawnPoints.Add(child.gameObject);\n            }\n        }\n        // Make sure there is at least one\n        if (obstacleSpawnPoints.Count > 0)\n        {\n            // Get a random spawn point from the ones we\n            // have\n            int index = Random.Range(0,\n                obstacleSpawnPoints.Count);\n            var spawnPoint = obstacleSpawnPoints[index];\n            // Store its position for us to use\n            var spawnPos = spawnPoint.transform.position;\n            // Create our obstacle\n            var newObstacle = Instantiate(obstacle,\n                spawnPos, Quaternion.identity);\n            // Have it parented to the tile\n            newObstacle.SetParent(spawnPoint.transform);\n        }\n    }\n    ```", "```kt\n    /// <summary>\n    /// Start is called before the first frame update\n    /// </summary>\n    private void Start()\n    {\n        // Set our starting point\n        nextTileLocation = startPoint;\n        nextTileRotation = Quaternion.identity;\n        for (int i = 0; i < initSpawnNum; ++i)\n        {\n            SpawnNextTile(i >= initNoObstacles);\n        }\n    }\n    ```"]