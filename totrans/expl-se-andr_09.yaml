- en: Chapter 9. Adding Services to Domains
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 将服务添加到域中
- en: 'In the previous chapter, we covered the process of getting file objects in
    the proper domain. In most cases, the file object is the target. However, in this
    chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了在适当域中获取文件对象的过程。在大多数情况下，文件对象是目标。然而，在本章中，我们将：
- en: Emphasize labeling processes—notably Android services run and managed by init
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调对进程进行标记——特别是由 init 运行和管理的服务
- en: Manage the ancillary associated objects created by init
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理由 init 创建的辅助关联对象
- en: Init – the king of daemons
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Init – 守护进程之王
- en: The init process is vital in a Linux system, and Android is not special in this
    case. However, Android has its own implementation of init. Init is the first process
    on the system, and thus has a **Process ID** (**PID**) of 1\. All other processes
    are the result of a direct `fork()` from init, thus all processes eventually are
    parented under init, either directly or indirectly. Init is responsible for cleaning
    up and maintaining these processes. For instance, any child process whose parent
    dies is reparented under init by the kernel. In this way, init can call `wait()`
    (`man 2 wait` for more details) to clean up after the process when it exits.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，init 进程至关重要，Android 在这个方面也不例外。然而，Android 有自己的 init 实现。Init 是系统上的第一个进程，因此其
    **进程 ID**（**PID**）为 1。所有其他进程都是直接从 init 的 `fork()` 调用的结果，因此所有进程最终都直接或间接地成为 init
    的子进程。Init 负责清理和维护这些进程。例如，任何父进程死亡的孩子进程都会由内核重新分配给 init。这样，init 可以在进程退出时调用 `wait()`（有关更多详细信息，请参阅
    `man 2 wait`）来清理进程。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A process which has terminated but has not had `wait()` called is a **zombie**
    process. The kernel must keep the process data structures around until this call.
    Failing to do so will consume memory indefinitely.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已经终止但尚未调用 `wait()` 的进程是一个 **僵尸进程**。内核必须保留进程数据结构，直到这个调用。未能这样做将无限期地消耗内存。
- en: Since init is the root of all processes, it also provides a mechanism to declare
    and execute commands through its own scripting language. Files using this language
    to control init are referred to as init scripts, and we have already modified
    some of them. In the source tree, we used the `init.rc` file, which you can reach
    by navigating to `device/fsl/imx6/etc/init.rc`, but on the device, it is packaged
    with the ramdisk at `/init.rc`, and is made available to init, which is also packaged
    in the ramdisk at `/init`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 init 是所有进程的根，它还提供了一种通过自己的脚本语言声明和执行命令的机制。使用这种语言来控制 init 的文件被称为 init 脚本，我们已经修改了一些。在源树中，我们使用了
    `init.rc` 文件，您可以通过导航到 `device/fsl/imx6/etc/init.rc` 来访问它，但在设备上，它与 ramdisk 一起打包在
    `/init.rc` 中，并可供 init 使用，init 也打包在 ramdisk 中的 `/init`。
- en: 'To add a service to the init script, you can modihe `init.r`e and add a declaration,
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要将服务添加到 init 脚本中，您可以修改 `init.r` 并添加一个声明，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `name` is the service name, `path` is the path to the executable, and
    `argument` are space delimited argument strings to be delivered to the executable
    in its `argv` array.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`name` 是服务名称，`path` 是可执行文件的路径，而 `argument` 是要传递给可执行文件的空格分隔的参数字符串，这些字符串将添加到其
    `argv` 数组中。
- en: 'For example, here is the service declaration for `rild`, the **Radio Interface
    Layer Daemon** (**RILD**):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是 `rild` 的服务声明，**Radio Interface Layer Daemon**（**RILD**）：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is often the case that additional service options can and need to be added.
    The init script `service` statement supports a rich assortment of options. For
    the complete list, refer to the informational file located at `system/core/init/readme.txt`.
    Additionally, we covered the SE for Android-specific changes in [Chapter 3](ch03.html
    "Chapter 3. Android Is Weird"), *Android Is Weird*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，可以并且需要添加额外的服务选项。init 脚本的 `service` 语句支持丰富的选项集。有关完整列表，请参阅位于 `system/core/init/readme.txt`
    的信息文件。此外，我们在 [第3章](ch03.html "第3章。Android 是奇怪的") 中介绍了 Android 特定的 SE 变更，*Android
    是奇怪的*。
- en: 'Continuing to dissect `rild`, we see that the rest of the declaration in the
    UDOO `init.rc` is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 继续分析 `rild`，我们看到 UDOO `init.rc` 中的其余声明如下：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The interesting thing to note here is that it creates quite a few sockets.
    The `socket` keyword in `init.rc` is described by the `readme.txt` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的有趣之处在于它创建了很多套接字。`init.rc` 中的 `socket` 关键字由 `readme.txt` 文件描述：
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'From the source tree file `system/core/init/readme.txt`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从源树文件 `system/core/init/readme.txt`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a Unix domain socket named `/dev/socket/<name>` and pass its `fd` to
    the launched process. The type must be `dgram`, `stream`, or `seqpacket`. The
    `user` and `group` IDs default to `0`. The SELinux security context for the socket
    is `context`. It defaults to the service security context, as specified by `seclabel`,
    or is computed based on the service executable file's security context.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`/dev/socket/<name>`的Unix域套接字，并将它的`fd`传递给启动的进程。类型必须是`dgram`、`stream`或`seqpacket`。`user`和`group`
    IDs默认为`0`。套接字的SELinux安全上下文是`context`。它默认为服务安全上下文，如`seclabel`中指定的，或者基于服务可执行文件的安全上下文计算得出。
- en: Let's take a look at this directory and see what we've found.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个目录，看看我们发现了什么。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This raises the question, "How did it get into that domain?" Using our knowledge
    from the previous chapter, we know that **/** `dev` is a `tmpfs`, so we know that
    it did not enter this domain through `xattrs`. It must be either a code modification
    or a type transition. Let's check whether it's a type transition. If it is, we
    would expect to see a statement in the expanded `policy.conf`. SELinux policy
    is based on the `m4` macro language. During builds, it is expanded into `policy.conf`,
    and then compiled. [Chapter 12](ch12.html "Chapter 12. Mastering the Tool Chain"),
    *Mastering the Tool Chain*, has more details on this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了问题，“它是如何进入该域的？”根据上一章的知识，我们知道`/**` `dev`是一个`tmpfs`，所以我们知道它不是通过`xattrs`进入这个域的。它必须是一个代码修改或类型转换。让我们检查是否是类型转换。如果是，我们预计会在展开的`policy.conf`中看到一个语句。SELinux策略基于`m4`宏语言。在构建过程中，它被展开为`policy.conf`，然后编译。[第12章](ch12.html
    "第12章。掌握工具链")，*掌握工具链*，对此有更多细节。
- en: 'We can discover this by using sesearch to find type transitions for `adbd_socket`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用sesearch来查找`adbd_socket`的类型转换来发现这一点：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the empty output, there are zero such lines, so it's not
    the policy which is doing this but a code change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从空输出中看到的，没有这样的行，所以这不是策略在这样做，而是一个代码更改。
- en: 'In Linux, processes are created with `fork()` followed by `exec()`. Because
    of this, we are able to afford great keywords to search the init daemon. We suspect
    that the code to set up the socket is just after a call to `fork()` in the child
    processes and before a call to `exec()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，进程是通过`fork()`然后是`exec()`创建的。正因为如此，我们能够提供强大的关键词来搜索init守护进程。我们怀疑设置套接字的代码就在子进程中的`fork()`调用之后和`exec()`调用之前：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, the fork we are searching for is on line 235 of `init.c`; let''s open `init.c`
    in a text editor and take a look. We will find the following snippet to examine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在寻找的`fork`在`init.c`的第235行；让我们在文本编辑器中打开`init.c`并查看。我们将找到以下片段以进行检查：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: According to `man 2 fork`, the return code of `fork()` in the child process
    is `0`. The child process executes within this `if` statement and the parent skips
    it. The function `create` **_** `socket()` also seems interesting. It appears
    to take the name of the service, the type of socket, permissions flags, `uid`,
    `gid`, and `socketcon`. What is `socketcon`? Let's check whether we can trace
    back to where it is set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`man 2 fork`，子进程中的`fork()`返回代码是`0`。子进程在这个`if`语句中执行，而父进程跳过它。函数`create` **_**
    `socket()`也似乎很有趣。它似乎接受服务名称、套接字类型、权限标志、`uid`、`gid`和`socketcon`。什么是`socketcon`？让我们检查我们是否可以追踪到它被设置的地方。
- en: 'If we look before `fork()`, we can see that the parent process gets its `scon`
    based on two factors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`fork()`之前查看，我们可以看到父进程根据两个因素获取其`scon`：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first path through the `if` statement occurs when `svc->seclabel` is not
    null. This `svc` structure is populated with the options that can be associated
    with a service. As a refresher from [Chapter 3](ch03.html "Chapter 3. Android
    Is Weird"), *Android Is Weird*, `seclabel` lets you explicitly set the context
    on a service, hardcoded to the value in `init.rc`. The `else` clause is a bit
    more involved and interesting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`if`语句的第一个路径发生在`svc->seclabel`不为空时。这个`svc`结构被填充了可以与一个服务关联的选项。作为对[第3章](ch03.html
    "第3章。Android很奇怪")，*Android很奇怪*的复习，`seclabel`允许你显式地设置一个服务上的上下文，硬编码到`init.rc`中的值。`else`子句要复杂和有趣得多。
- en: 'In the `else` clause, we get the context of the current process by calling
    `getcon()`. This function, since we''re running in init, should return `u:r:init:s0`
    and store it in `mycon`. The next function, `getfilecon()` is passed the path
    of the executable, and checks the context of the file itself. The third function
    is the workhorse here: `security_compute_create()`. This takes the `mycon`, `fcon`,
    and `target` class and computes the security context, `scon`. Given these inputs,
    it tries to determine, based on policy type transitions, what the resulting domain
    for the child should be. If no transitions are defined, `scon` will be the same
    as `mycon`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`子句中，我们通过调用`getcon()`获取当前进程的上下文。由于我们在init中运行，该函数应返回`u:r:init:s0`并将其存储在`mycon`中。下一个函数`getfilecon()`传递可执行文件的路径，并检查文件本身的上下文。第三个函数是这里的功臣：`security_compute_create()`。它接受`mycon`、`fcon`和`target`类，并计算安全上下文`scon`。给定这些输入，它尝试根据策略类型转换确定子进程的结果域。如果没有定义转换，`scon`将与`mycon`相同。
- en: 'A conditional expression within the `create_socket()` function additionally
    determines the socket context passed. The variable `si` is a structure that contains
    all the options to the socket statement in the init `service` section. As specified
    by the `readme.txt` file, `si->socketcon` is the socket context argument. In other
    words, the socket context can come from one of three places (in descending priority):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_socket()`函数中的条件表达式还决定了传递的socket上下文。变量`si`是一个结构，包含init `service`部分中socket语句的所有选项。根据`readme.txt`文件，`si->socketcon`是socket上下文参数。换句话说，socket上下文可以来自以下三个地方（按优先级降序）：'
- en: The `socketcon` option on the socket option in the `service` declaration
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`声明中socket选项的`socketcon`选项'
- en: The `seclabel` option on the `service` keyword
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`关键字上的`seclabel`选项'
- en: Dynamically computed from source and target contexts
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源上下文和目标上下文动态计算
- en: 'The socket context is passed to `create_socket()`. Now, let''s look at `create_socket()`.
    This function is defined at `system/core/init/util.c:87`. The snippets of code
    around `socket()` seem interesting:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: socket上下文传递给`create_socket()`。现在，让我们看看`create_socket()`。这个函数定义在`system/core/init/util.c:87`。围绕`socket()`的代码片段似乎很有趣：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `setsockcreatecon()` function sets the process' socket creation context.
    This means that the socket created by the `socket()` call will have the context
    set via `setsockcreatecon()`. After it's created, the process resets it to the
    original by using `setsockcreatecon(NULL)`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`setsockcreatecon()`函数设置进程的socket创建上下文。这意味着通过`socket()`调用创建的socket将具有通过`setsockcreatecon()`设置的上下文。创建后，进程通过使用`setsockcreatecon(NULL)`将其重置为原始上下文。'
- en: 'The next bit of interesting code is around `bind()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段有趣的代码是围绕`bind()`：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we have set the file creation context. The functions are analogous to
    `setsock_creation()`, but work for filesystem objects. However, the `selabel_lookup()`
    function looks in `file_contexts` for the context of the file. The part you might
    be missing is that the call to `bind()`, for path-based sockets, creates a file
    at the path specified in `sockaddr_un struct`. So, the socket object and the filesystem
    node entry are distinctly separate things and can have different contexts. Typically,
    the socket belongs to the process' context, and the filesystem node is given some
    other context.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了文件创建上下文。这些函数与`setsock_creation()`类似，但适用于文件系统对象。然而，`selabel_lookup()`函数在`file_contexts`中查找文件的上下文。你可能遗漏的部分是，对于基于路径的socket，`bind()`调用在`sockaddr_un
    struct`指定的路径上创建一个文件。因此，socket对象和文件系统节点条目是明显分开的，可以有不同的上下文。通常，socket属于进程的上下文，而文件系统节点被赋予其他上下文。
- en: Dynamic domain transitions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态域转换
- en: 'We saw init computing of the contexts for the init sockets, but we never encountered
    it while setting the domains for child processes. In this section, we will dive
    into the two techniques to do so: explicit setting with an init script and sepolicy
    dynamic domain transitions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了init计算init socket的上下文，但在设置子进程的域时从未遇到过。在本节中，我们将深入了解两种技术：使用init脚本的显式设置和sepolicy动态域转换。
- en: 'The first way to the domains for child processes is with the `seclabel` statement
    in the init script service declaration. Within the child processes execution after
    `fork()`, we find this statement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 获取子进程域的第一种方式是在init脚本服务声明中的`seclabel`语句。在`fork()`之后的子进程执行中，我们发现这个语句：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To clarify, the `svc` variable is the structure that contains the service options
    and arguments, so `svc->seclabel` is `seclabel`. If it's set, it calls `setexeccon()`,
    which sets the process' execution context for anything it executes via `exec()`.
    Further down, we see that the `exec()` function calls are made. The `exec()` syscall
    never returns on success; it only returns on failure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，`svc`变量是包含服务选项和参数的结构，所以`svc->seclabel`是`seclabel`。如果它被设置，它将调用`setexeccon()`，这将设置进程通过`exec()`执行的执行上下文。向下看，我们看到`exec()`函数调用被做出。`exec()`系统调用在成功时永远不会返回；它只在失败时返回。
- en: 'The other way to set the domains for child processes, which is the preferred
    way, is by using sepolicy. It''s preferred because the policy has no dependencies
    on anything else. By hardcoding a context into init, you''re coupling a dependency
    between the init script and the sepolicy. For instance, if the sepolicy removes
    a type that was hardcoded in the init script, the init `setcon` will fail, but
    both systems will compile correctly. If you remove a type for a type transition
    and leave the transition statement, you can catch the error at compile time. Since
    we looked at the `rild` service statement, let''s look at the `rild.te` policy
    file located in `sepolicy`. We should search for the `type_transition` keyword
    in this file using `grep`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设置子进程域的另一种方式，也是首选的方式，是使用sepolicy。它之所以被首选，是因为策略没有依赖于其他任何东西。通过将上下文硬编码到init中，你将init脚本和sepolicy之间的依赖耦合起来。例如，如果sepolicy删除了在init脚本中硬编码的类型，init的`setcon`将失败，但两个系统都将正确编译。如果你删除了一个类型转换的类型并留下了转换语句，你可以在编译时捕获错误。既然我们已经查看了`rild`服务语句，让我们看看位于`sepolicy`中的`rild.te`策略文件。我们应该使用`grep`在这个文件中搜索`type_transition`关键字：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'No instances of `type_transition` are found, but this keyword must exist, similar
    to files. However, it can be hidden in an unexpanded macro. The SELinux policy
    files are in the m4 macro language, and they get expanded prior to being compiled.
    Let''s look through `rild.te` and check whether we can find some macros. They
    are distinguished and look like functions with parameters. The first macro we
    come across is the `init_daemon_domain(rild)` macro. Now, we need to find this
    macro''s definition in `sepolicy`. The m4 language uses the `define` keyword to
    declare macros, so we can search for that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有找到`type_transition`的实例，但这个关键字必须存在，类似于文件。然而，它可能隐藏在一个未展开的宏中。SELinux策略文件是用m4宏语言编写的，并且在编译之前会被展开。让我们查看`rild.te`并检查我们是否可以找到一些宏。它们是有区别的，看起来像带有参数的函数。我们遇到的第一个宏是`init_daemon_domain(rild)`宏。现在，我们需要在`sepolicy`中找到这个宏的定义。m4语言使用`define`关键字来声明宏，所以我们可以搜索它：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our macro is declared in `te_macros`, which coincidentally holds all the macros
    related to **type enforcement** (**TE**). Let''s take a look at what this macro
    does in more detail. First, its definition is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宏在`te_macros`中声明，这个文件巧合地包含了所有与**类型强制**（**TE**）相关的宏。让我们更详细地看看这个宏做了什么。首先，它的定义是：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The commented lines in the preceding code (lines starting with `#` in m4),
    state that it sets up a transition from init to the daemon domain. This sounds
    like something we want. However, both the encompassing statements are macros,
    and we need to recursively expand them. We will start with `domain_auto_trans()`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中注释的行（m4中以`#`开头的行），表示它设置了一个从init到守护进程域的转换。这听起来像是我们想要的东西。然而，这两个包含的语句都是宏，我们需要递归地展开它们。我们将从`domain_auto_trans()`开始：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The comment here indicates that we are headed in the proper direction; however,
    we need to keep expanding macros in our search. According to the comment, the
    `domain_trans()` macro allows just the transition to occur. Remember that almost
    everything in SELinux needs explicit permission from the policy in order to happen,
    including type transitions. The last statement in the macro is the one we were
    searching for:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的注释表明我们正在朝着正确的方向前进；然而，我们需要继续展开宏以进行搜索。根据注释，`domain_trans()`宏只允许发生转换。记住，在SELinux中，几乎所有的事情都需要从策略中显式获得权限才能发生，包括类型转换。宏中的最后一个语句就是我们一直在寻找的：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you expand this statement out, you''ll get:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开这个语句，你会得到：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What this statement conveys is that if you make an `exec()` syscall on a file
    with the type `rild_exec`, and the executing domain is init, then make the child
    process' domain `rild`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话传达的意思是，如果你在一个类型为`rild_exec`的文件上执行`exec()`系统调用，并且执行域是init，那么将子进程的域设置为`rild`。
- en: Explicit contexts via seclabel
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过seclabel显式上下文
- en: 'The other option for setting contexts is very straightforward. It''s hardcoding
    them with the init script in the `service` declaration. In the `service` declaration,
    as we saw in [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android Is
    Weird*, there were modifications to the init language. One of the additions is
    `seclabel`. This option just lets init explicitly change the context of the service
    to the argument given to `seclabel`. Here is an example of `adbd`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设置上下文的另一种选项非常直接。它是通过在 `service` 声明中的 init 脚本中硬编码它们来实现的。在 `service` 声明中，正如我们在第
    3 章（[第 3 章。Android 是奇怪的](ch03.html "第 3 章。Android 是奇怪的")）中看到的，“Android 是奇怪的”中进行了对
    init 语言的修改。新增的一项是 `seclabel`。此选项仅允许 init 明确将服务的上下文更改为 `seclabel` 给定的参数。以下是一个 `adbd`
    的示例：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So why use dynamic transitions on some and `seclabel` on others? The answer
    is dependent on where you're executing from. Things such as `adbd` execute early
    on from the ramdisk, and since the ramdisk really doesn't use per file labels,
    you can't set up transitions properly—the target has the same context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么在某个地方使用动态转换，而在其他地方使用 `seclabel`？答案取决于你从哪里执行。像 `adbd` 这样的东西在 ramdisk 上运行得早，由于
    ramdisk 真的没有使用每个文件的标签，因此无法正确设置转换——目标具有相同的上下文。
- en: Relabeling processes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新标记进程
- en: 'Now that we are armed with dynamic process transitions, and the ability to
    set socket contexts from init scripts is needed. Let''s attempt to relabel the
    services that are in improper contexts. We can tell if they''re improper by checking
    them against the following rules:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了动态进程转换的能力，并且需要从 init 脚本中设置套接字上下文。让我们尝试重新标记处于不恰当上下文中的服务。我们可以通过检查以下规则来判断它们是否不恰当：
- en: No other process but init should be in the init context
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 init 之外，不应有任何其他进程处于 init 上下文中
- en: No long running process should be in the `init_shell` domain
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应该在 `init_shell` 域中运行长时间运行的过程
- en: Nothing but zygote should be in the zygote domain
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: zygote 域中除了 zygote 之外不应有任何内容
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A more comprehensive test suite is part of CTS on AOSP. Refer to the Android
    CTS project for more details: (git clone) [https://android.googlesource.com/platform/cts](https://android.googlesource.com/platform/cts).
    Take note of the `./hostsidetests/security/src/android/cts/security/SELinuxHostTest.java`
    and `./tests/tests/security/src/android/security/cts/SELinux.*.java` tests.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更全面的测试套件是 AOSP 上的 CTS 的一部分。有关更多详细信息，请参阅 Android CTS 项目：（git clone）[https://android.googlesource.com/platform/cts](https://android.googlesource.com/platform/cts)。注意
    `./hostsidetests/security/src/android/cts/security/SELinuxHostTest.java` 和 `./tests/tests/security/src/android/security/cts/SELinux.*.java`
    测试。
- en: 'Let''s run some basic commands and evaluate the status of our UDOO over the
    `adb` connection:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些基本命令并评估我们的 UDOO 通过 `adb` 连接的状态：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have two processes in the improper domains. The first is `watchdogd`, and
    the second is a `sh` process. We need to find these and correct them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个不恰当的域中的进程。第一个是 `watchdogd`，第二个是一个 `sh` 进程。我们需要找到这些并纠正它们。
- en: 'We will start with the mystery `sh` program. As you can recall from the previous
    chapter, our UDOO serial console process had the context of `init_shell`, so this
    is a good suspect. Let''s check PIDs and find out. From a UDOO serial console
    execute:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从神秘的 `sh` 程序开始。如您在上一章中回忆的那样，我们的 UDOO 串行控制台进程的上下文是 `init_shell`，所以这是一个很好的嫌疑人。让我们检查
    PID 并找出。从 UDOO 串行控制台执行：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can compare this PID to the PID field in the `adb shell ps` output here (PID
    field is the third field, index 2), and as you can see, we have a match.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个 PID 与这里 `adb shell ps` 输出的 PID 字段进行比较（PID 字段是第三个字段，索引 2），如您所见，我们有一个匹配。
- en: From there, we need to find the service declaration for this. We know that it
    is in `init.rc` since it's running in `init_shell`, a type that can only be transitioned
    to by init directly as per the SELinux policy. Also, init only starts processing
    things by service declarations, so in order to be in `init_shell`, you must start
    by init via a service declaration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们需要找到这个服务的声明。我们知道它在 `init.rc` 中，因为它在 `init_shell` 中运行，这是一种只能由 init 直接转换的类型，根据
    SELinux 策略。此外，init 只通过服务声明来处理事物，因此为了在 `init_shell` 中，你必须通过服务声明由 init 启动。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Use `sesearch` to find out such things on the compiled sepolicy binary:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sesearch` 在编译好的 sepolicy 二进制文件中查找此类问题：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we search `init.rc` for the UDOO, which is in `udoo/device/fsl/imx6/etc`,
    we can `grep` its contents for `/system/bin/sh`, the command in question. If we
    do that, we will find:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `init.rc` 中搜索 UDOO，它在 `udoo/device/fsl/imx6/etc` 中，我们可以使用 `grep` 搜索 `/system/bin/sh`，即有问题的命令。如果我们这样做，我们会找到：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s look at `499` since we don''t have anything to do with Wi-Fi:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `499`，因为我们与 Wi-Fi 没有任何关系：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this is the service in question, we should be able to disable it, and verify
    that our serial connection no longer works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们要处理的服务，我们应该能够禁用它，并验证我们的串行连接不再工作：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'My live serial connection died at:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我的实时串行连接在以下位置中断：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have verified what it is, we can start it back up:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了问题所在，我们可以重新启动它：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the system back in a working state, we now need to address the best way
    to correct the label on this service. We have two options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 系统恢复到工作状态后，我们现在需要解决如何正确修正这个服务的标签。我们有两种选择：
- en: Using an explicit `seclabel` entry in `init.rc`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `init.rc` 中使用显式的 `seclabel` 条目
- en: Using a type transition
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型转换
- en: The option we will use here is the first. The reason is because init executes
    shell from time to time, and we don't want all of these in the console processes
    domain. We want least privilege to segregate the running processes. By using the
    explicit seclabel, we won't change any of the other shells that are executed along
    the way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用第一个选项。原因是 init 会时不时地执行 shell，我们不希望所有这些都在控制台进程域中。我们希望最小权限来隔离运行中的进程。通过使用显式的
    seclabel，我们不会改变沿途执行的其他 shell。
- en: 'To do this, we need to modify the `init.rc` entry for console; add:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要修改控制台（console）的 `init.rc` 条目；添加：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The proper domain for this executable is `shell`, since it should have the
    same permission set as `adb shell`. After you make this change, recompile the
    bootimage, flash, and then reboot. We can see that it is now in a shell domain.
    To verify, execute the following from a UDOO serial connection:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可执行文件的正确域是 `shell`，因为它应该具有与 `adb shell` 相同的权限集。在做出这个更改后，重新编译引导镜像（bootimage），刷写（flash），然后重启。我们可以看到它现在位于
    shell 域中。为了验证，从 UDOO 串行连接执行以下命令：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, execute the following command using `adb`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 `adb` 执行以下命令：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next one we need to take care of is `watchdogd`. The `watchdogd` process
    already has a domain and allows rules in `watchdog.te`; so we just need to add
    a `seclabel` statement and get it into this proper domain. Modify `init.rc`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要处理的是 `watchdogd`。`watchdogd` 进程已经有一个域，并且允许在 `watchdog.te` 中设置规则；所以我们只需要添加一个
    `seclabel` 语句并将其放入这个正确的域中。修改 `init.rc`：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To verify using `adb`, execute the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `adb` 进行验证，执行以下命令：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, we have made actual policy corrections that the UDOO was in need
    of. However, we need to practice the use of dynamic domain transitions. A good
    teaching example would have subshells from a shell in their own domain. Let's
    start by defining a new domain and setting up the transition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对 UDOO 所需的实际策略进行了修正。然而，我们需要练习动态域转换的使用。一个好的教学示例将会有来自其自身域的子shell。让我们首先定义一个新的域并设置转换。
- en: 'We will create a new `.te` file in `sepolicy` called `subshell.te`, and edit
    it so that its contents contain the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `sepolicy` 中创建一个新的 `.te` 文件，命名为 `subshell.te`，并编辑它，使其内容包含以下内容：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the `mmm` trick used earlier in the book can be used to compile just the
    policy Also, use `adb push` command to push the new policy to `/data/security/current/sepolicy`
    and execute `setprop` to reload the policy, just as we did in [Chapter 8](ch08.html
    "Chapter 8. Applying Contexts to Files"), *Applying Contexts to Files*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，书中之前使用过的 `mmm` 技巧可以用来编译策略。此外，使用 `adb push` 命令将新策略推送到 `/data/security/current/sepolicy`，并执行
    `setprop` 来重新加载策略，就像我们在第 8 章中做的那样，*将上下文应用于文件*。
- en: 'To test this, we should be able to type `sh`, and verify the domain transition.
    We will start by getting our current context:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们应该能够输入 `sh` 并验证域转换。我们将首先获取当前上下文：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then execute a shell by doing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过以下方式执行一个 shell：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We were able to use a dynamic type transition to get a new process in a domain.
    If you couple this with labeling files, as presented in [Chapter 8](ch08.html
    "Chapter 8. Applying Contexts to Files"), *Applying Contexts to Files,* you have
    a powerful tool to control process permissions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用动态类型转换将一个新的进程放入一个域中。如果你结合使用标签文件，如第 8 章中所述，*将上下文应用于文件*，你将拥有一个强大的工具来控制进程权限。
- en: Limitations on app labeling
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用标签的限制
- en: 'A fundamental limitation of these dynamic process transitions is that they
    require an `exec()` system call to be made. Only then can SELinux compute the
    new domain, and trigger the context switch. The only other way to do this is by
    modifying the code, which essentially is what init is doing when you specify `seclabel()`.
    The init code sets the exec context for its process, causing the next `exec` to
    end up in the specified domain. In fact, we can see this in the `init.c` code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动态进程转换的一个基本限制是它们需要执行一个`exec()`系统调用。只有在这种情况下，SELinux才能计算新的域，并触发上下文切换。另一种实现这一点的唯一方法是通过修改代码，这本质上就是当你指定`seclabel()`时init所做的事情。init代码为其进程设置执行上下文，导致下一个`exec`最终进入指定的域。实际上，我们可以在`init.c`代码中看到这一点：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the child process gets its execute context set by a call to `setexeccon()`
    before the `exec()` system call hands over control to a new binary image. In Android,
    applications are not spawned this way, and no `exec()` syscall exists in the process
    creation path; so a new mechanism will be needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，子进程在`exec()`系统调用将控制权交给新的二进制镜像之前，通过调用`setexeccon()`来设置其执行上下文。在Android中，应用程序不是以这种方式产生的，并且在进程创建路径中不存在`exec()`系统调用；因此需要一个新的机制。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to label processes via type transitions as well
    as via the `seclabel` statements. We also investigated how init manages service
    sockets, and how to properly label them. We then corrected the process contexts
    for the serial console as well as the watchdog daemon.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过类型转换以及通过`seclabel`语句来标记进程。我们还研究了init如何管理服务套接字，以及如何正确地标记它们。然后我们纠正了串行控制台以及看门狗守护进程的进程上下文。
- en: Applications in Android never have an explicit call to `exec()` to start their
    program execution. Since there is no `exec()`, we have to label applications with
    a code change. In the next chapter, we will address how this happens, and how
    applications get labeled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的应用程序永远不会有一个显式的`exec()`调用来启动它们的程序执行。由于没有`exec()`，我们必须通过代码更改来标记应用程序。在下一章中，我们将讨论这是如何发生的，以及应用程序是如何被标记的。
