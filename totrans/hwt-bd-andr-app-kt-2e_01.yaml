- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Your First App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is an introduction to Android, where you will set up your environment
    and focus on the fundamentals of Android development. By the end of this chapter,
    you will have gained the knowledge required to create an Android app from scratch
    and install it on a virtual or physical Android device.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to analyze and understand the importance of the `AndroidManifest.xml`
    file and use the Gradle build tool to configure your app and implement **user
    interface** (**UI**) elements from Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: Android is the most widely used mobile phone operating system in the world,
    with over three billion active devices. This presents great opportunities to contribute
    and make an impact by learning Android and building apps that have a global reach.
    However, for a developer who is new to Android, there are many issues you must
    contend with in order to get started learning and becoming productive.
  prefs: []
  type: TYPE_NORMAL
- en: This book will address these issues. After learning the tooling and development
    environment, you will explore fundamental practices to build Android apps. We
    will cover a wide range of real-world development challenges faced by developers
    and explore various techniques to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a basic Android project and add
    features to it. You will be introduced to the comprehensive development environment
    of Android Studio and learn about the core areas of the software to enable you
    to work productively.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio provides all the tooling for application development but not
    the knowledge. This first chapter will guide you through using the software effectively
    to build an app and configure the most common areas of an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android project with Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a virtual device and running your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Gradle to build, configure, and manage app dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/96l1D](https://packt.link/96l1D)
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android project with Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be productive in terms of building Android apps, it is essential
    to become confident with how to use **Android Studio**. This is the official **integrated
    development environment** (**IDE**) for Android development, built on JetBrains’
    **IntelliJ IDEA IDE** and developed by the Android Studio team at Google. You
    will use it throughout this course to create apps and progressively add more advanced
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The development of Android Studio has followed the development of the IntelliJ
    IDEA IDE. The fundamental features of an IDE are, of course, present, enabling
    you to optimize your code with suggestions, shortcuts, and standard refactoring.
    The programming language you will use throughout this course to create Android
    apps is Kotlin. Previously the standard language to create Android apps was Java.
  prefs: []
  type: TYPE_NORMAL
- en: Since Google I/O 2017 (the annual Google developer conference), this has been
    Google’s preferred language for Android app development. What really sets Android
    Studio apart from other Android development environments is that **Kotlin** was
    created by JetBrains, the company that created IntelliJ IDEA, the software Android
    Studio is built on. Therefore, you can benefit from established and evolving first-class
    support for Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin was created to address some of the shortcomings of Java in terms of verbosity,
    handling null types, and adding more functional programming techniques, amongst
    many other issues. As Kotlin has been the preferred language for Android development
    since 2017, taking over from Java, you will use it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips and familiarizing yourself with Android Studio will enable
    you to feel confident working on and building Android apps. So, let’s get started
    creating your first project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The installation and setup of Android Studio are covered in the *Preface*. Please
    ensure you have completed those steps before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.01 – creating an Android Studio project for your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the starting point for creating a project structure your app will be
    built upon. The template-driven approach will enable you to create a basic project
    in a short timeframe while setting up the building blocks you can use to develop
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon opening Android Studio, you will see a window asking whether you want to
    create a new project or open an existing one. Select **Create** **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you’ll enter a simple wizard-driven flow, which greatly simplifies the
    creation of your first Android project. The next screen you will see has a large
    number of options for the initial setup you’d like your app to have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Starting a project template for your app](img/B19411_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Starting a project template for your app
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to your first introduction to the Android development ecosystem. The
    word displayed in most of the project types is *Activity*. In Android, an Activity
    is a page or screen. The options you can choose from all create this initial screen
    differently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The descriptions describe how the first screen of the app will look. These are
    templates to build your app with. Select **Empty Activity** from the template
    and click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project configuration screen is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Project configuration](img/B19411_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Project configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screen configures your app. Let’s go through all the options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`com.sample.shop.myshop`). As shown in *Figure 1.2*, the `Users/MyUser/android/projects`).
    The default location will vary with the operating system you are using. By default,
    the project will be saved into a new folder with the name of the application with
    spaces removed. This results in a `MyApplication` project folder being created.
    Please change this to the `Exercise` or `Activity` that you are working on, so
    for this project, name the folder `Exercise1.01`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: **Kotlin** is Google’s preferred language for Android app development.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum SDK**: Depending on which version of Android Studio you download,
    the default might be the same as shown in *Figure 1.2* or a different version.
    Keep this the same. Most of Android’s new features are made backward compatible,
    so your app will run fine on the vast majority of older devices. However, if you
    do want to target newer devices, you should consider raising the minimum API level.
    There is a **Help Me Choose** link to a dialog that explains the feature set that
    you have access to with a view to development on different versions of Android
    and the current percentage of devices worldwide running each Android version.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use legacy android.support libraries**: Leave this unchecked. You will be
    using AndroidX libraries, which are the replacement for the support libraries
    that were designed to make features on newer versions of Android backward compatible
    with older versions, but it provides much more than this. It also contains new
    Android components called **Jetpack**, which, as the name suggests, *boosts* your
    Android development and provide a host of rich features you will want to use in
    your app, thereby simplifying common operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have filled in all these details, select `MainActivity`) in one tab
    and the layout used for the screen in the other tab (`activity_main.xml`). The
    application structure folders are in the left panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Android Studio default project](img/B19411_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Android Studio default project
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have gone through the steps to create your first Android
    app using Android Studio. This template-driven approach has shown you the core
    options you need to configure for your app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will set up a virtual device and see your app run for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual device and running your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a part of installing Android Studio, you downloaded and installed the latest
    Android **software development kit** (**SDK**) components. These included a base
    emulator, which you will configure to create a virtual device to run Android apps
    on. An emulator mimics the hardware and software features and configuration of
    a real device. The benefit is that you can make changes and quickly see them on
    your desktop while developing your app. Although virtual devices do not have all
    the features of a real device, the feedback cycle is often quicker than going
    through the steps of connecting a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Also, although you should ensure your app runs as expected on different devices,
    you can standardize it by targeting a specific device by downloading a device
    profile, even if you don’t have a real device if this is a requirement of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen you will have seen (or something similar) when installing Android
    Studio is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – SDK components](img/B19411_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – SDK components
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the SDK components that are installed and how the virtual
    device fits in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android Emulator**: This is the base emulator, which we will configure to
    create virtual devices of different Android makes and models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Build-Tools**: Android Studio uses the build tools to build your
    app. This process involves compiling, linking, and packaging your app to prepare
    it for installation on a device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Platform**: This is the version of the Android platform that
    you will use to develop your app. The platform refers to the API level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Platform-Tools**: These are tools you can use, ordinarily, from
    the command line, to interact with and debug your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Tools**: In contrast to the platform tools, these are tools that
    you use predominantly from within Android Studio in order to accomplish certain
    tasks, such as the virtual device for running apps and the SDK manager to download
    and install platforms and other components of the SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel x86 Emulator Accelerator (HAXM installer)**: If your OS provides it,
    this is a feature at the hardware level of your computer you will be prompted
    to enable, which allows your emulator to run more quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SDK Patch Applier v4**: As newer versions of Android Studio become available,
    this enables patches to be applied to update the version you are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this knowledge, let’s start with the next exercise of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.02 – setting up a virtual device and running your app on it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up an Android Studio project to create our app in *Exercise 1.01*, *Creating
    an Android Studio project for your app*, and we are now going to run it on a virtual
    device. You can also run your app on a real device, but you will use a virtual
    device in this exercise. This process is a continuous cycle while working on your
    app. Once you have implemented a feature, you can verify its look and behavior
    as you require.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will create a single virtual device, but you should
    ensure you run your app on multiple devices to verify that its look and behavior
    are consistent. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the toolbar in Android Studio, you will see two drop-down boxes next to
    each other with **app** and **No** **devices** pre-selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The Android Studio toolbar](img/B19411_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The Android Studio toolbar
  prefs: []
  type: TYPE_NORMAL
- en: '**app** is the configuration of the app that we will run. As we haven’t set
    up a virtual device yet, it says **No devices**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a virtual device, click on **Device Manager**, as shown
    in *Figure 1**.5*, to open the virtual devices window/screen. The option to do
    this can also be accessed from the **Tools** menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Device Manager in the Tools menu](img/B19411_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Device Manager in the Tools menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the button or toolbar option to open the **Device Manager** window and
    click the **Create device** button, as shown in *Figure 1**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – The Device Manager window](img/B19411_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – The Device Manager window
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be presented with a screen, as shown in *Figure 1**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Device definition creation](img/B19411_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Device definition creation
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to choose the **Pixel 6** device. The real (non-virtual device)
    Pixel range of devices is developed by Google and has access to the most up-to-date
    versions of the Android platform. Once selected, click the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – System Image](img/B19411_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – System Image
  prefs: []
  type: TYPE_NORMAL
- en: The **Tirimasu** name displayed here is the initial code/release name for Android
    13\. Select the latest system image available. The **Target** column might also
    show **(Google Play)** or **(Google APIs)** in the name. Google APIs mean that
    the system image comes pre-installed with Google Play Services.
  prefs: []
  type: TYPE_NORMAL
- en: This is a rich feature set of Google APIs and Google apps that your app can
    use and interact with. On first running the app, you will see apps such as Maps
    and Chrome instead of a plain emulator image. A Google Play system image means
    that, in addition to the Google APIs, the Google Play app will also be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should develop your app with the latest version of the Android platform
    to benefit from the latest features. On first creating a virtual device, you will
    have to download the system image. If a **Download** link is displayed next to
    **Release Name**, click on it, and wait for the download to complete. Select the
    **Next** button to see the virtual device you have set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Virtual device configuration](img/B19411_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Virtual device configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Finish**, and your virtual device will be created. You will then see
    your device highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Virtual devices listed](img/B19411_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Virtual devices listed
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the play arrow button under the **Actions** column to run the virtual
    device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Virtual device launched](img/B19411_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Virtual device launched
  prefs: []
  type: TYPE_NORMAL
- en: You will then see the virtual device running within Android Studio in the **Emulator**
    tool window. Now that you’ve created the virtual device and it’s running, you
    can go back into Android Studio to run your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual device you have set up and started will be selected. Press the
    green triangle/play button to launch your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.13 – App launch configuration](img/B19411_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – App launch configuration
  prefs: []
  type: TYPE_NORMAL
- en: This will load the app into the emulator as shown in *Figure 1**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – The app running on a virtual device](img/B19411_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – The app running on a virtual device
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have gone through the steps to create a virtual device
    and run the app you created on it. The Android Virtual Device Manager, which you
    have used to do this, enables you to create the device (or range of devices) you
    would like to target your app for. Running your app on the virtual device allows
    a quick feedback cycle to verify how a new feature development behaves and that
    it displays the way you expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will explore the `AndroidManifest.xml` file of your project, which
    contains the information and configuration of your app.
  prefs: []
  type: TYPE_NORMAL
- en: The Android manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app you have just created, although simple, encompasses the core building
    blocks that you will use in all of the projects you create. The app is driven
    from the `AndroidManifest.xml` file, a manifest file that details the contents
    of your app. It is located at `app` | `manifests` | `AndroidManifest.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A typical manifest file, in general terms, is a top-level file that describes
    the enclosed files or other data and associated metadata that forms a group or
    unit. The Android manifest applies this concept to your Android app as an XML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Android app has an application class that allows you to configure the
    app. After the `<application>` element opens, you define your app’s components.
    As we have just created our app, it only contains the first screen shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next child XML node specified is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Android uses intents as a mechanism for interacting with apps and system components.
    Intents get sent, and the intent filter registers your app’s capability to react
    to these intents. `<android.intent.action.MAIN>` is the main entry point into
    your app, which, as it appears in the enclosing XML of `.MainActivity`, specifies
    that this screen will be started when the app is launched. `Android.intent.category.LAUNCHER`
    states that your app will appear in the launcher of your user’s device.
  prefs: []
  type: TYPE_NORMAL
- en: As you have created your app from a template, it has a basic manifest that will
    launch the app and display an initial screen at startup through an `Activity`
    component. Depending on which other features you want to add to your app, you
    may need to add permissions in the Android manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions are grouped into three different categories: normal, signature,
    and dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: These permissions include accessing the network state, Wi-Fi, the
    internet, and Bluetooth. These are usually permitted without asking for the user’s
    consent at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: These permissions are shared by the same group of apps that
    must be signed with the same certificate. This means these apps can share data
    freely, but other apps can’t get access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dangerous**: These permissions are centered around the user and their privacy,
    such as sending SMS, access to accounts and location, and reading and writing
    to the filesystem and contacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions have to be listed in the manifest, and in the case of dangerous
    permissions, from Android Marshmallow API 23 (Android 6 Marshmallow) onward, you
    must also ask the user to grant the permissions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will configure the Android Manifest. Detailed documentation
    on this file can be found at [https://developer.android.com/guide/topics/manifest/manifest-intro](https://developer.android.com/guide/topics/manifest/manifest-intro).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.03 – configuring the Android manifest internet permission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key permission that most apps require is access to the internet. This is
    not added by default. In this exercise, we will fix that and, in the process,
    load a `WebView`, which enables the app to show web pages. This use case is very
    common in Android app development as most commercial apps will display a privacy
    policy, terms and conditions, and so on. As these documents are likely common
    to all platforms, the usual way to display them is to load a web page. To do this,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio project for* *your app*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch tabs to the `MainActivity` class. From the main project window, it’s
    located at `app` | `java` | `com` | `example` | `myapplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can change what the project window displays by opening up the **Tool**
    window by selecting **View** | **Tool Windows** | **Project** – this will select
    **Project** view. The drop-down options on the top of the **Project** window allow
    you to change the way you view your project, with the most commonly used displays
    being **Project** and **Android**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – The Tool Windows drop-down menu](img/B19411_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – The Tool Windows drop-down menu
  prefs: []
  type: TYPE_NORMAL
- en: 'On opening the `MainActivity` class, you’ll see that it has the following content
    or similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You’ll examine the contents of this file in more detail in the next section
    of this chapter, but for now, you just need to be aware that the `setContentView(R.layout.activity_main)`
    statement sets the layout of the UI you saw when you first ran the app in the
    virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to change this to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, you are replacing the layout file with `WebView`. The `val` keyword is a
    read-only property reference, which can’t be changed once it has been set. JavaScript
    needs to be enabled in `WebView` to execute JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not setting the type, but Kotlin has type inference, so it will infer
    the type if possible. So, specifying the type explicitly with `val webView: WebView
    = WebView(this)` is not necessary. Depending on which programming languages you
    have used in the past, the order of defining the parameter name and type may or
    may not be familiar. Kotlin follows Pascal notation, that is, name followed by
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the app up, and the text will appear as shown in the screenshot here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.16 – No internet permission error message](img/B19411_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – No internet permission error message
  prefs: []
  type: TYPE_NORMAL
- en: This error occurs because there is no `INTERNET` permission added to your `AndroidManifest.xml`
    file. (If you get the `net::ERR_CLEARTEXT_NOT_PERMITTED` error, this is because
    the URL you are loading into `WebView` is not HTTPS, and non-HTTPS traffic is
    disabled from API level 28, Android 9.0 Pie and above).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s fix that by adding the `INTERNET` permission to the manifest. Open up
    the Android manifest and add the following above the `<``application>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can find the full Android manifest file with the permission added here:
    [https://packt.link/smzpl](https://packt.link/smzpl)'
  prefs: []
  type: TYPE_NORMAL
- en: Uninstall the app from the virtual device before running up the app again. You
    need to do this, as app permissions can sometimes get cached.
  prefs: []
  type: TYPE_NORMAL
- en: Do this by long-pressing on the app icon and selecting the **App Info** option
    that appears and then pressing the Bin icon with the **Uninstall** text below
    it. Alternatively, long press the app icon and then drag it to the Bin icon with
    the **Uninstall** text beside it in the top-right corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the app again and see the web page appear in `WebView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.17 – App displaying WebView](img/B19411_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17 – App displaying WebView
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you learned how to add a permission to the manifest. The Android
    Manifest can be thought of as a table of contents of your app. It lists all the
    components and permissions your app uses. As you have seen from starting the app
    from the launcher, it also provides the entry points into your app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore the Android build system, which uses the
    Gradle build tool to get your app up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gradle to build, configure, and manage app dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the course of creating this project, you have principally used the Android
    platform SDK. The necessary Android libraries were downloaded when you installed
    Android Studio. However, these are not the only libraries that are used to create
    your app. To configure and build your Android project or app, a build tool called
    **Gradle** is used.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle is a multi-purpose build tool that Android Studio uses to build your
    app. By default, Android Studio uses Groovy, a dynamically typed **Java virtual
    machine** (**JVM**) language, to configure the build process and allows easy dependency
    management so you can add libraries to your project and specify the versions.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio can also be configured to use Kotlin to configure builds, but
    as the default language is Groovy, you will be using this. The files that this
    build and configuration information is stored in are named `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: When you first create your app, there are two `build.gradle` files, one at the
    root/top level of the project and one specific to your app in the app `module`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The project-level build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now have a look at the project-level `build.gradle` file. This is where
    you set up all the root project settings, which can be applied to sub-modules/projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle works on a plugin system, so you can write your own plugin that does
    a task or series of tasks and plug it into your build pipeline. The three plugins
    listed previously do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.android.application`: This adds support to create an Android application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.android.library`: This enables sub-projects/modules to be Android libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.jetbrains.kotlin.android`: This provides integration and language support
    for Kotlin in the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apply false` statement enables these plugins only to sub-projects/modules,
    and not the project’s root level. The `version '7.3.1'` specifies the plugin version,
    which is applied to all sub-projects/modules.
  prefs: []
  type: TYPE_NORMAL
- en: The app-level build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `build.gradle` app is specific to your project configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The plugins for Android and Kotlin, detailed in the root `build.gradle` file,
    are applied to your project here by ID in the `plugins` lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `android` block, provided by the `com.android.application` plugin, is where
    you configure your Android-specific configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace`: This is set from the package name you specified when creating
    the project. It will be used for generating build and resource identifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileSdk`: This is used to define the API level the app has been compiled
    with, and the app can use the features of this API and lower.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultConfig`: This is the base configuration of your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applicationId`: This is set to your app’s package and is the app identifier
    that is used on Google Play to uniquely identify your app. It can be changed to
    be different from the package name if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minSdk`: This is the minimum API level your app supports. This will filter
    out your app from being displayed in Google Play for devices that are lower than
    this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetSdk`: This is the API level you are targeting. This is the API level
    your built app is intended to work and has been tested with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versionCode`: This specifies the version code of your app. Every time an update
    needs to be made to the app, the version code needs to be increased by one or
    more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versionName`: A user-friendly version name that usually follows semantic versioning
    of *X.Y.Z*, where *X* is the major version, *Y* is the minor version, and *Z*
    is the patch version, for example, *1.0.3*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testInstrumentationRunner`: This is the test runner to use for your UI tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildTypes`: Under `buildTypes`, a release is added that configures your app
    to create a `release` build. The `minifyEnabled` value, if set to `true`, will
    shrink your app size by removing any unused code, as well as obfuscating your
    app. This obfuscation step changes the name of the source code references to values
    such as `a.b.c()`. This makes your code less prone to reverse engineering and
    further reduces the size of the built app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileOptions`: This is the language level of the Java source code (`sourceCompatibility`)
    and byte code (`targetCompatibility`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kotlinOptions`: This is the `jvm` library the `kotlin gradle` plugin should
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `dependencies` block specifies the libraries your app uses on top of the
    Android platform SDK, as shown here (with added comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependencies follow the Maven `groupId`, `artifactId`, and `versionId`
    separated by `:`. So, as an example, the compatible support library specified
    earlier is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `groupId` is `android.appcompat`, `artifactId` is `appcompat`, and `versionId`
    is `1.5.1`. The build system locates and downloads these dependencies to build
    the app from the `repositories` block detailed in the `settings.gradle` file explained
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dependency versions specified in the previous code section and in the following
    sections of this and other chapters are subject to change and are updated over
    time, so they are likely to be higher when you create these projects.
  prefs: []
  type: TYPE_NORMAL
- en: The `implementation` notation for adding these libraries means that their internal
    dependencies will not be exposed to your app, making compilation faster.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `androidx` components are added as dependencies rather than in the
    Android platform source. This is so that they can be updated independently from
    Android versions. `androidx` contains the suite of Android Jetpack libraries and
    the repackaged support library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next Gradle file to examine is `settings.gradle`, which initially looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On first creating a project with Android Studio, there will only be one module,
    `app`, but when you add more features, you can add new modules that are dedicated
    to containing the source of a feature rather than packaging it in the main `app`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: These are called **feature modules**, and you can supplement them with other
    types of modules, such as shared modules, which are used by all other modules,
    like a networking module. This file also contains the repositories of the plugins
    and dependencies to download from in separate blocks for plugins and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the value of `RepositoriesMode.FAIL_ON_PROJECT_REPOS` ensures all dependencies
    repositories are defined here; otherwise, a build error will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.04 – exploring how Material Design is used to theme an app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about Google’s new design language, **Material
    Design**, and use it to load a Material Design-themed app. Material Design is
    a design language created by Google that adds enriched UI elements based on real-world
    effects such as lighting, depth, shadows, and animations. Perform the following
    steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio project for* *your app*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, look at the `dependencies` block and find the Material Design dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `themes.xml` file located at `app` | `src` | `main` | `res`
    | `values` | `themes.xml`: There is also a `themes.xml` file in the `values-night`
    folder used for a dark mode, which we will explore later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the parent of `Theme.MyApplication` is `Theme.MaterialComponents.DayNight.DarkActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: The Material Design dependency added in the `dependencies` block is being used
    here to apply the theme of the app. One of the key differences that `AppCompat`
    themes that preceded them is the ability to provide variations to the primary
    and secondary colors of your app.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `colorPrimaryVariant` enables you to add a tint to the primary
    color, which can be either lighter or darker than the `colorPrimary` color. In
    addition, you can style view element colors in the foreground of your app with
    `colorOnPrimary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together these bring cohesive branding to theme your app. To see this in effect,
    make the following changes to invert the primary and secondary colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app now, and you will see the app themed differently. The action bar
    and status bar have changed background color in contrast to the default Material
    themed app, as shown in *Figure 1**.18*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18 – App with primary and secondary colors inverted](img/B19411_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – App with primary and secondary colors inverted
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ve learned how Material Design can be used to theme an
    app. As you are currently only displaying `TextView` on the screen, it is not
    clear what benefits material design provides, but this will change when you start
    using Material UI design widgets more.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned how the project is built and configured, in the next
    section, you’ll explore the project structure in detail, learn how it has been
    created, and gain familiarity with the core areas of the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Android application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered how the Gradle build tool works, we’ll explore the
    rest of the project. The simplest way to do this is to examine the folder structure
    of the app. There is a tool window at the top left of Android Studio called **Project**,
    which allows you to browse the contents of your app.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it is set to **open**/**selected** when your Android project is
    first created. When you select it, you will see a view similar to the screenshot
    in *Figure 1**.19*. If you can’t see any window bars on the left-hand side of
    the screen, then go to the top toolbar and select **View** | **Appearance** |
    **Tool Window Bars** and make sure it is ticked.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different options for how to browse your project, but `app` folder
    structure, so let’s take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of these files with more detail about the most important
    ones. On opening it, you will see that it consists of the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Overview of the files and folder structure in the app](img/B19411_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Overview of the files and folder structure in the app
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin file (`MainActivity`), which you’ve specified as running when the
    app starts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statements include the libraries and the source of what this activity
    uses. The `class MainActivity : AppCompatActivity()` class header creates a class
    that extends `AppCompatActivity`. In Kotlin, the `:` character is used for both
    deriving from a class (also known as inheritance) and implementing an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity` derives from `androidx.appcompat.app.AppCompatActivity`, which
    is the backward-compatible activity designed to make your app work on older devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android activities have many callback functions you can override at different
    points of the activity’s life. This is known as the `onCreate` function as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `override` keyword in Kotlin specifies that you are providing a specific
    implementation for a function defined in the parent class. The `fun` keyword (as
    you may have guessed) stands for *function*. The `savedInstanceState: Bundle?`
    parameter is Android’s mechanism for restoring previously saved state. For this
    simple activity, you haven’t stored any state, so this value will be `null`. The
    question mark, `?`, that follows the type declares that this type can be `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `super.onCreate(savedInstanceState)` line calls through to the overridden
    method of the base class, and finally, `setContentView(R.layout.activity_main)`
    loads the layout we want to display in the activity; otherwise, it would be displayed
    as a blank screen as no layout has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at some other files (*Figure 1**.19*) present in the folder
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExampleInstrumentedTest`: This is an example UI test. You can check and verify
    the flow and structure of your app by running tests on the UI when the app is
    running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExampleUnitTest`: This is an example unit test. An essential part of creating
    an Android app is writing unit tests to verify that the source code works as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ic_launcher_background.xml` and `ic_launcher_foreground.xml`: These two files
    together make up the launcher icon of your app in vector format, which will be
    used by the `ic_launcher.xml` launcher icon file in Android API 26 (Oreo) and
    above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activity_main.xml`: This is the layout file that was created by Android Studio
    when we created the project. It is used by `MainActivity` to draw the initial
    screen content, which appears when the app runs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Screen displays in Android can be created using XML or Jetpack Compose, which
    uses a declarative API to dynamically build your UI. You will learn Jetpack Compose
    in [*Chapter 9*](B19411_09.xhtml#_idTextAnchor499). For XML, the documents start
    with an XML header followed by a top-level `ViewGroup` (which here is `ConstraintLayout`)
    and then one or more nested `Views` and `ViewGroups`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConstraintLayout` `ViewGroup` allows very precise positioning of views
    on a screen, constraining views with parent and sibling views, guidelines, and
    barriers. Detailed documentation on `ConstraintLayout` can be found at [https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout](https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout).
  prefs: []
  type: TYPE_NORMAL
- en: '`TextView`, currently the only child view of `ConstraintLayout`, displays text
    on the screen through the `android:text` attribute. The horizontal positioning
    of the view is done by constraining the view to both the start and end of the
    parent, which centers the view horizontally as both constraints are applied.'
  prefs: []
  type: TYPE_NORMAL
- en: From start to end, left-to-right languages (`ltr`) are read left to right, while
    `non ltr` languages are read right to left. The view is positioned vertically
    in the center by constraining the view to both the top and the bottom of its parent.
    The result of applying all four constraints centers `TextView` both horizontally
    and vertically within `ConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three XML namespaces in the `ConstraintLayout` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xmlns:android`: This refers to the Android-specific namespace and it is used
    for all attributes and values within the main Android SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlns:app`: This namespace is for anything not in the Android SDK. So, in
    this case, `ConstraintLayout` is not part of the main Android SDK but is added
    as a library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmnls:tools`: This refers to a namespace used for adding metadata to the XML,
    which indicates where the layout is used (`tools:context=".MainActivity"`). It
    is also used to show sample text visible in previews.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two most important attributes of an Android XML layout file are `android:layout_width`
    and `android:layout_height`.
  prefs: []
  type: TYPE_NORMAL
- en: These can be set to absolute values, usually of density-independent pixels (known
    as `dip` or `dp`) that scale pixel sizes to be roughly equivalent on different
    density devices. More commonly, however, these attributes have the `wrap_content`
    or `match_parent` values set for them. `wrap_content` will be as big as required
    to only enclose its contents. `match_parent` will be sized according to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: There are other `ViewGroups` you can use to create layouts. For example, `LinearLayout`
    lays out views vertically or horizontally, `FrameLayout` is usually used to display
    a single child view, and `RelativeLayout` is a simpler version of `ConstraintLayout`,
    which lays out views positioned relative to the parent and sibling views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ic_launcher.webp` files are the `.webp` launcher icons that have an icon
    for every different density of devices. This image format was created by Google
    and has greater compression compared to the `.png` images. As the minimum version
    of Android we are using is API 21: Android 5.0 (Jelly Bean), these `.webp` images
    are included, as support for the launcher vector format was not introduced until
    Android API 26 (Oreo).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ic_launcher.xml` file uses the vector files (`ic_launcher_background.xml`
    and `ic_launcher_foreground.xml`) to scale to different density devices in Android
    API 26 (Oreo) and above.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To target different density devices on the Android platform, besides each one
    of the `ic_launcher.png` icons, you will see in brackets the density it targets.
    As devices vary widely in their pixel densities, Google created density buckets
    so that the correct image would be selected to be displayed depending on how many
    dots per inch the device has.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different density qualifiers and their details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nodpi`: Density-independent resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldpi`: Low-density screens of 120 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi`: Medium-density screens of 160 dpi (the baseline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi`: High-density screens of 240 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xhdpi`: Extra-high-density screens of 320 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxhdpi`: Extra-extra-high-density screens of 480 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxxhdpi`: Extra-extra-extra-high-density screens of 640 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tvdpi`: Resources for televisions (approx 213 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseline density bucket was created at `160` dots per inch for medium-density
    devices and is called `160` dots/pixels, and the largest display bucket is `xxxhdpi`,
    which has `640` dots per inch. Android determines the appropriate image to display
    based on the individual device.
  prefs: []
  type: TYPE_NORMAL
- en: So, the Pixel 6 emulator has a density of approximately `411dpi`, so it uses
    resources from the extra-extra-high-density bucket (`xxhdpi`), which is the closest
    match. Android has a preference for scaling down resources to best match density
    buckets, so a device with `400dpi`, which is halfway between the `xhdpi` and `xxhdpi`
    buckets, is likely to display the `480dpi` asset from the `xxhdpi` bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create alternative bitmap drawables for different densities, you should
    follow the `3:4:6:8:12:16` scaling ratio between the six primary densities. For
    example, if you have a bitmap drawable that’s `48x48` pixels for medium-density
    screens, all the different sizes should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`36x36` (`0.75x`) for low density (`ldpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`48x48` (`1.0x` baseline) for medium density (`mdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`72x72` (`1.5x`) for high density (`hdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`96x96` (`2.0x`) for extra-high density (`xhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`144x144` (`3.0x`) for extra-extra-high density (`xxhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192x192` (`4.0x`) for extra-extra-extra-high density (`xxxhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a comparison of these physical launcher icons per density bucket, refer
    to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Comparison of principal density bucket launcher image sizes](img/Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Comparison of principal density bucket launcher image sizes
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Launcher icons are made slightly larger than normal images within your app as
    they will be used by the device’s launcher. As some launchers can scale up the
    image, this ensures there is no pixelation and blurring of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are going to look at some of the resources the app uses. These are referenced
    in XML files and keep the display and formatting of your app consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `colors.xml` file, you define the colors you want to use in your app
    in hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The format is based on the `#00` is completely transparent through to `#FF`,
    which is completely opaque. For the colors, `#00` means none of the color is added
    to make up the composite color, and `#FF` means all of the color is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no transparency is required, you can omit the first two characters. So,
    to create fully blue and 50% transparent blue colors, here’s the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strings.xml` file displays all the text displayed in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can use hardcoded strings in your app, but this leads to duplication and
    also means you cannot customize the text if you want to make the app multilingual.
    By adding strings as resources, you can also update the string in one place if
    it is used in different places in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common styles you would like to use throughout your app are added to the `themes.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to apply style information directly to views by setting `android:textStyle="bold"`
    as an attribute on `TextView`. However, you would have to repeat this in multiple
    places for every `TextView` you wanted to display in bold. Furthermore, when you
    start to have multiple style attributes added to individual views, it adds a lot
    of duplication and can lead to errors when you want to make a change to all similar
    views and miss changing a style attribute in one view.
  prefs: []
  type: TYPE_NORMAL
- en: If you define a style, you only have to change the style, and it will update
    all the views that have that style applied to them. A top-level theme was applied
    to the application tag in the `AndroidManifest.xml` file when you created the
    project and is referred to as a theme that styles all views contained within the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The colors you have defined in the `colors.xml` file are used here. In effect,
    if you change one of the colors defined in the `colors.xml` file, it will now
    propagate to style the app as well.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now explored the core areas of the app. You have added the `TextView`
    views to display labels, headings, and blocks of text. In the next exercise, you
    will be introduced to UI elements allowing the user to interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.05 – adding interactive UI elements to display a bespoke greeting
    to the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to add the capability of users to add and edit
    text and then submit this information to display a bespoke greeting with the entered
    data. You will need to add editable text views to achieve this. The `EditText`
    view is typically how this is done and can be added in an XML layout file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses an Android `TextAppearance.AppCompat.Title` style to display a title,
    as shown in *Figure 1**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – EditText with a hint](img/B19411_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – EditText with a hint
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is perfectly fine to enable the user to add/edit text, the `TextInputEditText`
    material and its wrapper `TextInputLayout` view give some polish to the `EditText`
    display. Here’s how `EditText` can be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22 – The TextInputLayout/TextInputEditText material with a hint](img/B19411_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – The TextInputLayout/TextInputEditText material with a hint
  prefs: []
  type: TYPE_NORMAL
- en: '`TextInputLayout` allows us to create a label for the `TextInputEditText` view
    and does a nice animation when the `TextInputEditText` view is focused (moving
    to the top of the field) while still displaying the label. The label is specified
    with `android:hint`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will change the `Hello World` text in your app so a user can enter their
    first and last name and further display a greeting by pressing a button. To do
    this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio project for your app*, called My Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the labels and text you are going to use in your app by adding these
    entries to `app` | `src` | `main` | `res` | `values` | `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will update our styles to use in the layout by adding the following
    styles to the `app` | `src` | `main` | `res` | `values` | `themes.xml` theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The parents of some of the styles refer to Material styles, so these styles
    will be applied directly to the views and the styles specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added the styles we want to apply to views in the layout and
    the text, we can update the layout in `activity_main.xml` in the `app` | `src`
    | `main` | `res` | `layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app and see the look and feel. You have added IDs for all the views
    so they can be constrained against their siblings and also provide a way in the
    activity to get the values of the `TextInputEditText` views. The `style="@style.."`
    notation applies the style from the `themes.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you select one of the `TextInputEditText` views, you’ll see the label animated
    and move to the top of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23 – The TextInputEditText fields with label states with no focus
    and with focus](img/B19411_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23 – The TextInputEditText fields with label states with no focus and
    with focus
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must add the interaction with the view in our activity. The layout by
    itself doesn’t do anything other than allow the user to enter text into the `EditText`
    fields. Clicking the button at this stage will not do anything. You will accomplish
    this by capturing the entered text by using the IDs of the form fields when the
    button is pressed and then using the text to populate a `TextView` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity` and complete the next steps to process the entered text
    and use this data to display a greeting and handle any form input errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` function, set a `ClickListener` on the button so we can respond
    to the button click and retrieve the form data by updating `MainActivity` to what
    is displayed in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, check that the trimmed names are not empty and format the name using
    Kotlin’s string templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, show a message if the form fields have not been filled in correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Toast` specified is a small text dialog that appears above the main layout
    for a short time to display a message to the user before disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and enter text into the fields and verify that a greeting message
    is shown when both text fields are filled in, and a pop-up message appears with
    why the greeting hasn’t been set if both fields are not filled in. You should
    see the following display for each one of these cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.24 – The app with the name filled in correctly and with an error](img/B19411_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24 – The app with the name filled in correctly and with an error
  prefs: []
  type: TYPE_NORMAL
- en: The full exercise code can be viewed at [https://packt.link/UxbOu](https://packt.link/UxbOu).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding exercise introduced you to adding interactivity to your app with
    the `EditText` fields that a user can fill in, adding a click listener to respond
    to button events, and performing some validation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Views in layout files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The established way to access Views in layout files is to use `findViewById`
    with the name of the View’s ID. So the `enter_button` button is retrieved by the
    `findViewById<Button>(R.id.enter_button)` syntax after the layout has been set
    in `setContentView(R.layout.activity_main)` in the Activity.
  prefs: []
  type: TYPE_NORMAL
- en: You will use this technique in this course. Google has also introduced `findViewById`,
    which creates a binding class to access Views and has the advantage of null and
    type safety. You can read about this at [https://developer.android.com/topic/libraries/view-binding](https://developer.android.com/topic/libraries/view-binding).
  prefs: []
  type: TYPE_NORMAL
- en: Further input validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validating user input is a key concept in processing user data, and you must
    have seen it in action many times when you’ve not filled in a required field in
    a form. This is what the previous exercise validated when it checked that the
    user had entered values into both the first name and last name fields.
  prefs: []
  type: TYPE_NORMAL
- en: There are other validation options that are available directly within XML view
    elements. Let’s say, for instance, you wanted to validate an IP address entered
    into a field. You know that an IP address can be four numbers separated by periods/dots
    where the maximum length of a number is three.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the maximum number of characters that can be entered into the field is
    `15`, and only numbers and periods/dots can be entered. Two XML attributes can
    help us with the validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:digits="0123456789."`: This restricts the characters that can be entered
    into the field by listing all the permitted individual characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:maxLength="15"`: This restricts the user from entering more than the
    maximum number of characters an IP address will consist of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, this is how you can display this in a form field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This validation restricts the characters that can be input and the maximum length.
    Additional validation would be required on the sequence of characters and whether
    they are periods/dots or numbers, as per the IP address format, but it is the
    first step to assist the user in entering the correct characters. There is also
    an `android:inputType` XML attribute, which can be used to specify permitted characters
    and configure the input options, `android:inputType="textPassword"`, for example,
    ensures that the characters entered are hidden. `android:inputType="Phone"` is
    the input method for a phone number.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge gained from the chapter, let’s start with the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1.01 – producing an app to create RGB colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will look into a scenario that uses validation. Suppose
    you have been tasked with creating an app that shows how the RGB channels of red,
    green, and blue are added together in the RGB color space to create a color.
  prefs: []
  type: TYPE_NORMAL
- en: Each RGB channel should be added as two hexadecimal characters, where each character
    can be a value of 0–9 or A–F. The values will then be combined to produce a six-character
    hexadecimal string that is displayed as a color within the app.
  prefs: []
  type: TYPE_NORMAL
- en: This activity aims to produce a form with editable fields in which the user
    can add two hexadecimal values for each color. After filling in all three fields,
    the user should click a button that takes the three values and concatenates them
    to create a valid hexadecimal color string. This should then be converted to a
    color and displayed in the UI of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio project for* *your app*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Title` constrained to the top of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a brief description to the user on how to complete the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three material `TextInputLayout` fields wrapping three `TextInputEditText`
    fields that appear under `Title`. These should be constrained so that each view
    is above the other (rather than to the side). Name the `TextInputEditText` fields
    `Red Channel`, `Green Channel`, and `Blue Channel`, respectively, and add a restriction
    to each field to allow entry only of two characters and add hexadecimal characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button that takes the inputs from the three color fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a view that displays the produced color in the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, display the RGB color created from the three channels in the layout
    when the button is pressed and all input is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final output should look like this (the color will vary depending on the
    inputs):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25 – Output when the color is displayed](img/B19411_01_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.25 – Output when the color is displayed
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When loading all completed projects from the GitHub repository for this course
    into Android Studio for the first time, do *not* open the project using **File**
    | **Open** from the top menu. Always use **File** | **New** | **Import Project**.
    This ensures the app builds correctly. When opening projects after the initial
    import, you can use **File** | **Open** or **File** | **Open Recent**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot about the foundations of Android development.
    You started with how to create Android projects using Android Studio and then
    created and ran apps on a virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then progressed by exploring the `AndroidManifest` file, which details
    the contents of your app and the permission model, followed by an introduction
    to Gradle and the process of adding dependencies and building your app.
  prefs: []
  type: TYPE_NORMAL
- en: This was then followed by going into the details of an Android application and
    the files and folder structure. Layouts and views were introduced, and exercises
    iterated to illustrate how to construct UIs with an introduction to Google’s Material
    Design.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will build on this knowledge by learning about the activity
    lifecycle, activity tasks, and launch modes, persisting and sharing data between
    screens, and how to create robust user journeys through your apps.
  prefs: []
  type: TYPE_NORMAL
- en: '| **mdpi** | **hdpi** | **xhdpi** | **xxhdpi** | **xxxhdpi** |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/Image98888.png) | ![A picture containing application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/Image98904.png) | ![A picture containing
    text, sign
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/Image98913.png) | ![A picture containing
    text, sign
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/Image98922.png) | ![A picture containing
    text, sign
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/Image98931.png) |
  prefs: []
  type: TYPE_NORMAL
