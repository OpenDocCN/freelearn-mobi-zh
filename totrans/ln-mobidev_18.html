<html><head></head><body>
        

                            
                    <h1 class="header-title">Continuous Deployment</h1>
                
            
            
                
<p>In this chapter, we will see how we can organize a workflow in which we automate the process of testing and delivering your app. You can do this for both the ad hoc and the public releases of your app. To make the build-measure-feedback loop really work for you, you need to release early and often.</p>
<p>You can install Jenkins or TeamCity on a build server or another dedicated machine to make a new build of your app each time a new feature becomes available. Basically it comes down to that, but there are many interesting strategies to consider. For example, what is your branching strategy (Git workflow)? Do you want to run unit or UI-tests on the build server? How can you support variants (Android) or targets (iOS) for your app? Let's find out in this chapter.</p>
<p>We will have a look at various tools that can help us with the ad hoc distribution of the app. Some of them can also help you with the deployment of your app to the Play Store or to the App Store.</p>
<p>Specifically, in this chapter we will cover the following topics:</p>
<ul>
<li>Learning the benefits of an automated workflow</li>
<li>Seeing what Continuous Integration, Continuous Delivery, and Continuous Deployment are about</li>
<li>Figuring out how a good branching strategy can help you to get things done</li>
<li>Learning about <strong>TeamCity</strong> and <strong>Jenkins</strong></li>
<li>Having a look at build variants or build targets to support different versions of an app</li>
<li>Examining how <strong>Gradle</strong> can help us create different build flavors and types</li>
<li>Seeing how we can distribute the app using <strong>Fastlane</strong>, <strong>Fabric</strong>, or <strong>HockeyApp</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous Deployment = Continuous Integration and Delivery</h1>
                
            
            
                
<p>Why are Continuous Integration and Continuous Delivery important in the first place? There are number of answers to this question. One of them is that you need feedback as early as possible. Since you also want to ensure a certain quality level, there may be some friction here. Distributing and testing your app will take a large amount of time, however, you also need to release early and often.</p>
<p>A build server can help you to accomplish this goal, because a build server can, among other things, verify if your code compiles and if your tests still succeed. In addition, it can distribute the app to beta testers or to the App or Play Store. At a specific time, or each time a new feature has been implemented, the build server will be triggered to perform these and other tasks.</p>
<p>Having a smart-branch strategy is required if you want to set up a Continuous Deployment environment. It can also save you a lot of trouble. Here is an example of such an environment:</p>
<div><img class=" image-border" height="135" src="img/a2309370-b420-47b7-8a46-916f25ad4b07.png" width="456"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous Integration</h1>
                
            
            
                
<p>Typically, this event will be triggered when changes have been committed and pushed to a repository. The build server obtains the source from a specific repository and branch. It tries to build the code and it performs automated quality checks using <strong>SonarQube</strong>, for example, (QA).</p>
<p>SonarQube is a great tool to measure code quality. It is an automated solution so it cannot fully replace code reviews, however, it is capable of finding issues that may be or may not become an issue for the quality or performance of your app.</p>
<p>SonarQube will take care of:</p>
<ul>
<li>Architecture and design</li>
<li>Coding rules</li>
<li>Duplications</li>
<li>Unit tests</li>
<li>Code complexity</li>
<li>Finding potential bugs</li>
</ul>
<p>You can define custom rules or use the default ones that exist for more than 20 programming languages, including Java (soon Kotlin will be also be fully supported), that you are probably using for your Android app. It can also check Objective-C code and Swift. You can find SonarQube here: <a href="http://www.sonarqube.org">http://www.sonarqube.org</a>. If the QA check succeeds, then the build server can also run the unit tests and even UI-tests.</p>
<p>You can configure the build server to make a daily build at a specific time or to start each time a new pull request is made. The best practice is to create a daily build from the development branch or each time you want to have an ad hoc release for your testers. For each new pull request, you can create a new build (with each new commit) for the specific feature branch. You will find more about branching strategies in the 'Repository and Git workflow' paragraph later.</p>
<p>The purpose of Continuous Integration is to review code and to test code as often as possible by running automated tests (unit and UI tests). The idea is that if anything during this flow fails, you will be notified as early as possible. This enables you to make changes before your app is distributed. The app is distributed only if all steps succeed. If the build breaks, members of your team (often developers) will be notified through email, Slack, or any other communication channel that you use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous Delivery</h1>
                
            
            
                
<p>In this workflow, the built and tested code is made available as an ad hoc distribution to testers (or beta users). They can review the app and apply some manual tests to it. They can perform some functionality tests in particular, as a lot of tests, but not everything can be automated.</p>
<p>The build server can distribute an ad hoc version of your app by using Fabric, HockeyApp, The alpha/beta Play Store, or iTunes Beta (previously known as TestFlight). The deployment of your app needs to be as smooth as possible. A tool such as Fastlane can help you distribute an ad hoc version and can also you help you to publish your app in the Play Store or App Store.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repository and Git workflow</h1>
                
            
            
                
<p>The build server needs to retrieve the code from a repository. It is always a smart idea to use a repository, even when you work alone. Two well-known Git-based repositories are GitHub and Bitbucket (also known as Stash). Both come with a free and a paid plan. GitHub offers private repositories only in the paid plan (see <a href="https://github.com">https://github.com</a>). A private repository is accessible for your team members only. A public repository is available to anyone. Bitbucket offers private repositories in the free plan, so let's create a Bitbucket account at <a href="https://bitbucket.org">https://bitbucket.org</a>.</p>
<p>A common Git workflow is shown as follows. For the development of each new feature, a feature branch will be created. Once completed, and code reviewed via a pull request, the feature branch can be merged into the development branch.</p>
<p>Using a smart branching strategy, at least two important things can be accomplished:</p>
<ul>
<li>Only versions of the app that are fully tested and are accepted can be released</li>
<li>Hotfixes can be applied quickly, without disturbing the continuous integration workflow</li>
</ul>
<p>This makes sense even when you are the only developer:</p>
<div><img class=" image-border" height="162" src="img/23f14c93-84d0-4a12-a092-183d8f12af55.png" width="414"/></div>
<p>On the dev (or on the feature) branch, unit and UI tests can be run. If all tests are successful, the dev branch can be merged into the master branch and made ready for release. If, however, something seems to be broken while the app is live, you can use feature branching on the master branch to apply a hotfix, without disturbing the development of new features.</p>
<p>This, of course, is just a simplified example, and you may want to do things differently depending on your needs. To learn more about the Git workflow, check the website at <a href="https://www.atlassian.com/git/tutorials/comparing-workflows">https://www.atlassian.com/git/tutorials/comparing-workflows</a> or <a href="https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows">https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Automated tests</h1>
                
            
            
                
<p>The build server can run the unit tests and even UI tests for your app. For UI tests, think of tools such as Espresso (Android) or Xcode UI testing (iOS). If you are looking for tools that support both platforms you can check out Appium, for example, (available for Android and iOS).</p>
<p>When it comes to testing, there are different approaches to consider. One of these approaches is <strong>Test-driven Development</strong> (<strong>TDD</strong>). If the functionality and all the requirements are known, we can define our tests before developing our app. Of course, all tests will fail initially, but that is actually a good thing because it will set an outline of what needs to be done and create focus to get things right. During the implementation of the features, your tests are going to succeed.</p>
<p>Espresso is suitable for writing concise and reliable Android UI tests. A test typically contains clicks, text input, and checks. To learn more about Espresso or Appium, see <a href="https://google.github.io/android-testing-support-library/docs/espresso/">https://google.github.io/android-testing-support-library/docs/espresso/</a> and <a href="http://appium.io">http://appium.io</a>.</p>
<p>Unit tests are often run for the feature branch, while integration and UI tests are often run for the development branch. After you pass all of your tests, your app can be deployed and released to an audience of beta or end users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An example of a continuous workflow for an Android app</h1>
                
            
            
                
<p>A picture of the ad hoc distribution of an Android app could look as follows. For Continuous Integration, in the picture shown next, TeamCity is used to retrieve the app source code from a repository, created at Bitbucket:</p>
<div><img class=" image-border" height="209" src="img/a5ac8f4a-96a9-4ff8-8eaa-6e88b0d31777.png" width="451"/></div>
<p>In the preceding diagram, we used <strong>TeamCity</strong> to instruct <strong>Gradle</strong> to build and sign the app and create a <strong>Sonar</strong> report to measure the quality of the code. Also, we ran unit tests and ran UI tests (using <strong>Espresso</strong>). Once configured, <strong>TeamCity</strong> will take care of all these steps. If they all succeed, then another step will upload the signed app (APK file) to <strong>HockeyApp</strong>, which, in turn, notifies users about a new version being available. If you prefer you can also use Jenkins as a build server, or use Fabric Beta instead of HockeyApp. We will discuss the highlights of CI/CD only. There are some interesting books available for both build servers. Have a look at <a href="https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment">https://www.packtpub.com/</a> for more information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building variants</h1>
                
            
            
                
<p>It is not unlikely that you will need to deliver more than one version of your app. In fact, it could be a smart thing to deliver your app under multiple names, each with a different look and feel. It is great for targeting more than one audience. Another example is that of delivering a light and paid (or free and pro) version of an app. Although a flavor often is used to customize the look and feel, there is no reason why you could not use it for enabling or disabling features.</p>
<p>In addition to a particular flavor, you might need to create build types with different configurations. Think of an app that is communicating against a backend. You probably want to test your app with a different endpoint than the one you use for your app in production. This allows you to safely test your app without the need to worry that it will mess up your production data:</p>
<div><img class=" image-border" height="145" src="img/7e0cc7d9-b431-4e03-906a-049e842263a2.png" width="148"/></div>
<p>The <strong>build flavor</strong> term is reserved for customization, where the build type is for configuration purposes. The combination of a flavor and build type is called a <strong>build variant</strong>; well, at least it is like that for Android and Android Studio. If you have a light and full version of your app and you need to have at least one configuration to use as a test endpoint and one for production, then there will be four variants in total, for example like this:</p>
<div><img class=" image-border" height="130" src="img/e8bcc165-d993-495a-b33a-1262c7360748.png" width="207"/></div>
<p>As we will see later, it is not difficult to accomplish this using Gradle. We can use multiple Gradle tasks to build each variant.</p>
<p>Can we do the same for our iOS app? Yes, we can, but in a slightly different way. Xcode allows you to define multiple schemes, define a build target, which you can compare with a build flavor for Android and a build configuration, which indeed, has the same purpose as the build variant:</p>
<div><img class=" image-border" height="127" src="img/9a0c3049-e3a2-4311-8d4c-93460788d928.png" width="134"/></div>
<p>In Xcode, you will have four different schemes (two targets x two build configurations):</p>
<div><img class=" image-border" height="111" src="img/1bdd8440-9cbf-4fe6-87b9-b618ee1b8897.png" width="175"/></div>
<p>If we use a build server, we can use the Xcode command-line tools to determine which scheme we want to use for which build.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Gradle way</h1>
                
            
            
                
<p>For Android, we can use Gradle to:</p>
<ul>
<li>Determine which resources to use and for which build flavor</li>
<li>Determine which configuration parameters to use for each build type</li>
<li>Build the app for each variant</li>
<li>Sign the app</li>
</ul>
<p>Download or clone the sample project from <a href="https://github.com/mikerworks/packt-lean-mobile-app-development">https://github.com/mikerworks/packt-lean-mobile-app-development</a>.</p>
<p>Or, more specifically check out <a href="https://github.com/mikerworks/packt-lean-android-build-variants">https://github.com/mikerworks/packt-lean-android-build-variants</a>.</p>
<p>When we look at the <kbd>build.gradle</kbd> file (inside the <kbd>app</kbd> folder) of the sample Android app, it has a couple of sections that define how to deal with different product flavors. Although it is sufficient to just define the flavors and keep the debug and release build types for your project, the sections in the example project might prove useful to examine.</p>
<p>The sample project has a blue and green version, with a test and a production endpoint. Each configuration has a different application ID and config fields.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">productFlavors</h1>
                
            
            
                
<p>In the <kbd>productFlavors</kbd> section, you can find the different flavors:</p>
<pre>productFlavors {<br/>     flavorBlueTest {<br/>         applicationId = "com.coolapp.flavorblue.test"<br/>         buildConfigField "String", "api_endpoint ", "\"https://testapi.coolapp.com/\""<br/>     }<br/>     flavorBlueProd{<br/>         applicationId = "com.coolapp.flavorblue"<br/>         buildConfigField "String", " api_endpoint ", "\"https:/api.coolapp.com /\""<br/>     }<br/>     flavorGreenTest{<br/>         applicationId = "com.coolapp.flavorgreen.test"<br/>         buildConfigField "String", " api_endpoint ", "\"test.api.coolapp.com /\""<br/>     }<br/>     flavorGreenProd{<br/>         applicationId = "com.coolapp.flavorgreen"<br/>         buildConfigField "String", " api_endpoint ", "\"api.coolapp.com /\""<br/>     }<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">sourceSets</h1>
                
            
            
                
<p>In the <kbd>productFlavors</kbd> section, you can see which sources and resources each flavor refers to:</p>
<pre>sourceSets {<br/>     flavorBlueTest {<br/>         java.srcDirs = ['src/blue/java']<br/>         res.srcDirs = ['src/blue /res']<br/>     }<br/>     flavorBlueProd{<br/>         java.srcDirs = ['src/blue/java']<br/>         res.srcDirs = ['src/blue/res']<br/>     }<br/>     flavorGreenTest{<br/>         java.srcDirs = ['src/green/java']<br/>         res.srcDirs = ['src/green/res']<br/>     }<br/>     flavorGreenProd {<br/>         java.srcDirs = ['src/green/java']<br/>         res.srcDirs = ['src/green/res']<br/>     }<br/> } </pre>
<p>The <kbd>java.srcDirs</kbd> and <kbd>res.srcDirs</kbd> objects determine which folder is being referred to for a particular flavor (or flavors).</p>
<p>In this project, resources such as text (<kbd>values.xml</kbd>) and colors (<kbd>colors.xml</kbd>) are defined under the <kbd>/src/main/res</kbd> folder:</p>
<div><img class=" image-border" height="234" src="img/52765d2b-7043-4f4a-8641-55850d74852f.png" width="208"/></div>
<p>As you can see, there are, besides the <kbd>main</kbd> folder, two other folders: <kbd>blue</kbd> and <kbd>green</kbd>. Under the <kbd>blue/res</kbd> and <kbd>green/res</kbd> folders, you will find the files and values that override the default resources.</p>
<p>For example, the <kbd>main</kbd> folder has this content for the <kbd>color.xml</kbd> file:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;resources&gt;<br/>     &lt;color name="colorPrimary"&gt;#3F51B5&lt;/color&gt;<br/>     &lt;color name="colorPrimaryDark"&gt;#303F9F&lt;/color&gt;<br/>     &lt;color name="colorAccent"&gt;#FF4081&lt;/color&gt;<br/>     &lt;color name="colorBackground"&gt;#888888&lt;/color&gt;<br/> &lt;/resources&gt; </pre>
<p>For example, you can see that, for the <kbd>green</kbd> flavor, the same resource file exists but this time with a different value for <kbd>colorBackground</kbd> (a nice green one):</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;resources&gt;<br/>     &lt;color name="colorPrimary"&gt;#3F51B5&lt;/color&gt;<br/>     &lt;color name="colorPrimaryDark"&gt;#303F9F&lt;/color&gt;<br/>     &lt;color name="colorAccent"&gt;#FF4081&lt;/color&gt;<br/>     &lt;color name="colorBackground"&gt;#00dd22&lt;/color&gt;<br/> &lt;/resources&gt; </pre>
<p>The same applies to the <kbd>values.xml</kbd> resource file, containing the texts for the app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">buildTypes</h1>
                
            
            
                
<p>In the <kbd>productFlavors</kbd> section, you can see the mapping between the signing configuration for the release of a particular flavor and the entry in the <kbd>signingConfigs</kbd> section, which we examine after the <kbd>buildTypes</kbd> section:</p>
<pre>buildTypes {<br/><br/>     release {<br/>         productFlavors.flavorBlueTest.signingConfig signingConfigs.flavorBlueTest<br/>         productFlavors.flavorBlueProd.signingConfig signingConfigs.flavorBlueProd<br/><br/>         productFlavors.flavorGreenTest.signingConfig signingConfigs.flavorGreenTest<br/>         productFlavors.flavorGreenProd.signingConfig signingConfigs.flavorGreenProd<br/>     }<br/><br/>     debug {<br/>         testCoverageEnabled = true<br/>     }<br/> } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">signingConfigs</h1>
                
            
            
                
<p>In the <kbd>productFlavors</kbd> section, you see that we can use different signing using a different key store for each flavor:</p>
<pre>signingConfigs {<br/>     flavorBlueTest{<br/>         storeFile file('../app/signing/coolapp_flavorBlue.jks')<br/>         storePassword 'secretFlavorBlue'<br/>         keyAlias 'secretFlavorBlue'<br/>         keyPassword 'secretFlavorBlue'<br/>     }<br/>     flavorBlueProd {<br/>         storeFile file('../app/signing/coolapp_flavorBlue.jks')<br/>         storePassword 'secretFlavorBlue'<br/>         keyAlias 'secretFlavorBlue'<br/>         keyPassword 'secretFlavorBlue'<br/>     }<br/>     flavorGreenTest{<br/>         storeFile file('../app/signing/coolapp_flavorGreen.jks')<br/>         storePassword 'secretFlavorGreen'<br/>         keyAlias 'secretFlavorGreen'<br/>         keyPassword 'secretFlavorGreen'<br/>     }<br/>     flavorGreenProd {<br/>         storeFile file('../app/signing/coolapp_flavorGreen.jks')<br/>         storePassword 'secretFlavorGreen'<br/>         keyAlias 'secretFlavorGreen'<br/>         keyPassword 'secretFlavorGreen'<br/>     }<br/> } </pre>
<p>For the sake of simplicity, you will see all properties, such as <kbd>storeFile</kbd>, <kbd>storePassword</kbd>, <kbd>keyAlias</kbd>, and <kbd>keyPassword</kbd> here, which all refer to the equally named properties of the key store. It is a good practice to put these values in a separate signing file.</p>
<p>In Android Studio, it will look like this if you open the Build Variants panel:</p>
<div><img class=" image-border" height="161" src="img/8940826c-9181-429e-b228-782ef2102aea.png" width="240"/></div>
<p>Now, all you need to do is tell Gradle to build a particular variant, like this:</p>
<pre>./gradlew assemblectFlavorGreenTestRelease 
./gradlew assemblectFlavorGreenProdRelease 
./gradlew assemblectFlavorBlueTestRelease 
./gradlew assemblectFlavorBlueProdRelease </pre>
<p>Open a Terminal window to build each variant locally. Next, we will look at TeamCity and see how we can use it to build all variants automatically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using TeamCity as build agent</h1>
                
            
            
                
<p>A build server, such as TeamCity or Jenkins, can be used to automate these processes. We will use TeamCity in our examples and you can download it for free at <a href="https://www.jetbrains.com/teamcity/download/">https://www.jetbrains.com/teamcity/download/</a>. If you prefer Jenkins, you can get it at <a href="https://jenkins.io">https://jenkins.io</a>.</p>
<p>Download, install, and configure TeamCity on a server or, if just for testing purposes, on your development machine. After installing TeamCity, you can start the build server. On OS X, open a Terminal window, locate the <kbd>bin</kbd> folder of the <kbd>teamcity</kbd> folder (for example, <kbd>/Users/mike/Dev/teamcity/bin</kbd>), and type the following command:</p>
<pre>m010:bin mike$ sh runall.sh start </pre>
<p>Start a browser and point it to <a href="http://localhost:8111"><kbd>http://localhost:8111</kbd></a>. Wait until the setup of TeamCity has completed and then create a new project, shown as follows:</p>
<div><img class=" image-border" height="276" src="img/52d89b2f-dc4a-4765-8c89-bf682f786a42.png" width="736"/></div>
<p>Now that we know how to use Gradle to build different variants, the picture shown next cannot be too challenging. We have a light and a full version. We want to have two built for each version: one that is consuming the data from the test endpoint and another one that is obtaining data from a production endpoint. This will result in four APK files in total:</p>
<div><img class=" image-border" height="279" src="img/f7a91c9e-abf5-4a68-9599-697c5d5241c2.png" width="449"/></div>
<p>Now we will create some build steps to create four APK files using Gradle, just like we did locally. First, we need to tell where TeamCity should get the repository from for this particular project. For this project we will use the same repository and branch for all flavors, but for more complex projects this may be different for flavors and it should be different for build types. This is because it makes sense to run your ad hoc tests on a development branch and to run your final tests on a production branch.</p>
<p>Define VCS Root for your project and choose Git as the type of VCS. Give it a name and choose the following URL as Fetch URL: <a href="https://github.com/mikerworks/packt-lean-android-build-variants.git">https://github.com/mikerworks/packt-lean-android-build-variants.git</a>.</p>
<p>You do not need to enter credentials here (Anonymous for Authentication method) as this Bitbucket repository has public access.</p>
<p>Now you are ready to create your first build step. Choose Command Line for Runner type, so you can enter the same thing for the build script content as you did on your local machine:</p>
<div><img class=" image-border" height="348" src="img/972a95fa-770b-48a0-b333-6c3745f9e6ea.png" width="472"/></div>
<p>For the Custom script field, enter<kbd>./gradlew assembleFlavorGreenTestRelease</kbd>.</p>
<p>You can define additional build steps in TeamCity, for example, to run unit tests, UI tests, SonarCube QA check, and basically anything else that you can automate from a command line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Automated deploy and delivery</h1>
                
            
            
                
<p>Your app needs to be distributed once it is built, signed, and tested. There are multiple ways to do this:</p>
<ul>
<li>Self-hosted website</li>
<li>HockeyApp or Fabric beta</li>
<li>Play Store alpha/beta or iTunes beta/TestFlight</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Self hosted</h1>
                
            
            
                
<p>You can upload the signed APK and make it available on your own website. For Android, it will be sufficient just to host the APK (although you need to do some additional configuration for IIS). For iOS, you can distribute your IPA file using an <strong>Over the Air</strong> (<strong>OTA</strong>) manifest. If you choose this option, you still need to register UDIDs and create a corresponding ad hoc provision profile.</p>
<p>From a high-level perspective, this approach looks like this:</p>
<div><img class=" image-border" height="91" src="img/f5b7815b-e1d9-4c45-b4ba-700ee8d116da.png" width="331"/></div>
<p>You also have to notify your users about a new version being available on your website.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HockeyApp or Fabric beta</h1>
                
            
            
                
<p>There are many SaaS solutions available to distribute and to notify your users of new ad hoc releases. One of them is HockeyApp. You can use a (<strong>cURL</strong>) script to upload your signed APK or IPA file to HockeyApp. HockeyApp can also notify your users of the new build, and each version can contain release notes, for example, by adding a build step running this command:</p>
<pre>    <strong>curl -F "status=2" -F "notify=0" -F "ipa=@//TeamCity/buildAgent/work/&lt;work folder&gt;/app/build/outputs/apk/app-release.apk" -H "X-HockeyAppToken:&lt;your hockey app token&gt;" https://rink.hockeyapp.net/api/2/apps/&lt;app id&gt;/app_versions/upload</strong>  </pre>
<p>Using HockeyApp, the landscape will look like this:</p>
<div><img class=" image-border" height="99" src="img/7d7f76bd-c4e6-47bd-868d-70659e513f80.png" width="478"/></div>
<p>HockeyApp is a paid service, and it diminishes the provisioning profile hassle for the distribution of your iOS app. Fabric Beta is another service that you can use for ad hoc distributions. Fabric beta is a freemium service and it works pretty much in the same way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fastlane, alpha/beta Play Store, and iTunes beta</h1>
                
            
            
                
<p>If you use fastlane in combination with beta Play Store or iTunes beta/Testflight distribution, then you probably can save yourself some time and headaches.</p>
<p><strong>Fastlane</strong> is a tool for delivering your app to a test or production environment. Because it is using iTunes beta for ad hoc distribution of your iOS app, it no longer requires you to obtain the UDIDs of your test users up front. The downside of this approach is that initially, although it is an ad hoc beta distribution, your app needs to be (pre-)approved by Apple, thus taking a little bit more time, before a test version becomes available for your test users.</p>
<p>It changes the high-level picture to this one:</p>
<div><img class=" image-border" height="104" src="img/fce1dfe7-8e0c-4e92-a375-91c53eaf4b62.png" width="617"/></div>
<p>The roadmap for fastlane looks like this. It will take care of each part of your distribution flow. It was originally developed for iOS app distribution.</p>
<p>&gt;<img class=" image-border" height="318" src="img/c9056b75-6da3-4cd3-892b-d31bb2d7aa2e.png" width="256"/></p>
<p>Fastlane comes with various other interesting features that will enlighten your build automation life, such as:</p>
<ul>
<li>Creating (localized) screenshots and uploading them</li>
<li>Sending updated metadata to the App Store</li>
<li>Generating and renewing push notification in profiles</li>
<li>Running tests</li>
</ul>
<p>Fastlane is also available for Android. It probably is the easiest way to automate building and releasing your apps. You can find fastlane at <a href="https://fastlane.tools">https://fastlane.tools</a>.</p>
<p>It will take some time (and some pain) to correctly set up CI/CD but it is worth the investment!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DevOps</h1>
                
            
            
                
<p>Often you are not just the developer, but also the operator. A <strong>DevOps</strong> culture probably is most commonly found at start-up companies; however, more and more established companies are adopting its philosophy. DevOps establishes a culture and environment where building, testing, and releasing your app will happen fast, often, and more reliably, which is exactly what we want. Basically, the idea is that the whole process will become the responsibility of the team, from development to operation (configuration, monitoring, and moderation). If something in production is broken, you create a hotfix, test it, and re-release it.</p>
<p>The Continuous Integration part of CI/CD is about the dev part (of DevOps) in particular. The delivery part is more about the Ops part. Together, these two cycles can correspond to the build-measure-feedback loop (from a higher perspective):</p>
<div><img class=" image-border" height="189" src="img/ce01d54d-9379-4c3b-a5de-21de99a8d99e.png" width="498"/></div>
<p>Continuous Delivery and DevOps are often used together. They have common goals, such as delivering small and quick changes with focused value to the end customer. Some of the differences between CD and DevOps are that the latter also focuses on the organization change to support great collaboration between the many functions involved. It requires good collaboration and communication skills from each of the team members. As your organization and your team(s) start to grow, this will become increasingly important.</p>
<p>CI/CD and DevOps make split testing and gathering feedback more easy to do. This approach will contribute significantly to the adoption of the lean start-up methodology (seen from a technical perspective). It will result in better quality, higher customer satisfaction, and more (and earlier!) releases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have seen what CI and CD are, along with their benefits for you. Public or ad hoc distribution can be initiated by the build server. You can use a build server, such as TeamCity or Jenkins to build and test your app.</p>
<p>Ad hoc releases can be distributed using HockeyApp, Fabric Beta, or the beta programs of the Play Store or App Store. Fastlane can help you with these and other tasks. By now, you probably have learned a lot already.</p>
<p>CI and CD are important if you want to improve and maintain the quality of your code and if you want to optimize your workflow. It allows you to gather feedback since you are able to release early and often. CI/CD and a DevOps culture can help you with the optimization of the build-measure-feedback loop.</p>
<p>In the next chapter we will learn why building an unfair advantage is important if you want to succeed and if you want to survive as a company.</p>


            

            
        
    </body></html>