- en: Chapter 5. Creating and Saving User Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 创建和保存用户数据
- en: In this chapter, we will start by adjusting the style of our navigation bar
    to match the navigation style of iOS 7\. Next, we will create our buttons in the
    navigation bar and hook them up to the proper methods. Once we adjust our storyboard,
    we can start writing the code to allow a user to take or pick an image, give the
    item a title, and then back up the data to disk for later use. On completing this
    chapter, our application will have all the functionality required for users to
    save new food items!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先调整导航栏的样式以匹配 iOS 7 的导航样式。接下来，我们将在导航栏中创建我们的按钮并将它们连接到适当的方法。一旦我们调整了我们的故事板，我们就可以开始编写代码，允许用户拍摄或选择图片，为项目添加标题，然后将数据备份到磁盘以供以后使用。完成本章后，我们的应用程序将具备用户保存新食品项目所需的所有功能！
- en: Picking up where we left off
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们上次停止的地方继续
- en: In the last chapter, we created all our files and then connected them to our
    storyboard. We then added all of the required elements (labels, image views, and
    so on) to each view controller. Last, we created outlets and connected them to
    our storyboard elements. The purpose of this chapter, along with that of the following
    chapter, is to finish building the application. We will be implementing one portion
    of the core functionality, which is the ability to take or select a photo, add
    a name, and then save the data. Once we complete this, we can start using some
    of the new features of iOS 7 to add additional visual appeal to our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了所有文件并将它们连接到我们的故事板。然后我们在每个视图控制器中添加了所有必需的元素（标签、图像视图等）。最后，我们创建了出口并将它们连接到我们的故事板元素。本章以及下一章的目的是为了完成应用程序的构建。我们将实现核心功能的一部分，即能够拍摄或选择照片，添加名称，然后保存数据。一旦我们完成这项工作，我们就可以开始使用
    iOS 7 的一些新功能来为我们的应用程序添加额外的视觉吸引力。
- en: The navigation bar style
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航栏样式
- en: Before we move on, let's go ahead and alter some of the navigation bar style
    options. Our application will have the same navigation bar style in every view,
    so our best approach is to use the appearance proxy on `UINavigationBar` in our
    `AppDelegate` object. This will allow us to write the code only once, and the
    navigation bars in the entire application will abide by these styles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们先改变一些导航栏样式选项。我们的应用程序在每个视图中都将具有相同的导航栏样式，因此我们最好的方法是在 `AppDelegate`
    对象中使用 `UINavigationBar` 的外观代理。这将允许我们只编写一次代码，整个应用程序中的导航栏都将遵循这些样式。
- en: 'Switch to `AppDelegate.m` and scroll down to the `applicationDidFinishLaunchingWithOptions`
    method. We are going to set the color of the navigation bar, the font for the
    title label, and the navigation bar tint color (this will change the color of
    the bar button items on the navigation bar). Additionally, our application will
    have text-based bar button items, so we want to set the appearance proxy on `UIBarButtonItem`
    to match our application style. Copy and paste the following code into `applicationDidFinishLaunchingWithOptions`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `AppDelegate.m` 文件并向下滚动到 `applicationDidFinishLaunchingWithOptions` 方法。我们将设置导航栏的颜色、标题标签的字体以及导航栏的色调颜色（这将改变导航栏上按钮项的颜色）。此外，我们的应用程序将具有基于文本的按钮项，因此我们希望将
    `UIBarButtonItem` 的外观代理设置为与我们的应用程序风格相匹配。将以下代码复制并粘贴到 `applicationDidFinishLaunchingWithOptions`
    中：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we set the color of the navigation bar base to dark red. Next, we set
    the title text font color to white and set its font to a specific font. You can
    replace this font with any font you wish; I just like the way this font looks.
    To match our title text, all navigation bar buttons should also be white, so we
    set the `navigationTintColor` method (do not get confused with the `navigationBarTintColor`
    method, which will change the color of the navigation bar itself and not the navigation
    items) to white. Last, we alter the font of our `UIBarButtonItem` objects to match
    our navigation bar title style.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导航栏底部的颜色设置为深红色。接下来，我们将标题文本字体颜色设置为白色，并将其字体设置为特定的字体。你可以用你喜欢的任何字体替换这个字体；我只是喜欢这个字体的样子。为了匹配我们的标题文本，所有导航栏按钮也应为白色，因此我们将
    `navigationTintColor` 方法（不要与 `navigationBarTintColor` 方法混淆，后者将改变导航栏本身的颜色而不是导航项的颜色）设置为白色。最后，我们更改了
    `UIBarButtonItem` 对象的字体以匹配导航栏标题样式。
- en: 'Now that our navigation bar is styled, let''s add some code to our `MenuViewController`
    to finalize the style of our application. Switch to `MenuViewController.m` and
    scroll down to the `viewDidLoad` method. First, let''s adjust the background color
    of the menu buttons. Previously, we set the `backgroundColor` property to white,
    but let''s change this to match our dark red navigation bar. Replace the previous
    background color code with the following code snippet:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为导航栏设置了样式，接下来让我们向`MenuViewController`添加一些代码来最终确定应用程序的样式。切换到`MenuViewController.m`文件，并向下滚动到`viewDidLoad`方法。首先，让我们调整菜单按钮的背景颜色。之前，我们将`backgroundColor`属性设置为白色，但让我们将其改为与我们的深红色导航栏相匹配。用以下代码片段替换之前的背景颜色代码：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Last, write the following code into the `viewDidLoad` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码写入`viewDidLoad`方法：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a very handy piece of code to use. By default, when a `viewController`
    method is pushed onto the navigation stack, it will display a back button (less-than
    sign) and text. The text is based on the previous view controller''s title. We
    want to only display the `<` symbol, so we add the previous line of code. We are
    basically telling the application that for every back button, the text should
    be equal to `@""`, or an empty string. It is worth noting that this can be changed
    by setting the back button property of the navigation item in our storyboard.
    The following screenshot is an example of our application before and after introducing
    an empty string:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段非常实用的代码。默认情况下，当`viewController`方法被推送到导航堆栈时，它将显示一个返回按钮（小于号）和文本。文本基于前一个视图控制器的标题。我们只想显示`<`符号，因此我们添加了上一行代码。我们基本上在告诉应用程序，对于每个返回按钮，文本应该等于`@""`，或者一个空字符串。值得注意的是，这可以通过在故事板中设置导航项的返回按钮属性来更改。以下截图是引入空字符串前后的应用程序示例：
- en: '![The navigation bar style](img/InsertImage_0319OS_05_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![导航栏样式](img/InsertImage_0319OS_05_01.jpg)'
- en: Adding our button action
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加按钮动作
- en: 'Our next step is to add the code to be called when the **Add New** button is
    pressed. In our previous chapter, we created an action called `addNewPressed`
    and connected it to our **Add New** button. Let''s go ahead and write the code
    to present the proper view controller when this button is pressed. First, switch
    to `MenuViewController.h`, and directly underneath the standard `#import` for
    UIKit, let''s import our view controllers as shown in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要添加的是当按下**添加新项**按钮时要调用的代码。在我们之前的章节中，我们创建了一个名为`addNewPressed`的动作，并将其连接到我们的**添加新项**按钮。让我们继续编写当按下此按钮时显示适当视图控制器的代码。首先，切换到`MenuViewController.h`文件，并在标准的`#import`
    UIKit语句下方，按照以下代码片段导入我们的视图控制器：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have also defined a string literal for our storyboard ID for good practice.
    We have named it `ADD_NEW_VIEW_CONTROLLER` so that we know what it contains. Switch
    back to `MenuViewController.m` and scroll down to our `addNewPressed` method.
    As we will be presenting this view controller (dragging it onto the screen from
    the bottom), we need to also create a navigation controller to hold the `AddNewViewController`
    object. The following is the code for adding a button action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个用于故事板ID的字符串字面量，我们将其命名为`ADD_NEW_VIEW_CONTROLLER`，以便我们知道它包含的内容。切换回`MenuViewController.m`文件，并向下滚动到我们的`addNewPressed`方法。由于我们将要显示这个视图控制器（从底部拖动到屏幕上），我们还需要创建一个导航控制器来持有`AddNewViewController`对象。以下是为添加按钮动作的代码：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is pretty straightforward. We allocate our `AddNewViewController`
    object by initializing it from our storyboard. Make sure that `AddNewViewController`
    in our storyboard has the property for our storyboard ID set to `AddNew` so that
    it matches our string literal defined earlier. Under certain circumstances, it
    is recommended to preinitialize the view controller before presenting it if there
    is a noticeable lag between the button press and the view being presented. Next,
    we create a navigation controller and assign our newly created `AddNewViewController`
    as its root view controller. Last, we tell the current navigation controller to
    present the new one. Go ahead and run the application and test the functionality.
    The `AddNewViewController` object inside of a navigation controller should slide
    onto the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直接。我们通过从故事板初始化来分配我们的 `AddNewViewController` 对象。确保我们的故事板中的 `AddNewViewController`
    具有我们的故事板 ID 属性设置为 `AddNew`，以便它与之前定义的字符串字面量相匹配。在某些情况下，如果在按钮按下和视图展示之间有明显的延迟，建议在展示之前预先初始化视图控制器。接下来，我们创建一个导航控制器并将我们新创建的
    `AddNewViewController` 分配为其根视图控制器。最后，我们告诉当前的导航控制器展示新的导航控制器。运行应用程序并测试这个功能。应该滑动到屏幕上的导航控制器中的
    `AddNewViewController` 对象。
- en: Adding buttons to our navigation bar
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将按钮添加到我们的导航栏
- en: You may have noticed that when presenting our `AddNewViewController` object,
    we have no way to dismiss the view to get back to the menu. Let's add this functionality
    now. We will be creating two bar button items that will be text-only items. The
    first button, **Cancel**, will dismiss the view while the second, **Save**, will
    save the new food entry.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在展示我们的 `AddNewViewController` 对象时，我们没有方法来关闭视图回到菜单。现在让我们添加这个功能。我们将创建两个仅包含文本的按钮项。第一个按钮，**取消**，将关闭视图，而第二个，**保存**，将保存新的食物条目。
- en: 'Switch to `AddNewViewController.m` and scroll down to `viewDidLoad`. Add the
    following code at the top of `viewDidLoad`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `AddNewViewController.m` 并滚动到 `viewDidLoad`。在 `viewDidLoad` 的顶部添加以下代码：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we create both bar button items using the built-in **Cancel** and **Save**
    bar button items provided by iOS. Each button also has its own selector (or method)
    that we will code in a moment. Next, we assign each bar button to the navigation
    bar. I chose to place **Cancel** on the left-hand side and **Save** on the right-hand
    side of the bar; however, this order is entirely up to you. If we run our application
    and click on the **Add New** button, our view will slide into place, and you will
    see **Cancel** on the left-hand side and **Save** on the right-hand side. Our
    appearance proxies defined in the app delegate should also be reflected in the
    font and text color. Next, let's actually add the **Cancel** button functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 iOS 提供的内置 **取消** 和 **保存** 按钮项创建了两个按钮项。每个按钮都有自己的选择器（或方法），我们将在稍后进行编码。接下来，我们将每个按钮项分配给导航栏。我选择将
    **取消** 放在栏的左侧，将 **保存** 放在右侧；然而，这个顺序完全取决于你。如果我们运行我们的应用程序并点击 **添加新项** 按钮，我们的视图将滑动到合适的位置，你将看到左侧是
    **取消**，右侧是 **保存**。我们在应用程序委托中定义的外观代理也应该反映在字体和文字颜色上。接下来，让我们实际添加 **取消** 按钮的功能。
- en: 'Switch back to `AddNewViewController.m` and scroll down to the bottom of `viewDidLoad`.
    We want to allow the user to cancel adding a food item, so let''s write the `cancelButtonPressed`
    method that we earlier assigned to our cancel button. Directly below `viewDidLoad`,
    add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回 `AddNewViewController.m` 并滚动到 `viewDidLoad` 的底部。我们希望允许用户取消添加食物项，所以让我们编写之前分配给取消按钮的
    `cancelButtonPressed` 方法。在 `viewDidLoad` 下方直接添加以下代码：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have defined both our `cancelButtonPressed` and `saveButtonPressed` methods
    here (`saveButtonPressed` has been intentionally left blank until later in the
    chapter). In `cancelButtonPressed`, we simply tell the view controller to dismiss
    itself and set the animated view controller to `YES`. Run the application and
    test this functionality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了 `cancelButtonPressed` 和 `saveButtonPressed` 方法（`saveButtonPressed`
    已经有意留空，直到本章的后面部分）。在 `cancelButtonPressed` 中，我们只是告诉视图控制器关闭自己并将动画视图控制器设置为 `YES`。运行应用程序并测试这个功能。
- en: Adjusting our storyboard view
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整我们的故事板视图
- en: Now that we have some of our code implemented, we need to finish arranging our
    view in `Main.storyboard`. Previously, we only added the required elements and
    did not position or size them correctly. Switch to `Main.storyboard` and scroll
    down to the `AddNewViewController` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一些代码，我们需要完成在`Main.storyboard`中排列视图。之前，我们只添加了所需的元素，但没有正确地定位或调整它们的大小。切换到`Main.storyboard`并向下滚动到`AddNewViewController`对象。
- en: We have three items to position and size here, starting with the two image views.
    Select the first image view, and in the **Utilities** pane, select the **Size
    Inspector** submenu. Set the width and height to 180 pixels to create a perfect
    square. Position this image view horizontally in the center of the view and slightly
    higher than the vertical center of the view. Do not worry about being precise,
    and feel free to position the image view where you think it looks best!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个项目需要定位和调整大小，首先是两个图像视图。选择第一个图像视图，在**工具**面板中，选择**大小检查器**子菜单。将宽度和高度设置为180像素以创建一个完美的正方形。将此图像视图水平放置在视图的中心，并略高于视图的垂直中心。不要担心过于精确，可以自由地将图像视图放置在您认为看起来最好的位置！
- en: Repeat this process for the other image view, making it an identical size and
    in exactly the same position. For this image view, switch to the **Attributes
    Inspector** submenu (in the **Utilities** pane on the right-hand side) and set
    its image to `placeholder_image` for `placeholderImageView`. Using the documents
    outline, make sure that this image view is positioned *below* the other image
    view. We will be using two image views to assist in save validation. When a user
    selects or takes an image, it will be set to the top image view (the empty one)
    and cover the placeholder image view beneath it. This allows us to check if the
    top image view contains an image. If it does not, it means the user has not added
    an image and that the placeholder is still visible. In this case, we will alert
    the user to let him/her know that he/she must include a photo.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此过程以处理其他图像视图，使其大小相同且位置完全一致。对于此图像视图，切换到**属性检查器**子菜单（在右侧的**工具**面板中），并将其图像设置为`placeholder_image`用于`placeholderImageView`。使用文档大纲，确保此图像视图位于其他图像视图的下方。我们将使用两个图像视图来协助保存验证。当用户选择或拍摄图像时，它将被设置为顶部的图像视图（空的一个）并覆盖下方的占位符图像视图。这允许我们检查顶部图像视图是否包含图像。如果没有，这意味着用户尚未添加图像，占位符仍然可见。在这种情况下，我们将提醒用户，让他/她知道他/她必须包含一张照片。
- en: Last, we need to adjust the settings of our `UITextField` object that will be
    used to type in the name of our food entry. Select the text field and reopen the
    **Size Inspector** submenu from the **Utilities** pane. Set the height to 38 pixels
    and the width to 280 pixels. Position the text field horizontally centered and
    slightly above the image views.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整将用于输入食物条目名称的`UITextField`对象的设置。选择文本字段并重新打开**大小检查器**子菜单（从**工具**面板）。将高度设置为38像素，宽度设置为280像素。将文本字段水平居中并略高于图像视图。
- en: 'Select the **Attributes Inspector** from the **Utilities** pane and change
    the following settings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从**工具**面板中选择**属性检查器**并更改以下设置：
- en: '**Alignment**: Select the Center icon'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：选择中心图标'
- en: '**Placeholder**: `Type The Food Name`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**占位符**：`输入食物名称`'
- en: '**Border Style**: This field should be set to none (the first of the four buttons)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边框样式**：此字段应设置为无（四个按钮中的第一个）'
- en: '**Capitalization**: Select Words'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小写**：选择单词'
- en: 'The final result should look something like the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应类似于以下截图：
- en: '![Adjusting our storyboard view](img/InsertImage_0319OS_05_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![调整我们的故事板视图](img/InsertImage_0319OS_05_02.jpg)'
- en: Adding our delegates
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的代表
- en: 'Now that our view is completely set up, we can start coding the desired functionality.
    Before we can move on, we need to specify some delegates that our view controller
    will require to work. We will work with a text field, image picker, navigation
    controller, and action sheet, all of which have their own custom delegates. Switch
    to `AddNewViewController.h` and replace the line of code after `#import` with
    the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全设置了视图，我们可以开始编写所需的功能代码。在我们可以继续之前，我们需要指定视图控制器将需要的某些委托。我们将与文本字段、图像选择器、导航控制器和操作表一起工作，它们都有自己的自定义委托。切换到`AddNewViewController.h`并替换`#import`之后的代码行，替换为以下代码：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are simply specifying the protocols that our class will conform to
    in the code. With this final step, we can now start coding our functionality into
    the application!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地指定我们的类将在代码中遵循的协议。完成这一步后，我们现在可以开始将功能编码到应用程序中！
- en: Using a tap gesture
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点击手势
- en: 'For our application, a user can tap on the placeholder image in order to take
    or select a photo. To do this, we will add a tap gesture recognizer directly to
    the placeholder image view. Switch to `AddNewViewController.m` and scroll down
    to `viewDidLoad`. Add the following code at the bottom of the `viewDidLoad` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，用户可以点击占位符图像来拍照或选择照片。为此，我们将直接在占位符图像视图中添加一个点击手势识别器。切换到`AddNewViewController.m`并滚动到`viewDidLoad`。在`viewDidLoad`文件底部添加以下代码：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we add a border and a corner radius to our image view for visual effect.
    Next, we create a tap gesture recognizer and assign it a method. We also set the
    property `numberOfTapsRequired` to `1`. The last step is to set the user interaction
    enabled on our placeholder image view to `YES` and then add our gesture recognizer
    to it. Now, our image view will keep listening for a single tap and call our `imageViewTapped`
    method when a tap is detected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的图像视图添加一个边框和圆角以产生视觉效果。接下来，我们创建一个点击手势识别器并为其分配一个方法。我们还设置属性`numberOfTapsRequired`为`1`。最后一步是将用户交互启用在我们的占位符图像视图中设置为`YES`，然后将我们的手势识别器添加到它上面。现在，我们的图像视图将一直监听单次点击，并在检测到点击时调用我们的`imageViewTapped`方法。
- en: 'When the image is tapped, we want to give the user an option to either select
    an image from their library or take a new one using the camera. The best way to
    do this is using an action sheet. Let''s create the `imageViewTapped` method,
    have it display an action sheet, and then respond to the users'' selection accordingly.
    Below the `ButtonPressed` methods, add the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当图片被点击时，我们希望给用户一个选项，要么从他们的库中选择一个图片，要么使用相机拍摄一个新的。最好的方式是使用操作表。让我们创建`imageViewTapped`方法，显示一个操作表，然后相应地响应用户的选择。在`ButtonPressed`方法下方，添加以下代码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this code, when the user taps on the image view, we create an action sheet
    and display it in the current view. We only need the **Cancel** button and two
    additional buttons, one for **Take Picture** and another for **Choose From Library**.In
    order for us to respond accordingly to the selected action sheet button, we need
    to implement the action sheet delegate method. Below the `imageViewTapped` method,
    add the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，当用户点击图像视图时，我们创建一个操作表并在当前视图中显示它。我们只需要**取消**按钮和两个额外的按钮，一个用于**拍照**，另一个用于**从库中选择**。为了我们能够相应地响应用户选择的操作表按钮，我们需要实现操作表代理方法。在`imageViewTapped`方法下方，添加以下代码：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this method, we first check if the selected button is the **Cancel** button,
    and if so, we return to end the execution of this method, which will also hide
    the action sheet for us. Next, we check if the button index is equal to `0`, or
    `Take Picture`. If so, we create an instance of `UIImagePickerController`. We
    set the delegate to `self` and also allow editing (this will allow the user to
    crop the image into a perfect square, which is ideal for our application), and
    then we set the source type to camera.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先检查选中的按钮是否是**取消**按钮，如果是，则返回以结束此方法的执行，这将为我们隐藏操作表。接下来，我们检查按钮索引是否等于`0`，或`拍照`。如果是，我们创建一个`UIImagePickerController`实例。我们将代理设置为`self`，并允许编辑（这将允许用户将图片裁剪成完美的正方形，这对我们的应用程序来说很理想），然后我们将源类型设置为相机。
- en: If the button index is `1`, or `Choose From Library`, we use exactly the same
    code with one exception. For this block, set the source type to photo library
    to display the phone's camera library. Save our code and run the application.
    Everything should work as expected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮索引是`1`，或者`从库中选择`，我们使用完全相同的代码，只有一个例外。对于这个块，将源类型设置为照片库以显示手机的相机库。保存我们的代码并运行应用程序。一切应该按预期工作。
- en: Getting the image from UIImagePickerController
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UIImagePickerController获取图片
- en: 'Now that a user can take a photo or select from their phone''s photo library,
    we need to grab that image and display it. In order to do so, we need to implement
    the image picker''s delegate method, the `didFinishPickingMediaWithInfo` method.
    Below our action sheet delegate method, add the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以拍照或从他们的手机照片库中选择，我们需要获取那张图片并显示它。为了做到这一点，我们需要实现图像选择器的代理方法，即`didFinishPickingMediaWithInfo`方法。在我们的操作表代理方法下方，添加以下代码：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this method, we create an instance of `UIImage` and assign it using the info
    dictionary provided by the image picker. Because we want our users to edit the
    image, we want to grab the edited version instead of the original (which can be
    accessed using `UIImagePickerControllerOriginalImage`). Now that we have our final
    image, we assign it to our final image view and then hide the placeholder image
    view. Last, we need to tell the image picker controller to dismiss itself to bring
    us back to our `AddNewViewController`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建一个`UIImage`实例，并使用图片选择器提供的信息字典来分配它。因为我们希望我们的用户编辑图片，所以我们想要获取编辑后的版本而不是原始版本（可以使用`UIImagePickerControllerOriginalImage`访问），现在我们有了最终的图片，我们将它分配给最终图片视图，然后隐藏占位符图片视图。最后，我们需要告诉图片选择器控制器自己消失，这样我们就可以回到我们的`AddNewViewController`。
- en: Save everything and run the code to test it out. If you wish to actually take
    a picture with the camera, you must run this on an actual device.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有内容并运行代码以测试。如果你希望实际上用相机拍照，你必须在一个实际设备上运行此操作。
- en: Adding the text field delegate
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文本字段代理
- en: 'Now that we have our image, we need to set up the text field delegate. This
    is probably the simplest of all delegate methods because we only need to tell
    the application what to do when the *return* key is pressed. For our application,
    we simply want to hide the keyboard. Below our image picker delegate method, add
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的图片，我们需要设置文本字段代理。这可能是所有代理方法中最简单的一个，因为我们只需要告诉应用程序当按下*返回*键时应该做什么。对于我们的应用程序，我们只想隐藏键盘。在我们的图片选择器代理方法下方，添加以下代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method simply tells the text view to resign first responder (hide the keyboard)
    when the *return* key is pressed. A user can type in a name, press the *return*
    key, and hide the keyboard. Make sure that the text fields delegate property has
    been set to `AddNewViewController` (self) either in the storyboard or in `viewDidLoad`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地告诉文本视图在按下*返回*键时放弃第一个响应者（隐藏键盘）。用户可以输入一个名字，按下*返回*键，然后隐藏键盘。确保文本字段的代理属性已经在故事板或`viewDidLoad`中设置为`AddNewViewController`（self）。
- en: Saving the data
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存数据
- en: We now have everything we need from the user to create a new food entry. In
    order to save the data, we will need to follow multiple steps so that we can access
    it again later in the app. The save data method we created earlier will be quite
    long once complete, so we will cover it piece by piece for simplicity, starting
    with a custom date helper method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在从用户那里获得了创建新食物条目所需的一切。为了保存数据，我们需要遵循多个步骤，以便我们可以在稍后应用程序中再次访问它。我们之前创建的保存数据方法一旦完成将会相当长，所以我们将为了简单起见逐块介绍，从自定义日期辅助方法开始。
- en: Getting the date string
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取日期字符串
- en: For our application, we will be creating a `.plist` file that will store the
    food entry's name, date created, and the file path to the image. The image itself
    will be saved separately in the documents directory. When saving any file to the
    documents directory, you must specify a filename. In order to save multiple images,
    we need to make sure that every single image file saved has a different filename.
    One of the best (and most popular) ways to accomplish this is using a date.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将创建一个`.plist`文件，该文件将存储食物条目的名称、创建日期以及图片的文件路径。图片本身将单独保存在文档目录中。在将任何文件保存到文档目录时，你必须指定一个文件名。为了保存多个图片，我们需要确保每个保存的图片文件都有一个不同的文件名。实现这一目标的一种最好（也是最流行）的方法是使用日期。
- en: Each device keeps track of the current date down to the millisecond. This means
    that at any given millisecond, the date will be completely different from every
    date before and every date after. This gives a great way to create a unique identifier
    for each image based on when it was created. What we will do is grab the current
    date, set the date format, and convert it to a string that we will then tack onto
    the end of each filename. This way, every single image will have a unique filename
    that will be stored in our `.plist` file to be accessed later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都会追踪到毫秒级的当前日期。这意味着在任何给定的毫秒，日期都会与之前和之后的每个日期完全不同。这为根据图片创建时间创建每个图片的唯一标识符提供了一个很好的方法。我们将做的是获取当前日期，设置日期格式，并将其转换为字符串，然后将它附加到每个文件名的末尾。这样，每个图片都将有一个唯一的文件名，该文件名将被存储在我们的`.plist`文件中，以便稍后访问。
- en: 'I have created a simple helper method that returns the current date as a string
    value that we can use for the filename, so let''s add it to our code. Scroll down
    to the end of the last method and add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个简单的辅助方法，该方法返回当前日期作为字符串值，我们可以将其用于文件名，所以让我们将其添加到我们的代码中。滚动到上一个方法的末尾并添加以下代码：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this code, we first create a date formatter that takes the year, month,
    day, hour, minute, and second values of a date and pushes them together. Next,
    we create a date object and set it to the current date and time. Finally, we create
    a string using our date formatter and return it. Now that we have our helper method,
    let's add the code to save the data!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们首先创建一个日期格式化器，它将日期的年、月、日、小时、分钟和秒值组合在一起。然后，我们创建一个日期对象并将其设置为当前日期和时间。最后，我们使用我们的日期格式化器创建一个字符串并返回它。现在我们有了辅助方法，让我们添加保存数据的代码！
- en: Adding validation
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加验证
- en: 'We are now ready to implement the `saveButtonPressed` method. Before we write
    any of the code to actually save the date, we first need to check that the user
    has actually selected an image and added a name. This will prevent us from having
    any errors and will guarantee that we have the required data. Scroll down to the
    empty `saveButtonPressed` method we created earlier and add the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现`saveButtonPressed`方法。在我们编写任何实际保存数据的代码之前，我们首先需要检查用户是否实际上已选择了一个图片并添加了名称。这将防止我们出现任何错误，并保证我们有所需的数据。滚动到我们之前创建的空`saveButtonPressed`方法，并添加以下代码：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This validation is very simple but effective. Here, we put to use having multiple
    image views by checking whether the final image view is nil. We also check to
    make sure that a user has actually added text to the text field by checking that
    the text property's length is greater than zero. If either of these two conditions
    is false, we display an alert view telling the user that both a title and an image
    are required to be saved. If both are true, we can proceed with our saving process.
    It is recommended that you use a data model to maintain data in an application;
    however, for our application, this will do fine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证非常简单但有效。在这里，我们通过检查最终图像视图是否为nil来使用多个图像视图。我们还通过检查文本属性的长度是否大于零来确保用户实际上已经向文本框中添加了文本。如果这两个条件中的任何一个为假，我们将显示一个警告视图，告诉用户需要保存标题和图片。如果两者都为真，我们可以继续我们的保存过程。建议您使用数据模型来维护应用程序中的数据；然而，对于我们的应用程序来说，这样做就足够了。
- en: Saving the image
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存图片
- en: 'The first step in the saving process is to save the image itself to the documents
    directory. Inside the first `if` statement block, add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保存过程的第一步是将图片本身保存到文档目录中。在第一个`if`语句块内部，添加以下代码：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we grab the first element (which will always be the path to the documents
    directory) from the list of directories in the file system. We then create a new
    path for our image by adding a filename to the end of the documents path. The
    filename is how we access the image later in our app. Using our date helper method,
    we set the filename to image, and the returned date string is separated by a hyphen.
    Now every image will be found in the documents directly with a unique filename.
    Last, we create an instance of `NSData`, assign the user's final image to it as
    data using `UIImagePNGRepresentation`, and then save the date to the image path
    created previously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从文件系统中的目录列表中获取第一个元素（它始终是文档目录的路径）。然后，我们在文档路径的末尾添加一个文件名来创建我们的图片路径。文件名是我们稍后在应用程序中访问图片的方式。使用我们的日期辅助方法，我们将文件名设置为image，并使用连字符分隔返回的日期字符串。现在，每个图片都会在文档目录中以唯一的文件名找到。最后，我们创建一个`NSData`实例，使用`UIImagePNGRepresentation`将用户的最终图片作为数据分配给它，然后将数据保存到之前创建的图片路径中。
- en: Now that our image has been saved, we can save the rest of our data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保存了图片，我们可以保存其余的数据。
- en: Creating versus loading the .plist file
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建与加载.plist文件
- en: 'In order to save the users'' data, we will be creating a dictionary that contains
    all relevant data for each food entry. We will then add this dictionary to a `.plist`
    file and save the `.plist` file to the documents directory. To make sure we don''t
    save over our previous data, we must first check to see if our `.plist` file already
    exists. Below the previous code for saving the image, add the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存用户数据，我们将创建一个包含每个食物条目所有相关数据的字典。然后，我们将此字典添加到`.plist`文件中，并将`.plist`文件保存到文档目录中。为了确保我们不覆盖我们之前的数据，我们必须首先检查我们的`.plist`文件是否已经存在。在保存图片的上一段代码下方添加以下代码：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we create another path by adding `Data.plist` to the end of the documents
    directory created earlier (this name can be anything you wish as long as it ends
    in `.plist`). Next, we create an empty array to hold the final `.plist` data and
    allow us to append more data to the end of the file. We create an instance of
    `NSFileManager` and use it to check if the file at the newly created path exists.
    If so, we set the contents of our `.plist` file to the `plistDataArray` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过在之前创建的文档目录末尾添加`Data.plist`来创建另一个路径（这个名称可以是任何你想要的，只要以`.plist`结尾）。接下来，我们创建一个空数组来保存最终的`.plist`数据，并允许我们在文件的末尾追加更多数据。我们创建一个`NSFileManager`实例，并使用它来检查新创建的路径上的文件是否存在。如果存在，我们将我们的`.plist`文件的内容设置为`plistDataArray`方法。
- en: If the `.plist` file does not exist, we instead create another empty array,
    save the array as a `.plist` file, and then set the `plistDataArray` method to
    the content of the newly created (but empty) `.plist` file. Now we can add more
    data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.plist`文件不存在，我们将创建另一个空数组，将数组保存为`.plist`文件，然后将`plistDataArray`方法设置为新创建的（但为空）`.plist`文件的内容。现在我们可以添加更多数据。
- en: Adding a new entry
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新条目
- en: 'Now, we will grab the user data and turn it into a dictionary so that we can
    add it to our data array. Then, we can save it to the documents directory. Add
    the following code after the previous code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将获取用户数据并将其转换为字典，以便我们可以将其添加到我们的数据数组中。然后，我们可以将其保存到文档目录中。在之前的代码之后添加以下代码：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we create a new empty mutable dictionary. The dictionary is then filled
    with the user-entered name, the image path used earlier, and the current date
    and time. We then add this dictionary to our `plistDataArray` method and tell
    it to save (write) the file. Last, we dismiss the view controller to bring us
    back to the menu where we started, and our data has been saved!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的空可变字典。然后，我们将用户输入的名称、之前使用的图像路径以及当前的日期和时间填充到字典中。然后，我们将这个字典添加到我们的`plistDataArray`方法中，并告诉它保存（写入）文件。最后，我们关闭视图控制器，回到我们开始时的菜单，我们的数据已经保存！
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built the most important component of our application, the
    ability to create new food entries. Now that all of this data has been saved,
    we can retrieve it and start displaying it to our user. Because everything is
    saved directly to the device, we are able to manipulate this data instantly and
    use it as we please.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了我们应用程序最重要的组件，即创建新的食物条目的能力。现在所有这些数据都已保存，我们可以检索它并开始向用户显示。因为所有内容都直接保存到设备上，所以我们能够即时操作这些数据并按需使用它。
- en: 'In the next chapter, we will build the final piece of our application''s core
    functionality: viewing the user-created data both in a table view and in a detail
    view.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建我们应用程序核心功能的最后一部分：在表格视图和详细视图中查看用户创建的数据。
