- en: Chapter 5. Creating and Saving User Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start by adjusting the style of our navigation bar
    to match the navigation style of iOS 7\. Next, we will create our buttons in the
    navigation bar and hook them up to the proper methods. Once we adjust our storyboard,
    we can start writing the code to allow a user to take or pick an image, give the
    item a title, and then back up the data to disk for later use. On completing this
    chapter, our application will have all the functionality required for users to
    save new food items!
  prefs: []
  type: TYPE_NORMAL
- en: Picking up where we left off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we created all our files and then connected them to our
    storyboard. We then added all of the required elements (labels, image views, and
    so on) to each view controller. Last, we created outlets and connected them to
    our storyboard elements. The purpose of this chapter, along with that of the following
    chapter, is to finish building the application. We will be implementing one portion
    of the core functionality, which is the ability to take or select a photo, add
    a name, and then save the data. Once we complete this, we can start using some
    of the new features of iOS 7 to add additional visual appeal to our application.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, let's go ahead and alter some of the navigation bar style
    options. Our application will have the same navigation bar style in every view,
    so our best approach is to use the appearance proxy on `UINavigationBar` in our
    `AppDelegate` object. This will allow us to write the code only once, and the
    navigation bars in the entire application will abide by these styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `AppDelegate.m` and scroll down to the `applicationDidFinishLaunchingWithOptions`
    method. We are going to set the color of the navigation bar, the font for the
    title label, and the navigation bar tint color (this will change the color of
    the bar button items on the navigation bar). Additionally, our application will
    have text-based bar button items, so we want to set the appearance proxy on `UIBarButtonItem`
    to match our application style. Copy and paste the following code into `applicationDidFinishLaunchingWithOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the color of the navigation bar base to dark red. Next, we set
    the title text font color to white and set its font to a specific font. You can
    replace this font with any font you wish; I just like the way this font looks.
    To match our title text, all navigation bar buttons should also be white, so we
    set the `navigationTintColor` method (do not get confused with the `navigationBarTintColor`
    method, which will change the color of the navigation bar itself and not the navigation
    items) to white. Last, we alter the font of our `UIBarButtonItem` objects to match
    our navigation bar title style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our navigation bar is styled, let''s add some code to our `MenuViewController`
    to finalize the style of our application. Switch to `MenuViewController.m` and
    scroll down to the `viewDidLoad` method. First, let''s adjust the background color
    of the menu buttons. Previously, we set the `backgroundColor` property to white,
    but let''s change this to match our dark red navigation bar. Replace the previous
    background color code with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, write the following code into the `viewDidLoad` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very handy piece of code to use. By default, when a `viewController`
    method is pushed onto the navigation stack, it will display a back button (less-than
    sign) and text. The text is based on the previous view controller''s title. We
    want to only display the `<` symbol, so we add the previous line of code. We are
    basically telling the application that for every back button, the text should
    be equal to `@""`, or an empty string. It is worth noting that this can be changed
    by setting the back button property of the navigation item in our storyboard.
    The following screenshot is an example of our application before and after introducing
    an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The navigation bar style](img/InsertImage_0319OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding our button action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next step is to add the code to be called when the **Add New** button is
    pressed. In our previous chapter, we created an action called `addNewPressed`
    and connected it to our **Add New** button. Let''s go ahead and write the code
    to present the proper view controller when this button is pressed. First, switch
    to `MenuViewController.h`, and directly underneath the standard `#import` for
    UIKit, let''s import our view controllers as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also defined a string literal for our storyboard ID for good practice.
    We have named it `ADD_NEW_VIEW_CONTROLLER` so that we know what it contains. Switch
    back to `MenuViewController.m` and scroll down to our `addNewPressed` method.
    As we will be presenting this view controller (dragging it onto the screen from
    the bottom), we need to also create a navigation controller to hold the `AddNewViewController`
    object. The following is the code for adding a button action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward. We allocate our `AddNewViewController`
    object by initializing it from our storyboard. Make sure that `AddNewViewController`
    in our storyboard has the property for our storyboard ID set to `AddNew` so that
    it matches our string literal defined earlier. Under certain circumstances, it
    is recommended to preinitialize the view controller before presenting it if there
    is a noticeable lag between the button press and the view being presented. Next,
    we create a navigation controller and assign our newly created `AddNewViewController`
    as its root view controller. Last, we tell the current navigation controller to
    present the new one. Go ahead and run the application and test the functionality.
    The `AddNewViewController` object inside of a navigation controller should slide
    onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to our navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that when presenting our `AddNewViewController` object,
    we have no way to dismiss the view to get back to the menu. Let's add this functionality
    now. We will be creating two bar button items that will be text-only items. The
    first button, **Cancel**, will dismiss the view while the second, **Save**, will
    save the new food entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `AddNewViewController.m` and scroll down to `viewDidLoad`. Add the
    following code at the top of `viewDidLoad`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create both bar button items using the built-in **Cancel** and **Save**
    bar button items provided by iOS. Each button also has its own selector (or method)
    that we will code in a moment. Next, we assign each bar button to the navigation
    bar. I chose to place **Cancel** on the left-hand side and **Save** on the right-hand
    side of the bar; however, this order is entirely up to you. If we run our application
    and click on the **Add New** button, our view will slide into place, and you will
    see **Cancel** on the left-hand side and **Save** on the right-hand side. Our
    appearance proxies defined in the app delegate should also be reflected in the
    font and text color. Next, let's actually add the **Cancel** button functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to `AddNewViewController.m` and scroll down to the bottom of `viewDidLoad`.
    We want to allow the user to cancel adding a food item, so let''s write the `cancelButtonPressed`
    method that we earlier assigned to our cancel button. Directly below `viewDidLoad`,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have defined both our `cancelButtonPressed` and `saveButtonPressed` methods
    here (`saveButtonPressed` has been intentionally left blank until later in the
    chapter). In `cancelButtonPressed`, we simply tell the view controller to dismiss
    itself and set the animated view controller to `YES`. Run the application and
    test this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting our storyboard view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some of our code implemented, we need to finish arranging our
    view in `Main.storyboard`. Previously, we only added the required elements and
    did not position or size them correctly. Switch to `Main.storyboard` and scroll
    down to the `AddNewViewController` object.
  prefs: []
  type: TYPE_NORMAL
- en: We have three items to position and size here, starting with the two image views.
    Select the first image view, and in the **Utilities** pane, select the **Size
    Inspector** submenu. Set the width and height to 180 pixels to create a perfect
    square. Position this image view horizontally in the center of the view and slightly
    higher than the vertical center of the view. Do not worry about being precise,
    and feel free to position the image view where you think it looks best!
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the other image view, making it an identical size and
    in exactly the same position. For this image view, switch to the **Attributes
    Inspector** submenu (in the **Utilities** pane on the right-hand side) and set
    its image to `placeholder_image` for `placeholderImageView`. Using the documents
    outline, make sure that this image view is positioned *below* the other image
    view. We will be using two image views to assist in save validation. When a user
    selects or takes an image, it will be set to the top image view (the empty one)
    and cover the placeholder image view beneath it. This allows us to check if the
    top image view contains an image. If it does not, it means the user has not added
    an image and that the placeholder is still visible. In this case, we will alert
    the user to let him/her know that he/she must include a photo.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we need to adjust the settings of our `UITextField` object that will be
    used to type in the name of our food entry. Select the text field and reopen the
    **Size Inspector** submenu from the **Utilities** pane. Set the height to 38 pixels
    and the width to 280 pixels. Position the text field horizontally centered and
    slightly above the image views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Attributes Inspector** from the **Utilities** pane and change
    the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alignment**: Select the Center icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Placeholder**: `Type The Food Name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Border Style**: This field should be set to none (the first of the four buttons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capitalization**: Select Words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final result should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting our storyboard view](img/InsertImage_0319OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding our delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our view is completely set up, we can start coding the desired functionality.
    Before we can move on, we need to specify some delegates that our view controller
    will require to work. We will work with a text field, image picker, navigation
    controller, and action sheet, all of which have their own custom delegates. Switch
    to `AddNewViewController.h` and replace the line of code after `#import` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are simply specifying the protocols that our class will conform to
    in the code. With this final step, we can now start coding our functionality into
    the application!
  prefs: []
  type: TYPE_NORMAL
- en: Using a tap gesture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our application, a user can tap on the placeholder image in order to take
    or select a photo. To do this, we will add a tap gesture recognizer directly to
    the placeholder image view. Switch to `AddNewViewController.m` and scroll down
    to `viewDidLoad`. Add the following code at the bottom of the `viewDidLoad` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we add a border and a corner radius to our image view for visual effect.
    Next, we create a tap gesture recognizer and assign it a method. We also set the
    property `numberOfTapsRequired` to `1`. The last step is to set the user interaction
    enabled on our placeholder image view to `YES` and then add our gesture recognizer
    to it. Now, our image view will keep listening for a single tap and call our `imageViewTapped`
    method when a tap is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the image is tapped, we want to give the user an option to either select
    an image from their library or take a new one using the camera. The best way to
    do this is using an action sheet. Let''s create the `imageViewTapped` method,
    have it display an action sheet, and then respond to the users'' selection accordingly.
    Below the `ButtonPressed` methods, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, when the user taps on the image view, we create an action sheet
    and display it in the current view. We only need the **Cancel** button and two
    additional buttons, one for **Take Picture** and another for **Choose From Library**.In
    order for us to respond accordingly to the selected action sheet button, we need
    to implement the action sheet delegate method. Below the `imageViewTapped` method,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first check if the selected button is the **Cancel** button,
    and if so, we return to end the execution of this method, which will also hide
    the action sheet for us. Next, we check if the button index is equal to `0`, or
    `Take Picture`. If so, we create an instance of `UIImagePickerController`. We
    set the delegate to `self` and also allow editing (this will allow the user to
    crop the image into a perfect square, which is ideal for our application), and
    then we set the source type to camera.
  prefs: []
  type: TYPE_NORMAL
- en: If the button index is `1`, or `Choose From Library`, we use exactly the same
    code with one exception. For this block, set the source type to photo library
    to display the phone's camera library. Save our code and run the application.
    Everything should work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the image from UIImagePickerController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that a user can take a photo or select from their phone''s photo library,
    we need to grab that image and display it. In order to do so, we need to implement
    the image picker''s delegate method, the `didFinishPickingMediaWithInfo` method.
    Below our action sheet delegate method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we create an instance of `UIImage` and assign it using the info
    dictionary provided by the image picker. Because we want our users to edit the
    image, we want to grab the edited version instead of the original (which can be
    accessed using `UIImagePickerControllerOriginalImage`). Now that we have our final
    image, we assign it to our final image view and then hide the placeholder image
    view. Last, we need to tell the image picker controller to dismiss itself to bring
    us back to our `AddNewViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Save everything and run the code to test it out. If you wish to actually take
    a picture with the camera, you must run this on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the text field delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our image, we need to set up the text field delegate. This
    is probably the simplest of all delegate methods because we only need to tell
    the application what to do when the *return* key is pressed. For our application,
    we simply want to hide the keyboard. Below our image picker delegate method, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method simply tells the text view to resign first responder (hide the keyboard)
    when the *return* key is pressed. A user can type in a name, press the *return*
    key, and hide the keyboard. Make sure that the text fields delegate property has
    been set to `AddNewViewController` (self) either in the storyboard or in `viewDidLoad`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have everything we need from the user to create a new food entry. In
    order to save the data, we will need to follow multiple steps so that we can access
    it again later in the app. The save data method we created earlier will be quite
    long once complete, so we will cover it piece by piece for simplicity, starting
    with a custom date helper method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the date string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we will be creating a `.plist` file that will store the
    food entry's name, date created, and the file path to the image. The image itself
    will be saved separately in the documents directory. When saving any file to the
    documents directory, you must specify a filename. In order to save multiple images,
    we need to make sure that every single image file saved has a different filename.
    One of the best (and most popular) ways to accomplish this is using a date.
  prefs: []
  type: TYPE_NORMAL
- en: Each device keeps track of the current date down to the millisecond. This means
    that at any given millisecond, the date will be completely different from every
    date before and every date after. This gives a great way to create a unique identifier
    for each image based on when it was created. What we will do is grab the current
    date, set the date format, and convert it to a string that we will then tack onto
    the end of each filename. This way, every single image will have a unique filename
    that will be stored in our `.plist` file to be accessed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have created a simple helper method that returns the current date as a string
    value that we can use for the filename, so let''s add it to our code. Scroll down
    to the end of the last method and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we first create a date formatter that takes the year, month,
    day, hour, minute, and second values of a date and pushes them together. Next,
    we create a date object and set it to the current date and time. Finally, we create
    a string using our date formatter and return it. Now that we have our helper method,
    let's add the code to save the data!
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to implement the `saveButtonPressed` method. Before we write
    any of the code to actually save the date, we first need to check that the user
    has actually selected an image and added a name. This will prevent us from having
    any errors and will guarantee that we have the required data. Scroll down to the
    empty `saveButtonPressed` method we created earlier and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This validation is very simple but effective. Here, we put to use having multiple
    image views by checking whether the final image view is nil. We also check to
    make sure that a user has actually added text to the text field by checking that
    the text property's length is greater than zero. If either of these two conditions
    is false, we display an alert view telling the user that both a title and an image
    are required to be saved. If both are true, we can proceed with our saving process.
    It is recommended that you use a data model to maintain data in an application;
    however, for our application, this will do fine.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in the saving process is to save the image itself to the documents
    directory. Inside the first `if` statement block, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we grab the first element (which will always be the path to the documents
    directory) from the list of directories in the file system. We then create a new
    path for our image by adding a filename to the end of the documents path. The
    filename is how we access the image later in our app. Using our date helper method,
    we set the filename to image, and the returned date string is separated by a hyphen.
    Now every image will be found in the documents directly with a unique filename.
    Last, we create an instance of `NSData`, assign the user's final image to it as
    data using `UIImagePNGRepresentation`, and then save the date to the image path
    created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our image has been saved, we can save the rest of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating versus loading the .plist file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to save the users'' data, we will be creating a dictionary that contains
    all relevant data for each food entry. We will then add this dictionary to a `.plist`
    file and save the `.plist` file to the documents directory. To make sure we don''t
    save over our previous data, we must first check to see if our `.plist` file already
    exists. Below the previous code for saving the image, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we create another path by adding `Data.plist` to the end of the documents
    directory created earlier (this name can be anything you wish as long as it ends
    in `.plist`). Next, we create an empty array to hold the final `.plist` data and
    allow us to append more data to the end of the file. We create an instance of
    `NSFileManager` and use it to check if the file at the newly created path exists.
    If so, we set the contents of our `.plist` file to the `plistDataArray` method.
  prefs: []
  type: TYPE_NORMAL
- en: If the `.plist` file does not exist, we instead create another empty array,
    save the array as a `.plist` file, and then set the `plistDataArray` method to
    the content of the newly created (but empty) `.plist` file. Now we can add more
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will grab the user data and turn it into a dictionary so that we can
    add it to our data array. Then, we can save it to the documents directory. Add
    the following code after the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new empty mutable dictionary. The dictionary is then filled
    with the user-entered name, the image path used earlier, and the current date
    and time. We then add this dictionary to our `plistDataArray` method and tell
    it to save (write) the file. Last, we dismiss the view controller to bring us
    back to the menu where we started, and our data has been saved!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built the most important component of our application, the
    ability to create new food entries. Now that all of this data has been saved,
    we can retrieve it and start displaying it to our user. Because everything is
    saved directly to the device, we are able to manipulate this data instantly and
    use it as we please.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will build the final piece of our application''s core
    functionality: viewing the user-created data both in a table view and in a detail
    view.'
  prefs: []
  type: TYPE_NORMAL
