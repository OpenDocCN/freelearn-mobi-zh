["```swift\n- (void)replay:(id)sender\n{\n    [[self.view viewWithTag:321] removeFromSuperview];\n    [self.view presentScene:[[GameLevelScene alloc] initWithSize:self.size]];\n\n}\n```", "```swift\n#import \"SKTAudio.h\"\n```", "```swift\n[[SKTAudio sharedInstance] playBackgroundMusic:@\"BackgroundAudio.mp3\"]; //change the file name to whatever file you imported\n```", "```swift\n[self runAction:[SKAction playSoundFileNamed:@\"jump.wav\" waitForCompletion:NO]];\n```", "```swift\n@implementation Player\n{\n  NSArray *walkingAnimation\n}\n```", "```swift\n    NSMutableArray *walkingFrames = [NSMutableArray array];\n    SKTextureAtlas *playerAtlas = [SKTextureAtlas atlasNamed:@\"sprites\"];\n\n    int numberOfImages = 8;\n    for (int i=1; i <= numberOfImages/2; i++) {\n        NSString *imageName = [NSString stringWithFormat:@\"P1Walking%d\", i];\n        SKTexture *temporaryTexture = [playerAtlas textureNamed: imageName];\n        [walkingFrames addObject:temporaryTexture];\n    }\n    walkingAnimation = walkingFrames;\n```", "```swift\n-(void)playWalkingAnim {\n[self runAction:[SKAction repeatActionForever:[SKAction animateWith  Textures:walkingAnimation\n  timePerFrame:0.1f\n  resize:NO\n  restore:YES]]\n  withKey:@\"PlayerWalking\"];\n\nreturn;\n}\n\n-(void)PlayerStoppedMoving {\n [self removeAllActions];\n}\n```", "```swift\n@property (nonatomic, assign) BOOL animateWalking;\n```", "```swift\nself.player1.animateWalking = YES;\n```", "```swift\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x > self.size.width / 2.0) {\n            self.player1.jumping = YES;\n        }        \n        else {\n            if (touchLocation.x < self.size.width / 2.0) {\n//This will check our touch position on the left hand side of the screen\n                if (touchLocation.y > self.size.height / 2){\n//This checks if we are in the top left hand corner of the screen, if so trigger walking backward\n                    self.player1.goingBackwards = YES;\n self.player1.animateWalking = YES;\n                    self.player1.xScale = -1.0;\n                }\n                if (touchLocation.y < self.size.height / 2){\n//This checks if we are touching the bottom left corner. If we are trigger walking forward.\n                    self.player1.walking = YES;\n self.player1.animateWalking = YES;\n                    self.player1.xScale = 1.0;\n                }\n            }\n\n        }\n    }\n}\n```", "```swift\nself.player1.animateWalking = NO;\n```", "```swift\n if (self.animateWalking) {\n        [self actionForKey:@\"PlayerWalking\"];\n    }\n    else {\n        [self PlayerStoppedMoving];\n\n    }\n    if (![self actionForKey:@\"PlayerWalking\"]) {\n\n        [self playWalkingAnim];\n    }\n```", "```swift\nNSString *rainParticles =\n        [[NSBundle mainBundle] pathForResource:@\"Rain\" ofType:@\"sks\"];\n\n        SKEmitterNode *rainEmitter =\n        [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];\n        â€©        rainEmitter.position = CGPointMake(0, self.scene.size.height);\n\n        [self addChild:rainEmitter];\n```", "```swift\n        NSString *fireParticles =\n        [[NSBundle mainBundle] pathForResource:@\"Flames\"              ofType:@\"sks\"];\n\n        SKEmitterNode *fireEmitter =\n        [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];\n        fireEmitter.position = CGPointMake(25, 50);\n\n        [_map addChild:fireEmitter];\n```", "```swift\n@property (nonatomic, assign) NSInteger level;\n```", "```swift\n-(id)initWithSize:(CGSize)size {\n    if (self = [super initWithSize:size]) {\n\n        self.userInteractionEnabled = YES;\n        self.backgroundColor = [SKColor colorWithRed:.0 green:.0 blue:.0 alpha:1.0];\n\n        if (_level == 0){\n        SKLabelNode *playLabel = [SKLabelNode labelNodeWithFontNamed:@\"AvenirNext-Heavy\"];\n        playLabel.text = @\"Adesa\";\n        playLabel.fontSize = 40;\n        playLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);\n        [self addChild:playLabel];\n\n        SKSpriteNode *playButton = [SKSpriteNode spriteNodeWithImageNamed:@\"play\"];\n        playButton.position = CGPointMake(self.size.width /2.0 , self.size.height / 2.5);\n        playButton.name = @\"playButton\";\n        [self addChild:playButton];\n        }\n\n    }\n    return self;\n}\n```", "```swift\nSKNode *node = [self nodeAtPoint:touchLocation];\n\n        if ([node.name isEqualToString:@\"playButton\"]) {\n            _level = 1;\n            [self removeAllChildren];\n\n            [[SKTAudio sharedInstance] playBackgroundMusic:@\"BackgroundAudio.mp3\"];\n            self.map = [JSTileMap mapNamed:@\"level1.tmx\"];\n            [self addChild:self.map];\n            NSString *rainParticles =\n            [[NSBundle mainBundle] pathForResource:@\"Rain\" ofType:@\"sks\"];\n\n            SKEmitterNode *rainEmitter =\n            [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];\n\n            rainEmitter.position = CGPointMake(0, self.scene.size.height);\n\n            [self addChild:rainEmitter];\n\n            NSString *fireParticles =\n            [[NSBundle mainBundle] pathForResource:@\"Flames\" ofType:@\"sks\"];\n\n            SKEmitterNode *fireEmitter =\n            [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];\n            fireEmitter.position = CGPointMake(25, 50);\n\n            [_map addChild:fireEmitter];\n\n            self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n            self.player1.position = CGPointMake(100, 50);\n            self.player1.zPosition = 15;\n            [self.map addChild:self.player1];\n            self.walls = [self.map layerNamed:@\"walls\"];\n            self.hazards = [self.map layerNamed:@\"hazards\"];\n        }\n```", "```swift\n-(void)gameOver:(BOOL)won {\n    if (_level > 0){\n    self.gameOver = YES;\n\n    NSString *gameText;\n    if (won) {\n        gameText = @\"Level Complete!\";\n\n    } else {\n        gameText = @\"You have died!\";\n        //add the following lines of code here:\n self.player1.position = CGPointMake(100, 50);\n self.player1.zPosition = 15;\n [self setViewpointCenter:self.player1.position];\n self.gameOver = NO;\n    }\n}\n}\n UIButton *replay = [UIButton buttonWithType:UIButtonTypeCustom];\n replay.tag = 321;\n UIImage *replayImage = [UIImage imageNamed:@\"replay\"];\n [replay setImage:replayImage forState:UIControlStateNormal];\n [replay addTarget:self action:@selector(replay:) forControlEvents:UIControlEventTouchUpInside];\n replay.frame = CGRectMake(self.size.width / 2.0 - replayImage.size.width / 2.0, self.size.height / 2.0 - replayImage.size.height / 2.0, replayImage.size.width, replayImage.size.height);\n [self.view addSubview:replay];\n\n}\n}\n\n- (void)replay:(id)sender\n{\n [[self.view viewWithTag:321] removeFromSuperview];\n //  [self.view presentScene:[[GameLevelScene alloc] initWithSize:self.size]];\n\n}\n\n```", "```swift\n-(void)didHeWin {\n    if (self.player1.position.x > 3200.0) {\n\n        if (_level == 1) {\n        [self.map removeFromParent];\n        self.map = [JSTileMap mapNamed:@\"level2.tmx\"];\n        [self addChild:self.map];\n\n        }\n        self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n        self.player1.position = CGPointMake(100, 50);\n        self.player1.zPosition = 15;\n        [self.map addChild:self.player1];\n        self.walls = [self.map layerNamed:@\"walls\"];\n        self.hazards = [self.map layerNamed:@\"hazards\"];\n    }\n}\n```", "```swift\n- (void)addSquiggy {\n\n    SKSpriteNode * squiggy = [SKSpriteNode spriteNodeWithImageNamed:@\"Squiggy\"];\n\n    int minY = squiggy.size.height / 2;\n    int maxY = self.frame.size.height - squiggy.size.height / 2;\n    int rangeY = maxY - minY;\n    int actualY = (arc4random() % rangeY) + minY;\n    squiggy.xScale = -1.0;\n    squiggy.position = CGPointMake(self.player1.position.x + 1000 + squiggy.size.width/2, actualY);\n\n    squiggy.name = @\"squiggy\";\n\n    [self.map addChild:squiggy];\n\n    // Setting the Speed of SQUIGGY!\n    int minDuration = 10.0;\n    int maxDuration = 20.0;\n    int rangeDuration = maxDuration - minDuration;\n    int actualDuration = (arc4random() % rangeDuration) + minDuration;\n\n    SKAction * actionMove = [SKAction moveTo:CGPointMake(-squiggy.size.width/2, actualY) duration:actualDuration];\n    SKAction * actionMoveDone = [SKAction removeFromParent];\n    [squiggy runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];\n}\n```", "```swift\n@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;\n@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;\n```", "```swift\n- (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {\n\n    self.lastSpawnTimeInterval += timeSinceLast;\n    if (self.lastSpawnTimeInterval > 2) {\n        self.lastSpawnTimeInterval = 0;\n        [self addSquiggy];\n    }\n}\n\n//Then add this method into our regular update method to call our new updateWithTimeSinceLastUpdate method\n\n       CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;\n    self.lastUpdateTimeInterval = currentTime;\n    if (timeSinceLast > 1) {\n        timeSinceLast = 1.0 / 60.0;\n\n    }\n\n    [self updateWithTimeSinceLastUpdate:timeSinceLast];\n```", "```swift\nstatic const uint32_t playerCategory = 0x1 << 0;\nstatic const uint32_t enemyCategory = 0x1 << 1;\n```", "```swift\nself.physicsWorld.gravity = CGVectorMake(0,0);\nself.physicsWorld.contactDelegate = self;\n```", "```swift\nsquiggy.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:squiggy.size];\n    squiggy.physicsBody.dynamic = YES;\n    squiggy.physicsBody.categoryBitMask = enemyCategory;\n    squiggy.physicsBody.contactTestBitMask = playerCategory;\n    squiggy.physicsBody.collisionBitMask = 0;\n```", "```swift\n -(void)setUpPlayerPhysics{\n    self.player1.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:self.player1.size];\n    self.player1.physicsBody.dynamic = YES;\n    self.player1.physicsBody.categoryBitMask = playerCategory;\n    self.player1.physicsBody.contactTestBitMask = enemyCategory;\n    self.player1.physicsBody.collisionBitMask = 0;\n}\n```", "```swift\n [self setUpPlayerPhysics];\n```", "```swift\n- (void)didBeginContact:(SKPhysicsContact *)contact\n{\n    SKPhysicsBody *firstBody, *secondBody;\n\n    uint32_t collision = (contact.bodyA.categoryBitMask | contact.bodyB.categoryBitMask);\n\n    if (collision == (playerCategory | enemyCategory)) {\n        [contact.bodyA.node removeFromParent];\n        [contact.bodyB.node removeFromParent];\n        [self gameOver:0];\n    }\n\n    else if (collision == (bulletCategory | enemyCategory)) {\n        for (SKSpriteNode *playerBullet in _playerBullets) {\n            if (playerBullet.hidden == NO) {\n                [contact.bodyA.node removeFromParent];\n                [contact.bodyB.node removeFromParent];\n            }\n        }\n    }\n\n    if (contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask)\n    {\n        firstBody = contact.bodyA;\n        secondBody = contact.bodyB;\n\n    }\n    else\n    {\n        firstBody = contact.bodyB;\n        secondBody = contact.bodyA;\n\n    }\n}\n```", "```swift\n-(void)gameOver:(BOOL)won {\n    if (_level > 0){\n    self.gameOver = YES;\n        [_player1 removeFromParent];\n    NSString *gameText;\n    if (won) {\n        gameText = @\"Level Complete!\";\n\n    } else {\n        gameText = @\"You have died!\";\n        self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n        self.player1.position = CGPointMake(100, 50);\n        self.player1.zPosition = 15;\n        [self setUpPlayerPhysics];\n        [self.map addChild:self.player1];\n        [self setViewpointCenter:self.player1.position];\n        self.gameOver = NO;\n    }\n}\n}\n```", "```swift\nstatic const uint32_t bulletCategory = 0x1 << 2;\n```", "```swift\n#define kNumBullets 20\n```", "```swift\nNSMutableArray *_playerBullets;\nint _nextPlayerBullet;\n```", "```swift\n  #pragma mark - Setup the bullets\n    _playerBullets = [[NSMutableArray alloc] initWithCapacity:kNumBullets];\n    for (int i = 0; i < kNumBullets; ++i) {\n        SKSpriteNode *playerBullet = [SKSpriteNode spriteNodeWithImageNamed:@\"Bullet\"];\n        playerBullet.hidden = YES;\n        [_playerBullets addObject:playerBullet];\n        [self.map addChild:playerBullet];\n    }\n```", "```swift\n-(void) startTheGame {\n    for (SKSpriteNode *playerBullet in _playerBullets) {\n        playerBullet.hidden = YES;\n    }\n}\n```", "```swift\n[self startTheGame];\n```", "```swift\n if (touchLocation.x > self.size.width / 2.0) {\n            if (touchLocation.y < self.size.height / 2.0) {\n            self.player1.jumping = YES;\n            }\n            else if (touchLocation.y > self.size.height / 2.0) {\n                NSLog(@\"PEW\");\n                if (touchLocation.x > self.size.width / 2.0) {\n                    if (touchLocation.y < self.size.height / 2.0) {\n                        self.player1.jumping = YES;\n                    }\n                    else if (touchLocation.y > self.size.height / 2.0) {\n                        if (self.player1.xScale == - 1.0) {\n                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];\n                            _nextPlayerBullet++;\n                            if (_nextPlayerBullet >= _playerBullets.count) {\n                                _nextPlayerBullet = 0;\n                            }\n\n                            bullet.position = CGPointMake(_player1.position.x-bullet.size.width/2,_player1.position.y+0);\n                            bullet.hidden = NO;\n                            [bullet removeAllActions];\n\n                            CGPoint location = CGPointMake(_player1.position.x - 1000, _player1.position.y);\n                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];\n\n                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {\n                                bullet.hidden = YES;\n                            }];\n\n                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];\n                            [bullet runAction:moveBulletActionWithDone withKey:@\"bulletFired\"];\n                        }\n\n                        else {\n                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];\n                            _nextPlayerBullet++;\n                            if (_nextPlayerBullet >= _playerBullets.count) {\n                                _nextPlayerBullet = 0;\n                            }\n\n                            bullet.position = CGPointMake(_player1.position.x+bullet.size.width/2,_player1.position.y+0);\n                            bullet.hidden = NO;\n                            [bullet removeAllActions];\n\n                            CGPoint location = CGPointMake(_player1.position.x + 1000, _player1.position.y);\n                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];\n\n                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {\n                                bullet.hidden = YES;\n                            }];\n\n                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];\n                            [bullet runAction:moveBulletActionWithDone withKey:@\"bulletFired\"];\n                        }\n                    }\n                }\n            }\n        }\n```", "```swift\nplayerBullet.hidden = YES;\n        playerBullet.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:playerBullet.size];\n        playerBullet.physicsBody.dynamic = YES;\n        playerBullet.physicsBody.categoryBitMask = bulletCategory;\n        playerBullet.physicsBody.contactTestBitMask = enemyCategory;\n        playerBullet.physicsBody.collisionBitMask = 0;\n```", "```swift\n//  GameLevelScene.m\n\n#import \"GameLevelScene.h\"\n#import \"JSTileMap.h\"\n#import \"Player.h\"\n#import \"SKTUtils.h\"\n#import \"SKTAudio.h\"\n#define kNumBullets 20\n\nstatic const uint32_t playerCategory = 0x1 << 0;\nstatic const uint32_t enemyCategory = 0x1 << 1;\nstatic const uint32_t bulletCategory = 0x1 << 2;\n\n@interface GameLevelScene() <SKPhysicsContactDelegate>\n@property (nonatomic, strong) JSTileMap *map;\n@property (nonatomic, strong) Player *player1;\n@property (nonatomic, assign) NSTimeInterval previousTime;\n@property (nonatomic, strong) TMXLayer *walls;\n@property (nonatomic, strong) TMXLayer *hazards;\n@property (nonatomic, assign) BOOL gameOver;\n\n@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;\n@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;\n@property (nonatomic, assign) NSInteger level;\n@end\n\nNSMutableArray *_playerBullets;\nint _nextPlayerBullet;\n\n@implementation GameLevelScene\n\n-(id)initWithSize:(CGSize)size {\n    if (self = [super initWithSize:size]) {\n\n        self.userInteractionEnabled = YES;\n        self.backgroundColor = [SKColor colorWithRed:.0 green:.0 blue:.0 alpha:1.0];\n        self.physicsWorld.gravity = CGVectorMake(0, 0);\n        self.physicsWorld.contactDelegate = self;\n\n        if (_level == 0){\n        SKLabelNode *playLabel = [SKLabelNode labelNodeWithFontNamed:@\"AvenirNext-Heavy\"];\n        playLabel.text = @\"Adesa\";\n        playLabel.fontSize = 40;\n        playLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);\n        [self addChild:playLabel];\n\n        SKSpriteNode *playButton = [SKSpriteNode spriteNodeWithImageNamed:@\"play\"];\n        playButton.position = CGPointMake(self.size.width /2.0 , self.size.height / 2.5);\n        playButton.name = @\"playButton\";\n        [self addChild:playButton];\n\n        }\n\n    }\n    return self;\n}\n\n-(void) startTheGame {\n    for (SKSpriteNode *playerBullet in _playerBullets) {\n        playerBullet.hidden = YES;\n    }\n}\n\n- (void)addSquiggy {\n\n    SKSpriteNode * squiggy = [SKSpriteNode spriteNodeWithImageNamed:@\"Squiggy\"];\n    squiggy.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:squiggy.size];\n    squiggy.physicsBody.dynamic = YES;\n    squiggy.physicsBody.categoryBitMask = enemyCategory;\n    squiggy.physicsBody.contactTestBitMask = playerCategory;\n    squiggy.physicsBody.collisionBitMask = 0;\n\n    int minY = squiggy.size.height / 2;\n    int maxY = self.frame.size.height - squiggy.size.height / 2;\n    int rangeY = maxY - minY;\n    int actualY = (arc4random() % rangeY) + minY;\n    squiggy.xScale = -1.0;\n    squiggy.position = CGPointMake(self.player1.position.x + 1000 + squiggy.size.width/2, actualY);\n    [self.map addChild:squiggy];\n\n    // Setting the Speed of SQUIGGY!\n    int minDuration = 10.0;\n    int maxDuration = 20.0;\n    int rangeDuration = maxDuration - minDuration;\n    int actualDuration = (arc4random() % rangeDuration) + minDuration;\n\n    SKAction * actionMove = [SKAction moveTo:CGPointMake(-squiggy.size.width/2, actualY) duration:actualDuration];\n    SKAction * actionMoveDone = [SKAction removeFromParent];\n    [squiggy runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];\n}\n\n- (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {\n\n    self.lastSpawnTimeInterval += timeSinceLast;\n    if (self.lastSpawnTimeInterval > 2) {\n        self.lastSpawnTimeInterval = 0;\n        [self addSquiggy];\n\n    }\n}\n\n-(CGRect)tileRectFromTileCoords:(CGPoint)tileCoords {\n    float levelHeightInPixels = self.map.mapSize.height * self.map.tileSize.height;\n    CGPoint origin = CGPointMake(tileCoords.x * self.map.tileSize.width, levelHeightInPixels - ((tileCoords.y + 1) * self.map.tileSize.height));\n    return CGRectMake(origin.x, origin.y, self.map.tileSize.width, self.map.tileSize.height);\n}\n\n- (NSInteger)tileGIDAtTileCoord:(CGPoint)coord forLayer:(TMXLayer *)layer {\n    TMXLayerInfo *layerInfo = layer.layerInfo;\n    return [layerInfo tileGidAtCoord:coord];\n}\n\n- (void)handleHazardCollisions:(Player *)player\n{\n    [self didHeWin];\n\n    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};\n\n    for (NSUInteger i = 0; i < 8; i++) {\n        NSInteger tileIndex = indices[i];\n\n        CGRect playerRect = [player collisionBox];\n        CGPoint playerCoord = [self.hazards coordForPoint:player.desiredPosition];\n\n        NSInteger tileColumn = tileIndex % 3;\n        NSInteger tileRow = tileIndex / 3;\n        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));\n\n        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:self.hazards];\n        if (gid != 0) {\n            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];\n            if (CGRectIntersectsRect(playerRect, tileRect)) {\n                [self gameOver:0];\n            }\n        }\n    }\n}\n\n-(void)gameOver:(BOOL)won {\n    if (_level > 0){\n    self.gameOver = YES;\n        [_player1 removeFromParent];\n    NSString *gameText;\n    if (won) {\n        gameText = @\"Level Complete!\";\n\n    } else {\n        gameText = @\"You have died!\";\n        self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n        self.player1.position = CGPointMake(100, 50);\n        self.player1.zPosition = 15;\n        [self setUpPlayerPhysics];\n        [self.map addChild:self.player1];\n        [self setViewpointCenter:self.player1.position];\n        self.gameOver = NO;\n    }\n}\n}\n\n-(void)setUpPlayerPhysics{\n    self.player1.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:self.player1.size];\n    self.player1.physicsBody.dynamic = YES;\n    self.player1.physicsBody.categoryBitMask = playerCategory;\n    self.player1.physicsBody.contactTestBitMask = enemyCategory;\n    self.player1.physicsBody.collisionBitMask = 0;\n\n#pragma mark - Setup the bullets\n    _playerBullets = [[NSMutableArray alloc] initWithCapacity:kNumBullets];\n    for (int i = 0; i < kNumBullets; ++i) {\n        SKSpriteNode *playerBullet = [SKSpriteNode spriteNodeWithImageNamed:@\"Bullet\"];\n        playerBullet.hidden = YES;\n        playerBullet.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:playerBullet.size];\n        playerBullet.physicsBody.dynamic = YES;\n        playerBullet.physicsBody.categoryBitMask = bulletCategory;\n        playerBullet.physicsBody.contactTestBitMask = enemyCategory;\n        playerBullet.physicsBody.collisionBitMask = 0;\n\n        [_playerBullets addObject:playerBullet];\n        [self.map addChild:playerBullet];\n    }\n}\n\n-(void)didHeWin {\n    if (self.player1.position.x > 3200.0) {\n\n        if (_level == 1) {\n        [self.map removeFromParent];\n        self.map = [JSTileMap mapNamed:@\"level2.tmx\"];\n        [self addChild:self.map];\n        }\n        self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n        self.player1.position = CGPointMake(100, 50);\n        self.player1.zPosition = 15;\n        [self.map addChild:self.player1];\n        self.walls = [self.map layerNamed:@\"walls\"];\n        self.hazards = [self.map layerNamed:@\"hazards\"];\n        [self setUpPlayerPhysics];\n    }\n}\n\n- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer\n{\n\n    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};\n    player.onGround = NO;\n    for (NSUInteger i = 0; i < 8; i++) {\n        NSInteger tileIndex = indices[i];\n\n        CGRect playerRect = [player collisionBox];\n        CGPoint playerCoord = [layer coordForPoint:player.desiredPosition];\n        if (playerCoord.y >= self.map.mapSize.height - 1) {\n            [self gameOver:0];\n            return;\n        }\n\n        NSInteger tileColumn = tileIndex % 3;\n        NSInteger tileRow = tileIndex / 3;\n        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));\n\n        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];\n        if (gid != 0) {\n            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];\n\n            if (CGRectIntersectsRect(playerRect, tileRect)) {\n                CGRect intersection = CGRectIntersection(playerRect, tileRect);\n\n                if (tileIndex == 7) {\n\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height);\n                    player.velocity = CGPointMake(player.velocity.x, 0.0);\n                    player.onGround = YES;\n                } else if (tileIndex == 1) {\n\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y - intersection.size.height);\n                } else if (tileIndex == 3) {\n\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x + intersection.size.width, player.desiredPosition.y);\n                } else if (tileIndex == 5) {\n\n                    player.desiredPosition = CGPointMake(player.desiredPosition.x - intersection.size.width, player.desiredPosition.y);\n\n                } else {\n                    if (intersection.size.width > intersection.size.height) {\n\n                        player.velocity = CGPointMake(player.velocity.x, 0.0);\n                        float intersectionHeight;\n                        if (tileIndex > 4) {\n                            intersectionHeight = intersection.size.height;\n                            player.onGround = YES;\n                        } else {\n                            intersectionHeight = -intersection.size.height;\n                        }\n                        player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height );\n                    } else {\n\n                        float intersectionWidth;\n                        if (tileIndex == 6 || tileIndex == 0) {\n                            intersectionWidth = intersection.size.width;\n                        } else {\n                            intersectionWidth = -intersection.size.width;\n                        }\n\n                        player.desiredPosition = CGPointMake(player.desiredPosition.x  + intersectionWidth, player.desiredPosition.y);\n                    }\n                }\n            }\n        }\n    }\n\n    player.position = player.desiredPosition;\n    [self handleHazardCollisions:self.player1];\n}\n\n- (void)didBeginContact:(SKPhysicsContact *)contact\n{\n    SKPhysicsBody *firstBody, *secondBody;\n\n    uint32_t collision = (contact.bodyA.categoryBitMask | contact.bodyB.categoryBitMask);\n\n    if (collision == (playerCategory | enemyCategory)) {\n        [contact.bodyA.node removeFromParent];\n        [contact.bodyB.node removeFromParent];\n        [self gameOver:0];\n    }\n\n    else if (collision == (bulletCategory | enemyCategory)) {\n        for (SKSpriteNode *playerBullet in _playerBullets) {\n            if (playerBullet.hidden == NO) {\n                [contact.bodyA.node removeFromParent];\n                [contact.bodyB.node removeFromParent];\n            }\n        }\n    }\n\n    if (contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask)\n    {\n        firstBody = contact.bodyA;\n        secondBody = contact.bodyB;\n\n    }\n    else\n    {\n        firstBody = contact.bodyB;\n        secondBody = contact.bodyA;\n\n    }\n}\n\n- (void)setViewpointCenter:(CGPoint)position {\n    NSInteger x = MAX(position.x, self.size.width / 2);\n    NSInteger y = MAX(position.y, self.size.height / 2);\n    x = MIN(x, (self.map.mapSize.width * self.map.tileSize.width) - self.size.width / 2);\n    y = MIN(y, (self.map.mapSize.height * self.map.tileSize.height) - self.size.height / 2);\n    CGPoint actualPosition = CGPointMake(x, y);\n    CGPoint centerOfView = CGPointMake(self.size.width/2, self.size.height/2);\n    CGPoint viewPoint = CGPointSubtract(centerOfView, actualPosition);\n    self.map.position = viewPoint;\n}\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n\n        SKNode *node = [self nodeAtPoint:touchLocation];\n\n        if ([node.name isEqualToString:@\"playButton\"]) {\n            _level = 1;\n            [self removeAllChildren];\n            self.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];\n            [[SKTAudio sharedInstance] playBackgroundMusic:@\"BackgroundAudio.mp3\"];\n            self.map = [JSTileMap mapNamed:@\"level1.tmx\"];\n            [self addChild:self.map];\n            NSString *rainParticles =\n            [[NSBundle mainBundle] pathForResource:@\"Rain\" ofType:@\"sks\"];\n\n            SKEmitterNode *rainEmitter =\n            [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];\n\n            rainEmitter.position = CGPointMake(0, self.scene.size.height);\n\n            [self addChild:rainEmitter];\n\n            NSString *fireParticles =\n            [[NSBundle mainBundle] pathForResource:@\"Flames\" ofType:@\"sks\"];\n\n            SKEmitterNode *fireEmitter =\n            [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];\n            fireEmitter.position = CGPointMake(25, 50);\n\n            [_map addChild:fireEmitter];\n\n            self.player1 = [[Player alloc] initWithImageNamed:@\"P1idle\"];\n            self.player1.position = CGPointMake(100, 50);\n            self.player1.zPosition = 15;\n            [self.map addChild:self.player1];\n            self.walls = [self.map layerNamed:@\"walls\"];\n            self.hazards = [self.map layerNamed:@\"hazards\"];\n            [self setUpPlayerPhysics];\n            [self startTheGame];\n        }\n\n        if (touchLocation.x > self.size.width / 2.0) {\n            if (touchLocation.y < self.size.height / 2.0) {\n            self.player1.jumping = YES;\n            }\n            else if (touchLocation.y > self.size.height / 2.0) {\n                NSLog(@\"PEW\");\n                if (touchLocation.x > self.size.width / 2.0) {\n                    if (touchLocation.y < self.size.height / 2.0) {\n                        self.player1.jumping = YES;\n                    }\n                    else if (touchLocation.y > self.size.height / 2.0) {\n                        if (self.player1.xScale == - 1.0) {\n                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];\n                            _nextPlayerBullet++;\n                            if (_nextPlayerBullet >= _playerBullets.count) {\n                                _nextPlayerBullet = 0;\n                            }\n\n                            bullet.position = CGPointMake(_player1.position.x-bullet.size.width/2,_player1.position.y+0);\n                            bullet.hidden = NO;\n                            [bullet removeAllActions];\n\n                            CGPoint location = CGPointMake(_player1.position.x - 1000, _player1.position.y);\n                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];\n\n                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {\n                                bullet.hidden = YES;\n                            }];\n\n                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];\n                            [bullet runAction:moveBulletActionWithDone withKey:@\"bulletFired\"];\n                        }\n\n                        else {\n                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];\n                            _nextPlayerBullet++;\n                            if (_nextPlayerBullet >= _playerBullets.count) {\n                                _nextPlayerBullet = 0;\n                            }\n\n                            bullet.position = CGPointMake(_player1.position.x+bullet.size.width/2,_player1.position.y+0);\n                            bullet.hidden = NO;\n                            [bullet removeAllActions];\n\n                            CGPoint location = CGPointMake(_player1.position.x + 1000, _player1.position.y);\n                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];\n\n                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {\n                                bullet.hidden = YES;\n                            }];\n\n                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];\n                            [bullet runAction:moveBulletActionWithDone withKey:@\"bulletFired\"];\n                        }\n                    }\n                }\n            }\n        }\n\n        else {\n            if (touchLocation.x < self.size.width / 2.0) {\n                if (touchLocation.y > self.size.height / 2){\n                    self.player1.goingBackwards = YES;\n                    self.player1.animateWalking = YES;\n                    self.player1.xScale = -1.0;\n                }\n                if (touchLocation.y < self.size.height / 2){\n                    self.player1.walking = YES;\n                    self.player1.animateWalking = YES;\n                    self.player1.xScale = 1.0;\n                }\n            }\n\n        }\n    }\n}\n\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n    for (UITouch *touch in touches) {\n\n        float halfWidth = self.size.width / 2.0;\n        CGPoint touchLocation = [touch locationInNode:self];\n\n        CGPoint previousTouchLocation = [touch previousLocationInNode:self];\n\n        if (touchLocation.x > halfWidth && previousTouchLocation.x <= halfWidth) {\n            self.player1.walking = NO;\n            self.player1.goingBackwards = NO;\n            self.player1.jumping = YES;\n        } else if (previousTouchLocation.x > halfWidth && touchLocation.x <= halfWidth) {\n\n            self.player1.goingBackwards = NO;\n            self.player1.jumping = NO;\n        }\n        else if (previousTouchLocation.x > halfWidth && touchLocation.x <= halfWidth) {\n            if (touchLocation.y > self.size.height / 2){\n            self.player1.walking = NO;\n            self.player1.jumping = NO;\n            }\n        }\n    }\n}\n\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n\n    for (UITouch *touch in touches) {\n        CGPoint touchLocation = [touch locationInNode:self];\n        if (touchLocation.x < self.size.width / 2.0) {\n            if (touchLocation.x < self.size.width / 2.0) {\n                if (touchLocation.y > self.size.height / 2){\n                    self.player1.goingBackwards = NO;\n                    self.player1.animateWalking = NO;\n                }\n                if (touchLocation.y < self.size.height / 2){\n                    self.player1.walking = NO;\n                    self.player1.animateWalking = NO;\n                }\n            }\n\n        } else {\n            self.player1.jumping = NO;\n        }\n    }\n}\n\n- (void)update:(NSTimeInterval)currentTime\n{\n\n    CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;\n    self.lastUpdateTimeInterval = currentTime;\n    if (timeSinceLast > 1) {\n        timeSinceLast = 1.0 / 60.0;\n        self.lastUpdateTimeInterval = currentTime;\n    }\n\n    [self updateWithTimeSinceLastUpdate:timeSinceLast];\n\n    if (self.gameOver) return;\n\n    [self setViewpointCenter:self.player1.position];\n    NSTimeInterval delta = currentTime - self.previousTime;\n\n    if (delta > 0.02) {\n        delta = 0.02;\n    }\n\n    self.previousTime = currentTime;\n\n    [self.player1 update:delta];\n\n    [self checkForAndResolveCollisionsForPlayer:self.player1 forLayer:self.walls];\n}\n\n@end //(which is fitting because this is the end of the chapter... and end of the page :D)\n```"]