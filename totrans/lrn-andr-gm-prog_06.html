<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Collision Detection and Basic Artificial Intelligence</h1>
            </header>

            <article>
                
<p>You learned an overview on how to play animations in our game, and now we are going to go a step further into this exciting journey of game development by learning one of the most complex yet crucial concepts required to make our game feel realistic. By adding animations, we can make our game look realistic, but it is also important for a game to feel realistic because that is what makes it fun to play. In this chapter, we will be taking a look at the following two concepts in further detail:</p>
<ul>
<li>Collision detection</li>
<li>Artificial intelligence</li>
</ul>
<p>Thus, this chapter will be divided into two main sections. The studies of collision detection and artificial intelligence are in themselves quite vast topics. For the sake of simplicity to serve our purpose, we will be taking a look at the most basic version of these topics to get an entry level understanding for being able to apply the knowledge of these concepts in our game. So without further ado, let's dive into this complex yet exciting topic of collision detection.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Collision detection</h1>
            </header>

            <article>
                
<p>To explain it simply, collision is a short duration interaction between two bodies. There are many different types of collisions such as elastic and non-elastic. The study of the intersection of two or more objects overlapping each other is called as <strong>collision detection</strong>. It is one of the most complex pieces of computational mathematics and is divided into many types, such as:</p>
<ul>
<li><strong>Bounding Box Collision:</strong> This is the simplest form of collision techniques wherein we take two rectangles and check for collision if they overlap each other. For this, we need four coordinates of each rectangle, namely, the <em>x</em> and <em>y</em> position and width and height of both rectangles.</li>
<li><strong>Circle Collision: </strong>This is the second simplest type of collision wherein we test for collisions between two circles. Here, the radius of two circles and <em>x</em> and <em>y</em> position of the center of the circles are taken into account to test for overlapping.</li>
<li><strong>Separating Axis Theorem:</strong> This type of collision is a bit more complex than the other two mentioned earlier, primarily because this is used to detect collisions between two polygons.</li>
</ul>
<p>There are, of course, many other types of collisions, but that is a totally huge concept in itself. For the purpose of this book, we will be dealing with the simpler forms of collision, and based on the understanding of these concepts, you can experiment further with more complex collision types.</p>
<p>Now, let's look at the algorithms for the three types of collisions you learned about.</p>
<div class="packt_infobox">These algorithms are just pseudo codes. Pseudo means false, which means these codes are not to be executed. They are just mentioned here for the purpose of understanding the different collision techniques.</div>
<p>Let's take a look at each of them individually before resuming work on our game project.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Algorithms for collision detection techniques</h1>
            </header>

            <article>
                
<p>It is very essential that we get a foundation for understanding these collision techniques and therefore it is very important that we understand the way these techniques work. Let's take a look at the different algorithms for detecting collisions. We will be using these concepts in our game when we are dealing with collisions further in this chapter. Since we will only be working with the simple types in this book, we will only take a look at the algorithms for Bounding Box and Circle Collision Detection techniques. </p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Bounding Box Collision</h1>
            </header>

            <article>
                
<p>We saw in our preceding explanation points that Bounding Box Collision technique is one of the simplest. That's because we are simply testing for between two rectangles. Consider the following pseudo code for a better understanding:</p>
<pre>
rectangle1 = {x: 5, y: 5, width: 50, height: 50}<br/>rectangle2 = {x: 20, y: 10, width: 10, height: 10}<br/><br/>if(rectangle1.x &lt; rectangle2.x + rectangle2.width &amp;&amp; rectangle1.width &gt; rectangle2.x &amp;&amp; rectangle1.y &lt; rectangle2.y + rectangle2.height &amp;&amp; rectangle1.height + rectangle1.y &gt; rectangle2.y) <br/>{<br/>    //Bounding Box Collision Detected<br/>}<br/><br/>// Taking the values from our variables<br/>if (5 &lt; 30 &amp;&amp; 55 &gt; 20 &amp;&amp; 5 &lt; 20 &amp;&amp; 55 &gt; 10) {<br/> // Bounding Box Collision Detected!<br/>}
</pre>
<p>As you can see from the preceding code, the mathematical operations required to detect a collision through this technique are quite simplistic. We are only working with basic <kbd>x</kbd>, <kbd>y</kbd> coordinates and <kbd>width</kbd> and <kbd>height</kbd>. </p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Circle Collision</h1>
            </header>

            <article>
                
<p>Yet another simple type of collision, this deals with mapping out the distance between the centers of two circles to detect a collision. Its algorithm goes as follows:</p>
<pre>
circle1 = {radius: 20, x: 5, y: 5};<br/>circle2 = {radius: 12, x: 10, y: 5};<br/><br/>dx = circle1.x - circle2.x;<br/>dy = circle1.y - circle2.y;<br/><br/>distance = Math.sqrt(dx * dx + dy * dy);<br/><br/>if (distance &lt; circle1.radius + circle2.radius) {<br/> // Circle Collision!<br/>}
</pre>
<p>As you can observe here, we have two circles. We then take their individual distances of <kbd>x</kbd> and <kbd>y</kbd> coordinates. After that, we take the square root of the sum of their squares. This is just the simple formula to calculate the distance between two circles. Then in our testing condition, we check if the distance is less than the sum of two circles. </p>
<p>Now that we have a basic understanding of the algorithms for collision detection, we are equipped to move ahead on detecting the collision in our game. Let's start with it!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Detecting collisions in our game</h1>
            </header>

            <article>
                
<p>Since we are dealing with a game here, we will be dealing with the theory with a practical application. So, let's a take up a task of studying collision techniques with an example of an approaching rock toward the player. Our game is a side scrolling game and therefore there will be multiple obstacles and collectibles heading our way. Through the simple Bounding Box Collision technique, we can detect collisions between our player and other objects and execute corresponding functions.</p>
<p>After we are done creating our incoming rocks, we will also create incoming coins so that the player can score points as well. However, before we proceed with this, we have to come up with a way for our player to avoid these obstacles too. We will be implementing collision detection wherein if the player collides with a rock then he will die. Thus, it is crucial for our player to jump. We will give our player jumping abilities on our touch input. So, let's get our player to jump!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Making our player jump</h1>
            </header>

            <article>
                
<p>Since in our further chapters, we will be spawning obstacles and coins randomly on the screen, we will modify our player to navigate up and down on the screen. So, let's say if you touch your screen, the player will go up and if you stop touching the screen, our player will go down. Let us take a look at the changes we need to implement in our code first and then understand them step by step by breaking them down. We will be working on the <kbd>GameView.java</kbd> file for this code portion.</p>
<p>Initially, our animation used to start as soon as the game started. But we need a little bit more control over our actions so we used our <kbd>getPlaying()</kbd> function to achieve this. Here's how we will tackle this problem:</p>
<p>We added a condition in our <kbd>update()</kbd> method that if our player is playing only then will we update our background image and player character. It simply means that the game won't start without some signal:</p>
<pre>
<span>public void </span>update(){<br/><strong>    if(playerCharacter.getPlaying()) {<br/></strong><strong>        bgImg.update();<br/></strong><strong>        playerCharacter.update();<br/></strong><strong>    }</strong><br/>}
</pre>
<p>We will now use the <kbd>onTouchEvent()</kbd> to notify that our game has started as well as when to go up and when to go down. In the first condition inside our <kbd>onTouchEvent()</kbd> , we will check if we have a touch event on the screen. <kbd>ACTION_DOWN</kbd> means that the screen is touched.</p>
<p>Inside this, if blocked, we will have another if block, which checks if the player is playing or not. If the player is not playing, then we set the <kbd>setPlaying()</kbd> function to set a <kbd>true</kbd> value, thereby starting the game loop which then starts the <kbd>update()</kbd> method because of our condition in step 1. Otherwise, it will simply tell the player that the screen is touched and therefore our <kbd>up</kbd> Boolean variable is set to <kbd>true</kbd>, which means the player goes up.</p>
<p>After this, we will write the <kbd>return true</kbd> statement, which is responsible for notifying about the touch event since our <kbd>onTouchEvent()</kbd> has a Boolean return type.</p>
<p>Next, we define our condition for the player to go down. In our case, this simply means that the touch input is no longer received, which means our finger was lifted from the screen. <kbd>ACTION_UP</kbd> defines this event.</p>
<p>If this event takes place, then we set our <kbd>up</kbd> variable to <kbd>false</kbd> and therefore our player goes down.</p>
<p>We will again write a <kbd>return true</kbd> statement for our event. Here's what our code for <kbd>onTouchEvent()</kbd> will look like:</p>
<pre>
<span>    @Override<br/></span><span>    </span><span>public boolean </span>onTouchEvent(MotionEvent event)<br/>    {<br/><strong>        if(event.getAction() == MotionEvent.ACTION_DOWN) {</strong><br/><strong>            if(!playerCharacter.getPlaying()){</strong><br/><strong>                playerCharacter.setPlaying(true);</strong><br/><strong>            } else {</strong><br/><strong>                playerCharacter.setUp(true);</strong><br/><strong>            }</strong><br/><strong>            return true;</strong><br/><strong>        }</strong><br/><br/><strong>        if(event.getAction() == MotionEvent.ACTION_UP){</strong><br/><strong>            playerCharacter.setUp(false);</strong><br/><strong>            return true;</strong><br/><strong>        }<br/></strong><span>        return super</span>.onTouchEvent(event);<br/>    }
</pre>
<p>From this edit, we have only defined the calls required for setting the up and down functionality of our player. However, we also need to add acceleration and deceleration to our player in order to actually move up and down. We will achieve this by editing our <kbd>PlayerCharacter.java</kbd> file. Let's write some jumping code in this file. Open it up and write the following code marked in bold in the <kbd>update()</kbd> method:</p>
<pre>
    <span>public void </span>update() {<br/><span>        long </span>elapsed = (System.<span>nanoTime</span>()-<span>startTime</span>)/<span>1000000</span>;<br/><span>        if</span>(elapsed &gt; <span>100</span>) {<br/><span>            score</span>++;<br/><span>            startTime </span>= System.<span>nanoTime</span>();<br/>        }<br/><span>        ac</span>.update();<br/><strong><br/>        if(up){</strong><br/><strong>            dyc = (int)(dya-=1.1);</strong><br/><strong>        }</strong><br/><strong>        else {</strong><br/><strong>            dyc = (int)(dya+=1.1);</strong><br/><strong>        }</strong><br/><br/><strong>        if(dyc &gt; 10) {</strong><br/><strong>            dyc = 10;</strong><br/><strong>        }</strong><br/><strong>        if(dyc &lt; -10) {</strong><br/><strong>            dyc = -10;</strong><br/><strong>        }</strong><br/><br/><strong>        yc += dyc*2;</strong><br/><strong>        dyc = 0;</strong><br/>    }
</pre>
<p>This block of code is extremely easy to understand. Let's break it down to get a proper grasp of the same:</p>
<ol>
<li>We check if our <kbd>up</kbd> variable is true or not.</li>
<li>If it is <kbd>true</kbd> , then we add a positive acceleration value which <em>increases by 1.1</em> in every update. You can tweak these values as per your liking.</li>
<li>If it is <kbd>false</kbd>, then we add a negative acceleration value which <em>decreases by 1.1</em> in every update.</li>
<li>After this, we don't want the acceleration or deceleration to go beyond a certain limit so we limit it to some bounds. In our case, we have kept a <em>maximum of 10 and minimum of -10.</em></li>
<li>We add the double of our acceleration value to the <kbd>y</kbd> coordinates.</li>
<li>We set our deceleration to 0 to reset it on our next <kbd>update()</kbd> call.</li>
</ol>
<div class="packt_tip">You can tweak the acceleration values to test for yourself and get comfortable with the desired speed. To change the speed of acceleration, simply change the values in <kbd>dyc</kbd>.</div>
<p>And this will make our player jump with joy! Build your game and test it on your device or emulator. You will observe two things here:</p>
<ul>
<li>The game is paused when you start it and will only play when you touch the screen. This is because of our if condition in our <kbd>GameView.java</kbd> file.</li>
<li>Your player now moves up and down because of the acceleration values we provided in the <kbd>PlayerCharacter.java</kbd> file.</li>
</ul>
<p>Now that we have established this, it's time to deal with oncoming obstacles and dodge them! Oh, and also learn about collisions in the process.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Dodging incoming rocks</h1>
            </header>

            <article>
                
<p>The very first thing we would need before we proceed with anything is a nice looking piece of rock. Not kidding, really! We need an image of a toony-looking rock, which would fit with the theme of our game. So, let's get a rock for ourselves. For the purpose of this chapter, we will be using this rock:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="214" src="assets/B05066_06_01.png" width="214"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">This is our basic rock</div>
<p>As we had done in our previous part, we will need animation for the rock and so we will create a sprite sheet of the rock we have. Then, we will simply name it as <kbd>rock.png</kbd> and get started with it. It would be cool to have a rolling rock since that would make more sense in the game, and so we will use a rolling rock sprite sheet.</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="206" src="assets/B05066_06_02.png" width="506"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Our <span class="packt_screen">rock.png</span> sprite sheet</div>
<p>Of course, as we saw before, this rock is also just an image and will be placed inside the <kbd>res/drawable</kbd> folder as we did before. So, pick up any rock and place it into the <kbd>res/drawable</kbd> folder to get started.</p>
<p>Now, since we are going to deal with a new object it must be pretty clear by this point that we would need to create a new class. So let's go ahead and do that. Create a new class and name it <kbd>Rock.java</kbd>. This will have all our code for our obstacle rock. You will then have a blank java file in which you will need to extend it to our <kbd>GameObj.java</kbd> file like every other game object in our game:</p>
<pre>
<span>package </span>nikhil.nikmlnkr.game;<br/><br/><span>/**<br/></span><span> * Created by Nikhil on 30-01-2017.<br/></span><span> */<br/></span><span><br/></span><span>public class </span><span>Rock <strong>extends GameObj</strong></span> {<br/>}
</pre>
<p>Now gear up! We are going to do some heavy duty coding on this one. Let's take a look at this step by step. We will need three methods in this file:</p>
<ul>
<li><kbd>Constructor</kbd>: This will have the parameters for our rock, such as the <kbd>x</kbd>, <kbd>y</kbd> positions, <kbd>width</kbd>, <kbd>height</kbd>, <kbd>score</kbd>, and so on</li>
<li><kbd>Update</kbd> method: This is the method, as seen earlier, that gets called in every frame
<ul>
<li><kbd>Draw</kbd> method: This method is responsible for actually drawing our object on the screen</li>
</ul>
</li>
</ul>
<p>Let's begin with our constructor and variables. We will need a <kbd>score</kbd> and <kbd>speed</kbd> variable as well as a variable for <kbd>Bitmap</kbd> and our predefined <kbd>AnimationClass</kbd>, since we will be animating this rock as well. Let's do that. We will start with the variables first. We will declare our variables that will be needed for the game, which includes <kbd>score</kbd>, <kbd>speed</kbd>, our <kbd>animationClass</kbd> reference, and <kbd>spriteSheet</kbd> reference. We have also taken a <kbd>Random</kbd> number reference variable to generate a score based on a unique condition in the game loop that you will see shortly. Currently, we are not displaying the score on the screen but soon you will see it:</p>
<pre>
<span>package </span>nikhil.nikmlnkr.game;<br/><br/><span>import </span>android.graphics.Bitmap;<br/><span>import </span>android.graphics.BitmapFactory;<br/><span>import </span>android.graphics.Canvas;<br/><br/><span>import </span>java.util.Random;<br/><br/><span>/**<br/></span><span> * Created by Nikhil on 30-01-2017.<br/></span><span> */<br/></span><span><br/></span><span>public class </span>Rock <span>extends </span>GameObj{<br/><span><br/>    private int </span><span>score</span>;<br/><span>    private int </span><span>speed</span>;<br/><span>    private </span>Random <span>rnd </span>= <span>new </span>Random ();<br/><span>    private </span>AnimationClass <span>animationClass </span>= <span>new </span>AnimationClass();<br/><span>    private </span>Bitmap <span>spriteSheet</span>;<br/><br/>}
</pre>
<p>Now, we will write our constructor. There are a bunch of parameters needed for the constructor such as the <kbd>x</kbd>, <kbd>y</kbd> coordinates, <kbd>width</kbd>, <kbd>height</kbd>, <kbd>score</kbd>, and <kbd>noOfFrames</kbd>. We basically take their reference as parameters to our method and hence we require <kbd>xc</kbd>, <kbd>yc</kbd>, <kbd>w</kbd>, <kbd>h</kbd>, <kbd>s</kbd>, and <kbd>noOfFrames</kbd> as parameters in our constructor.</p>
<p>After that, we actually need our rock to go faster once we survive for a longer time and hence we will write the code in such a way that, as our score increases, our rocks will become faster. We will use a little bit of math for this, wherein we will use our random variable. Basically, this will be our formula: <kbd>speed = 7 + (int) (rnd.nextDouble()*score/30);</kbd>. Then we will set our Bitmap reference variable so it can scan through our sprite sheet followed by a <kbd>for</kbd> loop to scan through the same. And finally, we will set our frames to our <kbd>animationClass</kbd> and add a delay for our animation to play. Let's see how that works out in our code:</p>
<pre>
<span>    public </span>Rock (Bitmap res, <span>int </span>xc, <span>int </span>yc, <span>int </span>w, <span>int </span>h, <span>int </span>s, <span>int </span>noOfFrames) {<br/><span>        this</span>.<span>xc </span>= xc;<br/><span>        this</span>.<span>yc </span>= yc;<br/><span>        width </span>= w;<br/><span>        height </span>= h;<br/><span>        score </span>= s;<br/><span><br/>        speed </span>= <span>7  </span>+ (<span>int</span>) (<span>rnd</span>.nextDouble()*<span>score</span>/<span>30</span>);<br/><span><br/>        if</span>(<span>speed </span>&gt; <span>35</span>)<br/><span>            speed </span>= <span>35</span>;<br/><br/>        Bitmap[] img = <span>new </span>Bitmap[noOfFrames];<br/><span><br/>        spriteSheet </span>= res;<br/><span><br/>        for</span>(<span>int </span>i=<span>0</span>; i&lt;img.<span>length</span>; i++) {<br/>        img[i] = Bitmap.<span>createBitmap</span>(<span>spriteSheet</span>, <span>0</span>, i*<span>height</span>, <br/><span>            width</span>,  <span>height</span>);<br/>        }<br/><span><br/>        animationClass</span>.setFrames(img);<br/><span>        animationClass</span>.setDelay(<span>100</span>);<br/><br/>    }
</pre>
<p>In this part of the code, we did nothing new but simply created our rock game object and its drawing on the screen method. It's the same thing that we did with our <kbd>PlayerCharacter</kbd>.</p>
<p>Now that our constructor is ready, we can move on to write our code for the <kbd>update()</kbd> and <kbd>draw()</kbd> methods. In our <kbd>update()</kbd> method, we don't need to do much. We'll only be moving our rock from right to left, and hence we'll use our <kbd>speed</kbd> variable to just shift our rock certain units in every frame toward the left. We will use the <kbd>draw()</kbd> method to simply draw our rock on the screen with the help of the <kbd>animationClass</kbd> reference variable:</p>
<pre>
    <span>public void </span>update() {<br/><span>        xc </span>-= <span>speed</span>;<br/><span>        animationClass</span>.update();<br/>    }<br/><span><br/>    public void </span>draw(Canvas canvas) {<br/><span>        try </span>{<br/>            canvas.drawBitmap(<span>animationClass</span>.getImage(), <span>xc</span>, <span>yc</span>, <span>null</span>);<br/>        } <span>catch </span>(Exception e) {}<br/>    }
</pre>
<p>As you can see in the preceding code, we simply created our <kbd>update()</kbd> method and shifted our rock certain units on the left with our <kbd>speed</kbd> variable. After that, immediately we gave a call to the <kbd>update()</kbd> method of <kbd>animationClass</kbd> so that the sprite sheet of the rock gets updated and we get an effect as though the rock is rolling as it moves.</p>
<p>We then simply used the <kbd>drawBitmap()</kbd> method to draw our rock on the screen.</p>
<p>We created our object, and now it's time for us to display it on the screen, and once we are done with that objective, we will move on to detecting the collision when it collides with our player.</p>
<p>We will now create our rocks on the <kbd>GameView.java</kbd> file, which will spawn rocks at continuous intervals. Also, when our player collides with our rocks it will pause the game. So, let's open up our <kbd>GameView.java</kbd> file and get started with writing the code for this.</p>
<p>We will create three new reference variables, <kbd>rockStartTime</kbd>, <kbd>rocks</kbd>, and <kbd>rnd</kbd>, which correspond to the start time of our rock game object, our actual rock game object, and a random variable for the purpose of randomizing the spawn location of the rocks on the screen. Since we are going to be spawning multiple rocks on the screen, we took its data type to be an <kbd>ArrayList</kbd> since dynamic arrays can be supported through an <kbd>ArrayList</kbd>. We will be needing this primarily because after our rocks have left the screen space, we will remove them, thereby having proper memory management of resources:</p>
<pre>
<strong>    private long rockStartTime;<br/></strong><strong>    private ArrayList&lt;Rock&gt; rocks;</strong><br/><strong><br/>    private Random rnd = new Random();</strong>
</pre>
<p>We will improvise a bit on our <kbd>surfaceDestroyed()</kbd> method and create a <kbd>counter</kbd> as well as shift our <kbd>retry</kbd> variable block in order to avoid an infinite loop situation. Code changes are marked in bold:</p>
<pre>
<span>    @Override<br/></span><span>    </span><span>public void </span>surfaceDestroyed(SurfaceHolder holder){<br/><span>        boolean </span>retry = <span>true</span>;<br/><strong>        int counter = 0;<br/></strong><strong>        while(retry &amp;&amp; counter &lt;1000)</strong><br/>        {<br/>            counter++;<br/><span>            try </span>{<span>mainThread</span>.setRunning(<span>false</span>);<br/><span>                mainThread</span>.join();<br/><strong>                retry = false;</strong><br/>            } <span>catch</span>(InterruptedException e){e.printStackTrace();}<br/>        }<br/><br/>    }
</pre>
<p>In our <kbd>surfaceCreated()</kbd> method, we assign our reference variable rocks with our <kbd>Rock</kbd> class and we initialize the <kbd>rockStartTime</kbd> variable to take in the current <kbd>System.nanoTime()</kbd> as follows:</p>
<pre>
<span>    @Override<br/></span><span>    </span><span>public void </span>surfaceCreated(SurfaceHolder holder){<br/><span><br/>        bgImg </span>= <span>new </span>BackgroundImage(BitmapFactory.<span>decodeResource<br/></span>        (getResources(),  R.drawable.<span>background_image</span>));<br/><span>        playerCharacter </span>= <span>new <br/></span>        PlayerCharacter(BitmapFactory.<span>decodeResource<br/></span>        (getResources(),R.drawable.<span>player_run</span>),<span>200</span>,<span>246</span>,<span>3</span>);<br/><strong>        rocks = new ArrayList&lt;Rock&gt;();</strong><br/><br/><strong>        rockStartTime = System.nanoTime();</strong><br/><span><br/>        //we can safely start the game loop<br/></span><span>        </span><span>mainThread</span>.setRunning(<span>true</span>);<br/><span>        mainThread</span>.start();<br/><br/>    }
</pre>
<p>In our update method, we address the real beast of <em>spawning rocks on the screen</em>. There are multiple things we are managing here so let's break them down further.</p>
<p>We will declare our <kbd>rockElapsed</kbd> variable, which keeps track of how much time the rock has been on the screen.</p>
<p>Then, we define the frequency with which we want to spawn our rocks on the screen. You can manipulate this value in the <kbd>if</kbd> condition as you please according to the desired effects you want.</p>
<p>Inside this <kbd>if</kbd> block, we have another nested <kbd>if</kbd> block which is essentially just to define where the rock will spawn. Here, we are defining the rock spawning in such a way that the first rock element is in the middle part of the screen, as you can see from the math calculations. Or if it is any other element than our first spawned rock, then we tell it to spawn randomly in any location where our <kbd>rnd</kbd> random variable comes into the picture.</p>
<p>We then define our collision logic. We will use a <kbd>for</kbd> loop here to run through all our rock objects on the screen, and if any element collides with our player character, then we pause the game.</p>
<p>Lastly, if the rock goes out of our defined screen space, then we <kbd>remove</kbd> the object from our <kbd>ArrayList</kbd>.</p>
<p>Let's write the code for this:</p>
<pre>
<span>    public void </span>update(){<br/><span>        if</span>(<span>playerCharacter</span>.getPlaying()) {<br/><span>            bgImg</span>.update();<br/><span>            playerCharacter</span>.update();<br/><strong><br/>            //spawn rocks on screen<br/>            long rockElapsed = (System.nanoTime() - <br/>            rockStartTime/1000000);</strong><br/><strong>            if(rockElapsed&gt;(2000 - playerCharacter.getScore()/4)){</strong><br/><strong>                if(rocks.size() == 0){</strong><br/><strong>                    rocks.add(new Rock(BitmapFactory.decodeResource<br/>                    (getResources(), R.drawable.rock), <br/>                    WIDTH+10, HEIGHT/2, 66, 82, <br/>                    playerCharacter.getScore(),3));</strong><br/><strong>                } else {</strong><br/><strong>                    rocks.add(new Rock(BitmapFactory.decodeResource<br/>                    (getResources(), R.drawable.rock), <br/>                    WIDTH+10, (int) <br/>                    (rnd.nextDouble() * (HEIGHT)), 66, 82, <br/>                    playerCharacter.getScore(),3));</strong><br/><strong>                }</strong><br/><strong>                rockStartTime = System.nanoTime();</strong><br/><strong>            }</strong><br/><br/><strong>            for(int i=0; i&lt;rocks.size();i++) {</strong><br/><strong>                rocks.get(i).update();</strong><br/><strong>                if(collision(rocks.get(i),playerCharacter)) {</strong><br/><strong>                    rocks.remove(i);</strong><br/><strong>                    playerCharacter.setPlaying(false);</strong><br/><strong>                    break;</strong><br/><strong>                }</strong><br/><strong>                //remove rocks if they go out of the screen<br/>                if(rocks.get(i).getXC()&lt;-100) {</strong><br/><strong>                    rocks.remove(i);</strong><br/><strong>                    break;</strong><br/><strong>                }</strong><br/><br/><strong>            }</strong><br/>        }<br/>    }
</pre>
<p>We then move on to write our collision detection function. We do this based on the concept of the Bounding Box Collision technique that you learned about earlier in this chapter. You can easily observe from this code, <kbd>Rect.intersects(a.getRectangle(), b.getRectangle())</kbd>, that we are simply comparing the rectangles of both of our objects using the <kbd>Rect</kbd> class that is predefined in our <kbd>android.graphics.Rect</kbd> import. If there is an overlapping rectangle, then this function returns a <kbd>true</kbd> value; otherwise, it returns <kbd>false</kbd>. This function is of the return type <kbd>boolean</kbd> so it is important for it to <kbd>return</kbd> a <kbd>boolean</kbd> value:</p>
<pre>
 <strong>public boolean collision(GameObj a, GameObj b) {</strong><br/><br/><strong>        if(Rect.intersects(a.getRectangle(), b.getRectangle())) {</strong><br/><strong>            return true;</strong><br/><strong>        }</strong><br/><strong>        return false;</strong><br/><strong> }</strong>
</pre>
<p>And then finally, we draw our rock object on the screen. We do this again with a <kbd>for</kbd> loop and using our <kbd>draw()</kbd> method:</p>
<pre>
    @Override<br/><span>    public void </span>draw(Canvas canvas)<br/>    {<br/><span>        final float </span>scaleFactorX = getWidth()/WIDTH;<br/><span>        final float </span>scaleFactorY = getHeight()/HEIGHT;<br/><span>        if</span>(canvas!=<span>null</span>) {<br/><span>            final int </span>savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/>            bgImg.draw(canvas);<br/>            playerCharacter.draw(canvas);<br/><strong><br/>            for(Rock r : rocks) {</strong><br/><strong>                r.draw(canvas);</strong><br/><strong>            }</strong><br/><br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }
</pre>
<p>This will get our game equipped with our collision detection technique. After writing this code, it must be quite obvious how our collision technique is going to work in our game. We created a function with return type Boolean, which will detect collisions between the rectangles of our two objects, which we pass into it as references.      </p>
<p>Let's quickly review our code blocks one by one by listing down exactly what each code block is responsible for in our <kbd>GameView.java</kbd> file to get a better clarity.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Defining our variables</h1>
            </header>

            <article>
                
<p>We define our variables required by adding our desired variables, such as <kbd>rockStartTime</kbd>, <kbd>rocks</kbd>, and <kbd>rnd</kbd>:</p>
<pre>
<span>public static final int </span><span>WIDTH </span>= <span>1920</span>;<br/><span>public static final int </span><span>HEIGHT </span>= <span>1080</span>;<br/><span>public static final int </span><span>MOVINGSPEED </span>= -<span>5</span>;<br/><span>private long </span><span>rockStartTime</span>;<br/><span>private </span>MainGameThread <span>mainThread</span>;<br/><span>private </span>BackgroundImage <span>bgImg</span>;<br/><span>private </span>PlayerCharacter <span>playerCharacter</span>;<br/><span>private </span>ArrayList&lt;Rock&gt; <span>rocks</span>;<br/><br/><span>private </span>Random <span>rnd </span>= <span>new </span>Random();
</pre>
<p>These variables give us references of objects to work with.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Tackling the infinite loop situation</h1>
            </header>

            <article>
                
<p>In our preceding code, there was a chance of running into an infinite loop and so we replace our retry and add in a counter for extra safety in case an infinite loop situation arises in our <kbd>surfaceDestroyed()</kbd> method. It is possible that our retry might return a <kbd>false</kbd> value or a <kbd>true</kbd> value during every run, and so there's a chance of an infinite loop situation. To avoid this, we have this counter which increments every time the while loop is running and stops after that. You can go ahead and experiment to see what problems occur if you avoid using the counter for yourself:</p>
<pre>
<span>@Override<br/></span><span>public void </span>surfaceDestroyed(SurfaceHolder holder){<br/><span>    boolean </span>retry = <span>true</span>;<br/><span>    int </span>counter = <span>0</span>;<br/><span>    while</span>(retry &amp;&amp; counter &lt;<span>1000</span>)<br/>    {<br/>        counter++;<br/><span>        try</span>{<span>mainThread</span>.setRunning(<span>false</span>);<br/><span>            mainThread</span>.join();<br/>            retry = <span>false</span>;<br/>        }<span>catch</span>(InterruptedException e){e.printStackTrace();}<br/>    }<br/><br/>}
</pre>
<p>This tackles our infinite loop situation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing our variables</h1>
            </header>

            <article>
                
<p>After defining our variables, it is also essential to initialize them. We do so from our <kbd>surfaceCreated()</kbd> method as follows:</p>
<pre>
<span>@Override<br/></span><span>public void </span>surfaceCreated(SurfaceHolder holder){<br/><span><br/>    bgImg </span>= <span>new </span>BackgroundImage(BitmapFactory.<span>decodeResource<br/></span>    (getResources(), R.drawable.<span>background_image</span>));<br/><span>    playerCharacter </span>= <span>new </span>PlayerCharacter(BitmapFactory.<span>decodeResource<br/></span>    (getResources(),R.drawable.<span>player_run</span>),<span>200</span>,<span>246</span>,<span>3</span>);<br/><span>    rocks </span>= <span>new </span>ArrayList&lt;Rock&gt;();<br/><span><br/>    rockStartTime </span>= System.<span>nanoTime</span>();<br/><span><br/>    //we can safely start the game loop<br/></span><span>    </span><span>mainThread</span>.setRunning(<span>true</span>); <br/><span>    mainThread</span>.start();<br/><br/>}
</pre>
<p>And that takes care of our variable values.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Collision behavior</h1>
            </header>

            <article>
                
<p>After this, we define what exactly will happen if there is a collision between two objects, which is defined in our <kbd>update()</kbd> method. We also address the situation if the rocks go out of the screen:</p>
<pre>
<span>long </span>rockElapsed = (System.<span>nanoTime</span>() - <span>rockStartTime</span>/<span>1000000</span>);<br/><br/><span>if</span>(rockElapsed&gt;(<span>2000 </span>- <span>playerCharacter</span>.getScore())){<br/><span><br/>    if</span>(<span>rocks</span>.size() == <span>0</span>){<br/><span>        rocks</span>.add(<span>new </span>Rock(BitmapFactory.<span>decodeResource<br/></span>        (getResources(), R.drawable.<span>rock</span>), <br/><span>        WIDTH</span>+<span>10</span>, <span>HEIGHT</span>/<span>2</span>, <span>66</span>, <span>82</span>, <br/><span>        playerCharacter</span>.getScore(),<span>3</span>));<br/>    } <span>else </span>{<br/><span>        rocks</span>.add(<span>new </span>Rock(BitmapFactory.<span>decodeResource<br/></span>        (getResources(), R.drawable.<span>rock</span>), <br/><span>        WIDTH</span>+<span>10</span>, (<span>int</span>) (<span>rnd</span>.nextDouble() * (<span>HEIGHT</span>)), <span>66</span>, <span>82</span>,           <br/><span>        playerCharacter</span>.getScore(),<span>3</span>));<br/>    }<br/><span><br/>    rockStartTime </span>= System.<span>nanoTime</span>();<br/>}<br/><br/><span>for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>rocks</span>.size();i++) {<br/><span><br/>    rocks</span>.get(i).update();<br/><span><br/>    if</span>(collision(<span>rocks</span>.get(i),<span>playerCharacter</span>)) {<br/><span>        rocks</span>.remove(i);<br/><span>        playerCharacter</span>.setPlaying(<span>false</span>);<br/><span>        break</span>;<br/>    }<br/><br/><span>//remove rocks if they go out of the screen<br/></span><span>    </span><span>if</span>(<span>rocks</span>.get(i).getXC()&lt;-<span>100</span>) {<br/><span>        rocks</span>.remove(i);<br/><span>        break</span>;<br/>    }<br/>}
</pre>
<p>Our collision behavior is now ready.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Collision function</h1>
            </header>

            <article>
                
<p>We defined our collision behavior, but it is also necessary that we write a logic that defines our collision itself. So, we make a collision detection function:</p>
<pre>
<span>public boolean </span>collision(GameObj a, GameObj b) {<br/><span><br/>    if</span>(Rect.<span>intersects</span>(a.getRectangle(), b.getRectangle())) {<br/><span>        return true</span>;<br/>    }<br/><span>    return false</span>;<br/>}
</pre>
<p>Our collision function is now ready.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Drawing our objects on the screen</h1>
            </header>

            <article>
                
<p>Once we are done, we simply draw our object on the screen in our if a block of our<kbd>draw()</kbd> method:</p>
<pre>
<span>for</span>(Rock r : <span>rocks</span>) {<br/>    r.draw(canvas);<br/>}
</pre>
<p>And that takes care of all the functionality needed to detect a collision.</p>
<p>Now that we are done with our collision logic, let's make a few tweaks to our player character. We have some unused variables there so let's get rid of them and customize it a little further. Prior to this, they were needed to get an understanding how things work. But now they are pretty useless to us, so there's no need for them to be lying around. Open up your <kbd>PlayerCharacter.java</kbd> and make the following changes to your code:</p>
<pre>
<span>package </span>nikhil.nikmlnkr.game;<br/><br/><span>import </span>android.graphics.Bitmap;<br/><span>import </span>android.graphics.Canvas;<br/><br/><span>/**<br/></span><span> * Created by Nikhil on 13-01-2017.<br/></span><span> */<br/></span><span><br/></span><span>public class </span>PlayerCharacter <span>extends </span>GameObj{<br/><span>    private </span>Bitmap <span>spriteSheet</span>;<br/><span>    private int </span><span>score</span>;<br/><span>    private boolean </span><span>up</span>, <span>playing</span>;<br/><span>    private </span>AnimationClass <span>ac </span>= <span>new </span>AnimationClass();<br/><span>    private long </span><span>startTime</span>;<br/><span><br/>    public </span>PlayerCharacter(Bitmap res, <span>int </span>w, <span>int </span>h, <span>int </span>noOfFrames) {<br/><span>        xc </span>= <span>100</span>;<br/><span>        yc </span>= GameView.<span>HEIGHT</span>/<span>2</span>;<br/><strong>        //removing the dya variable<br/></strong><span>        dyc </span>= <span>0</span>;<br/><span>        score </span>= <span>0</span>;<br/><span>        height </span>= h;<br/><span>        width </span>= w;<br/><br/>        Bitmap[] img = <span>new </span>Bitmap[noOfFrames];<br/><span>        spriteSheet </span>= res;<br/><span><br/>        for</span>(<span>int </span>i=<span>0</span>; i&lt;img.<span>length</span>;i++){<br/>            img[i] = Bitmap.<span>createBitmap</span>(<span>spriteSheet</span>, i*<span>width</span>, <span>0</span>, <br/><span>            width</span>, <span>height</span>);<br/>        }<br/><span>        ac</span>.setFrames(img);<br/><span>        ac</span>.setDelay(<span>10</span>);<br/><span>        startTime </span>= System.<span>nanoTime</span>();<br/>    }<br/><span><br/>    public void </span>setUp(<span>boolean </span>b){<br/><span>        up </span>= b;<br/>    }<br/><span><br/>    public void </span>update() {<br/><span>        long </span>elapsed = (System.<span>nanoTime</span>()-<span>startTime</span>)/<span>1000000</span>;<br/><span>        if</span>(elapsed &gt; <span>100</span>) {<br/><span>            score</span>++;<br/><span>            startTime </span>= System.<span>nanoTime</span>();<br/>        }<br/><span>        ac</span>.update();<br/><span><br/>        if</span>(<span>up</span>){<br/><strong>            dyc -=1;</strong><br/>        }<br/><span>        else </span>{<br/><strong>            dyc +=1;</strong><br/>        }<br/><br/><span>        if</span>(<span>dyc </span>&gt; <span>10</span>) {<br/><span>            dyc </span>= <span>10</span>;<br/>        }<br/><span>        if</span>(<span>dyc </span>&lt; -<span>10</span>) {<br/><span>            dyc </span>= -<span>10</span>;<br/>        }<br/><span><br/>        yc </span>+= <span>dyc</span>*<span>2</span>;<br/><span><strong>        //removing the dya variable</strong><br/></span><span>    </span>}<br/><span><br/>    public void </span>draw(Canvas canvas) {<br/>        canvas.drawBitmap(<span>ac</span>.getImage(), <span>xc</span>, <span>yc</span>, <span>null</span>);<br/>    }<br/><span><br/>    public int </span>getScore() {<br/><span>        return </span><span>score</span>;<br/>    }<br/><span><br/>    public boolean </span>getPlaying(){<br/><span>        return </span><span>playing</span>;<br/>    }<br/><span><br/>    public void </span>setPlaying(<span>boolean </span>b) {<br/><span>        playing </span>= b;<br/>    }<br/><span><br/>    public void </span>resetDYC() {<br/><span>        dyc </span>= <span>0</span>;<br/>    }<br/><span><br/>    public void </span>resetScore () {<br/><span>        score </span>= <span>0</span>;<br/>    }<br/>}
</pre>
<p>These are just minor tweaks which are quite self-explanatory and don't require any separate explanation as such. Now that we have established all of this, we can finally test our collision technique! So, let's go ahead and do that. Build your game and test it on your device or emulator. You will see something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="386" src="assets/B05066_06_03-1.png" width="686"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Hurray! Our rocks are on screen.... But wait, what?</div>
<p>So, the good news is that our rocks finally appear on the screen and the bad news is that they are all over the screen. We will address this situation shortly, but for now, we can get to test our collision functionality. As soon as our rocks collide with our player character the game will pause. We will now need to fix their frequency in order to control their spawning.</p>
<p>Open up your <kbd>GameView.java</kbd> file and make the changes marked in bold. Remove all commented code marked in bold and add the <kbd>if(rocks.size() &lt; 2)</kbd> statement as follows:</p>
<pre>
<span>public class </span>GameView <span>extends </span>SurfaceView <span>implements </span>SurfaceHolder.Callback<br/>{<br/><span>    public static final int </span><span>WIDTH </span>= <span>1920</span>;<br/><span>    public static final int </span><span>HEIGHT </span>= <span>1080</span>;<br/><span>    public static final int </span><span>MOVINGSPEED </span>= -<span>5</span>;<br/><strong>    //private long rockStartTime;<br/></strong><span>    private </span>MainGameThread <span>mainThread</span>;<br/><span>    private </span>BackgroundImage <span>bgImg</span>;<br/><span>    private </span>PlayerCharacter <span>playerCharacter</span>;<br/><span>    private </span>ArrayList&lt;Rock&gt; <span>rocks</span>;<br/><span><br/>    private </span>Random <span>rnd </span>= <span>new </span>Random();<br/><br/>    //Constructor, surfaceDestroyed and surfceChanged methods remain <br/>    same<br/><span>    @Override<br/></span><span>    </span><span>public void </span>surfaceCreated(SurfaceHolder holder){<br/><span><br/>        bgImg </span>= <span>new </span>BackgroundImage(BitmapFactory.<span>decodeResource<br/></span>        (getResources(), R.drawable.<span>background_image</span>));<br/><span>        playerCharacter </span>= <span>new <br/></span>        PlayerCharacter(BitmapFactory.<span>decodeResource<br/></span>        (getResources(),R.drawable.<span>player_run</span>),<span>200</span>,<span>246</span>,<span>3</span>);<br/><span>        rocks </span>= <span>new </span>ArrayList&lt;Rock&gt;();<br/><span><strong><br/>        //rockStartTime = System.nanoTime();</strong><br/></span><span><br/></span><span>        //we can safely start the game loop<br/></span><span>        </span><span>mainThread</span>.setRunning(<span>true</span>);<br/><span>        mainThread</span>.start();<br/><br/>    }<br/>    //onTouchEvent remains same<br/><span><br/>    public void </span>update()<br/>    {<br/><span>        if</span>(<span>playerCharacter</span>.getPlaying()) {<br/><span>            bgImg</span>.update();<br/><span>            playerCharacter</span>.update();<br/><span><br/>            //spawn rocks on screen<br/></span><span><strong>            //long rockElapsed = (System.nanoTime() - <br/>            rockStartTime/1000000);</strong><br/></span><span><strong>            //if(rockElapsed&gt;(2000 - playerCharacter.getScore())){</strong><br/></span><span>             </span><strong>if(rocks.size() &lt; 2){</strong><br/><span>                 if</span>(<span>rocks</span>.size() == <span>0</span>){<br/><span>                    rocks</span>.add(<span>new </span>Rock(BitmapFactory.<span>decodeResource<br/></span>                    (getResources(), R.drawable.<span>rock</span>),<br/><span>                    WIDTH</span>+<span>10</span>, <span>HEIGHT</span>/<span>2</span>, <span>120</span>, <span>82</span>, <br/><span>                    playerCharacter</span>.getScore(),<span>3</span>));<br/>                } <span>else </span>{<br/><span>                    rocks</span>.add(<span>new </span>Rock(BitmapFactory.<span>decodeResource<br/></span>                    (getResources(), R.drawable.<span>rock</span>), <br/><span>                    WIDTH</span>+<span>10</span>, (<span>int</span>) (<span>rnd</span>.nextDouble() * (<span>HEIGHT</span>)),<br/><span>                    120</span>, <span>82</span>, <span>playerCharacter</span>.getScore(),<span>3</span>));<br/>                }<br/><span>                rockStartTime </span>= System.<span>nanoTime</span>();<br/><strong>            } //Bracket ends here</strong><br/><span><br/>            for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>rocks</span>.size();i++) {<br/><span>                rocks</span>.get(i).update();<br/><span>                if</span>(collision(<span>rocks</span>.get(i),<span>playerCharacter</span>)) {<br/><span>                    rocks</span>.remove(i);<br/><span>                    playerCharacter</span>.setPlaying(<span>false</span>);<br/><span>                    break</span>;<br/>                }<br/><span>                //remove rocks if they go out of the screen<br/></span><span>                </span><span>if</span>(<span>rocks</span>.get(i).getXC()&lt;-<span>100</span>) {<br/><span>                    rocks</span>.remove(i);<br/><span>                    break</span>;<br/>                }<br/><br/>            }<br/>        }<br/>    }<br/><span><br/>    public boolean </span>collision(GameObj a, GameObj b) {<br/><span><br/>        if</span>(Rect.<span>intersects</span>(a.getRectangle(), b.getRectangle())) {<br/><span>            return true</span>;<br/>        }<br/><span>        return false</span>;<br/>    }<br/><span><br/>    @Override<br/></span><span>    </span><span>public void </span>draw(Canvas canvas)<br/>    {<br/><span>        //same as the draw method seen earlier</span><br/>    }<br/><br/>}
</pre>
<p>We simply commented out our <kbd>rockElapsed</kbd> and <kbd>rockStartTime</kbd> variables and instead replaced our <kbd>if</kbd> condition with the <kbd>rocks.size()</kbd> condition, which tells our game to spawn only <kbd>2</kbd> rocks on the screen at any given time. This way, we get a control on the frequency of rocks spawned on the screen. You can tweak your frequency as you desire:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="image-border" height="384" src="assets/B05066_06_04-1.png" width="683"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Okay, this looks better than the previous one</div>
<p>Of course, there is still the question of the appearance of the rock; this depends on the image that you use to create the sprite animation. But for now, we will move ahead with the further part. Also, note that in a similar way, you can also create collectible items such as coins so it is recommended for you create a coins class, which the player can collect and add to his score. Go ahead, experiment!</p>
<p>Now let's learn about our next concept, that is artificial intelligence. Since we are not going to use any artificial intelligence in our game, we will just go through the concept of this topic. Our current game is a simple side scroller, which does not require any enemies as such. So, let's get started with artificial intelligence, or as many call it, AI And of course, if you come up with an idea to add enemies in the game then you can always use the concepts you learned from the previous chapters and couple them with the concept you are about to learn to come up with something cool!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Artificial Intelligence</h1>
            </header>

            <article>
                
<p><strong>Artificial Intelligence</strong> (<strong>A.I.</strong>) is the study of systems being able to perform human tasks and automation without the requirement of human involvement. In games, this concept is widely used in order to create a real behavior for game enemies. Let's understand the basic concept of A.I. in this chapter. This part of the chapter is going to be theory only so feel free to skip this part if you just want to focus on getting your game ready. However, it is highly recommended to go through this part because if you want to create A.I. in your game then the concepts from this part will come in handy.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">History of Artificial Intelligence</h1>
            </header>

            <article>
                
<p>In games, A.I. is used to create intelligent behaviors to objects that the user cannot control. This can be anything ranging from a dragon you see on the screen or simply a character that keeps following you. To put it simply, it is something that provides the means for a seemingly inanimate object to possess human-like intelligence. On a technical level, A.I. is the study of coming up with algorithms which include techniques from robotics, computer graphics, computer science, and control theory. There are many algorithms for creating a life-like A.I.</p>
<p>The study of A.I. in games has been a part of this industry ever since its inceptions, as games provide one of the best ways to simulate artificial behavior in lifeless objects. However, if you take a look back at the 1950s era, you will observe that A.I. was relatively a simpler concept than what it has evolved into in today's times. The game of Nim made in 1951 was the first examples of A.I.:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B05066_06_05.jpg"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Game of Nim in 1951</div>
<p>This game was a simple Tic Tac Toe game, which demonstrated the very first example of A.I. while playing against the computer. The first notable ones for the arcade appeared in 1974: the Taito game, Speed Race (a racing video game), and the Atari games, Qwak (a duck hunting light gun shooter) and Pursuit (a fighter aircraft dogfighting simulator). Two text-based computer games from 1972, Hunt the Wumpus and Star Trek, also had enemies. Enemy movement was based on stored patterns. The incorporation of microprocessors would allow more computation and random elements overlaid into movement patterns. Let's talk about some interesting A.I. algorithms.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Artificial Intelligence Algorithms</h1>
            </header>

            <article>
                
<p>Algorithms for A.I. can include many aspects. Essentially, to break these down into simple terms, they are just search algorithms. Following are some of the most popular search algorithms, which can be implemented into A.I. logic. In between, there are pseudo codes for understanding these examples. Once you go through these, we can come up with some basic A.I. logic for our game if you wish to include it from your side.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Breadth-First Search</h1>
            </header>

            <article>
                
<p>This algorithm starts from the root node and then, after exploring all the neighboring nodes first, it moves toward the next level of neighbors, which returns the shortest path to our solution. It uses the FIFO queue data structure.</p>
<p>The disadvantage of this algorithm is that it consumes a lot of memory because each level of nodes is saved in order to create the next one.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Depth-First Search</h1>
            </header>

            <article>
                
<p>The implementation of this algorithm is done using recursion with the LIFO stack data structure and it creates the same nodes as our first method but in a different order. The space requirement is quite linear since nodes on a single path are stored in each iteration from root-to-leaf node.</p>
<p>The disadvantage of the algorithm is that there's a possibility that this algorithm may not terminate and go on infinitely on one path and in some cases the execution time increases. It can't check for duplicate nodes.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/Depth-first_search">https://en.wikipedia.org/wiki/Depth-first_search</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Bidirectional search</h1>
            </header>

            <article>
                
<p>In this technique, the search is carried forward from the initial state and backward from the goal state until both are met to identify the common state and then the path from the initial state is concatenated with an inverse path from the goal state.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/Bidirectional_search">https://en.wikipedia.org/wiki/Bidirectional_search</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Uniform cost search</h1>
            </header>

            <article>
                
<p>In this algorithm, the sorting is done by increasing the cost of the path to a node and the node with the least cost is expanded. It is also popularly known as Dijkstra's algorithm.</p>
<p>The disadvantage of this algorithm is that, since there can be multiple long paths, this technique must explore them all.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Iterative deepening Depth-First Search</h1>
            </header>

            <article>
                
<p>A depth-first search to level 1 is performed and then the same is done on level 2 and so on, until the solution is found. Until all the lower nodes are generated, a node is not created.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search">https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Comparison of preceding algorithms complexities</h1>
            </header>

            <article>
                
<p>Let's take a look at some of the interesting results by comparing our first five algorithms. Here's the performance of the algorithms based on various criteria:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Criteria</strong></p>
</td>
<td>
<p><strong>Breadth First</strong></p>
</td>
<td>
<p><strong>Depth </strong><strong>First</strong></p>
</td>
<td>
<p><strong>Bidirectional</strong></p>
</td>
<td>
<p><strong>Uniform Cost</strong></p>
</td>
<td>
<p><strong>Deepening</strong></p>
</td>
</tr>
<tr>
<td>
<p>Time</p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
<td>
<p>b<sup>m</sup></p>
</td>
<td>
<p>b<sup>d/2</sup></p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
</tr>
<tr>
<td>
<p>Space</p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
<td>
<p>b<sup>m</sup></p>
</td>
<td>
<p>b<sup>d/2</sup></p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
<td>
<p>b<sup>d</sup></p>
</td>
</tr>
<tr>
<td>
<p>Optimality</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<p>Completeness</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A * search</h1>
            </header>

            <article>
                
<p>This algorithm is the best known as the Best First search algorithm and is also widely used in games for pathfinding. Its performance is very efficient and expanding paths that are already expensive are avoided through this algorithm.</p>
<p><kbd>f(n) = g(n) + h(n)</kbd>, where <kbd>g(n)</kbd> the cost (so far) to reach the destination node, <kbd>h(n)</kbd> is the estimated cost to get from the node to the goal, and <kbd>f(n)</kbd> is the estimated total cost of the path through <kbd>n</kbd> to the goal. It is implemented using a priority queue by increasing <kbd>f(n)</kbd>.</p>
<p>Read more at: <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">https://en.wikipedia.org/wiki/A*_search_algorithm</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating your own Artificial Intelligence</h1>
            </header>

            <article>
                
<p>Now, as for this game, we don't really require any A.I. since most of our obstacles themselves are a big challenge for us. However, we can have some food for thought. Here's an exercise for you. Using your knowledge gained in previous chapters, try to create an A.I. class for an enemy spawning, which will start shooting projectiles at you if it enters a certain radius. Here are your objectives for creating an A.I.:</p>
<ul>
<li>Spawn enemies from right side of the screen</li>
<li>Make them move in the left-hand direction</li>
<li>Upon entering a certain radius, they will start shooting projectiles at you</li>
<li>If you collide with the projectile, the game pauses</li>
</ul>
<div class="packt_tip">You can use your Rock.java class as a shooting projectile. You can have a monkey coming in from the side of the screen which starts throwing rocks at you if it enters a certain radius. Try this out by yourself; it'll be fun to see what you come up with!</div>
<p>So, that's about it for our collision and A.I. part of this book.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, you learned a great deal about the various collision techniques as well as multiple artificial intelligence algorithms. We now know how to create collisions based on the Bounding Box Collision technique.</p>
<p>In the next chapter, we will add a ground for our player and understand how we can create explosions based on our collisions.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>