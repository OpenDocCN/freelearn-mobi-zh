- en: '*Chapter 6*: Understanding the Swift Type System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have left you with a solid foundation that you can use
    to build great, adaptive apps on. At this point, it is a good idea to take a step
    back and look at the code you have written to gain a deeper understanding of Swift
    and how it works. This section focuses on teaching you more about Swift as a language,
    regardless of what you intend to build.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about Swift's fantastic type system. Swift's
    type system is one of its most powerful features because it allows developers
    to express complex and flexible principles safely and predictably.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding available types in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding differences in types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding which type to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for `Xcode` in the App Store and select and download the latest
    version. Launch Xcode and follow any additional installation instructions that
    your system may prompt you with. Once Xcode has fully launched, you're ready to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding available types in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write great code, you need to learn what tools are available in your toolbox.
    This applies to building apps and understanding the features UIKit has to offer,
    but it also applies to the language you use to write software in. Different languages
    come with various features, best practices, pros, and cons. The deeper your understanding
    of the language you work with is, the better the decisions you can make about
    the code you write. As mentioned before, Swift's type system is one of the features
    that make Swift such an excellent language for both experts and beginners to develop
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you dive into the details of Swift''s types and how they compare to
    each other, it''s essential that you know what types Swift has to offer. On a
    high level, you can argue that Swift has two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a closer look at each type to see what they mean, how they work,
    and how you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The types you have seen so far in this book were mostly, if not all, reference
    types. Two types of objects are classified as reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have seen both of these object types in this book already. For instance,
    all the `UIViewController` subclasses you have created are reference types. All
    the closures that you used as callbacks or to perform animations are also reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does it mean if something is a reference type, and why should it matter
    to you? Well, reference types come with behavior that can be both convenient and
    very frustrating depending on what you are trying to achieve in your code.
  prefs: []
  type: TYPE_NORMAL
- en: One feature that is unique to reference types and classes is the ability to
    subclass. The only type that can inherit functionality from another object is
    a class. This will be covered in more depth when you learn about the differences
    between types, but it's good to be aware of this information already. Let's examine
    reference types up close by writing some code in a playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new playground project in Xcode and give it any name you like. Then,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Likely, you're not too excited about this little snippet of code. All it does
    is define a new `Pet` class, make an instance of it, and then pass that instance
    into `printName(for:)`. However, this code is extremely well-suited to illustrating
    what a reference type is.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call `printName(for: cat)`, you pass a *reference* to your `cat` instance
    to `printName(for:)`. This means that it is possible for anybody who gets ahold
    of this reference to make changes to the object that is referenced. If this sounds
    confusing, that''s okay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the playground you have created, and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What do you notice in the console after running this?
  prefs: []
  type: TYPE_NORMAL
- en: If you noticed that the dog's name changes from `Astro` to `Pugwash`, you have
    just observed what it means to pass a reference to something around.
  prefs: []
  type: TYPE_NORMAL
- en: Since `printName2(for:)` received a reference to your `Pet` instance, it was
    able to change its name. If you have programmed in other languages, this might
    be obvious to you. If not, this might be very surprising.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing you should note is that `dog` was declared as a constant. Regardless,
    you were able to change the name of your instance from `Astro` to `Pugwash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think this is obvious, add the following code to your playground and
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very similar to what you did with the `Pet` instance. You make
    a constant instance of a thing, and then you change one of its properties. This
    time, however, when you try to run your playground, you should see the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the code you implemented so far is pretty short, it does a great
    job of demonstrating reference types. You have currently seen two properties of
    a reference type in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Anybody that receives an instance of a reference type can mutate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change properties on a reference type, even if the property that holds
    onto the reference type is declared as a constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two characteristics are typical of reference types. The reason reference
    types work like this is that a variable or constant that is assigned a reference
    type *does not contain or own* the object. The constant or variable only points
    to an address in memory where the instance is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you create an instance of a reference type, it is written to RAM, where
    it will exist at a particular address. RAM is a special type of memory that is
    used by computers, such as an iPhone, to temporarily store data that is used by
    a certain program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign an instance of a reference type to a property, the property
    will have a **pointer** to the memory address for this instance. Let''s have another
    look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `dog` constant now points to a particular address in memory where the `Pet`
    instance is stored. You are allowed to change properties on the `Pet` instance
    as long as the underlying memory address isn't changed.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you could theoretically put something entirely different at that memory
    address, and `let dog` won't care because it still points to the same address.
  prefs: []
  type: TYPE_NORMAL
- en: For this same reason, it is possible for `printName2(for:)` to change a pet's
    name. Instead of passing it an instance of `Pet`, you pass it the memory address
    at which the instance is expected to exist. It's okay for `printName2(for:)` to
    make changes to the `Pet` instance because it doesn't change the underlying address
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tried to assign a new instance to `dog` by typing the following, you
    would get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason this would cause an error is that you can't change the memory address
    `dog` points to since it's a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what a reference type is and how it works, you might have
    already concluded that `CGPoint` that you saw in the preceding example must be
    a value type. Next, let's see what value types are all about.
  prefs: []
  type: TYPE_NORMAL
- en: Working with value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples for references types, you saw the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At first sight, you might expect a value type to be a special kind of class
    because it looks like this snippet creates an instance of a class called `CGPoint`.
    You would be right in your observation, but your conclusion is wrong. `CGPoint`
    is not a class at all.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are inherently reference types, and they can't ever be something else.
    So, what are value types, then?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of objects that are considered to be value types:'
  prefs: []
  type: TYPE_NORMAL
- en: Stucts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types are both very different, so let's make sure that you understand
    the basics of value types first, and then you'll learn what each of these two
    types is.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the `Pet` example again, but use a struct instead of a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new playground page in Xcode, again naming this anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will immediately notice that Xcode complains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error you should see in the console tells you that `pet` is a `let` constant
    and you are not allowed to change its name. You can turn `pet` into a variable
    by updating `printName`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run your playground now, make sure to look at the console closely. You'll
    notice that the pet's name remains unchanged in the second print.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates one of the key features of a value type. Instead of passing
    a reference to an address in memory around, a copy of the object is passed around.
    This explains why you aren't allowed to change properties on a value type that
    is assigned to a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Changing that property would change the value type's value, and it would, therefore,
    change the value of the constant. This also means that when you pass `dog` to
    `printName`, you pass a copy of the `Pet` instance to `printName`, meaning that
    any changes made to the instance are local to the `printName` function and won't
    be applied to `dog`, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior makes using value types extremely safe because it's tough for
    other objects or functions to make unwanted changes to a value type. Also, if
    you define something as a constant, it truly is a constant. Another characteristic
    of value types is that they're typically very fast and lightweight because they
    can exist on the stack, while reference types exist on the heap. You'll learn
    more about this later when we compare reference types and value types.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of value types, let's have a look at
    the specific value types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Structs are similar to classes in the way you define them. If you look at the
    `Pet` class you defined earlier, it might be easy to miss the fact that it''s
    a struct. If you pay close attention, you will notice one big difference, though:
    you didn''t have to write an initializer for the struct! Swift can automatically
    generate initializers for structs. This is extremely convenient and can save you
    a lot of typing for larger structs.'
  prefs: []
  type: TYPE_NORMAL
- en: Structs also can't inherit functionality from other objects. This means that
    structs always have a very flat and transparent set of properties and methods.
    This allows the compiler to make optimizations to your code that make structs
    extremely lightweight and fast.
  prefs: []
  type: TYPE_NORMAL
- en: A struct can, however, conform to protocols. The Swift standard library is full
    of protocols that define features for many of the built-in types, such as `Array`,
    `Dictionary`, and `Collection`. Most of these built-in types are implemented as
    structs that adopt one or more protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing you need to understand about structs is that they are very strict
    about whether they can be modified. Consider a struct that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This struct will cause the compiler to throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A struct itself is immutable by default, which means you cannot change any
    of its values. It''s up to you to make it explicit to the compiler when a method
    can mutate or change a struct. You do this by adding the `mutating` keyword to
    a function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you create a constant instance of `Car` and call `fillFuelTank()` on it,
    the compiler will error again. If you call a mutating function on a `let` instance,
    you mutate the instance, meaning the value of the property would change. Because
    of this, you can only call mutating functions on variable properties.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An enum is a type that holds a finite set of predefined values. Enums are often
    used to represent a particular state or result of an operation. The best way to
    learn what this means is to look at an example of an enum that represents the
    state of a traffic light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This sample shows a `TrafficLight` struct that has a `state` property. The type
    of this property is `TrafficLightState`, which is an enum.
  prefs: []
  type: TYPE_NORMAL
- en: '`TrafficLightState` defines three possible states for a traffic light. This
    is very convenient because an enum such as this eliminates the possibility of
    a bad state because the compiler can now enforce that you never end up with an
    invalid value.'
  prefs: []
  type: TYPE_NORMAL
- en: Enums can also contain properties and methods, just like structs can. However,
    an enum can also have an *associated value*. This means that each possible case
    can have a representation in a different type, such as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you modify `TrafficLightState`, as shown here, it will have `String` for
    `rawValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If Swift can infer the raw value, you don't have to do anything more than add
    the type of the raw value to the enum's type declaration. In this sample, the
    raw value for the `green` enum case will be the `green` string. This can be convenient
    if you need to map your enum to a different type – for instance, to set it as
    a label's text.
  prefs: []
  type: TYPE_NORMAL
- en: Just like structs, enums cannot inherit functionality from other objects, but
    they can conform to protocols. You make an enum conform to a protocol with an
    extension, just like you would do for classes and structs.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up the exploration of value types. Now that you know what value types
    and reference types are, let's explore some of their differences!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding differences in types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being aware of the available types in Swift – knowing their similarities and,
    more importantly, their differences – will help you make better decisions about
    the way you write your code. The preceding segments have listed several properties
    of value types and reference types. More specifically, you learned a lot about
    classes, structs, and enums. Closures are also a reference type because they get
    passed around by their location in memory, rather than their value, but there
    isn't much else to say about them in this context.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious comparison you can make is probably between structs and classes.
    They look very similar, but they have very different characteristics, as you have
    already seen. Enums are a special type altogether; they represent a value from
    a fixed number of possible values but are very similar to structs otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference you need to understand is the general difference
    between value types and reference types, and the difference between structs and
    classes specifically. Let's have a look at value types and reference types first,
    so you have the general picture. Then, you'll learn about the specific differences
    between structs and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing value types to reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When comparing value types to reference types, it is essential to distinguish
    between the differences you can see as a developer and the differences that are
    internal to Swift and the way your app will end up working. Knowing these details
    will ensure that you can make a well-informed decision that considers all the
    implications instead of only focusing on memory usage or developer convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the more obvious and visible differences first. Afterward, you
    will learn about the memory implications for each type.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new playground, once again naming it anything you like, and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a `PetProtocol` that requires two properties to exist on all
    objects that conform to this protocol. The `name` property is defined as a constant
    since it only needs it to be gettable, and `ownerName` is a variable since it
    requires both `get` and `set`. The code also defines an `Animal` and `Pet` class.
    `Pet` is a subclass of `Animal`, and it conforms to `PetProtocol` because `Animal`
    satisfies the `name` constant requirement and `Pet` itself satisfies the `ownerName`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the `class` declarations to `struct`. Your playground will not
    compile now because structs cannot inherit from other objects as classes can.
    This is a limitation that is sometimes frustrating because you can end up with
    a lot of code duplication. Imagine that, in addition to `Pet`, you would like
    to create more types of animals, such as a `WildAnimal` or `SeaCreature`. This
    would be easy to achieve with classes because you can inherit from `Animal`. This
    is not possible with structs, so you would implement all these types as structs
    they would need to duplicate their `Animal` logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference between value types and reference types is how they act
    when they are passed around. Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The declarations for `info` and `location` look very similar, but their underlying
    types are entirely different. Try writing a function that takes both `ImageLocation`
    and `ImageInformation` as an argument. Then, try updating the `isLoaded` property
    of `location` and changing the `name` property of `info`. The compiler will complain
    when you try to set `isLoaded` because the argument for `ImageLocation` is `let
    constant`. The reason for this was described earlier in the discussion on value
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Value types are passed around by value, meaning that changing the property of
    the argument will change the value altogether. Arguments for a function are always
    constants. This might not be obvious when you use a reference type, though, because
    it is perfectly fine to change the `name` property on `ImageInformation` inside
    of a function. This is because you don't pass the entire value around when you
    pass a reference type to a function; you pass the reference to the memory address
    around. This means that instead of the value being a constant, the underlying
    memory address is a constant. This, in turn, means that you can change whatever
    is in memory as much as you like; you just can't change the address that a constant
    points to.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you need to drive to somebody's house and they send you the address
    where they live. This is what it's like to pass around a reference type. Rather
    than sending you their entire house, they send you the address for their house.
    While you are driving to their house, the house can change in many ways. The owner
    could paint it, or replace the windows or doors, anything. In the end, you will
    still find the house because you received the address for this house, and, as
    long as the owner doesn't move to a different address, you will find the correct
    house.
  prefs: []
  type: TYPE_NORMAL
- en: If you change this analogy to use value types, the person whose house you're
    looking for will simply send you a full copy of their house. So, rather than you
    driving toward their house based on the address, they won't give you an address;
    they will just send you their whole house. If the owner makes changes to their
    copy of the house, you won't be able to see them reflected on your copy of the
    house unless they send you a new copy. This is also true for any modifications
    you make to your copy of the house.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that in some cases, it can be very efficient to send somebody
    a copy of something rather than the address. The example of a house might be a
    bit extreme, but I'm pretty sure that if you order a parcel, you would much rather
    receive the parcel itself than receiving an address to fetch the parcel. This
    sort of efficiency is what you will learn about next by comparing how value types
    and reference types behave in terms of memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which type to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing the wrong type of object to use in your application can have bad implications
    for your app on several levels. For instance, your app could suffer from unwanted
    side effects when a reference type is modified in some unexpected place. Or, you
    could end up with a lot of duplicated logic if you use a struct instead of a class
    in certain places. Your app could even suffer in terms of performance when you
    choose a slow reference type where a value type would have been a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: You should always evaluate what type of object is best suited for your current
    use case to make sure your code strikes a balanced trade-off between maintainability
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: When should I use a reference type?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great time to use a reference type is when you are subclassing a built-in
    class, such as `UIViewController`. In these cases, there is no point in fighting
    the system because that would definitely do more harm than good. Another time
    to use a reference type is when you are creating your own delegate protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are best implemented as weak reference types. This means that the
    object that acts as a delegate is referenced weakly by an object to avoid memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Because value types are passed around by making copies, it does not make sense
    to have a weak reference to them. In this case, your only choice is to use a reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: You also need a reference type if it doesn't make sense to pass around copies
    of something. If you think back to the example of driving to somebody's house,
    it makes a lot more sense to pass around the address of a house than to give everybody
    full copies of the house. You might consider the house as having an identity.
  prefs: []
  type: TYPE_NORMAL
- en: This means that each house is *unique*; there is only one house with that exact
    address, and making copies of it makes no sense. If you are working with an object
    where copying it makes no sense, you likely want to implement it as a reference
    type, so everybody that receives an instance of that type is looking at the same
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: One last reason to choose a reference type is if it can save you a lot of typing
    by subclassing. A lot of people consider subclassing bad, and you can often avoid
    it, but sometimes it just makes a lot more sense to work with a class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that a lot of subclasses can lead to muddy classes that contain
    functionality to save typing on a couple of subclasses even though the functionality
    is not relevant to all subclasses. But just like many tools, subclassing can be
    quite convenient when used correctly; it's not inherently bad to use it.
  prefs: []
  type: TYPE_NORMAL
- en: When to use a value type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often said that you should always start with a struct and change to a
    different type when needed. This is great advice for a lot of cases because structs
    are often fine for most cases. However, structs aren't the only value type, and
    it's always good to not default to using certain things blindly.
  prefs: []
  type: TYPE_NORMAL
- en: If you need an object that represents a finite set of possible states or results,
    such as a network connection state, a traffic light state, or a limited set of
    valid configuration options for your app, you will likely need an enum.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the value semantics that make value types great, an enum is a
    great way to avoid typos and represent a state. It's often pretty clear when you
    should use an enum due to its nature.
  prefs: []
  type: TYPE_NORMAL
- en: Structs are used for objects that do not have an identity. In other words, it
    makes sense to pass copies of it around. A good example of this is when you create
    a struct that can communicate with the network or a database. This struct would
    have no identity because it's mostly a collection of properties and methods that
    aren't associated with a single version of the struct.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of a struct is the `CGPoint` struct that you read about at the
    beginning of this section. `CGPoint` represents a location in a two-dimensional
    grid. It has no identity, and passing copies of it around makes sense. It only
    contains two properties, so it doesn't require any inheritance. These features
    make it a great candidate to be implemented as a value type.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the advice of always starting with a struct, try to figure out
    reasons for your new object to *not* be a struct. If you find a good reason to
    not use a struct, then make it a class. Often, you won't be able to find a good
    reason to use a class instead of a struct. If this is the case, make your new
    object a struct; you can always switch to using a class later. It's usually harder
    to switch from a class to a struct due to the stricter rules regarding mutability
    and the lack of subclassing for structs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot about value types and reference types in this chapter. You
    learned what each type is and how you can use them. You learned that you can use
    classes, closures, structs, and enums in Swift and that each of these object types
    has its own pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about all types, you saw how value types and reference types
    compare to each other, which has shed some light on the sometimes subtle and sometimes
    obvious use cases for each type. You learned that structs can't be subclasses,
    while classes can. You also learned that passing around value types passes around
    copies of each instance, and passing around reference types does not copy each
    instance but rather passes around a pointer to the addresses in memory. Then,
    you learned how each type is held in memory and what this means for the performance
    of the objects you create.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you read about how to choose between value types and reference types
    by using several rules of thumb that should make choosing between structs, classes,
    and enums fairly straightforward without blindly picking one. The next chapter
    will take your Swift knowledge one step further by showing you how to write ultra-flexible
    code with Swift's generics.
  prefs: []
  type: TYPE_NORMAL
