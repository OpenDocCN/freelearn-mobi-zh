- en: Chapter 11. Labeling Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 标签属性
- en: In this chapter, we will cover how to label properties via the `property_contexts`
    file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何通过 `property_contexts` 文件来标签化属性。
- en: 'Properties are a unique Android feature we learned about in [Chapter 3](ch03.html
    "Chapter 3. Android Is Weird"), *Android Is Weird*. We want to label these to
    restrict setting of our properties to only the domains that should set them, preventing
    a classic DAC root attack from inadvertently changing the value. In this chapter,
    we will learn to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是我们在第3章[Android Is Weird](ch03.html "第3章 Android Is Weird")中了解到的一个独特的 Android
    功能。我们希望对这些属性进行标签化，以限制我们的属性只由应该设置它们的域设置，防止意外更改值的经典 DAC 根攻击。在本章中，我们将学习如何：
- en: Create new properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新属性
- en: Label new and existing properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签新属性和现有属性
- en: Interpret and deal with property denials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释和处理属性拒绝
- en: Enumerate special Android properties and their behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举特殊的 Android 属性及其行为
- en: Labeling via property_contexts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 property_contexts 标签化
- en: 'All properties are labeled using the `property_contexts` file, and its syntax
    is similar to `file_contexts`. However, instead of working on file paths, it works
    on property names or property keys (properties in Android are a key-value store).
    The property keys themselves are typically delimited with periods (`.`). This
    is analogous to `file_contexts`, except the slash (`/`) becomes a period. Some
    sample properties and their entries in `property_contexts` would look like the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都使用 `property_contexts` 文件进行标签化，其语法类似于 `file_contexts`。然而，它不是在文件路径上工作，而是在属性名称或属性键（Android
    中的属性是键值存储）上工作。属性键通常用点（`.`）分隔。这与 `file_contexts` 类似，但斜杠（`/`）变成了点。一些示例属性及其在 `property_contexts`
    中的条目如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how all `ctl.` properties are labeled with the `ctl_default_prop` type,
    but `ctl.ril-daemon` has a different type label of `ctl_rildaemon_prop`. These
    are representative of how you can start generically and move to more specific
    values/types as necessary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有 `ctl.` 属性都使用 `ctl_default_prop` 类型进行标签化，但 `ctl.ril-daemon` 使用不同的类型标签 `ctl_rildaemon_prop`。这代表了你可以从通用开始，根据需要逐步过渡到更具体的值/类型。
- en: 'Additionally, anything not explicitly labeled defaults to `default_prop` through
    a "match all" expression in `property_contexts`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何未明确标签化的内容默认通过 `property_contexts` 中的“匹配所有”表达式使用 `default_prop`：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Permissions on properties
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性的权限
- en: 'One can view the current properties on the system, and create new ones with
    the command line utilities `getprop` and `setprop`, as shown in the following
    code snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命令行工具 `getprop` 和 `setprop` 查看系统上的当前属性，并创建新的属性，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Recall from [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android
    Is Weird*, that properties are mapped into everyone''s address space, thus anyone
    can read them. However, not everyone can set (write) them. The DAC permission
    model for properties is hardcoded into `system/core/init/property_service.c`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第3章 Android Is Weird](ch03.html "第3章 Android Is Weird")回忆起，属性被映射到每个人的地址空间中，因此任何人都可以读取它们。然而，并非每个人都可以设置（写入）它们。属性的
    DAC 权限模型是硬编码在 `system/core/init/property_service.c` 中的：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You must have the UID or GID in the `property_perms` array to set any property
    that the prefix matches with. For instance, in order to set the `selinux.` properties,
    you must be UID `AID_SYSTEM` (uid 1000) or root. Yes, root can always set a property,
    and this is a key benefit to applying SELinux to Android properties. Unfortunately,
    there is no way to `getprop -Z` to list the properties and their labels, like
    with `ls -Z` and files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在 `property_perms` 数组中具有 UID 或 GID，才能设置与前缀匹配的任何属性。例如，为了设置 `selinux.` 属性，你必须具有
    UID `AID_SYSTEM`（uid 1000）或 root 权限。是的，root 总是能够设置属性，这是将 SELinux 应用于 Android 属性的关键好处。不幸的是，没有方法使用
    `getprop -Z` 列出属性及其标签，就像使用 `ls -Z` 和文件一样。
- en: Relabeling existing properties
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新标签现有属性
- en: 'In order to become more comfortable with labeling properties, let''s relabel
    the `wifi.interface` property. First, let''s verify its context by causing a denial
    and viewing the denial log, as shown in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更熟悉标签属性，让我们重新标签 `wifi.interface` 属性。首先，让我们通过引发拒绝并查看拒绝日志来验证其上下文，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An interesting action occurred when we executed the `setprop` command over the
    UDOO serial console. The AVC denial record was printed out. This is because the
    serial console includes anything printed from the kernel using `printk()`. What
    happens here is the `init` process, which controls `setprops` as detailed in [Chapter
    3](ch03.html "Chapter 3. Android Is Weird"), *Android Is Weird*, writes a message
    to the kernel log. This log message shows up when we execute our `setprop` command.
    If you run this through `adb shell`, you'll see the message on the serial console,
    but not in the `adb` console. To do this, however, you must reboot your system
    because SELinux only prints denial records once while in permissive mode.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在UDOO串行控制台执行`setprop`命令时，发生了一个有趣的行为。AVC拒绝记录被打印出来。这是因为串行控制台包括了使用`printk()`从内核打印出的任何内容。这里发生的事情是`init`进程，它控制`setprops`，如[第3章](ch03.html
    "第3章。Android很奇怪")“Android很奇怪”中详细说明的，向内核日志写入一条消息。当我们执行`setprop`命令时，这条日志消息就会出现。如果你通过`adb
    shell`运行它，你会在串行控制台上看到这条消息，但不会在`adb`控制台上看到。但是，要这样做，你必须重新启动你的系统，因为SELinux在宽容模式下只会打印一次拒绝记录。
- en: 'The command using `adb shell` is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`adb shell`的命令如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The command using the serial console is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用串行控制台的命令如下：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the denial output, we can see that the property type label is `default_prop`.
    Let's change this to `wifi_prop`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从拒绝输出中，我们可以看到属性类型标签是`default_prop`。让我们将其更改为`wifi_prop`。
- en: 'We start by editing `property.te` in the `sepolicy` directory to declare the
    new type to label these properties by appending the following line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编辑`sepolicy`目录中的`property.te`，以声明新类型并按以下方式将这些属性标签化，添加以下行：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the type declared, the next step is to apply the label by modifying `property_contexts`
    by adding the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明后，下一步是通过修改`property_contexts`来应用标签，添加以下内容：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build the policy, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建策略：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Push the new `property_contexts` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 推送新的`property_contexts`文件：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Trigger a dynamic reload:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 触发动态重新加载：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ok, that didn't work! The `property_contexts` file must be in `/data/security`,
    not `/data/security/current`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这没有起作用！`property_contexts`文件必须在`/data/security`，而不是`/data/security/current`。
- en: To discover this, search the `libselinux/src/android.c` file. There is no mention
    of `property_contexts` in this file; thus, it must be mentioned elsewhere. This
    leads us to search `system/core`, which contains the property service for uses
    of that file. The matches are on code in `init.c` to load the file from priority
    locations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现这个问题，搜索`libselinux/src/android.c`文件。这个文件中没有提到`property_contexts`；因此，它必须在其他地方提到。这引导我们去搜索`system/core`，它包含了该文件的使用属性服务。匹配项在`init.c`中的代码，用于从优先位置加载文件。
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s push the `property_contexts` file to the proper location and try again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`property_contexts`文件推送到正确的位置并再次尝试：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Wow! It failed yet again. This exercise was meant to point out how tricky this
    can be if you forget to do something. No informative denial messages were displayed,
    only an indicator that it *was* denied. This is because the `sepolicy` file that
    contains the type declaration for `wifi_prop` was never pushed. This causes `check_mac_perms()`
    in `system/core/init/property_service.c` to fail in the `selinux_check_access()`
    function because it cannot find the type to compute the access check against,
    even though the look up in `property_contexts` succeeded. There are no verbose
    error logs from this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！它再次失败了。这个练习本意是想指出，如果你忘记做某事，这可能会多么棘手。没有显示任何有信息量的拒绝消息，只有一个指示表明*它*被拒绝了。这是因为包含`wifi_prop`类型声明的`sepolicy`文件从未被推送。这导致`system/core/init/property_service.c`中的`check_mac_perms()`在`selinux_check_access()`函数中失败，因为它找不到用于计算访问检查的类型，尽管在`property_contexts`中的查找是成功的。没有详细的错误日志。
- en: 'We can correct this by ensuring that the `sepolicy` is pushed as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过确保`sepolicy`也被推送来纠正这个问题：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we see a denial message, as expected, but the label of the target (or property)
    is `u:object_r:wifi_prop:s0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了预期的拒绝消息，但目标（或属性）的标签是`u:object_r:wifi_prop:s0`。
- en: Now with the target property labeled, you can allow access to it. Note that
    this is a contrived example, and in the real world, you probably would *not* want
    to allow access from shell to most properties. The policy should align with your
    security goals and the property of least privilege.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标属性已经标记，你可以允许对其的访问。请注意，这是一个虚构的例子，在现实世界中，你可能*不*希望允许从shell访问大多数属性。策略应与你的安全目标和对最小权限的要求相一致。
- en: 'We can add an `allow` rule in `shell.te` in the following way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`shell.te`中添加一个`allow`规则，如下所示：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compile the policy, push it to the phone, and trigger a dynamic reload:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译策略，将其推送到手机，并触发动态重新加载：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now attempt to set the `wifi.interface` property and notice the lack of denial.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试设置`wifi.interface`属性，并注意拒绝的缺失。
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating and labeling new properties
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和标记新属性
- en: All properties are dynamically created in the system using `setprop` calls or
    function calls that do the equivalent from C (`bionic/libc/include/sys/system_properties.h`)
    and Java (`android.os.SystemProperties`). Note that the `System.getProperty()`
    and `System.setProperty()` Java calls work on application private property stores
    and are not tied into the global one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都是通过`setprop`调用或执行等效操作的函数调用在系统中动态创建的（从C的`bionic/libc/include/sys/system_properties.h`和Java的`android.os.SystemProperties`）。请注意，`System.getProperty()`和`System.setProperty()`
    Java调用在应用程序私有属性存储上工作，并且与全局存储无关。
- en: For DAC controls, you need to modify `property_perms[]` as noted earlier to
    have permissions for non-root users to create or set the property. Note that root
    can always `set` and `create`, unless constrained by SELinux policy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DAC控制，你需要修改`property_perms[]`，如之前所述，以便非root用户有创建或设置属性的权限。请注意，root用户始终可以`set`和`create`，除非受到SELinux策略的限制。
- en: 'Suppose we want to create the `udoo.name` and `udoo.owner` properties; we only
    want the root user and shell domain to access them. We could create them like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建`udoo.name`和`udoo.owner`属性；我们只想让root用户和shell域访问它们。我们可以这样创建它们：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the denial shows these as being `default_prop` type. To correct this,
    we would relabel these, exactly as we did in the preceding section, *Relabeling
    existing properties*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意拒绝显示这些为`default_prop`类型。为了纠正这一点，我们需要重新标记这些属性，就像我们在上一节中做的那样，*重新标记现有属性*。
- en: Special properties
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊属性
- en: In Android, there are some special properties that have different behaviors.
    We enumerate the property names and meanings in the proceeding sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，有一些特殊属性具有不同的行为。我们在后续章节中列举了属性名称和含义。
- en: Control properties
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制属性
- en: 'Properties that start with `ctl` are reserved as control properties for controlling
    services through `init`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以`ctl`开头的属性被保留为控制属性，用于通过`init`控制服务：
- en: '`start`: Starts a service (`setprop ctl.start <servicename>`)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：启动一个服务（`setprop ctl.start <servicename>`）'
- en: '`stop`: Stops a service (`setprop ctl.stop <servicename>`)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：停止一个服务（`setprop ctl.stop <servicename>`）'
- en: '`restart`: Restarts a service (`setprop ctl.restart <servicename>`)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：重新启动一个服务（`setprop ctl.restart <servicename>`）'
- en: Persistent properties
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久属性
- en: Any property starting with the prefix `persist` persists across reboots and
    is restored. The data is saved to `/data/property` in files of the same name as
    the property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以`persist`为前缀的任何属性在重启后都会持续存在，并会被恢复。数据被保存到`/data/property`目录中，文件名与属性同名。
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: SELinux properties
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELinux属性
- en: The `selinux.reload_policy` property is special. As we have seen, its use is
    for triggering a dynamic reload event.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`selinux.reload_policy`属性是特殊的。正如我们所见，它的用途是触发动态重新加载事件。'
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have examined how to create and label new and existing properties
    and some of the oddities that occur when doing so. We have also examined the hard
    coded DAC permission table for properties in `property_service.c`, as well as
    the hardcoded specialty properties like the `ctl.` family. In the next chapter,
    we look at how the tool chain builds and creates all the policy files we have
    been using.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何创建和标记新的和现有的属性，以及在进行此操作时出现的某些奇怪现象。我们还检查了`property_service.c`中属性的硬编码DAC权限表，以及硬编码的特殊属性，如`ctl.`系列。在下一章中，我们将探讨工具链如何构建和创建我们一直在使用的所有策略文件。
