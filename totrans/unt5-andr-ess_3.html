<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. High-end Graphics for Android Devices</h1></div></div></div><p>Primarily, this chapter will explore how to enhance the quality of games and applications using different techniques and physically-based shaders. In this chapter, firstly we will examine the different techniques of lighting that are often used in game development and production stages. Secondly, this chapter will describe global illumination in Unity 5. At the end of the chapter, the reader will optimize a shader code.</p><p>The topics that will be covered in the chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Physically-based shaders</li><li class="listitem" style="list-style-type: disc">Global illumination</li><li class="listitem" style="list-style-type: disc">Practicing in shader optimization</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Physically-based shaders</h1></div></div></div><p>Unity makes it very easy to use<a id="id168" class="indexterm"/> ready shaders or write your own shaders using the Cg language or the surface shaders framework. Surface shaders are written in Cg, but they do a large amount of work that you do not have to write every time when you create a new shader. The surface shader language uses a component-based approach, or in other words a more abstract approach that facilitates writing complex shaders using a sophisticated lighting model. While using the surface shaders framework, graphics programmers do not have to keep reprocessed texture coordinates and matrix transformations. In this chapter, we will describe the different techniques and methods of writing performance-friendly shaders in great detail with nice visual quality effects used in a variety of games and applications developed throughout the world.</p><p>First, let's start with the basic principles and concepts of a shaders. A shader is a pre-compiled program for one of the number of stages of the graphics pipeline used in three-dimensional graphics to determine the final parameters of the object or image. It may include a description of arbitrary complexity absorption and scattering of light, texture mapping, reflection and refraction, shading, surface displacement, and postprocessing effects.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Basic shader concepts</h2></div></div></div><p>Programmable shaders <a id="id169" class="indexterm"/>are flexible and effective. Seemingly complex surfaces <a id="id170" class="indexterm"/>can be visualized with simple geometric forms. For example, the shaders can be used to draw a three-dimensional surface of the ceramic tiles on a completely flat surface.</p><p>In Unity, shaders are divided into three types: <strong>vertex</strong>, <strong>geometry</strong>, and <strong>fragment (pixel)</strong>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>The vertex shader</h3></div></div></div><p>The <strong>vertex shader</strong>
<a id="id171" class="indexterm"/> manipulates data mapped to the vertices of polyhedra. This data <a id="id172" class="indexterm"/>corresponds to the coordinates of the vertices in space, texture coordinates, a tangent vector, a bi-normal vector, and a normal vector. The vertex shader can be used for perspective vertices transformation, for generating texture coordinates, for lighting calculations, and so on.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>The geometry shader</h3></div></div></div><p>The <strong>geometry shader</strong>, in<a id="id173" class="indexterm"/> contrast to the vertex shader, is able to handle not only one <a id="id174" class="indexterm"/>vertex, but also a whole primitive with a set of vertexes (triangles, quads, and so on). It can be cut (two vertices) and triangular (three vertices), and the information on adjacent vertices (adjacency) can be processed for up to six vertices of the triangular primitive. Furthermore, the geometry shader can generate primitives "on the fly," without using a central processor. They were first used on the <em>Nvidia 8</em> series.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec09"/>The pixel/fragment shader</h3></div></div></div><p>The <strong>pixel shader</strong> works<a id="id175" class="indexterm"/> with fragments of the bitmap. A pixel shader<a id="id176" class="indexterm"/> is used in the last stage of the graphics pipeline to generate a fragment of the picture.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Shading languages</h2></div></div></div><p>Shading languages <a id="id177" class="indexterm"/>usually <a id="id178" class="indexterm"/>contain special data types such as matrices, samplers, vectors, and a set of built-in variables and constants for easy integration with different 3D libraries. As computer graphics have many application areas, to meet the different needs of the market, developers created a large number of shader languages.</p><p>These shading languages are focused on delivering the highest quality image. Describing the properties of materials made at the highest abstract level to work do not need any special skills or knowledge of programming hardware. Such shaders are usually created by artists in order to ensure "the right kind" such as texture mapping, light sources, and other aspects of art and science at the same time.</p><p>Processing these shaders is usually a resource-intensive task. The aggregate computing power needed for this work can be very high, as it is used to create photo-realistic images. The main part of the similar computation is performed by a visualization of large computer clusters.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Cg</h3></div></div></div><p>The <a id="id179" class="indexterm"/>Cg shading<a id="id180" class="indexterm"/> language developed by Nvidia in conjunction with Microsoft (essentially the same language from Microsoft is called <strong>HLSL</strong>, and is included in DirectX 9). Cg is used in Unity and stands as <a id="id181" class="indexterm"/>
<strong>C for Graphics</strong>. The language is very similar to C and it uses similar data types (<code class="literal">int</code>, <code class="literal">float</code>, and a special 16-bit floating point type—<code class="literal">half</code>). Cg also supports functions and structures. The language has peculiar optimizations like packed arrays—type declarations like <code class="literal">float a [4]</code> and <code class="literal">float4 a</code> are different types. The second announcement is a <a id="id182" class="indexterm"/>
<strong>packed array</strong>. The packed array operations are faster than conventional operations. Despite the fact that the language was developed by Nvidia, it works without problems with other graphics cards (for example, ATI cards). However, please note that all the shader programs have their own peculiarities, which can be obtained from specialized sources.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Unity shaders in Cg</h3></div></div></div><p>In addition, you should <a id="id183" class="indexterm"/>know that Unity 5 comes with built-in shaders, which are very useful, <a id="id184" class="indexterm"/>especially for some basic stuff required in many different games. Now let's start our wonderful journey into the world of Unity shaders in Cg language. Typically, shaders use diffuse components or a lighting model. First, you must understand what should be optimized in your shaders well. Basically, you should try to avoid complicated calculations and labor-intensive functions. In this chapter, firstly, we will examine the different techniques of lighting models that are so often used in game development and production stages. Lighting is one of the fundamental aspects of the shader. Therefore, programmers often use their approximate calculations for lighting to speed up performance.</p><p>Earlier, computer graphics were used as a fixed-function lighting model, which was not a very flexible solution, since it gave graphics programmers only a single lighting model that could only be adjusted by setting a finite set of parameters and textures. Unlike before, where a single fixed-lighting model was used, today, developers use a very flexible programmable approach to create different lighting models with the help of the Cg shader language, especially from the wonderful surface shaders in Unity.</p><p>The diffuse component in the shader will often specify exactly how the rays of light reflect from the surface in all directions. You may find that it is very similar to the work of a mirror that reflects the sun's rays at different angles and in all directions. However, it is not so, and we'll show you this difference in as much detail as possible later on in the chapter.</p><p>The main difference is that a reflective surface like a mirror reflects the image of the surrounding environment, while the diffuse lighting model reflects sunlight back into the field of view.</p><p>In order to create a simple<a id="id185" class="indexterm"/> and basic diffuse lighting model, you will need to create a <a id="id186" class="indexterm"/>shader that will contain an emissive color, an ambient color, and of course the total accumulation of color from all light sources. Techniques and tricks that we will show you in the following code will help you create your own lighting models, as well as explore various industry tricks to help you understand the basic ideas to create more complex lighting models using only the textures that will give a huge increase to your productivity. In other words, the use of premade textures to create lighting models can greatly increase your productivity.</p><p>Let's start with the simplest example of our surface shader as shown in the following code. The code was generated by the Unity Editor:</p><div><pre class="programlisting">// The first line of our shader code specifies the name of the
// shader in order to further select it from a list of all 
// shaders.
Shader "PacktPub/SimpleDiffuseLighting"
{
  // Next is the properties block of parameters of the shader 
  // known as Properties, which is followed by a block of the 
  // shader code known as SubShader.
        Properties
        {
                _MainTex ("Base (RGB)", 2D) = "white" {}
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                struct Input
                {
                        float2 uv_MainTex;
                };

                void surf (Input IN, inout SurfaceOutput o)
                {
                        half4 c = tex2D (_MainTex, IN.uv_MainTex);
                        o.Albedo = c.rgb;
                        o.Alpha = c.a;
                }
                ENDCG
        }

    // The shader specified as FallBack will be executed 
    // instead of our shader.
        FallBack "Diffuse"
}</pre></div><p>Let's consider the <code class="literal">Properties</code> block in<a id="id187" class="indexterm"/> more detail. The properties are some of the very <a id="id188" class="indexterm"/>important elements while writing shaders. The properties allow the artist to set their own textures or other settings to customize the visual effects. You can tune the properties of the selected shader through Unity materials.</p><p>Unity parses each shader code in order to find built-in structures. The <code class="literal">Properties</code> block is one of these built-in structures that Unity is looking for. Here is an example of the structure of the <code class="literal">Properties</code> block:</p><div><pre class="programlisting">Properties
{
        _YourVariableName ("Inspector GUI Name", Color) = (1,1,1,1)
}
//      Variable Name   Inspector GUI Name     Type  Default Value</pre></div><p>Each time you create a new property, you will need to name your variable. The variable name is used in the code of your shader, while the inspector GUI name will be shown in the Unity Editor. The type can be any one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Range (min, max)</code>: These are real numbers in the form of a slider from <code class="literal">min</code> to <code class="literal">max</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Color</code>: This opens the color picker in the Unity inspector for choosing the desired color value</li><li class="listitem" style="list-style-type: disc"><code class="literal">2D</code>: This is used for adding textures</li><li class="listitem" style="list-style-type: disc"><code class="literal">Rect</code>: This is a nonpower of two textures</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cube</code>: This is a cube map texture</li><li class="listitem" style="list-style-type: disc"><code class="literal">Float:</code> These are real values without the slider</li><li class="listitem" style="list-style-type: disc"><code class="literal">Vector</code>: This is a four-component vector with real numbers</li></ul></div><p>At the end of the <code class="literal">Properties</code> structure, we <a id="id189" class="indexterm"/>specified the default <a id="id190" class="indexterm"/>value.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>A custom diffuse lighting model</h2></div></div></div><p>Before you write your <a id="id191" class="indexterm"/>own diffuse lighting model, we will <a id="id192" class="indexterm"/>consider our new properties:</p><div><pre class="programlisting">Properties
{
        _FirstColor ("First Color", Color) = (1,1,1,1)
        _SecondColor ("Second Color", Color) = (0,0,0,0)
        _PowValue ("Pow Value", Range(0,10)) = 5.5
}</pre></div><p>Next, we need to declare these new properties in our shader:</p><div><pre class="programlisting">float4 _FirstColor;
float4 _SecondColor;
float  _PowValue;</pre></div><p>After the announcement of the properties in the shader code, we can use these variables as shown here:</p><div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput surface)
{
        float4 c = pow(_FirstColor + _SecondColor, _PowValue);
        surface.Albedo = c.rgb;
        surface.Alpha = c.a;
}</pre></div><p>As a result, you should have a shader as shown here:</p><div><pre class="programlisting">Shader "PacktPub/YourDiffuseLighting"
{
        Properties
        {
                _FirstColor ("First Color", Color) = (1,1,1,1)
                _SecondColor ("Second Color", Color) = (0,0,0,0)
                _PowValue ("Pow Value", Range(0,10)) = 3.5
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf Lambert

                float4 _FirstColor;
                float4 _SecondColor;
                float  _PowValue;
                float4 c;
                struct Input
                {
                        float2 uv_MainTex;
                };

                void surf (Input IN, inout SurfaceOutput surface)
                {
                        c = pow(_FirstColor + _SecondColor, _PowValue);
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><p>It's time to create your <a id="id193" class="indexterm"/>own diffuse lighting model. In most cases, no<a id="id194" class="indexterm"/> built-in lighting is well-suited for specific tasks in the game or application. Specific optimization problems require unique solutions. In order to override the built-in lighting functions you need to register, the <code class="literal">SubShader</code> block in the next line of code:</p><div><pre class="programlisting">#pragma surface surf YourName</pre></div><p>Now, we can describe our custom lighting function as shown in the following example:</p><div><pre class="programlisting">inline float4 LightingYourName 
(SurfaceOutput surface, float3 lightDirection, float attenuation)
{
        float delta = max(0, dot(surface.Normal, lightDirection));
        c.rgb = (surface.Albedo * _LightColor0.rgb) * 
                                                (delta * attenuation * 2);
        c.a = surface.Alpha;
        return c;
}</pre></div><p>Now, let's systematically look at the fundamental elements. The <code class="literal">#pragma</code> directive specifies the name of the function to be used for lighting. We used the built-in feature called <strong>Lambert</strong>
<a id="id195" class="indexterm"/> defined in the <code class="literal">Lighting.cginc</code> file, and now we specified the name of our function for future use. In establishing this lighting function, it is necessary to remember that the name of the function will eventually be formed using the first word of <code class="literal">Lighting + &lt;Your Function Name&gt;</code>, that is, for example if you decide to call a function <code class="literal">SunShine</code>, then the name of your lighting function will be <code class="literal">LightingSunShine</code>. There are three<a id="id196" class="indexterm"/> options to create your custom lighting <a id="id197" class="indexterm"/>functions that differ from each other by their input parameters as shown here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">float4 Lighting&lt;YourName&gt; (SurfaceOutput surface, float3 lightDirection, float attenuation) {}</code>: You should use this function for forward rendering, when you don't need the view direction value</li><li class="listitem" style="list-style-type: disc"><code class="literal">float4 Lighting&lt;YourName&gt; (SurfaceOutput surface, float3 lightDirection, float3 viewDirection, float attenuation) {}</code>: You should use this function for forward rendering, when you need the view direction value</li><li class="listitem" style="list-style-type: disc"><code class="literal">float4 Lighting&lt;YourName&gt;_PrePass (SurfaceOutput surface, float4 light) {}</code>: You should use this function for deferred rendering</li></ul></div><p>Ultimately, you should get a shader as follows:</p><div><pre class="programlisting">Shader "PacktPub/YourLightingModel"
{
        Properties
        {
                _FirstColor ("First Color", Color) = (1,1,1,1)
                _SecondColor ("Second Color", Color) = (0,0,0,0)
                _PowValue ("Pow Value", Range(0,10)) = 3.5
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf YourName

                float4 _FirstColor;
                float4 _SecondColor;
                float  _PowValue;
                float4 c;
    
                struct Input
                {
                        float2 uv_MainTex;
                };
    
                inline float4 LightingYourName (
                        SurfaceOutput surface, 
                        float3 lightDirection, 
                        float attenuation
                ){
                        float delta = max(0, dot(surface.Normal, lightDirection));
                        c.rgb = (surface.Albedo * _LightColor0.rgb) *
                                                (delta * attenuation * 2);
                        c.a = surface.Alpha;
                        return c;
                }

                void surf (Input IN, inout SurfaceOutput surface)
                {
                        c = pow(_FirstColor + _SecondColor, _PowValue);
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec12"/>A basic reflection environment</h3></div></div></div><p>Next, let's look at other ideas <a id="id198" class="indexterm"/>and techniques widely known in professional circles around the world that are used to write performance friendly shaders with nice visual effects. The following examples are based on environment reflections on your surface. A simple source code of this shader is shown here:</p><div><pre class="programlisting">Shader "PacktPub/BasicReflectionEnvironment"
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _CubeMapTexture ("Cube Map Texture", CUBE) = ""{}
                _ReflectionCount ("Reflection Count", Range(0.01, 1)) = 0.17
        }
  
        SubShader 
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                samplerCUBE _CubeMapTexture;
    
                float4 _DiffuseTint;
                float _ReflectionCount;
    
                float4 c;

                struct Input 
                {
                        float2 uv_MainTex;
                        float3 worldRefl;
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex) * _DiffuseTint;
                        surface.Emission = texCUBE(_CubeMapTexture, IN.worldRefl).rgb * _ReflectionCount;
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
   
        FallBack "Diffuse"
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec13"/>Masked texture reflection</h3></div></div></div><p>The next new shader <a id="id199" class="indexterm"/>implements a new technique that uses a texture to mask the reflection of your environment, and it is shown here:</p><div><pre class="programlisting">Shader "PacktPub/MaskedTextureReflection"
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _ReflectionCount ("Reflection Count", Range(0, 1)) = 1
                _CubeMapTexture ("Cube Map Texture", CUBE) = ""{}
                _MaskedTextureReflection ("Masked Texture Reflection", 2D) = ""{}
        }
  
        SubShader
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                sampler2D _MaskedTextureReflection;
    
                samplerCUBE _CubeMapTexture;
    
                float4 _DiffuseTint;
                float _ReflectionCount;
    
                float4 c;

                struct Input 
                {
                        float2 uv_MainTex;
                        float3 worldRefl;
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex);
                        float3 reflectionTexCube = texCUBE(_CubeMapTexture, IN.worldRefl).rgb;
                        float4 reflectionMaskTexel = tex2D(_MaskedTextureReflection, IN.uv_MainTex);
  
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Emission = (reflectionTexCube * reflectionMaskTexel.r) * _ReflectionCount;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Lighting model techniques</h2></div></div></div><p>Let's consider a variety of techniques and <a id="id200" class="indexterm"/>methods of<a id="id201" class="indexterm"/> implementation of the lighting model, which, like the previous shaders, are used worldwide in the game industry as well as in movies and cartoons.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec14"/>The Lit sphere model</h3></div></div></div><p>To begin, we would like to<a id="id202" class="indexterm"/> consider the <code class="literal">LitSphere</code> lighting model. The idea is <a id="id203" class="indexterm"/>very simple and straightforward—we should just use a 2D texture in order to completely bake our light. Alternatively, it is necessary to take into account and not forget that this technique is static and does not change the lighting up until the texture used for baking light is changed. This technique gives very high-quality lighting and is optimized enough, but it is not dynamic. In other words, it does not depend on the angle or distance from the camera or from the viewer that can be changed in real time, because this technique does not depend on the lighting in the scene. Let's explore this shader as follows:</p><div><pre class="programlisting">Shader "PacktPub/LitSphere" 
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _NormalMapTexture ("Normal Map Texture", 2D) = "bump" {}
        }
  
        SubShader
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf YourUnlit vertex:vert

                sampler2D _MainTex;
                sampler2D _NormalMapTexture;
                float4 _DiffuseTint;
    
                float4 c;
                float2 uv;
    
                inline float4 LightingYourUnlit (SurfaceOutput surface, float3 lightDirection, float attenuation)
                {
                        c.rgb = float4(1,1,1,1) * surface.Albedo;
                        c.a = surface.Alpha;
      
                        return c;
                }

                struct Input 
                {
                        float2 uv_MainTex;
                        float2 uv_NormalMapTexture;
      
                        float3 tangentOne;
                        float3 tangentTwo;
                };
    
void vert (inout appdata_full v, out Input inputData) 
{
        UNITY_INITIALIZE_OUTPUT(Input, inputData);
        
        TANGENT_SPACE_ROTATION;
            
        inputData.tangentOne = mul(rotation, UNITY_MATRIX_IT_MV[0].xyz);
        inputData.tangentTwo = mul(rotation, UNITY_MATRIX_IT_MV[1].xyz);          
}

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        surface.Normal = UnpackNormal(tex2D(_NormalMapTexture, IN.uv_NormalMapTexture)).rgb;

                        uv.x = dot(IN.tangentOne, surface.Normal);
                        uv.y = dot(IN.tangentTwo, surface.Normal);
    
                        c = tex2D (_MainTex, uv * 0.5 + 0.5);
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Alpha = c.a;
                }
                ENDCG
        } 
  
        FallBack "Diffuse"
}</pre></div><p>There are many different <a id="id204" class="indexterm"/>techniques and approaches to create lighting models and <a id="id205" class="indexterm"/>other visual effects; we cannot put all the ideas and techniques into this book, as it is beyond the scope of this book. You can also implement your own new ideas and techniques; it depends on your imagination. The previous examples of different approaches for writing shaders are widely used by developers around the world to create high-quality rendering in real time, and for optimization. Also, you can write shaders that work with the model vertices, so you can very simply create shader that will play the waves animation from the primitive plane.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Realistic rendering</h2></div></div></div><p>Marcos Fajardo of <em>Solid Angle</em>—the company <a id="id206" class="indexterm"/>behind the renderer <em>Arnold</em>—noted <a id="id207" class="indexterm"/>that more and more production studios in the world have either already come to that, or are in the process of transition with the following quote:</p><div><blockquote class="blockquote"><p><em>"The process is going on in the entire industry, and it's something. I've been working with this for the past ten years or so, and I'm really glad to see that this is happening at last."</em></p></blockquote></div><p>Fajardo can be called one of the greatest defenders and activists of global change in the industry. Solid Angle is really at the forefront of the large-scale movement to the path-traced GI with physically-plausible materials and lighting for production decisions (that is, when the budget is smaller and the time frame is more compressed).</p><p>The basis of the popularity of the "honest" method is the desire to "catch two rabbits at once," simplify the lives of artists around the world and to achieve a more realistic picture.</p><p>With some older technology chains, artists can get the scene with a few hundred light sources (where each source is needed to fulfill its role, one for the highlight of a material and the second for the specular reflection on this material, the third and fourth for the glare and reflections on the<a id="id208" class="indexterm"/> second material, plus ten to simulate global illumination, and so on), with very complex shaders written by the developer with C++, the code was full of tricks and tweaks. Lighting designers often just sit, turning on and off lights, one after the other—it is easy to understand why some of them are so necessary.</p><p>Most companies do <a id="id209" class="indexterm"/>not count the fact that the introduction of natural light sources and materials make a quick render itself, but there is an expectation that this will greatly facilitate the work of the artist. An hour of work which, to be honest, is a few tens of times more expensive than an hour rendering.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Global illumination</h1></div></div></div><p>During the, <em>Game Developers Conference</em> in 2014, which started on March 17 in San Francisco, the company <a id="id210" class="indexterm"/>Unity Technologies introduced the fifth generation of its popular game engine Unity. One of the most important features that distinguishes it from the previous edition is a new system of global illumination in real time—Enlighten—implemented with the participation of experts from the British company, <em>Geomerics</em>.</p><div><img src="img/9191OT_03_01.jpg" alt="Global illumination"/></div><p>Unity 5 is presented with support from WebGL standard web module optimization <code class="literal">asm.js</code>, physics engine NVIDIA PhysX 3.3, the system of creation and animation vegetation—SpeedTree, an advanced shader system, the preview function light maps in real time, and a cross-processed audio advertising network in Unity Cloud that facilitates the promotion of mobile games. In addition, the fifth version of the engine will be able to run in a 64-bit environment that significantly simplifies the workflow through a new multi-threaded scheduler, and provides you with the opportunity to make changes in real time and improve the system to create game resources (assets list) and an intuitive interface.</p><div><img src="img/9191OT_03_02.jpg" alt="Global illumination"/></div><p>The latest version of this <a id="id211" class="indexterm"/>toolkit, traditionally the best-selling in small teams of developers, is designed including large companies. This makes it a competitor to other high-tech new generation of game engines such as CryEngine and Unreal Engine 4. Along with the fourth generation engine from Epic Games, it has recently signed another agreement with Mozilla, where Unity 5 can be used by developers of three-dimensional and two-dimensional games for browsers and mobile devices.</p><div><img src="img/9191OT_03_03.jpg" alt="Global illumination"/></div><p>In Unity 5, developers will be able to view the coverage maps in real time using the ray tracing PowerVR from the company <em>Imagination Technologies</em>. This technique reduces the processing time, which gives a very good performance. Developers will be able to create a variety of materials from the real world with the new shader system in Unity 5.</p><p>
<strong>Global illumination</strong> is <a id="id212" class="indexterm"/>the name of a series of algorithms used in three-dimensional graphics for more realistic simulation of light. These algorithms take into account not only the direct light from the source (direct illumination), but also reflected light from various surfaces (indirect illumination).</p><p>In theory, <em>reflection</em>, <em>refraction</em>, and <em>shadows</em> are examples of global illumination, because for them it is necessary to consider the effect of the simulation of one object to the other (in contrast to the case when the object is exposed to direct light). In practice, however, the simulation of diffuse reflection or caustics is called global illumination.</p><p>Images obtained by the application of global illumination algorithms often appear more realistic than those in the rendering process that apply only direct illumination algorithms. However, to calculate global illumination requires much more time.</p><p>The following figure was processed only by direct illumination algorithms:</p><div><img src="img/9191OT_03_04.jpg" alt="Global illumination"/></div><p>The following figure was processed by global illumination algorithms:</p><div><img src="img/9191OT_03_05.jpg" alt="Global illumination"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Practicing in shader optimization</h1></div></div></div><p>Now, it is time to discuss<a id="id213" class="indexterm"/> how we can optimize our shaders. Alternatively, it is time to consider the other methods, such as optimizing built-in data types, which can significantly reduce the overhead of the Unity shaders' memory. We consider Unity shaders optimization for all supported platforms without any exclusions.</p><p>Very often, you will need to optimize shaders to achieve the same visual effect, but with a smaller number of textures for example. Primarily, when optimizing shader code, we would like to direct your attention to the types of variables. If you are willing to sacrifice the accuracy of calculations in order to decrease the quality to improve performance, then you should use the <code class="literal">half</code> or <code class="literal">fixed</code> variable types instead of <code class="literal">float</code>. As an example, you can use a <code class="literal">half</code> type of variable everywhere in your shader code:</p><div><pre class="programlisting">inline half4 LightingCarVehicle (SurfaceOutput surface, half3 lightDirection, half3 viewDirection, half attenuation)</pre></div><p>You can also replace <code class="literal">float</code> with <code class="literal">half</code> in the following statement:</p><div><pre class="programlisting">inline float4 LightingCarVehicle (SurfaceOutput surface, float3 lightDirection, float3 viewDirection, float attenuation)</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">float</code>: These variables have 32 bits precision</li><li class="listitem" style="list-style-type: disc"><code class="literal">half</code>: These variables have 16 bits precision</li><li class="listitem" style="list-style-type: disc"><code class="literal">fixed</code>: These variables have 11 bits precision</li></ul></div><p>For example, let's optimize our previous shader code <code class="literal">CarVehicle.shader</code> as follows:</p><div><pre class="programlisting">Shader "PacktPub/OptimizedCarVehicle"
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _DiffuseIntensity ("Diffuse Intensity", Range(0.01, 17)) = 7.7
                _SpecularColor ("Specular Color", Color) = (1,1,1,1)
                _SpecularIntensity ("Specular Intensity", Range(0.01, 50)) = 17
                _ReflectionCubeMap ("Reflection Cube Map", CUBE) = "" {}
                _BRDFTexture ("BRDF Texture", 2D) = "white" {}
                _ReflectionIntensity ("Reflection Intensity", Range(0.01, 11.0)) = 5.0
                _ReflectionCount ("Reflection Count", Range(0.01, 1.0)) = 0.17
                _FalloffSpread ("Falloff Spread", Range(0.01, 17)) = 5.3
        }
  
        SubShader 
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf CarVehicle

                samplerCUBE _ReflectionCubeMap;
    
                sampler2D _MainTex;
                sampler2D _BRDFTexture;
    
                fixed _SpecularIntensity;
                fixed _DiffuseIntensity;
                fixed _FalloffSpread;
                fixed _ReflectionCount;
                fixed _ReflectionIntensity;
    
                fixed4 _DiffuseTint;
                fixed4 _SpecularColor;
    
                fixed4 c;
                fixed3 halfVec;
                fixed falloff;
                fixed delta;
                fixed halfVecDotSurfaceNormal;
                fixed s;
    
                inline fixed4 LightingCarVehicle (SurfaceOutput surface, fixed3 lightDirection, fixed3 viewDirection, fixed attenuation)
                {
                        halfVec = normalize (lightDirection + viewDirection);
                        delta = max (0, dot (surface.Normal, lightDirection));
      
                        halfVecDotSurfaceNormal = 1 - dot(halfVec, normalize(surface.Normal));
                        halfVecDotSurfaceNormal = pow(clamp(halfVecDotSurfaceNormal, 0.0, 1.0), _DiffuseIntensity);
                        c = tex2D(_BRDFTexture, fixed2(delta, 1 - halfVecDotSurfaceNormal));
      
                        s = pow (max (0, dot (surface.Normal, halfVec)), surface.Specular * _SpecularIntensity) * surface.Gloss;
      
                        c.rgb = (surface.Albedo * _LightColor0.rgb * c.rgb + _LightColor0.rgb * _SpecularColor.rgb * s)* (attenuation * 2);
                        c.a = surface.Alpha + _LightColor0.a * _SpecularColor.a * s * attenuation;
      
                        return c;
                }

                struct Input 
                {
                        fixed2 uv_MainTex;
      
                        fixed3 worldRefl;
      
                        fixed3 viewDir;
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex);
      
                        falloff = pow(saturate(1 - dot(normalize(IN.viewDir), surface.Normal)), _FalloffSpread);
      
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Emission = pow((texCUBE(_ReflectionCubeMap, IN.worldRefl).rgb * falloff), _ReflectionIntensity) * _ReflectionCount;
                        surface.Specular = c.r;
                        surface.Gloss = 1.0;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><p>To understand how to <a id="id214" class="indexterm"/>develop shaders faster and better, you must understand that this can only be achieved by full optimization, using a variety of techniques and approaches. Let's divide our shader optimization process into the following three categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Optimization of memory used for variables</li><li class="listitem" style="list-style-type: disc">Optimization of the number and size of used textures</li><li class="listitem" style="list-style-type: disc">Optimization of computational algorithms</li></ul></div><p>All the mentioned points have been already discussed. Some of the ideas of how to optimize your shaders have been already considered earlier in this chapter, and we will show some more interesting approaches and techniques. We hope that most of the methods, techniques, approaches, and ideas of this book will greatly help you in production to achieve the desired quality and performance at the same time.</p><p>Also, while optimizing shaders you need to remember and know that the code should be as small as possible. This means that nothing unnecessary should be in your code. Many of the ideas described in the previous chapters, especially in the preceding fourth chapter, which talked about code optimization in C# and JavaScript, are well suited to optimize your shader code. Also, we want you to note that the frequency of execution of your shader code greatly affects the performance. Very often, shader developers use very good techniques in order to optimize their shaders. They prefer using vertex shaders instead of pixel shaders; this will greatly improve your performance in most cases, as there are significantly more pixels than vertices. Hence, processing the pixel shader frequency of the execution code will be much greater than for vertices.</p><p>Let's also consider the <a id="id215" class="indexterm"/>directives that may well optimize your shaders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">approxview</code>: This <a id="id216" class="indexterm"/>approximation is good enough in many cases. You should use this directive when you need to get the normalized view direction per vertex instead of per pixel.</li><li class="listitem" style="list-style-type: disc"><code class="literal">halfasview</code>: This will be<a id="id217" class="indexterm"/> computed and normalized per vertex halfway between view and light directions (half vector), and the lighting function will receive a <code class="literal">half</code> vector as a parameter instead of view vector.</li><li class="listitem" style="list-style-type: disc"><code class="literal">noforwardadd</code>: In the event<a id="id218" class="indexterm"/> of rendering shaders in one pass, even with multiple lights, and in the event of making your shader smaller, this directive is the best choice for you. The shader will support only one directional light in forward rendering. The rest of the lights can still have an effect like vertex lights or spherical harmonics. The rest of the lights can be used for spherical harmonics or for vertex light effects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">exclude_path:prepass</code>: The <a id="id219" class="indexterm"/>shader that uses this directive will not accept any custom lighting from the deferred renderer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">noambient</code>: This <a id="id220" class="indexterm"/>directive should be used in the event of deactivating spherical harmonics and ambient lights on your shader. This can slightly enhance your performance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nolightmap</code>: This <a id="id221" class="indexterm"/>directive disables Unity's internal light mapping system. In other words, it does not perform a light mapping check.</li></ul></div><p>
<strong>Alpha testing</strong> on mobile <a id="id222" class="indexterm"/>devices is <a id="id223" class="indexterm"/>very expensive, so you should use transparent shaders on mobile devices very accurately. You must use the alpha testing only when necessary. For example, let's cover optimized shader as follows:</p><div><pre class="programlisting">Shader "PacktPub/OptimizedShaderExample"
{
        Properties 
        {
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _SpecularWidth ("Specular Width", Range(0.01, 1)) = 0.5
                _NormalMapTexture ("Normal Map Texture", 2D) = "bump"{}
        }
  
        SubShader 
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf OptimizedBlinnPhong exclude_path:prepass nolightmap noforwardadd halfasview

                sampler2D _MainTex;
                sampler2D _NormalMapTexture;
                half _SpecularWidth;
    
                half4 c;
                half d;
                half s;

                struct Input 
                {
                        half2 uv_MainTex;
                };
    
                inline half4 LightingOptimizedBlinnPhong (SurfaceOutput surface, half3 lightDir, half3 halfDir, half atten)
                {
                        d = max(0, dot(surface.Normal, lightDir));
                        s = pow(max(0, dot(surface.Normal, halfDir)), surface.Specular * 128) * surface.Gloss;
      
                        c.rgb = (surface.Albedo * _LightColor0.rgb * d + _LightColor0.rgb * s) * (atten * 2);
                        c.a = 0.0;
      
                        return c;
                }

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D(_MainTex, IN.uv_MainTex);
      
                        surface.Albedo = c.rgb;
                        surface.Gloss = c.a;
                        surface.Alpha = 0.0;
                        surface.Specular = _SpecularWidth;
                        surface.Normal = UnpackNormal(tex2D(_NormalMapTexture, IN.uv_MainTex)).rgb;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Best case practice</h2></div></div></div><p>After our journey into the <a id="id224" class="indexterm"/>world of diverse ideas, approaches, and techniques in the field of lighting calculations, let's look at the best practice in order to maintain many different shaders easily. Let's consider the possibility of reusability of our shader code; for example, various lighting functions in Unity. In order to avoid writing the same code for the same lighting function each time for a new shader, it's best to write the code lighting function once and then just use this in any shader if necessary, as programmers use different frameworks and libraries. This practice will help you create a framework for your shaders, which will greatly facilitate easy development and effortless shader maintenance. In the previous examples, we used built-in <code class="literal">CgIncludes</code> files such as <code class="literal">Lambert</code> and <code class="literal">BlinnPhong</code> lighting functions. Unity created these lighting models for us. Unity helps us reduce our efforts while writing performance-friendly and nice quality shaders.</p><p>You can view the code embedded in Unity built-in <code class="literal">CgIncludes</code> files, which are located inside a directory called <code class="literal">CgIncludes</code>. Without these files, it will be much harder to write shaders in Unity. That's why Unity surface shaders are so efficient. Let's create our own <code class="literal">CgInclude</code> file as follows:</p><div><pre class="programlisting">#ifndef YOUR_NAME_INCLUDE
#define YOUR_NAME_INCLUDE

half4 _YourColorVariable;

inline half4 LightingOptimizedLambert (SurfaceOutput surface, half3 lightDirection, half attenuation)
{
        half diffuseValue = max(0, dot(surface.Normal, lightDirection));
        diffuseValue = (diffuseValue + 0.5) * 0.5;

        half4 tmpColor;
        tmpColor.rgb = surface.Albedo * _LightColor0.rgb * ((diffuseValue * _YourColorVariable.rgb) * attenuation * 2);
        tmpColor.a = surface.Alpha;

        return tmpColor;
}

#endif</pre></div><p>Now let's consider the code for the next shader as follows, where you can see how to use your <code class="literal">CgInclude</code> file with <a id="id225" class="indexterm"/>your lighting function, and how you can declare your variable <code class="literal">_YourColorVariable</code>:</p><div><pre class="programlisting">Shader "PacktPub/UsingCgIncludeOptimzedLambert"
{
        Properties 
        {
                _YourColorVariable ("Your Color Variable", Color) = (1,1,1,1)

                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _NormalMapTexture ("Normal Map Texture", 2D) = "bump" {}
                _CubeMapTexture ("Cube Map Texture", CUBE) = ""{}
                _ReflectionCount ("Reflection Count", Range(0,1)) = 0.17
        }
  
        SubShader
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #include "YourCgIncludeOptimizedLambert.cginc"
                #pragma surface surf OptimizedLambert

                samplerCUBE _CubeMapTexture;
    
                sampler2D _MainTex;
                sampler2D _NormalMapTexture;
    
                float4 _DiffuseTint;
                float _ReflectionCount;
    
                float4 c;

                struct Input 
                {
                        float2 uv_MainTex;
      
                        float2 uv_NormalMapTexture;
      
                        float3 worldRefl;
      
                        INTERNAL_DATA
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex);
      
                        surface.Normal = UnpackNormal(tex2D(_NormalMapTexture, IN.uv_NormalMapTexture)).rgb;
                        surface.Emission = texCUBE (_CubeMapTexture, WorldReflectionVector(IN, surface.Normal)).rgb * _ReflectionCount;
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Alpha = c.a;
                }
                ENDCG
        }

        FallBack "Diffuse"
}</pre></div><p>Thus, you can create a proper <a id="id226" class="indexterm"/>framework of your own shaders. Also, you can use examples from this chapter and place all your code in the form of <code class="literal">CgIncludes</code> files. This will greatly help you avoid repetitions in the code, which will greatly simplify the development of shaders and also facilitate their optimization.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, you learned a lot about writing shaders and their optimization. We started with a simple shader code and examined the fundamental elements in Unity surface shaders. Next, we wrote our custom diffuse lighting model. Also, we examined global illumination. We explored the various optimization techniques by changing the shader variable types, as well as by writing specific directives. Towards the end of this chapter, we covered the best case practice while developing shaders using <code class="literal">CgIncludes</code> files, and learned how to use its code.</p><p>The next chapter will cover legacy and Mecanim animation systems in Unity 5. You will also develop a simple custom sprite animation system and explore how to import, set up, and play audio files inside your scripts in Unity 5. At the end of the next chapter, you will explore the physics and particle systems in Unity 5.</p></div></body></html>