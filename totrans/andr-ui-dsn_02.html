<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;What Goes into an Effective UI?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. What Goes into an Effective UI?</h1></div></div></div><p>In this chapter, we'll look at the core components of every Android user interface: layouts and views. You'll learn how to add these elements to your Android projects and all the different ways you can customize these UI building blocks to meet your exact design needs. We'll also look at how to enhance our UI using strings, colors resources, and state lists, and we'll begin to look at how we can create a user interface that looks crisp and clear regardless of the screen it's being displayed on.</p><p>Although we'll be exploring layouts and views in greater detail throughout this chapter, the two are intrinsically linked. Before you can add a view to your app, you need a layout, and a layout without any views isn't likely to win your app any fans.</p><p>So, before we dive into the finer details of UI design, let's get an overview of how views and layouts come together to create an effective Android UI.</p><div class="section" title="What is a view?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>What is a view?</h1></div></div></div><p>As you're already aware, Android apps are made up of Activities. Typically, one <span class="strong"><strong>Activity</strong></span> is displayed at a time and this Activity occupies the entire screen.</p><p>Each Activity is made up of views, which are the most basic component of a user interface. Views always occupy a rectangular area, although a view can display content of any shape:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_001.jpg" alt="What is a view?"/></div><p>
</p><p>Some examples of the most commonly used views are <code class="literal">TextView</code>, <code class="literal">EditText</code>, <code class="literal">ImageView</code>, <code class="literal">Button</code>, and <code class="literal">ImageButton</code>.</p></div></div>
<div class="section" title="What is a layout?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>What is a layout?</h1></div></div></div><p>A <span class="strong"><strong>ViewGroup</strong></span> is a container that groups other child views and ViewGroup objects together.</p><p>One of the most common examples of a ViewGroup is a layout, which is an invisible container that's responsible for positioning the child elements on the screen. For example, <span class="strong"><strong>LinearLayout</strong></span> is a ViewGroup (also sometimes known as a <span class="strong"><strong>layout manager</strong></span>) that arranges its child elements (views or ViewGroups) into vertical or horizontal rows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_002.jpg" alt="What is a layout?"/></div><p>
</p><p>In this chapter, I'll mostly be focusing on layout managers, as these are the ViewGroup you'll typically use most often; but just be aware that other kinds of ViewGroup also exist.</p></div>
<div class="section" title="Building your UI &#x2013; XML or Java?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Building your UI – XML or Java?</h1></div></div></div><p>The easiest way of defining your user interface (and the views, ViewGroups, and layout elements that it contains) is via your project's XML file.</p><div class="section" title="Declaring your UI with XML"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Declaring your UI with XML</h2></div></div></div><p>Android provides a straightforward XML vocabulary that gives your user interface a human-readable structure, and creates a separation between the code that defines your UI and the code that controls your app's behavior. You define your layouts in XML in a dedicated layout resource file. This helps to keep both sets of code cleaner, and it gives you the ability to tweak and refine your UI without having to touch your app's underlying code. For example, you can update your layout to support an additional language <span class="emphasis"><em>without</em></span> having to touch the previously-tested code.</p><p>Declaring your UI in XML also makes it easier to provide alternate layouts; for example, at some point, you may want to create an alternative version of your layout that's optimized for landscape mode. If you declare your original layout in XML, providing a landscape-optimized layout is as easy as creating a <code class="literal">res/layout-land</code> directory, and then filling this folder with XML files that define your app's landscape-optimized layouts.</p><p>When you create an Android project in Eclipse or Android Studio, the IDE's project creation wizard automatically generates a layout resource file for your application's main activity:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_003.jpg" alt="Declaring your UI with XML"/></div><p>
</p><p>You'll find this layout resource file in your project's <code class="literal">res/layout</code> folder:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_004.jpg" alt="Declaring your UI with XML"/></div><p>
</p><p>Each layout resource file must contain exactly one root element, which can either be a view or a ViewGroup. For example, you can use the vertical <code class="literal">LinearLayout</code> element as your layout's root element:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
 &#13;
&lt;LinearLayout        android:orientation="vertical"   android:layout_width="fill_parent"   android:layout_height="fill_parent"&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note4"/>Note</h3><p>You can also use the <code class="literal">&lt;merge&gt;</code> element as your root element. We'll cover merging in 
<a class="link" href="ch09.html" title="Chapter 9. Optimizing Your UI">Chapter 9</a>, <span class="emphasis"><em>Optimizing your UI</em></span>.</p></div></div><p>Once you've defined your layout resource file's root element, you're ready to build a view hierarchy by adding objects such as <code class="literal">TextViews</code>, <code class="literal">Buttons</code>, and <code class="literal">ImageViews</code>.</p><p>To load a layout resource file, you need to reference it from your application's <code class="literal">onCreate()</code> callback implementation. For example, open your project's <code class="literal">MainActivity.java</code> file and you will see something like this:</p><pre class="programlisting">public void onCreate(Bundle savedInstanceState) { &#13;
  super.onCreate(savedInstanceState); &#13;
  setContentView(R.layout.main_layout); &#13;
} &#13;
</pre><p>Here, your project calls <code class="literal">setContentView()</code> and passes it the reference to your project's automatically-generated resource file; in this instance, it is <code class="literal">R.layout.main_layout</code>. When the user loads your application, <code class="literal">MainActivity</code> will read this referenced layout resource file and display its content to the user.</p></div><div class="section" title="Declaring your UI programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Declaring your UI programmatically</h2></div></div></div><p>The second option is to create your UI programmatically at runtime. This approach isn't generally recommended, as it means that your app's underlying code and the UI code get mixed up. So, tweaking an element of your app's UI becomes much more difficult than it needs to be.</p><p>However, sometimes you will need to define certain aspects of your user interface programmatically, and occasionally you may even need to define the whole thing in Java.</p><p>As we've already seen, when you define your layout resource in XML, you load it from your application code:</p><pre class="programlisting">setContentView(R.layout.activity_main); &#13;
</pre><p>Here, you're telling your Activity to load the <code class="literal">main_activity.xml</code> layout resource file, but if you're creating your layout programmatically, you need to remove this bit of code so that your Activity doesn't go looking for a layout resource file.</p><p>For example, take a look at the following:</p><pre class="programlisting">@Override &#13;
protected void onCreate(Bundle savedInstanceState) { &#13;
super.onCreate(savedInstanceState); &#13;
 &#13;
  // Create a LinearLayout object that will contain all the views in this Activity// &#13;
 &#13;
    LinearLayout linearLayout = new LinearLayout(this); &#13;
 &#13;
//Set the LinearLayout's orientation. In this instance, it's set to horizontal// &#13;
 &#13;
  linearLayout.setOrientation(LinearLayout.HORIZONTAL); &#13;
 &#13;
  // Create a LayoutParams object to be used by the LinearLayout// &#13;
 &#13;
    LayoutParams linearLayoutParam = new      LayoutParams(LayoutParams.MATCH_PARENT,      LayoutParams.MATCH_PARENT); &#13;
 &#13;
 &#13;
    // Set LinearLayout as the screen's root element// &#13;
    setContentView(linearLayout, linearLayoutParam); &#13;
  } &#13;
</pre></div><div class="section" title="Using both programmatic and XML layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Using both programmatic and XML layouts</h2></div></div></div><p>Sometimes the best solution maybe to use both programmatic and XML layouts. This approach helps you to keep some separation between your UI and application code by defining the bulk of your UI in XML, while also allowing you to create a more dynamic user interface by modifying the state of some onscreen elements at runtime.</p><p>For example, your app may contain a slideshow that's controlled by a single button. When the user taps the button, a new image appears. To create this effect, you can define the button in XML, and then add a new image programmatically whenever the user taps the button.</p><p>Since XML is the easiest and most efficient way of defining your UI, this chapter mainly focuses on creating and customizing views, ViewGroups, and layouts in XML. However, occasionally you may need to define parts of your UI programmatically, so I'll also include some snippets of Java along the way.</p></div></div>
<div class="section" title="Deep dive &#x2013; exploring layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Deep dive – exploring layouts</h1></div></div></div><p>Now that you have an idea of how views, ViewGroups, and Layouts come together to create a user interface, and how to create your user interface programmatically and in XML, it's time to look at each of Android's most common UI components in more detail. We'll start with the component that pretty much lays the foundation of any user interface: a layout container.</p><p>The Android platform supports a range of layouts, so your first task is deciding which layout best meets your design needs. If you're struggling to make this decision, keep in mind that you can nest layouts within one another to create your perfect layout container.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note5"/>Note</h3><p>Don't go overboard with the nesting as this can have a negative impact on your app's performance. If you find yourself nesting multiple layouts, then this could be a sign that you're using the wrong kind of layout!</p></div></div><p>Before you create any kind of layout, here are a few rules, regulations, and attributes that you need to get to grips with.</p><div class="section" title="Defining the size of your layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Defining the size of your layouts</h2></div></div></div><p>Whenever you create a layout, you need to tell the Android system how big this layout should be.</p><p>The XML attributes you use to define the size of your layouts are <code class="literal">android:layout_height</code> and <code class="literal">android:layout_width</code>. As their names suggest, these attributes set the height and width of your layouts respectively.</p><p>Both accept the following values:</p><div class="section" title="A supported keyword"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec3"/>A supported keyword</h3></div></div></div><p>Android screens come in lots of different sizes. One of the easiest ways of ensuring your user interface is flexible enough to cope with all these differently-sized screens is to set your layout's width and height to one of the following supported keywords:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">match_parent</code>: This makes the height or width expand to completely fill the available onscreen space</li><li class="listitem" style="list-style-type: disc"><code class="literal">wrap_content</code>: This sets the height or width to the minimum size required to fit the element's content and no larger</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>You can also use <code class="literal">match_parent</code> and <code class="literal">wrap_content</code> to set the size of other onscreen elements, including views and ViewGroups.</p></div></div></div><div class="section" title="A dimension value"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec4"/>A dimension value</h3></div></div></div><p>Alternatively, you can set the size of your layout using one of the units of measure supported by the Android system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Density-independent pixels (dp)</strong></span>: This is an abstract unit which is based on the screen's physical density. The dp unit is relative to 1 physical pixel on a 160 dots per inch screen. At runtime, Android automatically adjusts the number of pixels used to draw 1 dp by a factor that's appropriate for the current screen's dp. Using density-independent measurements is a straightforward solution to creating a UI that can adjust automatically across a range of screen sizes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>An absolute unit</strong></span>: Android supports a number of absolute units of measure (specifically pixels, millimeters, and inches), but you should avoid defining your layout using absolute sizes as this makes your UI very rigid, and can prevent it from resizing itself to suit a range of screens. Unless you have a <span class="emphasis"><em>very good reason</em></span> not to, stick to relative measurements, such as dp, <code class="literal">match_parent</code>, and <code class="literal">wrap_content</code>.</li></ul></div></div><div class="section" title="Setting the layout size programmatically"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec5"/>Setting the layout size programmatically</h3></div></div></div><p>You can also set the size of your layout programmatically by creating the <code class="literal">LayoutParams</code> object:</p><pre class="programlisting">LayoutParams linearLayoutParam = new LayoutParams &#13;
</pre><p>You can then set its width and height as follows:</p><pre class="programlisting">LayoutParams linearLayoutParam = new LayoutParams (LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); &#13;
</pre></div></div></div>
<div class="section" title="Exploring different layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Exploring different layouts</h1></div></div></div><p>Now that you know how to create layouts in XML and Java, and how to set their height and width, you can take a closer look at two of the most commonly used layouts: the straightforward and easy-to-use <code class="literal">LinearLayout</code> layout and the incredibly flexible <code class="literal">RelativeLayout</code> layout.</p><div class="section" title="Everything you need to know about LinearLayout"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Everything you need to know about LinearLayout</h2></div></div></div><p>
<code class="literal">LinearLayout</code> aligns all its children in a single horizontal or vertical row, stacking them one after the other.</p><p>You set the direction of your <code class="literal">LinearLayout</code> layout using either of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:orientation="horizontal."</code>: The views are placed next to each other in <span class="emphasis"><em>rows</em></span>. A horizontal <code class="literal">LinearLayout</code> layout is only ever one row high.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:orientation="vertical."</code>: The views are placed below each other in <span class="emphasis"><em>columns</em></span>. A vertical <code class="literal">LinearLayout</code> layout only ever has one child per row.</li></ul></div><p>Here's a simple <code class="literal">LinearLayout</code> layout with a horizontal orientation:</p><pre class="programlisting">&lt;LinearLayout  &#13;
 &#13;
  android:orientation="horizontal" &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent"&gt; &#13;
  &lt;Button &#13;
      android:id="@+id/okButton" &#13;
      android:text="Ok" &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" /&gt; &#13;
  &lt;Button &#13;
      android:id="@+id/cancelButton" &#13;
      android:text="Cancel" &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" /&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>Here's how this horizontal <code class="literal">LinearLayout</code> layout appears on an Android device:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_005.jpg" alt="Everything you need to know about LinearLayout"/></div><p>
</p><p>Here's the same <code class="literal">LinearLayout</code> based UI with the orientation set to <code class="literal">android:orientation="vertical"</code> instead:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_006.jpg" alt="Everything you need to know about LinearLayout"/></div><p>
</p></div><div class="section" title="Everything you need to know about RelativeLayout"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Everything you need to know about RelativeLayout</h2></div></div></div><p>
<code class="literal">RelativeLayout</code> is one of the most flexible layouts at your disposal, giving you the freedom to position every child element based on its relationship with any other child element, with its parent container.</p><p>For example, you have the flexibility to position <code class="literal">TextView</code> so that it aligns with the edge of the <code class="literal">RelativeLayout</code> container, and then you can position a <code class="literal">Button</code> 100 density-independent pixels above <code class="literal">TextView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip7"/>Tip</h3><p>
<span class="strong"><strong>Using RelativeLayout to optimize your UI</strong></span></p><p>
In addition to giving you control over where each element appears on the screen, <code class="literal">RelativeLayout</code> can improve your app's overall performance by reducing nesting. If you find yourself using several nested <code class="literal">LinearLayouts</code>, you maybe able to flatten your layout hierarchy by replacing them with a single <code class="literal">RelativeLayout</code>.</p></div></div><p>Since <code class="literal">RelativeLayout</code> is all about giving you the flexibility to position your UI elements wherever you want, it's no surprise that this layout supports a long list of attributes that let you position your UI elements relative to their parent container and relative to one another.</p><div class="section" title="Relative to the parent container"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec6"/>Relative to the parent container</h3></div></div></div><p>All the following attributes accept the <code class="literal">true</code> value; for example, <code class="literal">android:layout_alignParentTop="true"</code> and <code class="literal">android:layout_alignParentStart="true."</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentTop</code>: This aligns the top edge of a view with the top edge of its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentBottom</code>: This aligns the bottom edge of a view with the bottom edge of its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_centerInParent</code>: This centers a view horizontally and vertically within its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentRight</code>: This aligns the right edge of a view with the right edge of its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentLeft</code>: This aligns the left edge of a view with the left edge of its parent</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_centerHorizontal</code>: This centers a view horizontally within its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_centerVertical</code>: This centers a view vertically within its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentStart</code>: This aligns the start edge of a view with the start edge of its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignParentEnd</code>: This aligns the end edge of a view with the end edge of its parent</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignWithParentIfMissing</code>: If the view references an element that's missing, this attribute will align the view with the parent instead</li></ul></div><p>
</p><div class="mediaobject"><img src="graphics/image_02_007.jpg" alt="Relative to the parent container"/></div><p>
</p></div><div class="section" title="Relative to other elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec7"/>Relative to other elements</h3></div></div></div><p>You can also position UI elements relative to other onscreen elements; for example, you may want to position the <code class="literal">back_button</code> view to the left of <code class="literal">forward_button</code> and position <code class="literal">titleTextBox</code> above <code class="literal">subheadingTextBox</code>.</p><p>All the following attributes should reference the ID of the element you're using as your reference point (we'll look at IDs in more detail shortly, but essentially a view's ID is the value of its <code class="literal">android:id</code> element in your layout resource file, for example, the ID of <code class="literal">android:id ="@+id/viewName"</code> is <code class="literal">viewName</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_above</code>: This places a view above the specified element; for example, <code class="literal">android:layout_above="@+id/subheadingTextBox"</code> will place the UI element above <code class="literal">subheadingTextBox</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_below</code>: This places a view below the specified element</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_toLeftOf</code>: This places a view to the left of the specified element</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_toRightOf</code>: This places a view to the right of the specified element</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_toStartOf</code>: This aligns the end edge of a view with the start of the specified element</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_toEndOf</code>: This aligns the start edge of a view with the end edge of the specified element</li></ul></div><p>
</p><div class="mediaobject"><img src="graphics/image_02_008.jpg" alt="Relative to other elements"/></div><p>
</p></div><div class="section" title="Aligning with other elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec8"/>Aligning with other elements</h3></div></div></div><p>You can also position a UI element by specifying how it aligns with other on-screen elements. Again, the value for all the following attributes is the ID of the element you're using as your reference point:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignBottom</code>: This aligns the bottom of a view element with the bottom of the specified onscreen element. For example, <code class="literal">android:layout_alignBottom="@+id/back_button"</code> aligns the bottom of a UI element with the bottom of <code class="literal">back_button</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignLeft</code>: This aligns the left edge of a view with the left edge of the specified element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignRight</code>: This aligns the right edge of a view with the right edge of the specified element.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignTop</code>: This aligns the top edge of a view with the top edge of the specified element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignStart</code>: This aligns the start edge of a view with the start edge of the specified element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_alignBaseline</code>: This attribute is a bit different. <span class="strong"><strong>Baseline</strong></span> is a typography term for the invisible line that text sits on. So, this attribute aligns a view's baseline with the baseline of the specified element. For example, if you have two <code class="literal">TextViews</code>, you may want to use <code class="literal">alignBaseline</code> to create the impression that the text in both views is written on the same invisible line.</li></ul></div></div></div></div>
<div class="section" title="Creating views"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Creating views</h1></div></div></div><p>Views are the basic building blocks of a user interface.</p><p>Most of the time you'll create view objects by adding them to your Activity's corresponding layout resource file. You can either edit the XML code directly, or you may want to drag UI elements from your IDE's palette and drop them onto the UI preview:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_009.jpg" alt="Creating views"/></div><p>
</p><p>You also have the option of creating views programmatically. For example, if you wanted to instantiate a <code class="literal">TextView</code> programmatically, you would add <code class="literal">TextView</code> to your Activity's <code class="literal">onCreate()</code> method:</p><pre class="programlisting">   @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);  &#13;
       LinearLayout linearlayoutLayout =            (LinearLayout) findViewById(R.id.rootlayout);  &#13;
//Create a new TextView and assign it the ID txview// &#13;
       TextView txView = new TextView(this); &#13;
 &#13;
//Set the text programmatically// &#13;
 &#13;
       txView.setText("Hello World"); &#13;
 &#13;
//Add the txView TextView object to your layout// &#13;
 &#13;
       linearLayout.addView(txView); &#13;
   } &#13;
} &#13;
</pre><div class="section" title="Assigning the ID attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Assigning the ID attribute</h2></div></div></div><p>An ID gives you a way of identifying individual views within your layout. For example, if you create two buttons, you can distinguish between them by assigning them the IDs <code class="literal">yesButton</code> and <code class="literal">noButton</code>.</p><p>You assign an ID to a view using the <code class="literal">android:id</code> attribute:</p><pre class="programlisting">&lt;Button android:id="@+id/backButton" &#13;
</pre><p>You can then use the ID to reference this particular view:</p><pre class="programlisting">android:layout_below="@id/backButton" &#13;
</pre><p>You can also use the ID to locate a view programmatically using <code class="literal">findViewById(id)</code>:</p><pre class="programlisting">findViewById(R.id.myButton) &#13;
</pre><p>Once this method returns the desired view, you can interact with the view programmatically.</p></div><div class="section" title="Setting a view's size"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Setting a view's size</h2></div></div></div><p>In the same way you need to set the size of your layout container, you need to set the size of all the views you add to your layout resource file.</p><p>The good news is that you can use exactly the same attributes and values, which means you can add <code class="literal">android:layout_width</code> and <code class="literal">android:layout_height</code> to your layout resource file, and then choose from the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>wrap_content</strong></span>: This sets the view's height or width to the minimum size required to accommodate the view's content. For example, if you apply <code class="literal">wrap_content</code> to a button that contains a text label, the system will size the button so it's <span class="emphasis"><em>just</em></span> big enough to contain the button's text label.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>match_parent</strong></span>: This expands the view's height or width to fill all the available space.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Density-independent pixels (dp):</strong></span> When you assign a dp measurement, the Android system scales the view up or down based on the specific density of the user's screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>An absolute unit</strong></span>: Although this is not recommended, you can also use absolute units of measurements: pixels, millimeters, or inches.</li></ul></div></div><div class="section" title="Android gravity and layout gravity"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Android gravity and layout gravity</h2></div></div></div><p>The gravity attribute specifies how an object should be positioned along the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> axis inside its enclosing object. This may sound straightforward, but there's a catch: you'll encounter two different gravity attributes in Android. Although they look similar, they can actually yield very different results:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:gravity</code>: This positions the content that's inside a view, for example, the text inside a <code class="literal">TextView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_gravity</code>: This positions a child view inside its parent container, for example, a <code class="literal">TextView</code> inside a <code class="literal">LinearLayout</code></li></ul></div><p>Both accept a wide range of values, including several values that <span class="emphasis"><em>won't</em></span> change the size of the object you're applying the gravity attribute to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">top</code>: This positions the object at the top of its parent container. For example, <code class="literal">android:gravity="top"</code> will position the text at the top of <code class="literal">TextView</code>, while <code class="literal">android:layout_gravity="top"</code> will position <code class="literal">TextView</code> at the top of <code class="literal">LinearLayout</code>.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Left</code>: This positions the object to the left-hand side of its parent container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">center_vertical</code>: This positions the object in the vertical center of its parent container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Start</code>: This positions the object at the beginning of its parent container.</li></ul></div><p>Both <code class="literal">gravity</code> attributes also support several values that <span class="emphasis"><em>do</em></span> alter the object's size, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fill_vertical</code>: This expands the object vertically, so it completely fills its parent container. For example, <code class="literal">android:gravity="fill_vertical"</code> will expand an image vertically to fill its <code class="literal">ImageView</code> container, while <code class="literal">android:layout_gravity="fill_vertical"</code> will expand <code class="literal">ImageView</code> vertically to fill its <code class="literal">RelativeLayout</code> container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fill_horizontal</code>: This expands the object horizontally and vertically so that it completely fills its parent container.</li></ul></div><p>For the full list of supported values, see <a class="ulink" href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity">http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity</a>.</p><p>You assign gravity programmatically using the <code class="literal">setGravity</code> attribute, for example, <code class="literal">Gravity.CENTER_HORIZONTAL</code>. You could also use <code class="literal">setHorizontalGravity</code> and <code class="literal">setVerticalGravity</code>.</p></div><div class="section" title="Setting the background – working with color"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Setting the background – working with color</h2></div></div></div><p>When it comes to background, some views have a completely transparent background, such as <code class="literal">TextViews</code>, while others have a standard background color, for example buttons, which are grey by default.</p><p>If you're not a fan of a view's default background, you can always change it. Android gives you several options for adding a splash of color to your UI.</p><p>Firstly, the Android system does support a number of colors out of the box, so if you want to use any of the following hues, then you're in luck, because the Android system has already done all the hard work for you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">black</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">white</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_blue_bright</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_blue_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_blue_light</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_green_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_green_light</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_orange_light</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_orange_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_purple</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_red_dark</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">holo_red_light</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">darker_gray</code></li></ul></div><p>To apply any of these ready-made color resources to a view, add the <code class="literal">android:background</code> attribute, but set its value to <code class="literal">"@android:/color"</code> followed by the color of your choice:</p><pre class="programlisting">android:background="@android:color/holo_red_light"  &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note8"/>Note</h3><p>Android also supports values such as <code class="literal">primary_text_dark</code> and <code class="literal">widget_edittext_dark</code> for specific UI elements. You'll find the complete list of predefined colors in the official Android docs at <a class="ulink" href="http://developer.android.com/reference/android/R.color.html">
http://developer.android.com/reference/android/R.color.html</a>.</p></div></div><p>However, this list is pretty limited! Sooner or later Android's predefined colors just aren't going to cut it, and you'll want to create your own color resources, which means using hex codes.</p><p>If you have a particular shade in mind, you can usually find its hex code by performing a quick Google search, for example, by searching for <code class="literal">cyan hex code</code> or <code class="literal">light pink hex code</code>. Alternatively, you can go window shopping by browsing the Android style guide, which contains a wide range of colors and their corresponding hex codes. This is available at <a class="ulink" href="https://www.google.com/design/spec/style/color.html#color-color-palette">https://www.google.com/design/spec/style/color.html#color-color-palette</a>.</p><p>Once you have your hex code, you can take the quick and easy route of entering the code directly into your layout resource file:</p><pre class="programlisting">android:background="#0000ff" &#13;
</pre><p>This may <span class="emphasis"><em>seem</em></span> quick, but it might just end up costing you more time in the long run. Since consistency is a big part of providing a great user experience, chances are that you'll use the same colors multiple times throughout your application, and typing out the entire hex code every single time you want to use that color can really add up.</p><p>Although it may require a bit of initial effort, most of the time it makes sense to define your colors as color resources in your project's <code class="literal">res/values/colors.xml</code> file. You can then reference these color resources as many times as you want without having to type out entire hex codes.</p><p>If your project doesn't contain the <code class="literal">colors.xml</code> file, you can create one by right-clicking on your project's <code class="literal">values</code> folder and selecting <span class="strong"><strong>New</strong></span>, followed by <span class="strong"><strong>Values resource file</strong></span>. Give your file the name of <code class="literal">colors.xml</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_010.jpg" alt="Setting the background – working with color"/></div><p>
</p><p>Open the <code class="literal">colors.xml</code> file and define all the colors you want to use in your app using the following format:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
  &lt;color name="cyan"&gt;#00FFFF&lt;/color&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>You can then use this color resource anywhere in your app, including in the background of your views:</p><pre class="programlisting">android:background="@color/cyan" &#13;
</pre><p>You can also change the background of your entire UI by adding the <code class="literal">android:background</code> attribute to your layout container such as follows:</p><pre class="programlisting">&lt;LinearLayout  &#13;
  android:orientation="vertical" &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  android:background="@color/cyan" /&gt; &#13;
</pre><p>Alternatively, you can use images as the backdrop to your views, whether it's a simple textured background image or a high definition photo. We'll cover images in greater detail when we take a look at <code class="literal">ImageViews</code>, but as a quick overview, you just need to add the image to your project's <code class="literal">res/drawable</code> folder and then reference the image in your layout file:</p><pre class="programlisting">android:background="@drawable/imagename" &#13;
</pre><p>If you want to set your app's background programmatically, use the <code class="literal">setBackgroundResource</code> method.</p></div><div class="section" title="Assigning a weight value"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Assigning a weight value</h2></div></div></div><p>When you're positioning views inside <code class="literal">LinearLayout</code>, you can control how much space each view occupies onscreen by assigning it a weight value.</p><p>When you assign weight values to your views, any remaining space in the layout is assigned to your views in the proportion of their declared weight. For example, imagine your layout contains three buttons with different weight values:</p><pre class="programlisting">&lt;LinearLayout  &#13;
      android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  tools:context=".MainActivity"&gt; &#13;
 &#13;
  &lt;Button &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="A" &#13;
      android:id="@+id/button1" &#13;
      android:layout_weight="1"/&gt; &#13;
 &#13;
  &lt;Button &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="B" &#13;
      android:id="@+id/button2" &#13;
      android:layout_weight="1"/&gt; &#13;
 &#13;
  &lt;Button &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="C" &#13;
      android:id="@+id/button3" &#13;
      android:layout_weight="2"/&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>
<code class="literal">Button3</code> is declaring that it's more important than <code class="literal">Button1</code> and <code class="literal">Button2</code>, so it'll be assigned half of any remaining space, while <code class="literal">Button1</code> and <code class="literal">Button2</code> have to share the rest of the available space equally:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_011.jpg" alt="Assigning a weight value"/></div><p>
</p><p>Just be aware that other attributes may interact with your <code class="literal">layout_weight</code> values. For example, imagine your layout contains three <code class="literal">TextViews</code> and all of them are set to <code class="literal">android:layout_width="wrap content"</code>. In this scenario, the Android system calculates how wide each <code class="literal">TextView</code> needs to be in order to accommodate their text and <span class="emphasis"><em>only</em></span> then does it divide up the remaining space. So, if one <code class="literal">TextView</code> needs to accommodate much more text than the other two <code class="literal">TextView</code>, this will have an impact on your weight results.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note9"/>Note</h3><p>All views have a default weight of 0, unless you specify otherwise.</p></div></div></div></div>
<div class="section" title="Adding and customizing view objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Adding and customizing view objects</h1></div></div></div><p>The easiest way to add view objects to your layout is via the layout resource file in your project's <code class="literal">res/layout</code> folder, although you can also add views programmatically as and when required.</p><p>Over the next few sections, I'll show you how to create some of Android's most commonly used views, specifically <code class="literal">TextViews</code>, <code class="literal">EditText</code>, <code class="literal">ImageViews</code>, <code class="literal">Buttons</code>, and <code class="literal">ImageButtons</code>. Once you've created each view, I'll show you how to configure that view so it looks and functions <span class="emphasis"><em>exactly</em></span> as you want it to.</p><div class="section" title="TextView"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>TextView</h2></div></div></div><p>It may not be the most exciting part of your user interface, but the vast majority of Android apps feature some kind of text. You display text to your users via <code class="literal">TextView</code>.</p><p>To create <code class="literal">TextView</code>, add the <code class="literal">&lt;TextView&gt;</code> tag to your project's layout resource file, and then tell the <code class="literal">TextView</code> what text it should display either by:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adding the text directly to the layout</strong></span>: This is pretty straightforward. Just add the <code class="literal">android:text</code> attribute and your text to the <code class="literal">TextView</code> XML code, for example, <code class="literal">android:text="Hello world!"</code>.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Referencing a string resource</strong></span>: Most of the time, if your app needs to display text, then this text belongs in your project's resources and <span class="emphasis"><em>not</em></span> in your actual application code. This separation helps to keep your app's code clean and readable, and it also means that you can tweak and change your app's text at any point without ever having to touch your app's underlying code. To create a string resource, open your project's <code class="literal">res/values/strings.xml</code> file and add your text in the following format:</li></ul></div><pre class="programlisting">&lt;resources&gt; &#13;
    &lt;string name="helloWorld"&gt;Hello world!&lt;/string&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>You can then reference this string resource from your layout file:</p><pre class="programlisting">&lt;TextView &#13;
  android:layout_width="wrap_content" &#13;
  android:layout_height="wrap_content" &#13;
  android:text="@string/helloWorld" &#13;
  android:id="@+id/textView" /&gt; &#13;
</pre><p>This is all you need to know in order to display basic text, and sometimes this may be enough. However, text does have the potential to be a bit dry and boring! If you want to create more visually appealing text, you have several options.</p><div class="section" title="Brightening up your text"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec9"/>Brightening up your text</h3></div></div></div><p>You can use the <code class="literal">android:textColor</code> attribute to change the color of the text inside a <code class="literal">TextView</code>. To reference one of the default colors supported by the Android system, use the following:</p><pre class="programlisting">android:textColor="@android:color/"holo_green_dark" &#13;
</pre><p>If you're referencing a color that you defined yourself in your project's <code class="literal">res/values/colors.xml</code> file, the value is laid out slightly differently:</p><pre class="programlisting">android:textColor="@color/mycustomcolor" &#13;
</pre><p>If you want to set the color of your <code class="literal">TextView</code> programmatically, use the <code class="literal">setTextColor()</code> method.</p></div><div class="section" title="Setting the size of your text"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Setting the size of your text</h3></div></div></div><p>You can make your text larger or smaller using <code class="literal">android:textSize</code>.</p><p>Once again you need to remember that Android screens come in all sorts of different sizes, and your text needs to be easily readable regardless of the screen it's being displayed on.</p><p>To further complicate things, Android users can actually change the size of the font that's displayed on their device by opening their device's <span class="strong"><strong>Settings</strong></span>, tapping <span class="strong"><strong>Display,</strong></span> and selecting <span class="strong"><strong>Font Size</strong></span>. This is a really useful feature for people who have vision problems.</p><p>The easiest way of ensuring that your text is flexible enough to adapt to the user's font preferences and screen size is to use scale-independent pixels (<code class="literal">sp</code>) units:</p><pre class="programlisting">android:textSize="30sp" &#13;
</pre><p>Android also supports three relative font size styles that you may want to use in your application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TextAppearance.Small</code>, such as <code class="literal">style="@android:style/TextAppearance.Small."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextAppearance.Medium</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextAppearance.Large</code></li></ul></div></div><div class="section" title="Emphasizing your text"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Emphasizing your text</h3></div></div></div><p>You can add bold or italic emphasis to your text using the <code class="literal">android:textStyle</code> attribute. The possible values are normal, bold, and italic, or you can combine bold and italic by separating the two values with a pipe character (<code class="literal">android:textStyle="bold|italic"</code>):</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_012.jpg" alt="Emphasizing your text"/></div><p>
</p></div><div class="section" title="Setting the typeface"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Setting the typeface</h3></div></div></div><p>By default, Android applies the normal typeface to your text, but the system also supports <code class="literal">sans</code>, <code class="literal">monospace</code>, and <code class="literal">serif</code> typefaces, which you set using <code class="literal">android:typeface</code>:</p><pre class="programlisting">android:typeface="monospace" &#13;
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_02_013.jpg" alt="Setting the typeface"/></div><p>
</p><p>To set the typeface programmatically, you need to use the <code class="literal">setTypeFace</code> method.</p></div><div class="section" title="How many lines?"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>How many lines?</h3></div></div></div><p>By default, the content of your <code class="literal">TextView</code> will run across multiple lines depending on how much text it has to display. If you want more control over the span of your <code class="literal">TextView</code>, you have a few options, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:lines</code>: This makes <code class="literal">TextView</code> exactly <span class="emphasis"><em>X</em></span> number of lines tall, for example, <code class="literal">android:lines="2"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:minLines.</code> At a minimum, <code class="literal">TextView</code> will be this many lines tall</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:maxLines</code>: This limits the <code class="literal">TextView</code> to this many lines tall</li></ul></div></div></div></div>
<div class="section" title="EditText"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>EditText</h1></div></div></div><p>While <code class="literal">TextViews</code> are great for displaying text, if you want the user to be able to input text, you should use <code class="literal">EditText</code> instead.</p><p>One of the most common examples of <code class="literal">EditTexts</code> in action is a form that requests user data. In this example, each input field is a separate <code class="literal">EditText</code>:</p><pre class="programlisting">&lt;LinearLayout  &#13;
 &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &#13;
  android:orientation="vertical" &#13;
tools:context=".MainActivity"&gt; &#13;
 &#13;
  &lt;TextView &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="Please complete this form:" &#13;
      android:textSize="20sp" &#13;
      android:id="@+id/TextView" /&gt; &#13;
 &#13;
  &lt;EditText &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:inputType="textPersonName" &#13;
      android:hint="Name" &#13;
      android:id="@+id/editText" /&gt; &#13;
 &#13;
  &lt;EditText &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:inputType="textEmailAddress" &#13;
      android:hint="Email address" &#13;
      android:id="@+id/editText2" /&gt; &#13;
 &#13;
  &lt;EditText &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:inputType="textPostalAddress" &#13;
      android:hint="Postal address" &#13;
      android:id="@+id/editText3" /&gt; &#13;
 &#13;
  &lt;EditText &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:inputType="textPassword" &#13;
      android:hint="Password" &#13;
      android:id="@+id/editText4" &#13;
      android:layout_gravity="center_horizontal" /&gt; &#13;
 &#13;
  &lt;Button &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="Sign up" &#13;
      android:id="@+id/button" /&gt; &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>Here's how this simple form looks on the user's device:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_014.jpg" alt="EditText"/></div><p>
</p><p>Since the <code class="literal">EditText</code> class is derived from the <code class="literal">TextView</code> class, many of the <code class="literal">TextView</code> attributes are also applicable to <code class="literal">EditText</code>, including <code class="literal">textColor</code>, <code class="literal">textSize</code>, <code class="literal">textStyle</code>, and <code class="literal">typeface</code>. However, <code class="literal">EditText</code> also supports a range of XML attributes that are specific to the <code class="literal">EditText</code> class.</p><div class="section" title="Controlling keyboard behavior - setting the inputType"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Controlling keyboard behavior - setting the inputType</h2></div></div></div><p>By default, when the user taps the <code class="literal">EditText</code> field, the standard keyboard appears and they can enter whatever characters they like. However, you may want to restrict the kind of data users can enter into your <code class="literal">EditText</code> fields using the <code class="literal">android:inputType attribute</code>.</p><p>This restriction prevents the user from entering invalid data, but some <code class="literal">inputType</code> values also prompt the Android system to optimize the virtual keyboard for a particular kind of content. For example, if you specify that the <code class="literal">EditText</code>
<code class="literal">inputType</code> value is a phone number (<code class="literal">android:inputType="phone"</code>) the Android system will display the numerical keyboard, which makes it easier for the user to input the required data.</p><p>Some <code class="literal">inputType</code> values also prompt the keyboard into other useful behavior; for example, if you set <code class="literal">inputType</code> to <code class="literal">textCapWords</code>, the keyboard will capitalize every new word automatically. This is handy when you're asking the user to enter data that should always be capitalized, such as their name or address.</p><p>Here are the different <code class="literal">inputType</code> values you can use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">text</code>: This displays the standard text keyboard</li><li class="listitem" style="list-style-type: disc"><code class="literal">textEmailAddress</code>: This displays the standard text keyboard with the addition of the <code class="literal">@</code> character</li><li class="listitem" style="list-style-type: disc"><code class="literal">textUri</code>: This displays the standard text keyboard with the addition of the <code class="literal">/</code> character</li><li class="listitem" style="list-style-type: disc"><code class="literal">number</code>: This displays the basic numerical keyboard</li><li class="listitem" style="list-style-type: disc"><code class="literal">phone</code>: This displays the phone-style keyboard</li></ul></div><p>All the following values display the standard text keyboard, but modify other keyboard behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">textCapSentences</code>: This automatically capitalizes the first letter of every new sentence.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textCapWords</code>: This automatically capitalizes every word.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textAutoCorrect</code>: This automatically corrects commonly misspelled words.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textPassword</code>: This masks the user's password by transforming every inputted character into a dot. This is the behavior you typically encounter when entering passwords on your Android device. Another way of creating this masking effect is via the XML attribute <code class="literal">android:password="true."</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textMultiLine</code>: By default, the <code class="literal">EditText</code> field is constrained to a single line. This attribute allows the user to enter multiple lines of text.</li></ul></div><p>You can also combine multiple values using the pipe character. For example, if you're asking the user to create a password, you could automatically capitalize every new word while also masking their input:</p><pre class="programlisting">android:inputType="textCapWords| textPassword" &#13;
</pre><p>To specify keyboard behavior programmatically, use the <code class="literal">setRawInputType</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>While we're on the subject of controlling user input, you can restrict what numbers the user can enter into an <code class="literal">EditText</code> using <code class="literal">android:digits</code> (<code class="literal">android:digits="12345."</code>).</p></div></div></div><div class="section" title="android:imeOptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>android:imeOptions</h2></div></div></div><p>Once the user has entered information into the <code class="literal">EditText</code> field, they'll usually confirm their input by tapping the action key that appears in place of the keyboard's usual carriage return key.</p><p>If you <span class="emphasis"><em>don't</em></span> specify what action key the system should display, the Android system defaults to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">actionNext</code>: If there's at least one focusable field to move on to, the system displays the <span class="strong"><strong>Next</strong></span> action key.</li><li class="listitem" style="list-style-type: disc"><code class="literal">actionDone</code>: If there's no subsequent focusable fields, the system displays the <span class="strong"><strong>Done</strong></span> key. In our <code class="literal">form</code> example, the <span class="strong"><strong>Done</strong></span> key would appear once the user has completed the final <code class="literal">EditText</code> field.</li></ul></div><p>Sometimes, you may want to override this default behavior and specify which action key the keyboard should display. You can do this using the <code class="literal">android:imeOptions</code> attribute and one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">actionGo</code>: This displays the <span class="strong"><strong>Go</strong></span> key (<code class="literal">android:imeOptions="actionGo")</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">actionNext</code>: This displays the <span class="strong"><strong>Nex</strong></span>t key</li><li class="listitem" style="list-style-type: disc"><code class="literal">actionDone</code>: This displays the <span class="strong"><strong>Done</strong></span> key</li><li class="listitem" style="list-style-type: disc"><code class="literal">actionSearch</code>: This displays the <span class="strong"><strong>Search</strong></span> key</li><li class="listitem" style="list-style-type: disc"><code class="literal">actionSend</code>: This displays the <span class="strong"><strong>Send</strong></span> key</li></ul></div></div><div class="section" title="Giving the user a hint"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Giving the user a hint</h2></div></div></div><p>Even though <code class="literal">EditTexts</code> are designed to collect user input, you may want to prompt the user for a specific input by displaying temporary, greyed-out text in your <code class="literal">EditText</code> fields. These hints are useful when it isn't immediately obvious what information the user is supposed to enter.</p><p>You display hints using the <code class="literal">android:hint</code> attribute:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enter the hint into your layout resource file directly (<code class="literal">android:hint="Please enter your password"</code>)</li><li class="listitem" style="list-style-type: disc">Create and reference a string resource (<code class="literal">android:hint="@string/messageHint."</code>)</li></ul></div></div></div>
<div class="section" title="ImageView"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>ImageView</h1></div></div></div><p>Images are a handy way of conveying information to your users without forcing them to read lots of on-screen text. Although you can add images to lots of different areas within your app, (such as your layout's background and the background of onscreen elements, such as buttons), the Android SDK provides a dedicated view for displaying images, called <code class="literal">ImageView</code>.</p><p>We've already discussed how you can use density-independent and other relative units of measure to create a user interface that displays correctly across a range of different screens. However, ensuring your images look crisp and clear across a range of different screen sizes isn't quite so straightforward.</p><p>This makes <code class="literal">ImageView</code> one of the more complicated views, but since images are such an integral part of most Android UIs, it's well worth taking the time to properly master Android's <code class="literal">ImageView</code>.</p><p>In this section, I'll show you how to add <span class="strong"><strong>drawables</strong></span> to your UI and the steps you should take to ensure these images display properly across the full range of possible screen sizes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>A drawable just means "something that can be drawn on the screen," and is often used to describe your app's graphical content.</p></div></div><div class="section" title="Supporting multiple screens"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Supporting multiple screens</h2></div></div></div><p>Let's get the tricky stuff out of the way first: how to create images that display correctly across a wide range of different screens.</p><p>Although the Android system scales your content automatically to fit the current screen configuration, you shouldn't rely on the system to do all the hard work for you, <span class="emphasis"><em>especially</em></span> when it comes to <code class="literal">ImageViews</code> as this can result in blurry or pixelated images.</p><p>To provide the best possible user experience, you'll need to provide alternate versions of all the images you use in your app. These versions should be optimized for different screen densities.</p><p>The good news is that you don't have to provide images for <span class="emphasis"><em>every</em></span> screen density imaginable, as the Android system groups all possible screen densities into generalized density spans. As long as you provide a version for each density span, the Android system will choose the version that's the best match for the current screen configuration.</p><p>Android supports five main generalized screen densities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Low</strong></span>: <code class="literal">ldpi 120dpi</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Medium</strong></span>: <code class="literal">mdpi 60dpi</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>High</strong></span>: <code class="literal">hdpi 240dpi</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Extra-high</strong></span>: <code class="literal">xhdpi 320dpi</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Extra-extra-high</strong></span>: <code class="literal">xxhdpi 480dpi</code></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Android actually supports a sixth screen density: extra-extra-extra-high, also known as <code class="literal">xxxhdpi</code>. This <code class="literal">640dpi</code> density span is a bit different from the others as it <span class="emphasis"><em>only</em></span> applies to your application's launcher icon. Some devices, such as tablets, may display extra-large app icons in their launcher. To make sure your app's icon doesn't end up looking fuzzy on a large screen with an <code class="literal">xxxhdpi</code> display, you should supply an extra-extra-extra high density version of your app's icon. You don't need to provide <code class="literal">xxxhdi</code> versions of any other UI elements.</p></div></div><div class="section" title="Supporting different screen densities"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Supporting different screen densities</h3></div></div></div><p>So, how do you let Android know which image is optimized for <code class="literal">hdpi</code> displays, and which image is optimized for <code class="literal">xhdpi</code> displays? The answer is to create directories that are tagged with the <code class="literal">ldpi</code>, <code class="literal">mdpi</code>,  <code class="literal">hdpi</code>,  <code class="literal">xhdpi</code>,  <code class="literal">xxhdpi</code>, and  <code class="literal">xxxhdpi</code> qualifiers. Android will recognize that these directories contain resources that target a specific screen density, and then select an image from the appropriate directory based on the current screen configuration.</p><p>When you create an Android project in Eclipse or Android Studio, the project typically contains the default <code class="literal">res/drawable</code> directory only, so you'll need to create the following directories manually:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">drawable-ldpi</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable-mdpi</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable-hdpi</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable-xhdpi</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable- xxhdp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">drawable-xxxhdpi</code></li></ul></div><p>Remember, this directory should contain the extra-extra-extra-high density version of your app's launcher icon only.</p><p>To create these density-specific directories, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on your project's <code class="literal">res</code> folder and select <span class="strong"><strong>New</strong></span>, followed by <span class="strong"><strong>Android resource directory</strong></span>.</li><li class="listitem">In the window that appears, open the <span class="strong"><strong>Resource type</strong></span> dropdown and select <span class="strong"><strong>Drawable</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Available qualifiers</strong></span> section, add <span class="strong"><strong>Density</strong></span> as <span class="strong"><strong>Chosen qualifier</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>Density</strong></span> dropdown and select the desired density from the list, for example, <span class="strong"><strong>Low Density</strong></span> if you're creating the <code class="literal">drawable-ldpi</code> directory, or <span class="strong"><strong>XXX-High density</strong></span> if you're creating a <code class="literal">drawable-xxxhdpi</code> directory. You'll notice that when you select the density, <span class="strong"><strong>Directory name</strong></span> gets updated automatically:<p>
</p><div class="mediaobject"><img src="graphics/image_02_015.jpg" alt="Supporting different screen densities"/></div><p>
</p></li><li class="listitem">When you're happy with the information you've entered, click <span class="strong"><strong>OK</strong></span>. Your IDE will then create the new directory.</li><li class="listitem">Repeat! You'll typically want to create a directory for each of the generalized screen densities.</li></ol></div><p>If you're working with a project in Android Studio, sometimes you may create all your density-specific directories and then realize that none of them are appearing in Android Studio's <span class="strong"><strong>Project</strong></span> view. If this happens, the problem may be that you have the <span class="strong"><strong>Android</strong></span> view selected instead of <span class="strong"><strong>Project</strong></span> view. To switch views, click on the <span class="strong"><strong>Android</strong></span> label in Android Studio's <span class="strong"><strong>Project </strong></span>view, and then select <span class="strong"><strong>Project</strong></span> from the drop-down menu:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_016.jpg" alt="Supporting different screen densities"/></div><p>
</p><p>You'll notice your project structure has changed. Open the <code class="literal">app/src/main/res</code> folder, and you will see all the density-specific directories you created earlier.</p><div class="section" title="Creating density-specific images"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec0"/>Creating density-specific images</h4></div></div></div><p>Now that you've updated your project structure, it's time to actually create those optimized images and add them to your project.</p><p>Android supports several different image types, but you'll typically use one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bitmaps</strong></span>: Android supports bitmap files in three formats: <code class="literal">.png</code> (preferred), <code class="literal">.jpg</code> (acceptable), or if you really<span class="emphasis"><em> must</em></span>, <code class="literal">.gif</code> (discouraged).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Nine-patch file</strong></span>: This is a <code class="literal">.png</code> file with a difference! Nine-patch files allow you to define stretchable regions that help your image resize more smoothly. We'll explore nine-patch images in more detail in the later chapters.</li></ul></div><p>The key to creating alternate bitmaps and nine-patch files is to adhere to a 3:4:6:8:12:16 scaling ratio. For example, if you have an image that's 68 x 68 pixels and targets medium-density screens, you'd need to create the following alternatives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>LDPI</strong></span>: 51 x 51 pixels (0.75% of the original size)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MDPI</strong></span>: 68 x 68 pixels (original size)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HDPI</strong></span>: 102 x 102 pixels (150% of the original size)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XHDPI</strong></span>: 136 x 136 (200% of the original size)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XXHDPI</strong></span>: 204 x 204 (300% of the original size)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XXXHDPI</strong></span>: 272 x 272 (400% of the original size)</li></ul></div><p>When you're creating your alternate images, you <span class="emphasis"><em>must</em></span> use the same filename for each version of the image. This is essential if the Android system is going to recognize these files as alternate versions of the same image.</p><p>The final step is placing each file inside the appropriate directory.</p></div></div></div><div class="section" title="Adding ImageView"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Adding ImageView</h2></div></div></div><p>Creating the correct <code class="literal">drawable</code> directory structure and providing multiple versions of the same image may feel like a lot of work, but once you've done all this groundwork, displaying <code class="literal">drawable</code> content in <code class="literal">ImageView</code> is a fairly straightforward task.</p><p>Most of the time, you'll create your <code class="literal">ImageView</code> by adding an <code class="literal">&lt;ImageView&gt;</code> element to your Activity's layout resource file:</p><pre class="programlisting">&lt;ImageView &#13;
     android:id="@+id/imageView1"        android:layout_width="wrap_content"        android:layout_height="wrap_content" &#13;
     android:src="@drawable/myImage" &#13;
/ &gt; &#13;
</pre><p>Note the <code class="literal">android:src</code> attribute. This is how you tell your <code class="literal">ImageView</code> what <code class="literal">drawable</code> to display. Assuming you've provided several versions of the <code class="literal">myImage</code> file, the Android system checks each <code class="literal">drawable</code> directory for the most suitable version, and then it displays this image.</p><p>If you'd prefer to set your <code class="literal">ImageView</code> content programmatically, you can use the <code class="literal">setImageResource()</code> method instead.</p></div></div>
<div class="section" title="Buttons and ImageButtons"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Buttons and ImageButtons</h1></div></div></div><p>
<code class="literal">Buttons</code> (and by extension, <code class="literal">ImageButtons)</code> are UI components that react to the user tapping the screen. Whenever you add a button to your UI, it should be immediately clear to the user what this button will do when they touch it.</p><p>While you <span class="emphasis"><em>could</em></span> inform the user about a button's purpose with an accompanying <code class="literal">TextView</code> (something along the lines of <span class="emphasis"><em>tap the button below to move onto the next screen</em></span>) this is wordy and inefficient. Most of the time, you'll want to communicate a button's purpose by adding a label to this button.</p><p>Android provides you with several labeling options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A text label, for example <span class="strong"><strong>Next</strong></span>, <span class="strong"><strong>Submit</strong></span>, or <span class="strong"><strong>Cancel</strong></span>.</li><li class="listitem" style="list-style-type: disc">An image icon, such as a checkmark or a cross icon.</li><li class="listitem" style="list-style-type: disc">Both! If the button represents an unusual, unexpected, or complicated action, you may want to clear up any potential confusion by labeling the button with both text and an image:</li></ul></div><p>
</p><div class="mediaobject"><img src="graphics/image_02_017.jpg" alt="Buttons and ImageButtons"/></div><p>
</p><p>Depending on whether you want your button to display text, an icon, or both, you can add a button to your layout resource file in one of three ways.</p><div class="section" title="Creating buttons with text labels"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Creating buttons with text labels</h2></div></div></div><p>To create a basic button with a text label, insert a <code class="literal">&lt;Button&gt;</code> element into your layout resource file:</p><pre class="programlisting">&lt;Button &#13;
android:layout_width="wrap_content" &#13;
android:layout_height="wrap_content" &#13;
android:text="@string/button_text" /&gt; &#13;
</pre><p>You set the button's text label using the <code class="literal">android:text</code> attribute. As with <code class="literal">TextViews</code>, you can either insert the text into your layout directly (<code class="literal">android:text="Submit"</code>) or you can create a string resource in your project's <code class="literal">res/values/strings.xml</code> file, and then reference the string resource (<code class="literal">android:text="@string/submitText"</code>).</p><p>To set the button's text programmatically, use <code class="literal">setText</code>:</p><pre class="programlisting">      button.setText("Submit!"); &#13;
</pre></div><div class="section" title="Creating buttons with image labels"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Creating buttons with image labels</h2></div></div></div><p>As the name suggests, <code class="literal">ImageButton </code>is a button with an image label.</p><p>To insert <code class="literal">ImageButton</code> into your UI, you need to add the <code class="literal">&lt;ImageButton&gt;</code> tag to your layout resource file:</p><pre class="programlisting">&lt;ImageButton &#13;
  android:layout_width="wrap_content" &#13;
  android:layout_height="wrap_content" &#13;
  android:id="@+id/imageButton" &#13;
  android:src="@android:drawable/send" /&gt; &#13;
</pre><p>Recognize the <code class="literal">android:src</code> attribute? It's referencing a <code class="literal">drawable</code> resource, in exactly the same way an <code class="literal">ImageView</code> references a <code class="literal">drawable</code> reasource.</p></div><div class="section" title="Creating buttons with text and image labels"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Creating buttons with text and image labels</h2></div></div></div><p>If you want to leave the user in no doubt about what'll happen when they touch a button, you can label that button with both text and an image. This involves utilizing the <code class="literal">Button</code> class with the addition of <code class="literal">android:drawableLeft</code>:</p><pre class="programlisting">&lt;Button &#13;
  android:layout_width="wrap_content" &#13;
  android:layout_height="wrap_content" &#13;
  android:id="@+id/imageButton3" &#13;
  android:text="Send" &#13;
  android:drawableLeft="@android:drawable/send" /&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p><span class="strong"><strong>Change your button's background</strong></span></p><p>If you feel like these three options aren't enough, you can also change a button's background using <code class="literal">android:background</code> and then referencing a color value or an image.</p></div></div></div></div>
<div class="section" title="State list resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>State list resources</h1></div></div></div><p>Your typical button has three states:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Default</code>: This button is neither pressed nor focused</li><li class="listitem" style="list-style-type: disc"><code class="literal">Pressed</code>: This button is in a pressed state</li><li class="listitem" style="list-style-type: disc"><code class="literal">Focused</code>: This button is currently in focus</li></ul></div><p>All the button attributes we've discussed so far (text labels, image labels, and backgrounds) apply to a button element regardless of its current state. But sometimes you'll want your button to give the user visual clues about its current state. For example, when the user taps a button, you may want it to briefly display a darker color while it's in its pressed state, so users know that their devices have successfully registered the touch event.</p><p>If you want your button to react to its current state, you need to create a state list resource, which is an XML file that defines three different images or colors to use for each of the button's states.</p><p>To create this state list resource, do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create three drawables to use as your button's background. These drawables represent each of the button's states.</li><li class="listitem">Give each <code class="literal">drawable</code> a name that reflects the state it represents, for example, <code class="literal">button_pressed</code>, or <code class="literal">button_default</code>.</li><li class="listitem">Add these drawables to the appropriate <code class="literal">res/drawable</code> directory.</li><li class="listitem">Create a new XML file in your project's <code class="literal">res/drawable</code> directory, by right-clicking on the <code class="literal">drawable</code> directory and selecting <span class="strong"><strong>New</strong></span>, followed by <span class="strong"><strong>Drawable resource file</strong></span>. Give the XML file a descriptive name, such as <code class="literal">button_states</code>, and then click on <span class="strong"><strong>OK</strong></span>.</li></ol></div><p>Open your new <code class="literal">drawable</code> resource file and define all the drawables you want to use for each state by adding them as separate <code class="literal">&lt;list&gt;</code> elements inside a single <code class="literal">&lt;selector&gt;</code> element:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;selector &gt; &#13;
&lt;item android:drawable="@drawable/button_pressed" &#13;
        android:state_pressed="true" /&gt; &#13;
   &lt;item android:drawable="@drawable/button_focused" &#13;
        android:state_focused="true" /&gt; &#13;
   &lt;item android:drawable="@drawable/button_default" /&gt; &#13;
&lt;/selector&gt; &#13;
</pre><p>In the preceding code, we're defining which <code class="literal">drawable</code> the button should use when it's in each state:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When <code class="literal">pressed = true</code>, the button should use the <code class="literal">button_pressed</code> drawable.</li><li class="listitem" style="list-style-type: disc">When <code class="literal">focused = true</code>, the button should use the <code class="literal">button_focused</code> drawable.</li><li class="listitem" style="list-style-type: disc">If the button isn't pressed or focused, it should use the <code class="literal">button_default</code> drawable.</li></ul></div><p>The order of the <code class="literal">&lt;item&gt;</code> elements in your state list resource is important, as when you reference this state list, the system moves through the <code class="literal">&lt;item&gt;</code> elements in order and uses the first <code class="literal">&lt;item&gt;</code> element that's applicable to the button's current state. Since the default state is <span class="emphasis"><em>always</em></span> applicable, you must always place the default <code class="literal">drawable</code> at the end of the list, to ensure it's only used if the system has checked and discarded <code class="literal">android:state_pressed</code> and <code class="literal">android:state_focused</code> first.</p><p>To apply a state list resource to a button, you need to reference it as a single <code class="literal">drawable</code> in your Activity's layout resource file:</p><pre class="programlisting">&lt;Button &#13;
   android:id="@+id/button_send" &#13;
   android:layout_width="wrap_content" &#13;
   android:layout_height="wrap_content" &#13;
   android:text="@string/button_send" &#13;
   android:background="@drawable/button_custom" /&gt; &#13;
</pre><p>You can also create state list resources that use colors instead of images. These kinds of state lists are known as <span class="strong"><strong>color state list resources</strong></span>. You use the same <code class="literal">&lt;selector&gt;</code> and <code class="literal">&lt;item&gt;</code> elements; the only difference is that each <code class="literal">&lt;item&gt;</code> element references a color rather than a <code class="literal">drawable</code>:</p><pre class="programlisting">&lt;item android:drawable="@android:color/holo_red_light"  &#13;
        android:state_pressed="true" /&gt; &#13;
</pre><p>Or</p><pre class="programlisting">&lt;item android:drawable=""#0000ff"  &#13;
        android:state_pressed="true" /&gt; &#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, we covered some of the most commonly used views and layouts, and we looked at all the different ways to customize them to suit our specific design needs.</p><p>Even though there are views and layouts we haven't covered yet, many of the attributes we've explored in this chapter are applicable to the views and layouts that we'll encounter in later chapters, for example, <code class="literal">layout_width</code>, <code class="literal">android:src</code>, <code class="literal">android:id</code> and the relative units of measure.</p><p>In the next chapter, we'll expand on using resources such as strings, nine-patch images, colors, and state lists, and also take a look at some new resources, including arrays and dimensions.</p><p>Finally, you'll learn all about an important aspect of UI design that we haven't touched on yet: <span class="emphasis"><em>fragments</em></span>.</p></div></body></html>