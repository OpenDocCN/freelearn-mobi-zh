<html><head></head><body>
        

                            
                    <h1 class="header-title">Expressive Functions and Adjustable Interfaces</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Declaring adjustable functions with default parameters</li>
<li>Declaring interfaces containing default implementations</li>
<li>Extending functionalities of classes</li>
<li>Destructuring types</li>
<li>Returning multiple data</li>
<li>Inlining parameters of closure type</li>
<li>Infix notations for functions</li>
<li>Smart types checking with generic reified parameters</li>
<li>Overloading operators</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter will focus on exploring a number of Kotlin features that can help to write functions and interfaces that are robust, flexible, and clean. After reading the following recipes, you will understand the language-specific support and approach for boilerplate code reduction and runtime performance improvements. You will also understand the way functions of the standard library are implemented under the hood and how to work with them effectively.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring adjustable functions with default parameters</h1>
                
            
            
                
<p>When creating new functions, we often need to allow some of their parameters to be optional. This forces us to use method overloading to create multiple function declarations with the same name but different sets of arguments related to different use cases and scenarios. Usually, under the hood, each variant of the function is calling the base function with the default implementation. Let's consider a simple example of a function that calculates a displacement of an object moving with a constant acceleration rate:</p>
<pre>fun calculateDisplacement(initialSpeed: Float, <br/>                          acceleration: Float, <br/>                          duration: Long): Double =<br/>    initialSpeed * duration + 0.5 * acceleration * duration * duration</pre>
<p>We might also need to provide a displacement calculation for the scenario where the initial speed of the object is always equal to zero. In such a case, we would end up with overloading the basic function in the following manner:</p>
<pre>fun calculateDisplacement(acceleration: Float, duration: Long): Double = calculateDisplacement(0f, acceleration, duration)</pre>
<p>However, Kotlin allows you to reduce multiple declarations and to handle a number of different use cases with a single function having optional parameters. In this recipe, we are going to design an adjustable version of the <kbd>calculateDisplacement()</kbd><em> </em>function with an optional <kbd>initialSpeed: Float</kbd><em> </em>parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's declare the basic implementation for the function:</li>
</ol>
<pre style="padding-left: 60px">fun calculateDisplacement(initialSpeed: Float, <br/>                          acceleration: Float, <br/>                          duration: Long): Double =<br/>    initialSpeed * duration + 0.5 * acceleration * duration * <br/>    duration</pre>
<ol start="2">
<li>Let's declare a default value for the <kbd>initialSpeed</kbd> parameter<em>:</em></li>
</ol>
<pre style="padding-left: 60px">fun calculateDisplacement(initialSpeed: Float = 0f, <br/>                          acceleration: Float, </pre>
<pre style="padding-left: 60px">                          duration: Long): Double =<br/>    initialSpeed * duration + 0.5 * acceleration * duration * <br/>    duration</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We've declared a default value for the <kbd>initialSpeed</kbd><em> </em>parameter, equal to <kbd>0</kbd>. Once we have a default value assigned, the <kbd>initialSpeed</kbd><em> </em>parameter becomes an optional one. We can now omit it while invoking the function, as shown in the following example:</p>
<pre>val displacement = calculateDisplacement(<strong>acceleration</strong> = 9.81f, <strong>duration</strong> = 1000)</pre>
<p>Note that, if we are omitting some of the parameters and using their default values, we have to specify the values of the other parameters together with their names explicitly. This allows the compiler to map the values to the specific parameters. Of course, we are able to override the default value using the standard way:</p>
<pre>val displacement = calculateDisplacement(10f, 9.81f, 1000)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Kotlin makes it possible to declare interfaces containing default function implementations. You can learn more about this feature in the <em>Declaring interfaces containing default implementations</em> recipe.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring interfaces containing default implementations</h1>
                
            
            
                
<p>Kotlin makes the interface a powerful language element by offering the possibility to declare default implementations for its functions and to define default values of its properties. Those features bring the interface to a whole new level, allowing you to use it for more advanced applications than simple contract declarations.</p>
<p>In this recipe, we are going to define a reusable interface responsible for validating email address values entered by a user into the input field in an abstract registration form. The interface will provide two functions. The first one is responsible for parsing the email address and deciding if the given value is a valid email address, and the second one responsible for extracting a user's login from the email text entered into the form.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The declaration of an interface with a default function implementation is easy. Instead of declaring the function header, we need to include its body too:</p>
<pre>interface MyInterface {<br/>    fun foo() {<br/>        // default function body<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a new interface called <kbd>EmailValidator</kbd>:</li>
</ol>
<pre style="padding-left: 60px">interface EmailValidator {}</pre>
<ol start="2">
<li>Add a string property responsible for holding the current text input:</li>
</ol>
<pre style="padding-left: 60px">interface EmailValidator {<br/>    var input: String<br/>}</pre>
<ol start="3">
<li>Add the <kbd>isEmailValid()</kbd> function to the interface:</li>
</ol>
<pre style="padding-left: 60px">interface EmailValidator {<br/>    var input: String<br/>    fun isEmailValid(): Boolean = input.contains("@")<br/>}</pre>
<ol start="4">
<li>Add the <kbd>getUserLogin()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">interface EmailValidator {<br/>    var input: String<br/><br/>    fun isEmailValid(): Boolean = input.contains("@")<br/><br/>    fun getUserLogin(): String =<br/>        if (isEmailValid()) {<br/>            input.substringBefore("@")<br/>        } else {<br/>            ""<br/>        }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Now, let's give it a try and take a look at how we can use the <kbd>EmailValidator</kbd> interface in action. Let's assume we have a <kbd>RegistrationForm</kbd> class containing a hook method that is invoked every time the input text is modified:</p>
<pre>class RegistrationForm() {<br/>    fun onInputTextUpdated(text: String) {<br/>        // do some actions on text changed<br/>    }<br/>}</pre>
<p>To make use of our <kbd>EmailValidator</kbd> interface, we need to declare a class that is implementing it. We can modify the <kbd>RegistrationForm</kbd> class to implement the <kbd>EmailValidator</kbd> interface:</p>
<pre>class RegistrationForm(override var input: String = ""): <strong>EmailValidator</strong> {<br/>    fun onInputTextUpdated(newText: String) {<br/>        this.input = newText<br/><br/>        if (!isEmailValid()) {<br/>            print("Wait! You've entered wrong email...")<br/>        } else {<br/>            print("Email is correct, thanks: ${getUserLogin()}!")<br/>        }<br/>    }<br/>}</pre>
<p>Every time the <kbd>onInputUpdated()</kbd> function is invoked, we are updating the <kbd>input: String</kbd> property declared in the <kbd>EmailValidator</kbd> interface. Once it is up to date, we are using the <kbd>EmailValidator</kbd> interface functions <kbd>isEmailValid()</kbd> and <kbd>getUserLogin()</kbd> values. Extracting the function implementations to the interface makes it possible to reuse them and integrate them easily in a number of classes. The only part that needs an actual implementation is the <kbd>input</kbd> property of the <kbd>EmailValidator</kbd> interface, which holds the current state of the text inserted by the user. The smooth way of integrating the <kbd>EmailValidator</kbd> interface makes it great when it comes to reusability and versatility of the application in different scenarios.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's important to keep in mind that, although we can define a default function implementation in the interface, we are not able to instantiate default values for interface properties. Unlike the class properties, properties of an interface are abstract. They don't have backing fields that could hold a current value (state). If we declare a property inside an interface, we need to implement it in the class or object that implements this interface. This is the main difference between interfaces and abstract classes. Abstract classes can have constructors and can store properties along with their implementations.</p>
<p>As with Java, we can't extend multiple classes; however, we can implement multiple interfaces. When we have a class implementing multiple interfaces containing default implementations, we are at risk of dealing with conflicts caused by functions having the same signatures:</p>
<pre>interface A {<br/>    fun foo() {<br/>        // some operations <br/>    }<br/>}<br/><br/>interface B {<br/>    fun foo() {<br/>        // other operations<br/>    }<br/>}</pre>
<p>In this case, we need to override the <kbd>foo()</kbd> function explicitly to resolve the conflict:</p>
<pre>class MyClass: A, B {<br/>    override fun foo() {<br/>        print("I'm the first one here!")<br/>    }<br/>}</pre>
<p>Otherwise, we would get the following error:</p>
<pre><strong>Class 'MyClass' must override public open fun foo(): Unit because it inherits multiple interface methods of it.</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>A similar feature of Kotlin is the ability to declare default values of functions' parameters. You can learn more about it in the <em>Declaring adjustable functions with default parameters </em>recipe.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending functionalities of classes</h1>
                
            
            
                
<p>While working on implementing new features or refactoring of existing code, we often end up extracting some part of the code to functions in order to reuse them in different places. If the extracted function is atomic enough, we often end up exporting it to external utility classes whose primary purpose is to extend functionalities of existing classes. Kotlin provides an interesting alternative to the utility classes. It offers a built-in feature allowing us to extend functionalities of other classes with <em>extension functions</em> and <em>extension properties</em>.</p>
<p>In this recipe, we are going to extend the functionality of the <kbd>Array&lt;T&gt;</kbd> class<em> </em>and add a <kbd>swap(a:T, b: T)</kbd><em> </em>extension function to it, which is responsible for changing places of a two given elements of the array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We can declare extension functions and extension properties inside any file in the project. However, to keep them well organized, it's better to put them in dedicated files.</p>
<p>The syntax for extension functions is very similar to the one of the standard function. We just need to add information about the type that is being extended with the new function, as follows:</p>
<pre>fun SomeClass.newFunctionName(args): ReturnType {<br/>    // body<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new file, <kbd>Extensions.kt</kbd>, to store the extension function definition. </li>
<li>Implement the <kbd>swap()</kbd> function inside:</li>
</ol>
<pre style="padding-left: 60px">fun &lt;T&gt; Array&lt;T&gt;.swap(a: T, b: T) {<br/>    val positionA = indexOf(a)<br/>    val positionB = indexOf(b)<br/><br/>    if (positionA &lt; 0 || positionB &lt; 0) {<br/>        throw IllegalArgumentException("Given param doesn't belong<br/>        to the array")<br/>    }<br/><br/>    val tmp = this[positionA]<br/>    this[positionA] = this[positionB]<br/>    this[positionB] = tmp<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result, we are able to call the <kbd>swap</kbd> function on any instance of the <kbd>Array</kbd> class. Let's consider the following example:</p>
<pre>val array: Array&lt;String&gt; = arrayOf("a", "b", "c", "d")<br/>array.swap("c", "b")<br/>print(array.joinToString())</pre>
<p>This results in printing the following output to the console:</p>
<pre><strong>a, c, b, d</strong></pre>
<p>As you can see, we can access the current instance of the class inside the extension function using the <kbd>this</kbd> keyword.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Apart from extension functions, Kotlin also offers an extension properties feature. For example, we can declare a property for the <kbd>List&lt;T&gt;</kbd> class that will hold information about the last element index value:</p>
<pre>val &lt;T&gt; List&lt;T&gt;.lastIndex: Int  get() = size - 1</pre>
<p>Extensions are a widely used pattern across Kotlin standard library classes. They work seamlessly with Java, Kotlin, JavaScript, and native classes defined within the project and in external dependencies as well. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Destructuring types</h1>
                
            
            
                
<p>It is often practical to convert a single object of a complex type into a number of variables. This allows you to provide proper naming for the variables and simplifies the code. Kotlin provides an easy, built-in way to achieve this with a feature called <em>destructuring</em>:</p>
<pre>data class User(val login: String, val email: String, val birthday: LocalDate)<br/><br/>fun getUser() = User("Agata", "ag@t.pl", LocalDate.of(1990, 1, 18))<br/><br/>val (name, mail, birthday) = getUser()<br/><br/>print("$name was born on $birthday")</pre>
<p>As a result, this piece of code would print the following message to the console:</p>
<pre><strong>Agata was born on 1990-01-18</strong></pre>
<div><div><div><p>Pretty awesome! Destructuring is available for data classes out of the box. The Kotlin standard library provides this feature for many common types as well. However, destructuring is not available explicitly whenever we are dealing with custom, non-data classes. Especially, while working with classes from external libraries written in other languages such as Java, we need to define the destructuring mechanism manually. In this recipe, we are going to implement destructuring for a Java class defined as follows:</p>
</div>
</div>
</div>
<pre>// Java code<br/>public class LightBulb {<br/>    private final int id;<br/>    private boolean turnedOn = false;<br/><br/>    public LightBulb(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    public void setTurnedOn(boolean turnedOn) {<br/>        this.turnedOn = turnedOn;<br/>    }<br/><br/>    public boolean getTurnedOn() {<br/>        return turnedOn;<br/>    }<br/>    <br/>    public int getId() {<br/>        return id;<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">Destructuring declarations in Kotlin are position-based, opposed to property name-based declarations available in other languages. This means the Kotlin compiler decides which class property is linked to which variable based on the order of the properties. In order to allow custom class destructuring, we need to add implementations of the functions called <kbd>componentN</kbd><em>, </em>where <em>N</em> refers to the component number marked with the <kbd>operator</kbd> keyword to allow using them in a destructuring declaration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare an extension function returning the <kbd>id</kbd> property of the <kbd>LightBulb</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">operator fun LightBulb.component1() = this.id<br/></pre>
<ol start="2">
<li>Add another extension <kbd>componentN</kbd> function responsible for returning the <kbd>turnedOn</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">operator fun LightBulb.component2() = this.turnedOn</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once we declare proper <kbd>componentN</kbd><em> </em>functions, we can benefit from destructuring of the <kbd>LightBulb</kbd> type objects:</p>
<pre>val (id, turnedOn) = LightBulb(1)<br/>print("Light bulb number $id is turned ${if (turnedOn) "on" else "off"}")</pre>
<p>This code would print the following output to the console:</p>
<pre><strong>Light bulb number 1 is turned off</strong></pre>
<p>As you can see, the <kbd>component1()</kbd> function was assigned to the first variable of the destructured declaration—<kbd>id</kbd>. Similarly, the second <kbd>turnedOn</kbd> variable was assigned with the result of the <kbd>component2()</kbd> function.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Because of the fact that properties in destructured object assignments are position-based, sometimes we are forced to declare more variables than we want to use. We can use an underscore if we don't need to use a certain value, avoiding the compiler hint indicating an unused variable and simplifying the code a bit:</p>
<pre>val (_, turnedOn) = LightBulb(1)<br/>print("Light bulb is turned ${if (turnedOn) "on" else "off"}")</pre>
<p>Destructuring is also available for function return values:</p>
<pre>val (login, domain) = "agata@magdalena.com".split("@")<br/>print("login: $login, domain: $domain")</pre>
<p>The preceding code is going to return the following output:</p>
<pre><strong>login: agata, domain: magdalena.com</strong></pre>
<p>We can also use destructured declarations with lambda expressions:</p>
<pre>listOf(LightBulb(0), LightBulb(1))<br/>        .filter { (_, isOn) -&gt; isOn }<br/>        .map { (id, _) -&gt; id }</pre>
<p>Another useful application of destructured declarations is an iteration. For example, we can use this feature to traverse through map entries:</p>
<pre>val lightBulbsWithNames = <br/>        mapOf(LightBulb(0) to "Bedroom", LightBulb(1) to "Kitchen")<br/><br/>for ((lightbulb, name) in lightBulbsWithNames) {<br/>    lightbulb.turnedOn = true<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning multiple data</h1>
                
            
            
                
<p>Although Kotlin doesn't provide a multiple return feature, thanks to data classes and destructuring declarations, it is quite convenient to write functions that return a number of values of different types. In this recipe, we are going to implement a function returning the result of dividing two numbers. The result is going to contain the quotient and remainder values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start with declaring a data class for the return type:</li>
</ol>
<pre style="padding-left: 60px">data class DivisionResult(val quotient: Int, val remainder: Int)</pre>
<ol start="2">
<li>Let's implement the <kbd>divide()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun divide(dividend: Int, divisor: Int): DivisionResult {<br/>    val quotient = dividend.div(divisor)<br/>    val remainder = dividend.rem(divisor)<br/>    return DivisionResult(quotient, remainder)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We can see the <kbd>divide()</kbd> function in action:</p>
<pre>val dividend = 10<br/>val divisor = 3<br/>val (quotient, remainder) = divide(dividend, divisor)<br/><br/>print("$dividend / $divisor = $quotient r $remainder")</pre>
<p>The preceding code is going to print the following output:</p>
<pre><strong>10 / 3 = 3 r 1</strong></pre>
<p>Thanks to the fact that we are returning a data class instance, the <kbd>DivisionResult</kbd> class, we can benefit from the destructuring feature and assign the result to a set of separate variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The Kotlin standard library provides ready to use <kbd>Pair</kbd> and <kbd>Triple</kbd> classes. We can use them to return two and three values of any type. This eliminates the need to create a dedicated data classes for the return type. On the other hand, using data classes gives us the ability to operate on more meaningful names, which adds more clarity to the code.</p>
<p class="mce-root"/>
<p>The following example demonstrates using the <kbd>Pair</kbd> class to return two objects at the same time:</p>
<pre>fun getBestScore(): Pair&lt;String, Int&gt; = Pair("Max", 1000)<br/>val (name, score) = getBestScore()<br/>print("User $name has the best score of $score points")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to get more familiar with destructuring declarations, you can take a look at the <em>Destructuring types </em>recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Inlining parameters of closure type</h1>
                
            
            
                
<p>Usage of higher-order functions can lead to a decrease of runtime performance. Memory allocations of the functions passed as lambda arguments and their virtual calls in a function body lead to runtime overhead. However, in many cases, we can eliminate this type of overhead by inlining the lambda expression parameters.</p>
<p>In this recipe, we are going to implement the <kbd>lock()</kbd> function that will automate work with the Java <kbd>java.util.concurrent.locks.Lock</kbd> interface. The function will take two arguments—an instance of the <kbd>Lock</kbd> interface and the function that should be invoked after the lock is acquired. Finally, our <kbd>lock()</kbd> function should release the lock. We also want to allow making the function parameter inlined.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To declare an inline function, we simply need to add the <kbd>inline</kbd> modifier in front of the function header.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's declare a <kbd>lock()</kbd> function with two arguments—an instance of the <kbd>Lock</kbd> interface and the function to be invoked after the lock is acquired:</p>
<pre>inline fun performHavingLock(lock: Lock, task: () -&gt; Unit) {<br/>    lock.lock()<br/>    try {<br/>       task()<br/>    }<br/>    finally {<br/>        lock.unlock()<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>performHavingLock()</kbd> function allows us to provide synchronization for the function passed to it as the <kbd>task</kbd> parameter:</p>
<pre>performHavingLock(ReentrantLock()) {<br/> print("Wait for it!")<br/>}</pre>
<p>As a result, the <kbd>performHavingLock()</kbd> function is going to print the following output to the console:</p>
<pre><strong>Wait for it!</strong></pre>
<p>Under the hood, the inline modifier affects both the function itself and the lambda expressions passed to it. They are all going to be inlined in the underlying generated bytecode:</p>
<pre>Lock lock = (Lock)(new ReentrantLock());<br/>lock.lock();<br/><br/>try {<br/>   String var2 = "Wait for it!";<br/>   System.out.print(var2);<br/>} finally {<br/>   lock.unlock();<br/>}</pre>
<p>If we did not use the <kbd>inline</kbd> modifier, the compiler would create a separate instance of the <kbd>Function0</kbd> type in order to pass the lambda argument to the <kbd>performHavingLock()</kbd> function. Inlining lambdas may cause the generated code to grow. However, if we do it in a reasonable way (that is, avoiding inlining large functions), it will pay off in performance. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you want only some of the lambdas passed to the function to be inlined, you can mark some of the function parameters with the <kbd>noinline</kbd> modifier:</p>
<pre>inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {  <br/>    // ... <br/>}</pre>
<p>Kotlin also allows declaring inline class properties. The <kbd>inline</kbd> modifier can be used with getter and setter methods of properties that don't have a backing field. For example:</p>
<pre>val foo: Foo  <br/>    inline get() = Foo()  <br/><br/>var bar: Bar  <br/>    get() = ...  <br/>    inline set(v) { ... }</pre>
<p>We can also annotate an entire property:</p>
<pre>inline var bar: Bar  <br/>    get() = ...  <br/>    set(v) { ... }</pre>
<p>As a result, the inlined getters and setters are going to be represented in the same way as the regular inline functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Infix notations for functions</h1>
                
            
            
                
<p>To bring our code closer to the natural language, Kotlin provides infix notations for the functions containing a single parameter. This way, we can invoke the function without using brackets. In this recipe, we are going to learn how to design an infix extension function for the <kbd>String</kbd> type, named <kbd>concat()</kbd>, which is responsible for the concatenation of two string values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to enable an infix notation for the function, we simply need to add the <kbd>infix</kbd> keyword before the function header.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Declare the <kbd>concat()</kbd> extension function and implement its body:</p>
<pre>infix fun String.concat(next: String): String = this + next</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's test the <kbd>concat()</kbd> function by running the following code:</p>
<pre>print("This" concat "is" concat "weird")</pre>
<p>Great! We have just printed out the following text to the console:</p>
<pre><strong>Thisisweird</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The Kotlin standard library uses the infix notation extensively. You can benefit from infix functions to shape your code the clean way. One infix function worth noting is the <kbd>to()</kbd> extension function provided for the <kbd>Map.Entry&lt;K, V&gt;</kbd> class, which allows you to declare map entries in a minimalistic way:</p>
<pre>val namesWithBirthdays: Map&lt;String, LocalDate&gt; =<br/>        mapOf("Agata" <strong>to </strong>LocalDate.of(1990, 1, 18))</pre>
<p>The <kbd>to()</kbd> extension function is declared for a generic type <kbd>A</kbd> and generic argument of type <kbd>B</kbd>, which returns an instance of a <kbd>Pair&lt;A, B&gt;</kbd> class.</p>
<p>There are plenty of other functions supporting infix notations available in the standard library. If you check the implementation of the ones you are using on a daily basis, it may turn out they are available in the infix form too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can learn about another cool feature that helps to shape the code to be more natural to read in the <em>Overloading operators </em>recipe</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Smart types checking with generic reified parameters</h1>
                
            
            
                
<p>While implementing functions that support generic type arguments, we often deal with the need to provide additional information about object types at runtime. On the JVM platform, types have their representations in the <kbd>Class&lt;T&gt;</kbd> class instances. For example, we can face such a need while parsing JSON formatted data to the Kotlin class instances using the <kbd>Gson</kbd> library:</p>
<pre>data class ApiResponse(val gifsWithPandas: List&lt;ByteArray&gt;)<br/>data class Error(val message: String)<br/><br/>fun parseJsonResponse(json: String): ApiResponse {<br/>    Gson().fromJson(json, <strong>ApiResponse::class.java</strong>)<br/>}</pre>
<p>Normally, we can't access the generic type argument at runtime because of a JVM types erasure. However, Kotlin allows you to overcome this limitation because it preserves the type argument at runtime. In this recipe, we are going to tune up Gson's <kbd>fromJson(json: String, Class&lt;T&gt;)</kbd> function to get rid of the additional type argument.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have the Gson dependency included in your project (<a href="https://github.com/google/gson">https://github.com/google/gson</a>). If you are using Gradle, build script that you can fetch it with the following declaration:</p>
<pre>dependencies {
    compile 'com.google.code.gson:gson:2.8.2'
}</pre>
<p>In order to make a type argument accessible at runtime, we need to mark it with the <kbd>reified</kbd> modifier and mark the function as <kbd>inline</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new file where we will put an extension function implementation (for example, <kbd>GsonExtensions.kt</kbd>)</li>
</ol>
<ol start="2">
<li>Inside the file, declare an extension function for the <kbd>Gson</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">inline fun &lt;reified T&gt; Gson.fromJson(json: String): T { <br/>    return fromJson(json, T::class.java)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have implemented an extension function for the <kbd>Gson</kbd> type. Thanks to adding the <kbd>reified</kbd> modifier, we can access the generic type argument at runtime and pass it to the original <kbd>fromGson()</kbd> function.</p>
<p>As a result, we are able to use the more elegant version of the <kbd>fromGson()</kbd> function in our code:</p>
<pre>data class ApiResponse(val gifsWithPandas: List&lt;ByteArray&gt;)<br/><br/>val response = Gson().fromJson&lt;ApiResponse&gt;(json)</pre>
<p>We could also benefit from Kotlin smart casting and omit the explicit type declaration from the function call:</p>
<pre>val response: ApiResponse = Gson().fromJson(json)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Overloading operators</h1>
                
            
            
                
<p>The Kotlin language provides a set of operators which have their own symbol (for example, <kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>,  or <kbd>/</kbd>) and a priority defined. At the time of compilation, the Kotlin compiler transforms them into associated function calls or even more complex statements. We are also able to override an operator and declare its custom underlying implementation for a specified type. This implementation would be applied to the instances of the specified type the operator was used with.</p>
<p>In this recipe, we are going to define a class called <kbd>Position</kbd>, representing the current coordinates of the point in a three-dimensional space. Then, we are going to implement custom <kbd>plus</kbd> and <kbd>minus</kbd> operators for our class to provide a simple way of applying a geometric transformation to its instances. As a result, we want to be able to update the coordinates of the point represented by the <kbd>Position</kbd> class using the <kbd>+</kbd> and <kbd>-</kbd> operator symbols.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">In order to overload the operator for the specific type, we need to provide a member function or an extension function with a fixed name corresponding to the operator. Additionally, functions that overload operators need to be marked with the <kbd>operator</kbd> keyword.</p>
<p>In the following tables, you can find grouped sets of operators available in the language with their corresponding expressions to which they are translated to:</p>
<p><strong>Unary prefix</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>+a</kbd></td>
<td><kbd>a.unaryPlus()</kbd></td>
</tr>
<tr>
<td><kbd>-a</kbd></td>
<td><kbd>a.unaryMinus()</kbd></td>
</tr>
<tr>
<td><kbd>!a</kbd></td>
<td><kbd>a.not()</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Incrementation and decrementation</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a++</kbd></td>
<td><kbd>a.inc()</kbd></td>
</tr>
<tr>
<td><kbd>a--</kbd></td>
<td><kbd>a.dec()</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Arithmetic</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>+</kbd> <kbd>b</kbd></td>
<td><kbd>a.plus(b)</kbd></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>-</kbd> <kbd>b</kbd></td>
<td><kbd>a.minus(b)</kbd></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>*</kbd> <kbd>b</kbd> </td>
<td><kbd>a.times(b)</kbd></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>/</kbd> <kbd>b</kbd></td>
<td><kbd>a.div(b)</kbd></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>%</kbd> <kbd>b</kbd></td>
<td><kbd>a.rem(b)</kbd></td>
</tr>
<tr>
<td><kbd>a..b</kbd></td>
<td><kbd>a.rangeTo(b)</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>In<em> </em>operator</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>in</kbd> <kbd>b</kbd></td>
<td><kbd>b.contains(a)</kbd></td>
</tr>
<tr>
<td><kbd>a</kbd> <kbd>!in</kbd> <kbd>b</kbd></td>
<td><kbd>!b.contains(a)</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Indexed access</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a[i]</kbd></td>
<td><kbd>a.get(i)</kbd></td>
</tr>
<tr>
<td><kbd>a[i, j]</kbd></td>
<td><kbd>a.get(i, j)</kbd></td>
</tr>
<tr>
<td><kbd>a[i_1, ..., i_n]</kbd></td>
<td><kbd>a.get(i_1, ..., i_n)</kbd></td>
</tr>
<tr>
<td><kbd>a[i] = b</kbd></td>
<td><kbd>a.set(i, b)</kbd></td>
</tr>
<tr>
<td><kbd>a[i, j] = b</kbd></td>
<td><kbd>a.set(i, j, b)</kbd></td>
</tr>
<tr>
<td><kbd>a[i_1, ..., i_n] = b</kbd></td>
<td><kbd>a.set(i_1, ..., i_n, b)</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Invoke operator</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a()</kbd></td>
<td><kbd>a.invoke()</kbd></td>
</tr>
<tr>
<td><kbd>a(i)</kbd></td>
<td><kbd>a.invoke(i)</kbd></td>
</tr>
<tr>
<td><kbd>a(i, j)</kbd></td>
<td><kbd>a.invoke(i, j)</kbd></td>
</tr>
<tr>
<td><kbd>a(i_1, ..., i_n)</kbd></td>
<td><kbd>a.invoke(i_1, ..., i_n)</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Augmented assignment</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a += b</kbd></td>
<td><kbd>a.plusAssign(b)</kbd></td>
</tr>
<tr>
<td><kbd>a -= b </kbd></td>
<td><kbd>a.minusAssign(b)</kbd></td>
</tr>
<tr>
<td><kbd>a *= b</kbd></td>
<td><kbd>a.timesAssign(b)</kbd></td>
</tr>
<tr>
<td><kbd>a /= b</kbd></td>
<td><kbd>a.divAssign(b)</kbd></td>
</tr>
<tr>
<td><kbd>a %= b</kbd></td>
<td><kbd>a.remAssign(b)</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Equality and comparison</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Expression</strong></td>
</tr>
<tr>
<td><kbd>a == b</kbd></td>
<td><kbd>a?.equals(b) ?: (b === null)</kbd></td>
</tr>
<tr>
<td><kbd>a != b</kbd></td>
<td><kbd>!(a?.equals(b) ?: (b === null))</kbd></td>
</tr>
<tr>
<td><kbd>a &gt; b</kbd></td>
<td><kbd>a.comareTo(b) &gt; 0</kbd></td>
</tr>
<tr>
<td><kbd>a &lt; b</kbd></td>
<td><kbd>a.compareTo(b) &lt; 0</kbd></td>
</tr>
<tr>
<td><kbd>a &gt;= b</kbd></td>
<td><kbd>a.compareTo(b) &gt;= 0</kbd></td>
</tr>
<tr>
<td><kbd>a &lt;= b</kbd></td>
<td><kbd>a.compareTo(b) &lt;= 0</kbd></td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare the <kbd>Position</kbd> data class with <kbd>x</kbd>, <kbd>y</kbd>, <kbd>z</kbd>  properties related to the current position in the Cartesian coordinates system:</li>
</ol>
<pre style="padding-left: 60px">data class Position(val x: Float, val y: Float, val z: Float)</pre>
<ol start="2">
<li>Add a <kbd>plus</kbd> operator implementation for the <kbd>Position</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">data class Position(val x: Float, val y: Float, val z: Float) {<br/>    operator fun plus(other: Position) = <br/>      Position(x + other.x, y + other.y, z + other.z)<br/>}</pre>
<ol start="3">
<li>Overload the <kbd>minus</kbd> operator:</li>
</ol>
<pre style="padding-left: 60px">data class Position(val x: Float, val y: Float, val z: Float) {<br/>    operator fun plus(other: Position) = <br/>      Position(x + other.x, y + other.y, z + other.z)<br/><br/>    operator fun minus(other: Position) = <br/>      Position(x - other.x, y - other.y, z - other.z)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Now we can use the <kbd>Position</kbd> class together with <kbd>plus</kbd> and <kbd>minus</kbd> operators. Let's try using the minus operator:</p>
<pre>val position1 = Position(132.5f, 4f, 3.43f)<br/>val position2 = position1 - Position(1.5f, 400f, 11.56f)<br/>print(position2)</pre>
<p>That's it. The preceding code is going to print the following result to the console:</p>
<pre><strong>Position(x=131.0, y=-396.0, z=-8.13)</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Some of the operators have their corresponding compound <em>assign </em>operators defined. Once we have overloaded the <kbd>plus</kbd> and <kbd>minus</kbd><em> </em>operators, we can use the <kbd>plusAssign (+=)</kbd> and <kbd>minusAssign (-=)</kbd><em> </em>operators automatically. For example, we can use the <kbd>plusAssign</kbd><em> </em>operator to update the <kbd>Position</kbd><em> </em>instance state as follows:</p>
<pre>var position = Position(132.5f, 4f, 3.5f)<br/>position += Position(1f, 1f, 1f)<br/>print(position)</pre>
<p>As a result, we will get the <kbd>position</kbd><em> </em>variable with the following state:</p>
<pre><strong>Position(x=133.5, y=5.0, z=4.5)</strong></pre>
<p>It is important to note that the <em>assign </em>operator returns the <kbd>Unit</kbd><em>.</em> This makes it a better choice than an original basic operator (for example, <kbd>plus</kbd><em> </em>or <kbd>minus</kbd>) in terms of memory allocations efficiency when updating an instance. In contrast, the base operators are returning new instances every time.</p>
<p>It is good to know that Kotlin offers operators overloading for Java classes as well. To overload the operator, we just need to add a proper method to the class that has the name of the operator and the <kbd>public</kbd> visibility modifier. Here is what the Java version of the <kbd>Position</kbd> class with the overloaded <kbd>plus</kbd><em> </em>operator would look like:</p>
<pre>public class Position { <br/>        private final float x; <br/>        private final float y; <br/>        private final float z;<br/>  <br/>        public Position(float x, float y, float z) { <br/>            this.x = x; <br/>            this.y = y; <br/>            this.z = z;<br/>        } <br/>  <br/>        public int getX() { <br/>            return x; <br/>        } <br/>  <br/>        public int getY() { <br/>            return y; <br/>        } <br/>        <br/>        public float getZ() {<br/>            return z;<br/>        }<br/>  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>       <strong> public Position plus(Position pos) { </strong><br/><strong>            return new Position(pos.getX() + x, pos.getY() + y,<br/>            pos.getZ() + z); </strong><br/><strong>        }</strong> <br/>}</pre>
<p>And here is how it could be used in Kotlin code:</p>
<pre>val position = Position(2.f, 9.f, 55.5f) += (2.f, 2.f, 2.f)</pre>
<p>The Kotlin standard library also contains predefined implementations of different operators. One that you should use on a daily basis is the <kbd>plus</kbd> operator for a <kbd>MutableCollection</kbd> type. This allows for adding new elements to the collection in the following way:</p>
<pre>val list = mutableListOf("A", "B", "C")<br/>list += "D"<br/>print(list)</pre>
<p> As a result, the preceding code will print the following output to the console:</p>
<pre><strong>[A, B, C, D]</strong></pre>


            

            
        
    </body></html>