- en: Chapter 9. Autonomous Moving Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to steering behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing seek
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing flee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing arrive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing evade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing wander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing wall avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obstacle avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games are interesting as they are challenging in each and every level. To make
    a game interesting, it's important to increase the difficulty of the game at each
    level. It's always interesting to defeat something in the game. In this chapter,
    we will learn about various ways to create the autonomous behavior for game objects.
    This chapter has a bunch of recipes to demonstrate the artificially intelligent
    game objects. To understand all the concepts in detail, it is recommended to read
    the previous chapter, which gives you a grip on mathematics and physics. Each
    recipe will allow you to understand and learn a specific autonomous behavior.
    By the end of this chapter, you will be able to understand and implement various
    autonomous game behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to steering behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI characters are a type of autonomous agent that is intended to be used in
    computer games for showing virtual reality. These agents represent a character
    in a story or game and have some ability to follow some pre-set actions. Actions
    of these characters are directed in real time by a human player or participant.
    In games, autonomous characters are sometimes called non-player or artificially
    intelligent characters. An AI character always has some aspects of an autonomous
    robot with some predefined skills such as either they will be seeking some characters
    in the game or they will evade themselves from the playing character. All these
    behaviors are called steering behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a new game to demonstrate all the steering
    behaviors. To get started with the implementation, let us create a new project.
    Open Xcode and go to **File** | **New** | **Project**, and then select **iOS**
    | **Application** | **SpriteKit Game**. In the pop up provide the **Product Name**
    as `SteeringBehaviors`, select **Devices** | **iPhone**, and click on **Next**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have our working sample project and we need to update the game template
    project to get started with code game logic. Perform the following steps to start
    working with the basic code flow for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `GameViewController.m` file and update the `viewDidLoad` method; remove
    all the code from this class and make it look something similar to the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `GameScene.m` file; this class creates a scene, which will be plugged
    inside the game. Now, remove all the codes from this class and just add the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, compile and run the app; you should be able to see the background image
    correctly. This will look something similar to the following screenshot:![How
    to do it](img/00137.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will need one AI character on which we will be implementing all our AI
    behaviors. So, we will create a new subclass of `SKSpriteNode` with the name `Player`.
    Go to **File** | **New** | **File**, then select **iOS** | **Source** | **Cocoa
    Touch Classes**, and click on **Next**. Now, change the **Subclass of** to **SKSpriteNode**,
    and **Class** name as `Player`. The final screen should look something similar
    to the following screenshot:![How to do it](img/00138.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `Player.m` file, and add the following code after `@implementation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the declaration of both the methods in the `Player.h` file using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open your `GameScene.m` file and add the following code right after your
    `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, add the `touchesBegan` method just after the `createPlayer` method. This
    method will give you all the touch events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, nothing happened till now. Let''s make the game work for the first state.
    Now, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final file should look something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, compile and run the project. Touch on any location and you will see the
    square box is created on that location. Multiple sprites are added to the scene
    on the tap action. The output should look something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a separate class for our player. This approach will help us to isolate
    all the features of the game character. Similarly, when we take the games to next
    levels, these are very useful as we can isolate the behaviors for various types
    of AI characters.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the seek
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the seek behavior for our player, we will need a derive force that
    will redirect the agent toward a target position. In the seek behavior, our character
    will overshoot the target because the force applied on the player will be more,
    which will make the player overshoot the target and then return to the target.
    It will take a finite amount of time before coming to rest.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Seek behavior is something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image explains the algorithm that will be used to implement the
    seek behavior. In our case, we will need to seek to the target and have to follow
    the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vector desiredVelocity = targetVector – player.locationVector;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*desiredVelocity.normalize;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*desiredVelocity *= player.maxSpeed;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return (desiredVelocity – agent.locationVector);*'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will start again on the project to implement the seek behaviors. Now,
    follow the steps below to implement the seek behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Player.m` file and add the `enum` function on the top, after the
    import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code after your interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `enum` holds the behavior we want to implement. Whenever we add any behavior,
    we will have to add it to this `enum`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The target property will hold the location where we want the player to seek
    and `behaviourType` will tell us which behavior we want to implement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to implement the seek, add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code in the update function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will be executed if the player behavior is set as seek.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we are all set to test the function we have written in the previous few
    steps. So, open the `GameScene.m` file and create the instance of the `newPlayer`
    object at the top of the implementation file. The implementation code should look
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add the following line of code in the `init` method we have written earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final init function should look something similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00142.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We have created a `newPlayer` object and have also associated the physics body
    with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we have our player ready to seek the target. Wherever we tap on the screen,
    the player will seek to that location. In the `touchesBegain:withEvent` method,
    add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, now we are all set for the seek behavior. So, finally, we will call the
    player''s update method on every update of the scene, so that the player can seek
    to the location a user has tapped on. To perform this add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the above line of code, we are calling the update function on each and every
    `newPlayer` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, compile and run the project; you will see the player in the center of the
    screen and it will seek the location that you will tap on the screen. The output
    should look something similar to the following screenshot:![How to do it](img/00143.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This completes our seek behavior for the player object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing flee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flee is the opposite of the seek behavior, which steers the vehicle in the opposite
    direction from the target. Instead of producing the force toward target, we will
    push the player off to the target as the object has to flee from the target.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the flee behavior, we need to flee to the target and follow the
    following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding algorithm, we are calculating the force that will be needed
    to flee the object off from the screen. First, we will calculate the direction
    vector to determine the direction opposite to the player, so that our object can
    flee from the target in that location. Now, in the second step, we normalize the
    vector and increase its magnitude to its max speed. Using this algorithm, we will
    implement the flee behavior for our object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the flee behavior in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Player.m file and add the following line of code just after the seek
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code in the update function after the seek code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our function is ready to flee the player. This function will accept a target
    from which it will flee. So, once again, we will be using the same approach, and
    when the user will tap on the screen, we will make the object flee from the tapped
    point. The final `Player.m` file should look something similar to the following
    screenshot:![How to do it](img/00144.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now our `Player.m` class is ready to execute the flee behavior. So, open the
    `GameScene.m` file and take the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace this with the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And also, add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the `if` condition from the above code to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `init` function should look something similar to the following screenshot:![How
    to do it](img/00145.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all. Now compile and run the project. You should be able to see the player
    and when you tap anywhere near to the player, you will see the player will flee
    from the tapped location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing arrive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrive is similar to seek. The only difference between seek and arrive is that
    in arrive the player will stop at the target location. However, in seek, it overshoots
    the target location and then seeks again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technical definition of arrive is to reach the goal with zero velocity.
    The arrival behavior will remain the same as the seek behavior, the only difference
    is that it will not overshoot the target.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, when the player is outside the stopping radius, it will follow
    the maximum speed toward the target, while as soon as the player is inside the
    stopping radius, the desired velocity of the player will be ramped down to zero.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the arrive behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Player.m file, and add the following line of code in the end of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have to call this function till our player is not in the stopping radius.
    So, we will create a box around our target point, and as soon as the player is
    inside this box, we will stop calling the arrive function. To implement this,
    add the following line of code in the update method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final update function should look something similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00146.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, it''s time to check the arrive function we have written in the `Player.m`
    file. Open the `GameScene.m` file. Take the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace this with the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, compile and run the project; you should see our player in the center of
    the screen. Now, click anywhere on the screen to provide the target for the player.
    After you have tapped, the player will arrive at the target location you have
    tapped on with overshooting the target. The output should look something similar
    to the following screenshot:![How to do it](img/00147.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The red pointer shows the target location where the player has to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing evade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evade is similar to flee. The only difference between flee and evade is that
    in evade, the player will stop after fleeing to a safe location from the target
    location selected for evade. However, in flee, it just runs out of the screen
    from the target location and never comes back.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, evade is to flee from the target to the safe location. The evade
    behavior will remain the same as the flee behavior, the only difference is that
    it will not run away infinitely from the target.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, when the target location is inside the safe range of the player,
    then the player will flee till the target location is not outside its safe range.
    So, in our case, we will make the player flee till the player is far from the
    target, and then its velocity will be ramped down to zero.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the evade behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Player.m` file and add the following line of code in the end of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code in the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, the update function should look something similar to the following
    screenshot:![How to do it](img/00148.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding function, we are drawing a rectangle on the target location
    vector. Whenever the player is inside this rectangle, it's not safe. So, it will
    flee to get the player outside into the safe location. So, we will execute our
    evade function till the player is in the rectangle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it''s time to test the evade function we have written in `Player.m`. So,
    open the `GameScene.m` file. Enter the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace this with the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final `init` method should look something similar to the following screenshot:![How
    to do it](img/00149.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, compile and run the project to see the object player in action. Click anywhere
    near the player, and it will flee to maintain a certain distance from the location
    you have tapped, as shown in the following screenshot:![How to do it](img/00150.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read about all these properties in more detail at Apple's developer
    documentation at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing wander
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have observed very often in the game that few characters are just
    randomly moving around in their environment. These characters are waiting for
    some event to happen. For example, in any warfare game, the enemy soldiers are
    just wandering around in the castle to catch the player and they will keep on
    wandering till they find the player. Once the player is in the vicinity, then
    they will change their behavior to seek. So, the wandering ability of the characters
    makes them visually pleasant and realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Making a game object follow the path will make it unrealistic and will affect
    the overall game play by making it more predictive. So these wandering behaviors
    add much more fun and realistic behavior to the game.
  prefs: []
  type: TYPE_NORMAL
- en: The wander steering behavior produces a realistic movement, which makes the
    players think that the character is just walking and to feel the whole environment
    more alive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways to implement the wander behaviors. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing wander using seek and randomness. In this approach, wander brings
    together two behaviors, seek and randomness. This means technically wander is
    just seeking to some random points and targets in the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is to evaluate a virtual point in front of the character and
    draw a circle in front of it, and get point on it circumference. Now, make the
    object seek that location. The following image will explain the approach a little
    better:![Getting ready](img/00151.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will implement the first approach, so we will follow the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will implement the wander behavior and will take our project a little
    more further. Perform the following steps to implement the wander behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Player.m` file and add the following line of code in the end of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have implemented the algorithm that we have seen in the start of this section.
    In this code, we are getting a random local point in front of the player, and
    then make the player to seek that location. This will make a wander behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the following line of code in the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final `update` function should look something similar to the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00152.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, it''s time to test the `evade` function we have written in `Player.m`.
    So, open the `GameScene.m` file and add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace it with the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add the following if condition right after the if we had for the seek
    and flee:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final file should look something similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00153.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, compile and run the project to see the object player in action. Click anywhere
    on the screen and the player will start wandering on the screen, as shown in the
    following screenshot:![How to do it](img/00154.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing wall avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AI characters will look a little odd if they collide with a wall while wandering.
    So, we have to make them even more intelligent so that they can seek the wall
    and can respond or change direction accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The wander behavior returns a force that steers the AI away from the wall to
    avoid collision.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following approach will be used to implement the wall avoidance behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Create feelers to sense the wall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use one feeler in front of the AI to sense the wall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When wall is detected, apply the force at the reflected vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the following algorithm to achieve the wall avoidance behavior in the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: The visual explanation of the technique is shown in the following screenshot:![How
    to do it](img/00155.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create feelers that will sense the wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will project the feeler in front of the player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have got the `Front_Feeler` so let's apply the force in the same direction.
    This force will push the player away from the wall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fine-tune the behavior even more, you can additionally add two more feelers
    on the either side of the player. This will help player to take a more smooth
    turn and look realistic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obstacle avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the game objects are exhibiting the group behaviors, then it's really important
    to make them avoid collision with each other. Also, there can be multiple obstacles
    on the way, which the characters have to avoid intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following approach will be used to implement the obstacle avoidance behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Create three feelers in front of the player object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let all the three feelers sense the obstacles on the way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect the player in the opposite direction if the feeler has sensed any obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the following algorithm to achieve the obstacle avoidance behavior in
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: The visual explanation of the technique is shown in the following screenshot:![How
    to do it](img/00156.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create feelers that will sense the wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have left, right, and front feelers. So whenever these feelers will sense
    any object in their way, they will push the player away from the obstacle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot more steering behaviors that can make the games very interesting.
    There are various group behaviors as well, which can be explored after having
    a hands-on these behaviors. Few of the behaviors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flocking**: When the objects exhibit certain common behavior in groups, then
    that behavior is called flocking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: When the objects exhibit some behavior that causes a particular
    character to line up with agents close by, then it''s called alignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: In this behavior, the objects are steered toward the center of
    the mass of all the objects—that is, the average position of the agents within
    a certain radius'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation**: In this behavior, the objects are steered away from all of
    their neighbors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more about these behaviors at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444](http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
