<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Exploring the Fundamentals of SwiftUI</h1>
<p>Welcome to <em class="italic">Animating SwiftUI Applications</em>! If you picked up this book, then there’s a good chance you are a developer – or aspiring to be one – and you want to learn more about SwiftUI animations. Or maybe you’re fascinated by animations and how they work like I am. I know for me that the first time I played a video game (before the home computer was even available) and saw objects collide and bounce off each other on the screen, I was hooked by animations and the code behind how they worked. Whatever the reason you’re here though, together we will explore the amazing things we can make happen on an Apple device by leveraging the power of SwiftUI’s animation classes, methods, and properties.</p>
<p>This chapter starts with a brief look at the two programming styles, imperative and declarative, and will give you an idea of why Apple introduced the declarative SwiftUI way of coding to the development world. Then, we’ll explore the Xcode interface, the free application from Apple, where we do all of our work. Finally, we’ll look at the SwiftUI structures needed to develop apps, which is the foundation for proceeding further with animations.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding imperative and declarative programming </li>
<li>Exploring the Xcode interface</li>
<li>Understanding the state</li>
<li>Understanding SwiftUI structures</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>In order to write code that can run on Apple devices, first, we need an Apple computer.  This can be any of their models, but the MacBook Pro is the most popular for coding because of its power and speed. </p>
<p>Once we have the hardware, then the next bit of tech we need to write code is the software. Apple has put together a very comprehensive set of tools all bundled into one program called Xcode, which is free to download from the App Store. Those two things are everything you need to start writing code on Apple, but if you want to upload your finished app to the App Store, then you will need an Apple Developer account. This currently costs $99 a year to maintain, but it is necessary to be able to sell your apps to the world. Go to <a href="http://developer.apple.com">developer.apple.com</a> and sign up for an account there.</p>
<p>You should also have a working knowledge of the Swift programming language so that you feel comfortable writing code, but you don’t have to be an expert by any means; it’s just that it is very helpful if you understand, or at least recognize, the syntax of the Swift language and the <a id="_idIndexMarker000"/>fundamentals of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) so that you can follow along with the projects better. </p>
<p>With that said, if you are a complete beginner to writing code, you might be a bit confused here – but not to worry, when Apple introduced the Swift programming language in 2014, they held fast to their goal of making one of the easiest-to-pick-up and most user-friendly programming languages to date. And for the most part, the Swift language reads like English sentences, so you can progress very quickly. </p>
<p>Here is what I recommend when you’re just starting out learning Swift:</p>
<p>Start with the Swift tutorials offered by Paul Hudson. He is a brilliant Swift programmer, and one of the most prolific in the industry. He has put together tons of free Swift training tutorials and videos that get you to write code fast. I have worked with Paul on many projects, and you would be hard-pressed to find a better and more thorough teaching style – he’s also just an all-around nice guy. Check out all his stuff at <a href="http://hackingwithswift.com">hackingwithswift.com</a>.</p>
<p>Someone else I have worked with (and continue to work with) is John D. Gauchat. He has put together a Swift and SwiftUI Mastermind series of books that can serve as both a reference and a guide/cookbook of code for when you need to remember the syntax or how to implement something fast. He is very thorough as well, and you can find his work at <a href="http://jdgauchat.com">jdgauchat.com</a>.</p>
<p>Finally, if you like structured video courses, I have translated many of Paul’s and John’s Swift and SwiftUI books into video courses, and they are available over at <a href="http://udemy.com">udemy.com</a> – just search for my name to see them all, including the video version of this book (which includes extra projects). </p>
<p>OK, that’s enough of those shameful plugs, but if you are a complete beginner, I want you to learn the Swift programming language from the very best, and those two guys are; this way, you will be ready to follow along and code in no time. So, go get some Swift knowledge under your belt, and come back here. I’ll wait… </p>
<p>Finally, to access all of the code in this book, go to the following GitHub repository: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Understanding imperative and declarative programming</h1>
<p>SwiftUI is a fairly new framework introduced by Apple in 2019 that includes intuitive new design tools that help make building great-looking interfaces almost as easy as dragging and dropping… almost. With its modular approach, it’s estimated that you can build the same projects previously built in Xcode using about five times less code. Also, SwiftUI was Apple’s solution for building apps that can easily be used on all of their other platforms – so, an app can be built once, and it will<a id="_idTextAnchor020"/> perform perfectly on iOS, tvOS, macOS, and watchOS.</p>
<p>The SwiftUI interface, which<a id="_idIndexMarker001"/> we will cover shortly, uses editor and canvas preview windows that work in tandem. As you code in the Xcode editor, the new design canvas displays everything completely in sync and renders in real time as you type. So, any change you make in the editor is immediately reflected in the canvas preview, and vice versa. </p>
<p>I mentioned the ease of drag and dropping in code earlier; this is because those nice engineers at Apple must have spent countless nights working hard putting together a huge selection of pre-made chunks of code called views and modifiers that you can drag and drop right into the editor. This includes things such as buttons, labels, menus, lists, pickers, forms, text fields, toggle switches, modifiers, events, navigation objects, effects, and well, much more, but you get the point. Unlike UIKit and Storyboards, when you drop a view or a modifier into the editor or on the canvas, SwiftUI generates the code for that view automatically.</p>
<p>The SwiftUI approach to app <a id="_idIndexMarker002"/>development is known as <strong class="bold">declarative programming</strong>, and it has become widely popular in the last few years. Examples of declarative programming would include frameworks such as React and cross-platform development frameworks such as React Native and Flutter. So, now it’s Apple’s turn to offer its own completely native declarative UI framework, SwiftUI. </p>
<p>But what does declarative programming actually mean? Well, to best describe declarative programming, let’s first understand what imperative programming is. </p>
<p><strong class="bold">Imperative programming</strong> has been the<a id="_idIndexMarker003"/> oldest programming paradigm since the dawn of computer languages. The word “imperative” has its origin in the Latin word “imperare”, which means “to command,” and it was first used to express a command – for example: “do it”! (Hmm, I wonder whether Nike borrowed that imperative command and tweaked it a little…) This style of programming is what iOS developers used before SwiftUI came out. </p>
<p>Imperative programming is a programming paradigm that uses statements that change a program’s state. These statements are executed in a specific order, and they usually involve assignment statements, loops, and control structures that specify how the computation should be carried out.</p>
<p>In imperative programming, the programmer specifies exactly how the computation should be carried out, using statements that tell the computer what to do. This can make imperative programs more complex because the programmer has to specify all of the steps of computation. However, it can also make them more flexible because the programmer has more control over the details of the computation.</p>
<p>Here is an example of imperative programming using the UIKit framework in iOS:</p>
<pre class="source-code">
let button = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))
button.setTitle("Button", for: .normal)
button.setTitleColor(.black, for: .normal)
button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
view.addSubview(button)</pre>
<p>This code creates a new <code>UIButton</code>, sets its title and title color, and adds an action to be performed when the<a id="_idIndexMarker004"/> button is tapped. It then adds the button to the view hierarchy. This code is imperative because it specifies the exact steps needed to create and configure the button and add it to the view.</p>
<p>Now, this same code could also be written in a declarative style using a library such as SwiftUI, ReactiveCocoa, or RxSwift, which allows <a id="_idIndexMarker005"/>you to specify the desired behavior of the button rather than the steps needed to achieve it. Here is the same example written using SwiftUI:</p>
<pre class="source-code">
import SwiftUI
struct ContentView: View {
    var body: some View {
        Button(action: {
            // action to be performed when button is tapped
        }) {
            Text("Button")
                .font(.title)
                .foregroundColor(.black)
        }
    }
}</pre>
<p>In this example, the <code>Button</code> view is declarative, because it specifies the desired behavior of the button (displaying text and performing an action when tapped), rather than the steps needed to create and configure the button.</p>
<p>SwiftUI uses a declarative style of programming, which can make it easier to understand and maintain your code because you don’t have to specify all of the intermediate steps needed to achieve the desired behavior. It also allows your code to automatically update when the underlying data changes because you specify the desired outcome rather than the steps needed to achieve it.</p>
<p>So, declarative programming is a<a id="_idIndexMarker006"/> programming paradigm in which a program specifies what it wants to achieve, rather than how to achieve it. The focus is on the “what” rather than the “how.” Declarative programs are usually easier to understand because they don’t require the <a id="_idIndexMarker007"/>programmer to specify every single step of the computation. They can also be more concise because they don’t need to specify all of the intermediate steps.</p>
<p>There are many different programming languages and technologies that support declarative programming, including SQL, HTML, and functional programming languages such as Haskell and Lisp. In general, declarative programming is well suited to tasks that involve defining data relationships or specifying a desired output, rather than specifying the steps needed to achieve something.</p>
<p>To clarify, let’s use the analogy of an artist: imperative languages paint by numbers to reach the desired result, a finished painting, but declarative languages use the finished painting and let background algorithms (functions and methods) automatically choose the appropriate colors and brush strokes to achieve the desired result. Also, by using this declarative approach, SwiftUI minimizes or eliminates programming side effects, usually caused by tracking the state of the program.</p>
<p class="callout-heading">Note</p>
<p class="callout">You will want to keep in mind that in many cases, code will be a mixture of both imperative and declarative styles, so it’s not always one or the other.</p>
<p>With a better understanding of SwiftUI now, we will proceed to an overview of the Xcode interface.</p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor021"/>Exploring the Xcode interface</h1>
<p>In this section, we will <a id="_idIndexMarker008"/>take a tour of the Xcode interface. I’m assuming that you have used Xcode before, practicing your Swift skills, which means you have a good handle on many of the things here in the interface. However, there are a few new additions to accommodate SwiftUI.</p>
<p>When you first start up Xcode, you see the welcome screen. On the right is a list of recent projects, and on the left, there are buttons to start a new project, open an existing project, or clone one saved in a repository.</p>
<div><div><img alt="Figure 1.1: Xcode welcome screen " src="img/B18674_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Xcode welcome screen</p>
<p>We will be using the<a id="_idIndexMarker009"/> first option, which is <strong class="bold">Create a new Xcode project</strong>, for all of our projects, so select that.</p>
<p>The next screen lets us choose options for the project:</p>
<div><div><img alt="Figure 1.2: Project options  " src="img/B18674_01_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Project options </p>
<p>Let’s look at these options:</p>
<ul>
<li><strong class="bold">Product Name</strong>: This will be the <a id="_idIndexMarker010"/>name of the project. You should select a name that is directly related to what the project will do.</li>
<li><strong class="bold">Team</strong>: This will be the developer account you created with your Apple ID at <a href="http://developer.apple.com">developer.apple.com</a>, or a company account if you have one.</li>
<li><code>com.SMDAppTech</code>).</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">If you were wondering why Apple requires this reverse notion, here’s a deeper explanation. Reverse domain name notation (or reverse DNS) is a system used to map an IP address to a domain name. Reverse DNS strings are based on registered domain names, with the order of the components reversed for grouping purposes. Here is an example: if a company making a product called MyProduct has the domain name <a href="http://exampleDomain.com">exampleDomain.com</a>, they could use a reverse DNS string of <code>com.exampleDomain.MyProduct</code> as an identifier for that product. Reverse DNS names are a simple way of eliminating namespace collisions since any domain name is globally unique to its registered owner.</p>
<ul>
<li><strong class="bold">Interface</strong>: This is <a id="_idIndexMarker011"/>where we select the technology we will use to design the UI. From the drop-down list, you can choose <strong class="bold">SwiftUI</strong> or <strong class="bold">Storyboard</strong>. SwiftUI is a system that lets us declare the interface from code, while Storyboard is a graphical system that allows us to drag and drop many components and controls onto a storyboard to create the user interface – we want to select <strong class="bold">SwiftUI</strong>. </li>
</ul>
<p>A quick note: even though we drag and drop onto the storyboard in that option, the code is not generated after you drop an object onto the board. You still have to write out the code for each object and make connections for buttons and other controls. Whereas in SwiftUI, you can drag and drop similar components, and the code is automatically propagated in the editor for you. You then fill out the body with what you want it to do.</p>
<ul>
<li><strong class="bold">Language</strong>: This is the coding language; here, we will select <strong class="bold">Swift</strong>.</li>
<li>We don’t need to use core data, which is a way of persisting your data so it always loads back up again, and we don’t need to include tests for any of the projects.</li>
</ul>
<p>When we hit <strong class="bold">Next</strong>, we’re asked where to save the project. I like to save it on the desktop, but you can choose any location you want.</p>
<p>And now we are in the Xcode interface:</p>
<div><div><img alt="Figure 1.3: Xcode interface " src="img/B18674_01_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: Xcode interface</p>
<p>The Xcode interface is the<a id="_idIndexMarker012"/> part of Xcode where we do all of our coding. It is split up into different sections; here are those sections explained:</p>
<ul>
<li><strong class="bold">Project </strong><strong class="bold">Navigator</strong> (<strong class="bold">1)</strong>:</li>
</ul>
<p>This is a collapsible space that contains all the project files. A file called <code>ContentView</code> is here, into which we can write our code, and we can create more files as the project grows. If you have worked in Xcode before with UIKit, then the <code>ContentView</code> file is analogous to UIKit’s View Controller, where it had the <code>ViewDidLoad</code> method, in which we would usually load some user interface code. Here, we put the UI code in the <code>ContentView</code> struct and create other structs as needed. We can also organize all these files by creating and naming new groups and folders. There’s another file here called <code>Assets.xcassets</code> (also called the Assets catalog), where we place the images and colors needed for our project. </p>
<p>Looking at the top of the <code>Demo</code>. This is the main folder of your project into which everything else is placed, including the new Swift files that you create. Clicking on that<a id="_idIndexMarker013"/> takes us to many different options and settings to configure the app, things such as the deployment target, signing, capabilities, build settings, and more.</p>
<ul>
<li><strong class="bold">Tool </strong><strong class="bold">bar</strong> (<strong class="bold">2</strong>):</li>
</ul>
<p>Let’s look at the toolbar (after the traffic light buttons), starting from left to right:</p>
<ul>
<li>There is a navigator toggle button that opens and closes the <strong class="bold">Project Navigator</strong> pane that we just looked at, to give you more working space when you need it. </li>
<li>To the right of the navigation button is a play button that runs and stops the project.</li>
<li>Next, you will see the title of your project. However, if you click on it, this is a drop-down list, allowing you to select the scheme and various different simulators or devices to run your project in. A scheme is a destination for running the app. For example, Xcode lets us run the project on different simulators, on a device, in a window on the Mac computer, on an Apple watch, on an iPad, or on an Apple TV if we are building for those. We are building for the iPhone, so you can select any of the iPhone simulator models from the list, or connect your iPhone to your computer and you will see it appear in the list. If you select your iPhone, you can see what your app looks like running on an actual device.</li>
<li>After that, there is a display area to show any errors or warnings, as well as the app’s current status.</li>
<li>To the right on the toolbar is a plus button that opens up a library of tools that we use to help create the user interface, things such as modifiers, views, controls, and code snippets.</li>
<li>And finally, there's another <a id="_idIndexMarker014"/>button at the far right to show or collapse the Utilities Inspector, again, for more screen real estate when needed. </li>
</ul>
<ul>
<li><strong class="bold">Utilities</strong> (<strong class="bold">3</strong>):</li>
</ul>
<p>The <strong class="bold">Utilities</strong> Inspector is a collapsible area that offers more options to edit and configure the interface and its elements. There are five tabs at the top for this; from left to right, they are as follows:</p>
<ul>
<li><strong class="bold">File Inspector</strong> is used to adjust the parameters for the file you are working in</li>
<li><strong class="bold">History Inspector</strong> is used to view your project’s history (this is not used much in a SwiftUI project)</li>
<li><strong class="bold">Quick Help Inspector</strong> will give you a description/definition of the code selected in the editor</li>
<li><strong class="bold">Accessibility Inspector</strong> is for configuring things such as voiceover, Braille reading, and other settings related to making your app more accessible</li>
<li><strong class="bold">Attributes Inspector</strong> gives you the option to change any of the attributes of a particular view, modifier, or other control that you have selected</li>
</ul>
<ul>
<li><strong class="bold">Debug/Console</strong> (<strong class="bold">4</strong>):</li>
</ul>
<p>This is a collapsible space that appears and disappears by toggling the button on the bottom right. The area can also be divided into two sections. When split, the section on the left provides information for debugging, and the right is a console used to display any relevant information when we run the code, as well as warnings and errors.</p>
<ul>
<li><strong class="bold">Editor</strong> (<strong class="bold">5</strong>):</li>
</ul>
<p>This is the area in which we write our code. This section of Xcode is not collapsible, but we can split it into two or more sections by clicking the button at the far right just underneath the toolbar. It can be positioned at the top or the bottom depending on how you like to write code. </p>
<p>There is also a feature<a id="_idIndexMarker015"/> called the mini-map, a miniature map of the code file, which offers a helpful view of the entire file, and makes it easy to reference and navigate around your code, especially if you have very large files. We can enable it by clicking on the little hamburger icon at the top right and choosing <strong class="bold">Mini Map</strong>. </p>
<ul>
<li><strong class="bold">Canvas </strong><strong class="bold">Previews</strong> (<strong class="bold">6</strong>):</li>
</ul>
<p>The canvas is its own collapsible section of Xcode that features a graphical simulator called a preview, that has a real-time connection to the code within the editor. Any changes we make in the editor will be reflected in the preview. There is a <strong class="bold">Run</strong> button on the preview to test out what you’ve done so far, but the preview is a great visual aid that helps speed up development. </p>
<p>That’s the XCode interface in a nutshell. It may look daunting at first, but as you code along through the projects, you will become more comfortable and start to learn where everything is.</p>
<p>Let’s continue and look at the concept of the state, which is data that can change. We hold our data in variables, and that data changes many times when we animate something in SwiftUI; when the data changes, SwiftUI helpfully will handle updating the animations for us by using the state to refresh the views.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/>Understanding the state</h1>
<p>In SwiftUI, a state is a piece of data<a id="_idIndexMarker016"/> that can change. When the state changes, the view that depends on the state is automatically refreshed.</p>
<p>You can declare a state in a SwiftUI view by using the <code>@State</code> property wrapper. For example, see the following:</p>
<pre class="source-code">
struct ContentView: View {
    @State private var name: String = "Bella"
}</pre>
<p>Here, <code>name</code> is a state that is<a id="_idIndexMarker017"/> stored as a string. You can then use this state to display dynamic content in your view:</p>
<pre class="source-code">
struct ContentView: View {
    @State private var name: String = "Bella"
    var body: some View {
        Text("Hello, \(name)")
    }
}</pre>
<p>To change the state, we can assign a new value to the <code>@State</code> property. For example, see the following:</p>
<pre class="source-code">
struct ContentView: View {
    @State private var name: String = "Bella"
        var body: some View {
        VStack {
            Text("Hello, \(name)")
            Button(action: {
        <a id="_idTextAnchor023"/>        name = "Jack"
            }) {
                Text("Change name")
            }
        }
    }
}</pre>
<p>When the button is tapped, the name state is changed to <code>"Jack"</code> and the view is automatically refreshed to display the new name.</p>
<p>Let’s continue now<a id="_idIndexMarker018"/> and look at what makes up SwiftUI and helps it works so well.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor024"/>Understanding SwiftUI structures</h1>
<p>SwiftUI gives us views, controls, modifiers, and layout structures for declaring the user interface. The framework also includes event handlers for providing taps, gestures, and other kinds of input for our <a id="_idIndexMarker019"/>app, as well as tools for managing the flow of data coming from your app’s models. </p>
<p>But what’s a model? A <strong class="bold">model</strong> is simply a<a id="_idIndexMarker020"/> folder we create in the <strong class="bold">Project Navigator</strong> window where we usually keep the app’s data; for example, if we are working on a weather app, we can keep our wind, temperature, precipitation, and snow accumulation data in the app’s model after it has been received from the internet through an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) call, which is prebuilt software that talks to other<a id="_idIndexMarker021"/> programs for us. That data will then be processed and sent down to the views and controls that the user will see and can interact with. </p>
<p>SwiftUI allows us to avoid using Interface Builder and Storyboards to design the app’s user interface, as we can use the preview canvas and the editor instead. We can inspect the user interface as we write code, and also generate code when dragging and dropping views/controls into the canvas. The code within the editor and the canvas preview are side by side; changing one will update the other.</p>
<p>When building our<a id="_idIndexMarker022"/> apps, we use <strong class="bold">views</strong>. Nearly everything is a view in SwiftUI, and they are the building blocks of our apps, things such as text boxes, buttons, toggles, pickers, shapes, colors (yes, even colors are a view), stacks, and more. We add them to the canvas by dragging them out of the view’s library, or by typing out the code in the editor, and then setting their properties with modifiers. Each view will have its own unique set of properties and modifiers, and many views will also share those same properties and modifiers too. </p>
<p>The following are the SwiftUI <a id="_idIndexMarker023"/>structures we will look at so you can get a good foundation for completing this book’s projects:</p>
<ul>
<li>Computed properties</li>
<li>Stacks (<code>VStack</code>, <code>HStack</code>, and <code>ZStack</code>)</li>
<li>The <code>Spacer</code> view</li>
<li>The <code>Divider</code> view</li>
<li>The <code>padding</code> modifier</li>
<li>Closures</li>
<li><code>GeometryReader</code></li>
</ul>
<p>Let’s go through each of these now.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>Computed properties</h2>
<p>One of the first things we<a id="_idIndexMarker024"/> will look at is <strong class="bold">computed properties</strong> because that is<a id="_idIndexMarker025"/> how views are made. Here is a look at the template code that we see when we first create a new SwiftUI project:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundColor(.accentColor)
            Text("Hello, world!")
        }
        .padding()
    }
}</pre>
<p>If we run that code, this is <a id="_idIndexMarker026"/>what we see in the preview <a id="_idIndexMarker027"/>window:</p>
<div><div><img alt="Figure 1.4: Running the template code " src="img/B18674_01_04_NEW.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: Running the template code</p>
<p>The <strong class="bold">Hello, world!</strong> string is displayed in the middle of the screen. </p>
<p>Looking at the code, we see that it includes a <code>struct</code> object called <code>ContentView</code>, which is the basic building block struct that SwiftUI creates for us. Inside that is a computed property called <code>body</code> – it has open and close parentheses, and yes, it has a body where you place your code to be executed, as does any function in Swift. Computed properties <a id="_idIndexMarker028"/>do not store values as a regular stored property or variable would. Instead, this property will compute the <a id="_idIndexMarker029"/>code you place in between the parentheses and then return the result.</p>
<p>Computed properties can have getters and or setters. They can either get and return a value, set a new value, or do both. However, if it just has a getter, then it’s known as a read-only property because it will only return the computed properties value.</p>
<p>You might be wondering if this is a computed read-only property, where are the getter and return keywords? Well, this code is actually the shorthand version of a computed property. It’s optional to write out the longhand version, but we could if we wanted more readable and descriptive code; if we did, it would look like this:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        get {
            return VStack {
                Image(systemName: "globe")
                    .imageScale(.large)
                    .foregroundColor(.accentColor)
                Text("Hello, world!")
            }
            .padding()
        }
    }
}</pre>
<p>This code does the same thing as before: it returns the <code>get</code> and <code>return</code>. Again, they are optional, so you will see the shorthand version in most cases, because less code is, well, less code, which makes life easier. Still, many developers prefer the clarity of adding those keywords... it’s up to you.</p>
<p>There’s another curious bit of syntax here and that’s the <code>some View</code> keyword. The <code>some</code> keyword indicates that an opaque type will be returned, and <code>View</code> is the opaque type in this instance. Opaque <a id="_idIndexMarker030"/>refers to something that’s not clear or not easily understood. So, what’s not clear? That would be the type that this view will return. That’s because, being an opaque type, it hides the type and its implementation from us. All it cares about is that a single view will be returned, which is important because only one view can be <a id="_idIndexMarker031"/>returned to satisfy the <code>some</code> keyword’s requirements. The view’s type that will be returned is determined by what we put into the body of the computed property. In the code, there is a <code>Text</code> view there, so that’s the type that is returned. </p>
<p>When we create custom views, we just have to make sure that it conforms to the <code>View</code> protocol. To do that, we just need to implement the required <code>body</code> computed property, then we can add whatever view we want to display, things such as buttons, toggles, pickers, shapes, colors, and so on, but again, just one view.</p>
<p>Another bit of syntax to look at is <code>.padding()</code>, called a layout modifier – it modifies the layout of the text view by placing 20 points of padding (that’s the default amount when we don’t choose a value) all around the text view. Many different modifiers are grouped into different categories, such as text modifiers, image modifiers, list modifiers, and more.</p>
<p>Have a play around and experiment with them by clicking on the plus button on the top right in Xcode and then selecting the <strong class="bold">Modifiers</strong> tab. You will quickly get to know the many different modifiers as you start building the projects.</p>
<p>Let’s now turn our attention to the organizational layout of these views on the screen.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>Stacks</h2>
<p>Remember I said that the <code>some View</code> protocol has one requirement, and that is to return just one view when<a id="_idIndexMarker032"/> we run the code. That’s fine in very simple apps, but more often than not, we need to return more than one view – several views might need to be <a id="_idIndexMarker033"/>displayed on the screen for the user to interact with in fact, such as a button, a text field, some images, text, and so on. We need to organize these views vertically and horizontally on the screen, as well as on the <em class="italic">z</em>-axis (placing views on top of each other). </p>
<p>To achieve this, SwiftUI gives us vertical, horizontal, and zed stacks, or <code>VStack</code>, <code>HStack</code>, and <code>ZStack</code> for short. These are container views that can hold 10 views inside them. The views inside them <a id="_idIndexMarker034"/>are know as <strong class="bold">child views</strong>. Let’s look at each now.</p>
<h3>VStack</h3>
<p>A <code>Text</code> view, and it displays <strong class="bold">Hello World!</strong> on the user’s screen.</p>
<p>But what if we want to have more <a id="_idIndexMarker035"/>than one view returned from inside the body computed property? Maybe we want to have a <code>Button</code> <em class="italic">and</em> a <code>Text</code> view on the screen, as in this code example:</p>
<pre class="source-code">
struct ContentView: View {
    @State var myText = ""
    @State var changeText = false
    var body: some View {
        Text(myText)
            .padding()
        Button("Button") {
            changeText.toggle()
            if changeText {
                myText = "Hello SwiftUI!"
            } else {
                myText = "Hello World!"
            }
        }
    }
}</pre>
<p>If we press <em class="italic">Command</em> + <em class="italic">B</em> to build this code, it builds cleanly and error-free. </p>
<p>But even though this code is error-free, nothing appears in the previews, so it won’t do anything when we press the<a id="_idIndexMarker036"/> play button to run it. The code won’t do anything because there are two views inside the body computed property: a <code>Text</code> view and a <code>Button</code> view. This violates the <code>View</code> protocol, which only wants <code>some View</code> returned (singular), not <code>some </code><code>Views</code> (plural).</p>
<p>Now, look at the same co<a id="_idTextAnchor027"/>de with a minor change made to it:</p>
<pre class="source-code">
struct ContentView: View {
    @State var myText = ""
    @State var changeText = false
    
    var body: some View {
        VStack {
            Text(myText)
                .padding()
          Button("Button") {
                changeText.toggle()
                if changeText {
                    myText = "Hello SwiftUI!"
                } else {
                    myText = "Hello World!"
                }
            }
        }
    }
}</pre>
<p>I have put all of the code <a id="_idIndexMarker037"/>inside the <code>VStack</code>. Now, when we run it, everything works as expected, and the two views can coexist inside the <code>body</code> computed property without any issues. If we press the button, the text will change depending on the value in the <code>changeText</code> property:</p>
<div><div><img alt="Figure 1.5: VStack " src="img/B18674_01_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: VStack</p>
<p>The <code>VStack</code> can hold 10 child views and is still considered to only return one view itself, so the <code>some View</code> protocol is satisfied. If you need more than 10 children, you can nest VStacks inside each other to add even more views. </p>
<p>The <code>VStack</code>, as you might <a id="_idIndexMarker038"/>imagine, will stack all of its children vertically, but you can also set an optional alignment and spacing within the <code>VStack</code> initializer too.</p>
<h4>Alignment</h4>
<p>By default, everything in the <code>VStack</code> is center-aligned, but if you want all of its child views aligned to<a id="_idIndexMarker039"/> the leading edge or trailing edge, you can use the <code>alignment</code> parameter like this:</p>
<pre class="source-code">
struct ContentView: View {
   var body: some View {
        VStack<strong class="bold">(alignment: .leading) </strong>{
      Text("Hi, I'm child one in this vertical stack")
      Text("Hi, I'm child two in this vertical stack")
      Text("Hi, I'm child three in this vertical stack")
      Text("Hi, I'm child four in this vertical stack, I'm the         best")
        }
    }}</pre>
<p>All the child views are now aligned to the leading edge within the <code>VStack</code>:</p>
<div><div><img alt="Figure 1.6: Leading alignment " src="img/B18674_01_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: Leading alignment</p>
<p>You can also align the views to the trailing edge or the center. To do that, we use dot syntax to access those other <code>enumeration</code> values: <code>.leading</code>, <code>.trailing</code>, or <code>.center</code> are the<a id="_idIndexMarker040"/> options available for alignment.</p>
<h4>Spacing</h4>
<p>The other parameter<a id="_idIndexMarker041"/> inside the <code>VStack</code> is the <code>spacing</code> option. This will put some space between all the child views:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack,               I'm the best")
        }
    }
}</pre>
<p>The code puts 10 <a id="_idIndexMarker042"/>points of space between each child view, as we can see here:</p>
<div><div><img alt="Figure 1.7: VStack spacing " src="img/B18674_01_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7: VStack spacing</p>
<p>That’s how the <code>VStack</code> works; let’s<a id="_idIndexMarker043"/> continue and look at the <code>HStack</code> now.</p>
<h3>HStack</h3>
<p>In contrast to a <code>VStack</code>, an <strong class="bold">HStack</strong> displays its <a id="_idIndexMarker044"/>children horizontally. Here’s an<a id="_idIndexMarker045"/> example:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        HStack() {
            Text("0")
            Text("1")
            Text("2")
            Text("3")
            Text("4")
            Text("5")
            Text("6")
            Text("7")
            Text("8")
            Text("9")
        }.font(.headline)
    }
}</pre>
<p>The number views are <a id="_idIndexMarker046"/>now all stacked horizontally:</p>
<div><div><img alt="Figure 1.8: HStack " src="img/B18674_01_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8: HStack</p>
<p>Adding a <code>font</code> modifier to<a id="_idIndexMarker047"/> the entire parent stack will affect all the children inside it, but to affect an individual child view, you need to place the modifier on it directly. Here is an example of doing that:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        HStack() {
            Text("0")
            Text("1")
            Text("2")
            Text("3")
            Text("4").font(.title)
            Text("5")
            Text("6")
            Text("7")
            Text("8")
            Text("9")
        }.font(.headline)
    }
}</pre>
<p>As a result, the <code>Text</code> view<a id="_idIndexMarker048"/> number of <code>4</code> has now been altered to have a larger font:</p>
<div><div><img alt="Figure 1.9: Modifying the child " src="img/B18674_01_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9: Modifying the child</p>
<p>Let’s look at another <a id="_idIndexMarker049"/>important stack, the <code>ZStack</code>.</p>
<h3>ZStack</h3>
<p>A <strong class="bold">ZStack</strong> is a stack that will <a id="_idIndexMarker050"/>overlay its children, one on top of another. With this stack, we can create <a id="_idIndexMarker051"/>a hierarchy of views, where the first view in the stack will be placed at the bottom, and subsequent views will be stacked up on top of each other in sequential order. Take a look at this example:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        ZStack() {
            Image(systemName: "rectangle.inset.filled.and.              person.filled")
                .renderingMode(.original)
                .resizable()
                .frame(width: 350, height: 250)
            
            Text("SwiftUI")
                .font(.system(size: 50))
                .foregroundColor(.yellow)
                .padding(.trailing, 80)
        }
    }
}</pre>
<p>The code contains two views:</p>
<ul>
<li>The first is the <code>Image</code> view, which <a id="_idIndexMarker052"/>accepts images that you have imported into the Assets catalog, and makes it possible to display the images on the screen. By using the <code>systemName</code> parameter, we can choose a system image from Apple’s stock of pre-made images, from many different categories.</li>
</ul>
<p>To use a system image in your projects, download the <code>Image</code> parameter called <code>systemName</code>. For my example, I’ve used an image called <code>rectangle.inset.filled.and.person.filled</code> and have placed it at the beginning of the <code>ZStack</code>; any view added underneath it will be placed on top of that image.</p>
<ul>
<li>The second view is a <code>Text</code> view, placed on top of the system image by the <code>ZStack</code>. Again, because the code for the <code>Text</code> view is added under the code that creates the <code>Image</code> view, it is <a id="_idIndexMarker053"/>placed on top of the <code>Image</code> view when we run the app.</li>
</ul>
<p>Then, I use a little bit of padding, and we can position that text where we want it. You can also use the <code>offset</code> modifier to place views anywhere on the screen.</p>
<p>You can see the result of the code in the following figure:</p>
<div><div><img alt="Figure 1.10: ZStack " src="img/B18674_01_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10: ZStack</p>
<p>There are also three modifiers in this code that we will look at in more depth when we start building the projects – that’s the <code>renderingMode</code>, <code>resizable</code>, and <code>frame</code> modifiers. They are used<a id="_idIndexMarker054"/> here because we need to render and resize the image correctly.</p>
<h3>Combining stacks</h3>
<p>Now that we have seen how<a id="_idIndexMarker055"/> the three stacks can be used to display multiple views and position them where we want them on the screen, let’s look at an example that combines all three stacks, and the child views inside them, to produce a varied layout:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack {
            ZStack() {
                Image(systemName: "cloud.moon.rain.fill")
                    .foregroundColor(Color(.systemOrange))
                    .font(.system (size: 150))
                Text("Stormy").bold()
                    .font(.system(size: 30))
                    .offset(x: -15, y: -5)
                    .foregroundColor(.indigo)
            }
            HStack() {
                Image(systemName: "tornado")
                    .foregroundColor(Color(.systemBlue))
                    .font(.system (size: 50))
                
                VStack(alignment: .leading) {
                    Text("Be prepared for anything")
                        .font(.system(size: 25))
                        .fontWeight(.bold)
                    
                    Text("With the Stormy Weather app")
                        .font(.system(size: 16))
                }
            }
        }
    }
}</pre>
<p>Let’s break down this code to get <a id="_idIndexMarker056"/>a clear understanding of what we are doing.</p>
<p>First is the <code>VStack</code>. This will be our main stack and will hold all of our code. Using the <code>VStack</code> in this way means we can squeeze 10 child views inside it, but we only need to place a couple of views inside for this example.</p>
<p>Next is the <code>ZStack</code>. Inside are its two child views – a <code>Text</code> view and an <code>Image</code> view. Since the <code>Image</code> view comes first in the code, the <code>Text</code> view gets placed on top of it.</p>
<p>Notice how each child view in the <code>ZStack</code> has its own set of modifiers that are indented; these are to style these child views with colors and sizes and to position them on the screen.</p>
<p>The next stack is the <code>HStack</code>. Remember that this arranges its children horizontally, and it has two child views, including an <code>Image</code> view and <code>VStack</code>. Notice how we can nest stacks inside of other stacks as we are doing here, with this <code>VStack</code> inside of a <code>HStack</code>. The <code>HStack</code> places its first child view to the left – that’s the tornado image – and then places its second child view to the right – that’s the <code>VStack</code>. If we look inside the <code>VStack</code> now, it has two child views of its own. They will be placed vertically, with the smaller text on the bottom.</p>
<p>Don’t worry if this nesting of <a id="_idIndexMarker057"/>stacks seems a bit confusing at first; as we start building projects, you will train your brain to think and see in hierarchies, and this will become very natural to you.</p>
<p>By nesting the different stacks, we can make all kinds of interesting layout scenes. Here is the result of our example:</p>
<div><div><img alt="Figure 1.11: Combining and nesting stacks " src="img/B18674_01_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11: Combining and nesting stacks</p>
<p>Stacks are great for helping to organize and lay our views out on the screen, but there is another container view we can use<a id="_idIndexMarker058"/> that offers even more flexibility. That’s the <code>GeometryReader</code> view. However, we will look at that at the end of the chapter.</p>
<p>For now, let’s look at a <code>Spacer</code> view – this is a view that helps with spacing out the layout in our UI design.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor028"/>Spacer views</h2>
<p>A <code>HStack</code>, a <code>Spacer</code> view expands <a id="_idIndexMarker060"/>horizontally as much as the stack allows, moving sibling views out of the way within the limits of the stack’s size. </p>
<p>This is the <code>Spacer</code> initializer: <code>Spacer(minLength: CGFloat)</code>. This initializer creates a flexible space. The <code>minLength</code> argument sets the minimum size that the space can take. If the argument is left empty, the minimum length is zero.</p>
<p>Here’s an example of using a <code>Spacer</code> view in a <code>HStack</code>:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        HStack {
            Text("Hello")
            Spacer()
            Text("World")
        }.padding()
    }
}</pre>
<p>This will create a horizontal stack with <code>Spacer</code> view will take up all of the remaining space so that the two pieces of text are pushed to the edges of the container:</p>
<div><div><img alt="Figure 1.12: Spacer " src="img/B18674_01_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12: Spacer</p>
<p>The <code>Spacer</code> view <a id="_idIndexMarker061"/>can also be used in the <code>VStack</code>, and it will expand and push the child views apart vertically<a id="_idIndexMarker062"/> instead of horizontally. The <code>Spacer</code> view won’t do anything within the <code>ZStack</code> though, as that stack deals with the depth of a view on the <em class="italic">z</em>-axis, front to back.</p>
<p>Where <code>Spacer</code> separates views by creating space between them, another object called a <code>Divider</code> view separates views with a thin line, either vertically or horizontally.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor029"/>Divider views</h2>
<p>A <strong class="bold">Divider view</strong> is a visual element, a dividing <a id="_idIndexMarker063"/>line, that can be used to separate <a id="_idIndexMarker064"/>content either horizontally or vertically. You can also alter the divider’s thickness. Let’s look at some examples.</p>
<h3>Horizontal</h3>
<p>The following code creates <a id="_idIndexMarker065"/>a horizontal divider:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            <strong class="bold">Divider().background(Color.black)</strong>
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }
}</pre>
<p>As you can see, we have added <a id="_idIndexMarker066"/>a horizontal dividing line and set its <a id="_idIndexMarker067"/>color to black using the <code>background</code> modifier:</p>
<div><div><img alt="Figure 1.13: Divider " src="img/B18674_01_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13: Divider</p>
<h3>Vertical</h3>
<p>If we want to change the horizontal line to a vertical one, then we can pass the <code>width</code> parameter using a smaller <a id="_idIndexMarker068"/>number, and the <code>height</code> parameter using a larger number, as in this example:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            
            Divider().frame(height: 200).frame(width:               3).background(Color.blue)
            Divider().frame(height:200).frame(width:               3).background(Color.blue).offset(x: 300, y: 0)
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }      
}</pre>
<p>Using the <code>offset</code> modifier lets <a id="_idIndexMarker069"/>us place the line anywhere on the screen, or on any view for that matter. Here is the result:</p>
<div><div><img alt="Figure 1.14: Vertical Divider view " src="img/B18674_01_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14: Vertical Divider view</p>
<h3>Thickness</h3>
<p>We can change the thickness <a id="_idIndexMarker070"/>of the dividing line using the <code>frame</code> modifier, like so:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            Divider().frame(height: 20).frame(width: 300).              background(Color.blue)
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }
}</pre>
<p>Then, by using the <code>height</code> and <code>width</code> parameters of the <code>frame</code> modifier, we can change the dimensions <a id="_idIndexMarker071"/>of the <code>Divider</code> view, so we can make a line as long and wide as we want. The result of our example can be seen here:</p>
<div><div><img alt="Figure 1.15: Divider thickness " src="img/B18674_01_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15: Divider thickness</p>
<p>That’s pretty much all the configuring we can do with the <code>Divider</code> view. Let’s now look at one of the most frequently used modifiers in SwiftUI – the <code>padding</code> modifier.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor030"/>The padding modifier</h2>
<p>You may have noticed that<a id="_idIndexMarker072"/> we have used the <strong class="bold">padding modifier</strong> quite a bit already without really explaining it yet.</p>
<p>Every view has its own dimensions and <a id="_idIndexMarker073"/>space that it takes up on the screen. For example, we can place two views side by side and they will be very close to each other, separated by only a few points. </p>
<p>Points and pixels refer to different ways of measuring the size of the views on the screen.</p>
<p><strong class="bold">Points</strong> are used to specify the size<a id="_idIndexMarker074"/> of text and other UI elements, and they are independent of the resolution of the device’s screen. This means that a point will always be the same size on any device, regardless of the screen’s resolution.</p>
<p><strong class="bold">Pixels</strong>, on the other hand, are <a id="_idIndexMarker075"/>the individual dots that make up the screen of an iPhone (or any other device). Pixels are used to measure the physical resolution of a device’s screen. </p>
<p>When you add a <code>padding</code> modifier to a view, it adds a small amount of empty space all around that view by default, and that space is measured in points. The <code>padding</code> modifier by default adds eight points of empty space around a view, but if you want to be more specific about the amount of space with which to pad your view, then you can pass in a value (an integer) for a custom amount of padding. Let’s look at an example:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                
            }.background(Color.yellow)
                .padding(30)
                .background(Color.red)
        }
    }
}</pre>
<p>In this code, there are four <code>Text</code> views<a id="_idIndexMarker076"/> inside the <code>VStack</code>. At the end of the VStack’s closing brace is a call to the <code>background</code> modifier, which will color the background yellow so that you can see the <code>padding</code> modifier at work. Next, I added the <code>padding</code> modifier and passed in <code>30</code> points, which will be applied around the <code>VStack</code> equally. Finally, I colored<a id="_idIndexMarker077"/> the padding red, again, using the <code>background</code> modifier, so you can see the padding directly. In the example, the padding will look like a red frame around <code>VStack</code>, as shown in the following screenshot:</p>
<div><div><img alt="Figure 1.16: Padding " src="img/B18674_01_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16: Padding</p>
<p>Let’s look at some <a id="_idIndexMarker078"/>of the other <code>padding</code> options. The modifier <a id="_idIndexMarker079"/>allows us to choose from predefined enum values if we only want to pad one side, as in the following code:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("The leading edge has been padded")
            }.padding(.leading, 75)
        }
    }
} </pre>
<p>This code pads<a id="_idIndexMarker080"/> only the <code>leading</code> edge of each <code>Text</code> view by <code>75</code> points <a id="_idIndexMarker081"/>of space: </p>
<div><div><img alt="Figure 1.17: Padding options " src="img/B18674_01_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17: Padding options</p>
<p>We can also choose other padding options by typing in a dot for the <code>alignment</code> parameter and selecting from many different options, including <code>trailing</code>, <code>top</code>, <code>bottom</code>, <code>horizontal</code>, <code>infinity</code>, and others.</p>
<p>Looking at the previous<a id="_idIndexMarker082"/> code, notice the placement of the <code>padding</code> modifier; it has been put on the closing brace of the <code>VStack</code>. When placed like this, all the children inside the <code>VStack</code> have the <a id="_idIndexMarker083"/>padding applied to them, but if we want to pad the child views individually, we can do so by placing modifiers directly on them:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
            }
        }
    }
}</pre>
<p>As you can see, you can add modifiers to child views individually, styling them as you need for your layout. The result is as follows:</p>
<div><div><img alt="Figure 1.18: Padding children " src="img/B18674_01_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18: Padding children</p>
<p>Each <a id="_idIndexMarker084"/>child view now<a id="_idIndexMarker085"/> has its own padding, either <code>leading</code> or <code>trailing</code>, which alters its placement on the screen.</p>
<p>Let’s finish up this chapter<a id="_idIndexMarker086"/> by looking at closures, which is essentially a function without a name, and then another container view that offers some more flexibility than the other stacks we previously looked at – the <code>GeometryReader</code> view.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor031"/>Closures</h2>
<p>Here is the easy definition of a <strong class="bold">closure</strong>: a closure is a function without a name. Remember a<a id="_idIndexMarker087"/> function is a block of code that runs whatever code statements are in its body when it is called.</p>
<p>But let’s look at a more <a id="_idIndexMarker088"/>detailed definition of a closure: a closure is a self-contained block of code that can be passed around and executed at a later time.</p>
<p>Closures are not exactly functions, but they are similar, with some key differences: </p>
<ul>
<li>Closures can be stored as variables and passed as arguments to functions</li>
<li>Closures can capture and store references to any variables or constants from the context in which they are defined, which allows them to maintain the state and preserve data between invocations</li>
<li>Closures don’t have a name as a function would</li>
</ul>
<p>In SwiftUI, closures are often used as a way to respond to user input or other events. For example, you might use a closure as the action for a button, or to provide a block of code to be executed when a view appears or disappears.</p>
<p>Here’s an example of a closure being used as the action for a button in SwiftUI:</p>
<pre class="source-code">
Button(action: {
    // this block of code will be run when the button is       clicked
    print("Button was clicked!")
}) {
    Text("Button")
}</pre>
<p>In this example, the closure is defined using the <code>{ }</code> syntax and is passed as the <code>action</code> parameter to the <code>Button</code> view. Yes, that’s right, the <code>Button</code> action is a closure, and when<a id="_idIndexMarker089"/> the button is pressed, the code inside the closure will be executed.</p>
<p>Closures can also<a id="_idIndexMarker090"/> be used to provide custom behavior for views in SwiftUI. For example, you might use a closure to perform some custom animation when a view appears or disappears:</p>
<pre class="source-code">
struct MyView: View {
    var body: some View {
        Text("Hello, SwiftUI!")
            .onAppear {
                // this block of code will run when the view                   appears
                print("The view appeared!")
            }
    }
}</pre>
<p>In this example, the <code>onAppear</code> modifier is called on the <code>Text</code> view and is passed a closure that will be executed when the view appears on the screen.</p>
<p>We also have trailing closures. A trailing closure is a closure that is written after the function or method it is passed to. The closure is “trailing” because it comes after the function or method.</p>
<p>Here’s an example of a function that takes a closure as an argument:</p>
<pre class="source-code">
func doSomething(completion: () -&gt; Void) {
    // Do some work!
    print("Work complete")
    completion()
}</pre>
<p>Here’s how you would <a id="_idIndexMarker091"/>call this function and pass a closure as an argument:</p>
<pre class="source-code">
doSomething {
    // this block of code will run when the "completion"       closure is called
    print("completion closure called!")
}</pre>
<p>In this example, the <a id="_idIndexMarker092"/>closure is written after the <code>doSomething</code> function and is therefore a trailing closure. In SwiftUI, you can use trailing closures to provide custom behavior for views. For example, you might use a trailing closure to perform some custom animation when a view appears or disappears:</p>
<pre class="source-code">
Text("Hello, World!")
    .onAppear {
        // this block of code will be executed when the view           appears
        print("View appeared!")
    }</pre>
<p>In this example, the <code>onAppear</code> method is called on the <code>Text</code> view and is passed a trailing closure that will be executed when the view appears on the screen.</p>
<p>Don’t worry if you haven’t quite grasped how closures work yet; they are not as complicated as they appear, and you will understand them better as we progress throughout the book. For now, let’s move on to <code>GeometryReader</code>.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor032"/>GeometryReader</h2>
<p>The <code>GeometryReader</code> will contain the position and size of the view we are working with, and we can then alter or place that view however we want with the values that are returned by <code>GeometryReader</code>’s proxy.</p>
<p>Using these values, we can<a id="_idIndexMarker094"/> make the child views dynamically update their position depending on the device size and position when the orientation changes to either landscape or portrait. This all will become clearer when we see an example. </p>
<p>Let’s look at how to create <code>GeometryReader</code>. The following is the initializer used to create the <code>GeometryReader</code> view:</p>
<pre class="source-code">
GeometryReader(content: _)</pre>
<p>The <code>content</code> parameter is a <a id="_idIndexMarker095"/>closure that receives a geometry proxy value with the view’s position and dimensions. </p>
<p>To retrieve those values, we use the following properties and method:</p>
<ul>
<li>The <code>size</code> property will return the width and height of the <code>GeometryReader</code> view</li>
<li>The <code>safeAreaInsets</code> property will return an <code>EdgeInsets</code> value with the insets for the safe area</li>
<li>The <code>frame(in: )</code> method returns the position and size of the <code>GeometryReader</code> view</li>
</ul>
<p>Here is the code to create an empty <code>GeometryReader</code>: </p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
           GeometryReader {_ in
            //empty geometry reader
        }.background(Color.yellow)
     }
  }</pre>
<p>This is what we see when we run the code. Notice how it pushes itself out to occupy all the space on the screen; the <a id="_idIndexMarker096"/>yellow background shows all the areas of this empty <code>GeometryReader</code>, which is the entire screen.</p>
<div><div><img alt="Figure 1.19: GeometryReader " src="img/B18674_01_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19: GeometryReader</p>
<p>The default behavior <a id="_idIndexMarker097"/>of <code>GeometryReader</code> is to align its children in the upper-left corner and place them on top of each other. In this next example, the code places three views inside <code>GeometryReader</code>:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        GeometryReader {_ in
             Image(systemName: "tornado")
             Image(systemName: "tornado")
             Image(systemName: "tornado")
               }.background(Color.yellow)
            .font(.largeTitle)
    }
}</pre>
<p>When we run this code, notice<a id="_idIndexMarker098"/> that only one tornado image is visible:</p>
<div><div><img alt="Figure 1.20: GeometryReader default child alignment " src="img/B18674_01_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20: GeometryReader default child alignment</p>
<p>There are <a id="_idIndexMarker099"/>actually three tornado images in this example, but you can only see one because the default <a id="_idIndexMarker100"/>behavior is to place them on top of each other in the upper-left corner.</p>
<p>We obviously don’t want all the child views stacked on one another, so we will explore the following concepts to really utilize <code>GeometryReader</code>:</p>
<ul>
<li>Sizing a view to accommodate rotating the device</li>
<li>Positioning a view anywhere on the screen</li>
<li>Reading a view’s position in terms of its global and local space</li>
</ul>
<p>We’ll look at these<a id="_idIndexMarker101"/> now.</p>
<h3>Sizing views</h3>
<p>Let’s first look at the property that is <a id="_idIndexMarker102"/>used to access the <code>GeometryReader</code>’s size... aptly named, the <code>size</code> property. This will return the width and height of the <code>GeometryReader</code> view. </p>
<p>Here is an example of adding an image inside the <code>GeometryReader</code> view, and seeing how it adapts its size when the device is rotated:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View          
 GeometryReader { geometryProxy in
            Image("swiftui_icon")
                .resizable()
                .scaledToFit()
                .frame(width: geometryProxy.size.width / 2,                   height: geometryProxy.size.height / 4)
                .background(Color.gray)
        }
    }
}</pre>
<p>The following figure shows the size of the image in portrait mode:</p>
<div><div><img alt="Figure 1.21: GeometryReader size property (portrait) " src="img/B18674_01_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21: GeometryReader size property (portrait)</p>
<p>In portrait mode, the image is<a id="_idIndexMarker103"/> bigger, but when the device is rotated to landscape, the image scales down to adapt to the screen change, as shown here:</p>
<div><div><img alt="Figure 1.22: GeometryReader size property (landscape) " src="img/B18674_01_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22: GeometryReader size property (landscape)</p>
<p>In this example, we added an <code>Image</code> view within a <code>GeometryReader</code> view. I defined the <code>Proxy</code> parameter as <code>geometryProxy</code>, but you can call it anything you want. <code>geometryProxy</code> holds the information about <code>GeometryReader</code>’s dimensions and position. Using this <code>Proxy</code> object, the <a id="_idIndexMarker104"/>size of the image is changed when we rotate the device. The image will be half the width of the container, and the height will be a quarter of the height of the container. </p>
<p>Using <code>geometryProxy.size</code> lets us access the height and width of <code>GeometryReader</code>. The <code>Image</code> view will adapt when the device is rotated. I’m also using the <code>scaledToFit</code> modifier so that we can keep the correct aspect ratio for the image.</p>
<p>I set the <code>Image</code> view’s background to gray so that you can see the space that’s available in both portrait and landscape modes. When it’s in landscape mode, there’s much more space available around the <code>Image</code> view because it scales down.</p>
<p>Also notice that the image is positioned in the top-left corner of the <code>GeometryReader</code> view. Again, that’s the default location for its child views; they will simply stack up on each other in that area. </p>
<p>Next, we will look at positioning those child views anywhere we want within the <code>GeometryReader</code> container.</p>
<h3>Positioning views</h3>
<p>We’ve seen how <code>GeometryReader</code> can dynamically change the size of a view as it’s rotated, but it can also position the views<a id="_idIndexMarker105"/> within it. The positioning information is returned by the <code>geometryProxy</code> closure, and we can pass that information into the <code>x</code> and <code>y</code> parameters of the <code>position</code> modifier via the <code>size</code> property. Here’s an example:</p>
<pre class="source-code">
 struct ContentView: View {
    var body: some View {
 
GeometryReader { geometryProxy in
            //top right position
            VStack {
                Image(systemName: "tornado")
                .imageScale(.large)
            Text("Top Right")
                .font(.title)
            }.position(x: geometryProxy.size.width - 80, y:               geometryProxy.size.height / 40)
 
            //bottom left position
            VStack {
                Image(systemName: "tornado")
                .imageScale(.large)
                
            Text("Bottom Left")
                .font(.title)
            }.position(x: geometryProxy.size.width - 300,y:               geometryProxy.size.height - 40)
        }.background(Color.accentColor)
        .foregroundColor(.white)
    }
}</pre>
<p>The code here has two VStacks within <code>GeometryReader</code>, and each <code>VStack</code> has the <code>position</code> modifier on its closing brace, so everything within the VStacks will be positioned according to the<a id="_idIndexMarker106"/> values in the <code>position</code> modifier’s <code>x</code> and <code>y</code> parameters.</p>
<p>The result when running this code is the placement of the <code>Image</code> and <code>Text</code> views according to the <code>size.width</code> and <code>size.height</code> values, as shown in this figure: </p>
<div><div><img alt="Figure 1.23: GeometryReader positioning views " src="img/B18674_01_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23: GeometryReader positioning views</p>
<p>Let’s continue <a id="_idIndexMarker107"/>with <code>GeometryReader</code> and see how we can read the values of its position.</p>
<h3>Reading the position</h3>
<p>If we need to get the position of the <code>GeometryReader</code> view in terms of its <code>coordinate</code> location, again, we can use the <code>geometryProxy</code> object and pass its information into the <code>frame()</code> method.</p>
<p>There are two coordinate spaces<a id="_idIndexMarker108"/> in SwiftUI: </p>
<ul>
<li><strong class="bold">Global space</strong>: The coordinates <a id="_idIndexMarker109"/>of the entire screen</li>
<li><strong class="bold">Local space</strong>: The coordinates <a id="_idIndexMarker110"/>of individual views</li>
</ul>
<p>When reading the values of the local coordinate space of the <code>GeometryReader</code> view, we will always see <code>0,0</code> for <code>x</code> and <code>y</code>. That’s because <code>GeometryReader</code> always starts at that position, <code>0,0</code>, the top-left corner of the screen.</p>
<p>So, to get the position of the views in relation to where they are on the screen, we need to use the global coordinates. Here is an example that gets and displays the local and global values for the <code>GeometryReader</code> view:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        GeometryReader { geometryProxy in
            VStack {
                Image("SwiftUIIcon")
                    .resizable()
                    .scaledToFit()
                Text("Global").font(.title)
                Text("X, Y \(geometryProxy.frame(in:                   CoordinateSpace.global).origin.x, specifier:                   "(%.f,") \(geometryProxy.frame(in: .global).                  origin.y, specifier: "%.f)")")
                Text("Local").font(.title)
                Text("X, Y  \(geometryProxy.frame(in: .local).                  origin.x, specifier: "(%.f") \(geometryProxy.                  frame(in: .local).origin.y, specifier:                   "%.f)")")
            }
        }.frame(height: 250)
    }
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">Notice that the values are being formatted using a format specifier: <code>%.f</code>. This format specifier will truncate some of the decimal places so it displays fewer zeros.</p>
<p>Running the code will <a id="_idIndexMarker111"/>display the <code>x</code> and <code>y</code> coordinate values for both the global and local space for the views, when the device is in portrait mode, as shown here:</p>
<div><div><img alt="Figure 1.24: Reading the position (portrait) " src="img/B18674_01_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.24: Reading the position (portrait)</p>
<p>Rotating the device into landscape mode<a id="_idIndexMarker112"/> changes the global values to reflect the new location of the <code>Image</code> and <code>Text</code> views, as shown here:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div><div><img alt="Figure 1.25: Reading the position (landscape) " src="img/B18674_01_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.25: Reading the position (landscape)</p>
<p>The code in this example demonstrates the difference between the global and local coordinate spaces. The values for the local coordinate space always return <code>0,0</code> because that is the starting position of <code>GeometryReader</code>, but the values for the global coordinate space are the origin of the <code>geometryProxy</code> frame within the entire screen. So, the global values change <a id="_idIndexMarker113"/>as the device is rotated because the view’s position has changed. The local values do not change as they reflect the screen’s upper-left corner, <code>0,0</code>.</p>
<p>SwiftUI also offers properties to get the minimum, middle, and maximum coordinate positions from within <code>GeometryReader</code>’s frame for both the global and local spaces:</p>
<pre class="source-code">
Text("minX: \(geometryProxy.frame(in: .local).minX))")
Text("minX: \(geometryProxy.frame(in: .local).midX))")
Text("maxX: \(geometryProxy.frame(in: .local).maxX))")
Text("minX: \(geometryProxy.frame(in: .global).minY))")
Text("minX: \(geometryProxy.frame(in: .global).midY))")
Text("maxX: \(geometryProxy.frame(in: .global).maxY))")</pre>
<p>We use these properties with dot<a id="_idIndexMarker114"/> syntax, right at the end of the <code>frame</code> method. Here is an example: </p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        GeometryReader { geometryProxy in
            VStack() {
                Spacer()
                Text("Local Values").font(.title2).bold()
                HStack() {
                    Text("minX: \(Int(geometryProxy.frame(in:                       .local).minX))")
                    Spacer()
                    Text("midX: \(Int(geometryProxy.frame(in:                       .local).midX))")
                    Spacer()
                    Text("maxX: \(Int(geometryProxy.frame(in:                       .local).maxX))")
                }
                
                Divider().background(Color.black)
                
                Text("Global Values").font(.title2).bold()
                HStack() {
                    Text("minX: \(Int(geometryProxy.frame(in:                       .global).minX))")
                    Spacer()
                    Text("midX: \(Int(geometryProxy.frame(in:                       .global).midX))")
                    Spacer()
                    Text("maxX: \(Int(geometryProxy.frame(in:                       .global).maxX))")
                }
                Spacer()
                
            }.padding(.horizontal)
        }
    }
}</pre>
<p>This code will return the <a id="_idIndexMarker115"/>minimum, the middle, and the maximum <code>x</code> and <code>y</code> coordinates for <code>GeometryReader</code>’s frame and display them on the screen for both local and global spaces in portrait mode, as shown here:</p>
<div><div><img alt="Figure 1.26: Using the min, mid, and max properties (portrait) " src="img/B18674_01_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.26: Using the min, mid, and max properties (portrait)</p>
<p>When the device is rotated, those <a id="_idIndexMarker116"/>values will adjust to new values that reflect the change in the screen’s orientation, as shown here:</p>
<div><div><img alt="Figure 1.27: Using the min, mid, and max properties (landscape) " src="img/B18674_01_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.27: Using the min, mid, and max properties (landscape)</p>
<p>The SwiftUI structures you have <a id="_idIndexMarker117"/>just learned about will be the building blocks for the programs we will write going forward. Rather than listing all the structures in one chapter, which can be a lot to take in, I will introduce new ones in different projects throughout the book.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor033"/>Summary</h1>
<p>To sum up what we learned in this chapter, we introduced SwiftUI and saw the difference between the two programming paradigms, imperative and declarative. After that, we explored the Xcode interface. Then, we covered the important function of the state, and finally looked at the building blocks of SwiftUI – these are fundamentals that you will use throughout this book and are an essential first step toward creating beautiful animations in SwiftUI.</p>
<p>In the next chapter, we will explore animations, how they work, and the kinds of properties that can be animated.</p>
</div>
<div><div></div>
</div>
</body></html>