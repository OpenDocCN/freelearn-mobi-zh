<html><head></head><body>
<div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">Exploring the Fundamentals of SwiftUI</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Animating SwiftUI Applications</span></em><span class="koboSpan" id="kobo.5.1">! </span><span class="koboSpan" id="kobo.5.2">If you picked up this book, then there’s a good chance you are a developer – or aspiring to be one – and you want to learn more about SwiftUI animations. </span><span class="koboSpan" id="kobo.5.3">Or maybe you’re fascinated by animations and how they work like I am. </span><span class="koboSpan" id="kobo.5.4">I know for me that the first time I played a video game (before the home computer was even available) and saw objects collide and bounce off each other on the screen, I was hooked by animations and the code behind how they worked. </span><span class="koboSpan" id="kobo.5.5">Whatever the reason you’re here though, together we will explore the amazing things we can make happen on an Apple device by leveraging the power of SwiftUI’s animation classes, methods, </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and properties.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This chapter starts with a brief look at the two programming styles, imperative and declarative, and will give you an idea of why Apple introduced the declarative SwiftUI way of coding to the development world. </span><span class="koboSpan" id="kobo.7.2">Then, we’ll explore the Xcode interface, the free application from Apple, where we do all of our work. </span><span class="koboSpan" id="kobo.7.3">Finally, we’ll look at the SwiftUI structures needed to develop apps, which is the foundation for proceeding further </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">with animations.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Understanding imperative and declarative programming </span></li>
<li><span class="koboSpan" id="kobo.12.1">Exploring the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Xcode interface</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">the state</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">SwiftUI structures</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">In order to write code that can run on Apple devices, first, we need an Apple computer.  </span><span class="koboSpan" id="kobo.19.2">This can be any of their models, but the MacBook Pro is the most popular for coding because of its power and speed. </span></p>
<p><span class="koboSpan" id="kobo.20.1">Once we have the hardware, then the next bit of tech we need to write code is the software. </span><span class="koboSpan" id="kobo.20.2">Apple has put together a very comprehensive set of tools all bundled into one program called Xcode, which is free to download from the App Store. </span><span class="koboSpan" id="kobo.20.3">Those two things are everything you need to start writing code on Apple, but if you want to upload your finished app to the App Store, then you will need an Apple Developer account. </span><span class="koboSpan" id="kobo.20.4">This currently costs $99 a year to maintain, but it is necessary to be able to sell your apps to the world. </span><span class="koboSpan" id="kobo.20.5">Go to </span><a href="http://developer.apple.com"><span class="koboSpan" id="kobo.21.1">developer.apple.com</span></a><span class="koboSpan" id="kobo.22.1"> and sign up for an </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">account there.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">You should also have a working knowledge of the Swift programming language so that you feel comfortable writing code, but you don’t have to be an expert by any means; it’s just that it is very helpful if you understand, or at least recognize, the syntax of the Swift language and the </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.25.1">fundamentals of </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">OOP</span></strong><span class="koboSpan" id="kobo.29.1">) so that you can follow along with the projects better. </span></p>
<p><span class="koboSpan" id="kobo.30.1">With that said, if you are a complete beginner to writing code, you might be a bit confused here – but not to worry, when Apple introduced the Swift programming language in 2014, they held fast to their goal of making one of the easiest-to-pick-up and most user-friendly programming languages to date. </span><span class="koboSpan" id="kobo.30.2">And for the most part, the Swift language reads like English sentences, so you can progress very quickly. </span></p>
<p><span class="koboSpan" id="kobo.31.1">Here is what I recommend when you’re just starting out </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">learning Swift:</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Start with the Swift tutorials offered by Paul Hudson. </span><span class="koboSpan" id="kobo.33.2">He is a brilliant Swift programmer, and one of the most prolific in the industry. </span><span class="koboSpan" id="kobo.33.3">He has put together tons of free Swift training tutorials and videos that get you to write code fast. </span><span class="koboSpan" id="kobo.33.4">I have worked with Paul on many projects, and you would be hard-pressed to find a better and more thorough teaching style – he’s also just an all-around nice guy. </span><span class="koboSpan" id="kobo.33.5">Check out all his stuff </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at </span></span><a href="http://hackingwithswift.com"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">hackingwithswift.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Someone else I have worked with (and continue to work with) is John D. </span><span class="koboSpan" id="kobo.37.2">Gauchat. </span><span class="koboSpan" id="kobo.37.3">He has put together a Swift and SwiftUI Mastermind series of books that can serve as both a reference and a guide/cookbook of code for when you need to remember the syntax or how to implement something fast. </span><span class="koboSpan" id="kobo.37.4">He is very thorough as well, and you can find his work </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">at </span></span><a href="http://jdgauchat.com"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">jdgauchat.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Finally, if you like structured video courses, I have translated many of Paul’s and John’s Swift and SwiftUI books into video courses, and they are available over at </span><a href="http://udemy.com"><span class="koboSpan" id="kobo.42.1">udemy.com</span></a><span class="koboSpan" id="kobo.43.1"> – just search for my name to see them all, including the video version of this book (which includes extra projects). </span></p>
<p><span class="koboSpan" id="kobo.44.1">OK, that’s enough of those shameful plugs, but if you are a complete beginner, I want you to learn the Swift programming language from the very best, and those two guys are; this way, you will be ready to follow along and code in no time. </span><span class="koboSpan" id="kobo.44.2">So, go get some Swift knowledge under your belt, and come back here. </span><span class="koboSpan" id="kobo.44.3">I’ll wait… </span></p>
<p><span class="koboSpan" id="kobo.45.1">Finally, to access all of the code in this book, go to the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">repository: </span></span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.49.1">Understanding imperative and declarative programming</span></h1>
<p><span class="koboSpan" id="kobo.50.1">SwiftUI is a fairly new framework introduced by Apple in 2019 that includes intuitive new design tools that help make building great-looking interfaces almost as easy as dragging and dropping… almost. </span><span class="koboSpan" id="kobo.50.2">With its modular approach, it’s estimated that you can build the same projects previously built in Xcode using about five times less code. </span><span class="koboSpan" id="kobo.50.3">Also, SwiftUI was Apple’s solution for building apps that can easily be used on all of their other platforms – so, an app can be built once, and it will</span><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.51.1"> perform perfectly on iOS, tvOS, macOS, </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">and watchOS.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The SwiftUI interface, which</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.54.1"> we will cover shortly, uses editor and canvas preview windows that work in tandem. </span><span class="koboSpan" id="kobo.54.2">As you code in the Xcode editor, the new design canvas displays everything completely in sync and renders in real time as you type. </span><span class="koboSpan" id="kobo.54.3">So, any change you make in the editor is immediately reflected in the canvas preview, and vice versa. </span></p>
<p><span class="koboSpan" id="kobo.55.1">I mentioned the ease of drag and dropping in code earlier; this is because those nice engineers at Apple must have spent countless nights working hard putting together a huge selection of pre-made chunks of code called views and modifiers that you can drag and drop right into the editor. </span><span class="koboSpan" id="kobo.55.2">This includes things such as buttons, labels, menus, lists, pickers, forms, text fields, toggle switches, modifiers, events, navigation objects, effects, and well, much more, but you get the point. </span><span class="koboSpan" id="kobo.55.3">Unlike UIKit and Storyboards, when you drop a view or a modifier into the editor or on the canvas, SwiftUI generates the code for that </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">view automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The SwiftUI approach to app </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.58.1">development is known as </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">declarative programming</span></strong><span class="koboSpan" id="kobo.60.1">, and it has become widely popular in the last few years. </span><span class="koboSpan" id="kobo.60.2">Examples of declarative programming would include frameworks such as React and cross-platform development frameworks such as React Native and Flutter. </span><span class="koboSpan" id="kobo.60.3">So, now it’s Apple’s turn to offer its own completely native declarative UI framework, SwiftUI. </span></p>
<p><span class="koboSpan" id="kobo.61.1">But what does declarative programming actually mean? </span><span class="koboSpan" id="kobo.61.2">Well, to best describe declarative programming, let’s first understand what imperative programming is. </span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.62.1">Imperative programming</span></strong><span class="koboSpan" id="kobo.63.1"> has been the</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.64.1"> oldest programming paradigm since the dawn of computer languages. </span><span class="koboSpan" id="kobo.64.2">The word “imperative” has its origin in the Latin word “imperare”, which means “to command,” and it was first used to express a command – for example: “do it”! </span><span class="koboSpan" id="kobo.64.3">(Hmm, I wonder whether Nike borrowed that imperative command and tweaked it a little…) This style of programming is what iOS developers used before SwiftUI came out. </span></p>
<p><span class="koboSpan" id="kobo.65.1">Imperative programming is a programming paradigm that uses statements that change a program’s state. </span><span class="koboSpan" id="kobo.65.2">These statements are executed in a specific order, and they usually involve assignment statements, loops, and control structures that specify how the computation should be </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">carried out.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">In imperative programming, the programmer specifies exactly how the computation should be carried out, using statements that tell the computer what to do. </span><span class="koboSpan" id="kobo.67.2">This can make imperative programs more complex because the programmer has to specify all of the steps of computation. </span><span class="koboSpan" id="kobo.67.3">However, it can also make them more flexible because the programmer has more control over the details of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">the computation.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Here is an example of imperative programming using the UIKit framework </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">in iOS:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
let button = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))
button.setTitle("Button", for: .normal)
button.setTitleColor(.black, for: .normal)
button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
view.addSubview(button)</span></pre>
<p><span class="koboSpan" id="kobo.72.1">This code creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">UIButton</span></strong><span class="koboSpan" id="kobo.74.1">, sets its title and title color, and adds an action to be performed when the</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.75.1"> button is tapped. </span><span class="koboSpan" id="kobo.75.2">It then adds the button to the view hierarchy. </span><span class="koboSpan" id="kobo.75.3">This code is imperative because it specifies the exact steps needed to create and configure the button and add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the view.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Now, this same code could also be written in a declarative style using a library such as SwiftUI, ReactiveCocoa, or RxSwift, which allows </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.78.1">you to specify the desired behavior of the button rather than the steps needed to achieve it. </span><span class="koboSpan" id="kobo.78.2">Here is the same example written </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">using SwiftUI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.80.1">
import SwiftUI
struct ContentView: View {
    var body: some View {
        Button(action: {
            // action to be performed when button is tapped
        }) {
            Text("Button")
                .font(.title)
                .foregroundColor(.black)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.81.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Button</span></strong><span class="koboSpan" id="kobo.83.1"> view is declarative, because it specifies the desired behavior of the button (displaying text and performing an action when tapped), rather than the steps needed to create and configure </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the button.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">SwiftUI uses a declarative style of programming, which can make it easier to understand and maintain your code because you don’t have to specify all of the intermediate steps needed to achieve the desired behavior. </span><span class="koboSpan" id="kobo.85.2">It also allows your code to automatically update when the underlying data changes because you specify the desired outcome rather than the steps needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">achieve it.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">So, declarative programming is a</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.88.1"> programming paradigm in which a program specifies what it wants to achieve, rather than how to achieve it. </span><span class="koboSpan" id="kobo.88.2">The focus is on the “what” rather than the “how.” </span><span class="koboSpan" id="kobo.88.3">Declarative programs are usually easier to understand because they don’t require the </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.89.1">programmer to specify every single step of the computation. </span><span class="koboSpan" id="kobo.89.2">They can also be more concise because they don’t need to specify all of the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">intermediate steps.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">There are many different programming languages and technologies that support declarative programming, including SQL, HTML, and functional programming languages such as Haskell and Lisp. </span><span class="koboSpan" id="kobo.91.2">In general, declarative programming is well suited to tasks that involve defining data relationships or specifying a desired output, rather than specifying the steps needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">achieve something.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">To clarify, let’s use the analogy of an artist: imperative languages paint by numbers to reach the desired result, a finished painting, but declarative languages use the finished painting and let background algorithms (functions and methods) automatically choose the appropriate colors and brush strokes to achieve the desired result. </span><span class="koboSpan" id="kobo.93.2">Also, by using this declarative approach, SwiftUI minimizes or eliminates programming side effects, usually caused by tracking the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the program.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.95.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.96.1">You will want to keep in mind that in many cases, code will be a mixture of both imperative and declarative styles, so it’s not always one or </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">With a better understanding of SwiftUI now, we will proceed to an overview of the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">Xcode interface.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.100.1">Exploring the Xcode interface</span></h1>
<p><span class="koboSpan" id="kobo.101.1">In this section, we will </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.102.1">take a tour of the Xcode interface. </span><span class="koboSpan" id="kobo.102.2">I’m assuming that you have used Xcode before, practicing your Swift skills, which means you have a good handle on many of the things here in the interface. </span><span class="koboSpan" id="kobo.102.3">However, there are a few new additions to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">accommodate SwiftUI.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">When you first start up Xcode, you see the welcome screen. </span><span class="koboSpan" id="kobo.104.2">On the right is a list of recent projects, and on the left, there are buttons to start a new project, open an existing project, or clone one saved in </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">a repository.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer005">
<span class="koboSpan" id="kobo.106.1"><img alt="Figure 1.1: Xcode welcome screen " src="image/B18674_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.107.1">Figure 1.1: Xcode welcome screen</span></p>
<p><span class="koboSpan" id="kobo.108.1">We will be using the</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.109.1"> first option, which is </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Create a new Xcode project</span></strong><span class="koboSpan" id="kobo.111.1">, for all of our projects, so </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">select that.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The next screen lets us choose options for </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the project:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 1.2: Project options  " src="image/B18674_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 1.2: Project options </span></p>
<p><span class="koboSpan" id="kobo.117.1">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">these options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Product Name</span></strong><span class="koboSpan" id="kobo.120.1">: This will be the </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.121.1">name of the project. </span><span class="koboSpan" id="kobo.121.2">You should select a name that is directly related to what the project </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">will do.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">Team</span></strong><span class="koboSpan" id="kobo.124.1">: This will be the developer account you created with your Apple ID at </span><a href="http://developer.apple.com"><span class="koboSpan" id="kobo.125.1">developer.apple.com</span></a><span class="koboSpan" id="kobo.126.1">, or a company account if you </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">have one.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Organization Identifier</span></strong><span class="koboSpan" id="kobo.129.1">: Xcode will take this value and add it to the project’s name to create a unique bundle identifier for your app. </span><span class="koboSpan" id="kobo.129.2">It is recommended to write the identifier out with an inverted domain, as I did in the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">example (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">com.SMDAppTech</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">).</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.133.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.134.1">If you were wondering why Apple requires this reverse notion, here’s a deeper explanation. </span><span class="koboSpan" id="kobo.134.2">Reverse domain name notation (or reverse DNS) is a system used to map an IP address to a domain name. </span><span class="koboSpan" id="kobo.134.3">Reverse DNS strings are based on registered domain names, with the order of the components reversed for grouping purposes. </span><span class="koboSpan" id="kobo.134.4">Here is an example: if a company making a product called MyProduct has the domain name </span><a href="http://exampleDomain.com"><span class="koboSpan" id="kobo.135.1">exampleDomain.com</span></a><span class="koboSpan" id="kobo.136.1">, they could use a reverse DNS string of </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">com.exampleDomain.MyProduct</span></strong><span class="koboSpan" id="kobo.138.1"> as an identifier for that product. </span><span class="koboSpan" id="kobo.138.2">Reverse DNS names are a simple way of eliminating namespace collisions since any domain name is globally unique to its </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">registered owner.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Interface</span></strong><span class="koboSpan" id="kobo.141.1">: This is </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.142.1">where we select the technology we will use to design the UI. </span><span class="koboSpan" id="kobo.142.2">From the drop-down list, you can choose </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">SwiftUI</span></strong><span class="koboSpan" id="kobo.144.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Storyboard</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">SwiftUI is a system that lets us declare the interface from code, while Storyboard is a graphical system that allows us to drag and drop many components and controls onto a storyboard to create the user interface – we want to select </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">SwiftUI</span></strong><span class="koboSpan" id="kobo.148.1">. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.149.1">A quick note: even though we drag and drop onto the storyboard in that option, the code is not generated after you drop an object onto the board. </span><span class="koboSpan" id="kobo.149.2">You still have to write out the code for each object and make connections for buttons and other controls. </span><span class="koboSpan" id="kobo.149.3">Whereas in SwiftUI, you can drag and drop similar components, and the code is automatically propagated in the editor for you. </span><span class="koboSpan" id="kobo.149.4">You then fill out the body with what you want it </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">to do.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Language</span></strong><span class="koboSpan" id="kobo.152.1">: This is the coding language; here, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.154.1">Swift</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.156.1">We don’t need to use core data, which is a way of persisting your data so it always loads back up again, and we don’t need to include tests for any of </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the projects.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.158.1">When we hit </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">Next</span></strong><span class="koboSpan" id="kobo.160.1">, we’re asked where to save the project. </span><span class="koboSpan" id="kobo.160.2">I like to save it on the desktop, but you can choose any location </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">you want.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">And now we are in the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Xcode interface:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.164.1"><img alt="Figure 1.3: Xcode interface " src="image/B18674_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.165.1">Figure 1.3: Xcode interface</span></p>
<p><span class="koboSpan" id="kobo.166.1">The Xcode interface is the</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.167.1"> part of Xcode where we do all of our coding. </span><span class="koboSpan" id="kobo.167.2">It is split up into different sections; here are those </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">sections explained:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">Project </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.170.1">Navigator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.172.1">1)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.174.1">This is a collapsible space that contains all the project files. </span><span class="koboSpan" id="kobo.174.2">A file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">ContentView</span></strong><span class="koboSpan" id="kobo.176.1"> is here, into which we can write our code, and we can create more files as the project grows. </span><span class="koboSpan" id="kobo.176.2">If you have worked in Xcode before with UIKit, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">ContentView</span></strong><span class="koboSpan" id="kobo.178.1"> file is analogous to UIKit’s View Controller, where it had the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">ViewDidLoad</span></strong><span class="koboSpan" id="kobo.180.1"> method, in which we would usually load some user interface code. </span><span class="koboSpan" id="kobo.180.2">Here, we put the UI code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">ContentView</span></strong><span class="koboSpan" id="kobo.182.1"> struct and create other structs as needed. </span><span class="koboSpan" id="kobo.182.2">We can also organize all these files by creating and naming new groups and folders. </span><span class="koboSpan" id="kobo.182.3">There’s another file here called </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Assets.xcassets</span></strong><span class="koboSpan" id="kobo.184.1"> (also called the Assets catalog), where we place the images and colors needed for our project. </span></p>
<p><span class="koboSpan" id="kobo.185.1">Looking at the top of the </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Project Navigator</span></strong><span class="koboSpan" id="kobo.187.1"> section, you’ll see a blue icon, followed by the name of your project; here, it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Demo</span></strong><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">This is the main folder of your project into which everything else is placed, including the new Swift files that you create. </span><span class="koboSpan" id="kobo.189.3">Clicking on that</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.190.1"> takes us to many different options and settings to configure the app, things such as the deployment target, signing, capabilities, build settings, </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">and more.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.192.1">Tool </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.193.1">bar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.195.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">):</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.197.1">Let’s look at the toolbar (after the traffic light buttons), starting from left </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">to right:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.199.1">There is a navigator toggle button that opens and closes the </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Project Navigator</span></strong><span class="koboSpan" id="kobo.201.1"> pane that we just looked at, to give you more working space when you need it. </span></li>
<li><span class="koboSpan" id="kobo.202.1">To the right of the navigation button is a play button that runs and stops </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the project.</span></span></li>
<li><span class="koboSpan" id="kobo.204.1">Next, you will see the title of your project. </span><span class="koboSpan" id="kobo.204.2">However, if you click on it, this is a drop-down list, allowing you to select the scheme and various different simulators or devices to run your project in. </span><span class="koboSpan" id="kobo.204.3">A scheme is a destination for running the app. </span><span class="koboSpan" id="kobo.204.4">For example, Xcode lets us run the project on different simulators, on a device, in a window on the Mac computer, on an Apple watch, on an iPad, or on an Apple TV if we are building for those. </span><span class="koboSpan" id="kobo.204.5">We are building for the iPhone, so you can select any of the iPhone simulator models from the list, or connect your iPhone to your computer and you will see it appear in the list. </span><span class="koboSpan" id="kobo.204.6">If you select your iPhone, you can see what your app looks like running on an </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">actual device.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">After that, there is a display area to show any errors or warnings, as well as the app’s </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">current status.</span></span></li>
<li><span class="koboSpan" id="kobo.208.1">To the right on the toolbar is a plus button that opens up a library of tools that we use to help create the user interface, things such as modifiers, views, controls, and </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">code snippets.</span></span></li>
<li><span class="koboSpan" id="kobo.210.1">And finally, there's another </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.211.1">button at the far right to show or collapse the Utilities Inspector, again, for more screen real estate when needed. </span></li>
</ul>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.212.1">Utilities</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.214.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">):</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.216.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Utilities</span></strong><span class="koboSpan" id="kobo.218.1"> Inspector is a collapsible area that offers more options to edit and configure the interface and its elements. </span><span class="koboSpan" id="kobo.218.2">There are five tabs at the top for this; from left to right, they are </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.220.1">File Inspector</span></strong><span class="koboSpan" id="kobo.221.1"> is used to adjust the parameters for the file you are </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">working in</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.223.1">History Inspector</span></strong><span class="koboSpan" id="kobo.224.1"> is used to view your project’s history (this is not used much in a </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">SwiftUI project)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.226.1">Quick Help Inspector</span></strong><span class="koboSpan" id="kobo.227.1"> will give you a description/definition of the code selected in </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">the editor</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Accessibility Inspector</span></strong><span class="koboSpan" id="kobo.230.1"> is for configuring things such as voiceover, Braille reading, and other settings related to making your app </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">more accessible</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Attributes Inspector</span></strong><span class="koboSpan" id="kobo.233.1"> gives you the option to change any of the attributes of a particular view, modifier, or other control that you </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">have selected</span></span></li>
</ul>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.235.1">Debug/Console</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.237.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">):</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.239.1">This is a collapsible space that appears and disappears by toggling the button on the bottom right. </span><span class="koboSpan" id="kobo.239.2">The area can also be divided into two sections. </span><span class="koboSpan" id="kobo.239.3">When split, the section on the left provides information for debugging, and the right is a console used to display any relevant information when we run the code, as well as warnings </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">and errors.</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.241.1">Editor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.243.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">):</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.245.1">This is the area in which we write our code. </span><span class="koboSpan" id="kobo.245.2">This section of Xcode is not collapsible, but we can split it into two or more sections by clicking the button at the far right just underneath the toolbar. </span><span class="koboSpan" id="kobo.245.3">It can be positioned at the top or the bottom depending on how you like to write code. </span></p>
<p><span class="koboSpan" id="kobo.246.1">There is also a feature</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.247.1"> called the mini-map, a miniature map of the code file, which offers a helpful view of the entire file, and makes it easy to reference and navigate around your code, especially if you have very large files. </span><span class="koboSpan" id="kobo.247.2">We can enable it by clicking on the little hamburger icon at the top right and choosing </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Mini Map</span></strong><span class="koboSpan" id="kobo.249.1">. </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.250.1">Canvas </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.251.1">Previews</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.253.1">6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">):</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.255.1">The canvas is its own collapsible section of Xcode that features a graphical simulator called a preview, that has a real-time connection to the code within the editor. </span><span class="koboSpan" id="kobo.255.2">Any changes we make in the editor will be reflected in the preview. </span><span class="koboSpan" id="kobo.255.3">There is a </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Run</span></strong><span class="koboSpan" id="kobo.257.1"> button on the preview to test out what you’ve done so far, but the preview is a great visual aid that helps speed up development. </span></p>
<p><span class="koboSpan" id="kobo.258.1">That’s the XCode interface in a nutshell. </span><span class="koboSpan" id="kobo.258.2">It may look daunting at first, but as you code along through the projects, you will become more comfortable and start to learn where </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">everything is.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">Let’s continue and look at the concept of the state, which is data that can change. </span><span class="koboSpan" id="kobo.260.2">We hold our data in variables, and that data changes many times when we animate something in SwiftUI; when the data changes, SwiftUI helpfully will handle updating the animations for us by using the state to refresh </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the views.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.262.1">Understanding the state</span></h1>
<p><span class="koboSpan" id="kobo.263.1">In SwiftUI, a state is a piece of data</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.264.1"> that can change. </span><span class="koboSpan" id="kobo.264.2">When the state changes, the view that depends on the state is </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">automatically refreshed.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">You can declare a state in a SwiftUI view by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">@State</span></strong><span class="koboSpan" id="kobo.268.1"> property wrapper. </span><span class="koboSpan" id="kobo.268.2">For example, see </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
struct ContentView: View {
    @State private var name: String = "Bella"
}</span></pre>
<p><span class="koboSpan" id="kobo.271.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">name</span></strong><span class="koboSpan" id="kobo.273.1"> is a state that is</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.274.1"> stored as a string. </span><span class="koboSpan" id="kobo.274.2">You can then use this state to display dynamic content in </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">your view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
struct ContentView: View {
    @State private var name: String = "Bella"
    var body: some View {
        Text("Hello, \(name)")
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.277.1">To change the state, we can assign a new value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">@State</span></strong><span class="koboSpan" id="kobo.279.1"> property. </span><span class="koboSpan" id="kobo.279.2">For example, see </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
struct ContentView: View {
    @State private var name: String = "Bella"
        var body: some View {
        VStack {
            Text("Hello, \(name)")
            Button(action: {
        </span><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.282.1">        name = "Jack"
            }) {
                Text("Change name")
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.283.1">When the button is tapped, the name state is changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">"Jack"</span></strong><span class="koboSpan" id="kobo.285.1"> and the view is automatically refreshed to display the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">new name.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">Let’s continue now</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.288.1"> and look at what makes up SwiftUI and helps it works </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">so well.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.290.1">Understanding SwiftUI structures</span></h1>
<p><span class="koboSpan" id="kobo.291.1">SwiftUI gives us views, controls, modifiers, and layout structures for declaring the user interface. </span><span class="koboSpan" id="kobo.291.2">The framework also includes event handlers for providing taps, gestures, and other kinds of input for our </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.292.1">app, as well as tools for managing the flow of data coming from your app’s models. </span></p>
<p><span class="koboSpan" id="kobo.293.1">But what’s a model? </span><span class="koboSpan" id="kobo.293.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">model</span></strong><span class="koboSpan" id="kobo.295.1"> is simply a</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.296.1"> folder we create in the </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Project Navigator</span></strong><span class="koboSpan" id="kobo.298.1"> window where we usually keep the app’s data; for example, if we are working on a weather app, we can keep our wind, temperature, precipitation, and snow accumulation data in the app’s model after it has been received from the internet through an </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">Application Programming Interface</span></strong><span class="koboSpan" id="kobo.300.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.301.1">API</span></strong><span class="koboSpan" id="kobo.302.1">) call, which is prebuilt software that talks to other</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.303.1"> programs for us. </span><span class="koboSpan" id="kobo.303.2">That data will then be processed and sent down to the views and controls that the user will see and can interact with. </span></p>
<p><span class="koboSpan" id="kobo.304.1">SwiftUI allows us to avoid using Interface Builder and Storyboards to design the app’s user interface, as we can use the preview canvas and the editor instead. </span><span class="koboSpan" id="kobo.304.2">We can inspect the user interface as we write code, and also generate code when dragging and dropping views/controls into the canvas. </span><span class="koboSpan" id="kobo.304.3">The code within the editor and the canvas preview are side by side; changing one will update </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">When building our</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.307.1"> apps, we use </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">views</span></strong><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">Nearly everything is a view in SwiftUI, and they are the building blocks of our apps, things such as text boxes, buttons, toggles, pickers, shapes, colors (yes, even colors are a view), stacks, and more. </span><span class="koboSpan" id="kobo.309.3">We add them to the canvas by dragging them out of the view’s library, or by typing out the code in the editor, and then setting their properties with modifiers. </span><span class="koboSpan" id="kobo.309.4">Each view will have its own unique set of properties and modifiers, and many views will also share those same properties and modifiers too. </span></p>
<p><span class="koboSpan" id="kobo.310.1">The following are the SwiftUI </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.311.1">structures we will look at so you can get a good foundation for completing this </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">book’s projects:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.313.1">Computed properties</span></span></li>
<li><span class="koboSpan" id="kobo.314.1">Stacks (</span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">VStack</span></strong><span class="koboSpan" id="kobo.316.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">HStack</span></strong><span class="koboSpan" id="kobo.318.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">ZStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">The </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Spacer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1"> view</span></span></li>
<li><span class="koboSpan" id="kobo.325.1">The </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Divider</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1"> view</span></span></li>
<li><span class="koboSpan" id="kobo.328.1">The </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">padding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1"> modifier</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.331.1">Closures</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">GeometryReader</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.333.1">Let’s go through each of </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">these now.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.335.1">Computed properties</span></h2>
<p><span class="koboSpan" id="kobo.336.1">One of the first things we</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.337.1"> will look at is </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">computed properties</span></strong><span class="koboSpan" id="kobo.339.1"> because that is</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.340.1"> how views are made. </span><span class="koboSpan" id="kobo.340.2">Here is a look at the template code that we see when we first create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">SwiftUI project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundColor(.accentColor)
            Text("Hello, world!")
        }
        .padding()
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.343.1">If we run that code, this is </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.344.1">what we see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">preview </span></span><span class="No-Break"><a id="_idIndexMarker027"/></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">window:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.347.1"><img alt="Figure 1.4: Running the template code " src="image/B18674_01_04_NEW.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.348.1">Figure 1.4: Running the template code</span></p>
<p><span class="koboSpan" id="kobo.349.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">Hello, world!</span></strong><span class="koboSpan" id="kobo.351.1"> string is displayed in the middle of the screen. </span></p>
<p><span class="koboSpan" id="kobo.352.1">Looking at the code, we see that it includes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">struct</span></strong><span class="koboSpan" id="kobo.354.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">ContentView</span></strong><span class="koboSpan" id="kobo.356.1">, which is the basic building block struct that SwiftUI creates for us. </span><span class="koboSpan" id="kobo.356.2">Inside that is a computed property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">body</span></strong><span class="koboSpan" id="kobo.358.1"> – it has open and close parentheses, and yes, it has a body where you place your code to be executed, as does any function in Swift. </span><span class="koboSpan" id="kobo.358.2">Computed properties </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.359.1">do not store values as a regular stored property or variable would. </span><span class="koboSpan" id="kobo.359.2">Instead, this property will compute the </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.360.1">code you place in between the parentheses and then return </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Computed properties can have getters and or setters. </span><span class="koboSpan" id="kobo.362.2">They can either get and return a value, set a new value, or do both. </span><span class="koboSpan" id="kobo.362.3">However, if it just has a getter, then it’s known as a read-only property because it will only return the computed </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">properties value.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">You might be wondering if this is a computed read-only property, where are the getter and return keywords? </span><span class="koboSpan" id="kobo.364.2">Well, this code is actually the shorthand version of a computed property. </span><span class="koboSpan" id="kobo.364.3">It’s optional to write out the longhand version, but we could if we wanted more readable and descriptive code; if we did, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
struct ContentView: View {
    var body: some View {
        get {
            return VStack {
                Image(systemName: "globe")
                    .imageScale(.large)
                    .foregroundColor(.accentColor)
                Text("Hello, world!")
            }
            .padding()
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.367.1">This code does the same thing as before: it returns the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Hello World!</span></strong><span class="koboSpan" id="kobo.369.1"> text view, and the image view, but I’ve just added the two keywords, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">get</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">return</span></strong><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">Again, they are optional, so you will see the shorthand version in most cases, because less code is, well, less code, which makes life easier. </span><span class="koboSpan" id="kobo.373.3">Still, many developers prefer the clarity of adding those keywords... </span><span class="koboSpan" id="kobo.373.4">it’s up </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">There’s another curious bit of syntax here and that’s the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">some View</span></strong><span class="koboSpan" id="kobo.377.1"> keyword. </span><span class="koboSpan" id="kobo.377.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">some</span></strong><span class="koboSpan" id="kobo.379.1"> keyword indicates that an opaque type will be returned, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">View</span></strong><span class="koboSpan" id="kobo.381.1"> is the opaque type in this instance. </span><span class="koboSpan" id="kobo.381.2">Opaque </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.382.1">refers to something that’s not clear or not easily understood. </span><span class="koboSpan" id="kobo.382.2">So, what’s not clear? </span><span class="koboSpan" id="kobo.382.3">That would be the type that this view will return. </span><span class="koboSpan" id="kobo.382.4">That’s because, being an opaque type, it hides the type and its implementation from us. </span><span class="koboSpan" id="kobo.382.5">All it cares about is that a single view will be returned, which is important because only one view can be </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.383.1">returned to satisfy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">some</span></strong><span class="koboSpan" id="kobo.385.1"> keyword’s requirements. </span><span class="koboSpan" id="kobo.385.2">The view’s type that will be returned is determined by what we put into the body of the computed property. </span><span class="koboSpan" id="kobo.385.3">In the code, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Text</span></strong><span class="koboSpan" id="kobo.387.1"> view there, so that’s the type that is returned. </span></p>
<p><span class="koboSpan" id="kobo.388.1">When we create custom views, we just have to make sure that it conforms to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">View</span></strong><span class="koboSpan" id="kobo.390.1"> protocol. </span><span class="koboSpan" id="kobo.390.2">To do that, we just need to implement the required </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">body</span></strong><span class="koboSpan" id="kobo.392.1"> computed property, then we can add whatever view we want to display, things such as buttons, toggles, pickers, shapes, colors, and so on, but again, just </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">one view.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Another bit of syntax to look at is </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">.padding()</span></strong><span class="koboSpan" id="kobo.396.1">, called a layout modifier – it modifies the layout of the text view by placing 20 points of padding (that’s the default amount when we don’t choose a value) all around the text view. </span><span class="koboSpan" id="kobo.396.2">Many different modifiers are grouped into different categories, such as text modifiers, image modifiers, list modifiers, </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Have a play around and experiment with them by clicking on the plus button on the top right in Xcode and then selecting the </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">Modifiers</span></strong><span class="koboSpan" id="kobo.400.1"> tab. </span><span class="koboSpan" id="kobo.400.2">You will quickly get to know the many different modifiers as you start building </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">the projects.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Let’s now turn our attention to the organizational layout of these views on </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the screen.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.404.1">Stacks</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Remember I said that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">some View</span></strong><span class="koboSpan" id="kobo.407.1"> protocol has one requirement, and that is to return just one view when</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.408.1"> we run the code. </span><span class="koboSpan" id="kobo.408.2">That’s fine in very simple apps, but more often than not, we need to return more than one view – several views might need to be </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.409.1">displayed on the screen for the user to interact with in fact, such as a button, a text field, some images, text, and so on. </span><span class="koboSpan" id="kobo.409.2">We need to organize these views vertically and horizontally on the screen, as well as on the </span><em class="italic"><span class="koboSpan" id="kobo.410.1">z</span></em><span class="koboSpan" id="kobo.411.1">-axis (placing views on top of each other). </span></p>
<p><span class="koboSpan" id="kobo.412.1">To achieve this, SwiftUI gives us vertical, horizontal, and zed stacks, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">VStack</span></strong><span class="koboSpan" id="kobo.414.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">HStack</span></strong><span class="koboSpan" id="kobo.416.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">ZStack</span></strong><span class="koboSpan" id="kobo.418.1"> for short. </span><span class="koboSpan" id="kobo.418.2">These are container views that can hold 10 views inside them. </span><span class="koboSpan" id="kobo.418.3">The views inside them </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.419.1">are know as </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">child views</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">each now.</span></span></p>
<h3><span class="koboSpan" id="kobo.423.1">VStack</span></h3>
<p><span class="koboSpan" id="kobo.424.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">VStack</span></strong><span class="koboSpan" id="kobo.426.1"> is simply a container view that arranges its children in a vertical line. </span><span class="koboSpan" id="kobo.426.2">Looking at the previous code, when we press the </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">Run</span></strong><span class="koboSpan" id="kobo.428.1"> button, one view is returned, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Text</span></strong><span class="koboSpan" id="kobo.430.1"> view, and it displays </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Hello World!</span></strong><span class="koboSpan" id="kobo.432.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">user’s screen.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">But what if we want to have more </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.435.1">than one view returned from inside the body computed property? </span><span class="koboSpan" id="kobo.435.2">Maybe we want to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Button</span></strong> <em class="italic"><span class="koboSpan" id="kobo.437.1">and</span></em><span class="koboSpan" id="kobo.438.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Text</span></strong><span class="koboSpan" id="kobo.440.1"> view on the screen, as in this </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">code example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
struct ContentView: View {
    @State var myText = ""
    @State var changeText = false
    var body: some View {
        Text(myText)
            .padding()
        Button("Button") {
            changeText.toggle()
            if changeText {
                myText = "Hello SwiftUI!"
</span><span class="koboSpan" id="kobo.442.2">            } else {
                myText = "Hello World!"
</span><span class="koboSpan" id="kobo.442.3">            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.443.1">If we press </span><em class="italic"><span class="koboSpan" id="kobo.444.1">Command</span></em><span class="koboSpan" id="kobo.445.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.446.1">B</span></em><span class="koboSpan" id="kobo.447.1"> to build this code, it builds cleanly and error-free. </span></p>
<p><span class="koboSpan" id="kobo.448.1">But even though this code is error-free, nothing appears in the previews, so it won’t do anything when we press the</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.449.1"> play button to run it. </span><span class="koboSpan" id="kobo.449.2">The code won’t do anything because there are two views inside the body computed property: a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Text</span></strong><span class="koboSpan" id="kobo.451.1"> view and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Button</span></strong><span class="koboSpan" id="kobo.453.1"> view. </span><span class="koboSpan" id="kobo.453.2">This violates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">View</span></strong><span class="koboSpan" id="kobo.455.1"> protocol, which only wants </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">some View</span></strong><span class="koboSpan" id="kobo.457.1"> returned (singular), not </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">some </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Views</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.460.1"> (plural).</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Now, look at the same co</span><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.462.1">de with a minor change made </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
struct ContentView: View {
    @State var myText = ""
    @State var changeText = false
    
    var body: some View {
        VStack {
            Text(myText)
                .padding()
          Button("Button") {
                changeText.toggle()
                if changeText {
                    myText = "Hello SwiftUI!"
</span><span class="koboSpan" id="kobo.464.2">                } else {
                    myText = "Hello World!"
</span><span class="koboSpan" id="kobo.464.3">                }
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.465.1">I have put all of the code </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.466.1">inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">VStack</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">Now, when we run it, everything works as expected, and the two views can coexist inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">body</span></strong><span class="koboSpan" id="kobo.470.1"> computed property without any issues. </span><span class="koboSpan" id="kobo.470.2">If we press the button, the text will change depending on the value in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">changeText</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.472.1"> property:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.473.1"><img alt="Figure 1.5: VStack " src="image/B18674_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.474.1">Figure 1.5: VStack</span></p>
<p><span class="koboSpan" id="kobo.475.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">VStack</span></strong><span class="koboSpan" id="kobo.477.1"> can hold 10 child views and is still considered to only return one view itself, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">some View</span></strong><span class="koboSpan" id="kobo.479.1"> protocol is satisfied. </span><span class="koboSpan" id="kobo.479.2">If you need more than 10 children, you can nest VStacks inside each other to add even more views. </span></p>
<p><span class="koboSpan" id="kobo.480.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">VStack</span></strong><span class="koboSpan" id="kobo.482.1">, as you might </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.483.1">imagine, will stack all of its children vertically, but you can also set an optional alignment and spacing within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">VStack</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.485.1">initializer too.</span></span></p>
<h4><span class="koboSpan" id="kobo.486.1">Alignment</span></h4>
<p><span class="koboSpan" id="kobo.487.1">By default, everything in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">VStack</span></strong><span class="koboSpan" id="kobo.489.1"> is center-aligned, but if you want all of its child views aligned to</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.490.1"> the leading edge or trailing edge, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">alignment</span></strong><span class="koboSpan" id="kobo.492.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
struct ContentView: View {
   var body: some View {
        VStack</span><strong class="bold"><span class="koboSpan" id="kobo.495.1">(alignment: .leading) </span></strong><span class="koboSpan" id="kobo.496.1">{
      Text("Hi, I'm child one in this vertical stack")
      Text("Hi, I'm child two in this vertical stack")
      Text("Hi, I'm child three in this vertical stack")
      Text("Hi, I'm child four in this vertical stack, I'm the         best")
        }
    }}</span></pre>
<p><span class="koboSpan" id="kobo.497.1">All the child views are now aligned to the leading edge within </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">VStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.501.1"><img alt="Figure 1.6: Leading alignment " src="image/B18674_01_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Figure 1.6: Leading alignment</span></p>
<p><span class="koboSpan" id="kobo.503.1">You can also align the views to the trailing edge or the center. </span><span class="koboSpan" id="kobo.503.2">To do that, we use dot syntax to access those other </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">enumeration</span></strong><span class="koboSpan" id="kobo.505.1"> values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">.leading</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">.trailing</span></strong><span class="koboSpan" id="kobo.509.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">.center</span></strong><span class="koboSpan" id="kobo.511.1"> are the</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.512.1"> options available </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">for alignment.</span></span></p>
<h4><span class="koboSpan" id="kobo.514.1">Spacing</span></h4>
<p><span class="koboSpan" id="kobo.515.1">The other parameter</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.516.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">VStack</span></strong><span class="koboSpan" id="kobo.518.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">spacing</span></strong><span class="koboSpan" id="kobo.520.1"> option. </span><span class="koboSpan" id="kobo.520.2">This will put some space between all the </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">child views:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack,               I'm the best")
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.523.1">The code puts 10 </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.524.1">points of space between each child view, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">see here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.526.1"><img alt="Figure 1.7: VStack spacing " src="image/B18674_01_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.527.1">Figure 1.7: VStack spacing</span></p>
<p><span class="koboSpan" id="kobo.528.1">That’s how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">VStack</span></strong><span class="koboSpan" id="kobo.530.1"> works; let’s</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.531.1"> continue and look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">HStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> now.</span></span></p>
<h3><span class="koboSpan" id="kobo.534.1">HStack</span></h3>
<p><span class="koboSpan" id="kobo.535.1">In contrast to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">VStack</span></strong><span class="koboSpan" id="kobo.537.1">, an </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">HStack</span></strong><span class="koboSpan" id="kobo.539.1"> displays its </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.540.1">children horizontally. </span><span class="koboSpan" id="kobo.540.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">an</span></span><span class="No-Break"><a id="_idIndexMarker045"/></span><span class="No-Break"><span class="koboSpan" id="kobo.542.1"> example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
struct ContentView: View {
    var body: some View {
        HStack() {
            Text("0")
            Text("1")
            Text("2")
            Text("3")
            Text("4")
            Text("5")
            Text("6")
            Text("7")
            Text("8")
            Text("9")
        }.font(.headline)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.544.1">The number views are </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.545.1">now all </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">stacked horizontally:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.547.1"><img alt="Figure 1.8: HStack " src="image/B18674_01_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.548.1">Figure 1.8: HStack</span></p>
<p><span class="koboSpan" id="kobo.549.1">Adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">font</span></strong><span class="koboSpan" id="kobo.551.1"> modifier to</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.552.1"> the entire parent stack will affect all the children inside it, but to affect an individual child view, you need to place the modifier on it directly. </span><span class="koboSpan" id="kobo.552.2">Here is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">doing that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
struct ContentView: View {
    var body: some View {
        HStack() {
            Text("0")
            Text("1")
            Text("2")
            Text("3")
            Text("4").font(.title)
            Text("5")
            Text("6")
            Text("7")
            Text("8")
            Text("9")
        }.font(.headline)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.555.1">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Text</span></strong><span class="koboSpan" id="kobo.557.1"> view</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.558.1"> number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">4</span></strong><span class="koboSpan" id="kobo.560.1"> has now been altered to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">larger font:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.562.1"><img alt="Figure 1.9: Modifying the child " src="image/B18674_01_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.563.1">Figure 1.9: Modifying the child</span></p>
<p><span class="koboSpan" id="kobo.564.1">Let’s look at another </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.565.1">important stack, </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ZStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.569.1">ZStack</span></h3>
<p><span class="koboSpan" id="kobo.570.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.571.1">ZStack</span></strong><span class="koboSpan" id="kobo.572.1"> is a stack that will </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.573.1">overlay its children, one on top of another. </span><span class="koboSpan" id="kobo.573.2">With this stack, we can create </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.574.1">a hierarchy of views, where the first view in the stack will be placed at the bottom, and subsequent views will be stacked up on top of each other in sequential order. </span><span class="koboSpan" id="kobo.574.2">Take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
struct ContentView: View {
    var body: some View {
        ZStack() {
            Image(systemName: "rectangle.inset.filled.and.              person.filled")
                .renderingMode(.original)
                .resizable()
                .frame(width: 350, height: 250)
            
            Text("SwiftUI")
                .font(.system(size: 50))
                .foregroundColor(.yellow)
                .padding(.trailing, 80)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.577.1">The code contains </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">two views:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.579.1">The first is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">Image</span></strong><span class="koboSpan" id="kobo.581.1"> view, which </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.582.1">accepts images that you have imported into the Assets catalog, and makes it possible to display the images on the screen. </span><span class="koboSpan" id="kobo.582.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">systemName</span></strong><span class="koboSpan" id="kobo.584.1"> parameter, we can choose a system image from Apple’s stock of pre-made images, from many </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">different categories.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.586.1">To use a system image in your projects, download the </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">SF Symbols</span></strong><span class="koboSpan" id="kobo.588.1"> app – this is free from Apple and contains thousands of images to use in Xcode from your developer portal. </span><span class="koboSpan" id="kobo.588.2">Simply look through the app, pick one, copy its name, and paste it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Image</span></strong><span class="koboSpan" id="kobo.590.1"> parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">systemName</span></strong><span class="koboSpan" id="kobo.592.1">. </span><span class="koboSpan" id="kobo.592.2">For my example, I’ve used an image called </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">rectangle.inset.filled.and.person.filled</span></strong><span class="koboSpan" id="kobo.594.1"> and have placed it at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ZStack</span></strong><span class="koboSpan" id="kobo.596.1">; any view added underneath it will be placed on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">that image.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.598.1">The second view is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Text</span></strong><span class="koboSpan" id="kobo.600.1"> view, placed on top of the system image by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">ZStack</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">Again, because the code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Text</span></strong><span class="koboSpan" id="kobo.604.1"> view is added under the code that creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">Image</span></strong><span class="koboSpan" id="kobo.606.1"> view, it is </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.607.1">placed on top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Image</span></strong><span class="koboSpan" id="kobo.609.1"> view when we run </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">the app.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.611.1">Then, I use a little bit of padding, and we can position that text where we want it. </span><span class="koboSpan" id="kobo.611.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">offset</span></strong><span class="koboSpan" id="kobo.613.1"> modifier to place views anywhere on </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">You can see the result of the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.617.1"><img alt="Figure 1.10: ZStack " src="image/B18674_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.618.1">Figure 1.10: ZStack</span></p>
<p><span class="koboSpan" id="kobo.619.1">There are also three modifiers in this code that we will look at in more depth when we start building the projects – that’s the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">renderingMode</span></strong><span class="koboSpan" id="kobo.621.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">resizable</span></strong><span class="koboSpan" id="kobo.623.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">frame</span></strong><span class="koboSpan" id="kobo.625.1"> modifiers. </span><span class="koboSpan" id="kobo.625.2">They are used</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.626.1"> here because we need to render and resize the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">image correctly.</span></span></p>
<h3><span class="koboSpan" id="kobo.628.1">Combining stacks</span></h3>
<p><span class="koboSpan" id="kobo.629.1">Now that we have seen how</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.630.1"> the three stacks can be used to display multiple views and position them where we want them on the screen, let’s look at an example that combines all three stacks, and the child views inside them, to produce a </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">varied layout:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
struct ContentView: View {
    var body: some View {
        VStack {
            ZStack() {
                Image(systemName: "cloud.moon.rain.fill")
                    .foregroundColor(Color(.systemOrange))
                    .font(.system (size: 150))
                Text("Stormy").bold()
                    .font(.system(size: 30))
                    .offset(x: -15, y: -5)
                    .foregroundColor(.indigo)
            }
            HStack() {
                Image(systemName: "tornado")
                    .foregroundColor(Color(.systemBlue))
                    .font(.system (size: 50))
                
                VStack(alignment: .leading) {
                    Text("Be prepared for anything")
                        .font(.system(size: 25))
                        .fontWeight(.bold)
                    
                    Text("With the Stormy Weather app")
                        .font(.system(size: 16))
                }
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">Let’s break down this code to get </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.634.1">a clear understanding of what we </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">are doing.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">First is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">VStack</span></strong><span class="koboSpan" id="kobo.638.1">. </span><span class="koboSpan" id="kobo.638.2">This will be our main stack and will hold all of our code. </span><span class="koboSpan" id="kobo.638.3">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">VStack</span></strong><span class="koboSpan" id="kobo.640.1"> in this way means we can squeeze 10 child views inside it, but we only need to place a couple of views inside for </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Next is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">ZStack</span></strong><span class="koboSpan" id="kobo.644.1">. </span><span class="koboSpan" id="kobo.644.2">Inside are its two child views – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">Text</span></strong><span class="koboSpan" id="kobo.646.1"> view and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Image</span></strong><span class="koboSpan" id="kobo.648.1"> view. </span><span class="koboSpan" id="kobo.648.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">Image</span></strong><span class="koboSpan" id="kobo.650.1"> view comes first in the code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">Text</span></strong><span class="koboSpan" id="kobo.652.1"> view gets placed on top </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Notice how each child view in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">ZStack</span></strong><span class="koboSpan" id="kobo.656.1"> has its own set of modifiers that are indented; these are to style these child views with colors and sizes and to position them on </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">The next stack is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">HStack</span></strong><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">Remember that this arranges its children horizontally, and it has two child views, including an </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Image</span></strong><span class="koboSpan" id="kobo.662.1"> view and </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">VStack</span></strong><span class="koboSpan" id="kobo.664.1">. </span><span class="koboSpan" id="kobo.664.2">Notice how we can nest stacks inside of other stacks as we are doing here, with this </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">VStack</span></strong><span class="koboSpan" id="kobo.666.1"> inside of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">HStack</span></strong><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">HStack</span></strong><span class="koboSpan" id="kobo.670.1"> places its first child view to the left – that’s the tornado image – and then places its second child view to the right – that’s the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">VStack</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">If we look inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">VStack</span></strong><span class="koboSpan" id="kobo.674.1"> now, it has two child views of its own. </span><span class="koboSpan" id="kobo.674.2">They will be placed vertically, with the smaller text on </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">the bottom.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Don’t worry if this nesting of </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.677.1">stacks seems a bit confusing at first; as we start building projects, you will train your brain to think and see in hierarchies, and this will become very natural </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">By nesting the different stacks, we can make all kinds of interesting layout scenes. </span><span class="koboSpan" id="kobo.679.2">Here is the result of </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">our example:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.681.1"><img alt="Figure 1.11: Combining and nesting stacks " src="image/B18674_01_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.682.1">Figure 1.11: Combining and nesting stacks</span></p>
<p><span class="koboSpan" id="kobo.683.1">Stacks are great for helping to organize and lay our views out on the screen, but there is another container view we can use</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.684.1"> that offers even more flexibility. </span><span class="koboSpan" id="kobo.684.2">That’s the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.686.1"> view. </span><span class="koboSpan" id="kobo.686.2">However, we will look at that at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">For now, let’s look at a </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">Spacer</span></strong><span class="koboSpan" id="kobo.690.1"> view – this is a view that helps with spacing out the layout in our </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">UI design.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.692.1">Spacer views</span></h2>
<p><span class="koboSpan" id="kobo.693.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">Spacer view</span></strong><span class="koboSpan" id="kobo.695.1"> does exactly</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.696.1"> what its name says: it creates space between your views by pushing other components to the edges of a container or helps fill empty space between components. </span><span class="koboSpan" id="kobo.696.2">For example, when placed within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">HStack</span></strong><span class="koboSpan" id="kobo.698.1">, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">Spacer</span></strong><span class="koboSpan" id="kobo.700.1"> view expands </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.701.1">horizontally as much as the stack allows, moving sibling views out of the way within the limits of the stack’s size. </span></p>
<p><span class="koboSpan" id="kobo.702.1">This is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">Spacer</span></strong><span class="koboSpan" id="kobo.704.1"> initializer: </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">Spacer(minLength: CGFloat)</span></strong><span class="koboSpan" id="kobo.706.1">. </span><span class="koboSpan" id="kobo.706.2">This initializer creates a flexible space. </span><span class="koboSpan" id="kobo.706.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">minLength</span></strong><span class="koboSpan" id="kobo.708.1"> argument sets the minimum size that the space can take. </span><span class="koboSpan" id="kobo.708.2">If the argument is left empty, the minimum length </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">is zero.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Here’s an example of using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">Spacer</span></strong><span class="koboSpan" id="kobo.712.1"> view in </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">HStack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
struct ContentView: View {
    var body: some View {
        HStack {
            Text("Hello")
            Spacer()
            Text("World")
        }.padding()
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.717.1">This will create a horizontal stack with </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">Hello</span></strong><span class="koboSpan" id="kobo.719.1"> on the left, </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">World</span></strong><span class="koboSpan" id="kobo.721.1"> on the right, and a flexible space in between. </span><span class="koboSpan" id="kobo.721.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">Spacer</span></strong><span class="koboSpan" id="kobo.723.1"> view will take up all of the remaining space so that the two pieces of text are pushed to the edges of </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">the container:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.725.1"><img alt="Figure 1.12: Spacer " src="image/B18674_01_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.726.1">Figure 1.12: Spacer</span></p>
<p><span class="koboSpan" id="kobo.727.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">Spacer</span></strong><span class="koboSpan" id="kobo.729.1"> view </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.730.1">can also be used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">VStack</span></strong><span class="koboSpan" id="kobo.732.1">, and it will expand and push the child views apart vertically</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.733.1"> instead of horizontally. </span><span class="koboSpan" id="kobo.733.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">Spacer</span></strong><span class="koboSpan" id="kobo.735.1"> view won’t do anything within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">ZStack</span></strong><span class="koboSpan" id="kobo.737.1"> though, as that stack deals with the depth of a view on the </span><em class="italic"><span class="koboSpan" id="kobo.738.1">z</span></em><span class="koboSpan" id="kobo.739.1">-axis, front </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">to back.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Where </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">Spacer</span></strong><span class="koboSpan" id="kobo.743.1"> separates views by creating space between them, another object called a </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">Divider</span></strong><span class="koboSpan" id="kobo.745.1"> view separates views with a thin line, either vertically </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">or horizontally.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.747.1">Divider views</span></h2>
<p><span class="koboSpan" id="kobo.748.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">Divider view</span></strong><span class="koboSpan" id="kobo.750.1"> is a visual element, a dividing </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.751.1">line, that can be used to separate </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.752.1">content either horizontally or vertically. </span><span class="koboSpan" id="kobo.752.2">You can also alter the divider’s thickness. </span><span class="koboSpan" id="kobo.752.3">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">some examples.</span></span></p>
<h3><span class="koboSpan" id="kobo.754.1">Horizontal</span></h3>
<p><span class="koboSpan" id="kobo.755.1">The following code creates </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.756.1">a </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">horizontal divider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            </span><strong class="bold"><span class="koboSpan" id="kobo.759.1">Divider().background(Color.black)</span></strong><span class="koboSpan" id="kobo.760.1">
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.761.1">As you can see, we have added </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.762.1">a horizontal dividing line and set its </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.763.1">color to black using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">background</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.765.1"> modifier:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.766.1"><img alt="Figure 1.13: Divider " src="image/B18674_01_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.767.1">Figure 1.13: Divider</span></p>
<h3><span class="koboSpan" id="kobo.768.1">Vertical</span></h3>
<p><span class="koboSpan" id="kobo.769.1">If we want to change the horizontal line to a vertical one, then we can pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">width</span></strong><span class="koboSpan" id="kobo.771.1"> parameter using a smaller </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.772.1">number, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">height</span></strong><span class="koboSpan" id="kobo.774.1"> parameter using a larger number, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            
            Divider().frame(height: 200).frame(width:               3).background(Color.blue)
            Divider().frame(height:200).frame(width:               3).background(Color.blue).offset(x: 300, y: 0)
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }      
}</span></pre>
<p><span class="koboSpan" id="kobo.777.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">offset</span></strong><span class="koboSpan" id="kobo.779.1"> modifier lets </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.780.1">us place the line anywhere on the screen, or on any view for that matter. </span><span class="koboSpan" id="kobo.780.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">the result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.782.1"><img alt="Figure 1.14: Vertical Divider view " src="image/B18674_01_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.783.1">Figure 1.14: Vertical Divider view</span></p>
<h3><span class="koboSpan" id="kobo.784.1">Thickness</span></h3>
<p><span class="koboSpan" id="kobo.785.1">We can change the thickness </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.786.1">of the dividing line using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">frame</span></strong><span class="koboSpan" id="kobo.788.1"> modifier, </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
struct ContentView: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Hi, I'm child one in this vertical stack")
            Text("Hi, I'm child two in this vertical stack")
            Text("Hi, I'm child three in this vertical stack")
            Text("Hi, I'm child four in this vertical stack")
            Divider().frame(height: 20).frame(width: 300).              background(Color.blue)
            
            Text("Hi, I'm child five in this vertical stack")
            Text("Hi, I'm child six in this vertical stack")
            Text("Hi, I'm child seven in this vertical stack")
            Text("Hi, I'm child eight in this vertical stack")
        }.padding()
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.791.1">Then, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">height</span></strong><span class="koboSpan" id="kobo.793.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">width</span></strong><span class="koboSpan" id="kobo.795.1"> parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">frame</span></strong><span class="koboSpan" id="kobo.797.1"> modifier, we can change the dimensions </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.798.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Divider</span></strong><span class="koboSpan" id="kobo.800.1"> view, so we can make a line as long and wide as we want. </span><span class="koboSpan" id="kobo.800.2">The result of our example can be </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">seen here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.802.1"><img alt="Figure 1.15: Divider thickness " src="image/B18674_01_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.803.1">Figure 1.15: Divider thickness</span></p>
<p><span class="koboSpan" id="kobo.804.1">That’s pretty much all the configuring we can do with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Divider</span></strong><span class="koboSpan" id="kobo.806.1"> view. </span><span class="koboSpan" id="kobo.806.2">Let’s now look at one of the most frequently used modifiers in SwiftUI – the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">padding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> modifier.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.809.1">The padding modifier</span></h2>
<p><span class="koboSpan" id="kobo.810.1">You may have noticed that</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.811.1"> we have used the </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">padding modifier</span></strong><span class="koboSpan" id="kobo.813.1"> quite a bit already without really explaining </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">it yet.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">Every view has its own dimensions and </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.816.1">space that it takes up on the screen. </span><span class="koboSpan" id="kobo.816.2">For example, we can place two views side by side and they will be very close to each other, separated by only a few points. </span></p>
<p><span class="koboSpan" id="kobo.817.1">Points and pixels refer to different ways of measuring the size of the views on </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">the screen.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.819.1">Points</span></strong><span class="koboSpan" id="kobo.820.1"> are used to specify the size</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.821.1"> of text and other UI elements, and they are independent of the resolution of the device’s screen. </span><span class="koboSpan" id="kobo.821.2">This means that a point will always be the same size on any device, regardless of the </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">screen’s resolution.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.823.1">Pixels</span></strong><span class="koboSpan" id="kobo.824.1">, on the other hand, are </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.825.1">the individual dots that make up the screen of an iPhone (or any other device). </span><span class="koboSpan" id="kobo.825.2">Pixels are used to measure the physical resolution of a device’s screen. </span></p>
<p><span class="koboSpan" id="kobo.826.1">When you add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">padding</span></strong><span class="koboSpan" id="kobo.828.1"> modifier to a view, it adds a small amount of empty space all around that view by default, and that space is measured in points. </span><span class="koboSpan" id="kobo.828.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">padding</span></strong><span class="koboSpan" id="kobo.830.1"> modifier by default adds eight points of empty space around a view, but if you want to be more specific about the amount of space with which to pad your view, then you can pass in a value (an integer) for a custom amount of padding. </span><span class="koboSpan" id="kobo.830.2">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.832.1">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                Text("There is padding all around this view")
                
            }.background(Color.yellow)
                .padding(30)
                .background(Color.red)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.833.1">In this code, there are four </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">Text</span></strong><span class="koboSpan" id="kobo.835.1"> views</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.836.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">VStack</span></strong><span class="koboSpan" id="kobo.838.1">. </span><span class="koboSpan" id="kobo.838.2">At the end of the VStack’s closing brace is a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">background</span></strong><span class="koboSpan" id="kobo.840.1"> modifier, which will color the background yellow so that you can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">padding</span></strong><span class="koboSpan" id="kobo.842.1"> modifier at work. </span><span class="koboSpan" id="kobo.842.2">Next, I added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">padding</span></strong><span class="koboSpan" id="kobo.844.1"> modifier and passed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">30</span></strong><span class="koboSpan" id="kobo.846.1"> points, which will be applied around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">VStack</span></strong><span class="koboSpan" id="kobo.848.1"> equally. </span><span class="koboSpan" id="kobo.848.2">Finally, I colored</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.849.1"> the padding red, again, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">background</span></strong><span class="koboSpan" id="kobo.851.1"> modifier, so you can see the padding directly. </span><span class="koboSpan" id="kobo.851.2">In the example, the padding will look like a red frame around </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">VStack</span></strong><span class="koboSpan" id="kobo.853.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.855.1"><img alt="Figure 1.16: Padding " src="image/B18674_01_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.856.1">Figure 1.16: Padding</span></p>
<p><span class="koboSpan" id="kobo.857.1">Let’s look at some </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.858.1">of the other </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">padding</span></strong><span class="koboSpan" id="kobo.860.1"> options. </span><span class="koboSpan" id="kobo.860.2">The modifier </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.861.1">allows us to choose from predefined enum values if we only want to pad one side, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("The leading edge has been padded")
            }.padding(.leading, 75)
        }
    }
} </span></pre>
<p><span class="koboSpan" id="kobo.864.1">This code pads</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.865.1"> only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">leading</span></strong><span class="koboSpan" id="kobo.867.1"> edge of each </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Text</span></strong><span class="koboSpan" id="kobo.869.1"> view by </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">75</span></strong><span class="koboSpan" id="kobo.871.1"> points </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.872.1">of space: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.873.1"><img alt="Figure 1.17: Padding options " src="image/B18674_01_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.874.1">Figure 1.17: Padding options</span></p>
<p><span class="koboSpan" id="kobo.875.1">We can also choose other padding options by typing in a dot for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">alignment</span></strong><span class="koboSpan" id="kobo.877.1"> parameter and selecting from many different options, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">trailing</span></strong><span class="koboSpan" id="kobo.879.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">top</span></strong><span class="koboSpan" id="kobo.881.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">bottom</span></strong><span class="koboSpan" id="kobo.883.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">horizontal</span></strong><span class="koboSpan" id="kobo.885.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">infinity</span></strong><span class="koboSpan" id="kobo.887.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">and others.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">Looking at the previous</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.890.1"> code, notice the placement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">padding</span></strong><span class="koboSpan" id="kobo.892.1"> modifier; it has been put on the closing brace of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">VStack</span></strong><span class="koboSpan" id="kobo.894.1">. </span><span class="koboSpan" id="kobo.894.2">When placed like this, all the children inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">VStack</span></strong><span class="koboSpan" id="kobo.896.1"> have the </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.897.1">padding applied to them, but if we want to pad the child views individually, we can do so by placing modifiers directly </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">on them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.899.1">
struct ContentView: View {
    var body: some View {
        VStack{
            VStack(alignment: .leading, spacing: 10) {
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
                Text("I'm padded on the leading edge").padding                   (.leading, 75)
                Text("I'm padded on the trailing edge").padding                   (.trailing, 75)
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.900.1">As you can see, you can add modifiers to child views individually, styling them as you need for your layout. </span><span class="koboSpan" id="kobo.900.2">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.902.1"><img alt="Figure 1.18: Padding children " src="image/B18674_01_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.903.1">Figure 1.18: Padding children</span></p>
<p><span class="koboSpan" id="kobo.904.1">Each </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.905.1">child view now</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.906.1"> has its own padding, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">leading</span></strong><span class="koboSpan" id="kobo.908.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">trailing</span></strong><span class="koboSpan" id="kobo.910.1">, which alters its placement on </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.912.1">Let’s finish up this chapter</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.913.1"> by looking at closures, which is essentially a function without a name, and then another container view that offers some more flexibility than the other stacks we previously looked at – the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.915.1"> view.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.916.1">Closures</span></h2>
<p><span class="koboSpan" id="kobo.917.1">Here is the easy definition of a </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">closure</span></strong><span class="koboSpan" id="kobo.919.1">: a closure is a function without a name. </span><span class="koboSpan" id="kobo.919.2">Remember a</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.920.1"> function is a block of code that runs whatever code statements are in its body when it </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">But let’s look at a more </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.923.1">detailed definition of a closure: a closure is a self-contained block of code that can be passed around and executed at a </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">later time.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">Closures are not exactly functions, but they are similar, with some key differences: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.926.1">Closures can be stored as variables and passed as arguments </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">to functions</span></span></li>
<li><span class="koboSpan" id="kobo.928.1">Closures can capture and store references to any variables or constants from the context in which they are defined, which allows them to maintain the state and preserve data </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">between invocations</span></span></li>
<li><span class="koboSpan" id="kobo.930.1">Closures don’t have a name as a </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">function would</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.932.1">In SwiftUI, closures are often used as a way to respond to user input or other events. </span><span class="koboSpan" id="kobo.932.2">For example, you might use a closure as the action for a button, or to provide a block of code to be executed when a view appears </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">or disappears.</span></span></p>
<p><span class="koboSpan" id="kobo.934.1">Here’s an example of a closure being used as the action for a button </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">in SwiftUI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
Button(action: {
    // this block of code will be run when the button is       clicked
    print("Button was clicked!")
}) {
    Text("Button")
}</span></pre>
<p><span class="koboSpan" id="kobo.937.1">In this example, the closure is defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">{ }</span></strong><span class="koboSpan" id="kobo.939.1"> syntax and is passed as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">action</span></strong><span class="koboSpan" id="kobo.941.1"> parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">Button</span></strong><span class="koboSpan" id="kobo.943.1"> view. </span><span class="koboSpan" id="kobo.943.2">Yes, that’s right, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Button</span></strong><span class="koboSpan" id="kobo.945.1"> action is a closure, and when</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.946.1"> the button is pressed, the code inside the closure will </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">be executed.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Closures can also</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.949.1"> be used to provide custom behavior for views in SwiftUI. </span><span class="koboSpan" id="kobo.949.2">For example, you might use a closure to perform some custom animation when a view appears </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">or disappears:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
struct MyView: View {
    var body: some View {
        Text("Hello, SwiftUI!")
            .onAppear {
                // this block of code will run when the view                   appears
                print("The view appeared!")
            }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.952.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">onAppear</span></strong><span class="koboSpan" id="kobo.954.1"> modifier is called on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Text</span></strong><span class="koboSpan" id="kobo.956.1"> view and is passed a closure that will be executed when the view appears on </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">We also have trailing closures. </span><span class="koboSpan" id="kobo.958.2">A trailing closure is a closure that is written after the function or method it is passed to. </span><span class="koboSpan" id="kobo.958.3">The closure is “trailing” because it comes after the function </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">or method.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">Here’s an example of a function that takes a closure as </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">an argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.962.1">
func doSomething(completion: () -&gt; Void) {
    // Do some work!
</span><span class="koboSpan" id="kobo.962.2">    print("Work complete")
    completion()
}</span></pre>
<p><span class="koboSpan" id="kobo.963.1">Here’s how you would </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.964.1">call this function and pass a closure as </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">an argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.966.1">
doSomething {
    // this block of code will run when the "completion"       closure is called
    print("completion closure called!")
}</span></pre>
<p><span class="koboSpan" id="kobo.967.1">In this example, the </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.968.1">closure is written after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">doSomething</span></strong><span class="koboSpan" id="kobo.970.1"> function and is therefore a trailing closure. </span><span class="koboSpan" id="kobo.970.2">In SwiftUI, you can use trailing closures to provide custom behavior for views. </span><span class="koboSpan" id="kobo.970.3">For example, you might use a trailing closure to perform some custom animation when a view appears </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">or disappears:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.972.1">
Text("Hello, World!")
    .onAppear {
        // this block of code will be executed when the view           appears
        print("View appeared!")
    }</span></pre>
<p><span class="koboSpan" id="kobo.973.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">onAppear</span></strong><span class="koboSpan" id="kobo.975.1"> method is called on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">Text</span></strong><span class="koboSpan" id="kobo.977.1"> view and is passed a trailing closure that will be executed when the view appears on </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">Don’t worry if you haven’t quite grasped how closures work yet; they are not as complicated as they appear, and you will understand them better as we progress throughout the book. </span><span class="koboSpan" id="kobo.979.2">For now, let’s move on </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.983.1">GeometryReader</span></h2>
<p><span class="koboSpan" id="kobo.984.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.985.1">GeometryReader view</span></strong><span class="koboSpan" id="kobo.986.1"> is another </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.987.1">container view that offers more flexibility than the other stacks we previously looked at. </span><span class="koboSpan" id="kobo.987.2">The closure (function) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.989.1"> will contain the position and size of the view we are working with, and we can then alter or place that view however we want with the values that are returned by </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">’s proxy.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">Using these values, we can</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.993.1"> make the child views dynamically update their position depending on the device size and position when the orientation changes to either landscape or portrait. </span><span class="koboSpan" id="kobo.993.2">This all will become clearer when we see an example. </span></p>
<p><span class="koboSpan" id="kobo.994.1">Let’s look at how to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.996.1">. </span><span class="koboSpan" id="kobo.996.2">The following is the initializer used to create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.998.1"> view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.999.1">
GeometryReader(content: _)</span></pre>
<p><span class="koboSpan" id="kobo.1000.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">content</span></strong><span class="koboSpan" id="kobo.1002.1"> parameter is a </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.1003.1">closure that receives a geometry proxy value with the view’s position and dimensions. </span></p>
<p><span class="koboSpan" id="kobo.1004.1">To retrieve those values, we use the following properties </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">and method:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1006.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">size</span></strong><span class="koboSpan" id="kobo.1008.1"> property will return the width and height of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1"> view</span></span></li>
<li><span class="koboSpan" id="kobo.1011.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">safeAreaInsets</span></strong><span class="koboSpan" id="kobo.1013.1"> property will return an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">EdgeInsets</span></strong><span class="koboSpan" id="kobo.1015.1"> value with the insets for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">safe area</span></span></li>
<li><span class="koboSpan" id="kobo.1017.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">frame(in: )</span></strong><span class="koboSpan" id="kobo.1019.1"> method returns the position and size of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1"> view</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1022.1">Here is the code to create an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1024.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
struct ContentView: View {
    var body: some View {
           GeometryReader {_ in
            //empty geometry reader
        }.background(Color.yellow)
     }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">This is what we see when we run the code. </span><span class="koboSpan" id="kobo.1026.2">Notice how it pushes itself out to occupy all the space on the screen; the </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.1027.1">yellow background shows all the areas of this empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1029.1">, which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">entire screen.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.1031.1"><img alt="Figure 1.19: GeometryReader " src="image/B18674_01_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1032.1">Figure 1.19: GeometryReader</span></p>
<p><span class="koboSpan" id="kobo.1033.1">The default behavior </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.1034.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1036.1"> is to align its children in the upper-left corner and place them on top of each other. </span><span class="koboSpan" id="kobo.1036.2">In this next example, the code places three views </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
struct ContentView: View {
    var body: some View {
        GeometryReader {_ in
             Image(systemName: "tornado")
             Image(systemName: "tornado")
             Image(systemName: "tornado")
               }.background(Color.yellow)
            .font(.largeTitle)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1041.1">When we run this code, notice</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.1042.1"> that only one tornado image </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">is visible:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.1044.1"><img alt="Figure 1.20: GeometryReader default child alignment " src="image/B18674_01_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1045.1">Figure 1.20: GeometryReader default child alignment</span></p>
<p><span class="koboSpan" id="kobo.1046.1">There are </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.1047.1">actually three tornado images in this example, but you can only see one because the default </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.1048.1">behavior is to place them on top of each other in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">upper-left corner.</span></span></p>
<p><span class="koboSpan" id="kobo.1050.1">We obviously don’t want all the child views stacked on one another, so we will explore the following concepts to really </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">utilize </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1054.1">Sizing a view to accommodate rotating </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">the device</span></span></li>
<li><span class="koboSpan" id="kobo.1056.1">Positioning a view anywhere on </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">the screen</span></span></li>
<li><span class="koboSpan" id="kobo.1058.1">Reading a view’s position in terms of its global and </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">local space</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1060.1">We’ll look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">these</span></span><span class="No-Break"><a id="_idIndexMarker101"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1"> now.</span></span></p>
<h3><span class="koboSpan" id="kobo.1063.1">Sizing views</span></h3>
<p><span class="koboSpan" id="kobo.1064.1">Let’s first look at the property that is </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.1065.1">used to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1067.1">’s size... </span><span class="koboSpan" id="kobo.1067.2">aptly named, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">size</span></strong><span class="koboSpan" id="kobo.1069.1"> property. </span><span class="koboSpan" id="kobo.1069.2">This will return the width and height of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1071.1"> view. </span></p>
<p><span class="koboSpan" id="kobo.1072.1">Here is an example of adding an image inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1074.1"> view, and seeing how it adapts its size when the device </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">is rotated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
struct ContentView: View {
    var body: some View          
 GeometryReader { geometryProxy in
            Image("swiftui_icon")
                .resizable()
                .scaledToFit()
                .frame(width: geometryProxy.size.width / 2,                   height: geometryProxy.size.height / 4)
                .background(Color.gray)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1077.1">The following figure shows the size of the image in </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">portrait mode:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.1079.1"><img alt="Figure 1.21: GeometryReader size property (portrait) " src="image/B18674_01_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1080.1">Figure 1.21: GeometryReader size property (portrait)</span></p>
<p><span class="koboSpan" id="kobo.1081.1">In portrait mode, the image is</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.1082.1"> bigger, but when the device is rotated to landscape, the image scales down to adapt to the screen change, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.1084.1"><img alt="Figure 1.22: GeometryReader size property (landscape) " src="image/B18674_01_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1085.1">Figure 1.22: GeometryReader size property (landscape)</span></p>
<p><span class="koboSpan" id="kobo.1086.1">In this example, we added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">Image</span></strong><span class="koboSpan" id="kobo.1088.1"> view within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1090.1"> view. </span><span class="koboSpan" id="kobo.1090.2">I defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">Proxy</span></strong><span class="koboSpan" id="kobo.1092.1"> parameter as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">geometryProxy</span></strong><span class="koboSpan" id="kobo.1094.1">, but you can call it anything you want. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">geometryProxy</span></strong><span class="koboSpan" id="kobo.1096.1"> holds the information about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1098.1">’s dimensions and position. </span><span class="koboSpan" id="kobo.1098.2">Using this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">Proxy</span></strong><span class="koboSpan" id="kobo.1100.1"> object, the </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.1101.1">size of the image is changed when we rotate the device. </span><span class="koboSpan" id="kobo.1101.2">The image will be half the width of the container, and the height will be a quarter of the height of the container. </span></p>
<p><span class="koboSpan" id="kobo.1102.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">geometryProxy.size</span></strong><span class="koboSpan" id="kobo.1104.1"> lets us access the height and width of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1106.1">. </span><span class="koboSpan" id="kobo.1106.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">Image</span></strong><span class="koboSpan" id="kobo.1108.1"> view will adapt when the device is rotated. </span><span class="koboSpan" id="kobo.1108.2">I’m also using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">scaledToFit</span></strong><span class="koboSpan" id="kobo.1110.1"> modifier so that we can keep the correct aspect ratio for </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.1112.1">I set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">Image</span></strong><span class="koboSpan" id="kobo.1114.1"> view’s background to gray so that you can see the space that’s available in both portrait and landscape modes. </span><span class="koboSpan" id="kobo.1114.2">When it’s in landscape mode, there’s much more space available around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">Image</span></strong><span class="koboSpan" id="kobo.1116.1"> view because it </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">scales down.</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">Also notice that the image is positioned in the top-left corner of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1120.1"> view. </span><span class="koboSpan" id="kobo.1120.2">Again, that’s the default location for its child views; they will simply stack up on each other in that area. </span></p>
<p><span class="koboSpan" id="kobo.1121.1">Next, we will look at positioning those child views anywhere we want within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1"> container.</span></span></p>
<h3><span class="koboSpan" id="kobo.1124.1">Positioning views</span></h3>
<p><span class="koboSpan" id="kobo.1125.1">We’ve seen how </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1127.1"> can dynamically change the size of a view as it’s rotated, but it can also position the views</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.1128.1"> within it. </span><span class="koboSpan" id="kobo.1128.2">The positioning information is returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">geometryProxy</span></strong><span class="koboSpan" id="kobo.1130.1"> closure, and we can pass that information into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">x</span></strong><span class="koboSpan" id="kobo.1132.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">y</span></strong><span class="koboSpan" id="kobo.1134.1"> parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">position</span></strong><span class="koboSpan" id="kobo.1136.1"> modifier via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">size</span></strong><span class="koboSpan" id="kobo.1138.1"> property. </span><span class="koboSpan" id="kobo.1138.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
 struct ContentView: View {
    var body: some View {
 
GeometryReader { geometryProxy in
            //top right position
            VStack {
                Image(systemName: "tornado")
                .imageScale(.large)
            Text("Top Right")
                .font(.title)
            }.position(x: geometryProxy.size.width - 80, y:               geometryProxy.size.height / 40)
 
            //bottom left position
            VStack {
                Image(systemName: "tornado")
                .imageScale(.large)
                
            Text("Bottom Left")
                .font(.title)
            }.position(x: geometryProxy.size.width - 300,y:               geometryProxy.size.height - 40)
        }.background(Color.accentColor)
        .foregroundColor(.white)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1141.1">The code here has two VStacks within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1143.1">, and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">VStack</span></strong><span class="koboSpan" id="kobo.1145.1"> has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">position</span></strong><span class="koboSpan" id="kobo.1147.1"> modifier on its closing brace, so everything within the VStacks will be positioned according to the</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.1148.1"> values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">position</span></strong><span class="koboSpan" id="kobo.1150.1"> modifier’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">x</span></strong><span class="koboSpan" id="kobo.1152.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1"> parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.1155.1">The result when running this code is the placement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">Image</span></strong><span class="koboSpan" id="kobo.1157.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">Text</span></strong><span class="koboSpan" id="kobo.1159.1"> views according to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">size.width</span></strong><span class="koboSpan" id="kobo.1161.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">size.height</span></strong><span class="koboSpan" id="kobo.1163.1"> values, as shown in this figure: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.1164.1"><img alt="Figure 1.23: GeometryReader positioning views " src="image/B18674_01_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1165.1">Figure 1.23: GeometryReader positioning views</span></p>
<p><span class="koboSpan" id="kobo.1166.1">Let’s continue </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.1167.1">with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1169.1"> and see how we can read the values of </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">its position.</span></span></p>
<h3><span class="koboSpan" id="kobo.1171.1">Reading the position</span></h3>
<p><span class="koboSpan" id="kobo.1172.1">If we need to get the position of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1174.1"> view in terms of its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">coordinate</span></strong><span class="koboSpan" id="kobo.1176.1"> location, again, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">geometryProxy</span></strong><span class="koboSpan" id="kobo.1178.1"> object and pass its information into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">frame()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1181.1">There are two coordinate spaces</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.1182.1"> in SwiftUI: </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1183.1">Global space</span></strong><span class="koboSpan" id="kobo.1184.1">: The coordinates </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.1185.1">of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">entire screen</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1187.1">Local space</span></strong><span class="koboSpan" id="kobo.1188.1">: The coordinates </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.1189.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">individual views</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1191.1">When reading the values of the local coordinate space of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1193.1"> view, we will always see </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">0,0</span></strong><span class="koboSpan" id="kobo.1195.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">x</span></strong><span class="koboSpan" id="kobo.1197.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">y</span></strong><span class="koboSpan" id="kobo.1199.1">. </span><span class="koboSpan" id="kobo.1199.2">That’s because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1201.1"> always starts at that position, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">0,0</span></strong><span class="koboSpan" id="kobo.1203.1">, the top-left corner of </span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.1205.1">So, to get the position of the views in relation to where they are on the screen, we need to use the global coordinates. </span><span class="koboSpan" id="kobo.1205.2">Here is an example that gets and displays the local and global values for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">GeometryReader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1"> view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1208.1">
struct ContentView: View {
    var body: some View {
        GeometryReader { geometryProxy in
            VStack {
                Image("SwiftUIIcon")
                    .resizable()
                    .scaledToFit()
                Text("Global").font(.title)
                Text("X, Y \(geometryProxy.frame(in:                   CoordinateSpace.global).origin.x, specifier:                   "(%.f,") \(geometryProxy.frame(in: .global).                  origin.y, specifier: "%.f)")")
                Text("Local").font(.title)
                Text("X, Y  \(geometryProxy.frame(in: .local).                  origin.x, specifier: "(%.f") \(geometryProxy.                  frame(in: .local).origin.y, specifier:                   "%.f)")")
            }
        }.frame(height: 250)
    }
}</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.1209.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1210.1">Notice that the values are being formatted using a format specifier: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">%.f</span></strong><span class="koboSpan" id="kobo.1212.1">. </span><span class="koboSpan" id="kobo.1212.2">This format specifier will truncate some of the decimal places so it displays </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">fewer zeros.</span></span></p>
<p><span class="koboSpan" id="kobo.1214.1">Running the code will </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.1215.1">display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">x</span></strong><span class="koboSpan" id="kobo.1217.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">y</span></strong><span class="koboSpan" id="kobo.1219.1"> coordinate values for both the global and local space for the views, when the device is in portrait mode, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.1221.1"><img alt="Figure 1.24: Reading the position (portrait) " src="image/B18674_01_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1222.1">Figure 1.24: Reading the position (portrait)</span></p>
<p><span class="koboSpan" id="kobo.1223.1">Rotating the device into landscape mode</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.1224.1"> changes the global values to reflect the new location of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">Image</span></strong><span class="koboSpan" id="kobo.1226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">Text</span></strong><span class="koboSpan" id="kobo.1228.1"> views, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">shown here:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.1230.1"><img alt="Figure 1.25: Reading the position (landscape) " src="image/B18674_01_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1231.1">Figure 1.25: Reading the position (landscape)</span></p>
<p><span class="koboSpan" id="kobo.1232.1">The code in this example demonstrates the difference between the global and local coordinate spaces. </span><span class="koboSpan" id="kobo.1232.2">The values for the local coordinate space always return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">0,0</span></strong><span class="koboSpan" id="kobo.1234.1"> because that is the starting position of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1236.1">, but the values for the global coordinate space are the origin of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">geometryProxy</span></strong><span class="koboSpan" id="kobo.1238.1"> frame within the entire screen. </span><span class="koboSpan" id="kobo.1238.2">So, the global values change </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.1239.1">as the device is rotated because the view’s position has changed. </span><span class="koboSpan" id="kobo.1239.2">The local values do not change as they reflect the screen’s upper-left </span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">corner, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">0,0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1243.1">SwiftUI also offers properties to get the minimum, middle, and maximum coordinate positions from within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1245.1">’s frame for both the global and </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">local spaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1247.1">
Text("minX: \(geometryProxy.frame(in: .local).minX))")
Text("minX: \(geometryProxy.frame(in: .local).midX))")
Text("maxX: \(geometryProxy.frame(in: .local).maxX))")
Text("minX: \(geometryProxy.frame(in: .global).minY))")
Text("minX: \(geometryProxy.frame(in: .global).midY))")
Text("maxX: \(geometryProxy.frame(in: .global).maxY))")</span></pre>
<p><span class="koboSpan" id="kobo.1248.1">We use these properties with dot</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.1249.1"> syntax, right at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">frame</span></strong><span class="koboSpan" id="kobo.1251.1"> method. </span><span class="koboSpan" id="kobo.1251.2">Here is an example: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1252.1">
struct ContentView: View {
    var body: some View {
        GeometryReader { geometryProxy in
            VStack() {
                Spacer()
                Text("Local Values").font(.title2).bold()
                HStack() {
                    Text("minX: \(Int(geometryProxy.frame(in:                       .local).minX))")
                    Spacer()
                    Text("midX: \(Int(geometryProxy.frame(in:                       .local).midX))")
                    Spacer()
                    Text("maxX: \(Int(geometryProxy.frame(in:                       .local).maxX))")
                }
                
                Divider().background(Color.black)
                
                Text("Global Values").font(.title2).bold()
                HStack() {
                    Text("minX: \(Int(geometryProxy.frame(in:                       .global).minX))")
                    Spacer()
                    Text("midX: \(Int(geometryProxy.frame(in:                       .global).midX))")
                    Spacer()
                    Text("maxX: \(Int(geometryProxy.frame(in:                       .global).maxX))")
                }
                Spacer()
                
            }.padding(.horizontal)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1253.1">This code will return the </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.1254.1">minimum, the middle, and the maximum </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">x</span></strong><span class="koboSpan" id="kobo.1256.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">y</span></strong><span class="koboSpan" id="kobo.1258.1"> coordinates for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">GeometryReader</span></strong><span class="koboSpan" id="kobo.1260.1">’s frame and display them on the screen for both local and global spaces in portrait mode, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.1262.1"><img alt="Figure 1.26: Using the min, mid, and max properties (portrait) " src="image/B18674_01_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1263.1">Figure 1.26: Using the min, mid, and max properties (portrait)</span></p>
<p><span class="koboSpan" id="kobo.1264.1">When the device is rotated, those </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.1265.1">values will adjust to new values that reflect the change in the screen’s orientation, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.1267.1"><img alt="Figure 1.27: Using the min, mid, and max properties (landscape) " src="image/B18674_01_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1268.1">Figure 1.27: Using the min, mid, and max properties (landscape)</span></p>
<p><span class="koboSpan" id="kobo.1269.1">The SwiftUI structures you have </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.1270.1">just learned about will be the building blocks for the programs we will write going forward. </span><span class="koboSpan" id="kobo.1270.2">Rather than listing all the structures in one chapter, which can be a lot to take in, I will introduce new ones in different projects throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">the book.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.1272.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1273.1">To sum up what we learned in this chapter, we introduced SwiftUI and saw the difference between the two programming paradigms, imperative and declarative. </span><span class="koboSpan" id="kobo.1273.2">After that, we explored the Xcode interface. </span><span class="koboSpan" id="kobo.1273.3">Then, we covered the important function of the state, and finally looked at the building blocks of SwiftUI – these are fundamentals that you will use throughout this book and are an essential first step toward creating beautiful animations </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">in SwiftUI.</span></span></p>
<p><span class="koboSpan" id="kobo.1275.1">In the next chapter, we will explore animations, how they work, and the kinds of properties that can </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">be animated.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer033">
</div>
</div>
</body></html>