<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Adding Sound and Video</h1></div></div></div><p>Your game may look stunning, but if it's silent your audience will probably find it a dull experience. Fortunately, Marmalade allows us to remedy this with its support for sound and video playback. In this chapter we will learn about the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Playing back audio files recorded in formats such as MP3</li><li class="listitem" style="list-style-type: disc">Adding multiple simultaneous sound effects using sound samples</li><li class="listitem" style="list-style-type: disc">Playing back full-motion video clips</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Multimedia support in Marmalade</h1></div></div></div><p>Modern mobile phones <a id="id953" class="indexterm"/>
<a id="id954" class="indexterm"/>and tablet devices are now capable of playing back good quality music and video, so it makes sense that Marmalade should provide ways in which we can harness these abilities.</p><p>Marmalade provides three different API layers that apply to multimedia support. These are s3eSound, s3eAudio, and s3eVideo. Unsurprisingly, the latter relates to the playback of video files, but you may be wondering why there are two APIs provided relating to sound.</p><p>The difference between s3eSound and s3eAudio is that the former is generally used for sound effects while the latter is normally used for music. The s3eSound API allows us to play several different sound effects at the same time, but by default only provides support for 16-bit mono-PCM sound samples. The s3eAudio API on the other hand allows us to play compressed formats such as MP3, but we are limited (on most devices) to playing a single audio track.</p><p>The good news is that most modern devices lets us have the best of both worlds by allowing both s3eSound and s3eAudio to be used at the same time.</p><p>In the following sections we'll look at how to make use of all three of these APIs and will also take a look at another module called <code class="literal">SoundEngine</code>, that makes using the s3eSound API a bit easier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec43"/>The s3eAudio API</h1></div></div></div><p>Let's start with the quickest and easiest way of allowing our games to stop being the strong, silent type.</p><p>The<a id="id955" class="indexterm"/> s3eAudio API allows us to play compressed music formats such as MP3<a id="id956" class="indexterm"/> and <a id="id957" class="indexterm"/>AAC. Some devices may also allow us to play other formats, such as<a id="id958" class="indexterm"/> MIDI files. Marmalade makes use of whichever audio codecs a particular device may have built-in rather than decoding the audio itself, so be sure to check that your chosen audio format is supported by all the devices you wish to target.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>Due to its ubiquity, it is recommended that you use MP3 as your format of choice. There are very few devices (if any) that can't play an MP3 file and the format itself allows you a wide variety of bit rates so you can trade-off between audio quality and file size.</p></div></div><p>Let's now take a look at how we can get an audio track playing and what other functionality the s3eAudio API provides for us. There is nothing we need to add to our MKB file in order to allow us to use s3eAudio, as it is one of the low level APIs of Marmalade that is always available for use. All we need to do is include the header file <code class="literal">s3eAudio.h</code> <a id="id959" class="indexterm"/>in any source file that needs access to s3eAudio functions.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Starting audio playback</h2></div></div></div><p>There are two <a id="id960" class="indexterm"/>ways of starting the playback of an audio track. The first allows us to specify the filename of the audio track we want to play and the number of times we would like the track to repeat, and looks like this:</p><div><pre class="programlisting">s3eAudioPlay("music.mp3", aRepeatCount);</pre></div><p>The filename is just a standard C, null-terminated string and is relative to the <code class="literal">data</code> directory when run from Windows or the application install directory on the device. Specifying a number for the repeat count will cause the audio track to play that many times, while setting it to zero will cause the track to loop continuously.</p><p>The other method is to play the audio track from an area of memory as follows:</p><div><pre class="programlisting">s3eAudioPlayFromBuffer(apBuffer, aBufferLength, aRepeatCount);</pre></div><p>The parameters<a id="id961" class="indexterm"/> <code class="literal">apBuffer</code> and <code class="literal">aBufferLength</code> <a id="id962" class="indexterm"/> provide the memory location where the audio track resides and the length of audio data in bytes. The repeat count is specified in the same manner as with <code class="literal">s3eAudioPlay</code>.</p><p>In most cases we will find that the first method is good enough since it is easy to use and doesn't require us to allocate blocks of memory and fill it with data. You may find that the buffer method provides slightly faster initial playback if you have preloaded the audio data, but on most <a id="id963" class="indexterm"/>recent devices the difference is negligible.</p><p>If you make a call to either of these functions while an audio track is currently playing, that track will be stopped and the new track will begin playing.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Pausing, resuming, and stopping playback</h2></div></div></div><p>Once an audio<a id="id964" class="indexterm"/> track is playing, we can pause playback by calling the <a id="id965" class="indexterm"/> <code class="literal">s3eAudioPause</code> function. The audio can be started again from the point at which it was paused by <a id="id966" class="indexterm"/> calling <a id="id967" class="indexterm"/> <code class="literal">s3eAudioResume</code>. Finally, to <a id="id968" class="indexterm"/> stop playback <a id="id969" class="indexterm"/>completely just call <code class="literal">s3eAudioStop</code>.</p><p>All three of these functions take no parameters and will return <code class="literal">S3E_RESULT_SUCCESS</code> when no errors occur. An error is raised if any of these functions are called when it makes no sense to do so, for example calling <code class="literal">s3eAudioPause</code> when there is no audio playing.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Changing volume</h2></div></div></div><p>Like most of the low level APIs in Marmalade, s3eAudio features a pair of functions called <code class="literal">s3eAudioGetInt</code> <a id="id970" class="indexterm"/>and <code class="literal">s3eAudioSetInt</code> that are used to change <a id="id971" class="indexterm"/>attributes related to that API. In s3eAudio, one of the things we use these functions for is to change the volume of audio playback.</p><p>To set the <a id="id972" class="indexterm"/>
<a id="id973" class="indexterm"/>playback volume we can make the following call:</p><div><pre class="programlisting">s3eAudioSetInt(S3E_AUDIO_VOLUME, S3E_AUDIO_MAX_VOLUME / 2);</pre></div><p>In the aforementioned example we set the volume to half of <code class="literal">S3E_AUDIO_MAX_VOLUME</code>, which is the maximum allowed volume.</p><p>To determine the current volume we use this code:</p><div><pre class="programlisting">int32 lVolume = s3eAudioGetInt(S3E_AUDIO_VOLUME);</pre></div><p>We can also request the default volume for audio by passing in the value <code class="literal">S3E_AUDIO_VOLUME_DEFAULT</code>. This is the default volume level for playing audio and has been chosen by the Marmalade SDK so as to provide a fairly consistent volume level across all devices.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Other audio queries</h2></div></div></div><p>The <code class="literal">s3eAudioGetInt</code> function <a id="id974" class="indexterm"/>allows us to make several other queries regarding audio playback. The following table shows which properties can be specified:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_STATUS</code>
<a id="id975" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns current audio status—one of <code class="literal">S3E_AUDIO_STOPPED</code>, <code class="literal">S3E_AUDIO_PLAYING</code>, <code class="literal">S3E_AUDIO_PAUSED</code>, or <code class="literal">S3E_AUDIO_FAILED</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_POSITION</code>
<a id="id976" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the current position in the audio track in milliseconds, or <code class="literal">0</code> if no track is playing. Note that not all platforms support this feature.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_CHANNEL</code>
<a id="id977" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the currently selected audio channel. This property can also be used in <code class="literal">s3eAudioSetInt</code> to select which audio channel the future audio commands will be applied to. See the following property for more on audio channels.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_NUM_CHANNELS</code>
<a id="id978" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the number of audio channels available. On most platforms this will return <code class="literal">1</code> since most devices only allow a single audio track to be played at any time. Some devices provide more than one channel, meaning more than one audio track can be played simultaneously.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_MUTES_S3ESOUND</code>
<a id="id979" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the hardware is not capable of outputting sound through both s3eAudio and s3eSound at the same time. In this instance playing an audio track will cause s3eSound processing to continue, but without actually producing any output.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_DURATION</code>
<a id="id980" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the length, in milliseconds, of the track currently playing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE</code>
<a id="id981" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the hardware is able to play an audio track by streaming from a URL.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec107"/>End of track notification</h2></div></div></div><p>There are two <a id="id982" class="indexterm"/>methods we can use to determine when an audio track has finished. One is to use a polled approach, the other is to make use of a callback.</p><p>To poll whether an audio track has completed or not, we can do the following:</p><div><pre class="programlisting">if (s3eAudioIsPlaying() == S3E_FALSE)
{
  // Audio is not playing!
}</pre></div><p>This function returns <code class="literal">S3E_TRUE</code> if the audio is currently playing, or <code class="literal">S3E_FALSE</code> if it is stopped or paused. This function is actually just a shortcut for calling <code class="literal">s3eAudioGetInt</code> with the property <a id="id983" class="indexterm"/> <code class="literal">S3E_AUDIO_STATUS</code>.</p><p>The callback approach is also very simple to use, as the following code snippet shows:</p><div><pre class="programlisting">int32 AudioFinished(s3eAudioCallbackData* apAudioData,
void* apUserData)
{
  // apAudioData-&gt;m_ChannelID identifies the audio channel that
  // has completed.
  // s3eCallback functions must return a value, but in case of
  // audio callback the value returned does not matter.
  return 0;
}

// Use the following line to set up the audio callback
s3eAudioRegister(S3E_AUDIO_STOP, (s3eCallback) AudioFinished, NULL);

// And this line to remove the callback function
s3eAudioUnRegister(S3E_AUDIO_STOP, (s3eCallback) AudioFinished);</pre></div><p>The callback <a id="id984" class="indexterm"/>function will be called whenever an audio track finishes and will pass the pointer to user data supplied as the last parameter in the <code class="literal">s3eAudioRegister</code> call by using the <a id="id985" class="indexterm"/> <code class="literal">apUserData</code> argument. It will not be called if we have asked the audio track to be looped unless it is the last repetition. The function will also be called if the audio is stopped due to an error, such as a corrupted track. We can determine whether completion was caused due to error by calling the <a id="id986" class="indexterm"/> <code class="literal">s3eAudioGetError</code> function, which returns an error code of the enumerated type <code class="literal">s3eAudioError</code>. A complete list of error codes can be found in <code class="literal">s3eAudio.h</code>.</p><p>The decision of whether to use the polling or callback-based approach depends on your application, and indeed quite often in games we don't even really care that much about when an audio track has finished as we often just want the same track to loop forever until a new piece of audio is required. If you are just waiting for a jingle to finish during a splash screen, the polled method is probably adequate, but if you want to join several tracks together one after the other, the callback approach would probably lead to a clean solution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>The s3eSound API</h1></div></div></div><p>If you want to <a id="id987" class="indexterm"/>add spot sound effects to your game, such as laser bolts and explosions, the s3eSound API is what you need to use. This API allows multiple sound samples to be played simultaneously at different volumes and pitch by mixing them together into a single output.</p><p>To make use of the s3eSound API, simply include the file <code class="literal">s3eSound.h</code> in your source code.</p><p>The API expects all sound effects to be supplied as uncompressed 16-bit signed PCM. File formats such as WAV are not supported by the API, so you must write your own code to load and extract the sample data from such files.</p><p>As you read through this section you may start to think that there's an awful lot to do in order to play some sound effects. While this may appear to be the case, s3eSound is actually a very low-level API and provides enough flexibility to allow you to code your own complex sound routines.</p><p>Later in this chapter we will be covering the <code class="literal">SoundEngine</code> module, which comes with Marmalade to provide a wrapper for the s3eSound API. The <a id="id988" class="indexterm"/> <code class="literal">SoundEngine</code> module takes care of most of the hard work involved in using the s3eSound API for us and also includes the ability to load WAV files directly from a GROUP file.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Starting sound playback</h2></div></div></div><p>In order to play a <a id="id989" class="indexterm"/>
<a id="id990" class="indexterm"/>sound sample using s3eSound, the first thing we have to do is allocate a free sound channel. The s3eSound API provides a limited number of channels (we'll see later how to determine exactly how many are available) that allow us to specify a sound sample, volume, and playback rate. The sound data for all currently active channels is then mixed together in the inner workings of s3eSound into a single waveform and this is what is played through the device's sound hardware. To allocate a free channel, we make the following function call:</p><div><pre class="programlisting">int32 lChannel = s3eSoundGetFreeChannel();</pre></div><p>This will return the ID number of a free channel, or <code class="literal">-1</code> if no channel is available. Most of the time it is unlikely that a free channel will not be available, but if we are playing a lot of sound effects we might want to consider tagging each of our sound effects with a priority value and maintaining a list of currently active sounds. When we run out of channels, we can check the list of sounds and reclaim the channel being used by the lowest priority sound effect, assuming that it is at a lower priority than the sound we wish to start of course!</p><p>Assuming a channel is available we must set up the playback rate of our sample data, which is done like this:</p><div><pre class="programlisting">s3eSoundChannelSetInt(lChannel, S3E_CHANNEL_RATE, lFrequency);</pre></div><p>The first <a id="id991" class="indexterm"/>
<a id="id992" class="indexterm"/>parameter is the sound channel ID we just allocated. The second parameter indicates that we want to set the playback rate for that channel, and the third parameter is the actual desired playback rate in Hertz (Hz). The maximum frequency that can be set is specified by the define <code class="literal">S3E_SOUND_MAX_FREQ</code>.</p><p>We should also set the volume that we want the sound to be played at, which is also done using the <a id="id993" class="indexterm"/> <code class="literal">s3eSoundChannelSetInt</code> function:</p><div><pre class="programlisting">s3eSoundChannelSetInt(lChannel, S3E_CHANNEL_VOLUME, lVolume);</pre></div><p>The valid values for the <code class="literal">lVolume</code> parameter are from <code class="literal">0</code> to the define <code class="literal">S3E_SOUND_MAX_VOLUME</code>.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>It is possible to change the volume and playback rate at any time once the sound has started playing. This makes it possible to implement effects such as volume fades or pitch shifts.</p></div></div><p>Now we can start playing our sound sample. We do this with the following call:</p><div><pre class="programlisting">s3eSoundChannelPlay(lChannel, lSampleData, lNumSamples, lRepeatCount,
lLoopIndex);</pre></div><p>Unsurprisingly, we first pass in the channel ID we are using, followed by the address in memory where the 16-bit PCM sample data can be found in the <a id="id994" class="indexterm"/> <code class="literal">lSampleData</code> parameter. The <code class="literal">lNumSamples</code> parameter <a id="id995" class="indexterm"/> is the number of actual sound samples in our waveform (not the number of bytes), and <code class="literal">lRepeatCount</code> <a id="id996" class="indexterm"/>indicates how often we want the sound to repeat. A value of <code class="literal">0</code> will play the sound forever. Finally the <code class="literal">lLoopIndex</code> parameter <a id="id997" class="indexterm"/> allows us to specify which sample to start at if the sound repeats. This makes it possible to use sounds that only need to repeat a portion of the sample data.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Pausing, resuming, and stopping playback</h2></div></div></div><p>Once a sound channel has started playing a sound sample, we might want to temporarily suspend its playback or stop it entirely. To pause a <a id="id998" class="indexterm"/> sound channel we use the function <a id="id999" class="indexterm"/> <code class="literal">s3eSoundChannelPause</code>, and we can start playing it again from the paused position using <a id="id1000" class="indexterm"/>
<a id="id1001" class="indexterm"/> <code class="literal">s3eSoundChannelResume</code>. To stop a <a id="id1002" class="indexterm"/>
<a id="id1003" class="indexterm"/>sound channel entirely we call <code class="literal">s3eSoundChannelStop</code>. Each of these functions takes a single parameter, which is the channel ID we want to affect.</p><p>To determine the current <a id="id1004" class="indexterm"/>
<a id="id1005" class="indexterm"/>playback status of a particular sound channel we can use the <code class="literal">s3eSoundChannelGetInt</code> function as follows:</p><div><pre class="programlisting">if (s3eSoundChannelGetInt(lChannel, S3E_CHANNEL_STATUS) == 1)
{
  // Sound channel is currently playing
}

if (s3eSoundChannelGetInt(lChannel, S3E_CHANNEL_PAUSED) == 1)
{
  // Sound channel is currently active, but paused
}</pre></div><p>Note that this function can also be used with the <a id="id1006" class="indexterm"/> <code class="literal">S3E_CHANNEL_RATE</code> and <code class="literal">S3E_CHANNEL_VOLUME</code> <a id="id1007" class="indexterm"/>properties to discover the current sample rate and volume for a particular channel.</p><p>Finally, it is also possible to affect all currently active sound channels at once using the functions <code class="literal">s3eSoundPauseAllChannels</code>, <code class="literal">s3eSoundResumeAllChannels</code>, and <code class="literal">s3eSoundStopAllChannels</code>. These functions take no inputs and are extremely useful for handling situations like going in and out of pause mode, or when switching from one part of the game to another (for example, when exiting the title screen and entering the main game).</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec110"/>Global sound settings</h2></div></div></div><p>As well as being <a id="id1008" class="indexterm"/>
<a id="id1009" class="indexterm"/>able to read and write settings on a per channel basis, we can also make settings that affect sound support globally. To do this we use the <a id="id1010" class="indexterm"/> <code class="literal">s3eSoundSetInt</code> and <a id="id1011" class="indexterm"/> <code class="literal">s3eSoundGetInt</code> functions as follows:</p><div><pre class="programlisting">// To read a global sound setting
int32 lValue = s3eSoundGetInt(lProperty);

// To change a global sound setting
s3eSoundSetInt(lProperty, lValue);</pre></div><p>Here are some of the more useful values for the <a id="id1012" class="indexterm"/> <code class="literal">lProperty</code> parameter:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_VOLUME</code>
<a id="id1013" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Can be used to read or write the current master sound volume. This will scale the volumes of each individual channel appropriately. The maximum value is determined by the define <code class="literal">S3E_SOUND_MAX_VOLUME</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_DEFAULT_FREQ</code>
<a id="id1014" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the default frequency that will be used when starting playback on a sound channel. If all our sound waveforms have the same sample rate, it is possible to write to this property once and not have to set the sample rate explicitly when playing each individual sound.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_NUM_CHANNELS</code>
<a id="id1015" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A read-only value indicating the maximum number of simultaneous sounds that can be played.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_USED_CHANNELS</code>
<a id="id1016" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id1017" class="indexterm"/> read-only value that shows which sound channels are currently in use. This is returned as a bit mask with the least significant bit relating to sound channel 0. This value could be used to determine an available sound channel, but for future compatibility using <code class="literal">s3eSoundGetFreeChannel</code> to do this is recommended.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_AVAILABLE</code>
<a id="id1018" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A read-only value that returns <code class="literal">1</code> if s3eSound is available on the device.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_SOUND_VOLUME_DEFAULT</code>
<a id="id1019" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A read-only value that is used as the default value for the global sound volume. It can vary from device to device and is intended to allow sound output to be at a similar volume across all devices.</p>
</td></tr></tbody></table></div><p>There are other values described in the <a id="id1020" class="indexterm"/>
<a id="id1021" class="indexterm"/>Marmalade documentation, but we won't cover them here as they are used for purposes such as custom sound stream generation, which are beyond the scope of this book.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Sound notifications</h2></div></div></div><p>We have already <a id="id1022" class="indexterm"/>seen how to use a polled method of detecting whether or not a sound channel is currently playing, but sometimes it is useful to know exactly when a sound sample has finished playing, for example, so we can immediately start playing back a new sound effect.</p><p>The s3eSound API allows us to set several different callback functions on a per channel basis and we use the functions <code class="literal">s3eSoundChannelRegister</code> and <code class="literal">s3eSoundChannelUnRegister</code> to enable and disable them as follows:</p><div><pre class="programlisting">// To set up a sound channel callback
s3eSoundChannelRegister(lChannel, lCallbackType, (s3eCallback)
              CallbackFunction, lpUserData);

// To disable a sound channel callback
s3eSoundChannelUnRegister(lChannel, lCallbackType);</pre></div><p>As with all other <a id="id1023" class="indexterm"/>Marmalade callbacks, we specify the code for the callback function by passing in a pointer to the function itself, and we can also register a block of user data that will be passed into this function when it is triggered. There are four different callback types called <code class="literal">S3E_CHANNEL_END_SAMPLE</code>, <code class="literal">S3E_CHANNEL_STOP_AUDIO</code>, <code class="literal">S3E_CHANNEL_GEN_AUDIO</code>, and <code class="literal">S3E_CHANNEL_GEN_AUDIO_STEREO</code>. We will only take a look at the first two of them here, as the latter two are concerned with generating custom audio streams and are beyond the scope of this book. For an example of how to use these callback types, take a look at the source code for the <code class="literal">SoundEngine</code> module, which we'll be covering in the next section.</p><p>First let's look at the <code class="literal">S3E_CHANNEL_END_SAMPLE</code> callback, which allows us to loop sounds and join different sounds together as a sequence. The registered callback function is passed a pointer to an <code class="literal">s3eSoundEndSampleInfo</code> structure as its first parameter. The structure indicates which sound channel has ended by using its <code class="literal">m_Channel</code> member.</p><p>If we want to start a completely new sound playing on this channel, we can set the <code class="literal">m_NewData</code> member of the <code class="literal">s3eSoundEndSampleInfo</code> structure to the start address of the new sample data, and the <code class="literal">m_NumSamples</code> member to the number of samples in the new waveform.</p><p>The structure also contains a member called <code class="literal">m_RepsRemaining</code>, which allows us to change the number of repetitions of the sample data we want on this sound channel. Note, though, that this callback will still be triggered every time the end of the sample data has been reached.</p><p>If we wish the channel to continue playing sample data, be it the original data or a new sample specified using the <code class="literal">m_NewData</code> and <code class="literal">m_NumSamples</code> members of the <code class="literal">s3eSoundEndSampleInfo</code> structure, we must return a non-zero value from the callback function. If zero is returned, the sound channel will stop playing.</p><p>The following code example puts the functionality described previosuly into practice:</p><div><pre class="programlisting">// Simple structure used to indicate the next sound sample to play
typedef struct
{
  void* mSampleData;
  uint32 mSampleCount;
} NewSoundData;

// Sample callback function that will start a new sound effect
// playing if one has been specified when registering the
// callback function
int32 SoundEndCallback(s3eSoundEndSampleInfo* apInfo,
   NewSoundData* apSound)
{
  if (apSound)
  {
     apInfo-&gt;m_NewData = apSound-&gt;mSampleData;
     apInfo-&gt;m_NumSamples = apSound-&gt;mSampleCount;
     apInfo-&gt;m_RepsRemaining = 1;
  }
  return apInfo-&gt;m_RepsRemaining;
}

// Register the callback function to play a new sound when
// current sound completes
s3eSoundChannelRegister(lChannel, S3E_CHANNEL_END_SAMPLE,
   (s3eCallback) SoundEndCallback,
   &amp;lNewSoundDataInstance);</pre></div><p>The second <a id="id1024" class="indexterm"/>callback type we'll consider is <code class="literal">S3E_CHANNEL_STOP_AUDIO</code>. This callback will occur whenever a sound channel finishes playing a sound completely (for example, if we have an <code class="literal">S3E_CHANNEL_END_SAMPLE</code> callback set and we return zero from it to end all playback). It is passed a pointer to an <code class="literal">s3eSoundEndSampleInfo</code> structure, but the only valid field is the <code class="literal">m_Channel</code> member.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>The SoundEngine module</h1></div></div></div><p>As the <a id="id1025" class="indexterm"/> previous section of this chapter shows, the basics of using s3eSound are actually fairly straightforward. The main issue that we have to deal with as developers is the fact that s3eSound can only support raw uncompressed 16-bit PCM samples, which means it is our responsibility to get the sound data into memory so it can be played.</p><p>One of the most common file formats for storing sound samples is the WAV file, so wouldn't it be great if we could use this format to store our sound effects? Wouldn't it also be great if we could load these files into memory using the same resource manager code that we've used for textures and 3D models?</p><p>The answer to our prayers is the <code class="literal">SoundEngine</code> module, which is a layer that sits on top of s3eSound and allows us to easily load and access sound effects using the resource manager.</p><p>The <code class="literal">SoundEngine</code> module <a id="id1026" class="indexterm"/>doesn't just stop there though. It also wraps up the s3eSound calls we've learnt about in this chapter and it allows us to support a further sound format that can be stored in WAV files—namely the compressed IMA ADPCM type. This is particularly useful given that sound sample data can be quite large in size; so this format helps us claw back some memory space at the expense of a slight drop in sound quality.</p><p>The following sections give a brief introduction to using this module, but for full details you should refer to the source and header files to see all the functionality <code class="literal">SoundEngine</code> has to offer. The sound example project accompanying this chapter also makes use of this module, so take a look at that to learn more.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec112"/>Adding the SoundEngine module to a project</h2></div></div></div><p>The <a id="id1027" class="indexterm"/>
<a id="id1028" class="indexterm"/> <code class="literal">SoundEngine</code> module actually ships with the Marmalade SDK, but it lives, awkwardly, in the <code class="literal">examples</code> directory. The easiest way to solve this is to just copy the entire <code class="literal">SoundEngine</code> directory to the directory where your project resides and then reference it by adding <code class="literal">SoundEngine</code> to your MKB files subprojects. This is the same approach we used with the GUI and <code class="literal">Localise</code> modules that were introduced in the sample code for the previous chapter.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>The location of the <code class="literal">SoundEngine</code> module in the <code class="literal">examples</code> folder means it isn't really considered part of the main Marmalade SDK. In practice it is highly unlikely that the <code class="literal">SoundEngine</code> code will suddenly disappear from the SDK, since the s3eSound API is unlikely to change drastically from what it is now; so you shouldn't have any concerns about using it directly in your own projects. If you prefer to write your own code, <code class="literal">SoundEngine</code> does at least serve the purpose of being a very good example of how to use the s3eSound API.</p></div></div><p>With the module added to our project, we can include the file <code class="literal">IwSound.h</code> in our code to make use of it. A call to <code class="literal">IwSoundInit</code> is needed to set everything up and a call to <code class="literal">IwSoundTerminate</code> cleans up at the end of our program.</p><p>We must also add a custom resource handler to allow WAV files to be loaded by the resource manager. The following code snippet will do the trick:</p><div><pre class="programlisting">IwGetResManager()-&gt;AddHandler(new CIwResHandlerWAV);</pre></div><p>Finally, there is a manager class that takes care of all sound-related events and we must ensure that we call the <code class="literal">Update</code> method of this class somewhere within the main game loop. We do <a id="id1029" class="indexterm"/>
<a id="id1030" class="indexterm"/>this with the following line of code:</p><div><pre class="programlisting">IwGetSoundManager()-&gt;Update();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec113"/>Loading and accessing sound resources</h2></div></div></div><p>To load a WAV file all <a id="id1031" class="indexterm"/>
<a id="id1032" class="indexterm"/>
<a id="id1033" class="indexterm"/>
<a id="id1034" class="indexterm"/>we have to do is add a reference to its filename into a GROUP file, though we still need to do a little more in order to be able to play the sound back. What we need to do is declare an instance of the class <code class="literal">CIwSoundSpec</code>.</p><p>This class allows us to reference a particular sound sample by name and lets us set a volume and pitch to play the sound at. We can also specify whether or not we want the sound to loop (note that <code class="literal">SoundEngine</code> currently provides no way of specifying the number of times to loop the sound; we can only indicate continuous looping). Here's an example definition:</p><div><pre class="programlisting">CIwSoundSpec
{
  name gun1
  data gun_shot1

  // Play at the default pitch for the sample
  pitch 1.0

  // Play at half volume
  vol 0.5

  // Do we want this sound to loop?
  looping false
}</pre></div><p>The <code class="literal">pitch</code> and <code class="literal">vol</code> (volume) parameters are specified as fractional scales, where <code class="literal">1.0</code> indicates the default pitch or volume level of a sound. We can also specify a range for both these parameters that allows a random value to be chosen when starting the sound. Specifying a range for the pitch can be quite useful to add a bit of variety to the sound effects in your game without having to add lots of slightly different sound samples. </p><p>The example below shows how to <a id="id1035" class="indexterm"/>
<a id="id1036" class="indexterm"/>specify ranges for the volume and pitch:</p><div><pre class="programlisting">CIwSoundSpec
{
  name gun2
  data gun_shot2

  // Choose a random pitch when playing this sound
  pitchMin 0.9
  pitchMax 1.1

  // Choose a random volume when playing this sound
  volMin 0.9
  volMax 1.1

  // Do we want this sound to loop?
  looping false
}</pre></div><p>Another useful <a id="id1037" class="indexterm"/>
<a id="id1038" class="indexterm"/>
<a id="id1039" class="indexterm"/>
<a id="id1040" class="indexterm"/>class that we have access to is<a id="id1041" class="indexterm"/> <code class="literal">CIwSoundGroup</code>. This allows us to collect a number of different sound effects together and pause, resume, stop, or alter the volume or pitch of any that are currently being played all at the same time. Note that a sound group only allows a single volume or pitch value to be specified, not a random range:</p><div><pre class="programlisting">CIwSoundGroup
{
   name guns

   // Reduce volume of all gun sounds by a half
   vol 0.5

   // Include the gun1 sound in this group
   addSpec gun1
}</pre></div><p>Sounds can be added to groups using the<a id="id1042" class="indexterm"/> <code class="literal">addSpec</code> keyword, or alternatively you can add <code class="literal">CIwSoundSpec</code> to a group when it is defined by using the <code class="literal">group</code> keyword <a id="id1043" class="indexterm"/>followed by the group name, in its definition. We can use either method, but the group or sound must have been declared before we make reference to it.</p><p>To access a sound specification or group, we just load the GROUP file and retrieve them using the resource manager in the normal way. Here's an example:</p><div><pre class="programlisting">IwGetResManager()-&gt;LoadGroup("sounds.group");
CIwSoundSpec* lpGunSpec = static_cast&lt;CIwSoundSpec*&gt;(
  IwGetResManager()-&gt;GetResNamed("gun1", "CIwSoundSpec"));
CIwSoundGroup* lpGunsGroup = static_cast&lt;CIwSoundGroup*&gt;(
  IwGetResManager()-&gt;GetResNamed("guns", "CIwSoundGroup"));</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Playing, stopping, and altering sound parameters</h2></div></div></div><p>Once we have hold of a pointer to <code class="literal">CIwSoundSpec</code> we can start playing it by calling the<a id="id1044" class="indexterm"/> <code class="literal">Play</code> method, which will do all the behind-the-scenes stuff of allocating a free channel and setting volume and playback speed. The <code class="literal">Play</code> method<a id="id1045" class="indexterm"/> can be <a id="id1046" class="indexterm"/>
<a id="id1047" class="indexterm"/>
<a id="id1048" class="indexterm"/>passed an optional parameter, which is an instance of the class <code class="literal">CIwSoundParams</code>, that allows the volume and pitch to be modified when starting the sound.</p><p>The <code class="literal">Play</code> method returns a pointer to a<a id="id1049" class="indexterm"/> <code class="literal">CIwSoundInst</code> class, which has methods to allow that single instance of the sound to have its volume or pitch modified, and also provides methods called <code class="literal">Pause</code>, <code class="literal">Resume</code>, and <code class="literal">Stop</code>, which should be self explanatory! If no free sound channel is available, the <code class="literal">Play</code> method will return <code class="literal">NULL</code>.</p><p>If we have a pointer to <code class="literal">CIwSoundGroup</code> we can affect all currently playing instances of sounds contained within it. Again there are <code class="literal">Pause</code>, <code class="literal">Resume</code>, and <code class="literal">Stop</code> methods that do what you would expect, plus there are the methods <code class="literal">SetVol</code> <a id="id1050" class="indexterm"/>and <code class="literal">SetPitch</code> <a id="id1051" class="indexterm"/>that will scale the current volume and pitch of the sounds. These methods use the value <code class="literal">IW_GEOM_ONE</code> (4096) to indicate a scale of one.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>The s3eVideo API</h1></div></div></div><p>We'll finish our <a id="id1052" class="indexterm"/>look at Marmalade's multimedia support by having a whirlwind look at support for playing video clips using the s3eVideo API. To make use of the functions it provides, we just need to include the <code class="literal">s3eVideo.h</code> file into our source code.</p><p>Before we begin, there are two things to consider when using video clips in our games. The first is that while it is possible to specify where on the screen the video clip will appear, it will always be drawn on top of all other graphics. The second issue is that due to hardware limitations in many mobile devices, the s3eVideo API cannot be used at the same time as the s3eAudio and s3eSound APIs. In the case of s3eAudio, any currently playing track will be stopped (this also applies the other way around—starting an audio track will stop a currently playing video clip). The s3eSound API will continue processing its events while a video clip is playing, but its sound output will be silenced until the video clip is finished. For most games we would probably decide it is best to explicitly stop all s3eSound playback before starting a video clip, particularly if we are doing anything advanced like joining sound samples together using the callback system.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec115"/>Starting video playback</h2></div></div></div><p>The s3eVideo API works in a<a id="id1053" class="indexterm"/> similar manner to the s3eAudio API. To <a id="id1054" class="indexterm"/>start playing a video clip we use the <code class="literal">s3eVideoPlay</code> function, specifying the filename of the video clip, the number of times we want it to loop, a screen position, and the size that we want to display it at, as follows:</p><div><pre class="programlisting">s3eVideoPlay(lFileName, lRepeatCount, lX, lY, lWidth, lHeight);</pre></div><p>The video clip will automatically resize to fit the rectangle, but no attempt is made to keep the correct aspect ratio.</p><p>Where possible it is usually best to try to make your video clips the same resolution as the rectangular area you want to display them in. This will avoid any unnecessary stretching of the image (which can look quite ugly!) and may lead to slightly better performance, though on most modern devices the resize will be happening in hardware and there will be no appreciable difference.</p><p>The actual size of the video file itself is also worth bearing in mind, since we often want to minimize the size of the final install package. Ultimately, we need to use a bit of trial and error until we get a result that ticks all the boxes for acceptable quality, performance, and file size.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Determining video codec support</h2></div></div></div><p>The s3eVideo API <a id="id1055" class="indexterm"/>makes use of the device's built-in video decoding, so not all video formats will be playable on all devices. To determine whether support <a id="id1056" class="indexterm"/>for a particular codec is available, there is a function called <code class="literal">s3eVideoIsCodecSupported</code> that takes a value from the <code class="literal">s3eVideoCodec</code> enum. Take a look at the <code class="literal">s3eVideo.h</code> file or the Marmalade documentation for a complete list of possible values.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec117"/>Pausing, resuming, and stopping video playback</h2></div></div></div><p>Again the<a id="id1057" class="indexterm"/>
<a id="id1058" class="indexterm"/>
<a id="id1059" class="indexterm"/> parallels with the s3eAudio API are apparent when it comes to controlling video playback. The <a id="id1060" class="indexterm"/>functions <code class="literal">s3eVideoPause</code>,<a id="id1061" class="indexterm"/> <code class="literal">s3eVideoResume</code>, and<a id="id1062" class="indexterm"/> <code class="literal">s3eVideoStop</code> all take no parameters and are used to pause, resume, and finish video clip playback respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec118"/>End of video notification</h2></div></div></div><p>We have the<a id="id1063" class="indexterm"/> choice of polling or callbacks once more for detecting the end of video playback. Let's start with the polled method that involves a call to the function <code class="literal">s3eVideoIsPlaying</code>, which will return <code class="literal">S3E_TRUE</code> if a video is playing or <code class="literal">S3E_FALSE</code> if a video is paused or stopped. Quite simple really!</p><p>If we want to use the callback approach, the following code snippet illustrates what to do:</p><div><pre class="programlisting">int32 VideoFinished(void* apSystemData, void* apUserData)
{
  // apSystemData will always be NULL as there is no data associated
  // with this callback.
  // Return value is unimportant.
  return 0;
}

// To set up the callback function
s3eVideoRegister(S3E_VIDEO_STOP, (s3eCallback) VideoFinished, NULL);

// And to cancel it again...
s3eVideoUnRegister(S3E_VIDEO_STOP, (s3eCallback) VideoFinished);</pre></div><p>The callback will be triggered whenever video playback stops, either because we explicitly call <code class="literal">s3eVideoStop</code>, an error in playback such as a corrupted video file occurs, or if an audio track is started using <code class="literal">s3eAudioPlay</code>. Note that the callback is not triggered between repetitions of the video clip if we are looping it.</p><p>For most games, video clips will probably only be used during introductory sequences or tutorials, since using video in the game itself is probably not practical. With this in mind, a polled approach for detecting when a video clip is finished is normally sufficient.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec119"/>Other video queries</h2></div></div></div><p>The s3eVideo API, <a id="id1064" class="indexterm"/>like the s3eSound and s3eAudio APIs, also has a pair of functions for reading and writing global video parameters. They are called <code class="literal">s3eVideoGetInt</code> and <code class="literal">s3eVideoSetInt</code>. They are called as follows:</p><div><pre class="programlisting">int32 lValue = s3eVideoGetInt(lProperty);
s3eVideoSetInt(lProperty, lValue);</pre></div><p>The following table shows the values that can be used for the <code class="literal">lProperty</code> parameter<a id="id1065" class="indexterm"/>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_VIDEO_VOLUME</code>
<a id="id1066" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This property is used to find the current volume level for the sound associated with the video clip and also to set a new volume. The maximum volume level is defined by the value <code class="literal">S3E_VIDEO_MAX_VOLUME</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_VIDEO_DEFAULT_VOLUME</code>
<a id="id1067" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a read-only property that shows the default volume that will be used for playing back the sound in a video clip. Its value is intended to provide a similar level of volume across all device types.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_VIDEO_STATUS</code>
<a id="id1068" class="indexterm"/>
<a id="id1069" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a read-only parameter showing the current status of the video playback. It will return one of the following values: <code class="literal">S3E_VIDEO_STOPPED</code>, <code class="literal">S3E_VIDEO_PLAYING</code>, <code class="literal">S3E_VIDEO_PAUSED</code>, or <code class="literal">S3E_VIDEO_FAILED</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_VIDEO_POSITION</code>
<a id="id1070" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This property returns the current playback position of the video in milliseconds, or <code class="literal">0</code> if no video is playing. This parameter cannot be written to, so it is not possible to jump to a particular point in a video clip.</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Example code</h1></div></div></div><p>This chapter has three example projects associated with it and they are described in the following sections. The sound, audio, and video clips used in these projects were sourced from a couple of great websites that offer a vast variety of stock media for free! Links to these websites are provided here:</p><p>
<a class="ulink" href="http://www.royalty-free-music-room.com">http://www.royalty-free-music-room.com</a>
</p><p>
<a class="ulink" href="http://www.partnersinrhyme.com">http://www.partnersinrhyme.com</a>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec120"/>The Sound project</h2></div></div></div><p>This project<a id="id1071" class="indexterm"/> demonstrates use of the s3eAudio API and the <code class="literal">SoundEngine</code> module (which in turn makes use of s3eSound).</p><p>On running the example you'll be presented with three clickable buttons that have been implemented using the GUI module introduced in the last chapter. The first button toggles an MP3 track on and off using s3eAudio, while the other two start some sound effects using <code class="literal">SoundEngine</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec121"/>The Video project</h2></div></div></div><p>This is <a id="id1072" class="indexterm"/>another simple example showing how to use the s3eVideo API to start and stop a video clip. A button at the bottom of the screen will start and stop a video clip, which is played in a continuous loop.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec122"/>The Skiing project</h2></div></div></div><p>Finally we <a id="id1073" class="indexterm"/>come to the Skiing project once again and it will come as no surprise that it has been enhanced by the addition of some music and sound effects.</p><p>The main menu now plays an MP3 audio track while waiting for the player to press a button. On pressing a button, a confirmation sound effect is played.</p><p>In the game itself, several sounds have been added. A swooshing sound is produced, by using a looping sample, whenever the skier moves and the pitch of this sample is decreased as the player turns, to make things sound a little more dynamic.</p><p>Other sounds that have been added include a selection of celebratory sounds for when the player passes through a gate, a painful-sounding yell for when the player collides with an obstacle, and a springy sound that gets played when the player collides with a flag pole and causes it to wobble.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Summary</h1></div></div></div><p>As this chapter draws to a close, our look at Marmalade's multimedia support has now given us the ability to play sound effects, music tracks, and also play back video clips.</p><p>There are very few games that don't feature sound or music of some sort, and adding a few sound effects can make a world of difference to your game. While not all games need to make use of video, it is nice to know we have it at our disposal should we ever need to use it.</p><p>In the next chapter we'll be looking at how Marmalade can make it easier for us to target as wide a range of devices as possible, from entry-level handsets to top-of-the-range ones.</p></div></body></html>