- en: Chapter 9. Writing Code the Swift Way – Design Patterns and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 以Swift方式编写代码 – 设计模式和技巧
- en: Unless you are on the cutting edge of computer science, most of the software
    you write will be more focused on user experience and maintainability than on
    any particular advanced programming language. As you write more and more of this
    type of software, you will see a lot of patterns emerge, especially if you focus
    on readability and maintainability, as most of us should. However, we don't have
    to come up with all of these patterns on our own; people have been programming
    and coming up with patterns for years that transfer really well from language
    to language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是计算机科学的尖端人物，否则你编写的软件将更多地关注用户体验和可维护性，而不是任何特定的先进编程语言。随着你编写越来越多的这类软件，你将看到许多模式出现，特别是如果你专注于可读性和可维护性，正如我们大多数人应该做的那样。然而，我们不必自己想出所有这些模式；多年来，人们一直在编程，并提出了许多模式，这些模式可以从一种语言很好地转移到另一种语言。
- en: We call these patterns, **design patterns**. Design patterns is a massive topic
    with countless books, tutorials, and other resources. We spend our entire careers
    practicing, shaping, and perfecting the use of these patterns in practical ways.
    We give each pattern a name so that we can have smoother conversations with fellow
    programmers and also organize them better in our own minds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这些模式称为**设计模式**。设计模式是一个庞大的主题，有无数本书籍、教程和其他资源。我们花费我们整个职业生涯来练习、塑造和完善这些模式在实践中的应用。我们给每个模式起一个名字，这样我们就可以与同行程序员进行更流畅的对话，并在我们自己的脑海中更好地组织它们。
- en: In this chapter, we will take a look at some of the most common design patterns,
    especially the ones important to understand Apple's frameworks. You will have
    a much easier time understanding and making use of that code when you begin to
    recognize patterns while using other people's code. It will also help you write
    better code yourself. We will focus on the high level ideas behind each pattern
    and then how to implement them in Swift. We will then go past the classic design
    patterns and look at some advanced features of Swift that allow us to write particularly
    clean code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些最常见的设计模式，特别是那些对理解苹果框架很重要的模式。当你开始在使用他人代码时识别模式时，你将更容易理解和利用那段代码。这也有助于你自己编写更好的代码。我们将关注每个模式背后的高层次思想，然后是如何在Swift中实现它们。然后我们将超越经典的设计模式，看看Swift的一些高级特性，这些特性允许我们编写特别干净的代码。
- en: 'To do all that, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一切，我们将在本章中涵盖以下主题：
- en: What is a design pattern?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: The behavioral patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为型模式
- en: The structural patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构型模式
- en: The creational patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型模式
- en: Using associated values effectively
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用关联值
- en: Extending system types to reduce code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统类型扩展以减少代码
- en: The lazy properties
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载属性
- en: What is a design pattern?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: Let's delve a little deeper into what a design pattern is before we dive into
    the specific patterns. As you may have begun to understand, there are unlimited
    ways to write a program that does even a simple thing. A design pattern is a solution
    to solve a recurrent and common problem. These problems are often so ubiquitous,
    that even if you don't use a pattern deliberately, you will almost certainly be
    using one or more patterns inadvertently; especially, if you are using third-party
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究具体模式之前，让我们先深入了解一下什么是设计模式。正如你可能已经理解的，编写一个甚至只做简单事情的程序有无数种方式。设计模式是为了解决反复出现和常见问题的一种解决方案。这些问题通常是如此普遍，以至于即使你没有故意使用模式，你也几乎肯定在不经意间使用了其中的一种或多种模式；尤其是如果你在使用第三方代码。
- en: 'To better evaluate the use of design patterns, we will look at three high-level
    measurements: **coupling**, **cohesion**, and **complexity**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地评估设计模式的使用，我们将查看三个高级度量：**耦合度**、**内聚度**和**复杂性**。
- en: Coupling is the degree to which individual code components depend on other components.
    We want to reduce the coupling in our code so that all our code components operate
    as independently as possible. We want to be able to look at them and understand
    each component on its own without needing a full understanding of the entire system.
    Low coupling also allows us to make changes to one component without drastically
    affecting the rest of the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合度是指单个代码组件对其他组件的依赖程度。我们希望减少代码中的耦合度，以便所有代码组件尽可能独立地运行。我们希望能够单独查看它们，并理解每个组件，而无需对整个系统有全面的理解。低耦合还允许我们在不影响其他代码的情况下对单个组件进行更改。
- en: Cohesion is a reference to how well different code components fit together.
    We want code components that can operate independently, but they should still
    fit together with other components in a cohesive and understandable way. This
    means that to have low coupling and high cohesion, we want code components that
    are designed to have a single purpose and a small interface to the rest of our
    code. This applies to every level of our code, from how the different sections
    of our app fit together, down to how functions interact with each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合性是指不同代码组件之间如何很好地结合在一起。我们希望代码组件能够独立操作，但它们仍然应以一种连贯且易于理解的方式与其他组件结合。这意味着为了实现低耦合和高聚合，我们希望代码组件被设计成只有一个目的，并且与其他代码的接口很小。这适用于我们代码的每个层面，从我们的应用程序的不同部分如何结合，到函数之间如何相互交互。
- en: 'Both of these measurements have a high impact on our final measurement: complexity.
    Complexity is basically just how difficult it is to understand the code, especially
    when it comes to practical things like adding new features or fixing bugs. By
    having low coupling and high cohesion, we will generally be writing much less
    complex code. However, taken to their extremes, these principles can sometimes
    actually cause greater complexity. Sometimes the simplest solution is the quickest
    and most effective one because we don''t want to get bogged down into architecting
    the perfect solution when we can implement a near perfect solution ten times faster.
    Most of us cannot afford to code on an unlimited budget.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种度量都对我们的最终度量：复杂度，有很高的影响。复杂度基本上就是理解代码的难度，尤其是在添加新功能或修复错误等实际事情上。通过实现低耦合和高聚合，我们通常会编写更少的复杂代码。然而，如果将这些原则推向极端，有时实际上会导致更大的复杂度。有时最简单的解决方案是最快和最有效的，因为我们不希望在我们能够十倍更快地实现近乎完美的解决方案时，陷入设计完美解决方案的困境。我们大多数人都不可能在不限预算的情况下编码。
- en: 'Instead of having a single giant list, design patterns are usually organized
    according to how they are used into three main categories: **behavioral**, **structural**,
    and **creational**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与拥有一个单一的巨大列表不同，设计模式通常根据它们的使用方式组织成三个主要类别：**行为**、**结构**和**创建**。
- en: Behavioral patterns
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns are patterns that describe how objects will communicate
    with each other. In other words, it is how one object will send information to
    another object, even if that information is just that some event has occurred.
    They help to lower the code's coupling by providing a more detached communication
    mechanism that allows one object to send information to another, while having
    as little knowledge about the other object as possible. The less any type knows
    about the rest of the types in the code base, the less it will depend on those
    types. These behavior patterns also help to increase cohesion by providing straightforward
    and understandable ways to send the information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式是描述对象之间如何相互通信的模式。换句话说，这是如何一个对象将信息发送给另一个对象，即使信息只是某个事件已经发生。它们通过提供一种更分离的通信机制来帮助降低代码的耦合度，允许一个对象向另一个对象发送信息，同时尽可能少地了解另一个对象。任何类型对代码库中其他类型的了解越少，它对这些类型的依赖就越少。这些行为模式还通过提供简单易懂的方式来发送信息，从而帮助提高聚合性。
- en: This can often be the difference between doing something, such as calling your
    sister to ask your mom to ask your grandpa what he wants for his birthday and
    being able to ask your grandpa directly because you have a good communication
    channel open with him. In general, we will want to have the direct channel of
    communication open but sometimes it is actually better design to interact with
    fewer people, as long as we don't put too much burden on the other components.
    Behavioral patterns can help us with this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这往往是在做某事，比如打电话给你的姐姐让她去问你的妈妈再问你的爷爷他生日想要什么，和能够直接问你爷爷因为他与你有一个良好的沟通渠道之间的区别。一般来说，我们希望保持直接的沟通渠道畅通，但有时与较少的人互动实际上是一种更好的设计，只要我们不过度依赖其他组件。行为模式可以帮助我们做到这一点。
- en: Iterator
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: The first behavioral pattern we will discuss is called the **iterator pattern**.
    We are starting with this one because we have actually already made use of this
    pattern in [Chapter 6](ch06.html "Chapter 6. Make Swift Work For You – Protocols
    and Generics"), *Make Swift Work For You – Protocols and Generics*. The idea of
    the iterator pattern is to provide a way to step through the contents of a container
    independent of the way the elements are represented inside the container.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个行为模式被称为**迭代器模式**。我们之所以从这一模式开始，是因为我们实际上已经在[第6章](ch06.html "第6章。让Swift为你工作
    – 协议和泛型") *让Swift为你工作 – 协议和泛型*中使用了这种模式。迭代器模式的思想是提供一种方法，可以独立于容器内部元素表示方式来遍历容器的内容。
- en: As we saw, Swift provides us with the basics of this pattern with the `GeneratorType`
    and `SequenceType` protocols. It even implements those protocols for its array
    and dictionary containers. Even though we don't know how the elements are stored
    within an array or dictionary, we are still able to step through each value contained
    within them. Apple can easily change the way the elements are stored within them
    and it would not affect how we loop through the containers at all. This shows
    a great decoupling between our code and the container implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Swift通过`GeneratorType`和`SequenceType`协议为我们提供了这种模式的基础。它甚至为它的数组和字典容器实现了这些协议。即使我们不知道数组或字典内部元素是如何存储的，我们仍然能够遍历它们包含的每个值。苹果可以轻松地更改它们内部元素的存储方式，而这根本不会影响我们遍历容器的方式。这显示了我们的代码与容器实现之间的高度解耦。
- en: 'If you remember, we were even able to create a generator for the infinite Fibonacci
    sequence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们甚至能够为无限斐波那契序列创建一个生成器：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The "container" doesn't even store any elements but we can still iterate through
    them as if it did.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"容器"甚至不存储任何元素，但我们仍然可以像它存储了元素一样遍历它们。'
- en: The iterator pattern is a great introduction to how we make real world use of
    design patterns. Stepping through a list is such a common problem that Apple built
    the pattern directly into Swift.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式是了解我们如何在现实世界中使用设计模式的一个很好的介绍。遍历列表是一个如此常见的问题，以至于苹果直接将其构建到Swift中。
- en: Observer
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者
- en: The other behavioral pattern that we will discuss is called the **observer pattern**.
    The basic idea of this pattern is that you have one object that is designed to
    allow other objects to be notified when something occurs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的另一种行为模式被称为**观察者模式**。这种模式的基本思想是，有一个对象被设计成允许其他对象在发生某些事件时被通知。
- en: Callback
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: 'In Swift, the easiest way to achieve this is to provide a closure property
    on the object that you want to be observable and have that object call the closure
    whenever it wants to notify its observer. The property will be optional, so that
    any other object can set their closure on this property:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，实现这一点最简单的方法是在你想要被观察的对象上提供一个闭包属性，并在该对象想要通知其观察者时调用该闭包。该属性将是可选的，这样任何其他对象都可以设置它们的闭包到这个属性上：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we have a class that represents an ATM that allows for withdrawing cash.
    It provides a closure property called `onCashWithdrawn` that is called every time
    cash is withdrawn. This type of closure property is usually called a **callback**.
    It is a good idea to make its purpose clear by its name. I personally choose to
    name all event-based callbacks by starting them with the word "on."
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个代表允许取款的ATM的类。它提供了一个每次取款时都会被调用的闭包属性`onCashWithdrawn`。这种类型的闭包属性通常被称为**回调**。通过其名称清楚地表明其目的是一个好主意。我个人选择以“on”这个词作为所有基于事件回调的命名前缀。
- en: 'Now, any object can define its own closure on the callback and be notified
    whenever cash is withdrawn:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何对象都可以定义自己的闭包在回调上，并在取款时被通知：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `ATM` is considered the observable object and the `RecordKeeper`
    is the observer. The `ATM` type is completely disconnected from whatever process
    might be keeping a record of its transactions. The record keeping mechanism can
    be changed without making any changes to the `ATM` and the `ATM` can be changed
    without any change to the `RecordKeeper` as long as the new `ATM` implementation
    still calls `onCashWithDrawn` whenever cash is withdrawn.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ATM`被视为可观察对象，而`RecordKeeper`是观察者。`ATM`类型与可能记录其交易过程的任何过程完全断开连接。记录机制可以改变，而无需对`ATM`进行任何更改。只要新的`ATM`实现仍然在取款时调用`onCashWithDrawn`，`ATM`就可以更改，而无需对`RecordKeeper`进行任何更改。
- en: However, the `RecordKeeper` needs to be passed an `ATM` instance for this connection
    to be made. There can also only ever be one observer at a time. If we need to
    allow multiple observers, we can potentially provide an array of callbacks, but
    that can make removing observers more difficult. A solution that solves both of
    those problems is to implement the observer pattern using a notification center
    instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`RecordKeeper` 需要传递一个 `ATM` 实例以建立此连接。同时，一次也只有一个观察者。如果我们需要允许多个观察者，我们可以提供回调函数数组，但这可能会使移除观察者变得更加困难。解决这两个问题的方案是使用通知中心来实现观察者模式。
- en: Notification center
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知中心
- en: 'A notification center is a central object that manages events for other types.
    We can implement a notification center for ATM withdrawals:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通知中心是一个管理其他类型事件的中心对象。我们可以为 ATM 提款实现一个通知中心：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this implementation, any object can start observing by passing a unique
    key and callback to the `addObserverForKey:callback:` method. It doesn't have
    to have any reference to an instance of an `ATM`. An observer can also be removed
    by passing the same unique key to `removeObserverForKey:`. At any point, any object
    can trigger the notification by calling the `trigger:` method and all the registered
    observers will be notified.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，任何对象都可以通过传递一个唯一的键和回调给 `addObserverForKey:callback:` 方法来开始观察。它不需要对 `ATM`
    实例有任何引用。观察者也可以通过传递相同的唯一键给 `removeObserverForKey:` 来被移除。在任何时候，任何对象都可以通过调用 `trigger:`
    方法来触发通知，所有注册的观察者都将被通知。
- en: If you really want to challenge yourself with advanced protocols and generics,
    you can try to implement a completely generic notification center that can store
    and trigger multiple events at once. The ideal notification center in Swift would
    allow any object to trigger an arbitrary event and any object to observe that
    arbitrary event, as long as it knows about it. The notification center should
    not have to know anything about any specific events. It should also allow an event
    to contain any type of data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想通过高级协议和泛型来挑战自己，你可以尝试实现一个完全通用的通知中心，它可以同时存储和触发多个事件。在 Swift 中，理想的通知中心应该允许任何对象触发任意事件，以及任何对象观察任意事件，只要它们知道这些事件。通知中心不需要了解任何特定事件。它还应允许事件包含任何类型的数据。
- en: Structural patterns
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型模式
- en: '**Structural patterns** are patterns that describe how objects should relate
    to each other so that they can work together to achieve a common goal. They help
    us lower our coupling by suggesting an easy and clear way to break down a problem
    into related parts and they help raise our cohesion by giving us a predefined
    way that those components will fit together.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构型模式**是描述对象之间如何相互关联以共同实现一个共同目标的模式。它们通过建议一种简单明了的方式来将问题分解为相关部分，帮助我们降低耦合度，并通过为我们提供一种预定义的方式，让这些组件能够相互配合，从而帮助我们提高内聚度。'
- en: This is like a sports team defining specific roles for each person on the field
    so that they can play together better as a whole.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一个运动队为场上的每个人定义特定的角色，以便他们能够作为一个整体更好地一起比赛。
- en: Composite
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: The first structural pattern we are going to look at is called the **composite
    pattern**. The concept of this pattern is that you have a single object that can
    be broken down into a collection of objects just like itself. This is like the
    organization of many large companies. They will have teams that are made up of
    smaller teams, which are then made up of even smaller teams. Each sub-team is
    responsible for a small part and they come together to be responsible for a larger
    part of the company.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的第一个结构型模式被称为**组合模式**。这种模式的概念是，你可以有一个单一的对象，它可以被分解成一组与自身类似的对象。这就像许多大型公司的组织结构。它们将拥有由更小的团队组成的团队，这些小团队再由更小的团队组成。每个子团队负责一小部分工作，然后他们一起负责公司更大的部分。
- en: Hierarchies
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次结构
- en: A computer ultimately represents what is on the screen with a grid of pixel
    data. However, it does not make sense for every program to be concerned with each
    individual pixel. Instead, most programmers use frameworks, often provided by
    the operating system, to manipulate what is on the screen at a much higher level.
    A graphical program is usually given one or more windows to draw within and instead
    of drawing pixels within a window; a program will usually set up a series of "views".
    A view will have lots of different properties but they will most importantly have
    a position, size, and background color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机最终用像素数据网格来表示屏幕上的内容。然而，并不是每个程序都需要关心每个单独的像素。相反，大多数程序员使用操作系统提供的框架，在更高的层面上操作屏幕上的内容。一个图形程序通常被赋予一个或多个窗口来绘制，而不是在窗口内绘制像素；程序通常会设置一系列“视图”。一个视图将具有许多不同的属性，但最重要的是它有一个位置、大小和背景颜色。
- en: We can potentially build up an entire window with just a big list of views but
    programmers have devised a way of using the composite pattern to make the whole
    process much more intuitive. A view can actually contain other views, which are
    generally referred to as subviews. In this sense, you can look at any view like
    a tree of subviews. If you look at the very root of the tree, you will see a complete
    image of what will be displayed on the window. However, you can look at any of
    the tree branches or leaves and see a smaller part of that view. This is the same
    as looking at a large team as a whole versus looking at a small team within that
    larger team. In all of this, there is no difference between a view at the root
    of the tree and a view at the leaf of the tree, except the root has more sub-views.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个大的视图列表构建整个窗口，但程序员已经设计了一种使用组合模式来使整个过程更加直观的方法。一个视图实际上可以包含其他视图，这些视图通常被称为子视图。从这个意义上说，你可以将任何视图视为子视图的树。如果你查看树的根，你会看到一个将在窗口上显示的完整图像。然而，你可以查看树中的任何分支或叶子，并看到该视图的较小部分。这与将一个大团队作为一个整体看待与在更大团队中看待一个小团队是一样的。在这整个过程中，树根的视图和树叶的视图之间没有区别，除了根有更多的子视图。
- en: 'Let''s look at our own implementation of a `View` class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们自己的`View`类的实现：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a pretty simple class, but by adding the `subviews` property, which
    is an array of additional views, we are using the composite pattern to make this
    a very powerful class. You can imagine a virtually infinite hierarchy of views
    that are all contained within a single parent view. That single view could be
    passed to some other class that could draw the entire hierarchy of views.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的类，但通过添加`subviews`属性，它是一个额外的视图数组，我们使用组合模式使这个类变得非常强大。你可以想象一个几乎无限的视图层次结构，所有这些视图都包含在一个单一父视图内。这个单一视图可以被传递给其他类，以绘制整个视图层次结构。
- en: 'As an example, let''s set up a view that has red in the left-half, green in
    the upper-right half, and blue in the lower-right half:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们设置一个视图，其中左侧为红色，右上角为绿色，右下角为蓝色：
- en: '![Hierarchies](img/B05103_09_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![层次结构](img/B05103_09_01.jpg)'
- en: 'To produce this with our class, we could write a code similar to:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的类生成此内容，我们可以编写类似的代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this implementation, we actually have a red left half as defined by `leftView`
    and a blue right half as defined by `rightView`. The reason the upper-right half
    is green instead of blue is that we added `upperRightView` as a subview to `rightView`
    and only made it half the height. This means that our view hierarchy looks similar
    to the following image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们实际上有一个由`leftView`定义的红色左侧和一个由`rightView`定义的蓝色右侧。右上角是绿色而不是蓝色，是因为我们将`upperRightView`作为子视图添加到`rightView`中，并且只使其高度为二分之一。这意味着我们的视图层次结构看起来类似于以下图像：
- en: '![Hierarchies](img/B05103_09_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![层次结构](img/B05103_09_02.jpg)'
- en: It is important to note that the position of `upperRightView` is left at *0,
    0*. That is because the positioning of all sub-views will always be relative to
    their immediate parent view. This allows us to pull any view out of the hierarchy
    without affecting any of its sub-views; drawing `rightView` within `rootView`
    will look exactly the same as if it were drawn on its own.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`upperRightView`的位置被保留为*0, 0*。这是因为所有子视图的位置总是相对于它们最近的父视图。这使得我们可以在不影响任何子视图的情况下从层次结构中提取任何视图；在`rootView`内绘制`rightView`将看起来与它单独绘制时完全一样。
- en: You could also set up separate objects to manage the contents of different subsections
    of the main view. For example, to create a program like Xcode, we might have one
    object that manages the contents of the file list on the left and a different
    object that manages the display of the selected file. Clearly, Xcode is much more
    complex than that, but it gives us an idea of how we can build incredibly powerful
    and complex software with relatively simple concepts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置单独的对象来管理主视图的不同部分的 内容。例如，要创建一个像Xcode这样的程序，我们可能有一个对象管理左侧的文件列表内容，另一个对象管理所选文件的显示。显然，Xcode比这要复杂得多，但它给了我们一个想法，即我们可以如何使用相对简单的概念构建极其强大和复杂的软件。
- en: You may, however, have noticed a potential problem with our view class. What
    would happen if we added a view to its own subview hierarchy somewhere. That is
    most likely going to cause an infinite loop when another part of our code goes
    to draw the view. As another challenge to you, try to update our `View` class
    to prevent this from happening. I suggest you start by making `subviews` private
    and providing methods for adding and removing subviews. You will probably also
    want to add an optional `superview` property that will reference the parent view.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到了我们视图类的一个潜在问题。如果我们将其自己的子视图层次结构添加到某个地方，会发生什么？这很可能会在代码的另一个部分试图绘制视图时导致无限循环。作为对你的一项挑战，尝试更新我们的`View`类以防止这种情况发生。我建议你首先将`subviews`设为私有，并提供添加和删除子视图的方法。你可能还希望添加一个可选的`superview`属性，它将引用父视图。
- en: Alternative to subclassing
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对于子类化
- en: As you can see, the composite pattern is ideal for any situation where an object
    can be broken down into pieces that are just like it. This is great for something
    seemingly infinite like a hierarchy of views, but it is also a great alternative
    to subclassing. Subclassing is actually the tightest form of coupling. A subclass
    is extremely dependent on its superclass. Any change to a superclass is almost
    certainly going to affect all of its subclasses. We can often use the composite
    pattern as a less coupled alternative to subclassing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，组合模式非常适合任何可以将对象分解成与其完全相同的片段的情况。这对于看似无限的视图层次结构非常理想，但它也是子类化的一个很好的替代方案。子类化实际上是耦合最紧密的形式。子类极其依赖于其超类。对超类的任何更改几乎肯定会影响所有子类。我们经常可以使用组合模式作为子类化的一个松散耦合的替代方案。
- en: As an example, let's explore the concept of representing a sentence. One way
    to look at the problem is to consider the sentence a special kind of string. Any
    kind of specialization like this will usually lead us to create a subclass; after
    all, a subclass is a specialization of its superclass. So we could create a `Sentence`
    subclass of `String`. This will be great because we can build strings using our
    sentence class and then pass them to methods that are expecting a normal string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们探讨表示一个句子的概念。看待这个问题的一种方式是将句子视为一种特殊的字符串。任何这样的专门化通常都会引导我们创建一个子类；毕竟，子类是其超类的一种专门化。因此，我们可以创建一个`Sentence`子类，它是`String`的子类。这将非常棒，因为我们可以使用我们的句子类构建字符串，然后将它们传递给期望接收普通字符串的方法。
- en: 'However, there is an important obstacle to this method: we don''t have control
    of the `String` code and even worse we can''t even look at the code so we don''t
    even know how the characters are stored. This means that the code can be changed
    underneath us with an update from Apple without our knowledge. Even with our knowledge,
    this could cause a maintenance headache.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个方法存在一个重要的障碍：我们没有控制`String`代码，甚至更糟糕的是，我们甚至无法查看代码，所以我们甚至不知道字符是如何存储的。这意味着代码可以在我们不知情的情况下被苹果的更新所更改。即使我们有知识，这也可能引起维护上的麻烦。
- en: 'A better solution would be to use the composite pattern and implement a `Sentence`
    type that contains strings:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用组合模式并实现一个包含字符串的`Sentence`类型：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we were able to give more meaningful names to the parts of the sentence
    with various words and we set up a `Type` enumeration that allows us to use different
    end punctuations. As a convenience, we can even add a `string` calculated property
    so that we can use the sentence as a normal string:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够用各种词汇给句子的各个部分赋予更有意义的名称，并设置了一个`Type`枚举，允许我们使用不同的结束标点符号。作为一个便利性，我们甚至可以添加一个计算属性`string`，这样我们就可以将句子用作普通字符串：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a much better alternative to subclassing in this scenario.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是一个比子类化更好的替代方案。
- en: Delegate
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托
- en: One of the most commonly used design patterns in Apple's frameworks is called
    the **delegate pattern**. The idea behind it is that you set up an object to let
    another object handle some of its responsibilities. In other words, one object
    will delegate some of its responsibilities to another object. This is like a manager
    hiring employees to do a job that the manager cannot or does not want to do themselves.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果框架中最常用的设计模式之一被称为**委托模式**。其背后的理念是设置一个对象，以便让另一个对象处理其部分责任。换句话说，一个对象将部分责任委托给另一个对象。这就像经理雇佣员工来完成经理自己无法或不想亲自完成的工作。
- en: As a more technical example, on iOS, Apple provides a user interface class called
    `UITableView`. As the name suggest, this class provides us with an easy way to
    draw a list of elements. On its own, a `UITableView` isn't enough to make an interface.
    It needs data to display and it needs to be able to handle all kinds of user interactions,
    such as tapping, reordering, deleting, and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更技术性的例子，在iOS中，苹果提供了一个名为`UITableView`的用户界面类。正如其名所示，这个类为我们提供了一个绘制元素列表的简单方法。单独的`UITableView`不足以创建界面。它需要数据来显示，并且需要能够处理各种用户交互，如点击、重新排序、删除等。
- en: One instinct is to create your own subclass of `UITableView`, maybe something
    like `PeopleTableView`. This is an OK option until you remember how we discussed
    that subclassing is actually the strongest type of coupling between two objects.
    In order to properly subclass a `UITableView`, you would have to be pretty intimately
    aware of how the superclass works. This is especially difficult when you are not
    even allowed to see the code of the superclass.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一种本能的想法是创建自己的`UITableView`子类，比如`PeopleTableView`。这是一个不错的选择，直到你记得我们讨论过子类化实际上是两个对象之间最强的耦合类型。为了正确地子类化`UITableView`，你必须非常熟悉超类的工作方式。这在你甚至不允许查看超类代码的情况下尤其困难。
- en: Another option is to set data on the table view and use the observer pattern
    to handle user interactions. This is better than the subclassing option, but most
    data you will want to display is not static and therefore it would be cumbersome
    to make updates to the table view. It will also still be hard to implement an
    object that can be reused easily for other ways of displaying a list of information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在表格视图中设置数据，并使用观察者模式来处理用户交互。这比子类化选项更好，但大多数你想要显示的数据都不是静态的，因此更新表格视图会变得繁琐。同时，实现一个可以轻松用于其他显示信息列表方式的对象也会很困难。
- en: 'So instead, what Apple did is, they created two different properties on `UITableView`:
    `delegate` and `dataSource`. These properties are there so that we can assign
    our own objects to handle various responsibilities for the table. The data source
    is primarily responsible for providing the information to be shown in the table
    and the delegate''s responsibility is to handle user interaction. Of course, if
    these objects could be of any type, the table view would not really be able to
    interact with them. Also, if these objects were of a specific type, we would still
    run into the same subclassing problem. Instead, they are defined to implement
    the `UITableViewDelegate` and `UITableViewDataSource` protocols respectively.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，苹果的做法是，在`UITableView`上创建了两个不同的属性：`delegate`和`dataSource`。这些属性的存在是为了让我们能够分配自己的对象来处理表格的各种责任。数据源主要负责提供表格中要显示的信息，而委托的责任是处理用户交互。当然，如果这些对象可以是任何类型，表格视图实际上无法与它们交互。另外，如果这些对象是特定类型，我们仍然会遇到相同的子类化问题。因此，它们被定义为分别实现`UITableViewDelegate`和`UITableViewDataSource`协议。
- en: These protocols define only the methods necessary to allow the table view to
    properly function. This means that the `delegate` and `dataSource` properties
    can be any type as long as they implement the necessary methods. For example,
    one of the critical methods the data source must implement is `tableView:numberOfRowsInSection:`.
    This method provides the table view and an integer referring to the section that
    it wants to know about. It requires that an integer be returned for the number
    of rows in the referenced section. This is only one of multiple methods that data
    source must implement, but it gives you an idea of how the table view no longer
    has to figure out what data it contains. It simply asks the data source to figure
    it out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议仅定义了允许表格视图正确运行所需的方法。这意味着`delegate`和`dataSource`属性可以是任何类型，只要它们实现了必要的方法。例如，数据源必须实现的一个关键方法是`tableView:numberOfRowsInSection:`。这个方法为表格视图提供了一个整数，表示它想要了解的分区。它要求返回一个整数，表示引用分区中的行数。这是数据源必须实现的多达多个方法之一，但它让你了解表格视图不再需要确定它包含的数据。它只是要求数据源来解决这个问题。
- en: This provides a very loosely coupled way to implement a specific table view
    and this same pattern is reused all over the programming world. You would be amazed
    at what Apple has been able to do with its table view, with very little to no
    pain inflicted on third party developers. The table view is incredibly optimized
    to handle thousands upon thousands of rows if you really wanted it to. The table
    has also changed a lot since the first developer kit for iOS, but these protocols
    have very rarely been changed except to add additional features.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种非常松散耦合的方式来实现特定的表格视图，并且这种相同的模式在编程世界的各个角落都被重复使用。你会对苹果公司如何使用其表格视图感到惊讶，它对第三方开发者造成的痛苦非常小。如果你真的想要的话，表格视图可以非常优化地处理成千上万行数据。自iOS的第一个开发者工具包以来，表格也发生了很大的变化，但这些协议很少改变，除非是为了添加额外的功能。
- en: Model view controller
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型视图控制器
- en: '**Model view controller** is one of the highest levels and most abstract design
    patterns. Variations of it are pervasive across a huge percentage of software,
    especially Apple''s frameworks. It really can be considered the foundational pattern
    for how all of Apple''s code is designed and therefore how most third party developers
    design their own code. The core concept of model view controller is that you split
    all of your types into three categories, often referred to as layers: **model**,
    **view**, and **controller**.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图控制器**是最高级别和最抽象的设计模式之一。它的变体在大量软件中普遍存在，尤其是在苹果的框架中。它实际上可以被认为是苹果所有代码设计的基石，因此也是大多数第三方开发者设计自己代码的基础。模型视图控制器的核心概念是将所有类型分成三个类别，通常被称为层：**模型**、**视图**和**控制器**。'
- en: The model layer is for all of the types that represent and manipulate data.
    This layer is the real foundation of what your software can do for its user, so
    it is also often referred to as the business logic. For example, the model layer
    from an address book app would have types representing contacts, groups, and so
    on. It would also contain logic to create, delete, modify, and store those types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层是为所有表示和操作数据的类型设计的。这一层是软件能够为用户提供的真正基础，因此它也常被称为业务逻辑。例如，地址簿应用中的模型层将包含代表联系人、群组等的类型。它还将包含创建、删除、修改和存储这些类型的逻辑。
- en: The view layer is for all types involved in the display and interaction of your
    software. It consists of types like tables, text view, and buttons. Essentially,
    this layer is responsible for displaying information to the user and providing
    the affordances for how a user can interact with your application. The view in
    an address book app would consist of the displayed list of contacts, groups, and
    contact information.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 视图层是所有参与软件显示和交互的类型。它包括表格、文本视图和按钮等类型。本质上，这一层负责向用户显示信息，并提供用户如何与您的应用程序交互的便利性。地址簿应用中的视图将包括显示的联系人、群组和联系人信息列表。
- en: The final layer, controller, is mostly just the glue code between the model
    and view layers. It will instruct the view of what to display based on the data
    in the model layer and it will trigger the right business logic depending on the
    interactions coming from the view layer. In our address book example, the controller
    layer would connect something such as a contact add button in the view, to the
    logic defined in the model for creating a new contact. It will also connect things
    like the on screen table view to the list of contacts in the model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层，控制器层，主要是模型层和视图层之间的粘合代码。它将根据模型层中的数据指示视图显示什么内容，并根据视图层传来的交互触发正确的业务逻辑。在我们的通讯录示例中，控制器层会将视图中的某个元素，比如添加联系人的按钮，连接到模型中定义的创建新联系人的逻辑。它还会将屏幕上的表格视图连接到模型中的联系人列表。
- en: 'In the ideal implementation of model view controller, no model type should
    ever have any knowledge of the existence of a view type and no view type should
    know about a model type. Often, a model view controller is visualized sort of
    like a cake:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型视图控制器理想的实现中，没有任何模型类型应该知道视图类型的存在，也没有任何视图类型应该知道模型类型的存在。通常，模型视图控制器被形象地比作一块蛋糕：
- en: '![Model view controller](img/B05103_09_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图控制器](img/B05103_09_03.jpg)'
- en: The user sees and interacts with the top of the cake and each layer only communicates
    with its adjacent layers. This means that all communication between the view and
    the model layers should go through the controller layer. At the same time, the
    controller layer should be pretty lightweight, because the model layer is doing
    the heavy lifting on the logic side of the application and the view layer is doing
    the heavy lifting on drawing to the screen and accepting user input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户看到并与之交互的是蛋糕的顶部，每一层只与其相邻的层进行通信。这意味着视图层和模型层之间的所有通信都应该通过控制器层进行。同时，控制器层应该相对轻量级，因为模型层在应用逻辑方面承担着繁重的任务，而视图层在屏幕绘制和接受用户输入方面承担着繁重的任务。
- en: 'One of the main benefits of this design pattern is that it provides a logical
    and consistent way to break down many pieces of software. This greatly increases
    your ability to share your code with other developers and understand their code.
    It gives everyone a frame of reference for when they try to understand another
    large code base that they haven''t seen before. The naming of classes also gives
    strong clues to developers about what role a type will play in the overall system.
    Virtually every view class in iOS has the word "view" in it: `UITableView`, `UIView`,
    `UICollectionViewCell`, etc. Also, most of the controller layer classes that Apple
    provides have the word controller in them: `UIViewController`, `UITableViewController`,
    `MFMailComposeViewController`, etc. The model layer is mostly left to third party
    developers, other than the basic data types, since Apple isn''t going to be able
    to help much with the business logic of your software. However, even among third
    party developers, these classes are often nouns named after the data they are
    representing or manipulating: Person, AddressBook, Publisher, and so on.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的主要好处之一是它提供了一种逻辑上和一致的方式来分解许多软件组件。这极大地提高了你与其它开发者共享代码和理解他们代码的能力。当尝试理解一个之前未曾见过的庞大代码库时，它为每个人提供了一个参考框架。类的命名也给了开发者关于类型在整体系统中扮演什么角色的强烈提示。iOS中几乎每个视图类都包含“view”这个词：`UITableView`、`UIView`、`UICollectionViewCell`等。同样，苹果提供的控制器层类大多数都包含“controller”这个词：`UIViewController`、`UITableViewController`、`MFMailComposeViewController`等。模型层主要留给第三方开发者，除了基本的数据类型，因为苹果不太可能在你软件的业务逻辑方面提供太多帮助。然而，即使在第三方开发者中，这些类通常都是以它们所表示或操作的数据命名的名词：Person、AddressBook、Publisher等等。
- en: Another huge benefit of model view controller is that most components will be
    very reusable. You should be able to easily reuse views with different types of
    data like you can use a table view to display virtually any kind of data without
    changing the table view type and you should be able to display something like
    an address book in lots of different ways without changing the address book type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模型视图控制器的另一个巨大好处是大多数组件将非常易于重用。你应该能够轻松地重用视图，就像你可以使用表格视图来显示几乎任何类型的数据，而不需要改变表格视图类型一样；你也应该能够以许多不同的方式显示类似通讯录这样的内容，而不需要改变通讯录类型。
- en: As useful as this pattern is, it is also extremely hard to stick to. You will
    probably spend your entire development career evolving your sense for how to effectively
    breakdown your problems into these layers. It is often helpful to create explicit
    folders for each layer, forcing yourself to put every type into only one of the
    categories. You will also probably find yourself creating a bloated controller
    layer, especially in iOS, because it is often convenient to stick business logic
    there. More than any other design pattern, model view controller is probably the
    one that can be most described as something you strive for but rarely ever perfectly
    achieve.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个模式很有用，但它也非常难以坚持。你可能会在整个开发生涯中不断进化你对如何有效地将问题分解为这些层级的感知。通常，为每一层创建显式的文件夹会有所帮助，迫使你将每种类型放入仅一个类别中。你也可能会发现自己创建了一个臃肿的控制器层，尤其是在iOS中，因为将业务逻辑放在那里通常很方便。比其他任何设计模式，模型视图控制器可能是最需要努力追求但很少能完美实现的东西。
- en: Creational patterns
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: The final type of design patterns we will discuss is called **creational patterns**.
    These patterns relate to the initialization of new objects. At first, the initialization
    of an object probably seems simple and not a very important place to have design
    patterns. After all, we already have initializers. However, in certain circumstances,
    creational patterns can be extremely helpful.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一种设计模式称为**创建型模式**。这些模式与新对象的初始化有关。起初，对象的初始化可能看起来很简单，并不是一个特别重要的地方来应用设计模式。毕竟，我们已经有初始化器了。然而，在特定情况下，创建型模式可以非常有帮助。
- en: Singleton/shared instance
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例/共享实例
- en: The first patterns we will discuss are the **singleton** and **shared instance**
    patterns. We are discussing them together because they are extremely similar.
    First we will discuss shared instance, because it is the less strict form of the
    singleton pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一种设计模式是**单例模式**和**共享实例模式**。我们将它们一起讨论，因为它们非常相似。首先，我们将讨论共享实例，因为它是单例模式的较不严格形式。
- en: 'The idea of the shared instance pattern is that you provide an instance of
    your class to be used by other parts of your code. Let''s look at a quick example
    of this in Swift:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 共享实例模式的想法是提供你类的一个实例供代码的其他部分使用。让我们通过Swift中的一个快速示例来看看这一点：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have a simple address book class but we are providing a static constant
    called `sharedInstance` that any other code can use without having to create its
    own instance. This is a very convenient way to allow otherwise separate code to
    collaborate. Instead of having to pass around a reference to the same instance
    all over your code, any code can refer the shared instance right through the class
    itself:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的地址簿类，但我们提供了一个静态常量`sharedInstance`，任何其他代码都可以使用它，而无需创建自己的实例。这是一种非常方便的方式，允许原本分离的代码进行协作。你不需要在代码中传递相同实例的引用，任何代码都可以通过类本身直接引用共享实例：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the different thing about the singleton pattern is that you would write
    your code in such a way that it is not even possible to create a second instance
    of your class. Even though our preceding address book class provides a shared
    instance, there is nothing to stop someone from creating their own instance using
    the normal initializers. We could pretty easily change our address book class
    to a singleton instead of a shared instance, as shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单例模式的不同之处在于，你会以这种方式编写代码，以至于甚至不可能创建你类的一个第二个实例。尽管我们之前的地址簿类提供了一个共享实例，但没有任何东西可以阻止某人使用正常的初始化器创建自己的实例。我们可以相当容易地将我们的地址簿类改为单例而不是共享实例，如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Besides changing the name of the static constant, the only difference with this
    code is that we declared the initializers as private. This makes it so that no
    code outside of this file can use the initializer and therefore, no code outside
    of this file can create a new instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改静态常量的名称外，与这段代码的唯一区别在于我们将初始化器声明为私有。这使得文件外的代码无法使用初始化器，因此，文件外的代码也无法创建新的实例。
- en: 'The singleton pattern is great for when multiple instances of the same class
    are going to cause a problem. This is especially important for classes that represent
    a finite physical resource but it can also be a way to simplify a class that would
    be more difficult and unnecessary to implement in a way that would allow multiple
    instances. For example, there isn''t actually much of a reason to ensure there
    is only ever one address book in an application. Perhaps the user will want to
    have two address books: one for business and one for personal. They should be
    able to operate independently as long as they are working from a different file,
    but maybe in your application you know that there will only ever be a single address
    book and it always has to be driven by a single file. Instead of requiring your
    code to create an address book with a specific file path, and instead of dealing
    with the danger of having multiple instances reading and writing to the same file,
    you can use the singleton version above and have the file path be fixed.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式在多个实例的同一类将导致问题时非常出色。这对于代表有限物理资源的类尤为重要，但它也可以是一种简化类的途径，这样就可以以更困难和不必要的方式实现多个实例。例如，实际上并没有太多理由确保应用程序中始终只有一个地址簿。也许用户会想要有两个地址簿：一个用于商业，一个用于个人。只要它们从不同的文件中工作，它们应该能够独立操作。但在你的应用程序中，你可能知道将始终只有一个地址簿，并且它总是由一个文件驱动。与其要求你的代码使用特定的文件路径创建地址簿，并且处理多个实例读取和写入同一文件的风险，你还可以使用上面的单例版本，并将文件路径固定。
- en: In fact, the singleton and shared instance patterns are so convenient that many
    developers over use them. So let's discuss some of the drawbacks of these patterns.
    It is nice to be able to access an instance from anywhere, but when it is easy
    to do so, it is also easy to create a very complex web of dependencies on that
    object. That goes against the principle of low coupling that we are trying to
    achieve. Imagine trying to change a singleton class when you have 20 different
    pieces of code all using it directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，单例模式和共享实例模式非常方便，以至于许多开发者过度使用它们。因此，让我们讨论一下这些模式的缺点。能够从任何地方访问一个实例是很方便的，但当这样做变得容易时，也容易在对象上创建一个非常复杂的依赖网络。这与我们试图实现的低耦合原则相悖。想象一下，当你有20段不同的代码都直接使用它时，试图更改单例类是多么困难。
- en: Using these patterns can also create hidden dependencies. Usually, it is pretty
    clear what dependencies an instance has based on what it must be initialized with,
    but a singleton or shared instance does not get passed into the initializer, so
    it can often go unnoticed as a dependency. Even though there is some initial extra
    overhead to passing an object into an initializer, it will often reduce the coupling
    and maintain a clearer picture of how your types interact. The bottom line is,
    like with any other pattern, think carefully about each use of the singleton and
    shared instance patterns and be sure it is the best tool for the job.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模式也可能创建隐藏的依赖。通常，根据它必须初始化的内容，可以很清楚地了解实例的依赖关系，但单例或共享实例并没有传递给初始化器，因此它通常会被忽视作为依赖。尽管将对象传递给初始化器有一些初始的额外开销，但它通常会减少耦合，并保持对类型之间交互的更清晰的认识。底线是，就像任何其他模式一样，仔细思考每个单例和共享实例模式的使用，并确保它是完成工作的最佳工具。
- en: Abstract factory
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: 'The final pattern we will discuss here is called **abstract factory**. It is
    based on a simpler pattern called **factory**. The idea of a factory pattern is
    that you implement an object for creating other objects, much like you would create
    a factory for assembling cars. The factory pattern is great when the initializing
    of a type is very complex or you want to create a bunch of similar objects. Let''s
    take a look at the second scenario. What if we were creating a two-player ping-pong
    game and we had some scenario in the game where we would add additional balls
    that a specific player needed to keep in play? The ball class might look something
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的最后一个模式被称为**抽象工厂**。它基于一个更简单的模式，即**工厂模式**。工厂模式的想法是，你为创建其他对象实现一个对象，就像你为组装汽车创建一个工厂一样。当初始化一个类型非常复杂或你想创建许多相似的对象时，工厂模式非常出色。让我们看看第二种场景。如果我们正在创建一个双打乒乓球游戏，并且在游戏中有一些场景需要添加特定玩家需要保持比赛进行的多余球，球类可能看起来像这样：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Every time we needed a new ball we could assign a new color and owning player
    to it. Or, we could create a separate ball factory for each player:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们需要一个新的球时，我们都可以为其分配一个新的颜色和拥有者。或者，我们可以为每个玩家创建一个单独的球工厂：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we could pass this factory into whatever object is responsible for handling
    the ball creation event and that object is no longer responsible for determining
    the color of the ball or any other properties we might want. This is great for
    reducing the number of responsibilities that object has and also keeps the code
    very flexible to add additional ball properties in the future without having to
    change the ball creation event object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个工厂传递给任何负责处理球创建事件的物体，这样该物体就不再负责确定球的颜色或任何其他我们可能想要的属性。这对于减少该物体所承担的责任数量非常有用，同时也使得代码在未来添加额外的球属性时非常灵活，而无需更改球创建事件对象。
- en: An abstract factory is a special form of factory where the instances the factory
    creates may be one of many subclasses of a single other class. A great example
    of this would be an image creation factory. As we discussed in [Chapter 3](ch03.html
    "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"), *One Piece at
    a Time – Types, Scopes, and Projects*, computers have an enormous number of ways
    to represent images. In that chapter we hypothesized having a superclass called
    just "Image" that would have a subclass for each type of image. This would help
    us write classes to handle any type of image very easily by always having them
    work with the image superclass. Similarly, we could create an image factory that
    would virtually eliminate any need for an external type to know anything about
    the different types of images. We could design an abstract factory that takes
    the path to any image, loads the image into the appropriate subclass, and returns
    it simply as the image superclass. Now, neither the code that loads an image,
    nor the code that uses the image, needs to know what type of image they are dealing
    with. All of the complexity of different image representations is abstracted away
    inside the factory and the image class hierarchy. This is a huge win for making
    our code easier to understand and more maintainable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂是一种特殊的工厂形式，其中工厂创建的实例可能是单个其他类的一个或多个子类的实例。一个很好的例子是图像创建工厂。正如我们在[第3章](ch03.html
    "第3章。一次一件——类型、作用域和项目")中讨论的，“一次一件——类型、作用域和项目”，计算机有无数种方式来表示图像。在第3章中，我们假设有一个名为“Image”的超类，它将为每种图像类型有一个子类。这将帮助我们很容易地编写处理任何类型图像的类，因为它们总是与图像超类一起工作。同样，我们可以创建一个图像工厂，这将几乎消除外部类型了解不同类型图像的任何需要。我们可以设计一个抽象工厂，它接受任何图像的路径，将其加载到适当的子类中，并简单地将其作为图像超类返回。现在，加载图像的代码和使用图像的代码都不需要知道它们正在处理什么类型的图像。不同图像表示的复杂性都被抽象到工厂和图像类层次结构中。这对于使我们的代码更容易理解且更易于维护是一个巨大的优势。
- en: Using associated values effectively
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用关联值
- en: Good programming is about more than just grand, universal concepts of how to
    write effective code. The best programmers know how to play to the strengths of
    the tools at hand. We are now going to move from looking at the core tenants of
    programming design to some of the gritty details of enhancing your code with the
    power of Swift.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程不仅仅是关于如何编写有效代码的宏大、普遍概念。最优秀的程序员知道如何发挥手中工具的优势。现在，我们将从观察编程设计的核心原则转向使用Swift的强大功能来增强代码的一些具体细节。
- en: The first thing we will look at is making effective use of the associated value
    of an enumeration. Associated values are a pretty unique feature of Swift, so
    they open up some pretty interesting possibilities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何有效地使用枚举的关联值。关联值是Swift的一个相当独特的特性，因此它们开辟了一些相当有趣的可能性。
- en: Replacing class hierarchies
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换类层次结构
- en: 'We have already seen in [Chapter 3](ch03.html "Chapter 3. One Piece at a Time
    – Types, Scopes, and Projects"), *One Piece at a Time – Types, Scopes, and Projects*
    that we can use an enumeration with associated values to represent a measurement
    like distance in multiple measurement systems:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](ch03.html "第3章。一次一件——类型、作用域和项目")中看到，我们可以使用带有关联值的枚举来表示像距离这样的测量值在多个测量系统中的表示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can generalize this use case as using an enumeration to flatten out a simple
    class hierarchy. Instead of the enumeration, we could have created a height superclass
    or protocol with subclasses for each measurement system. However, this would be
    a more complex solution and we would lose the benefits of using a value type instead
    of a reference type. The enumeration solution is also very compact, making it
    very easy to understand at a glance instead of having to analyze how multiple
    different classes fit together.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个用例概括为使用枚举来简化简单的类层次结构。而不是枚举，我们本可以创建一个高度超类或协议，并为每个测量系统创建子类。然而，这将是一个更复杂的解决方案，我们会失去使用值类型而不是引用类型的好处。枚举解决方案也非常紧凑，使得它一目了然，而不是需要分析多个不同类如何结合在一起。
- en: 'Let''s look at an even more complex example. Let''s say we want to create a
    fitness app and we want to be able to track multiple types of workouts. Sometimes
    people workout to do a certain number of repetitions of various movements; other
    times they are just going for a certain amount of time. We could create a class
    hierarchy for this, but an enumeration with associated values works great:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂的例子。假设我们想要创建一个健身应用，并希望能够跟踪多种类型的锻炼。有时人们锻炼是为了完成一定数量的各种动作的重复；而有时他们只是想要锻炼一定的时间。我们可以为这个目的创建一个类层次结构，但使用关联值的枚举效果很好：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, when we want to create a workout, we only need to define values relevant
    to the type of workout we are interested in without having to use any classes
    at all.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要创建一个锻炼时，我们只需要定义与我们感兴趣的锻炼类型相关的值，而无需使用任何类。
- en: Concisely representing state
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁地表示状态
- en: 'Another great use of enumerations with associated values is to represent the
    state of something. The simplest example of this would be a result enumeration
    that can either contain a value or an error description if an error occurs:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举与关联值另一个很好的用途是表示某物的状态。这个最简单的例子将是一个结果枚举，它可以在发生错误时包含一个值或错误描述：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This allows us to write a function that can fail and give a reason that it
    failed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们编写一个可能会失败并给出失败原因的函数：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is an alternative to normal error handling and can make sense for functions
    where the failure case is treated similarly to a success case instead of as a
    rare exception.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对正常错误处理的替代方案，并且对于将失败情况视为与成功情况类似而不是罕见异常的情况的函数来说是有意义的。
- en: 'A slightly more complex idea is to use an enumeration to represent a process
    that will go through various stages over time, often called a state machine. We
    could write an enumeration for the process of a download:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微复杂一些的想法是使用枚举来表示一个将在一段时间内经过各种阶段的过程，通常称为状态机。我们可以为下载过程编写一个枚举：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While the download is in progress we can access how complete it is and once
    it is complete we can access the data that it downloaded. This information is
    only accessible when it is applicable. This enumeration will also make it easier
    to make sure our download is always in a reasonable and clearly defined state.
    There is no possibility for a middle ground where, for example, the download might
    be complete but the data hasn't been processed yet. If we wanted to represent
    an additional processing step, we could easily add another case and it would be
    clear from then on out that a download will go through that additional state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载进行过程中，我们可以访问其完成程度，一旦完成，我们可以访问下载的数据。这些信息仅在适用时才可访问。这个枚举还将使确保我们的下载始终处于合理且明确定义的状态变得更加容易。例如，下载可能已完成但数据尚未处理的中立状态是不可能的。如果我们想要表示一个额外的处理步骤，我们可以轻松地添加另一个情况，并且从那时起，将清楚地知道下载将经过那个额外的状态。
- en: Extending system types to reduce code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展系统类型以减少代码
- en: Another powerful feature that we briefly covered in [Chapter 3](ch03.html "Chapter 3. One
    Piece at a Time – Types, Scopes, and Projects"), *One Piece at a Time – Types,
    Scopes, and Projects* is the ability to extend existing types. We saw that we
    could add an extension to the string type that would allow us to repeat the string
    multiple times. Let's look at a more practical use case for this and discuss its
    benefits in terms of improving our code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们在[第3章](ch03.html "第3章。一次处理一个部分 – 类型、作用域和项目")中简要介绍过的强大功能，即*一次处理一个部分 – 类型、作用域和项目*，是扩展现有类型的能力。我们了解到，我们可以向字符串类型添加一个扩展，使我们能够多次重复字符串。让我们看看这个功能的更实际的应用案例，并讨论它在改进我们的代码方面的好处。
- en: Perhaps we are creating a grade-tracking program where we are going to be printing
    out a lot of percentages. A great way to represent percentages is by using a float
    with a value between zero and one. Floats are great for percentages because we
    can use the built-in math functions and they can represent pretty granular numbers.
    The hurdle to cross when using a float to represent a percentage is printing it
    out. If we simply print out the value, it will most likely not be formatted the
    way we would want. People prefer percentages to be out of 100 and have a percent
    symbol after it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们正在创建一个成绩跟踪程序，我们将打印出大量的百分比。表示百分比的一个很好的方式是使用介于零和一之间的浮点数。浮点数非常适合表示百分比，因为我们可以使用内置的数学函数，并且它们可以表示非常细粒度的数字。使用浮点数表示百分比时需要克服的障碍是打印它。如果我们简单地打印出值，它很可能不是我们想要的方式。人们更喜欢百分比以
    100 为基数，并在其后加上百分号。
- en: Worst case scenario, we are going to write something, such as `print("\(myPercent
    * 100)%")`, every time we need to print out a percentage. This is not very flexible;
    what if we wanted to tweak all percentage outputs to have leading spaces, so it
    prints out right aligned? We would have to go through and change every print statement.
    Instead, we could write our own function like `printPercentage`. This will allow
    us to share the same code in lots of places.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是，我们每次需要打印百分比时都要写一些东西，比如 `print("\(myPercent * 100)%")`。这并不灵活；如果我们想调整所有百分比输出以具有前导空格，使其打印为右对齐，我们不得不逐个更改每个打印语句。相反，我们可以编写自己的函数，比如
    `printPercentage`。这将允许我们在很多地方共享相同的代码。
- en: 'This is a good step, but we can do one better using Swift''s ability to extend
    system types. If we have an arbitrary function called `printPercentage`, we are
    going to have a hard time remembering it is there and other developers will have
    a hard time discovering it in the first place. It would be much nicer if we could
    easily get a printable version of a float directly from the float itself. We can
    make this possible by adding an extension to `Float`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的步骤，但我们可以利用 Swift 扩展系统类型的能力做得更好。如果我们有一个名为 `printPercentage` 的任意函数，我们将很难记住它的存在，其他开发者也可能很难在最初发现它。如果我们可以轻松地从浮点数本身获取可打印版本，那就好多了。我们可以通过向
    `Float` 添加扩展来实现这一点：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can use auto-complete to help us remember what formats we have defined
    for a float. Over time, you will probably develop a collection of useful and generic
    extensions like this that are extremely reusable because they are independent
    of any of your other program specific code. Writing these in such a reusable way
    makes it very easy to bring them into a new program, greatly accelerating each
    new project you start.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用自动完成功能来帮助我们记住为浮点数定义了哪些格式。随着时间的推移，你可能会积累一些像这样的有用且通用的扩展，它们因为独立于你其他特定程序的代码而极具可重用性。以这种方式编写这些代码使得将它们引入新程序变得非常容易，从而大大加快了每个新项目的启动速度。
- en: 'However, you do want to be careful that you don''t end up creating too many
    extensions. For more complex situations, it is often more appropriate to use the
    composite pattern instead. For example, we could have written this as a `Percent`
    type that can be constructed with a `Float`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你确实需要小心，不要创建太多的扩展。对于更复杂的情况，通常更合适的是使用组合模式。例如，我们可以将其编写为一个可以与 `Float` 构造的 `Percent`
    类型：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case it may not warrant the complexity of its own class, but you should
    at least consider how you might want to extend the idea of a percentage in the
    future.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可能不需要创建自己的类，但你至少应该考虑如何在未来扩展百分比的概念。
- en: Lazy properties
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载属性
- en: One feature we have not yet discussed is the concept of lazy properties. Marking
    a property as lazy allows Swift to wait to initialize it until the first time
    it is accessed. This can be useful in at least a few important ways.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未讨论的一个特性是懒加载属性的概念。将属性标记为懒加载允许 Swift 在首次访问时才初始化它。这至少在几个重要方面可能很有用。
- en: Avoiding unnecessary memory usage
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的内存使用
- en: 'The most obvious way to use lazy properties is to avoid unnecessary memory
    usage. Let''s look at a very simple example first:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用懒加载属性最明显的方式是避免不必要的内存使用。让我们先来看一个非常简单的例子：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though we created a new instance of `MyType` in the preceding code, `largeString`
    is not set until we try to access it. This is great if we have a large variable
    that may not be needed on every instance. Until it is accessed, it is not taking
    up any memory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在前面的代码中创建了一个新的`MyType`实例，但直到我们尝试访问它之前，`largeString`并未被设置。如果我们有一个可能不是每个实例都需要的大变量，这很好。在访问之前，它不会占用任何内存。
- en: Avoiding unnecessary processing
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的处理
- en: 'We can also take this idea of a lazy property even further using a closure
    to calculate the value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用闭包来计算值进一步扩展这个懒属性的想法：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we are actually making use of a self-evaluating closure. We did this by
    adding the open and close parentheses to the end of the closure. By doing this,
    we are assigning the `subFolders` property to the result of executing the closure;
    because it is a lazy property, the closure will not be executed until the `subFolders`
    property is accessed for the first time. Just like the plain lazy property that
    can help us avoid taking up unnecessary memory, this technique allows us to avoid
    running time-consuming operations when we don't have to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上是在使用一个自我评估的闭包。我们通过在闭包的末尾添加开闭括号来实现这一点。通过这样做，我们将`subFolders`属性分配给执行闭包的结果；因为它是一个延迟属性，所以闭包只有在第一次访问`subFolders`属性时才会执行。就像可以帮我们避免占用不必要的内存的普通延迟属性一样，这项技术允许我们在不需要时避免运行耗时的操作。
- en: Localizing logic to the concerned property
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将逻辑本地化到相关属性
- en: An alternative to using lazy properties to achieve our goals above would be
    to use optional properties instead and simply assign those values later as needed.
    This is an OK solution, especially if our only goal is to reduce unnecessary memory
    usage or processing. However, there is one other great benefit to the lazy property
    solution. It produces more legible code by connecting the logic to calculate a
    property's value right by its definition. If we simply had an optional property
    it would have to be initialized in either an initializer or by some other method.
    It would not be immediately clear when looking at the property what its value
    will be and when it will be set, if it will be set at all.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现上述目标，除了使用懒属性外，我们还可以使用可选属性，并在需要时简单地分配这些值。这是一个可行的解决方案，特别是如果我们唯一的目的是减少不必要的内存使用或处理。然而，懒属性解决方案还有另一个巨大的好处。它通过将计算属性值的逻辑直接连接到其定义，产生了更易读的代码。如果我们只是有一个可选属性，它必须在初始化器或其他方法中初始化。在查看属性时，不会立即清楚其值是什么，以及何时设置，如果会设置的话。
- en: This is a critically important advantage as your code base grows in size and
    age. It is very easy to get lost in a code base, even if it is your own. The more
    straight lines you can draw from one piece of logic to another, the easier it
    will be able to find the logic you are looking for when you come back to your
    code base later.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码库规模和年龄增长时，这是一个至关重要的优势。即使代码库是你的，也很容易在其中迷失方向。你可以从一条逻辑到另一条逻辑画出越多的直线，当你后来回到代码库时，找到你想要的逻辑就会越容易。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of very large design concepts in a short period of time.
    We have looked at a number of specific design patterns, that help reduce the complexity
    of our code by reducing inter-object dependencies, commonly referred to as low
    coupling, and increasing the simplicity in which those objects work together,
    otherwise referred to as high cohesion.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在短时间内，我们覆盖了许多非常大的设计概念。我们查看了许多特定的设计模式，这些模式通过减少对象之间的依赖性来降低我们代码的复杂性，通常称为低耦合，并增加了这些对象协同工作的简单性，通常称为高内聚。
- en: We learned that there are three types of design patterns that focus on fixing
    different types of problems. Behavioral patterns help objects communicate with
    each other better, structural patterns facilitate the breaking down of complex
    structures into smaller and simpler ones, and creational patterns help with the
    initialization of new objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，存在三种关注解决不同类型问题的设计模式。行为模式有助于对象之间更好地进行通信，结构模式促进将复杂结构分解成更小、更简单的部分，而创建模式则帮助初始化新对象。
- en: We also looked at some very specific features of Swift and how they can help
    us achieve similar goals to the ones we achieve with design patterns. We saw how
    to use enumerations with associated values to reduce the complexity of our type
    system and represent state better; we used extensions to system types to reduce
    the amount of code we write, and we wrote more efficient and understandable code
    using lazy properties.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 Swift 的一些非常具体的特性以及它们如何帮助我们实现与设计模式相似的目标。我们看到了如何使用带关联值的枚举来简化我们的类型系统并更好地表示状态；我们使用扩展来减少对系统类型的代码量，并使用惰性属性编写更高效、更易于理解的代码。
- en: As I said in the beginning, design patterns is a huge topic and not something
    you will master quickly, if ever. Figuring out how to best use the feature of
    a specific language is also a huge topic. I strongly recommend you use this chapter
    as a reference when you start to develop larger software and want to find ways
    to make it less complex. I also strongly encourage you to research more patterns
    and try to implement them on your own. Each design pattern is another tool in
    your toolbox. The more tools you have and the more experienced you are with each
    of them, the better you will be able to choose the right tool for the right job.
    That is the art of programming.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我一开始所说的，设计模式是一个巨大的主题，而且不是你能够迅速掌握的，如果真的能掌握的话。弄清楚如何最好地使用特定语言的功能也是一个巨大的主题。我强烈建议你在开始开发大型软件并希望找到使其更简单的方法时，将本章作为参考。我也强烈鼓励你研究更多模式，并尝试自己实现它们。每个设计模式都是你工具箱中的另一个工具。你拥有的工具越多，你对每个工具的经验越丰富，你就越能选择适合正确工作的正确工具。这就是编程的艺术。
- en: Now we are ready for the next chapter, where we will take a step back into the
    past to look at Objective-C so that we can leverage the vast resources targeted
    at Objective-C that are still very relevant to us as Swift developers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进入下一章，在这一章中，我们将回顾过去，研究 Objective-C，以便我们能够利用针对 Objective-C 的丰富资源，这些资源对我们作为
    Swift 开发者来说仍然非常相关。
