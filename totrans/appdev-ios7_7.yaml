- en: Chapter 7. Manipulating Text with TextKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用TextKit操作文本
- en: We will start this chapter with an overview of the new UIKit hierarchy. From
    there, we will dive directly into the dynamic text type to support OS-wide font
    and size settings. Next, we will cover some of the new features, such as exclusion
    paths to wrap texts around shapes and adding a letterpress effect with a few lines
    of code. Last, we will discuss how to apply standard formatting to your text,
    such as underlined text. Let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，概述新的UIKit层次结构。从那里，我们将直接深入到动态文本类型以支持全系统字体和大小设置。接下来，我们将介绍一些新功能，例如使用排除路径将文本围绕形状包裹以及使用几行代码添加压痕效果。最后，我们将讨论如何将标准格式应用于文本，例如下划线文本。让我们开始吧！
- en: What is TextKit?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是TextKit？
- en: Prior to iOS 6, providing mixed styles for your text was available using **UIWebView**
    and HTML markup or using the lower level framework **Core Text**. With the launch
    of iOS 6, Apple introduced attributed strings, allowing developers to adjust color
    and font attributes on defined subsections of any string. The first 10 characters
    could be set to a color of yellow and the remaining characters a bold font.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 6之前，您可以使用 **UIWebView** 和HTML标记或使用较低级别的框架 **Core Text** 来提供文本的混合样式。随着iOS
    6的推出，苹果引入了属性字符串，允许开发者调整任何字符串定义子部分的颜色和字体属性。前10个字符可以设置为黄色，其余字符为粗体字体。
- en: 'In iOS 6, text-based UIKit controls were based on both Core Graphics and WebKit.
    Here is a diagram to illustrate the hierarchy:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 6中，基于文本的UIKit控件基于Core Graphics和WebKit。以下是一个示意图来展示其层次结构：
- en: '![What is TextKit?](img/0319OT_07_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![什么是TextKit?](img/0319OT_07_01.jpg)'
- en: You will notice that **UITextView** actually uses **WebKit** itself for the
    sake of drawing attributed text using HTML. Although attributed strings provided
    many solutions for working with text, they were limited in flexibility for advanced
    layouts. This multi-line rendered text required the use of **Core Text**. This
    framework is very difficult to work with and understand.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 **UITextView** 实际上使用 **WebKit** 本身来绘制带有HTML的属性文本。尽管属性字符串提供了许多处理文本的解决方案，但它们在高级布局的灵活性方面有限。这种多行渲染文本需要使用
    **Core Text**。这个框架非常难以处理和理解。
- en: 'With iOS 7, Apple has introduced **TextKit** to streamline working with text.
    Apple now inherits **UITextView** from **TextKit** rather than **WebKit** as illustrated
    in the following figure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7中，苹果引入了 **TextKit** 以简化文本处理。苹果现在从 **TextKit** 继承 **UITextView** 而不是从 **WebKit**，如下面的图所示：
- en: '![What is TextKit?](img/0319OT_07_02.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![什么是TextKit?](img/0319OT_07_02.jpg)'
- en: '**TextKit** inherits all of the power found in **Core Text** (it is built on
    top of **Core Text**) and provides it in an easy-to-use and much improved API.
    All text-based UIKit controls (with the exception of **UIWebView** for obvious
    reasons) are now using **TextKit**. You can see how the core structure is now
    much more refined with better flow.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextKit** 继承了所有在 **Core Text** 中找到的强大功能（它是建立在 **Core Text** 之上的），并以易于使用且改进了许多的API提供。现在所有基于文本的UIKit控件（除了出于明显原因的
    **UIWebView**）现在都在使用 **TextKit**。你可以看到核心结构现在变得更加精细，具有更好的流线型。'
- en: 'TextKit can be divided into three primary classes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TextKit可以分为三个主要类：
- en: '`NSTextStorage`: This class is used to store all text attribute information.
    Think of it as an internal blueprint for all text effects. It is important to
    note that `NSTextStorage` is a subclass of the `NSMutableAttributedString` class,
    which is why it is responsible for all text attributes. In addition to storing
    text attributes, `NSTextStorage` will also make sure everything stays consistent
    during all editing operations.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSTextStorage`：这个类用于存储所有文本属性信息。将其视为所有文本效果的内部蓝图。需要注意的是，`NSTextStorage`是`NSMutableAttributedString`类的子类，因此它负责所有文本属性。除了存储文本属性外，`NSTextStorage`还将确保在所有编辑操作中保持一致性。'
- en: '`NSLayoutManager`: This class will manage the way the data found in `NSTextStorage`
    is laid out in the view (as the name implies). `NSTextStorage` will notify this
    class if any changes or modifications have been made to the stored text attributes.
    It will then update the views accordingly. As a result, changes are reflected
    almost instantaneously.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSLayoutManager`：这个类将管理在`NSTextStorage`中找到的数据在视图中的布局方式（正如其名所示）。如果存储的文本属性有任何更改或修改，`NSTextStorage`将通知这个类。然后它会相应地更新视图。因此，更改几乎可以即时反映出来。'
- en: '`NSTextContainer`: This class is responsible for specifying the view that the
    text will be displayed in. `NSTextContainer` also keeps track of the information
    related to the view, such as size/frame or shape. Most notably, `NSTextContainer`
    is capable of storing an array of bezier paths, which we will use later when creating
    exclusion paths. This is what allows TextKit to flow text around images and other
    objects.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSTextContainer`：这个类负责指定文本将要显示的视图。`NSTextContainer`还跟踪与视图相关的信息，例如大小/框架或形状。最值得注意的是，`NSTextContainer`能够存储一个bezier路径数组，我们将在创建排除路径时使用它。这就是TextKit能够围绕图像和其他对象流动文本的原因。'
- en: TextKit can be used for multiple text-based effects. This includes responding
    to user-selected text sizes with dynamic type, wrapping text around an image with
    exclusion paths, and text formatting similar to a rich text editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TextKit可用于多种基于文本的效果。这包括对用户选择的文本大小使用动态字体，使用排除路径围绕图像包裹文本，以及类似于富文本编辑器的文本格式。
- en: In this chapter, we will cover all of these features in detail and then apply
    some of them to our application text. To start, let's look at dynamic type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍所有这些功能，并将其中一些应用到我们的应用程序文本中。首先，让我们看看动态字体。
- en: Dynamic type
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态字体
- en: 'One of the biggest new features of iOS 7 from a user experience standpoint
    is the ability to adjust OS-wide text formatting. This includes increasing the
    font weight (bold) and text size. These settings can be set in the device''s settings
    application. Although it is not a requirement to support dynamic type, it is recommended
    to do so! Here is an example of these settings:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看，iOS 7最大的新特性之一是能够调整整个操作系统的文本格式。这包括增加字体粗细（粗体）和文本大小。这些设置可以在设备的设置应用程序中设置。尽管支持动态字体不是强制性的，但建议这样做！以下是一个这些设置的示例：
- en: '![Dynamic type](img/0319OT_07_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![动态字体](img/0319OT_07_03.jpg)'
- en: 'When typically dealing with fonts, we specify the font family name and the
    size we want to set, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在通常处理字体时，我们指定要设置的字体家族名称和大小，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When working with dynamic type, we will use fonts with styles instead of using
    the literal name of any font unlike the preceding code. `UIFont` has been equipped
    with a new method called `preferredFontForTextStyle`. This loads the selected
    font preferences from the user''s device and sets the text to the given style.
    Here is an example of the multiple font styles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理动态字体时，我们将使用具有样式的字体，而不是使用任何字体的字面名称，这与前面的代码不同。`UIFont`已经配备了一个名为`preferredFontForTextStyle`的新方法。这个方法从用户的设备加载所选的字体偏好，并将文本设置为给定的样式。以下是一个多字体样式的示例：
- en: '![Dynamic type](img/0319OT_07_04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![动态字体](img/0319OT_07_04.jpg)'
- en: 'The text on the left-hand side is the smallest size able to be rendered, the
    middle text is the largest size possible, while the right-hand side text is each
    an option in bold format. Let''s take a look at an example of using TextKit for
    dynamic type. Here is a code example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的文本是可以渲染的最小尺寸，中间的文本是可能的最大尺寸，而右侧的文本是每个选项的粗体格式。让我们看看使用TextKit进行动态字体的一个示例。以下是一个代码示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As mentioned in the preceding code, we are not using an explicit font name,
    but instead are using one of the six included styles. By doing this, we avoid
    using hard-coded font names for our application. As a result, our application
    will respond very well to user-defined font selections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码中提到的，我们不是使用显式的字体名称，而是使用其中的一种六种包含的样式。通过这样做，我们避免了在我们的应用程序中使用硬编码的字体名称。因此，我们的应用程序将很好地响应用户定义的字体选择。
- en: Handling updates
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理更新
- en: The preceding code will automatically render based on the user settings. A problem
    occurs when you switch to settings and adjust the text size. If you switch back
    to the application without closing it first, the text updates will not be reflected.
    This is because in order to respond to actual changes, your controller must respond
    to changes made using `NSNotificatonCenter`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将根据用户设置自动渲染。当您切换到设置并调整文本大小时，会出现问题。如果您在没有先关闭应用程序的情况下切换回应用程序，文本更新将不会反映出来。这是因为为了响应实际的变化，您的控制器必须响应使用`NSNotificationCenter`做出的更改。
- en: 'By adding the following code to the end of any `viewDidLoad` method, you can
    have your controller respond to text updates:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下代码添加到任何`viewDidLoad`方法的末尾，您可以使您的控制器响应用文更新：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The defined selector will look something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的选择器将看起来像这样：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First we register our class to receive notification updates based on the preferred
    content size changing. So, if a user switches to the settings application and
    changes the text size, our app will intercept this and call the defined method
    `preferredContentSizeChanged`. Earlier, this method simply set the font; however,
    now it will be pulling in the new user-defined text size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注册我们的类以接收基于首选内容大小变化的更新通知。因此，如果用户切换到设置应用并更改文本大小，我们的应用将拦截此操作并调用定义的方法`preferredContentSizeChanged`。之前，这个方法只是设置字体；然而，现在它将拉取新的用户定义的文本大小。
- en: Changing the text size can also affect your view layouts. Because of this, you
    want to have your views to be responsive based on the text. Most of this can be
    done using Auto Layout. While Auto Layout may work well in most cases, one area
    where it does not work well is determining row height.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 改变文本大小也会影响你的视图布局。因此，你希望你的视图能够根据文本做出响应。大部分的这些都可以通过自动布局（Auto Layout）来完成。虽然自动布局在大多数情况下都能很好地工作，但它不擅长处理行高的确定。
- en: Exclusion paths
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除路径
- en: Exclusion paths allow you to wrap text around a particular view. Most text editors
    provide support for this feature, and with TextKit, you can now do it in your
    applications. With TextKit, you can wrap your text around both complex and simple
    paths. For instance, you may want to wrap your text around a simple circle or
    around a more complex shape such as a butterfly image. You may want to use this
    feature when displaying text with images, or even views that provide relevant
    details related to the text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 排除路径允许你围绕特定的视图包裹文本。大多数文本编辑器都提供了对这一功能的支持，而通过TextKit，你现在可以在你的应用程序中实现这一功能。使用TextKit，你可以围绕复杂和简单的路径包裹你的文本。例如，你可能想要围绕一个简单的圆形或围绕一个更复杂的形状，如蝴蝶图片。你可能想在显示带有图像的文本或提供与文本相关细节的视图时使用此功能。
- en: 'Let''s assume you have a circular UIView that contains data related to a piece
    of text. We want to center the circular UIImageView and wrap the text around it
    on all sides. To test this, let''s add a text view to our storyboard and wrap
    some filler text around our food image. Switch to **Main.Storyboard** and select
    the `FoodDetailViewController` class. Drag over a text view and resize it to be
    bigger than the food image. Additionally, make sure that the text view is beneath
    the image view. Here is what your storyboard should look like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含与一段文本相关的数据的圆形`UIView`。我们希望将圆形的`UIImageView`居中，并在其四周包裹文本。为了测试这个功能，让我们在我们的故事板中添加一个文本视图，并在我们的食物图片周围包裹一些填充文本。切换到**Main.Storyboard**并选择`FoodDetailViewController`类。拖动一个文本视图并调整其大小，使其比食物图片大。此外，确保文本视图位于图片视图下方。你的故事板应该看起来像这样：
- en: '![Exclusion paths](img/0319OT_07_05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![排除路径](img/0319OT_07_05.jpg)'
- en: Make sure to create an outlet to `FoodDetailViewController` for our new text
    view. Give it the name `textview`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为我们的新文本视图`FoodDetailViewController`创建一个输出端口。给它命名为`textview`。
- en: 'Switch to `FoodDetailViewController.m` and scroll to `viewDidLoad`. Add this
    line of code at the very bottom:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`FoodDetailViewController.m`并滚动到`viewDidLoad`。在底部添加以下代码行：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we create a new bezier path and give it coordinates of a rectangle that
    are equal to those of our image view rectangle. Now that we have defined the shape
    for exclusion, it is time to tell the text view to pay attention to this exclusion
    path. TextKit has included an additional property to the text container of all
    text-based views called `exclusionPaths`. This parameter accepts an array, which
    means that multiple exclusions can be handled at once. Here is the result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的贝塞尔路径，并给它一个与我们的图片视图矩形相等的坐标。现在我们已经定义了排除形状，是时候告诉文本视图注意这个排除路径了。TextKit为所有基于文本的视图的文本容器增加了一个额外的属性，称为`exclusionPaths`。这个参数接受一个数组，这意味着可以同时处理多个排除。以下是结果：
- en: '![Exclusion paths](img/0319OT_07_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![排除路径](img/0319OT_07_06.jpg)'
- en: Adding letterpress
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加压印效果
- en: Any text can appear to be letter pressed with the right amount of shadow and
    highlight. TextKit provides an easy and effective way to accomplish this with
    a new attribute parameter called `NSTextEffectLetterpressStyle`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何文本都可以通过适当的阴影和突出显示效果看起来像是压印的。TextKit通过一个名为`NSTextEffectLetterpressStyle`的新属性参数提供了一个简单有效的方法来实现这一点。
- en: 'Here is an example with code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有代码的示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using attributed strings, we can apply this specific text effect in addition
    to other attributes. That''s all it takes to apply this subtle effect! Take a
    look at our app as an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性文本，我们可以应用这种特定的文本效果，以及其他属性。这就是应用这种微妙效果的全部！以我们的应用为例看看：
- en: '![Adding letterpress](img/0319OT_07_07.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![添加凸版印刷](img/0319OT_07_07.jpg)'
- en: Text formatting
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本格式化
- en: With TextKit, we can apply some fairly simple text editing properties to our
    text. These include bold, italics, and underlined text. In order to do this, we
    are going to use a brand new class available in iOS 7, `UIFontDescriptor`. This
    class is used to describe a font and all of its attributes. Also, more importantly,
    you are able to directly modify attributes and create a new font. All font attributes
    are represented by either a dictionary or a key string constant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TextKit，我们可以将一些简单的文本编辑属性应用到我们的文本上。这包括粗体、斜体和下划线文本。为了做到这一点，我们将使用iOS 7中一个全新的类，`UIFontDescriptor`。这个类用于描述字体及其所有属性。更重要的是，您可以直接修改属性并创建一个新的字体。所有字体属性都由字典或键字符串常量表示。
- en: Making text bold and italicizing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作粗体和斜体文本
- en: 'Let''s take a look at a piece of code to see how we can make bold text using
    `UIFontDescriptor`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一段代码，看看我们如何使用`UIFontDescriptor`来制作粗体文本：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First we are grabbing the current attributes from a text view's text storage
    object. Next we are creating a reference to the original font used for this piece
    of text. We want to do this just in case we need that information (this is mostly
    dependent on why the application is using `UIFontDescriptor`). We also create
    a reference to the current font descriptor as well. Once we have all of this information,
    we create a new font descriptor and set its symbolic trait to be bold. Lastly,
    we create an instance of our new font that used our new font descriptor and assign
    it to our text view. To change the text to italics, simply pass the proper symbolic
    trait.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从文本视图的文本存储对象中获取当前的属性。接下来，我们创建一个对这个文本块原始字体使用的引用。我们想这样做，以防我们需要这些信息（这主要取决于应用程序为什么使用`UIFontDescriptor`）。我们还创建了一个当前字体描述符的引用。一旦我们有了所有这些信息，我们就创建一个新的字体描述符，并将其符号特性设置为粗体。最后，我们创建了一个使用我们新字体描述符的新字体实例，并将其分配给我们的文本视图。要更改文本为斜体，只需传递正确的符号特性。
- en: 'A symbolic trait is actually just a property of a font that describes its style.
    It is an unsigned 32-bit integer. Here is the list of all traits that has been
    provided by Apple:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 符号特性实际上只是描述字体风格的属性。它是一个无符号32位整数。以下是苹果提供所有特性的列表：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Underlining text
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下划线文本
- en: 'Using TextKit to underline text is accomplished using a method similar to any
    one of the methods shown in the preceding code, with some modifications. Here
    is a code sample:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TextKit下划线文本的方法类似于前面代码中显示的任何一种方法，但有一些修改。以下是一个代码示例：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we must check if the `NSUnderlineStyleAttributeName` attribute already
    exists in our current text attributes. From here, we simply turn the underline
    attribute **On** or **Off** and apply it to our text.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须检查当前的文本属性中是否已经存在`NSUnderlineStyleAttributeName`属性。从这里，我们只需简单地打开或关闭下划线属性并将其应用到我们的文本上。
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: TextKit offers many great ways to manipulate text in iOS. Supporting these features
    is key to providing a better experience for users. I recommend that you take the
    time to navigate through Apple's documentation. We have covered many of the standard
    uses in this chapter. TextKit is a very powerful new API that will continue to
    provide innovative ways to be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TextKit为iOS中的文本操作提供了许多优秀的方法。支持这些功能对于提供更好的用户体验至关重要。我建议您花时间浏览苹果的文档。我们已经在本章中涵盖了标准用法。TextKit是一个非常强大的新API，将继续提供创新的使用方式。
- en: In the final chapter, we are going to cover UIKit Dynamics. We will learn how
    adding physics to our UI elements can create an exciting experience!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将介绍UIKit Dynamics。我们将学习如何通过向UI元素添加物理特性来创造令人兴奋的体验！
