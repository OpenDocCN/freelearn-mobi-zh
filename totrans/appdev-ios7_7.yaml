- en: Chapter 7. Manipulating Text with TextKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this chapter with an overview of the new UIKit hierarchy. From
    there, we will dive directly into the dynamic text type to support OS-wide font
    and size settings. Next, we will cover some of the new features, such as exclusion
    paths to wrap texts around shapes and adding a letterpress effect with a few lines
    of code. Last, we will discuss how to apply standard formatting to your text,
    such as underlined text. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: What is TextKit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to iOS 6, providing mixed styles for your text was available using **UIWebView**
    and HTML markup or using the lower level framework **Core Text**. With the launch
    of iOS 6, Apple introduced attributed strings, allowing developers to adjust color
    and font attributes on defined subsections of any string. The first 10 characters
    could be set to a color of yellow and the remaining characters a bold font.
  prefs: []
  type: TYPE_NORMAL
- en: 'In iOS 6, text-based UIKit controls were based on both Core Graphics and WebKit.
    Here is a diagram to illustrate the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is TextKit?](img/0319OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that **UITextView** actually uses **WebKit** itself for the
    sake of drawing attributed text using HTML. Although attributed strings provided
    many solutions for working with text, they were limited in flexibility for advanced
    layouts. This multi-line rendered text required the use of **Core Text**. This
    framework is very difficult to work with and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'With iOS 7, Apple has introduced **TextKit** to streamline working with text.
    Apple now inherits **UITextView** from **TextKit** rather than **WebKit** as illustrated
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is TextKit?](img/0319OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TextKit** inherits all of the power found in **Core Text** (it is built on
    top of **Core Text**) and provides it in an easy-to-use and much improved API.
    All text-based UIKit controls (with the exception of **UIWebView** for obvious
    reasons) are now using **TextKit**. You can see how the core structure is now
    much more refined with better flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TextKit can be divided into three primary classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSTextStorage`: This class is used to store all text attribute information.
    Think of it as an internal blueprint for all text effects. It is important to
    note that `NSTextStorage` is a subclass of the `NSMutableAttributedString` class,
    which is why it is responsible for all text attributes. In addition to storing
    text attributes, `NSTextStorage` will also make sure everything stays consistent
    during all editing operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSLayoutManager`: This class will manage the way the data found in `NSTextStorage`
    is laid out in the view (as the name implies). `NSTextStorage` will notify this
    class if any changes or modifications have been made to the stored text attributes.
    It will then update the views accordingly. As a result, changes are reflected
    almost instantaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSTextContainer`: This class is responsible for specifying the view that the
    text will be displayed in. `NSTextContainer` also keeps track of the information
    related to the view, such as size/frame or shape. Most notably, `NSTextContainer`
    is capable of storing an array of bezier paths, which we will use later when creating
    exclusion paths. This is what allows TextKit to flow text around images and other
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextKit can be used for multiple text-based effects. This includes responding
    to user-selected text sizes with dynamic type, wrapping text around an image with
    exclusion paths, and text formatting similar to a rich text editor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover all of these features in detail and then apply
    some of them to our application text. To start, let's look at dynamic type.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest new features of iOS 7 from a user experience standpoint
    is the ability to adjust OS-wide text formatting. This includes increasing the
    font weight (bold) and text size. These settings can be set in the device''s settings
    application. Although it is not a requirement to support dynamic type, it is recommended
    to do so! Here is an example of these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic type](img/0319OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When typically dealing with fonts, we specify the font family name and the
    size we want to set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with dynamic type, we will use fonts with styles instead of using
    the literal name of any font unlike the preceding code. `UIFont` has been equipped
    with a new method called `preferredFontForTextStyle`. This loads the selected
    font preferences from the user''s device and sets the text to the given style.
    Here is an example of the multiple font styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic type](img/0319OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The text on the left-hand side is the smallest size able to be rendered, the
    middle text is the largest size possible, while the right-hand side text is each
    an option in bold format. Let''s take a look at an example of using TextKit for
    dynamic type. Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the preceding code, we are not using an explicit font name,
    but instead are using one of the six included styles. By doing this, we avoid
    using hard-coded font names for our application. As a result, our application
    will respond very well to user-defined font selections.
  prefs: []
  type: TYPE_NORMAL
- en: Handling updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding code will automatically render based on the user settings. A problem
    occurs when you switch to settings and adjust the text size. If you switch back
    to the application without closing it first, the text updates will not be reflected.
    This is because in order to respond to actual changes, your controller must respond
    to changes made using `NSNotificatonCenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding the following code to the end of any `viewDidLoad` method, you can
    have your controller respond to text updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The defined selector will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First we register our class to receive notification updates based on the preferred
    content size changing. So, if a user switches to the settings application and
    changes the text size, our app will intercept this and call the defined method
    `preferredContentSizeChanged`. Earlier, this method simply set the font; however,
    now it will be pulling in the new user-defined text size.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the text size can also affect your view layouts. Because of this, you
    want to have your views to be responsive based on the text. Most of this can be
    done using Auto Layout. While Auto Layout may work well in most cases, one area
    where it does not work well is determining row height.
  prefs: []
  type: TYPE_NORMAL
- en: Exclusion paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exclusion paths allow you to wrap text around a particular view. Most text editors
    provide support for this feature, and with TextKit, you can now do it in your
    applications. With TextKit, you can wrap your text around both complex and simple
    paths. For instance, you may want to wrap your text around a simple circle or
    around a more complex shape such as a butterfly image. You may want to use this
    feature when displaying text with images, or even views that provide relevant
    details related to the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume you have a circular UIView that contains data related to a piece
    of text. We want to center the circular UIImageView and wrap the text around it
    on all sides. To test this, let''s add a text view to our storyboard and wrap
    some filler text around our food image. Switch to **Main.Storyboard** and select
    the `FoodDetailViewController` class. Drag over a text view and resize it to be
    bigger than the food image. Additionally, make sure that the text view is beneath
    the image view. Here is what your storyboard should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exclusion paths](img/0319OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure to create an outlet to `FoodDetailViewController` for our new text
    view. Give it the name `textview`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `FoodDetailViewController.m` and scroll to `viewDidLoad`. Add this
    line of code at the very bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a new bezier path and give it coordinates of a rectangle that
    are equal to those of our image view rectangle. Now that we have defined the shape
    for exclusion, it is time to tell the text view to pay attention to this exclusion
    path. TextKit has included an additional property to the text container of all
    text-based views called `exclusionPaths`. This parameter accepts an array, which
    means that multiple exclusions can be handled at once. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exclusion paths](img/0319OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding letterpress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any text can appear to be letter pressed with the right amount of shadow and
    highlight. TextKit provides an easy and effective way to accomplish this with
    a new attribute parameter called `NSTextEffectLetterpressStyle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using attributed strings, we can apply this specific text effect in addition
    to other attributes. That''s all it takes to apply this subtle effect! Take a
    look at our app as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding letterpress](img/0319OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With TextKit, we can apply some fairly simple text editing properties to our
    text. These include bold, italics, and underlined text. In order to do this, we
    are going to use a brand new class available in iOS 7, `UIFontDescriptor`. This
    class is used to describe a font and all of its attributes. Also, more importantly,
    you are able to directly modify attributes and create a new font. All font attributes
    are represented by either a dictionary or a key string constant.
  prefs: []
  type: TYPE_NORMAL
- en: Making text bold and italicizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at a piece of code to see how we can make bold text using
    `UIFontDescriptor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First we are grabbing the current attributes from a text view's text storage
    object. Next we are creating a reference to the original font used for this piece
    of text. We want to do this just in case we need that information (this is mostly
    dependent on why the application is using `UIFontDescriptor`). We also create
    a reference to the current font descriptor as well. Once we have all of this information,
    we create a new font descriptor and set its symbolic trait to be bold. Lastly,
    we create an instance of our new font that used our new font descriptor and assign
    it to our text view. To change the text to italics, simply pass the proper symbolic
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'A symbolic trait is actually just a property of a font that describes its style.
    It is an unsigned 32-bit integer. Here is the list of all traits that has been
    provided by Apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Underlining text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using TextKit to underline text is accomplished using a method similar to any
    one of the methods shown in the preceding code, with some modifications. Here
    is a code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we must check if the `NSUnderlineStyleAttributeName` attribute already
    exists in our current text attributes. From here, we simply turn the underline
    attribute **On** or **Off** and apply it to our text.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TextKit offers many great ways to manipulate text in iOS. Supporting these features
    is key to providing a better experience for users. I recommend that you take the
    time to navigate through Apple's documentation. We have covered many of the standard
    uses in this chapter. TextKit is a very powerful new API that will continue to
    provide innovative ways to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we are going to cover UIKit Dynamics. We will learn how
    adding physics to our UI elements can create an exciting experience!
  prefs: []
  type: TYPE_NORMAL
