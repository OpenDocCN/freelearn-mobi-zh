- en: Chapter 4. Changes to Swifts Core Will Have You Asking for More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the libraries have been touched to pull off this effort including-the
    Swift standard library, all of Cocoa and Cocoa Touch frameworks, Core Graphics,
    and Grand Central Dispatch. With the release of Swift 3, we can expect changes
    that reduce the awkwardness of the language's link to Objective-C, exuding way
    more *Swifty-ness*. The Swift team has introduced new API guidelines with the
    intention of giving the language its own character. The result is a huge renaming
    and refactoring effort that flows throughout the language. Swift 3 has undergone
    a huge facelift in terms of its interaction with Objective-C and C APIs. The Swift
    team is aiming to make your development experience feel more like Swift and less
    like directly dumping Objective-C into your code. Swift is its own language and
    should have its own feel just like any other programming language. Yet prior versions
    of Swift were heavily influenced by the need to interact with Objective-C and
    C APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will quickly highlight the philosophies for writing good
    Swift APIs. Afterward, we will spend the remaining chapter on language improvements
    for referencing and using Objective-C features in Swift 3 and importing code from
    Objective-C and C to Swift 3\. Every language change to Swift 3 is covered by
    one or more Swift Evolution proposals. As we cover a new feature, I'll also provide
    the proposal number that documents the rationale behind the change. While knowing
    the actual rational for a new feature is not critical to your understanding of
    how to implement its code, I think it is interesting to know the efforts and sometimes
    debates behind why a particular change was implemented. The Swift Evolution repository
    contains tons of information on accepted and rejected proposals. If you are a
    careful observer, you will also see proposals that were accepted for the Swift
    3 release but didn't get implemented in time for the release.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The grand renaming
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the proposals for the Swift API Design Guidelines. The Grand
    Renaming proposals represent, collectively, a very large undertaking and are covered
    by proposals *SE-0005*, *SE-0006*, *SE-0086*, and *SE-0088*. Implementing the
    API guidelines represents the largest change to the language for Swift 3\. I couldn''t
    possibly cover every API change resulting in the Grand Renaming proposals in this
    short book. Thankfully, you don''t have to understand every line that changed
    in the libraries to be productive with Swift 3\. You have two fantastic resources
    that will pay dividends with very little effort on your part. The first resource
    is the Swift migration tool which converts existing Swift projects to the latest
    syntax. When you use the Swift migrator, you can convert your Swift 2.2 projects
    to Swift 3 and receive most of the changes for free. The second extremely valuable
    resource is the Swift API Guidelines, which were developed to help make your code
    more *Swifty*. The Swift API Guidelines are based on the following principles
    as quoted on [https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Clarity at the point of use**:This is your most important goal. Entities
    such as methods and properties are declared only once but used repeatedly. Design
    APIs to make those uses clear and concise. When evaluating a design, reading a
    declaration is seldom sufficient, always examine a use case to make sure it looks
    clear in context.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarity is more important than brevity**: Although Swift code can be compact,
    it is a *non-goal* to enable the smallest possible code with the fewest characters.
    Brevity in Swift code, where it occurs, is a side-effect of the strong type system
    and features that naturally reduce the boilerplate.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write a documentation comment**: This for and every declaration. Insights
    gained by writing documentation can have a profound impact on your design, so
    don''t put it off.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on adopting these guidelines, please refer to the WWDC 2016
    lecture on Swift API Guidelines at [https://developer.apple.com/videos/play/wwdc2016/403/](https://developer.apple.com/videos/play/wwdc2016/403/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Objective-C code in Swift 3
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Swift 3, we get a slew of changes that make working with Objective-C and
    C APIs more enjoyable. We are going to cover the important changes that will make
    writing code more productive in Swift 3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the Objective-C selector of property getters and setters - SE-0064
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Objective-C, we can use a type called a **selector** to reference the name
    of a method. Swift 2.2 introduced `#selector` expressions to remove the error-prone
    nature of providing string literals as the selector name. In Swift 3, the language
    builds on #selector expressions by allowing you to reference getter and setter
    methods. This feature allows us to refer to getter and setter properties of objects.
    Let''s look at an example to see how we could access the setter for one of the
    properties on our `ClassRoom` class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now access the setter for the `roomNum` using `#selector(setter: ClassRoom.roomNum)`
    or the getter using `#selector(getter: ClassRoom.roomNum)`. Once we have our reference,
    we can use any of the NSObject perform methods available in Objective-C.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md](https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Objective-C key paths [SE-0062]
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to selectors, using Objective-C *keypaths* in Swift 2.2 required us
    to use string literals. Swift 3 introduces the `#keyPath` expressions to improve
    accuracy by replacing error-prone string literals with objects that can be checked
    at compile time. Our example below demonstrates how keypaths were done in Swift
    2.2 and how referencing keypaths improves with Swift 3.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'For Objective-C:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Swift 2.2:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Swift 3:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our Swift 3 example above, we use the `#keyPath` expressions that are compile
    time checked that allow us to safely access values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md](https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Importing code from Objective-C and C APIs to Swift 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you maintain Objective-C or C libraries and want to expose cleaner syntax
    for Swift, this section is for you! We now have the ability to provide more control
    over how constants, global functions, and generics are imported from Objective-C
    and C into Swift.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Importing Objective-C constants as Swift types [SE-0033]
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants with global scope, defined in header files, are imported with the
    same global scope in Swift. In many cases, it would be more helpful to have related
    constants grouped together. In Swift 3, you can now annotate your type declarations
    with `NS_STRING_ENUM` or `NS_EXTENSIBLE_STRING_ENUM` to have those declarations
    imported as members of a common type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Importing as Struct
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want your constants to be imported as members of a struct, then add
    `NS_EXTENSIBLE_STRING_ENUM` to the end of your constant type declaration. For
    more consistent importing into Swift, name your constants using the same type
    as a prefix. In our example, we created a `MPPlatformIdentifier` type that we
    use as a prefix to name our constants: `MPPlatformIdentifierIOS`, `MPPlatformIdentifierMacOS`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'For Objective-C:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This imports into Swift as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Importing as Enum
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your other option is to have your constants imported as an enumeration type.
    Your constants are imported as an enum when you add `NS_STRING_ENUM` to the end
    of your type. Each constant that you define using this new type will be added
    to the enum in Swift.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'For Objective-C:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This imports into Swift as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md](https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Importing Objective-C lightweight generics [SE-0057]
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift 2, you could import and interact with Objective-C lightweight generics.
    While you could import lightweight generics of any form into Swift 2, only the
    Foundation types (`NSArray`, `NSSet`, and `NSDictionary`) preserved their type
    information after import.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about lightweight generics by reading the Swift documentation
    on the subject here: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: With Swift 3, you can import your own Objective-C generics without losing information
    on the type. In our example below, we have several property types defined using
    Foundation collection types and a custom generic class. Notice that in both Swift
    2 and Swift 3, generics import their type information correctly for the Foundation
    collection types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For Objective-C:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Imports into Swift 2 as:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sadly, we lose the type information for our custom generic property `myCollection`,
    when importing into Swift 2\. Swift rightly determines that the `myCollection`
    property is of `MyCollection` type, but the parameterized data is lost. Since
    we lost our type information on import, accessing `addItem()` of `myCollection`
    class results in a method signature that uses `AnyObject` for the parameter type.
    This is a subpar result as we expect the type to be `MyClass`, matching the Objective-C
    signature.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In Swift 3, this import issue is fixed. Our custom Objective-C generics are
    imported as expected. Examining our Swift 3 import, we can see that all of our
    generics keep their type information and our class methods will completely match
    their Objective-C counterparts for our custom generic classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Imports into Swift 3 as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read the proposal at : [https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md](https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Importing as member [SE-0044]
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many C APIs provide functions that allow you to create, access, and modify C
    structures. Importing these libraries as-is will add these functions to your global
    namespace in Swift. While this is fine in many cases, it might be preferable to
    group these imports under common types in Swift. Swift 3 allows us to use the
    `CF_SWIFT_NAME` macro to control how initializers, properties, and methods display
    in Swift. Let's look at how we can accomplish these tasks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Defining an initializer
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can modify a C function to create a Swift initializer by appending a `CF_SWIFT_NAME`
    macro to the function definition in the header file. To tell Swift we want the
    function added as an initializer on a specific type, we need to provide the type
    (`MyPlatform`) followed by a dot and the *init* format we want (that is the parameters
    from the C function definition). Swift will import our new initializer as an extension
    on `MyPlatform`, representing our common type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The common type needs to exist for Swift to add any extensions. Swift will not
    create this type for you and will fail silently if no type exists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'For C:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This imports into Swift as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating getters and setters
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to initializers, we can also create computed properties. We can
    define the getters and setters that will be imported into Swift. For the property's
    getter, we need to add the `CF_SWIFT_NAME` macro to the end of the C function
    that will serve as the getter and provide a common type and a property name. Our
    setter will be similar in that we add the macro to the C function that serves
    as our setter property. See below for the syntax in action. In Swift 3, the getter
    and setter will be added to the common type `MyPlatform` using an extension.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'For C:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This imports into Swift as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding methods
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can group methods under a common type during our import into Swift 3\. This
    is accomplished using the `CF_SWIFT_NAME` macro appended to the C function definition
    in our header file. You will need to provide the macro a common type and a method
    signature that uses the same number of variables as the C function. Swift will
    handle determining the parameter type. You just need to provide names you want
    to use as the signature in Swift.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'For C:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This imports into Swift as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating static variables
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we can import global variables as static variables associated with
    a common type in Swift 3\. We just need to provide a common type and variable
    name to our `CF_SWIFT_NAME` macro. Our static variable will be added to the common
    type in Swift via an extension.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'For C:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This imports into Swift as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read the proposal at: [https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md](https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just finished covering the principles of Swift's API Guidelines. In addition,
    I provided you with resources on how to find the Swift Evolution proposals that
    document the motivations for each change. We also covered new features to work
    with `#selector` and `#keyPath` expressions when working with Objective-C APIs
    in Swift. Finally, we explored working with C APIs and controlling how they are
    imported into Swift 3\. In the next chapter, we will cover more language changes.
    Stay tuned as we still a have a lot of new things to cover!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了Swift API指南原则的讲解。此外，我还提供了如何查找记录每个变更动机的Swift Evolution提案的资源。我们还涵盖了在Swift中使用Objective-C
    API时处理`#selector`和`#keyPath`表达式的全新功能。最后，我们探讨了如何与C API一起工作并控制它们如何导入到Swift 3中。在下一章中，我们将介绍更多的语言变更。请保持关注，因为我们还有很多新内容要介绍！
