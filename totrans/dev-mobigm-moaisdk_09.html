<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Real-world Physics with Box2D</h1></div></div></div><p>If you've already worked on games before, you should be familiar with Box2D. It's a multiplatform physics library that is broadly used across the gaming community. You'll find it really easy to work with it and get nice-looking physics pretty quickly, but this doesn't mean you have to create another <em>Angry Birds</em> clone, hint hint.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Creating the world</h1></div></div></div><p>The first step is to create the <a id="id215" class="indexterm"/>world that will be in charge of the physics simulation by following the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a file called <code class="literal">physics_manager.lua</code> and <code class="literal">require</code> it from <code class="literal">game.lua</code>.</li><li class="listitem">Now let's build the <code class="literal">PhysicsManager</code> module.<div><pre class="programlisting">module ( "PhysicsManager", package.seeall )
function PhysicsManager:initialize ( layer )</pre></div><div><ol class="orderedlist arabic"><li class="listitem">The first step is to create the <a id="id216" class="indexterm"/><code class="literal">MOAIBox2DWorld</code><code class="literal"> </code>object. This will take care of talking to Box2D from Moai SDK.<div><pre class="programlisting">        self.world = MOAIBox2DWorld.new ()</pre></div></li><li class="listitem">Then, we need to set up our scale. What we're doing here is saying that one meter on the simulation is equivalent to 38 points in our world coordinates. Since we're using a main character sprite that is 64 points tall, we can say that our character could be about 1.67 meters tall. So, 65 / 1.67 is about 38. That's the calculation needed in order to find that scale.<div><pre class="programlisting">        self.world:setUnitsToMeters ( 1/38 )</pre></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Box2D works better on simulations that contain bodies that go from 0.1 to 10 meters, so take that into account when setting this scale.</p></div></div></li><li class="listitem">Here we're setting the gravity. The parameter is how many meters per second in <code class="literal">x</code> and <code class="literal">y</code> our objects get affected. So, for this example, we're using a gravity that is similar to the one on Earth (which is -9.8 mts / (s * s), so we can safely use -10).<div><pre class="programlisting">        self.world:setGravity ( 0, -10 )</pre></div></li><li class="listitem">And finally we start the simulation:<div><pre class="programlisting">        self.world:start ()</pre></div></li><li class="listitem">Normally, we don't want to see the objects that Box2D creates on our screen; we just want them to be connected to our own rendered objects and make them behave according to the simulation. But, for debugging purposes, having the physics objects displayed <a id="id217" class="indexterm"/>on screen can be pretty handy. If you pass a layer to the <code class="literal">initialize</code> method, it will use it as a debug layer to display the objects you create on Box2D. You'll see the actual shapes of the physics objects, and their colors will change when they collide with each other.<div><pre class="programlisting">            if layer then
                layer:setBox2DWorld ( self.world )
            end
        end</pre></div></li></ol></div></li></ol></div><p>That's it. We have our world working! Now it's time to have a little talk about bodies.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Box2D body types</h1></div></div></div><p>The whole point of using a physics engine is to create a world where you put objects (bodies) that behave according to physics laws. The term <code class="literal">body</code> is highly based on physics literature, where all the objects that <a id="id218" class="indexterm"/>interact are called bodies.</p><p>There are three types of bodies in Box2D: static, kinematic, and dynamic. They are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Static bodies</strong>: You can think <a id="id219" class="indexterm"/><a id="id220" class="indexterm"/>of these as bodies that are fixed to the world. They don't move on their own, and they are not affected by gravity or collisions. Keep in mind that static bodies are able to collide with other objects, but they will not move or change as a result of the collision, just as the other objects (if they're not static). We'll use static bodies as platforms in our game, for our player to stand on.</li><li class="listitem" style="list-style-type: disc"><strong>Kinematic bodies</strong>: These <a id="id221" class="indexterm"/><a id="id222" class="indexterm"/>bodies are not affected by collisions or gravity either, but they can move on their own. They can affect other objects during collisions, as statics bodies do. A simple moving platform hazard should probably be implemented using a kinematic body.</li><li class="listitem" style="list-style-type: disc"><strong>Dynamic bodies</strong>: These are affected by <a id="id223" class="indexterm"/><a id="id224" class="indexterm"/>gravity, collisions, and can move on their own. We'll be using these to make our character and enemies move and collide. You can always set these bodies to ignore some force effects.</li></ul></div><p>Now that we know a little bit more about bodies, let's add the floor to our game.</p><div><ol class="orderedlist arabic"><li class="listitem">In order to do this, append the <a id="id225" class="indexterm"/>following code to <code class="literal">World:initialize()</code>.</li><li class="listitem">Here we create a static body using <code class="literal">addBody</code> from <code class="literal">MOAIBox2DWorld</code>. We then use the method <code class="literal">setTransform</code> to place it. We center it in the <code class="literal">X</code> axis and place it at the bottom of the screen in the <code class="literal">Y</code> axis.<div><pre class="programlisting">    self.floor = {}
    self.floor.body = self.world:addBody ( MOAIBox2DBody.STATIC )
    self.floor.body:setTransform ( 0, -WORLD_RESOLUTION_Y/2 )</pre></div></li><li class="listitem">After this we need to define the shape of the object (called fixture in the context of Box2D). We can use multiple kinds of shapes, and even combine them to create objects that are more complex. In this example, we're creating a rectangular object that has a width equal to the screen size and height equal to 100. The way we define these rectangles follows the convention of the rectangles on images, with the center at <code class="literal">(0,0)</code> on model coordinates.<div><pre class="programlisting">    self.floor.fixture = self.floor.body:addRect (
    -WORLD_RESOLUTION_X/2, -50, 
    WORLD_RESOLUTION_X/2, 50 )</pre></div></li><li class="listitem">Then we define that we don't want friction on the floor. This will stop our player from slowing down when running.<div><pre class="programlisting">    self.floor.fixture:setFriction ( 0 )</pre></div></li></ol></div><p>Now we need to initialize our world in <code class="literal">game.lua</code> in order to render something to the screen. Just copy the following code below the call to <code class="literal">loadBackground</code>:</p><div><pre class="programlisting">    PhysicsManager:initialize ( self.layers.walkBehind )</pre></div><p>What we're doing here is using the <code class="literal">walkBehind</code> layer as a parameter for debugging purposes. If you don't want to see the objects that are created, just avoid passing the layer and you won't see them.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Now run the game and you should see a box in the bottom. That's our floor.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Character versus the world</h1></div></div></div><p>Now we want to make the main character interact with our world.</p><p>We'll add some new <a id="id226" class="indexterm"/>methods to the <code class="literal">Character</code> module as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">First we create an object to store our body and shapes as follows:<div><pre class="programlisting">function Character:initializePhysics ()
    self.physics = {}</pre></div></li><li class="listitem">Then we add a dynamic body to the physics simulation. This will be the body of our character as follows:<div><pre class="programlisting">    self.physics.body = 
    PhysicsManager.world:addBody ( MOAIBox2DBody.DYNAMIC )</pre></div></li><li class="listitem">Now we position the body using the same initial position that we used for our rendered character as follows:<div><pre class="programlisting">    self.physics.body:setTransform (
    unpack(character_object.position) )</pre></div></li><li class="listitem">Now we add a shape. We'll use a square that's the same size as the sprite (64 x 64 ). This is obviously far from ideal, because collisions may seem strange in some cases (it will feel like there was a transparent box around him), but in order to keep it simple, we can live with that.<div><pre class="programlisting">    self.physics.fixture = self.physics.body:addRect( -32, -32, 32, 32 )</pre></div><div><img src="img/5064_09_01.jpg" alt="Character versus the world"/></div></li><li class="listitem">In the preceding image, we see the character and a platform with the Box2D debug on them. We can see that the player should be falling, but it doesn't because its box is too big.<div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>You may want to create a better shape in your final game, in order to have better collision detection, but keep in mind that if the collision shape is more complex, it'll need more calculations when colliding. Always try to minimize the amount of vertices and edges of your fixtures.</p></div></div></li><li class="listitem">The last step is to bind our <code class="literal">prop</code> with our <code class="literal">body</code>. To do so, we'll use the <code class="literal">setParent</code> method, <a id="id227" class="indexterm"/>which tells the Action Tree that the physics body affects the <code class="literal">prop</code> when moving. This is a great example demonstrating the power of the Action Tree.<div><pre class="programlisting">    self.prop:setParent ( self.physics.body )
end</pre></div></li></ol></div><p>If you hit play now, the character should be falling due to gravity.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Movement</h1></div></div></div><p>Now let's get right into the important stuff. First we'll define a couple of methods on <code class="literal">Character</code>. Then we'll rebuild <a id="id228" class="indexterm"/>
<code class="literal">InputManager</code> to handle key events instead of mouse events and integrate that with our game.</p><div><ol class="orderedlist arabic"><li class="listitem">The first method we're going to use will make our character run. It will be called when we press the <em>A</em> or <em>D</em> keys, moving left or right respectively. We'll pass it two parameters, <code class="literal">direction</code> (<code class="literal">-1</code> for left, <code class="literal">1</code> for right) and <code class="literal">keyDown</code>, which is a Boolean value that tells us if the player is pressing the key.</li><li class="listitem">The first thing we do is use the <code class="literal">direction</code> parameter in combination with <code class="literal">setScl</code> (used to scale objects). The idea is that if you scale a sprite by a negative factor, it flips in the direction of the scaled component, so what we're doing here is telling our sprite to face left or right according to what key the player pressed.<div><pre class="programlisting">function Character:run ( direction, keyDown )
    if keyDown then
    self.prop:setScl ( direction, 1 )</pre></div></li><li class="listitem">Then, we force the linear velocity by 100 in the specified direction and keep the velocity on the vertical axis, since we want to be able to jump and move while jumping:<div><pre class="programlisting">    velX, velY = self.physics.body:getLinearVelocity ()
    self.physics.body:setLinearVelocity ( direction * 100, velY )</pre></div></li><li class="listitem">Then if we're not already running and we're not jumping, we start the run animation as following:<div><pre class="programlisting">   if(self.currentAnimation ~= self:getAnimation ( 'run' ) )and not self.jumping then
        self:startAnimation('run')
    end</pre></div></li><li class="listitem">If this event was <code class="literal">keyUp</code> and we were not jumping, then stop moving. This is buggy, you should have a better logic here that keeps the state of the different keys, but to keep it simple we can live with it. And that's it, our <code class="literal">Character</code> can now run:<div><pre class="programlisting">    else
    if not self.jumping then
        self:stopMoving ()
    end
    end
end</pre></div></li><li class="listitem">The two methods are really simple. <a id="id229" class="indexterm"/>If we move left, we call run with <code class="literal">-1</code> as the direction; if we move right, we call run with <code class="literal">1</code> as the direction. In either case, we pass the <code class="literal">keyDown</code><a id="id230" class="indexterm"/> we receive. This <code class="literal">keyDown</code> will be obtained from the <code class="literal">InputManager</code> later.<div><pre class="programlisting">function Character:moveLeft ( keyDown )
    self:run ( -1, keyDown )
end
function Character:moveRight( keyDown )
    self:run ( 1, keyDown )
end</pre></div></li><li class="listitem">What we do to stop moving is (after checking that we're not jumping) stop all the movement, setting the linear velocity to 0 in both directions and start the idle animation. This is pretty simple:<div><pre class="programlisting">function Character:stopMoving ()
    if not self.jumping then
        self.physics.body:setLinearVelocity ( 0, 0 )
        self:startAnimation ( 'idle' )
    end
end</pre></div></li><li class="listitem">For the jump, we're going to do something different. Instead of forcing the linear velocity, we'll apply a force. We could do this in the same way, but just in order to illustrate how to apply forces, we'll use it here. Then we set a variable called jumping to true; this will allow us to know that we're jumping, and finally start the jump animation. This is easy as well.<div><pre class="programlisting">function Character:jump ( keyDown )
    if keyDown and not self.jumping then
        self.physics.body:applyForce ( 0, 8000 )
        self.jumping = true
        self:startAnimation ( 'jump' )
    end
end</pre></div></li><li class="listitem">Finally, we'll implement the <code class="literal">stopJumping</code> method. We basically set jumping to false and stop moving as follows:<div><pre class="programlisting">function Character:stopJumping ()
    self.jumping = false
    self:stopMoving ()
end</pre></div></li><li class="listitem">Our last method will be the one used to handle collisions with the floor. In order to use it, we need to add a line to <code class="literal">initializePhysics</code>.</li><li class="listitem">What we're doing now is setting up a <code class="literal">callback</code> method that will be executed when Box2D detects a collision with the player's shape. The parameters are the method itself, and which phase of the collision it should be called in is defined as following:<div><pre class="programlisting">self.physics.fixture:setCollisionHandler (
    onCollide, 
    MOAIBox2DArbiter.BEGIN )</pre></div><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>To check all the collision phases, take a look at the <code class="literal">setCollisionHandler</code> definition at <a class="ulink" href="http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20">http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20</a>.</p></div></div><p>Now we need to create the <code class="literal">callback</code> <a id="id231" class="indexterm"/>method:</p></li><li class="listitem">What we do now is check that the shape that we're colliding with is the floor, if it is, then we stop jumping as follow:<div><pre class="programlisting">function onCollide ( phase, fixtureA, fixtureB, arbiter )
    if fixtureB == PhysicsManager.floor.fixture then
        Character:stopJumping ()
    end
end</pre></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Keyboard input</h1></div></div></div><p>We'll have to change a couple of things <a id="id232" class="indexterm"/>in order to start using the keyboard:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, we need to remove our <a id="id233" class="indexterm"/><code class="literal">processInput</code> method and the call to on <code class="literal">Game:start</code> in <code class="literal">game.lua</code>.</li><li class="listitem">Then we need to create a method that will be in charge of managing the key input from <code class="literal">InputManager</code>.<div><pre class="programlisting">function Game:keyPressed ( key, down )
    if key == 'right' then Character:moveRight(down)end
    if key == 'left' then Character:moveLeft(down)end
    if key == 'up' then Character:jump(down)end
end</pre></div><p>This method maps some key presses with the methods we created on <code class="literal">Character</code>. This should be enough to handle the movement of our character.</p></li><li class="listitem">Now, we'll have to remove all the code (except the module definition) from <code class="literal">input_manager.lua</code> and rewrite it using the following code:<div><pre class="programlisting">function InputManager:initialize ()
    function onKeyboardEvent ( key, down )
        if key == 119 then key = 'up' end
        if key == 97 then key = 'left' end
        if key == 100 then key = 'right' end
        Game:keyPressed(key, down)
    end</pre></div><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">onKeyboardEvent</code> will be our keyboard callback. What we do here is just use the key code of <em>A</em>, <em>D</em>, and <em>W</em>, replace them with a readable string, and pass them as parameters to <code class="literal">keyPressed</code>, the method we implemented previously.<div><pre class="programlisting">    MOAIInputMgr.device.keyboard:setCallback( onKeyboardEvent )
end</pre></div></li><li class="listitem">Now it's only a matter of setting the callback and we're done.</li></ol></div></li><li class="listitem">Try running the game now. You should be able to move the character around and jump using <em>A</em>, <em>D</em>, and <em>W</em>.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Creating the scene</h1></div></div></div><p>We'll now create the necessary <a id="id234" class="indexterm"/>code to define a level. We won't be messing with sprites for it; instead we'll just use the default debug shapes from Box2D. We'll create the entire physical world, and you should now be able to assign sprites to it (it's the same as what we did with the player).</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, we need to remove all the code that relates to the floor definition in <code class="literal">physics_manager.lua</code>, since now we'll be creating the floor with the rest of the platforms.</li><li class="listitem">Now, on <code class="literal">game.lua</code>, just below the <code class="literal">background_objects</code> definitions, we'll create a definition for the scene:<div><pre class="programlisting">local scene_objects = {
    floor = {
        type = MOAIBox2DBody.STATIC,
        position = {0, -WORLD_RESOLUTION_Y/2},
        friction = 0,
        size = {2 * WORLD_RESOLUTION_X, 10}
    }
    platform1 = {
        type = MOAIBox2DBody.STATIC,
        position = {100, -50},
        friction = 0,
        size = {100, 20}
    }
}</pre></div></li><li class="listitem">As you may see in the given code, we're defining two objects, namely, a floor and a platform. To each object we define its body type, its position, and size. Note that the floor is now just another scene object.</li><li class="listitem">We're now going to iterate through that table and create all the objects in one single piece of code:<div><pre class="programlisting">function Game:loadScene()
    self.objects = {}
    for key, attr in pairs(scene_objects)do</pre></div><div><ol class="orderedlist arabic"><li class="listitem">We start iterating through all the <code class="literal">scene_objects</code>:<div><pre class="programlisting">    local body = PhysicsManager.world:addBody(attr.type)</pre></div></li><li class="listitem">Here we create the Box2D body, using the type in the definition:<div><pre class="programlisting">    body:setTransform ( unpack(attr.position) );
    width, height = unpack ( attr.size );
    local fixture = body:addRect (
    -width/2, -height/2, width/2, height/2 )</pre></div></li><li class="listitem">Then we set the size and position.<div><pre class="programlisting">    fixture:setFriction ( attr.friction )</pre></div></li><li class="listitem">And finally the friction.<div><pre class="programlisting">    self.objects[key] = { body = body, fixture = fixture }
    end
end</pre></div></li><li class="listitem">Then we store the object under the defined name and we're done.</li></ol></div></li></ol></div><p>If you wish to add more stuff to the definitions (such as the vertices for a polygon shape, or something like that), it should be only a matter of deciding how to represent that in the definition and adding the necessary method calls to meet that definition inside <code class="literal">loadScene</code>.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>Currently, only eight vertices are supported. You can modify Moai SDK's source code to add more.</p></div></div><div><ol class="orderedlist arabic"><li class="listitem">Below the <code class="literal">PhysicsManager</code> initialization on <code class="literal">Game:initialize</code>, you should add a call to <code class="literal">loadScene</code>.<div><pre class="programlisting">    self:loadScene ()</pre></div></li><li class="listitem">There is one more thing <a id="id235" class="indexterm"/>that we need to do now and that's fix our <code class="literal">collision</code> method that was using the hardcoded floor.<div><ol class="orderedlist arabic"><li class="listitem">First we need another auxiliary method in <code class="literal">game.lua</code>:<div><pre class="programlisting">function Game:belongsToScene ( fixture )
    for key, object in pairs (self.objects )do
        if object.fixture == fixture then
            return true
        end
    end
    return false
end</pre></div></li><li class="listitem">In this method, we iterate through all the scene objects and see if the one passed as a parameter is one of them.</li><li class="listitem">Open <code class="literal">character.lua</code> and replace <code class="literal">onCollide</code> with the new version:<div><pre class="programlisting">function onCollide ( phase, fixtureA, fixtureB, arbiter )
    if Game:belongsToScene ( fixtureB ) then
        Character:stopJumping ()
    end
end</pre></div></li></ol></div></li><li class="listitem">What we do here is call the auxiliary method when a collision occurs in order to see if we're colliding with an object from the scene. In that case, we stop jumping. This will make a funny mechanic; run the game and you'll see why (Super Meat Boy? Anybody? Ok, when you collide with a vertical edge of a box, the player stops, allowing you to jump again!).</li></ol></div><p>The way we created this scene is decoupled from the code that actually loads it. In the real world, you will want to be able to edit your levels externally and then load them in code.</p><p>The loading code will behave mostly <a id="id236" class="indexterm"/>in the same way as in this case, but you'll probably use another language (XML, JSON, and so on) to store your levels. Level Editors are your friends.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Do you know <a id="id237" class="indexterm"/>
<strong>Inkscape</strong>? It's a vector graphics editor that uses SVG as the main format. SVG is XML! So it is highly parsable. By the way, it's open source and free. Another useful open source tool if you're working with tiles is <strong>Tiled</strong>, which will be really useful to create your maps, as it includes layers, tilemap support, and exports to Lua.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Exercises</h1></div></div></div><p>Adding enemies to this scene should be familiar to you by now. You'll need to think about the artificial intelligence for the movement, but other than that, everything else has have already been seen. You should create it as a dynamic body, and modify the player collision handler in order to react properly (killing the player for example, or taking life from it).</p><p>Another great idea would be to implement Mario-style platforms where you can jump up through the bottom of a platform and then collide and stay on top. (You'll have to use Box2D's sensors and check the normal of collision in the collision handler. Then, based on the collision normal, only stop movement at the appropriate time).</p><p>Play around a bit with this, since playing is a big part of the learning process.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Summary</h1></div></div></div><p>In this chapter, you might have  felt like Newton. We did some experiments with Box2D in order to build the physics of our platformer prototype. We saw how to use the keyboard and make our character animate and move using the input from the user and collisions.</p><p>The next chapter will take care of showing some debug data to illustrate how to create HUDs.</p></div></body></html>