- en: Ranges, Progressions, and Sequences
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围、进度和序列
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Exploring the use of range expressions to iterate through alphabet characters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用范围表达式遍历字母字符
- en: Traversing through ranges using progression with a custom step value
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义步长值的进度遍历范围
- en: Building custom progressions to traverse dates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义进度来遍历日期
- en: Using range expressions with flow control statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用范围表达式与流程控制语句
- en: Discovering the concept of sequences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现序列的概念
- en: Applying sequences to solve algorithmic problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将序列应用于解决算法问题
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will focus on explaining the advantages of **range expressions**
    and **sequences**. These powerful data structure concepts offered by the Kotlin
    standard library can help you to improve the quality and readability of your code,
    as well as its safety and performance. Range expressions provide a declarative
    way of iterating through sets of comparable types using `for` loops. They are
    also useful for implementing concise and safe control flow statements and conditions.
    The `Sequence` class, as a missing supplement to the `Collection` type, provides
    a built-in lazy evaluation of its elements. In many cases, using sequences can
    help optimize data-processing operations and make the code more efficient in terms
    of computation complexity and memory consumption. The recipes covered in this
    chapter are going to focus on solving real-life programming problems. Moreover,
    at the same time, they are also going to explain how those concepts work under
    the hood.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点解释**范围表达式**和**序列**的优势。Kotlin标准库提供的这些强大的数据结构概念可以帮助您提高代码的质量和可读性，以及其安全性和性能。范围表达式提供了一种声明性的方式，通过`for`循环迭代可比较类型的集合。它们对于实现简洁和安全的控制流语句和条件也非常有用。`Sequence`类作为`Collection`类型的补充，提供了其元素的内置惰性求值。在许多情况下，使用序列可以帮助优化数据处理操作，并在计算复杂度和内存消耗方面使代码更加高效。本章涵盖的食谱将专注于解决现实生活中的编程问题。此外，同时，它们还将解释这些概念在底层是如何工作的。
- en: Exploring the use of range expressions to iterate through alphabet characters
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用范围表达式遍历字母字符
- en: 'Ranges, provided by the Kotlin standard library, are a powerful solution for
    implementing iteration and conditional statements in a natural and safe way. A
    range can be understood as an abstract data type that represents a set of iterable
    elements and allows iteration through them in a declarative way. The `ClosedRange` interface
    from the `kotlin.ranges` package is a basic model of the range data structure.
    It contains references to the first and last elements of the range and provides
    the `contains(value: T): Boolean` and `isEmpty(): Boolean` functions, which are
    responsible for checking whether the specified element belongs to the range and
    whether the range is empty. In this recipe, we are going to learn how to declare
    a range that consists of alphabet characters and iterate through it in a decreasing
    order.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kotlin标准库提供的范围是一个强大的解决方案，用于以自然和安全的方式实现迭代和条件语句。范围可以被理解为一种抽象数据类型，它表示一组可迭代的元素，并允许以声明性的方式遍历它们。来自`kotlin.ranges`包的`ClosedRange`接口是范围数据结构的基本模型。它包含对范围首尾元素的引用，并提供`contains(value:
    T): Boolean`和`isEmpty(): Boolean`函数，这些函数负责检查指定元素是否属于范围以及范围是否为空。在本食谱中，我们将学习如何声明一个由字母字符组成的范围，并以降序遍历它。'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Kotlin standard library provides functions that allow the declaration of
    ranges for the integral, primitive types, such as `Int`, `Long`, and `Char`. To
    define a new range instance, we can use the `rangeTo()` function. For example,
    we can declare a range of integers from `0` to `1000` in the following way:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了允许声明整数、原始类型（如`Int`、`Long`和`Char`）范围的函数。要定义一个新的范围实例，我们可以使用`rangeTo()`函数。例如，我们可以以下这种方式声明一个从`0`到`1000`的整数范围：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `rangeTo()` function has also its own special operator equivalent, `..`,
    which allows the declaration of a range with a more natural syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`rangeTo()`函数也有其自己的特殊运算符等价物，即`..`，它允许使用更自然的语法声明一个范围：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, in order to declare a range of elements in a decreasing order, we can
    use the `downTo()` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了以降序声明一系列元素，我们可以使用`downTo()`函数。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Declare a decreasing range of alphabet characters:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明字母字符的降序范围：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '2\. Create a `for` loop to traverse the range:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建一个`for`循环来遍历范围：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, we are going to get the following code printed out to the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下代码打印到控制台：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, there is also a `downTo()` extension function variant for the `Char`
    type. We are using it to create a range of characters from `Z`to `A`. Note that,
    thanks for the infix notation, we can omit the brackets while invoking the function—`'Z'
    downTo 'A'`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，还有`downTo()`扩展函数变体用于`Char`类型。我们使用它来创建从`Z`到`A`的字符范围。请注意，多亏了内联表示法，我们可以在调用函数时省略括号——`'Z'
    downTo 'A'`。
- en: Next, we are creating a `for` loop, which iterates through the range and prints
    out the subsequent `Char` elements. Using the `in` operator, we are specifying
    the object that is being iterated in the loop—and that's it! As you can see, the
    Kotlin syntax for the `for` loop is neat and natural to use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`for`循环，它遍历范围并打印出后续的`Char`元素。使用`in`运算符，我们指定了循环中正在迭代的对象——就是这样！正如你所见，Kotlin中`for`循环的语法整洁且易于使用。
- en: Implementations of ranges of the primitive types, such as `IntRange`, `LongRange`,
    and `CharRange`, also contain `Iterator` interface implementations under the hood.
    They are being used while traversing the range using the `for` loop under the
    hood. In fact, the range implementing the `Iterable` interface is called a **progression**.
    Under the hood, the `IntRange`, `LongRange`, and `CharRange` classes inherit from
    the `IntProgression`, `LongProgression`, and `CharProgression` base classes, and
    they provide the implementations of the `Iterator` interface internally.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型范围实现，如`IntRange`、`LongRange`和`CharRange`，在底层也包含`Iterator`接口实现。在底层使用`for`循环遍历范围时，它们被使用。实际上，实现`Iterable`接口的范围被称为**进度**。在底层，`IntRange`、`LongRange`和`CharRange`类从`IntProgression`、`LongProgression`和`CharProgression`基类继承，并内部提供`Iterator`接口的实现。
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'There is also a convenient way to reverse the order of an already-defined progression.
    We can do so with the extension function provided for the `IntProgression`, `LongProgression`,
    and `CharProgression` types, which is called `reversed()`. It returns new instances
    of progressions with a reversed order of elements. Here is an example of how to
    use the `reversed()` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方便的方法可以反转已定义进度的顺序。我们可以使用为`IntProgression`、`LongProgression`和`CharProgression`类型提供的扩展函数`reversed()`来实现这一点。它返回具有元素顺序反转的新进度实例。以下是如何使用`reversed()`函数的示例：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding `for` loop prints the following text to the console:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`for`循环将以下文本打印到控制台：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Kotlin standard library offers also another handy extension function called
    `until()`, which allows the declaration of ranges that don''t include the last
    element. It is pretty useful when working with classes that contain internal collections
    and don''t provide elegant interfaces to access them. A good example would be
    the Android `ViewGroup` class, which is a container for the child `View` type
    objects. The following example presents how to iterate through the next indexes
    of any given `ViewGroup` instance children in order to modify the state of each
    of the children:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库还提供了一个名为`until()`的便捷扩展函数，它允许声明不包含最后一个元素的范围。当与包含内部集合且不提供优雅接口访问它们的类一起工作时，这非常有用。一个很好的例子是Android的`ViewGroup`类，它是一个用于子`View`类型对象的容器。以下示例展示了如何遍历任何给定`ViewGroup`实例子元素的下一个索引，以修改每个子元素的状态：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `until()` infix function helps to make the loop conditions clean and natural
    to understand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`until()`内联函数有助于使循环条件清晰且易于理解。'
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: This recipe gave us an insight into how Kotlin standard library implementations
    of ranges for primitives are easy to work with. A problem can appear if we want
    to traverse non-primitive types using the `for` loop. However, it turns out we
    can easily declare a range for any `Comparable` type. This will be shown in the
    *Building custom progressions to traverse dates* recipe.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方让我们了解了Kotlin标准库对原始类型范围实现的易用性。如果我们想使用`for`循环遍历非原始类型，可能会出现一个问题。然而，我们很容易为任何`Comparable`类型声明一个范围。这将在*构建自定义进度以遍历日期*配方中展示。
- en: As you have noticed, we are using the `in` operator to specify the object that
    is being iterated in the loop. However, there are also other scenarios where the
    `in` and `!in` operators can be used together with ranges. We will investigate
    them in depth in the *Using range expressions with flow control statements* recipe.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们使用`in`运算符来指定循环中正在迭代的对象。然而，还有其他场景中，`in`和`!in`运算符可以与范围一起使用。我们将在*使用范围表达式与流程控制语句*菜谱中深入探讨它们。
- en: Traversing through ranges using progression with a custom step value
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义步长值遍历范围
- en: Besides doing so for the `Iterator` instances, progressions implementations
    for integral types, such as the `Int`, `Long`, and `Char` types, also include
    the `step` property. The `step` value specifies the intervals between the subsequent
    elements of a range. By default, the `step` value of a progression is equal to
    `1`. In this recipe, we are going to learn how to traverse a range of alphabet
    characters with a `step` value equal to `2`. In the result, we want to have every
    second alphabet letter printed to the console.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对`Iterator`实例这样做之外，对于整型类型（如`Int`、`Long`和`Char`类型）的进度实现也包括`step`属性。`step`值指定了范围后续元素之间的间隔。默认情况下，进度的`step`值等于`1`。在本例中，我们将学习如何使用`step`值等于`2`遍历字母字符的范围。在结果中，我们希望每第二个字母字符被打印到控制台。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Kotlin standard library provides a convenient way of creating progression
    with a custom `step` value. We can do so using an extension function for progressions
    of integral types called `step()`. We can also benefit from the infix notation
    and declare a progression with a custom `step`, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了一个方便的方法来创建具有自定义`step`值的进度。我们可以使用名为`step()`的进度整型类型的扩展函数来实现这一点。我们还可以利用中缀表示法，如下声明具有自定义`step`的进度：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we were to use `progression` in the `for` loop, it would iterate 10 times:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`for`循环中使用`progression`，它将迭代10次：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could also achieve the same result by iterating with the `while` loop, as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过以下方式使用`while`循环达到相同的结果：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Declare a range of the `Char` type using the `downTo()`function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`downTo()`函数声明一个`Char`类型的范围：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Convert the range to a progression with a custom `step` value using the `step()`
    function:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`step()`函数将范围转换为具有自定义`step`值的进度：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the `forEach()`function to iterate through the elements of the progression
    and print each of them to the console:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach()`函数遍历进度的元素，并将每个元素打印到控制台：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the result, we are going to get the following code printed to the console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，我们将得到以下代码打印到控制台：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the beginning, we declared a range containing all the alphabet characters
    in decreasing order with the `downTo()`function. Then, we transformed the range
    a the custom progression containing every second character with the `step()` function.
    Finally, we are using the `Iterable.forEach()`function to iterate through the
    next elements of the progression and print each of them to the console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们使用`downTo()`函数声明了一个包含所有字母字符的降序范围的变量。然后，我们使用`step()`函数将范围转换为包含每个第二个字符的自定义进度。最后，我们使用`Iterable.forEach()`函数遍历进度的下一个元素，并将每个元素打印到控制台。
- en: The `step()` extension function is available for the `IntProgression`, `LongProgression`,
    and `CharProgression` types. Under the hood, it creates a new instance of a progression
    copying the properties of the original one and setting up the new `step` value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`step()`扩展函数适用于`IntProgression`、`LongProgression`和`CharProgression`类型。在内部，它创建一个进度的新实例，复制原始进度的属性，并设置新的`step`值。'
- en: See also
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Apart from iteration, range expressions are useful for defining flow control
    conditions. You can read more about this in the *Using range expressions with
    flow control statements* recipe.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了迭代之外，范围表达式对于定义流程控制条件也很有用。你可以在*使用范围表达式与流程控制语句*菜谱中了解更多信息。
- en: Building custom progressions to traverse dates
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用于遍历日期的自定义进度
- en: Kotlin provides built-in support for ranges of primitive types. In the previous
    recipes, we worked with the `IntRange` and `CharRange` types, which are included
    in the Kotlin standard library. However, it is possible to implement a custom
    progression for any type by implementing the `Comparable` interface. In this recipe,
    we will learn how to create a progression of the `LocalDate` type and discover
    how to traverse the dates the easy way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为原始类型的范围提供了内置支持。在之前的菜谱中，我们使用了`IntRange`和`CharRange`类型，这些类型包含在Kotlin标准库中。然而，通过实现`Comparable`接口，我们可以为任何类型实现自定义的递增。在这个菜谱中，我们将学习如何创建`LocalDate`类型的递增，并了解如何轻松地遍历日期。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to accomplish the task, we need to start by getting familiar with
    the `ClosedRange` and `Iterator` interfaces. We need to use them to declare a
    custom progression for the `LocalDate` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成任务，我们首先需要熟悉`ClosedRange`和`Iterator`接口。我们需要使用它们来为`LocalDate`类声明一个自定义的递增：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Iterator` interface provides information about the subsequent values and
    their availability:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`接口提供了关于后续值及其可用性的信息：'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ClosedRange` interface provides the minimum and maximum values of the
    range. It also provides the `contains(value: T): Boolean` and `isEmpty(): Boolean`
    functions, which check whether a given value belongs to the range and whether
    the range is empty respectively. Those two functions have default implementations
    provided in the `ClosedRange` interface. As the result, we don''t need to override
    them in our custom implementation of the `ClosedRange` interface.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosedRange`接口提供了范围的最低值和最高值。它还提供了`contains(value: T): Boolean`和`isEmpty():
    Boolean`函数，分别检查给定值是否属于范围以及范围是否为空。这两个函数在`ClosedRange`接口中提供了默认实现。因此，我们不需要在我们的自定义`ClosedRange`接口实现中重写它们。'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s start with implementing the `Iterator` interface for the `LocalDate`
    type. We are going to create a custom `LocalDateIterator` class, which implements
    the `Iterator<LocalDate>` interface:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从为`LocalDate`类型实现`Iterator`接口开始。我们将创建一个自定义的`LocalDateIterator`类，该类将实现`Iterator<LocalDate>`接口：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can implement the progression for the `LocalDate` type. Let''s create
    a new class called `DateProgression`, which is going to implement the `Iterable<LocalDate>`
    and `ClosedRange<LocalDate>` interfaces:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`LocalDate`类型的递增。让我们创建一个新的类，称为`DateProgression`，它将实现`Iterable<LocalDate>`和`ClosedRange<LocalDate>`接口：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, declare a custom `rangeTo` operator for the `LocalDate` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为`LocalDate`类声明一个自定义的`rangeTo`操作符：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Now, we are able to declare range expressions for the `LocalDate` type. Let''s
    see how to use our implementation. In the following example, we will use our custom
    `LocalDate.rangeTo` operator implementation in order to create a range of dates
    and iterate its elements:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够为`LocalDate`类型声明范围表达式。让我们看看如何使用我们的实现。在下面的示例中，我们将使用我们自定义的`LocalDate.rangeTo`操作符实现来创建一个日期范围并迭代其元素：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a result, we are going to have the dates printed out to the console with
    a week-long interval:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将以一周为间隔将日期打印到控制台：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `DateIterator` class holds three properties—`currentDate: LocalDate`, `endDateInclusive:
    LocalDate`, and `stepDays: Long`. In the beginning, the `currentDate` property
    is initialized with the `startDate` value passed in the constructor. Inside the
    `next()` function, we are returning the `currentDate` value and updating it to
    the next date value using a given `stepDays` property interval.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateIterator`类包含三个属性——`currentDate: LocalDate`、`endDateInclusive: LocalDate`和`stepDays:
    Long`。一开始，`currentDate`属性使用构造函数中传入的`startDate`值初始化。在`next()`函数内部，我们返回`currentDate`值，并使用给定的`stepDays`属性间隔将其更新到下一个日期值。'
- en: The `DateProgression` class combines the functionalities of the `Iterable<LocalDate>`
    and `ClosedRange<LocalDate>` interfaces. It provides the `Iterator` object required
    by the `Iterable` interface by returning the `DateIterator` instance. It also
    overrides the `start` and `endInclusive` properties of the `ClosedRange` interface.
    There is also the `stepDays` property with a default value equal to `1`. Note
    that every time the `step` function is called, a new instance of the `DateProgression` class
    is being created.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateProgression` 类结合了 `Iterable<LocalDate>` 和 `ClosedRange<LocalDate>` 接口的特性。它通过返回
    `DateIterator` 实例来提供 `Iterable` 接口所需的 `Iterator` 对象。它还重写了 `ClosedRange` 接口的 `start`
    和 `endInclusive` 属性。还有一个默认值为 `1` 的 `stepDays` 属性。请注意，每次调用 `step` 函数时，都会创建一个新的
    `DateProgression` 类实例。'
- en: You can follow the same pattern to implement custom progressions for any class
    that implements the `Comparable` interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的模式为任何实现 `Comparable` 接口的类实现自定义序列。
- en: Using range expressions with flow control statements
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围表达式与流程控制语句
- en: Apart from iterations, Kotlin range expressions can be useful when it comes
    to working with flow control statements. In this recipe, we are going to learn
    how to use range expressions together with `if` and `when` statements in order
    to tune up the code and make it safe. In this recipe, we are going to consider an
    example of using the `in` operator to define a condition of an `if` statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迭代之外，当涉及到使用流程控制语句时，Kotlin 范围表达式可能非常有用。在本食谱中，我们将学习如何将范围表达式与 `if` 和 `when` 语句一起使用，以优化代码并使其更安全。在本食谱中，我们将考虑使用
    `in` 操作符来定义 `if` 语句条件的示例。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Kotlin range expressions—represented by the `ClosedRange` interface—implement
    a `contains(value: T): Boolean` function, which returns an information if a given
    parameter belongs to the range. This feature makes it convenient to use ranges
    together with control flow instructions. The `contains()` function has also its
    equivalent operator, `in`, and its negation, `!in`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kotlin 范围表达式——由 `ClosedRange` 接口表示——实现了一个 `contains(value: T): Boolean` 函数，该函数返回一个信息，表明给定的参数是否属于该范围。这个特性使得将范围与控制流指令一起使用变得方便。`contains()`
    函数也有其等价的操作符 `in` 和其否定 `!in`。'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a variable and assign to it a random integer value:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个变量，并给它分配一个随机整数值：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can check whether the `randomInt` value belongs to the scope of integers
    from `0` to `10` inclusive using range expressions:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用范围表达式检查 `randomInt` 值是否属于从 `0` 到 `10`（包括 `10`）的整数范围：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We have used a range expression together with the `in` operator in order to
    define a condition for the `if` statement. The condition statement is natural to
    read and concise. In contrast, an equivalent classic implementation would look
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用范围表达式与 `in` 操作符一起定义了 `if` 语句的条件。条件语句易于阅读且简洁。相比之下，等效的经典实现可能看起来像这样：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: No doubt, the declarative approach using the range and `in` operator is cleaner
    and easier to read, compared to classic, imperative-style condition statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，使用范围和 `in` 操作符的声明式方法比经典的命令式条件语句更简洁、更容易阅读。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Range expressions can enhance use of the `when` expression as well. In the
    following example, we are going to implement a simple function that will be responsible
    for mapping a student''s exam score to a corresponding grade. Let''s say we have
    the following enum class model for student grades:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 范围表达式还可以增强 `when` 表达式的使用。在下面的示例中，我们将实现一个简单的函数，该函数将负责将学生的考试成绩映射到相应的等级。假设我们有以下用于学生等级的枚举类模型：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can define a function that will map the exam score value, in the `0` to
    `100` % range, to the proper grade (`A`, `B`, `C`, or `D`) using a `when` expression,
    as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个函数，将考试分数值（在 `0` 到 `100` % 范围内）映射到适当的等级（`A`、`B`、`C` 或 `D`），使用 `when`
    表达式，如下所示：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using ranges together with the `in` operator makes the implementation of the
    `computeGrade()` function much cleaner and more natural than the classic equivalent
    implementation using traditional comparison operators, such as `<`, `>`, `<=`,
    and `>=`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围与 `in` 操作符一起使用，使得 `computeGrade()` 函数的实现比使用传统的比较操作符（如 `<`、`>`、`<=` 和 `>=`）的经典等效实现更简洁、更自然。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you'd like to discover more about lambdas, the infix notation, and operator
    overloading, go ahead and dive into [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive
    Functions and Adjustable Interfaces*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于lambda表达式、内联表示法和运算符重载的信息，请继续阅读[第2章](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml)，*表达性函数和可调整接口*。
- en: Discovering the concept of sequences
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现序列的概念
- en: In terms of high-level functionalities, the `Sequence` and `Collection` data
    structures are nearly the same. They both allow iteration through their elements.
    There are also many powerful extension functions in the Kotlin standard library
    that provide declarative-style data-processing operations for each of them. However,
    the `Sequence` data structure behaves differently under the hood—it delays any
    operations on its elements until they are finally consumed. It instantiates the subsequent
    elements on the go while traversing through them. These characteristics of `Sequence`, called
    **lazy evaluation**, make this data structure quite similar to the Java concept,  `Stream`.  To
    understand all of this better, we are going to implement a simple data-processing
    scenario to analyze the efficiency and behavior of `Sequence` and contrast our
    findings with `Collection`-based implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级功能方面，`Sequence`和`Collection`数据结构几乎相同。它们都允许遍历它们的元素。Kotlin标准库中还有许多强大的扩展函数，为每个数据结构提供声明式数据处理的操作。然而，`Sequence`数据结构在底层的行为不同——它延迟对其元素的任何操作，直到它们最终被消费。它在遍历它们的同时实例化后续元素。`Sequence`的这些特性，称为**延迟评估**，使这种数据结构与Java概念`Stream`非常相似。为了更好地理解这一切，我们将实现一个简单的数据处理场景来分析`Sequence`的效率和行为，并将我们的发现与基于`Collection`的实现进行对比。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s consider the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the first line, we created a list of strings and assigned it to the `collection`
    variable. Next, we are applying the `map()`function to the list. Mapping operation
    allows us to transform each element of the collection and return a new value instead
    of the original one. In our case, we are using it just to observe that `map()`was
    invoked by printing the message to the console. Finally, we want to filter our
    collection to contain only the first two elements using the `take()`function and
    print the content of the list to the console.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个字符串列表并将其分配给`collection`变量。接下来，我们正在将`map()`函数应用于列表。映射操作允许我们转换集合中的每个元素，并返回一个新值而不是原始值。在我们的例子中，我们只是用它来观察是否调用了`map()`，通过向控制台打印消息。最后，我们想要使用`take()`函数过滤我们的集合，只包含前两个元素，并将列表的内容打印到控制台。
- en: 'In the end, the preceding code prints the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前面的代码将打印以下输出：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `map()`function was properly applied to every element of
    the collection and the `take()`function has properly filtered the elements of
    the list. However, it would not be an optimal implementation if we were working
    with a larger dataset. Preferably, we would like to wait with the execution of
    the data-processing operations until we know what specific elements of the dataset
    we really need, and then apply those operations only to those elements. It turns
    out that we can easily optimize our scenario using the `Sequence` data structure.
    Let's explore how to do it in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`map()`函数已正确应用于集合的每个元素，而`take()`函数已正确过滤了列表中的元素。然而，如果我们处理的是更大的数据集，这并不是一个最优的实现。我们最好等到我们知道数据集的哪些特定元素是我们真正需要的，然后再对这些元素应用这些操作。结果证明，我们可以很容易地使用`Sequence`数据结构来优化我们的场景。让我们在下一节中探讨如何实现它。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare a `Sequence` instance for the given elements:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为给定元素声明一个`Sequence`实例：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply the mapping operation to the elements of the sequence:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将映射操作应用于序列的元素：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Print the first two elements of the sequence to the console:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将序列的前两个元素打印到控制台：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Sequence`-based implementation is going to give us the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基于序列（`Sequence`）的实现将给出以下输出：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, replacing the `Collection` data structure with the `Sequence`
    type allows us to gain the desired optimization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用`Sequence`类型替换`Collection`数据结构使我们能够获得所需的优化。
- en: 'The scenario considered in this recipe was implemented identically—first, using
    `List`, then using the `Sequence` type. However, we can notice the difference
    in the behavior of the `Sequence` data structure compared to that of `Collection`.
    The `map()` function was applied only to the first two elements of the sequence,
    even though the `take()` function was called after the mapping transformation
    declaration. It''s also worth noting that in the example using `Collection`, the
    mapping was performed instantly when the `map()` function was invoked. In the
    case of `Sequence`, mapping was performed at the time of the evaluation of its
    elements while printing them to the console, and more precisely while converting
    `Sequence` to the `List` type with the following line of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中考虑的场景被实现得完全相同——首先使用`List`，然后使用`Sequence`类型。然而，我们可以注意到`Sequence`数据结构与`Collection`的行为差异。`map()`函数仅应用于序列的前两个元素，尽管在映射转换声明之后调用了`take()`函数。还值得注意的是，在使用`Collection`的示例中，当调用`map()`函数时，映射是立即执行的。在`Sequence`的情况下，映射是在将元素打印到控制台时进行的，更确切地说，是在将`Sequence`转换为以下代码行中的`List`类型时进行的：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: There is a convenient way of transforming `Collection` to `Sequence`*. *We can
    do so with the `asSequence()`extension function provided by the Kotlin standard
    library for the `Iterable` type. In order to convert a `Sequence`instance into
    a `Collection` instance*, *you can use the `toList()` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Collection`转换为`Sequence`有一种方便的方法。我们可以使用Kotlin标准库为`Iterable`类型提供的`asSequence()`扩展函数来完成此操作。要将`Sequence`实例转换为`Collection`实例，您可以使用`toList()`函数。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Thanks to the feature of `Sequence` lazy evaluation, we have avoided needless
    calculations, increasing the performance of the code at the same time. Lazy evaluation
    allows the implementation of sequences with a potentially infinite number of elements
    and turns out to be effective when implementing algorithms as well.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多亏了`Sequence`的延迟求值特性，我们避免了不必要的计算，同时提高了代码的性能。延迟求值允许实现具有无限元素数量的序列，并且在实现算法时也表现出有效性。
- en: You can explore a `Sequence`-based implementation of the Fibonacci algorithm
    in the *Applying sequences to solve algorithmic problems* recipe. It presents,
    in more detail, another useful function for defining sequences called `generateSequence()`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*将序列应用于解决算法问题*食谱中探索基于`Sequence`的斐波那契算法的实现。它更详细地介绍了另一个用于定义序列的有用函数，称为`generateSequence()`。
- en: Applying sequences to solve algorithmic problems
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将序列应用于解决算法问题
- en: In this recipe, we are going to get familiar with the `generateSequence()` function,
    which provides an easy way to define the various types of sequences. We will use
    it to implement an algorithm for generating Fibonacci numbers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将熟悉`generateSequence()`函数，该函数提供了一种轻松定义各种类型序列的方法。我们将使用它来实现生成斐波那契数的算法。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The basic variant of the `generateSequence()` function is declared as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateSequence()`函数的基本变体声明如下：'
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It takes one parameter called `nextFunction`, which is a function that returns
    the next elements of the sequence. Under the hood, it is being invoked by the `Iterator.next()`
    function, inside the `Sequence` class' internal implementation, and allows instantiation
    of the next object to be returned while consuming the sequence values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个名为`nextFunction`的参数，该参数是一个返回序列下一个元素的函数。在底层，它通过`Sequence`类内部实现中的`Iterator.next()`函数被调用，并允许在消耗序列值的同时实例化下一个要返回的对象。
- en: 'In the following example, we are going to implement a finite sequence that
    emits integers from `10` to `0`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将实现一个有限序列，该序列从`10`到`0`发出整数：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `takeIf()` function applied to the current `counter` value checks whether
    its value is greater or equal to `0`. If the condition is fulfilled, it returns
    the `counter` value; otherwise, it returns `null`. Whenever `null` is returned
    by the `generateSequence()` function, the sequence stops. After the `takeIf` function
    returns the value, the `counter` value is post-decremented. The preceding code
    will result in the following numbers being printed to the console:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到当前`counter`值的`takeIf()`函数检查其值是否大于或等于`0`。如果条件得到满足，它返回`counter`值；否则，它返回`null`。每当`generateSequence()`函数返回`null`时，序列停止。在`takeIf`函数返回值后，`counter`值将进行后递减。前面的代码将导致以下数字被打印到控制台：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The subsequent values of the Fibonacci sequence are generated by summing up
    their two preceding ones. Additionally, the two first values are equal to `0`
    and `1`. In order to implement such a sequence, we are going to use an extended
    variant of the `generateSequence()` function with an additional `seed` parameter,
    declared as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列的后续值是通过将它们的两个前一个值相加生成的。此外，前两个值等于 `0` 和 `1`。为了实现这样一个序列，我们将使用一个带有额外 `seed`
    参数的 `generateSequence()` 函数的扩展版本，声明如下：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare a function called `fibonacci()` and use the `generateSequence()` function
    to define a formula for the next elements of the sequence:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `fibonacci()` 的函数，并使用 `generateSequence()` 函数定义序列的下一个元素的公式：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use the `fibonacci()` function to print the next Fibonacci numbers to the console:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fibonacci()` 函数将下一个斐波那契数打印到控制台：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, we are going to get the next 20 Fibonacci numbers printed to the
    console:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到下一个 20 个斐波那契数打印到控制台：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The additional `seed` parameter in the `generateSequence()` provides a starting
    value. The `nextFunction()` function is applied to the `seed` while computing
    the second value. Later on, it is generating each following element using its
    preceding value. However, in the case of the Fibonacci sequence, we have two initial
    values and we need a pair of preceding values in order to compute the next value.
    For this reason, we wrapped them in `Pair` type instances. Basically, we are defining
    a sequence of  `Pair<Int, Int>` type elements, and in each `nextFunction()` call,
    we are returning a new pair that holds the values updated accordingly. At the
    end, we just need to use the `map()` function to replace each `Pair` element with
    the value of its `first` property. As a result, we are getting an infinite sequence
    of integer types returning the subsequent Fibonacci numbers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `generateSequence()` 中的额外 `seed` 参数提供了一个起始值。在计算第二个值时，将 `nextFunction()` 函数应用于
    `seed`。随后，它使用前一个值生成每个后续元素。然而，在斐波那契数列的情况下，我们有两个初始值，我们需要一对前一个值来计算下一个值。因此，我们将它们包装在
    `Pair` 类型实例中。基本上，我们正在定义一个 `Pair<Int, Int>` 类型元素的序列，并在每次 `nextFunction()` 调用中返回一个新的对，它包含相应更新的值。最后，我们只需要使用
    `map()` 函数将每个 `Pair` 元素替换为其 `first` 属性的值。因此，我们得到一个无限序列，返回后续的斐波那契数。
