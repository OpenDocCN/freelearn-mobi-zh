- en: Chapter 7. Utilizing Audit Logs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。利用审计日志
- en: So far we've seen AVC records or the SELinux denial messages show up in `dmesg`,
    but `dmesg` is a circular memory buffer, subject to frequent rollover dependent
    on how verbose your kernel is. By using the audit kernel subsystem, we can route
    these messages into user space and log them to disk. On the desktop, the daemon
    that does this is called `auditd`. A minimal port of `auditd` is maintained in
    the NSA branches however, it has not officially been merged into AOSP. We are
    going to use the `auditd` version from the NSA branches since we are working on
    Android 4.3\. The officially merged version as of April 7, 2014 can be found at
    [https://android-review.googlesource.com/#/c/89645/](https://android-review.googlesource.com/#/c/89645/).
    It's implemented within `logd`, and merged at [https://android-review.googlesource.com/#/c/83526/](https://android-review.googlesource.com/#/c/83526/).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到AVC记录或SELinux拒绝消息出现在`dmesg`中，但`dmesg`是一个环形内存缓冲区，其频繁滚动取决于内核的详细程度。通过使用审计内核子系统，我们可以将这些消息路由到用户空间并将它们记录到磁盘上。在桌面环境中，执行此操作的守护进程称为`auditd`。然而，`auditd`的最小端口在NSA分支中得到了维护，但它尚未正式合并到AOSP中。由于我们正在开发Android
    4.3，我们将使用NSA分支中的`auditd`版本。截至2014年4月7日官方合并的版本可以在[https://android-review.googlesource.com/#/c/89645/](https://android-review.googlesource.com/#/c/89645/)找到。它是通过`logd`实现的，并在[https://android-review.googlesource.com/#/c/83526/](https://android-review.googlesource.com/#/c/83526/)合并。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Update our system with the fast-paced SE for **Android Open Source Community**
    (**AOSP**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用针对**Android开源社区**（**AOSP**）的快速开发版更新我们的系统
- en: Investigate how the audit subsystem works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查审计子系统的工作原理
- en: Learn to read SELinux audit logs and start writing policy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习阅读SELinux审计日志并开始编写策略
- en: Look at contexts relative to the logs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看与日志相关的上下文
- en: All LSMs should log their messages into the audit subsystem. The audit subsystem
    can then route the messages to the kernel circular buffer using `printk`, or to
    the auditing daemon in user space, if one is present. The kernel and userspace
    logging daemon communicate using the `AUDIT_NETLINK` socket. We will dissect this
    interface further in the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有LSM都应该将它们的消息记录到审计子系统中。审计子系统可以使用`printk`将消息路由到内核环形缓冲区，或者如果存在，路由到用户空间的审计守护进程。内核和用户空间日志守护进程使用`AUDIT_NETLINK`套接字进行通信。我们将在本章中进一步分析此接口。
- en: Lastly, the audit subsystem has the capability to print comprehensive records
    when policy violations occur. Although you don't need this feature to enable and
    work with SELinux, it can make your life easier. To enable this system, you must
    use `auditd`, because `logd` currently doesn't have this support. You'll need
    to build your kernel with `CONFIG_AUDITSYSCALL=y` and place an `audit.rules` file
    in `/data/misc/audit/`. After you patch your tree with the following instructions,
    read `system/core/auditd/README`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当策略违规发生时，审计子系统具有打印详细记录的能力。尽管您不需要此功能来启用和使用SELinux，但它可以使您的生活更加轻松。要启用此系统，您必须使用`auditd`，因为`logd`目前还没有这项支持。您需要使用`CONFIG_AUDITSYSCALL=y`构建内核，并在`/data/misc/audit/`中放置一个`audit.rules`文件。在按照以下说明修补您的树之后，请阅读`system/core/auditd/README`。
- en: Unfortunately, the UDOO kernel version 3.0.35 does not support `CONFIG_AUDITSYSCALL`.
    The patch located at [https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b](https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b)
    should enable the support. However, on the UDOO, it causes a deadlock we could
    not trace down.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，UDOO内核版本3.0.35不支持`CONFIG_AUDITSYSCALL`。位于[https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b](https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b)的补丁应该可以启用支持。然而，在UDOO上，它导致了一个我们无法追踪的死锁。
- en: Upgrades – patches galore
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级——大量补丁
- en: Although Android 4.3, released from Google, had SE for Android support, it is
    still limited, especially in the areas of auditing. One of the simplest ways to
    bring this to a more useable state is to get the patches for some of the projects
    from the NSA's SE for Android 4.3 branch. Here, the community has staged and deployed
    many of the more advanced features which were not merged in the 4.3 timeframe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然谷歌发布的Android 4.3版本支持Android安全增强功能，但它仍然有限，尤其是在审计领域。将此功能带到更实用的状态的最简单方法之一是从NSA的Android
    4.3安全增强功能分支获取一些项目的补丁。在这里，社区已经部署了许多在4.3时间框架内未合并的更高级功能。
- en: 'The NSA maintains repositories at [https://bitbucket.org/seandroid/](https://bitbucket.org/seandroid/).
    There are many projects so figuring out which to use and what branch can be daunting.
    A way to find them is to go through each project and find the projects with a
    `SEAndroid-4.3` branch. You don''t need to descend into the device trees since
    we''re not building AOSP devices. The list of such project is:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NSA 在 [https://bitbucket.org/seandroid/](https://bitbucket.org/seandroid/) 维护仓库。由于项目众多，确定使用哪个项目和哪个分支可能会令人感到困难。找到它们的一种方法是遍历每个项目，找到具有
    `SEAndroid-4.3` 分支的项目。我们不需要深入到设备树中，因为我们不是在构建 AOSP 设备。此类项目的列表如下：
- en: '[https://bitbucket.org/seandroid/system-core](https://bitbucket.org/seandroid/system-core)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/system-core](https://bitbucket.org/seandroid/system-core)'
- en: '[https://bitbucket.org/seandroid/frameworks-base](https://bitbucket.org/seandroid/frameworks-base)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/frameworks-base](https://bitbucket.org/seandroid/frameworks-base)'
- en: '[https://bitbucket.org/seandroid/external-libselinux](https://bitbucket.org/seandroid/external-libselinux)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/external-libselinux](https://bitbucket.org/seandroid/external-libselinux)'
- en: '[https://bitbucket.org/seandroid/build](https://bitbucket.org/seandroid/build)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/build](https://bitbucket.org/seandroid/build)'
- en: '[https://bitbucket.org/seandroid/frameworks-native](https://bitbucket.org/seandroid/frameworks-native)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/frameworks-native](https://bitbucket.org/seandroid/frameworks-native)'
- en: 'We can also safely skip `sepolicy` since we''ve already updated it to the bleeding
    edge, but the kernels are a bit trickier. We need the changes from kernel-common
    ([https://bitbucket.org/seandroid/kernel-common](https://bitbucket.org/seandroid/kernel-common))
    and the binder patch ([https://android-review.googlesource.com/#/c/45984/](https://android-review.googlesource.com/#/c/45984/)),
    which can be attained as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以安全地跳过 `sepolicy`，因为我们已经将其更新到最新版本，但内核稍微复杂一些。我们需要从 `kernel-common ([https://bitbucket.org/seandroid/kernel-common](https://bitbucket.org/seandroid/kernel-common))`
    和 `binder` 补丁 `[https://android-review.googlesource.com/#/c/45984/](https://android-review.googlesource.com/#/c/45984/)`
    中获取更改，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can start by figuring out the exact version we need to patch to by looking
    at the `build/core/build_id.mk` file, and by using the webpage [https://source.android.com/source/build-numbers.html](https://source.android.com/source/build-numbers.html)
    to do a lookup.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看 `build/core/build_id.mk` 文件来确定需要修补的确切版本，并使用网页 [https://source.android.com/source/build-numbers.html](https://source.android.com/source/build-numbers.html)
    进行查找。
- en: The file shows `BUILD_ID` is `JSS15J`, and the lookup shows that we are working
    with the `android-4.3_r2.1` release for the UDOO.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 文件显示 `BUILD_ID` 是 `JSS15J`，查找结果显示我们正在使用 UDOO 的 `android-4.3_r2.1` 版本。
- en: For each downloaded project so far, generate the patches by running the command
    `git checkout origin/seandroid-4.3_r2`. Finally, execute `git format-patch origin/jb-mr2.0-release`.
    Since there is no `4.3._r2.1` branch, we're using `r2`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于迄今为止下载的每个项目，通过运行命令 `git checkout origin/seandroid-4.3_r2` 生成补丁。最后，执行 `git
    format-patch origin/jb-mr2.0-release`。由于没有 `4.3._r2.1` 分支，我们使用 `r2`。
- en: For each of these patches, you'll need to apply them in the tree from their
    corresponding `udoo/<project>` folder. It is important to apply the patches for
    each project in numeric order starting with the `0001*` patch, moving on to `0002*`,
    and so on. As an example of how to apply a specific patch for a project, let's
    look at the first patch needed for `system-core`. Note that these Git repositories
    use hyphens in place of the slashes in the source tree; so `frameworks-base` correlates
    to `frameworks/base`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些补丁中的每一个，你都需要将它们应用到从相应的 `udoo/<project>` 文件夹中的树中。对于每个项目，按照从 `0001*` 补丁开始，接着是
    `0002*`，依此类推的数字顺序应用补丁非常重要。以下是如何为一个项目应用特定补丁的示例，让我们看看为 `system-core` 需要的第一个补丁。请注意，这些
    Git 仓库在源树中使用连字符代替斜杠；因此 `frameworks-base` 与 `frameworks/base` 相关联。
- en: 'First, generate the patches:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成补丁：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Apply the first patch, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式应用第一个补丁：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that for UDOO, it is important not to apply a patch number higher than
    `0005` in `frameworks/base`. For other projects, you should apply all the patches.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 UDOO 来说，在 `frameworks/base` 中应用高于 `0005` 的补丁编号非常重要。对于其他项目，你应该应用所有补丁。
- en: Note the error. Just hit *Ctrl* + *C* to quit the patching process whenever
    you see this. The Git trees are not quite perfect, and because of this, some of
    the patches are already in the UDOO source. The patch command will let us know,
    and we can skip these by canceling them, when warned, with *Ctrl* + *C*. Keep
    going through the patches, canceling the ones already applied, and fixing up any
    failures. After patching userspace, it's *highly* recommended that you build to
    ensure nothing is broken.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意错误。只要看到这个错误，就按*Ctrl* + *C*来退出补丁过程。Git树并不完美，因此，一些补丁已经包含在UDOO源代码中。patch命令会通知我们，当警告时，我们可以通过按*Ctrl*
    + *C*取消它们，继续通过补丁，取消已应用的补丁，并修复任何失败。在修补用户空间后，强烈建议你构建以确保没有出错。
- en: 'Once userspace is completely patched, we need to patch the kernel. Start by
    cloning the kernel-common project from Bitbucket with the `git clone https://bitbucket.org/seandroid/kernel-common.git`
    command. We will patch the kernel with the same method as the rest of the projects
    with the exception of the binder patch. By viewing the link for the binder patch
    mentioned, [https://android-review.googlesource.com/#/c/45984/](https://android-review.googlesource.com/#/c/45984/),
    we found that the Git SHA hash is `a3c9991b560cf0a8dec1622fcc0edca5d0ced936`,
    as given in the **Patch set 4** reference field in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户空间完全修补，我们需要修补内核。首先，使用`git clone https://bitbucket.org/seandroid/kernel-common.git`命令从Bitbucket克隆kernel-common项目。我们将使用与其他项目相同的方法来修补内核，除了binder补丁。通过查看提到的binder补丁链接[https://android-review.googlesource.com/#/c/45984/](https://android-review.googlesource.com/#/c/45984/)，我们发现Git
    SHA散列是`a3c9991b560cf0a8dec1622fcc0edca5d0ced936`，正如以下截图中的**Patch set 4**参考字段所给出的：
- en: '![Upgrades – patches galore](img/0594OS_7_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![升级 - 补丁众多](img/0594OS_7_1.jpg)'
- en: 'We can then generate the patch for this SHA hash:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成这个SHA散列的补丁：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, apply that patch with the patch command as we did before. The patch has
    a failed hunk for a header file inclusion; just fix it up like the others by using
    the reject file. When you build, you''ll get this error in the kernel:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用与之前相同的方法使用patch命令应用该补丁。该补丁有一个失败的hunk用于头文件包含；就像其他补丁一样，通过使用reject文件来修复它。当你构建时，你将在内核中得到这个错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Go ahead and remove this line and all references. This was a change made in
    the 3.0 kernels:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 继续删除这一行及其所有引用。这是在3.0内核中做出的更改：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We figured this out by looking through the original 3.0 patches, which can
    be found at following link:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看原始的3.0补丁来解决这个问题，这些补丁可以在以下链接找到：
- en: '[https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0](https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0](https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0)'
- en: 'As you recall, the UDOO uses a custom `init.rc`. We need to add any changes
    to `init.rc` to the one UDOO actually uses. All the patches that can modify `init.rc`
    will be in the system-core project, specifically these:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，UDOO使用自定义的`init.rc`。我们需要将任何对`init.rc`的更改添加到UDOO实际使用的那个`init.rc`中。所有可以修改`init.rc`的补丁都在system-core项目中，具体如下：
- en: '`0003-Auditd-initial-commit.patch`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0003-Auditd-initial-commit.patch`'
- en: '`0007-Handle-policy-reloads-within-ueventd-rather-than-res.patch`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0007-Handle-policy-reloads-within-ueventd-rather-than-res.patch`'
- en: '`0009-Allow-system-UID-to-set-enforcing-and-booleans.patch`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0009-Allow-system-UID-to-set-enforcing-and-booleans.patch`'
- en: Go ahead and find the changes to `init.rc` in these patches and apply them to
    `device/fsl/imx6/etc/init.rc` using the same patch technique.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 继续查找这些补丁中`init.rc`的变化，并使用相同的补丁技术将其应用到`device/fsl/imx6/etc/init.rc`。
- en: The audit system
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计系统
- en: In the previous section, we did a lot of patching; the point of which was to
    enable the audit integration work done on Android and its dependencies. These
    patches also fix some bugs in the code and, very importantly, enable the SELinux/LSM
    binder hooks and policy controls.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们做了很多补丁工作；其目的是为了启用在Android及其依赖项上完成的审计集成工作。这些补丁还修复了代码中的某些错误，并且非常重要，它们启用了SELinux/LSM
    binder钩子和策略控制。
- en: The audit system in Linux is used by LSMs to print the denial records as well
    as to gather very thorough and complete records of events. No matter what, when
    an LSM prints a message, it gets propagated to the audit subsystem and printed.
    However, if the audit subsystem has been enabled, then you get more context associated
    with the denial. The audit subsystem even supports loading rules for watching
    this. For instance, you could watch all writes to `/system` that were not done
    by the system UID.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的审计系统被 LSM 用于打印拒绝记录，以及收集非常详尽和完整的事件记录。无论如何，当 LSM 打印消息时，它都会传播到审计子系统并打印出来。然而，如果审计子系统已被启用，那么你将获得更多与拒绝相关的上下文。审计子系统甚至支持加载规则以监视这一点。例如，你可以监视所有由系统
    UID 未执行的对 `/system` 的写入操作。
- en: The auditd daemon
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: auditd 守护进程
- en: The `auditd` daemon, or service, runs in userspace and listens over a NETLINK
    socket to the audit subsystem. The daemon registers itself to receive the kernel
    messages, and can also load the audit rules over this socket. Once registered,
    the `auditd` daemon receives all the audit events. The `auditd` daemon was minimally
    ported, and there was an attempt to mainline it into Android that was later rejected.
    However, `auditd` has been used by various OEMs (such as Samsung) and by the NSA's
    4.3 branch. An alternative approach that put records in logcat was later merged
    into Android (for more information, refer to [https://android-review.googlesource.com/89645](https://android-review.googlesource.com/89645)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`auditd` 守护进程或服务在用户空间运行，并通过 NETLINK 套接字监听审计子系统。守护进程将自己注册以接收内核消息，并且也可以通过这个套接字加载审计规则。一旦注册，`auditd`
    守护进程就会接收所有的审计事件。`auditd` 守护进程只是最小化移植的，并且曾尝试将其主线集成到 Android 中，但后来被拒绝了。然而，`auditd`
    已被各种 OEM（如三星）和 NSA 的 4.3 分支所使用。后来，将记录放入 logcat 的另一种方法被合并到 Android 中（更多信息，请参阅 [https://android-review.googlesource.com/89645](https://android-review.googlesource.com/89645))。'
- en: Earlier, we saw the AVC denial messages from SELinux in `dmesg`. The problem
    with this is that the circular memory log is prone to rollover when you have many
    denials or a chatty kernel. With `auditd`, all the messages come to the daemon
    and are written to the `/data/misc/audit/audit.log` file. This log file, herein
    referred to as `audit.log`, may exist on device boot and is rotated into the `/data/misc/audit/audit.old`
    file, known as `audit.old`. The daemon resumes logging to a new `audit.log` file.
    This rotate event occurs when the size threshold `AUDITD_MAX_LOG_FILE_SIZEKB`
    (set during compile time in the `system/core/auditd/Android.mk` file) is exceeded.
    This threshold is typically 1000 KB but can be changed in the device's `makefile`.
    Also, sending `SIGHUP` with `kill` will cause a rotate as in the following example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在 `dmesg` 中看到了 SELinux 的 AVC 拒绝消息。这个问题在于，当有大量的拒绝或一个健谈的内核时，循环内存日志容易溢出。使用
    `auditd`，所有消息都会发送到守护进程，并写入 `/data/misc/audit/audit.log` 文件。这个日志文件，在此处称为 `audit.log`，可能在设备启动时存在，并旋转到
    `/data/misc/audit/audit.old` 文件，称为 `audit.old`。守护进程将重新开始向新的 `audit.log` 文件记录。当大小阈值
    `AUDITD_MAX_LOG_FILE_SIZEKB`（在 `system/core/auditd/Android.mk` 文件编译时设置）被超过时，就会发生这个旋转事件。这个阈值通常是
    1000 KB，但可以在设备的 `makefile` 中更改。此外，使用 `kill` 发送 `SIGHUP` 也会像以下示例中那样导致旋转。
- en: 'Verify the daemon is running and get its PID:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 验证守护进程正在运行并获取其 PID：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify only one log exists:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 验证只存在一个日志：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rotate the logs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转日志：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Verify `audit.old`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 `audit.old`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Auditd internals
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: auditd 内部机制
- en: Since the `auditd` and `libaudit` code from the Linux desktop have a GPL license,
    a rewrite was done for Android, released under the Apache license. The rewrite
    is minimal, thus you will only find the functions implemented that were required
    to support the daemon. The functional and header interfaces should remain identical
    though.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 桌面的 `auditd` 和 `libaudit` 代码具有 GPL 许可证，因此为 Android 进行了重写，并发布了 Apache
    许可证。重写是最小化的，因此你只会找到支持守护进程所需的功能。尽管如此，功能性和头文件接口应该保持相同。
- en: The `auditd` daemon starts life at `main()` in `system/core/auditd.c`. It quickly
    changes its permissions from UID root to a special `auditd` UID. When it does
    this, it retains `CAPSYS_AUDIT`, which is a required DAC capability check to use
    the `AUDIT` NETLINK socket. It does this via a call to `drop_privileges_or_die()`.
    From there, it does some option parsing with `getopt()`, and we finally get to
    the audit-specific calls, the first of which opens the NETLINK socket using `audit_open()`.
    This function simply calls `socket(PF_NETLINK, SOCK_RAW, NETLINK_AUDIT)`, which
    opens a file descriptor to the NETLINK socket. After opening the socket, the daemon
    opens a handle to `audit.log` with a call to `audit_log_open(const char *logfile,
    const char *rotatefile, size_t threshold)`. This function checks whether the `audit.log`
    file exists and, if it does, renames it to `audit.old`. It then creates a new
    empty log file in which the data is recorded.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`auditd`守护进程在其生命周期中从`system/core/auditd.c`中的`main()`函数开始。它迅速将其权限从UID root更改为特殊的`auditd`
    UID。在这个过程中，它保留了`CAPSYS_AUDIT`权限，这是使用`AUDIT` NETLINK套接字所必需的DAC能力检查。它是通过调用`drop_privileges_or_die()`来实现的。从那里，它使用`getopt()`进行一些选项解析，然后我们最终到达审计特定的调用，第一个调用是使用`audit_open()`打开NETLINK套接字。这个函数简单地调用`socket(PF_NETLINK,
    SOCK_RAW, NETLINK_AUDIT)`，从而打开一个指向NETLINK套接字的数据文件描述符。在打开套接字之后，守护进程通过调用`audit_log_open(const
    char *logfile, const char *rotatefile, size_t threshold)`打开对`audit.log`的句柄。这个函数检查`audit.log`文件是否存在，如果存在，则将其重命名为`audit.old`。然后，它创建一个新的空日志文件，用于记录数据。'
- en: The next step is to register the daemon with the audit subsystem so that it
    knows to whom to send messages. By setting the PID of the daemon, you ensure that
    only this daemon will get the messages. Since NETLINK can support many readers,
    you don't want a "rogue `auditd`" to read the messages. With that stated, the
    daemon calls `audit_set_pid(audit_fd, getpid(), WAIT_YES)`, where `audit_fd` is
    the NETLINK socket from `audit_open()`, `getpid()` returns the daemon's PID, and
    `WAIT_YES` causes the daemon to block until the operation is complete. Next, the
    daemon enables the audit subsystem's advanced features with a call to `audit_set_enabled(audit_fd,
    1)` and adds rules to the audit subsystem via `audit_rules_read_and_add(audit_fd,
    AUDITD_RULES_FILE)`. This function reads the rules from that file, formats some
    structures, and sends those structures to the kernel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将守护进程注册到审计子系统中，以便它知道向谁发送消息。通过设置守护进程的PID，你确保只有这个守护进程会接收到消息。由于NETLINK可以支持多个读取者，你不希望有一个“流氓`auditd`”读取消息。有了这个前提，守护进程调用`audit_set_pid(audit_fd,
    getpid(), WAIT_YES)`，其中`audit_fd`是来自`audit_open()`的NETLINK套接字，`getpid()`返回守护进程的PID，而`WAIT_YES`使得守护进程在操作完成前阻塞。接下来，守护进程通过调用`audit_set_enabled(audit_fd,
    1)`启用审计子系统的先进功能，并通过`audit_rules_read_and_add(audit_fd, AUDITD_RULES_FILE)`将规则添加到审计子系统中。这个函数从该文件读取规则，格式化一些结构，并将这些结构发送到内核。
- en: The `audit_set_enabled()` and `audit_rules_read_and_add()`only have an effect
    if the kernel is built with `CONFIG_AUDITSYSCALL`. After this, the daemon checks
    whether the `-k` option was specified. The `-k` option tells `auditd` to look
    in `dmesg` for any missed audit records. It does this because there is a race
    between capturing audit records before the circular buffer overflows and userspace
    starting many services, generating audit events and policy violations. Essentially,
    this helps coalesce the audit events from early boot into the same log files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit_set_enabled()`和`audit_rules_read_and_add()`只有在内核构建时带有`CONFIG_AUDITSYSCALL`配置选项时才有效。在此之后，守护进程检查是否指定了`-k`选项。`-k`选项告诉`auditd`在`dmesg`中查找任何丢失的审计记录。它这样做是因为在捕获审计记录以防止环形缓冲区溢出和用户空间启动许多服务、生成审计事件和政策违规之间存在竞争。本质上，这有助于将早期引导中的审计事件合并到相同的日志文件中。'
- en: After this, the daemon enters a loop to read from the NETLINK socket, formatting
    the messages, and writing them to the log file. It starts this loop by waiting
    for IO on the NETLINK socket using `poll()`. If `poll()` exits with an error,
    the loop continues to check the `quit` variable. If `EINTR` is raised, the loop
    guard, `quit`, is set to `true` in the signal handler, and the daemon exits. If
    `poll()` is data on the NETLINK, the daemon calls `audit_get_reply(audit_fd, &rep,
    GET_REPLY_BLOCKING, 0)`, getting an `audit_reply` structure back with the `rep`
    parameter. It then writes the `audit_reply` structure (with formatting) to the
    `audit.log` file with `audit_log_write(alog, "type=%d msg=%.*s\n", rep.type, rep.len,
    rep.msg.data)`. It does this until `EINTR` is raised, at which point, the daemon
    exits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，守护进程进入一个循环，从 NETLINK 套接字读取，格式化消息，并将它们写入日志文件。它通过使用 `poll()` 等待 NETLINK 套接字上的
    IO 来启动这个循环。如果 `poll()` 因为错误而退出，循环将继续检查 `quit` 变量。如果引发 `EINTR`，循环保护器 `quit` 在信号处理程序中设置为
    `true`，守护进程退出。如果 `poll()` 在 NETLINK 上有数据，守护进程会调用 `audit_get_reply(audit_fd, &rep,
    GET_REPLY_BLOCKING, 0)`，并通过 `rep` 参数返回一个 `audit_reply` 结构。然后，它使用 `audit_log_write(alog,
    "type=%d msg=%.*s\n", rep.type, rep.len, rep.msg.data)` 将格式化的 `audit_reply` 结构写入
    `audit.log` 文件。它一直这样做，直到引发 `EINTR`，此时守护进程退出。
- en: When the daemon exits, it clears the PID registered with the kernel (`audit_set_pid(audit_fd,
    0)`), closes the audit socket via `audit_close()` (which is really just the syscall,
    `close(audit_fd)`), and closes the `audit.log` with `audit_log_close()`. The `audit_log_*`
    family of functions is not part of the GPLed interface to audit and is a custom
    write.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当守护进程退出时，它会清除与内核注册的 PID (`audit_set_pid(audit_fd, 0)`)，通过 `audit_close()` 关闭审计套接字（实际上就是系统调用
    `close(audit_fd)`），并使用 `audit_log_close()` 关闭 `audit.log` 文件。`audit_log_*` 函数族不是
    GPL 授权的审计接口的一部分，而是一种自定义的写入方式。
- en: When Google ported `auditd` to the `logd` infrastructure in Android, it used
    the same functions and library code used by the daemon's `main()` and wrapped
    it into `logd`. However, Google *did not* take the `audit_set_enabled()` and `audit_rules_read_and_add()`
    functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌将 `auditd` 移植到 Android 的 `logd` 基础设施时，它使用了守护进程 `main()` 中使用的相同函数和库代码，并将其包装到
    `logd` 中。然而，谷歌 *没有* 使用 `audit_set_enabled()` 和 `audit_rules_read_and_add()` 函数。
- en: Interpreting SELinux denial logs
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 SELinux 拒绝日志
- en: The SELinux denials get routed to the kernel audit subsystem, to `auditd`, and
    finally, to `audit.log` and `audit.old`. With the logs resident in `audit.log`,
    let's pull this file over `adb` and have a closer look at it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 拒绝信息会被路由到内核审计子系统，到 `auditd`，最终到 `audit.log` 和 `audit.old`。由于日志存储在 `audit.log`
    中，让我们通过 `adb` 将此文件拉取过来，并仔细查看它。
- en: 'Run the following command from the host, with `adb` enabled:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从主机运行以下命令，确保 `adb` 已启用：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s tail that file and look for these lines:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看该文件并寻找以下行：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The records here consist of two major portions: `type` and `msg`. The `type`
    field indicates what type of message it is. Messages with type 1400 are AVC messages,
    which are SELinux denial messages (there are other types, as well). The `msg`
    (short for message) portion of the preceding policy contains the part for us to
    analyze.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的记录由两个主要部分组成：`type` 和 `msg`。`type` 字段指示消息的类型。类型为 1400 的消息是 AVC 消息，即 SELinux
    拒绝消息（还有其他类型）。前面的策略中的 `msg`（简称消息）部分是我们需要分析的部分。
- en: 'The last command we executed was `adb pull /data/misc/audit/aduit.log` and,
    as you can see, we have a few `adb` policy violations at the tail of the `audit.log`
    file. Let''s start by looking at this event:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后执行的命令是 `adb pull /data/misc/audit/aduit.log`，如您所见，我们在 `audit.log` 文件的末尾有一些
    `adb` 策略违规。让我们先看看这个事件：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see that the `comm` field is `adbd`. However, it''s not wise to trust
    this value since it can be controlled from userspace using the `prctl()` interface.
    It can only be viewed as a hint. The best way to verify this is to check the PID
    using `ps -Z`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `comm` 字段是 `adbd`。然而，由于它可以通过 `prctl()` 接口从用户空间控制，所以这个值并不可信。它只能作为一个提示。验证这个值最好的方法是使用
    `ps -Z` 检查 PID：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the daemon verified, we can now check the message in more detail. The
    message consists of the following fields (optional fields are identified by `*`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证守护进程后，我们现在可以更详细地检查消息。消息由以下字段组成（可选字段用 `*` 标识）：
- en: '`avc: denied`: This part will always happen and denotes it is a denial record.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`avc: denied`：这部分总是会发生，表示这是一个拒绝记录。'
- en: '`{ permission }`: This is the permission that was denied, in this case, `getattr`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{权限}`：这是被拒绝的权限，在本例中是 `getattr`。'
- en: '`for`: This will always be printed and makes the output readable.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`：这总是会被打印出来，使得输出可读。'
- en: '`Path*`: This is the optional field that contains the path of the object in
    question. It only makes sense for filesystem access denials.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path*`: 这是一个可选字段，包含所讨论对象的路径。它仅在文件系统访问拒绝的情况下才有意义。'
- en: '`dev*`: This is the optional field that identifies the block device for the
    mounted filesystem. It only makes sense for filesystem access denials.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev*`: 这是一个可选字段，用于标识挂载文件系统的块设备。它仅在文件系统访问拒绝的情况下才有意义。'
- en: '`ino*`: This is the optional inode of the file. Only the anonymous files in
    Linux print inode. It only makes sense for filesystem access denials.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ino*`: 这是一个可选的文件inode。只有 Linux 中的匿名文件会打印inode。它仅在文件系统访问拒绝的情况下才有意义。'
- en: '`tclass`: This is the target class of the object, which in our case was `file`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tclass`: 这是对象的目标类，在我们的例子中是 `file`。'
- en: 'At this point, we need to understand what the `msg` portion of the denial record
    is telling us at a very distilled level. It is saying that the Android debug bridge
    daemon wants to be able to call `getattr` on our policy file. A few events down,
    we will see it also wants `read` and `open`. This is the side effect of running
    `adb pull`. A `getattr` permission denial occurs from a `stat()` syscall, and
    the `read/open` are from `read()` and `open()` syscalls. If you want to allow
    this in your policy, which would be a security decision based on your threat model,
    you should add:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要非常精炼地理解拒绝记录中的 `msg` 部分在告诉我们什么。它表示 Android 调试桥接守护进程想要能够调用我们的策略文件上的
    `getattr`。在接下来的几个事件中，我们会看到它还想要 `read` 和 `open`。这是运行 `adb pull` 的副作用。`getattr`
    权限拒绝来自 `stat()` 系统调用，而 `read/open` 来自 `read()` 和 `open()` 系统调用。如果你想在策略中允许这一点，这将是一个基于你的威胁模型的安全决策，你应该添加：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, use the macro sets defined in `global_macros`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用在 `global_macros` 中定义的宏集：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Most of the time, you should use the macros defined in `global_macros` for file
    permission accesses. Typically, adding them one by one is very time consuming
    and tedious. The macros group the permissions in a context analogous to read,
    write, and execute DAC permissions. For instance, if you give it `open` and `read`,
    there's a good chance at some point that the source domain will need to stat the
    file. So, the `r_file_perms` macro has those permissions in it already.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你应该使用在 `global_macros` 中定义的宏来访问文件权限。通常，逐个添加它们是非常耗时且繁琐的。宏将权限分组在一个类似于读取、写入和执行
    DAC 权限的上下文中。例如，如果你给它 `open` 和 `read`，那么在某个时候源域可能需要获取该文件的统计信息。因此，`r_file_perms`
    宏已经包含了这些权限。
- en: 'You should add this rule to `external/sepolicy/adbd.te`. The `.te` files (also
    called `type enforcement` files) are organized by source context, so make sure
    you add it to the correct file. We do not recommend adding this allow rule—there''s
    no legitimate reason that `adbd` needs access to the audit logs—we can safely
    ignore these with a `dontaudit` rule:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将此规则添加到 `external/sepolicy/adbd.te`。`.te` 文件（也称为类型强制文件）按源上下文组织，所以请确保将其添加到正确的文件。我们不推荐添加此允许规则——`adbd`
    需要访问审计日志没有合法的理由——我们可以安全地忽略这些内容，使用 `dontaudit` 规则：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `dontaudit` rule is a policy statement that says don't audit (print) denials
    that match this rule.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`dontaudit` 规则是一个策略声明，表示不要审计（打印）与该规则匹配的拒绝。'
- en: If you're not sure what to do, the best advice is to leverage the mailing lists
    for SE for Android, SELinux, and audit. Just keep the messages appropriate to
    the specific mailing lists topic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定该怎么做，最好的建议是利用 SE for Android、SELinux 和 audit 的邮件列表。只需确保消息与特定邮件列表的主题相关。
- en: 'A tool exists called `audit2allow`, which can help you write policy allow rules.
    However, it''s only a tool and can be misused. It translates the policy file to
    the allow rules for the policy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为 `audit2allow` 的工具，可以帮助你编写策略允许规则。然而，它只是一个工具，可能会被误用。它将策略文件转换为策略的允许规则：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `audit2allow` tool is not macro aware or aware if you really want to add
    this allow rule to the policy file. Only the policy author can make this decision.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit2allow` 工具不具备宏意识，或者如果你真的想将此允许规则添加到策略文件中，它也不具备这种意识。只有策略作者才能做出这个决定。'
- en: 'There is also a tool to enable the `r_file_*` macro mapping called `fixup.py`.
    You can get the tool at [https://bitbucket.org/billcroberts/fixup/overview](https://bitbucket.org/billcroberts/fixup/overview).
    After downloading, make it executable, and place it somewhere in your executable
    path:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `fixup.py` 的工具，可以启用 `r_file_*` 宏映射。你可以在 [https://bitbucket.org/billcroberts/fixup/overview](https://bitbucket.org/billcroberts/fixup/overview)
    获取该工具。下载后，使其可执行，并将其放置在可执行路径中的某个位置：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Contexts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文
- en: In the simplest sense, writing policies is just the activity of identifying
    policy violations and adding the appropriate allow rules to the policy file. However,
    in order for SELinux to be effective, the source and target contexts must be correct.
    If they are not, the allow rules are meaningless.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的意义上，编写策略的活动就是识别策略违规并添加适当的允许规则到策略文件中。然而，为了使SELinux有效，源上下文和目标上下文必须正确。如果不正确，允许规则就毫无意义。
- en: The first things you might encounter are denials where the target type is unlabeled.
    In this case, the proper target label needs to be set (refer to [Chapter 11](ch11.html
    "Chapter 11. Labeling Properties"), *Labeling Properties*). Also, process labels
    can be wrong. Multiple processes can belong to a domain, and unless explicitly
    done via policy, the child process of a parent inherits the parent's domain. However,
    in Android, domains that have multiple processes are quite limited. You will never
    see multiple processes in `init`, `system_server`, `adbd`, `auditd`, `debuggerd`,
    `dhcp`, `servicemanager`, `vold`, `netd`, `surfaceflinger`, `drmserver`, `mediaserver`,
    `installd`, `keystore`, `sdcardd`, `wpa`, and `zygote` domains.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的目标类型未标记的拒绝。在这种情况下，需要设置正确的目标标签（参考[第11章](ch11.html "第11章。标记属性")，*标记属性*）。此外，进程标签也可能错误。多个进程可以属于一个域，除非通过策略明确执行，否则父进程的子进程会继承父进程的域。然而，在Android中，具有多个进程的域相当有限。你永远不会在`init`、`system_server`、`adbd`、`auditd`、`debuggerd`、`dhcp`、`servicemanager`、`vold`、`netd`、`surfaceflinger`、`drmserver`、`mediaserver`、`installd`、`keystore`、`sdcardd`、`wpa`和`zygote`域中看到多个进程。
- en: 'It''s okay to see multiple processes in the following domains:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下域中看到多个进程是可以的：
- en: '`system_app`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_app`'
- en: '`untrusted_app`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`untrusted_app`'
- en: '`platform_app`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform_app`'
- en: '`shared_app`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_app`'
- en: '`media_app`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media_app`'
- en: '`release_app`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release_app`'
- en: '`isolated_app`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolated_app`'
- en: '`shell`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell`'
- en: 'On a released device, nothing should be run in the `su`, `recovery`, and `init_shell`
    domains. The following table provides a complete mapping of domains to the expected
    executables and cardinality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在已发布的设备上，`su`、`recovery`和`init_shell`域中不应运行任何内容。以下表格提供了域到预期可执行文件和容量的完整映射：
- en: '| Domain | Executable(s) | Cardinality (N) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 域 | 可执行文件 | 容量（N） |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `u:r:init:s0"` | `/init` | `N == 1` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:init:s0"` | `/init` | `N == 1` |'
- en: '| `u:r:ueventd:s0` | `/sbin/ueventd` | `N == 1` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:ueventd:s0` | `/sbin/ueventd` | `N == 1` |'
- en: '| `u:r:healthd:s0` | `/sbin/healthd` | `N == 1` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:healthd:s0` | `/sbin/healthd` | `N == 1` |'
- en: '| `u:r:servicemanager:s0` | `/system/bin/servicemanager` | `N == 1` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:servicemanager:s0` | `/system/bin/servicemanager` | `N == 1` |'
- en: '| `u:r:vold:s0` | `/system/bin/vold` | `N == 1` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:vold:s0` | `/system/bin/vold` | `N == 1` |'
- en: '| `u:r:netd:s0` | `/system/bin/netd` | `N == 1` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:netd:s0` | `/system/bin/netd` | `N == 1` |'
- en: '| `u:r:debuggerd:s0` | `/system/bin/debuggerd, /system/bin/debuggerd64` | `N
    == 1` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:debuggerd:s0` | `/system/bin/debuggerd, /system/bin/debuggerd64` | `N
    == 1` |'
- en: '| `u:r:surfaceflinger:s0` | `/system/bin/surfaceflinger` | `N == 1` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:surfaceflinger:s0` | `/system/bin/surfaceflinger` | `N == 1` |'
- en: '| `u:r:zygote:s0` | `zygote, zygote64` | `N == 1` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:zygote:s0` | `zygote, zygote64` | `N == 1` |'
- en: '| `u:r:drmserver:s0` | `/system/bin/drmserver` | `N == 1` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:drmserver:s0` | `/system/bin/drmserver` | `N == 1` |'
- en: '| `u:r:mediaserver:s0` | `/system/bin/mediaserver` | `N >= 1` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:mediaserver:s0` | `/system/bin/mediaserver` | `N >= 1` |'
- en: '| `u:r:installd:s0` | `/system/bin/installd` | `N == 1` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:installd:s0` | `/system/bin/installd` | `N == 1` |'
- en: '| `u:r:keystore:s0` | `/system/bin/keystore` | `N == 1` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:keystore:s0` | `/system/bin/keystore` | `N == 1` |'
- en: '| `u:r:system_server:s0` | `system_server` | `N ==1` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:system_server:s0` | `system_server` | `N ==1` |'
- en: '| `u:r:sdcardd:s0` | `/system/bin/sdcard` | `N >=1` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:sdcardd:s0` | `/system/bin/sdcard` | `N >=1` |'
- en: '| `u:r:watchdogd:s0` | `/sbin/watchdogd` | `N >=0 && N < 2` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:watchdogd:s0` | `/sbin/watchdogd` | `N >=0 && N < 2` |'
- en: '| `u:r:wpa:s0` | `/system/bin/wpa_supplicant` | `N >=0 && N < 2` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:wpa:s0` | `/system/bin/wpa_supplicant` | `N >=0 && N < 2` |'
- en: '| `u:r:init_shell:s0` | `null` | `N == 0` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:init_shell:s0` | `null` | `N == 0` |'
- en: '| `u:r:recovery:s0` | `null` | `N == 0` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:recovery:s0` | `null` | `N == 0` |'
- en: '| `u:r:su:s0` | `null` | `N == 0` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `u:r:su:s0` | `null` | `N == 0` |'
- en: Several **Compatibility Test Suite** (**CTS**) tests have been written around
    this and submitted to AOSP at [https://android-review.googlesource.com/#/c/82861/](https://android-review.googlesource.com/#/c/82861/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕这一点已经编写了几个**兼容性测试套件**（**CTS**）测试，并已提交到AOSP，[https://android-review.googlesource.com/#/c/82861/](https://android-review.googlesource.com/#/c/82861/)。
- en: Based on these generic assertions of what a good policy should look like, let's
    evaluate ours.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对良好策略应具备的通用断言，让我们评估我们的策略。
- en: 'First, we will check for unlabeled objects. From the host, with the `audit.log`
    file you obtained with `adb pull`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查未标记的对象。从主机，使用您通过`adb pull`获得的`audit.log`文件：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It looks like we have some files and other things that are not labeled properly;
    we will address these in the [Chapter 11](ch11.html "Chapter 11. Labeling Properties"),
    *Labeling Properties*. Now, let's check for domains that have multiple processes
    when they should not, and find improper binaries in those domains (refer to the
    previous table for the complete mapping.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们有一些文件和其他东西没有正确标记；我们将在[第11章](ch11.html "第11章。标记属性")*标记属性*中解决这些问题。现在，让我们检查那些不应该有多个进程的域，并找出这些域中的不适当二进制文件（参考前表以获取完整映射）。
- en: 'Init:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Init：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Zygote:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Zygote：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After doing this, we found issues because something is running in the `init_shell`
    domain, and `watchdogd` is in the `init` domain. These must be corrected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这项工作后，我们发现了一些问题，因为某些东西正在`init_shell`域中运行，而`watchdogd`却在`init`域中。这些问题必须得到纠正。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing `sepolicy` is relatively easy, writing good policy is an art. It requires
    the policy author to understand the system and the implications of the `allow`
    rule. Policy itself is a meta-programming language where the language controls
    how userspace and the kernel get along, and much like any program, the policy
    can be architected for a specific use. Policies can be too porous (essentially
    useless) or very tight and difficult to change without breaking the portions that
    already work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`sepolicy`相对容易，编写好的策略则是一门艺术。它要求策略作者理解系统以及`allow`规则的影响。策略本身是一种元编程语言，其中语言控制用户空间和内核如何相处，并且与任何程序一样，策略可以针对特定用途进行架构。策略可能过于松散（本质上无用）或非常紧密，难以更改而不破坏已经正常工作的部分。
- en: A good policy needs to preserve the intended proper function of the system,
    so thorough testing of all the systems within Android is essential. CTS is a great
    help in exercising Android, but it often does not cover all the cases; user testing
    is recommended. In the next chapter, we will cover how filesystems and filesystem
    objects get their security labels and how we can change them. Later, we will go
    over how to use CTS as a tool to test the system and generate policy violations
    for intended behaviors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一项好的策略需要保留系统的预期正确功能，因此对Android系统中所有系统的彻底测试是必不可少的。CTS在测试Android系统方面非常有帮助，但它通常并不涵盖所有情况；建议进行用户测试。在下一章中，我们将介绍文件系统和文件系统对象是如何获得其安全标签的，以及我们如何可以更改它们。稍后，我们将讨论如何将CTS用作工具来测试系统并生成针对预期行为的策略违规。
