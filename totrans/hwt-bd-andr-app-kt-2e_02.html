<html><head></head><body>
		<div><h1 id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/><a id="_idTextAnchor107"/>2</h1>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor108"/>Building User Screen Flows</h1>
			<p><a id="_idTextAnchor109"/>This chapter covers the Android activity lifecycle and explains how the Android system interacts with your app. By the end of this chapter, you’ll have learned how to build user journeys through different screens. You’ll also be able to use activity tasks and launch modes, save and restore the state of your activity, use logs to report on your application, and share data between screens.</p>
			<p><a id="_idTextAnchor110"/>The previous chapter introduced you to the core elements of Android development, from configuring your app using the <code>AndroidManifest.xml</code> file, working with simple activities, and the Android resource structure to building an app with <code>gradle</code> and running an app on a virtual device.</p>
			<p>In this chapter, you’ll go further and learn how the Android system interacts with your app through the Android lifecycle, how you are notified of changes to your app’s state, and how you can use the Android lifecycle to respond to these changes.</p>
			<p>You’ll then progress to learning how to create user journeys through your app and how to share data between screens. You’ll be introduced to different techniques to achieve these goals so that you’ll be able to use them in your own apps and recognize them when you see them used in other apps.</p>
			<p>We will cover the following topics in the chapter:</p>
			<ul>
				<li>The Activity lifecycle</li>
				<li>Saving and restoring the Activity state</li>
				<li>Activity interaction with Intents</li>
				<li>Intents, Tasks, and Launch Modes</li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor111"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/PmKJ6">https://packt.link/PmKJ6</a></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor112"/><a id="_idTextAnchor113"/>The Activity lifecycle</h1>
			<p>In the previous<a id="_idIndexMarker093"/> chapter, we used the <code>onCreate(saveInstanceState: Bundle?)</code> method to display a layout in the UI of our screen. Now, we’ll explore in more detail how the Android system interacts with your application to make this happen. As soon as an Activity is launched, it goes through a series of steps to take it through initialization, from preparing to be displayed to being partially displayed and then fully displayed.</p>
			<p>There are also steps that correspond with your application being hidden, backgrounded, and then destroyed. This process is called the <strong class="bold">Activity lifecycle</strong>. For every one of these steps, there<a id="_idIndexMarker094"/> is a <strong class="bold">callback</strong> that your Activity can use to perform actions such as creating and changing the display and saving data when your app has been put into the background and then restoring that data after your app comes back into the foreground.</p>
			<p>These callbacks are made on your Activity’s parent, and it’s up to you to decide whether you need to implement them in your own Activity to take any corresponding action. Each of these callback functions has the <code>override</code> keyword. The <code>override</code> keyword in Kotlin means that either this function is providing an implementation of an interface or an abstract method, or, in the case of your Activity here, which is a subclass, it is providing the implementation that will override its parent.</p>
			<p>Now that you know how the Activity lifecycle works in general, let’s go into more detail about the principal callbacks you will work with in order, from creating an Activity to the Activity being destroyed:</p>
			<ul>
				<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>: This is the callback that you will use the most for activities that draw a full-sized screen. It’s here where you prepare your Activity layout to be displayed. At this stage, after the method has completed, it is still not displayed to the user, although it will appear that way if you don’t implement any other callbacks. You usually set up the UI of your Activity here by calling the <code>setContentView(R.layout.activity_main)</code> method and carrying out any initialization that is required.</li>
			</ul>
			<p>This method is only called once in its lifecycle unless the Activity is created again. This happens by default for some actions (such as rotating the phone from portrait to landscape orientation). The <code>savedInstanceState</code> parameter of the <code>Bundle?</code> type (<code>?</code> means the type can be null) in its simplest form is a map of key-value pairs optimized to save and restore data.</p>
			<p>It will be <a id="_idIndexMarker095"/>null if this is the first time that the Activity has been run after the app has started, if the Activity is being created for the first time, or if the Activity is being recreated without any states being saved.</p>
			<ul>
				<li><code>override fun onRestart()</code>: When the Activity restarts, this is called immediately before <code>onStart()</code>. It is important to be clear about the difference between restarting an Activity and recreating an activity. When the Activity is backgrounded by pressing the home button, when it comes back into the foreground again <code>onRestart()</code> will be called. Recreating an Activity is what happens when a configuration change happens, such as the device being rotated. The Activity is finished and then created again, in which case <code>onRestart()</code> will not be called.</li>
				<li><code>override fun onStart()</code>: This is the first callback made when the Activity is brought from the background to the foreground.</li>
				<li><code>override fun onRestoreInstanceState(savedInstanceState: Bundle?)</code>: If the state has been saved using <code>onSaveInstanceState(outState: Bundle?)</code>, this is the method that the system calls after <code>onStart()</code> where you can retrieve the <code>Bundle</code> state instead of restoring the state using <code>onCreate(savedInstanceState: Bundle?)</code>.</li>
				<li><code>override fun onResume()</code>: This callback is run as the final stage of creating an Activity for the first time, and also when the app has been backgrounded and then is brought into the foreground. Upon the completion of this callback, the screen/activity is ready to be used, receive user events, and be responsive.</li>
				<li><code>override fun onSaveInstanceState(outState: Bundle?)</code>: If you want to save the state of the activity, this function can do so. You add key-value pairs using one of the convenience functions depending on the data type. The data will then be available if your Activity is recreated in <code>onCreate(saveInstanceState: Bundle?)</code> and <code>onRestoreInstanceState(savedInstanceState: Bundle?)</code>.</li>
				<li><code>override fun onPause()</code>: This function is called when the Activity starts to be backgrounded or another dialog or Activity comes into the foreground.</li>
				<li><code>override fun onStop()</code>: This function is called when the Activity is hidden, either <a id="_idIndexMarker096"/>because it is being backgrounded or another Activity is being launched on top of it.</li>
				<li><code>override fun onDestroy()</code>: This is called by the system to kill the Activity when system resources are low, when <code>finish()</code> is called explicitly on the Activity, or, more commonly, when the Activity is killed by the user closing the app from the recents/overview button.</li>
			</ul>
			<p>The flow of callbacks/events is illustrated in the following diagram:</p>
			<div><div><img src="img/B19411_02_01.jpg" alt="Figure 2.1 – Activity lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Activity lifecycle</p>
			<p>Now that <a id="_idIndexMarker097"/>you understand what these common lifecycle callbacks do, let’s implement them to see when they are call<a id="_idTextAnchor114"/><a id="_idTextAnchor115"/>ed.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor116"/>Exercise 2.01 – logging the Activity Callbacks</h2>
			<p>Create an <a id="_idIndexMarker098"/>application called <code>Activity Callbacks</code> with an empty Activity. The aim of this exercise is to log the Activity callbacks and the order that they occur for common operations:</p>
			<ol>
				<li>In order to verify the order of the callbacks, let’s add a log statement at the end of each callback. Open up <code>MainActivity</code>  and prepare the Activity for logging by adding <code>import android.util.Log</code> to the <code>import</code> statements. Then, add a constant to the class to identify your Activity. Constants in Kotlin are identified by the <code>const</code> keyword and can be declared at the top level (outside the class) or in an object within the class.</li>
			</ol>
			<p>Top-level constants are generally used if they are required to be public. For private constants, Kotlin provides a convenient way to add static functionality to classes by declaring a companion object. Add the following at the bottom of the class below <code>onCreate(savedInstanceState: Bundle?)</code>:</p>
			<pre class="source code">
companion object {
    private const val TAG = "MainActivity"
}</pre>
			<p>Then, add a log statement at the end of <code>onCreate(savedInstanceState: Bundle?)</code>:</p>
			<pre class="source code">
Log.d(TAG, "onCreate")</pre>
			<p>Our Activity should now have the following code:</p>
			<pre class="source code">
package com.example.activitycallbacks
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, "onCreate")
    }
    companion object {
        private const val TAG = "MainActivity"
    }
}</pre>
			<p><code>d</code> in the <a id="_idIndexMarker099"/>preceding log statement refers to <em class="italic">debug</em>. There are six different log levels that can be used to output message information from the least to most important – <code>v</code> for <em class="italic">verbose</em>, <code>d</code> for <em class="italic">debug</em>, <code>i</code> for <em class="italic">info</em>, <code>w</code> for <em class="italic">warn</em>, <code>e</code> for <em class="italic">error</em>, and <code>wtf</code> for <em class="italic">what a terrible failure</em> (this last log level highlights an exception that should never occur):</p>
			<pre class="source code">
Log.v(TAG, "verbose message")
Log.d(TAG, "debug message")
Log.i(TAG, "info message")
Log.w(TAG, "warning message")
Log.e(TAG, "error message")
Log.wtf(TAG, "what a terrible failure message")</pre>
			<ol>
				<li value="2">Now, let’s see how the logs are displayed in Android Studio. Open the <strong class="bold">Logcat</strong> window. It can be accessed by clicking on the <strong class="bold">Logcat</strong> tab at the bottom of the screen and also from the toolbar by going to <strong class="bold">View</strong> | <strong class="bold">Tool Windows</strong> | <strong class="bold">Logcat</strong>.</li>
				<li>Run the <a id="_idIndexMarker100"/>app on the virtual device and examine the <strong class="bold">Logcat</strong> window output. You should see the log statement you have added formatted like the following line in <em class="italic">Figure 2</em><em class="italic">.2</em>. If the <strong class="bold">Logcat</strong> window looks different, you might have to enable the newest version of <strong class="bold">Logcat</strong> by going to <strong class="bold">Android Studio</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Experimental</strong> and checking the box that says <strong class="bold">Enable New Logcat </strong><strong class="bold">Tool Window</strong>.</li>
			</ol>
			<div><div><img src="img/B19411_02_02.jpg" alt="Figure 2.2 – Log output in Logcat"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Log output in Logcat</p>
			<ol>
				<li value="4">Log statements can be quite difficult to interpret at first glance, so let’s break down the following statement into its separate parts:<pre class="source code">
2023-01-14 16:47:12.330 26715-26715/com.example.activitycallbacks/D/onCreate</pre></li>
			</ol>
			<p>Let’s examine the elements of the log statement in detail:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Fields</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Values</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Date</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>2023-01-14</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Time</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>16:47:12.330</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Process identifier and thread identifier (your app process ID and current </strong><strong class="bold">thread ID)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>26715-26715</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Class name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>MainActivity</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Package name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>com.example.activitycallbacks</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Log level</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>D (</code><code>for Debug)</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Log message</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>onCreate</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Table explaining a log statement</p>
			<p>By default, in the<a id="_idIndexMarker101"/> log filter (the text box above the log window), it says <code>package:mine</code>, which is your app logs. You can examine the output of the different log levels of all the processes on the device by changing the log filter from <code>level:debug</code> to other options in the drop-down menu. If you select <code>level:verbose</code>, as the name implies, you will see a lot of output.</p>
			<p>5.	What’s great about the <code>tag</code> option of the log statement is that it enables you to filter the log statements that are reported in the <code>tag</code> followed by the text of the tag, <code>tag:MainActivity</code>, as shown in <em class="italic">Figure 2</em><em class="italic">.4</em>:</p>
			<p class="IMG---Figure"><a id="_idTextAnchor117"/></p>
			<div><div><img src="img/B19411_02_03.jpg" alt="Figure 2.4 – Filtering log statements by the tag name"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Filtering log statements by the tag name</p>
			<p>So, if you are debugging an issue in your Activity, you can type in the tag name and add logs to your Activity to see the sequence of log statements. This is what you are going to do next by implementing the principal Activity callbacks and adding a log statement to each one to see when they are run.</p>
			<p>6.	Place your <a id="_idIndexMarker102"/>cursor on a new line after the closing brace of the <code>onCreate(savedInstanceState: Bundle?)</code> function and then add the <code>onRestart()</code> callback with a log statement. Make sure you call through to <code>super.onRestart()</code> so that the existing functionality of the Activity callback works as expected:</p>
			<pre class="source code">
override fun onRestart() {
    super.onRestart()
    Log.d(TAG, "onRestart")
}</pre>
			<p class="callout heading">Note</p>
			<p class="callout">In Android Studio, you can start typing the name of a function and autocomplete options will pop up with suggestions for functions to override. Alternatively, if you go to the top menu and then <strong class="bold">Code</strong> | <strong class="bold">Generate</strong> | <strong class="bold">Override methods</strong>, you can select the methods to override.</p>
			<p>Do this for all of the following callback functions:</p>
			<pre class="source code">
onCreate(savedInstanceState: Bundle?)
onRestart()
onStart()
onRestoreInstanceState(savedInstanceState: Bundle)
onResume()
onPause()
onStop()
onSaveInstanceState(outState: Bundle)
onDestroy()</pre>
			<p>7.	The<a id="_idIndexMarker103"/> completed activity will now override the callbacks with your implementation, which adds a log message. The following truncated code snippet shows a log statement in <code>onCreate(savedInstanceState: Bundle?)</code>. The complete class is available at <a href="https://packt.link/Lj2GT">https://packt.link/Lj2GT</a>:</p>
			<pre class="source code">
package com.example.activitycallbacks
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, "onCreate")
    }
    companion object {
        private const val TAG = "MainActivity"
    }
}</pre>
			<p>8.	Run the app, and then once it has loaded, as in <em class="italic">Figure 2</em><em class="italic">.5</em>, look at the <strong class="bold">Logcat</strong> output; you <a id="_idIndexMarker104"/>should see the following log statements (this is a shortened version):</p>
			<pre class="source code">
D/MainActivity: onCreate
D/MainActivity: onStart
D/MainActivity: onResume</pre>
			<p>The Activity has been created, started, and then prepared for the user to interact with<a id="_idTextAnchor118"/>:</p>
			<div><div><img src="img/B19411_02_04.jpg" alt="Figure 2.5 – The app loaded and displaying MainActivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The app loaded and displaying MainActivity</p>
			<p>9.	Press the round home button in the center of the navigation controls in the emulator window above the virtual device and background the app. Not all devices use<a id="_idIndexMarker105"/> the same three-button navigation of <em class="italic">back</em> (triangle icon), <em class="italic">home</em> (circle icon), and <em class="italic">recents/overview</em> (square icon). Gesture navigation can also be enabled so all these actions can be achieved by swiping and optionally holding. You should now see the following <strong class="bold">Logcat</strong> output:</p>
			<pre class="source code">
D/MainActivity: onPause
D/MainActivity: onStop
D/MainActivity: onSaveInstanceState</pre>
			<p>For apps that target versions below Android Pie (API 28), <code>onSaveInstanceState(outState: Bundle)</code> may also be called before <code>onPause()</code> or <code>onStop()</code>.</p>
			<p>10.	Now, bring the app back into the foreground by pressing the recents/overview square button in the emulator controls and selecting the app. You should now see the following:</p>
			<pre class="source code">
D/MainActivity: onRestart
D/MainActivity: onStart
D/MainActivity: onResume</pre>
			<p>The Activity has been restarted. You might have noticed that the <code>onRestoreInstance</code><strong class="source inline">
State(savedInstanceState: Bundle)</strong> function was not called. This is because the Activity was not destroyed and recreated.</p>
			<p>11.	Press the recents/overview square button again and then swipe the app image upward to kill the activity. This is the output:</p>
			<pre class="source code">
D/MainActivity: onPause
D/MainActivity: onStop
D/MainActivity: onDestroy</pre>
			<p>12.	Launch <a id="_idIndexMarker106"/>your app again and then rotate the phone. You might find that the phone does not rotate, and the display is sideways. If this happens, drag down the status bar at the very top of the virtual device, look for a button with a rectangular icon with arrows called <strong class="bold">Auto-rotate</strong>, and select i<a id="_idTextAnchor119"/>t.</p>
			<div><div><img src="img/B19411_02_05.jpg" alt="Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected</p>
			<p>You should see the following callbacks:</p>
			<pre class="source code">
D/MainActivity: onCreate
D/MainActivity: onStart
D/MainActivity: onResume
D/MainActivity: onPause
D/MainActivity: onStop
D/MainActivity: onSaveInstanceState
D/MainActivity: onDestroy
D/MainActivity: onCreate
D/MainActivity: onStart
D/MainActivity: onRestoreInstanceState
D/MainActivity: onResume</pre>
			<p>Please note that as stated in step 9, the order of the <code>onSaveInstanceState(outState: Bundle)</code> callback may vary.</p>
			<p>Configuration<a id="_idIndexMarker107"/> changes, such as rotating the phone, by default recreate the activity. You can choose not to handle certain configuration changes in the app, which will then not recreate the activity.</p>
			<p>13.	To not recreate the activity for rotation, add <code>android:configChanges=</code><strong class="source inline">
"orientation|screenSize|screenLayout"</strong> to <code>MainActivity</code> in the <code>AndroidManifest.xml</code> file. Launch the app and then rotate the phone, and these are the only callbacks that you have added to <code>MainActivity</code> that you will see:</p>
			<pre class="source code">
D/MainActivity: onCreate
D/MainActivity: onStart
D/MainActivity: onResume</pre>
			<p>The <code>orientation</code> and <code>screenSize</code> values have the same function for different Android API levels for detecting screen orientation changes. The <code>screenLayout</code> value detects other layout changes that might occur on foldable phones.</p>
			<p>These are some of the config changes you can choose to handle yourself (another common one is <code>keyboardHidden</code> to react to changes in accessing the keyboard). The app will still be notified by the system of these changes through the following callback:</p>
			<pre class="source code">
override fun onConfigurationChanged(newConfig:
Configuration) {
    super.onConfigurationChanged(newConfig)
    Log.d(TAG, "onConfigurationChanged")
}</pre>
			<p>If you add this callback function to <code>MainActivity</code>, and you have added <code>android:</code><strong class="source inline">
configChanges="orientation|screenSize|screenLayout"</strong> to <code>Main</code><strong class="source inline">
Activity</strong> in the manifest, you will see it called on rotation.</p>
			<p>This<a id="_idIndexMarker108"/> approach of not restarting the activity is not recommended as the system will not apply alternative resources automatically. So, rotating a device from portrait to landscape won’t apply a suitable landscape layout.</p>
			<p>In this exercise, you have learned about the principal Activity callbacks and how they run when a user carries out common operations with your app through the system’s interaction with <code>MainActivity</code>. In the next section, we will cover saving the state and restoring it, as well as see more examples of how the Activity lifecycle wo<a id="_idTextAnchor120"/><a id="_idTextAnchor121"/>rks.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor122"/>Saving and restoring the Activity state</h1>
			<p>In this section, you’ll <a id="_idIndexMarker109"/>explore how your Activity saves and restores the state. As you’ve learned in the previous section, configuration changes, such as rotating the <a id="_idIndexMarker110"/>phone, cause the Activity to be recreated. This can also happen if the system has to kill your app in order to free up memory.</p>
			<p>In these scenarios, it is important to preserve the state of the Activity and then restore it. In the next two exercises, you’ll work through an example ensuring that the user’s data is restored when <code>TextView</code> is created and populated from a user’s data after filling in a<a id="_idTextAnchor123"/><a id="_idTextAnchor124"/> form.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor125"/>Exercise 2.02 – saving and restoring the state in layouts</h2>
			<p>In this exercise, firstly <a id="_idIndexMarker111"/>create an application called <code>Save and Restore</code> with an empty activity. The app you are going to create will have a simple form that offers a discount code for a user’s favorite restaurant if they enter some<a id="_idIndexMarker112"/> personal details (no actual information will be sent anywhere, so your data is safe):</p>
			<ol>
				<li>Open up the <code>strings.xml</code> file (located in <code>app</code> | <code>src</code> | <code>main</code> | <code>res</code> | <code>values</code> | <code>strings.xml</code>) and add the following strings that you’ll need for your app:<pre class="source code">
&lt;string name="header_text"&gt;Enter your name and email for a discount code at Your Favorite Restaurant!&lt;/string&gt;
    &lt;string name="first_name_label"&gt;First Name:&lt;/string&gt;
    &lt;string name="email_label"&gt;Email:&lt;/string&gt;
    &lt;string name="last_name_label"&gt;Last Name:&lt;/string&gt;
    &lt;string name="discount_code_button"&gt;GET DISCOUNT
        &lt;/string&gt;
    &lt;string name="discount_code_confirmation"&gt;Hey  %s! 
        Here is your discount code&lt;/string&gt;
    &lt;string name="add_text_validation"&gt;Please fill in all 
        form fields&lt;/string&gt;</pre></li>
				<li>In <code>R.layout.activity_main</code>, replace the contents with the following XML that creates a containing layout file and adds a <code>TextView</code> header with the text <code>Enter your name and email for a discount code at Your Favorite Restaurant!</code> This is done by adding the <code>android:text</code> attribute with the <code>@</code><code>string/header_text</code> value:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="4dp"
    android:layout_marginTop="4dp"
    tools:context=".MainActivity"&gt;
    &lt;TextView
        android:id="@+id/header_text"
        android:gravity="center"
        android:textSize="20sp"
        android:paddingStart="8dp"
        android:paddingEnd="8dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/header_text"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>You <a id="_idIndexMarker113"/>will see here that <code>android:textSize</code> is <a id="_idIndexMarker114"/>specified in <code>sp</code> which stands for Scale-independent pixels. This unit type represents the same values as density-independent pixels, which define the size measurement according to the density of the device that your app is being run on, and also change the text size according to the user’s preference, defined in <strong class="bold">Settings</strong> | <strong class="bold">Display</strong> | <strong class="bold">Font style</strong> (this might be <strong class="bold">Font size and style</strong> or something similar, depending on the exact device you are using).</p>
			<p>Other <a id="_idIndexMarker115"/>attributes in the layout affect positioning. The <a id="_idIndexMarker116"/>most common ones are padding and margin. Padding is applied on the inside of Views and is the space between the text and the border. Margins are specified on the outside of Views and are the space from the outer edges of Views. For example, <code>android:padding</code> sets the padding for the View with the specified value on all sides. Alternatively, you can specify the padding for one of the four sides of a View with <code>android:paddingTop</code>, <code>android:paddingBottom</code>, <code>android:paddingStart</code>, and <code>android:paddingEnd</code>. This pattern also exists to specify margins, so <code>android:layout_margin</code> specifies the margin value for all four sides of a View, and <code>android:layout_marginTop</code>, <code>android:layout_marginBottom</code>, <code>android:layout_marginStart</code>, and <code>android:layout_marginEnd</code> allow setting the margin for individual sides.</p>
			<p>In order to have consistency and uniformity throughout the app with these positioning values, you can define the margin and padding values as dimensions contained within a <code>dimens.xml</code> file so they can be used in multiple layouts. A dimension value of <code>&lt;dimen name="grid_4"&gt;4dp&lt;/dimen&gt;</code> can then be used as a View attribute like this: <code>android:paddingStart="@dimen/grid_4"</code>. To position the content within a View, you can specify <code>android:gravity</code>. The <code>center</code> value constrains the content both vertically and horizontally within the View.</p>
			<ol>
				<li value="3">Next, add three <code>EditText</code> views below <code>header_text</code> for the user to add their first name, last name, and email:<pre class="source code">
&lt;EditText
    android:id="@+id/first_name"
    android:textSize="20sp"
    android:layout_marginStart="24dp"
    android:layout_marginEnd="16dp"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:hint="@string/first_name_label"
    android:inputType="text"
    app:layout_constraintTop_toBottomOf="@id/header_text"
    app:layout_constraintStart_toStartOf="parent"
    /&gt;
&lt;EditText
    android:textSize="20sp"
    android:layout_marginEnd="24dp"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:hint="@string/last_name_label"
    android:inputType="text"
    app:layout_constraintTop_toBottomOf="@id/header_text"
    app:layout_constraintStart_toEndOf="@id/first_name"
    app:layout_constraintEnd_toEndOf="parent" /&gt;
&lt;!-- android:inputType="textEmailAddress" is not
enforced, but is a hint to the IME (Input Method
Editor) usually a keyboard to configure the
display for an email -typically by showing the '@'
symbol --&gt;
&lt;EditText
    android:id="@+id/email"
    android:textSize="20sp"
    android:layout_marginStart="24dp"
    android:layout_marginEnd="32dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:hint="@string/email_label"
    android:inputType="textEmailAddress"
    app:layout_constraintTop_toBottomOf="@id/first_name"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent" /&gt;</pre></li>
			</ol>
			<p>The <code>EditText</code> fields <a id="_idIndexMarker117"/>have an <code>inputType</code> attribute <a id="_idIndexMarker118"/>to specify the type of input that can be entered into the form field. Some values, such as <code>number</code> on <code>EditText</code>, restrict the input that can be entered into the field, and on selecting the field, suggest how the keyboard is displayed. Others, such as <code>android:inputType="textEmailAddress"</code>, will not enforce an <code>@</code> symbol being added to the form field, but will give a hint to the keyboard to display it.</p>
			<ol>
				<li value="4">Finally, add a button for the user to press to generate a discount code, a <code>TextView</code> to display <a id="_idIndexMarker119"/>the discount code, and a <code>TextView</code> for <a id="_idIndexMarker120"/>the confirmation message:<pre class="source code">
&lt;Button
    android:id="@+id/discount_button"
    android:textSize="20sp"
    android:layout_marginTop="12dp"
    android:gravity="center"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/discount_code_button"
    app:layout_constraintTop_toBottomOf="@id/email"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"/&gt;
&lt;TextView
    android:id="@+id/discount_code_confirmation"
    android:gravity="center"
    android:textSize="20sp"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:layout_marginTop="8dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@id/discount_
        button"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    tools:text="Hey John Smith! Here is your discount 
        code" /&gt;
&lt;TextView
    android:id="@+id/discount_code"
    android:gravity="center"
    android:textSize="20sp"
    android:textStyle="bold"
    android:layout_marginTop="8dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@id/discount_
        code_confirmation"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    tools:text="XHFG6H9O" /&gt;</pre></li>
			</ol>
			<p>There are <a id="_idIndexMarker121"/>also some attributes that you haven’t seen before. The <code>xmlns:tools="http://schemas.android.com/tools"</code> tools namespace, which <a id="_idIndexMarker122"/>was specified at the top of the XML layout file, enables certain features that can be used when creating your app to assist with configuration and design.</p>
			<p>The attributes are removed when you build your app, so they don’t contribute to the overall size of the app. You are using the <code>tools:text</code> attribute to show the text that will typically be displayed in the form fields. This helps when you switch to the <code>Design</code> view from viewing the XML in the <code>Code</code> view in Android Studio as you can see an approximation of how your layout displays on a device.</p>
			<ol>
				<li value="5">Run the app and you should see the output displayed in <em class="italic">Figure 2</em><em class="italic">.7</em>. The <strong class="bold">GET DISCOUNT</strong> button<a id="_idIndexMarker123"/> has <a id="_idIndexMarker124"/>not been enabled and so currently w<a id="_idTextAnchor126"/>ill not do anything.</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_06.jpg" alt="Figure 2.7 – The Activity screen on the first launch"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The Activity screen on the first launch</p>
			<ol>
				<li value="6">Enter some text into each <a id="_idTextAnchor127"/>of the form fields:</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_07.jpg" alt="Figure 2.8 – The EditText fields filled in"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The EditText fields filled in</p>
			<ol>
				<li value="7">Now, use the second rotate button in the virtual device controls (<img src="img/B19411_02_08.png" alt=""/>) to rotate the <a id="_idIndexMarker125"/>phone 90 deg<a id="_idTextAnchor128"/>rees <a id="_idIndexMarker126"/>to the right:</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_09.jpg" alt="Figure 2.9 – The virtual device turned to landscape orientation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The virtual device turned to landscape orientation</p>
			<p>Can <a id="_idIndexMarker127"/>you spot what has happened? The <code>EditText</code> fields, the Android framework will preserve the state of the fields if they have an ID set on them.</p>
			<ol>
				<li value="8">Go back to the <code>activity_main.xml</code> layout file and add an ID to the <code>Last Name</code> <code>EditText</code> which appears below the <code>First </code><code>Name</code> <code>EditText</code>:<pre class="source code">
&lt;EditText
    android:id="@+id/first_name"
&lt;EditText
    <strong class="bold">android:id="@+id/last_name"</strong>
    …</pre></li>
			</ol>
			<p>When you run up the app again and rotate the device, it will preserve the value you have entered. You’ve now seen that you need to set an ID on the <code>EditText</code> fields to preserve the state. For the <code>EditText</code> fields, it’s common to retain the state on a configuration change when the user is entering details into a form so that it is the default behavior if the field has an ID.</p>
			<p>Obviously, you want to get the details of the <code>EditText</code> field once the user has entered some text, which is why you set an ID, but setting an ID for other field types, such as <code>TextView</code>, does not retain the state if you update them and you need to save the state yourself. Setting IDs for Views that enable scrolling, such as <code>RecyclerView</code>, is also important as it enables the scroll position to be maintained when the Activity is recreated.</p>
			<p>Now, you <a id="_idIndexMarker129"/>have <a id="_idIndexMarker130"/>defined the layout for the screen, but you have not added any logic for creating and displaying the discount code. In the next exercise, we will work through this.</p>
			<p>The layout created in this exercise is available at <a href="https://packt.link/ZJleK">https://packt.link/ZJleK</a>.</p>
			<p>You can find the code for the entire exercise at <a href="https://packt.link/Kh0kR">https://packt.link/Kh0kR</a>.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor129"/>Exercise 2.03 – saving and restoring the state with Callbacks</h2>
			<p>The aim <a id="_idIndexMarker131"/>of this exercise is to bring all the UI elements in the<a id="_idIndexMarker132"/> layout together to generate a discount code after the user has entered their data. In order to do this, you will have to add logic to the button to retrieve all the <code>EditText</code> fields and then display a confirmation to the user, as well as generate a discount code:</p>
			<ol>
				<li>Open up <code>MainActivity.kt</code> and replace the contents with the following:<pre class="source code">
package com.example.saveandrestore
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.inputmethod.InputMethodManager
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import java.util.*
class MainActivity : AppCompatActivity() {
    private val discountButton: Button
        get() = findViewById(R.id.discount_button)
    private val firstName: EditText
        get() = findViewById(R.id.first_name)
    private val lastName: EditText
        get() = findViewById(R.id.last_name)
    private val email: EditText
        get() = findViewById(R.id.email)
    private val discountCodeConfirmation: TextView
        get() = findViewById(R.id.discount_code_
            confirmation)
    private val discountCode: TextView
        get() = findViewById(R.id.discount_code)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, "onCreate")
        // here we handle the Button onClick event
        discountButton.setOnClickListener {
            val firstName = firstName.text.toString().
                trim()
            val lastName = lastName.text.toString().
                trim()
            val email = email.text.toString()
            if (firstName.isEmpty() || lastName.isEmpty() 
            || email.isEmpty()) {
                Toast.makeText(this, getString(R.string.
                    add_text_validation), 
                    Toast.LENGTH_LONG)
                    .show()
            } else {
                val fullName = firstName.plus(" ")
                    .plus(lastName)
                discountCodeConfirmation.text =
                    getString(R.string.discount_code_
                    confirmation, fullName)
                // Generates discount code
                discountCode.text = UUID.randomUUID().
                    toString().take(8).uppercase()
                hideKeyboard()
            }
        }
    }
    private fun hideKeyboard() {
        if (currentFocus != null) {
            val imm = getSystemService(Context.INPUT_
                METHOD_SERVICE) as InputMethodManager
            imm.hideSoftInputFromWindow(currentFocus?.
                windowToken, 0)
        }
    }
    companion object {
        private const val TAG = "MainActivity"
    }
}</pre></li>
			</ol>
			<p><code>get() = …</code> is a custom accessor for a property.</p>
			<p>Upon clicking <a id="_idIndexMarker133"/>the discount button, you retrieve<a id="_idIndexMarker134"/> the values from the <code>first_name</code> and <code>last_name</code> fields, concatenate them with a space, and then use a string resource to format the discount code confirmation text. The string you reference in the <code>strings.xml</code> file is as follows:</p>
			<pre class="source code">
&lt;string name="discount_code_confirmation"&gt;Hey %s! Here
is your discount code&lt;/string&gt;</pre>
			<p>The <code>%s</code> value specifies a string value to be replaced when the string resource is retrieved. This is done by passing in the full name when getting the string:</p>
			<pre class="source code">
getString(R.string.discount_code_confirmation,
fullName)</pre>
			<p>The code is generated by using the <code>java.util</code> package. This creates a unique ID, and then the <code>take()</code> Kotlin function is used to get the first eight characters before setting these to uppercase. Finally, <code>discountCode</code> is set in the view, the keyboard is hidden, and<a id="_idIndexMarker135"/> all the form fields are set back to their initial values.</p>
			<ol>
				<li value="2">Run the app<a id="_idIndexMarker136"/> and enter some text into the name and email fields, and <a id="_idTextAnchor130"/>then click on <code>GET DISCOUNT</code>:</li>
			</ol>
			<div><div><img src="img/B19411_02_10.jpg" alt="Figure 2.10 – Screen displayed after the user has generated a discount code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Screen displayed after the user has generated a discount code</p>
			<p>The app <a id="_idIndexMarker137"/>behaves as expected, showing the confirmation.</p>
			<ol>
				<li value="3">Now, rotate the phone by pressing the second rotate button (<img src="img/B19411_02_081.png" alt=""/>) in the emulator contro<a id="_idTextAnchor131"/>ls and <a id="_idIndexMarker138"/>observe the result:</li>
			</ol>
			<div><div><img src="img/B19411_02_11.jpg" alt="Figure 2.11 – Discount code no longer displaying on the screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Discount code no longer displaying on the screen</p>
			<p>Oh, no! The <a id="_idIndexMarker139"/>discount code has gone. The <code>TextView</code> fields do not retain the state, so you will have to save the state yourself.</p>
			<ol>
				<li value="4">Go back<a id="_idIndexMarker140"/> into <code>MainActivity.kt</code> and add the following Activity callbacks:<pre class="source code">
override fun onRestoreInstanceState(savedInstanceState: Bundle) {
    super.onRestoreInstanceState(savedInstanceState)
    Log.d(TAG, "onRestoreInstanceState")
}
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    Log.d(TAG, "onSaveInstanceState")
}</pre></li>
			</ol>
			<p>These callbacks, as the names declare, enable you to save and restore the instance state. <code>on</code><strong class="source inline">
SaveInstanceState(outState: Bundle)</strong> allows you to add key-value pairs from your Activity when it is being backgrounded or destroyed, which you can retrieve in either <code>onCreate(savedInstanceState: Bundle?)</code> or <code>onRestoreInstanceState</code><strong class="source inline">
(</strong><code>savedInstanceState: Bundle)</code>.</p>
			<p>So, you <a id="_idIndexMarker141"/>have two callbacks to retrieve the state once it has been set. If you are doing a lot of initialization in <code>onCreate(savedInstanceState: Bundle)</code>, it might be better to use <code>onRestoreInstanceState(savedInstanceState: Bundle)</code> to retrieve this instance state when your Activity is being recreated. In this way, it’s clear which state is being recreated. However, you might prefer to use <code>onCreate(savedInstanceState: Bundle)</code> if there is minimal setup required.</p>
			<p>Whichever of <a id="_idIndexMarker142"/>the two callbacks you decide to use, you will have to get the state you set in the <code>onSaveInstanceState(outState: Bundle)</code> call. For the next step in the exercise, you will use <code>onRestoreInstanceState(savedInstanceState: Bundle)</code>.</p>
			<ol>
				<li value="5">Add two constants to the <code>MainActivity</code> companion object, which is at the bottom of <code>MainActivity</code>:<pre class="source code">
private const val DISCOUNT_CONFIRMATION_MESSAGE =
"DISCOUNT_CONFIRMATION_MESSAGE"
private const val DISCOUNT_CODE = "DISCOUNT_CODE"</pre></li>
				<li>Now, add these constants as keys for the values you want to save and retrieve and make the following changes to the Activity in the <code>onSaveInstanceState(outState: Bundle)</code> and <code>onRestoreInstanceState(savedInstanceState: </code><code>Bundle)</code> functions.<pre class="source code">
override fun onRestoreInstanceState(savedInstanceState: Bundle) {
    super.onRestoreInstanceState(savedInstanceState)
    Log.d(TAG, "onRestoreInstanceState")
    // Get the discount code or an empty string if it 
       hasn't been set
    discountCode.text = savedInstanceState.
        getString(DISCOUNT_CODE,"")
    // Get the discount confirmation message or an empty 
       string if it hasn't been set
    discountCodeConfirmation.text = savedInstanceState.
        getString(DISCOUNT_CONFIRMATION_MESSAGE,"")
}
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    Log.d(TAG, "onSaveInstanceState")
    outState.putString(DISCOUNT_CODE, discountCode.text.
    toString())
    outState.putString(DISCOUNT_CONFIRMATION_MESSAGE, 
    discountCodeConfirmation.text.toString())
}</pre></li>
				<li>Run the<a id="_idIndexMarker143"/> app, enter the values into the <code>EditText</code> fields, and <a id="_idIndexMarker144"/>then generate a discount code. Then, rotate the device and you will see that the discount <a id="_idTextAnchor132"/>code is restored in <em class="italic">Figure 2</em><em class="italic">.12</em>:</li>
			</ol>
			<div><div><img src="img/B19411_02_12.jpg" alt="Figure 2.12 – Discount code continues to be displayed on the screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Discount code continues to be displayed on the screen</p>
			<p>In this<a id="_idIndexMarker145"/> exercise, you first saw how the state of the <code>EditText</code> fields is <a id="_idIndexMarker146"/>maintained on configuration changes. You also saved and restored the instance state using the Activity lifecycle <code>onSaveInstanceState(outState: Bundle)</code> and <code>onCreate(savedInstanceState: Bundle?)</code>/<code>onRestoreInstanceState(savedInstanceState: Bundle)</code> functions. These functions provide a way to save and restore simple data. The Android framework also provides <code>ViewModel</code>, an Android architecture component that is lifecycle-aware. The mechanisms of how to save and restore this state (with <code>ViewModel</code>) are managed by the framework, so you don’t have to explicitly manage it as you have done in the preceding example. You will learn how to use this component in <a href="B19411_11.xhtml#_idTextAnchor582"><em class="italic">Chapter 11</em></a>, <em class="italic">Android </em><em class="italic">Architecture Components</em>.</p>
			<p>The complete code for this exercise can be found here: <a href="https://packt.link/zsGW3">https://packt.link/zsGW3</a>.</p>
			<p>In the next section, you will add another Activity to an app an<a id="_idTextAnchor133"/><a id="_idTextAnchor134"/>d navigate between the activities.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor135"/>Activity interaction with Intents</h1>
			<p>An intent in <a id="_idIndexMarker147"/>Android is a communication mechanism between components. Within your own app, a lot of the time, you will want another specific Activity to start <a id="_idIndexMarker148"/>when some action happens in the current activity. Specifying exactly which Activity will start is called <a id="_idIndexMarker149"/>an <code>AndroidManifest.xml</code> file from the previous exercise and you will see an example of two intent filters set within the <code>&lt;intent-filter&gt;</code> XML element of the <code>MainActivity</code>:</p>
			<pre class="source code">
&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN"/&gt;
    &lt;category android:name="android.intent.category. LAUNCHER"/&gt;
&lt;/intent-filter&gt;</pre>
			<p>The one specified with <code>&lt;action android:name="android.intent.action.MAIN" /&gt;</code> means that this is the main entry point into the app. Depending on which category is set, it governs which Activity first starts when the app is started. The other intent filter that is specified is <code>&lt;category android:name="android.intent.category.LAUNCHER" /&gt;</code>, which defines that the app should appear in the launcher. When combined, the two intent filters define that when the app is started from the launcher, <code>MainActivity</code> should be started. Removing the <code>&lt;action android:name="android.intent.action.MAIN" /&gt;</code> intent filter results in the <code>"Error running 'app': Default Activity not found"</code> message. As the app has not got a main entry point, it can’t be launched. If you remove <code>&lt;category android:name="android.intent.category.LAUNCHER" /&gt;</code> then there is nowhere that it can be launched from.</p>
			<p>For the next exercise, you will see how int<a id="_idTextAnchor136"/><a id="_idTextAnchor137"/>ents work to navigate around your app.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor138"/>Exercise 2.04 – an introduction to Intents</h2>
			<p>The goal of<a id="_idIndexMarker151"/> this exercise is to create a simple app that uses intents to display text to the user based on their input:</p>
			<ol>
				<li>Create a new project in Android Studio called <code>Intents Introduction</code> and select an empty Activity. Once you have set up the project, go to the toolbar and select <code>File</code> | <code>New</code> | <code>Activity</code> | <code>Empty</code> <code>Activity</code>. Call it <code>WelcomeActivity</code> and leave all the other defaults as they are. It will be added to the <code>AndroidManifest.xml</code> file, ready to use. The issue you have now that you’ve added <code>WelcomeActivity</code> is knowing how to do anything with it. <code>MainActivity</code> starts when you launch the app, but you need a way to launch <code>WelcomeActivity</code> and then, optionally, pass data to it, which is when you use intents.</li>
				<li>In order to work through this example, add the following strings to the <code>strings.xml</code> file.<pre class="source code">
    &lt;string name="header_text"&gt;Please enter your name and 
        then we\'ll get started!&lt;/string&gt;
    &lt;string name="welcome_text"&gt;Hello %s, we hope you 
        enjoy using the app!&lt;/string&gt;
    &lt;string name="full_name_label"&gt;Enter your full 
        name:&lt;/string&gt;
    &lt;string name="submit_button_text"&gt;SUBMIT&lt;/string&gt;</pre></li>
				<li>Next, change the <code>MainActivity</code> layout in <code>activity_main.xml</code> and replace the content with the following code to add an <code>EditText</code> and a <code>Button</code>:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:padding="28dp"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;EditText
        android:id="@+id/full_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="28sp"
        android:hint="@string/full_name_label"
        android:layout_marginBottom="24dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/&gt;
    &lt;Button
        android:id="@+id/submit_button"
        android:textSize="24sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/submit_button_text"
        app:layout_constraintTop_toBottomOf="@id/full_
            name"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"/&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>The a<a id="_idTextAnchor139"/>pp, when<a id="_idIndexMarker152"/> run, looks as in <em class="italic">Figure 2</em><em class="italic">.13</em>:</p>
			<div><div><img src="img/B19411_02_13.jpg" alt="Figure 2.13 – The app display after adding the EditText full name field and SUBMIT button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – The app display after adding the EditText full name field and SUBMIT button</p>
			<p>You now need to configure the button so that when it’s clicked, it retrieves the user’s full name from the <code>EditText</code> field and then sends it in an intent, which starts <code>WelcomeActivity</code>.</p>
			<ol>
				<li value="4">Update the <code>activity_welcome.xml</code> layout <a id="_idIndexMarker153"/>file to prepare to do this:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".WelcomeActivity"&gt;
    &lt;TextView
        android:id="@+id/welcome_text"
        android:textSize="24sp"
        android:padding="24sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        tools:text="Welcome John Smith we hope you enjoy 
            using the app!"/&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>You are adding a <code>TextView</code> field to display the full name of the user with a welcome message. The logic to create the full name and welcome message will be shown in the next step.</p>
			<ol>
				<li value="5">Now, open <code>MainActivity</code> and add a <a id="_idIndexMarker154"/>constant value above the class header and update the imports:<pre class="source code">
<strong class="bold">package com.example.intentsintroduction</strong>
<strong class="bold">import android.content.Intent</strong>
<strong class="bold">import android.os.Bundle</strong>
<strong class="bold">import android.widget.Button</strong>
<strong class="bold">import android.widget.EditText</strong>
<strong class="bold">import android.widget.Toast</strong>
<strong class="bold">import androidx.appcompat.app.AppCompatActivity</strong>
<strong class="bold">const val FULL_NAME_KEY = "FULL_NAME_KEY"</strong>
class MainActivity : AppCompatActivity(){
…
}</pre></li>
			</ol>
			<p>You will use the constant to set the key to hold the full name of the user by setting it in the intent.</p>
			<ol>
				<li value="6">Then, add the following code to the bottom of <code>onCreate(savedInstanceState: Bundle?)</code>:<pre class="source code">
findViewById&lt;Button&gt;(R.id.submit_button).setOnClickListener {
    val fullName = findViewById&lt;EditText&gt;(R.id.full_
        name).text.toString()
    if (fullName.isNotEmpty()) {
        // Set the name of the Activity to launch
        val welcomeIntent = Intent(this,
            WelcomeActivity::class.java)
        welcomeIntent.putExtra(FULL_NAME_KEY,
            fullName)
        startActivity(welcomeIntent)
    } else {
        Toast.makeText(this, getString(
            R.string.full_name_label),
            Toast.LENGTH_LONG).show()
    }
}</pre></li>
			</ol>
			<p>There is logic to <a id="_idIndexMarker155"/>retrieve the value of the full name and verify that the user has filled this in; otherwise, a pop-up toast message will be shown if it’s blank. The main logic, however, takes the <code>fullName</code> value of the <code>EditText</code> field and creates an explicit intent to start <code>WelcomeActivity</code>, and then puts an <code>Extra</code>  key with a value into the Intent. The last step is to use the intent to start <code>WelcomeActivity</code>.</p>
			<ol>
				<li value="7">Now, run the app, enter your name, a<a id="_idTextAnchor140"/>nd press <strong class="bold">SUBMIT</strong>, as shown in <em class="italic">Figure 2</em><em class="italic">.14</em>:</li>
			</ol>
			<div><div><img src="img/B19411_02_14.jpg" alt="Figure 2.14 – The default screen displayed when the intent extras data is not processed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – The default screen displayed when the intent extras data is not processed</p>
			<p>Well, that’s <a id="_idIndexMarker156"/>not very impressive. You’ve added the logic to send the user’s name, but not to display it.</p>
			<ol>
				<li value="8">To enable this, please open <code>WelcomeActivity</code> and add the import <code>import android.widget.TextView</code> to the imports list and add the following to the bottom of <code>onCreate(savedInstanceState: Bundle?)</code>:<pre class="source code">
if (intent != null) {
    val fullName = intent.getStringExtra(FULL_NAME_KEY)
    findViewById&lt;TextView&gt;(R.id.welcome_text).text = 
        getString(R.string.welcome_text, fullName)
}</pre></li>
			</ol>
			<p>We check<a id="_idIndexMarker157"/> that the intent that started the Activity is not null and then retrieve the string value that was passed from the <code>MainActivity</code> intent by getting the string <code>FULL_NAME_KEY</code> extra key. We then format the <code>&lt;string name="welcome_text"&gt;Hello %s, we hope you enjoy using the app!&lt;/string&gt;</code> resource string by getting the string from the resources and passing in the <code>fullname</code> value retrieved from the intent. Finally, this is set as the text of <code>TextView</code>.</p>
			<ol>
				<li value="9">Run the app again, and a simple gree<a id="_idTextAnchor141"/>ting will be displayed, as in <em class="italic">Figure 2</em><em class="italic">.15</em>:</li>
			</ol>
			<div><div><img src="img/B19411_02_15.jpg" alt="Figure 2.15 – User welcome message displayed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – User welcome message displayed</p>
			<p>This exercise, although very simple in terms of layouts and user interaction, allows the demonstration of some core principles of intents. You will use them to add navigation and create user flows from one section of your app to another. In the next section, you will see how you can use intents to launch an A<a id="_idTextAnchor142"/><a id="_idTextAnchor143"/>ctivity and receive a result back from it.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor144"/>Exercise 2.05 – retrieving a result from an Activity</h2>
			<p>For <a id="_idIndexMarker158"/>some user flows, you will only launch an Activity for the sole purpose of retrieving a result back from it. This pattern is often used to ask permission to use a particular feature, popping up a dialog with a question about whether the user gives their permission to access contacts, the calendar, and so on, and then reporting the result of yes or no back to the calling Activity. In this exercise, you will ask the user to pick their favorite color of the rainbow, and then once that is chosen, display the result in the calling activity:</p>
			<ol>
				<li>Create a new project named <code>Activity Results</code> with an empty activity and add the following strings to the <code>strings.xml</code> file:<pre class="source code">
&lt;string name="header_text_main"&gt;Please click the button below to choose your favorite color of the rainbow!&lt;/string&gt;
&lt;string name="header_text_picker"&gt;Rainbow Colors&lt;/string&gt;
&lt;string name="footer_text_picker"&gt;Click the button above which is your favorite color of the rainbow.&lt;/string&gt;
&lt;string name="color_chosen_message"&gt;%s is your favorite color!&lt;/string&gt;
&lt;string name="submit_button_text"&gt;CHOOSE COLOR&lt;/string&gt;
&lt;string name="red"&gt;RED&lt;/string&gt;
&lt;string name="orange"&gt;ORANGE&lt;/string&gt;
&lt;string name="yellow"&gt;YELLOW&lt;/string&gt;
&lt;string name="green"&gt;GREEN&lt;/string&gt;
&lt;string name="blue"&gt;BLUE&lt;/string&gt;
&lt;string name="indigo"&gt;INDIGO&lt;/string&gt;
&lt;string name="violet"&gt;VIOLET&lt;/string&gt;
&lt;string name="unexpected_color"&gt;Unexpected color&lt;/string&gt;</pre></li>
				<li>Add the<a id="_idIndexMarker159"/> following colors to <code>colors.xml</code>:<pre class="source code">
    &lt;!--Colors of the Rainbow --&gt;
    &lt;color name="red"&gt;#FF0000&lt;/color&gt;
    &lt;color name="orange"&gt;#FF7F00&lt;/color&gt;
    &lt;color name="yellow"&gt;#FFFF00&lt;/color&gt;
    &lt;color name="green"&gt;#00FF00&lt;/color&gt;
    &lt;color name="blue"&gt;#0000FF&lt;/color&gt;
    &lt;color name="indigo"&gt;#4B0082&lt;/color&gt;
    &lt;color name="violet"&gt;#9400D3&lt;/color&gt;</pre></li>
				<li>Now, you have to set up the Activity that will set the result you receive in <code>MainActivity</code>. Go to <code>RainbowColorPickerActivity</code>.</li>
				<li>Update the <code>activity_main.xml</code> layout file to display a header, a button, and then a hidden <code>android:visibility="gone"</code> View, which will be made visible and set with the user’s favorite color of the rainbow when the result is reported:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;TextView
        android:id="@+id/header_text"
        android:textSize="20sp"
        android:padding="10dp"
        android:gravity="center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/header_text_main"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"/&gt;
    &lt;Button
        android:id="@+id/submit_button"
        android:textSize="18sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/submit_button_text"
        app:layout_constraintTop_toBottomOf="@id/header_
            text"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"/&gt;
    &lt;TextView
        android:id="@+id/rainbow_color"
        android:layout_width="320dp"
        android:layout_height="50dp"
        android:layout_margin="12dp"
        android:textSize="22sp"
        android:textColor="@android:color/white"
        android:gravity="center"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toBottomOf="@id/submit_
            button"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:text="BLUE is your favorite color"
        tools:background="@color/blue"/&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
				<li>You’ll be <a id="_idIndexMarker160"/>using the <code>registerForActivityResult(ActivityResultContracts.StartActivityForResult())</code> function to get a result back from the Activity you launch. Add two constant keys for the values we want to use in the intent, as well as a default color constant above the class header in <code>MainActivity</code>, and update the imports so it is displayed as follows with the package name and imports:<pre class="source code">
package com.example.activityresults
<strong class="bold">import android.content.Intent</strong>
<strong class="bold">import android.graphics.Color</strong>
<strong class="bold">import android.os.Bundle</strong>
<strong class="bold">import android.widget.Button</strong>
<strong class="bold">import android.widget.TextView</strong>
<strong class="bold">import androidx.activity.result.contract.ActivityResultContracts</strong>
<strong class="bold">import androidx.appcompat.app.AppCompatActivity</strong>
<strong class="bold">import androidx.core.content.ContextCompat</strong>
<strong class="bold">import androidx.core.view.isVisible</strong>
<strong class="bold">const val RAINBOW_COLOR_NAME = "RAINBOW_COLOR_NAME" // Key to return rainbow color name in intent</strong>
<strong class="bold">const val RAINBOW_COLOR = "RAINBOW_COLOR" // Key to return rainbow color in intent</strong>
<strong class="bold">const val DEFAULT_COLOR = "#FFFFFF" // White</strong>
class MainActivity : AppCompatActivity()…</pre></li>
				<li>Then, create a property<a id="_idIndexMarker161"/> below the class header that is used to both launch the new activity and return a result from it:<pre class="source code">
private val startForResult =
    registerForActivityResult(ActivityResultContracts.
    StartActivityForResult()) { activityResult -&gt;
        val data = activityResult.data
        val backgroundColor = data?.getIntExtra(RAINBOW_
            COLOR, Color.parseColor(DEFAULT_COLOR))
            ?: Color.parseColor(DEFAULT_COLOR)
        val colorName = data?.getStringExtra(RAINBOW_
            COLOR_NAME) ?: ""
        val colorMessage = getString(R.string.color_
            chosen_message, colorName)
        val rainbowColor = findViewById&lt;TextView&gt;(R.
            id.rainbow_color)
        rainbowColor.setBackgroundColor(ContextCompat.
        getColor(this, backgroundColor))
        rainbowColor.text = colorMessage
        rainbowColor.isVisible = true
    }</pre></li>
			</ol>
			<p>Once the<a id="_idIndexMarker162"/> result is returned, you can proceed to query the intent data for the values you are expecting. For this exercise, we want to get the background color name (<code>colorName</code>) and the hexadecimal value of the color (<code>backgroundColor</code>) so that we can display it. The <code>?</code> operator checks whether the value is null (that is, not set in the intent), and if so, the Elvis operator (<code>?:</code>) sets the default value. The color message uses string formatting to set a message, replacing the placeholder in the resource value with the color name. Now that you’ve got the colors, you can make the <code>rainbow_color</code> <code>TextView</code> field visible and set the background color of the View to <code>backgroundColor</code> and add text displaying the name of the user’s favorite color of the rainbow.</p>
			<ol>
				<li value="7">First, add the <a id="_idIndexMarker163"/>logic to launch the Activity from the property defined previously by  adding the following to the bottom of <code>onCreate(savedInstanceState: Bundle?)</code>::<pre class="source code">
    findViewById&lt;Button&gt;(R.id.submit_button)
    .setOnClickListener {
        startForResult.launch(Intent(this,
        RainbowColorPickerActivity::class.java)
        )
    }</pre></li>
			</ol>
			<p>This creates an Intent that is launched for its result: <code>Intent(this</code>, <code>RainbowColor</code><strong class="source inline">
</strong><code>PickerActivity::class.java)</code>.</p>
			<ol>
				<li value="8">For the layout of the <code>RainbowColorPickerActivity</code> activity, you are going to display a button with a background color and color name for each of the seven colors of the rainbow: <code>RED</code>, <code>ORANGE</code>, <code>YELLOW</code>, <code>GREEN</code>, <code>BLUE</code>, <code>INDIGO</code>, and <code>VIOLET</code>. These will be displayed in a <code>LinearLayout</code> vertical list. For most of the layout files in the book, you will be using <code>ConstraintLayout</code>, as it provides fine-grained positioning of individual Views. For situations where you need to display a vertical or horizontal list of a small number of items, <code>LinearLayout</code> is also a good choice. If you need to display a large number of items, then <code>RecyclerView</code> is a better option as it can cache layouts for individual rows and recycle views that are no longer displayed on the screen. You will learn about <code>RecyclerView</code> in <a href="B19411_06.xhtml#_idTextAnchor353"><em class="italic">Chapter </em><em class="italic">6</em></a>, <em class="italic">RecyclerView</em>.</li>
				<li>The first thing you need to do in <code>RainbowColorPickerActivity</code> is create the layout. This will be where you present the user with the option to choose their favorite color of the rainbow.</li>
				<li>Open <code>activity_rainbow_color_picker.xml</code> and replace the layout, inserting the following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ScrollView xmlns:android=
    "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"&gt;
&lt;/ScrollView&gt;</pre></li>
			</ol>
			<p>We<a id="_idIndexMarker164"/> are adding <code>ScrollView</code> to allow the contents to scroll if the screen height cannot display all of the items. <code>ScrollView</code> can only take one child View, which is the layout to scroll.</p>
			<ol>
				<li value="11">Next, add <code>LinearLayout</code> within <code>ScrollView</code> to display the contained views in the order that they are added with a header and a footer. The first child View is a header with the title of the page and the last View that is added is a footer with instructions for the user to pick their favorite color:<pre class="source code">
&lt;LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center_horizontal"
    android:orientation="vertical"
    tools:context=".RainbowColorPickerActivity"&gt;
    &lt;TextView
        android:id="@+id/header_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        android:padding="10dp"
        android:text="@string/header_text_picker"
        android:textAllCaps="true"
        android:textSize="24sp"
        android:textStyle="bold"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;TextView
        android:layout_width="380dp"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:padding="10dp"
        android:text="@string/footer_text_picker"
        android:textSize="20sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>The layo<a id="_idTextAnchor145"/>ut<a id="_idIndexMarker165"/> should now look as in <em class="italic">Figure 2</em><em class="italic">.16</em> in the app:</p>
			<div><div><img src="img/B19411_02_16.jpg" alt="Figure 2.16 – Rainbow colors screen with a header and footer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Rainbow colors screen with a header and footer</p>
			<ol>
				<li value="12">Now, finally, add<a id="_idIndexMarker166"/> the button views between the header and the footer to select a color of the rainbow, and then run the app (the following code only displays the first button ). The full layout is available at <a href="https://packt.link/ZgdHX">https://packt.link/ZgdHX</a>:<pre class="source code">
    &lt;Button
        android:id="@+id/red_button"
        android:layout_width="120dp"
        android:layout_height="wrap_content"
        android:backgroundTint="@color/red"
        android:text="@string/red" /&gt;</pre></li>
			</ol>
			<p>These buttons are displayed in the order of the colors of the rainbow with the color text and background. The XML <code>id</code> attribute is what you will use in the Activity to<a id="_idIndexMarker167"/> prepare the result of what is returned to the calling activity.</p>
			<ol>
				<li value="13">Now, open <code>RainbowColorPickerActivity</code> and replace the content with the following:<pre class="source code">
package com.example.activityresults
import android.app.Activity
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import android.widget.Toast
class RainbowColorPickerActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_rainbow_color_
            picker)
    }
    private fun setRainbowColor(colorName: String, color: 
    Int) {
        Intent().let { pickedColorIntent -&gt;
            pickedColorIntent.putExtra(RAINBOW_COLOR_
                NAME, colorName)
            pickedColorIntent.putExtra(RAINBOW_COLOR, 
                color)
            setResult(Activity.RESULT_OK, 
                pickedColorIntent)
            finish()
        }
    }
}</pre></li>
			</ol>
			<p>The <code>setRainbowColor</code>  function creates an intent and adds the rainbow color name<a id="_idIndexMarker168"/> and the rainbow color <code>hex</code> value as String extras. The result is then returned to the calling Activity, and as you have no further use for this Activity, you call <code>finish()</code> so that the calling Activity is displayed. The way that you retrieve the rainbow color that the user has chosen is by adding a listener for all the buttons in the layout.</p>
			<ol>
				<li value="14">Now, add the following to the bottom of <code>onCreate(savedInstanceState: Bundle?)</code>:<pre class="source code">
val colorPickerClickListener = View.OnClickListener { view -&gt;
    when (view.id) {
        R.id.red_button -&gt; setRainbowColor(getString(R.
            string.red), R.color.red)
        R.id.orange_button -&gt; setRainbowColor(getString(R.
            string.orange), R.color.orange)
        R.id.yellow_button -&gt; setRainbowColor(getString(R.
            string.yellow), R.color.yellow)
        R.id.green_button -&gt; setRainbowColor(getString(R.
            string.green), R.color.green)
        R.id.blue_button -&gt; setRainbowColor(getString(R.
            string.blue), R.color.blue)
        R.id.indigo_button -&gt; setRainbowColor(getString(R.
            string.indigo), R.color.indigo)
        R.id.violet_button -&gt; setRainbowColor(getString(R.
            string.violet), R.color.violet)
        else -&gt; {
            Toast.makeText(this, getString(R.string.
                unexpected_color), Toast.LENGTH_LONG)
                .show()
        }
    }
}</pre></li>
			</ol>
			<p>The <code>colorPickerClickListener</code> added in the preceding code determines which <a id="_idIndexMarker169"/>colors to set for the <code>setRainbowColor(colorName: String, color: Int)</code> function by using a <code>when</code> statement. The <code>when</code> statement is the equivalent of the <code>switch</code> statement in Java and languages based on C. It allows multiple conditions to be satisfied with one branch and is more concise. In the preceding example, <code>view.id</code> is matched against the IDs of the rainbow layout buttons and, when found, executes the branch, setting the color name and hex value from the string resources to pass into <code>setRainbowColor(colorName: String, </code><code>color: Int)</code>.</p>
			<ol>
				<li value="15">Now, add<a id="_idIndexMarker170"/> this click listener to the buttons from the layout below the preceding code:<pre class="source code">
findViewById&lt;View&gt;(R.id.red_button).setOnClickListener(colorPickerClickListener)
findViewById&lt;View&gt;(R.id.orange_button).setOnClickListener(colorPickerClickListener)findViewById&lt;View&gt;(R.id.yellow_button).setOnClickListener(colorPickerClickListener)
findViewById&lt;View&gt;(R.id.green_button).setOnClickListener(colorPickerClickListener)
findViewById&lt;View&gt;(R.id.blue_button).setOnClickListener(colorPickerClickListener)
findViewById&lt;View&gt;(R.id.indigo_button).setOnClickListener(colorPickerClickListener)
findViewById&lt;View&gt;(R.id.violet_button).setOnClickListener(colorPickerClickListener)</pre></li>
			</ol>
			<p>Every button has a <code>ClickListener</code> interface attached, and as the operation is the same, they have the same <code>ClickListener</code> interface attached. Then, when the button is pressed, it sets the result of the color that the user has chosen and returns it to the calling activity.</p>
			<ol>
				<li value="16">Now, run the app and p<a id="_idTextAnchor146"/>ress the <code>CHOOSE COLOR</code> button, as shown in <em class="italic">Figure 2</em><em class="italic">.17</em>:</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_17.jpg" alt="Figure 2.17 – The rainbow colors app start s﻿creen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – The rainbow colors app start s<a id="_idTextAnchor147"/>creen</p>
			<ol>
				<li value="17">Now, select<a id="_idIndexMarker171"/> your favorite color of the rainbow:</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_18.jpg" alt="Figure 2.18 – The rainbow colors selection screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – The rainbow colors selection screen</p>
			<ol>
				<li value="18">Once you’ve chosen your favorite color, a screen with your favor<a id="_idTextAnchor148"/>ite color will be displayed, as <a id="_idIndexMarker172"/>shown in <em class="italic">Figure 2</em><em class="italic">.19</em>:</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19411_02_19.jpg" alt="Figure 2.19 – The app displaying the selected color"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – The app displaying the selected color</p>
			<p>As you can see, the app displays the color that you’ve selected as your favorite color in <em class="italic">Figure 2</em><em class="italic">.19</em>.</p>
			<p>This exercise introduced<a id="_idIndexMarker173"/> you to another way of creating user flows using <code>registerFor</code><strong class="source inline">
ActivityResult</strong>. This can be very useful for carrying out a dedicated Task where you need a result before proceeding with the user’s flow through the app. Next, you will explore launch modes and how the<a id="_idTextAnchor149"/><a id="_idTextAnchor150"/>y impact the flow of user journeys when building apps.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor151"/>Intents, Tasks, and Launch Modes</h1>
			<p>Up until now, you <a id="_idIndexMarker174"/>have been using the standard behavior for creating Activities and moving from one Activity to the next. When you open the app from the launcher with the default behavior, it creates its own Task, and each Activity you create is added to a back stack, so when you open three Activities one after the other as part of your user’s journey, pressing the back button three times will move the user back through the previous screens/Activities and then go back to the device’s home screen, while still keeping the app open.</p>
			<p>The launch mode for this type of Activity is called <code>Standard</code>; it is the default and doesn’t need specifying in the Activity element of <code>AndroidManifest.xml</code>. Even if you launch the same Activity three times, one after the other, there will be three instances of the same activity that exhibit the behavior described previously.</p>
			<p>For some apps, you may want to change this behavior so the same instance is used. The launch mode that can help here is called <code>singleTop</code>. If a <code>singleTop</code> Activity is<em class="italic"> </em>the most recently added, when the same <code>singleTop</code> Activity is launched again, then instead of creating a new Activity, it uses the same Activity and runs the <code>onNewIntent</code> callback. In this callback, you receive an intent, and you can then process this intent as you have done previously in <code>onCreate</code>.</p>
			<p>There are three other launch modes to be aware of called <code>singleTask</code>, <code>singleInstance</code> and <code>singleInstancePerTask</code>. These are not for general use and are only used for special scenarios. Detailed <a id="_idIndexMarker175"/>documentation of all launch modes can be viewed here: <a href="https://developer.android.com/guide/topics/manifest/activity-element#lmode">https://developer.android.com/guide/topics/manifest/activity-element#lmode</a>.</p>
			<p>You’ll explore the differences in behavior of the <code>S<a id="_idTextAnchor152"/><a id="_idTextAnchor153"/>tandard</code> and <code>singleTop</code> launch modes in the next exercise.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor154"/>Exercise 2.06 – setting the Launch Mode of an Activity</h2>
			<p>This exercise<a id="_idIndexMarker176"/> has many different layout files and Activities to illustrate the two most commonly used launch modes. Please download the code from <a href="https://packt.link/DQrGI">https://packt.link/DQrGI</a>:</p>
			<ol>
				<li>Open up the <code>activity_main.xml</code> file and examine it.</li>
			</ol>
			<p>This illustrates a new concept when using layout files. If you have a layout file and you would like to include it in another layout, you can use the <code>&lt;include&gt;</code> XML element (have a look at the following snippet of the layout file):</p>
			<pre class="source code">
&lt;include layout="@layout/letters"
    android:id="@+id/letters_layout"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toBottomOf="@id/launch_mode_
        standard"/&gt;
&lt;include layout="@layout/numbers"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toBottomOf="@id/launch_mode_
        single_top"/&gt;</pre>
			<p>The preceding layout uses the <code>include</code> XML element to include the two layout files: <code>letters.xml</code> and <code>numbers.xml</code>.</p>
			<ol>
				<li value="2">Open up and inspect the <code>letters.xml</code> and <code>numbers.xml</code> files found in the <code>res</code> | <code>layout</code> folder. These are very similar and are only differentiated from the buttons they contain by the ID of the buttons themselves and the text label they dis<a id="_idTextAnchor155"/>play.</li>
				<li>Run the app <a id="_idIndexMarker177"/>and you will see the following screen:</li>
			</ol>
			<div><div><img src="img/B19411_02_20.jpg" alt="Figure 2.20 – App displaying both the standard and single top modes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – App displaying both the standard and single top modes</p>
			<p>In order to demonstrate/illustrate the difference between the <code>standard</code> and <code>singleTop</code> activity launch modes, you have to launch two or three activities one after the other.</p>
			<ol>
				<li value="4">Open up <code>MainActivity</code> and examine the contents of the code block (truncated) in <code>onCreate(savedInstanceState: Bundle?)</code>:<pre class="source code">
val buttonClickListener = View.OnClickListener { view -&gt;
    when (view.id) {
        R.id.letterA -&gt; startActivity(Intent(this, 
            ActivityA::class.java))
        // Other letters and numbers follow the same 
           pattern/flow
        else -&gt; {
            Toast.makeText(
                this, getString(
                    R.string.unexpected_button_pressed
                ),
                Toast.LENGTH_LONG
            )
                .show()
        }
    }
}
findViewById&lt;View&gt;(R.id.letterA).setOnClickListener(buttonClickListener)
// The buttonClickListener is set on all the number and letter views</pre></li>
			</ol>
			<p>The logic <a id="_idIndexMarker178"/>contained in the main Activity and the other activities is basically the same. It displays an Activity and allows the user to press a button to launch another Activity using the same logic of creating a <code>ClickListener</code> and setting it on the button you saw in <em class="italic">Exercise 2.05</em>, <em class="italic">Retrieving a result from </em><em class="italic">an Activity</em>.</p>
			<ol>
				<li value="5">Open<a id="_idIndexMarker179"/> the <code>AndroidManifest.xml</code> file and you will see the following activities  displayed:<pre class="source code">
&lt;activity android:name=".ActivityA" android:launchMode="standard"/&gt;
&lt;activity android:name=".ActivityB" android:launchMode="standard"/&gt;
&lt;activity android:name=".ActivityC" android:launchMode="standard"/&gt;
&lt;activity android:name=".ActivityOne" android:launchMode="singleTop"/&gt;
&lt;activity android:name=".ActivityTwo" android:launchMode="singleTop"/&gt;
&lt;activity android:name=".ActivityThree" android:launchMode="singleTop"/&gt;</pre></li>
			</ol>
			<p>You launch an Activity based on a button pressed on the main screen, but the letter and number activities have a different launch mode, which you can see specified in the <code>AndroidManifest.xml</code> file.</p>
			<p>The <code>standard</code> launch mode is specified here to illustrate the difference between <code>standard</code> and <code>singleTop</code>, but <code>standard</code> is the default and would be how the Activity is launched if the <code>android:launchMode</code> XML attribute was not present.</p>
			<ol>
				<li value="6">Press one of the letters under the <code>Standard</code> headin<a id="_idTextAnchor156"/>g and you will see the following screen (with <strong class="bold">A</strong>, <strong class="bold">B</strong>, or <strong class="bold">C</strong>):</li>
			</ol>
			<div><div><img src="img/B19411_02_21.jpg" alt="Figure 2.21 – The app displaying standard activity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – The app displaying standard activity</p>
			<ol>
				<li value="7">Keep on <a id="_idIndexMarker180"/>pressing any of the letter buttons, which will launch another Activity. Logs have been added to show this sequence of launching activities. Here is the log after pressing 10 letter Activities randomly:<pre class="source code">
MainActivity com.example.launchmodes onCreate
Activity A   com.example.launchmodes onCreate
Activity A   com.example.launchmodes onCreate
Activity B   com.example.launchmodes onCreate
Activity B   com.example.launchmodes onCreate
Activity C   com.example.launchmodes onCreate
Activity B   com.example.launchmodes onCreate
Activity B   com.example.launchmodes onCreate
Activity A   com.example.launchmodes onCreate
Activity C   com.example.launchmodes onCreate
Activity B   com.example.launchmodes onCreate
Activity C   com.example.launchmodes onCreate</pre></li>
			</ol>
			<p>If you observe the preceding log, every time the user presses a character button in launch mode, a new instance of the character Activity is launched and added to the back stack.</p>
			<ol>
				<li value="8">Close the <a id="_idIndexMarker181"/>app, making sure it is not backgrounded (or in the recents/overview menu) but is actually closed, and then open the app again and pr<a id="_idTextAnchor157"/>ess one of the number buttons under the <strong class="bold">Single </strong><strong class="bold">Top</strong> heading:</li>
			</ol>
			<div><div><img src="img/B19411_02_22.jpg" alt="Figure 2.22 – The app displaying the Single Top activity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – The app displaying the Single Top activity</p>
			<ol>
				<li value="9">Press the number buttons 10 times, but make sure you press the same number button at least twice sequentially before pressing another number button.</li>
			</ol>
			<p>The logs you<a id="_idIndexMarker182"/> should see in the <strong class="bold">Logcat</strong> window (<strong class="bold">View</strong> | <strong class="bold">Tool Windows</strong> | <strong class="bold">Logcat</strong>) should be similar to the following:</p>
			<pre class="source code">
MainActivity com.example.launchmodes  onCreate
Activity 1   com.example.launchmodes  onCreate
Activity 1   com.example.launchmodes  onNewIntent
Activity 2   com.example.launchmodes  onCreate
Activity 2   com.example.launchmodes  onNewIntent
Activity 3   com.example.launchmodes  onCreate
Activity 2   com.example.launchmodes  onCreate
Activity 3   com.example.launchmodes  onCreate
Activity 3   com.example.launchmodes  onNewIntent
Activity 1   com.example.launchmodes  onCreate
Activity 1   com.example.launchmodes  onNewIntent</pre>
			<p>You’ll notice that instead of calling <code>onCreate</code> when you pressed the same button again at least twice sequentially, the Activity is not created, but a call is made to <code>onNewIntent</code>. If you press the back button, you’ll notice that it will take you less than 10 clicks to back out of the app and return to the home screen, r<a id="_idTextAnchor158"/>eflecting the fact tha<a id="_idTextAnchor159"/>t 10 activities have not been created.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor160"/>Activity 2.01 – creating a login form</h2>
			<p>The aim <a id="_idIndexMarker183"/>of this activity is to create a login form with username and password fields. Once the values in these fields are submitted, check these entered values against the hardcoded values and display a welcome message if they match, or an error message if they don’t, and return the user to the login form. The steps needed to achieve this are the following:</p>
			<ol>
				<li>Create a form with username and password <code>EditText</code> Views and a <code>LOGIN</code> button.</li>
				<li>Add a <code>ClickListener</code> interface to the button to react to a button press event.</li>
				<li>Validate <a id="_idIndexMarker184"/>that the form fields are filled in.</li>
				<li>Check the submitted username and password fields against the hardcoded values.</li>
				<li>Display a welcome message with the username if successful and hide the form.</li>
				<li>Display an error message if not successful and redirect the user back to the form.</li>
			</ol>
			<p>There are a few possible ways that you could go about trying to complete this activity. Here are three ideas for approaches you could adopt:</p>
			<ul>
				<li>Use a <code>singleTop</code> Activity and send an intent to route to the same Activity to validate the credentials</li>
				<li>Use a <code>standard</code> Activity to pass a username and password to another Activity and validate the credentials</li>
				<li>Use <code>registerForActivityResult</code> to carry out the validation in another Activity and then return the result</li>
			</ul>
			<p>The complete<a id="_idTextAnchor161"/>d app, upon its first loading, should look as in <em class="italic">Figure 2</em><em class="italic">.23</em>:</p>
			<div><div><img src="img/B19411_02_23.jpg" alt="Figure 2.23 – The app display when first loaded"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23 – The app display when first loaded</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/PmKJ6">https://packt.link/PmKJ6</a>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, you have covered a lot of the groundwork of how your application interacts with the Android framework, from the Activity lifecycle callbacks to retaining the state in your activities, navigating from one screen to another, and how intents and launch modes make this happen. These are core concepts that you need to understand in order to move on to more advanced topics.</p>
			<p>In the next chapter, you will be introduced to fragments and how they fit into the architecture of your application, as well as exploring more of the Android resources framework.</p>
		</div>
	</body></html>