["```swift\nprotocol StringContainer {\n    var count: Int { get }\n    mutating func addString(string: String)\n    func enumerateStrings(handler: (string: String) -> Void)\n}\n```", "```swift\nstruct StringBag: StringContainer {\n    // Error: Type 'StringBag' does not conform to protocol 'StringContainer'\n}\n```", "```swift\nstruct StringBag: StringContainer {\n    var strings = [String]()\n    var count: Int {\n        return self.strings.count\n    }\n\n    mutating func addString(string: String) {\n        self.strings.append(string)\n    }\n\n    func enumerateStrings(handler: (string: String) -> Void) {\n        for string in self.strings {\n            handler(string: string)\n        }\n    }\n}\n```", "```swift\nclass SomeSuperclass {}\nclass StringBag2: SomeSuperclass, StringContainer {\n    var strings = [String:Void]()\n    var count: Int {\n        return self.strings.count\n    }\n\n    func addString(string: String) {\n        self.strings[string] = ()\n    }\n\n    func enumerateStrings(handler: (string: String) -> Void) {\n        for string in self.strings.keys {\n            handler(string: string)\n        }\n    }\n}\n```", "```swift\nvar someStringBag: StringContainer = StringBag()\nsomeStringBag.addString(\"Sarah\")\nsomeStringBag = StringBag2()\nsomeStringBag.addString(\"Sarah\")\n```", "```swift\nprotocol Container {\n    typealias Element\n\n    mutating func addElement(element: Element)\n    func enumerateElements(handler: (element: Element) -> Void)\n}\n```", "```swift\nstruct StringBag3: Container {\n    typealias Element = String\n\n    var elements = [Element:Void]()\n\n    var count: Int {\n        return elements.count\n    }\n\n    mutating func addElement(element: Element) {\n        self.elements[element] = ()\n    }\n\n    func enumerateElements(handler: (element: Element) -> Void) {\n        for element in self.elements.keys {\n            handler(element: element)\n        }\n    }\n}\n```", "```swift\nstruct IntBag: Container {\n    typealias Element = Int\n\n    var elements = [Element:Void]()\n\n    var count: Int {\n        return elements.count\n    }\n\n    mutating func addElement(element: Element) {\n        self.elements[element] = ()\n    }\n\n    func enumerateElements(handler: (element: Element) -> Void) {\n        for element in self.elements.keys {\n            handler(element: element)\n        }\n    }\n}\n```", "```swift\nfunc firstInNumbers(\n    numbers: [Int],\n    passingTest: (number: Int) -> Bool\n    ) -> Int?\n{\n    for number in numbers {\n        if passingTest(number: number) {\n            return number\n        }\n    }\n    return nil\n}\n```", "```swift\nfunc firstInArray<ValueType>(\n    array: [ValueType],\n    passingTest: (value: ValueType) -> Bool\n    ) -> ValueType?\n{\n    for value in array {\n        if passingTest(value: value) {\n            return value\n        }\n    }\n    return nil\n}\n```", "```swift\nvar strings = [\"This\", \"is\", \"a\", \"sentence\"]\nvar numbers = [1, 1, 2, 3, 5, 8, 13]\nfirstInArray(strings, passingTest: {$0 == \"a\"}) // \"a\"\nfirstInArray(numbers, passingTest: {$0 > 10}) // 13\n```", "```swift\nfirstInArray(numbers, passingTest: {$0 == \"a\"}) // Cannot convert\n// value of type '[Int]' to expected argument type'[_]'\n```", "```swift\nstruct Bag<ElementType> {\n    var elements = [ElementType]()\n\n    mutating func addElement(element: ElementType) {\n        self.elements.append(element)\n    }\n\n    func enumerateElements(\n        handler: (element: ElementType) -> ()\n        )\n    {\n        for element in self.elements {\n            handler(element: element)\n        }\n    }\n}\n```", "```swift\nvar stringBag = Bag(elements: [\"This\", \"is\", \"a\", \"sentence\"])\nvar numberBag = Bag(elements: [1, 1, 2, 3, 5, 8, 13])\n```", "```swift\nvar emptyBag = Bag(elements: []) // Cannot invoke initilaizer for\n// type 'Bag<_>' with an argument list of type '(elements: [_])'\n```", "```swift\nvar emptyBag: Bag<String> = Bag(elements: [])\n```", "```swift\nfunc indexOfValue<T>(value: T, inArray array: [T]) -> Int? {\n    var index = 0\n    for testValue in array {\n        if testValue == value { // Error: Cannot invoke '=='\n            return index\n        }\n        index++\n    }\n    return nil\n}\n```", "```swift\nfunc indexOfValue<T: Equatable>(\n    value: T,\n    inArray array: [T]\n    ) -> Int?\n{\n    var index = 0\n    for testValue in array {\n        if testValue == value {\n            return index\n        }\n        index++\n    }\n    return nil\n}\n```", "```swift\nclass MyType {}\nvar typeList = [MyType]()\nindexOfValue(MyType(), inArray: typeList)\n// Cannot convert value of type '[MyType]' to expected\n// argument type '[_]'\n```", "```swift\nstruct Bag2<ElementType> {\n    var elements: [ElementType:Void]\n    // Type 'ElementType' does not conform to protocol 'Hashable'\n}\n```", "```swift\nstruct Bag2<ElementType: Hashable> {\n    var elements: [ElementType:Void]\n\n    mutating func addElement(element: ElementType) {\n        self.elements[element] = ()\n    }\n\n    func enumerateElements(\n        handler: (element: ElementType) -> ()\n        )\n    {\n        for element in self.elements.keys {\n            handler(element: element)\n        }\n    }\n}\n```", "```swift\nfunc container<C: Container where C.Element: Equatable>(\n    container: C,\n    hasElement element: C.Element\n    ) -> Bool\n{\n    var hasElement = false\n    container.enumerateElements { testElement in\n        if element == testElement {\n            hasElement = true\n        }\n    }\n    return hasElement\n}\n```", "```swift\nfunc merged<C1: Container, C2: Container where C1.Element == C2.Element>(\n    lhs: C1,\n    rhs: C2\n    ) -> C1\n{\n    var merged = lhs\n    rhs.enumerateElements { element in\n        merged.addElement(element)\n    }\n    return merged\n}\n```", "```swift\nextension Array<Element> { // Use of undeclared type 'Element'\n    // ...\n}\n```", "```swift\nextension Array {\n    func someMethod<Element>(element: Element) {\n        // ...\n    }\n}\n```", "```swift\nextension Array {\n    mutating func addElement<Element>(element: Element) {\n        self.append(element)\n        // Cannot invoke 'append' with argument list\n        // of type '(Element)'\n    }\n}\n```", "```swift\nextension Array {\n    func hasElementThatPasses(\n        test: (element: Element) -> Bool\n        ) -> Bool\n    {\n        for element in self {\n            if test(element: element) {\n                return true\n            }\n        }\n        return false\n    }\n}\n```", "```swift\nextension Array where Element: Equatable {\n    func containsElement(element: Element) -> Bool {\n        for testElement in self {\n            if testElement == element {\n                return true\n            }\n        }\n        return false\n    }\n}\n```", "```swift\n[1,2,3,4,5].containsElement(4) // true\nclass MyType {}\nvar typeList = [MyType]()\ntypeList.containsElement(MyType()) // Type 'MyType' does not\n// conform to protocol 'Equtable'\n```", "```swift\nextension Comparable {\n    func isBetween(a: Self, b: Self) -> Bool {\n        return a < self && self < b\n    }\n}\n```", "```swift\n6.isBetween(4, b: 7) // true\n\"A\".isBetween(\"B\", b: \"Z\") // false\n```", "```swift\nprotocol Building {\n    var squareFootage: Int {get}\n}\n\nstruct House: Building {\n    let squareFootage: Int\n}\n\nstruct Factory: Building {\n    let squareFootage: Int\n}\n```", "```swift\nclass Building {\n    // ...\n\n    func clean() {\n        print(\n            \"Scrub \\(self.squareFootage) square feet of floors\"\n        )\n    }\n}\n\nclass House: Building {\n    // ...\n\n    override func clean() {\n        print(\"Make \\(self.numberOfBedrooms) beds\")\n        print(\"Clean \\(self.numberOfBathrooms) bathrooms\")\n    }\n}\n\nlet building: Building = House(\n    squareFootage: 800,\n    numberOfBedrooms: 2,\n    numberOfBathrooms: 1\n)\nbuilding.clean()\n// Make 2 beds\n// Clean 1 bathroom\n```", "```swift\nprotocol Building {\n    var squareFootage: Int {get}\n}\n\nextension Building {\n    func clean() {\n        print(\n            \"Scrub \\(self.squareFootage) square feet of floors\"\n        )\n    }\n}\n\nstruct House: Building {\n    let squareFootage: Int\n    let numberOfBedrooms: Int\n    let numberOfBathrooms: Double\n\n    func clean() {\n        print(\"Make \\(self.numberOfBedrooms) beds\")\n        print(\"Clean \\(self.numberOfBathrooms) bathrooms\")\n    }\n}\n\nlet house = House(\n    squareFootage: 1000,\n    numberOfBedrooms: 2,\n    numberOfBathrooms: 1.5\n)\nhouse.clean()\n// Make 2 beds\n// Clean 1.5 bathrooms\n\n(house as Building).clean()\n// Scrub 1000 square feet of floors\n```", "```swift\nstruct FibonacciGenerator: GeneratorType {\n    typealias Element = Int\n\n    var values = (0, 1)\n\n    mutating func next() -> Element? {\n        self.values = (\n            self.values.1,\n            self.values.0 + self.values.1\n        )\n        return self.values.0\n    }\n}\n```", "```swift\nvar generator = FibonacciGenerator()\nwhile let next = generator.next() {\n    if next > 10 {\n        break\n    }\n    print(next)\n}\n// 1, 1, 2, 3, 5, 8\n```", "```swift\nstruct FibonacciSequence: SequenceType {\n    typealias Generator = FibonacciGenerator\n\n    func generate() -> Generator {\n        return FibonacciGenerator()\n    }\n}\n```", "```swift\nfor next in FibonacciSequence() {\n    if next > 10 {\n        break\n    }\n    print(next)\n}\n```", "```swift\nstruct FibonacciSequence2: SequenceType {\n    typealias Generator = AnyGenerator<Int>\n\n    func generate() -> Generator {\n        var values = (0, 1)\n        return anyGenerator({\n            values = (values.1, values.0 + values.1)\n            return values.0\n        })\n    }\n}\n```", "```swift\nstruct SequenceLimiter<\n    S: SequenceType where S.Generator.Element: Comparable\n    >: SequenceType\n{\n    typealias Generator = AnyGenerator<S.Generator.Element>\n    let sequence: S\n    let max: S.Generator.Element\n\n    init(_ sequence: S, max: S.Generator.Element) {\n        self.sequence = sequence\n        self.max = max\n    }\n\n    func generate() -> Generator {\n        var g = self.sequence.generate()\n        return anyGenerator({\n            if let next = g.next() {\n                if next <= self.max {\n                    return next\n                }\n            }\n            return nil\n        })\n    }\n}\n```", "```swift\nextension SequenceType where Generator.Element: Comparable {\n    func limit(max: Generator.Element) -> SequenceLimiter<Self> {\n        return SequenceLimiter(self, max: max)\n    }\n}\n```", "```swift\nFibonacciSequence().limit(50)\n```", "```swift\nextension SequenceType where Generator.Element == Int {\n    var product: Generator.Element {\n        return self.reduce(1, combine: *)\n    }\n}\n```", "```swift\nFibonacciSequence().limit(50).product // 2,227,680\n```"]