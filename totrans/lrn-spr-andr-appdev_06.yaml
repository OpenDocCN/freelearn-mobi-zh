- en: Accessing the Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the database in the Spring Framework. The
    database is a collection of data that is stored in the server in an organized
    way, so that an application can retrieve the data in the way that the user requests.
    In this chapter, you will learn how to use the database on both the client and
    server side. In addition to this, we will explore the usage of JDBC, JPA, Hibernate,
    and MySQL from the server side, and we will look at the room persistence library
    from the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a database management system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access in Spring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access with JDBC in Spring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample project using JDBC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access with JPA and Hibernate in Spring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample project using JPA + Hibernate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the room persistence library?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android application using the room persistence library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have previously demonstrated how to set up the environment and what tools,
    software, and IDE are needed in order to develop Spring. To create your project,
    visit this link: [https://start.spring.io/](https://start.spring.io/). The following
    options will be available here:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language – Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot version – 2.1.1 (SNAPSHOT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create the project, you need to provide some information, such as—**Group**,
    **Artifact**, **Name**, **Description**, **Package Name**, **Packaging**, and
    **Java Version**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use MySQL in upcoming projects. Consequently, you need to download
    the tools for MySQL from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)
    and install it. Please try to configure the MySQL database with the given information
    to make your project easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code with an example for this chapter is available on GitHub at the
    following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **database** is a collection of information that is stored in the server in
    an organized way. A user can fetch and use this data from the server in various
    systems. In the database, a user can add, delete, update, get, or manage the data.
    Normally, data is assembled into tables, columns, and rows, making it easier to
    find relevant data. A computer database contains aggregations of data records
    or files. A company's data can include their statistics or client information,
    or it can be top secret documents. A database manager provides the client or the
    user with the ability to control read and/or write access, analyze the data, and
    so on. We will now look at various types of database and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: Types of database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases are used for a variety of purposes, such as to store personal or company
    information. There are several databases available on the market, as described
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Personal database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A personal database is designed for data stored on a personal computer. This
    database is small and very easy to manage, and it is normally used by a small
    group of people or a small organization.
  prefs: []
  type: TYPE_NORMAL
- en: Relational database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The relational database is created on a set of tables that fit into a pre-defined
    category. These databases are sorted by an arrangement of tables where information
    gets fit into a pre-characterized class. The table is comprised of rows and columns.
    The column has a passage for information for an explicit classification. On the
    other side, rows contain a case for that information characterized by the classification.
    The relational database has a standard user and application program interface
    named **Structured Query Language** (**SQL**).
  prefs: []
  type: TYPE_NORMAL
- en: Distributed database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed database is stored in multiple physical locations and distributed
    at various sites of an organization. The sites are connected with the help of
    communication links, so the user can access the distributed data easily. There
    are two kinds of distributed database—homogeneous and heterogeneous. In a homogenous
    distributed database, the physical locations have the same hardware and run in
    the same OS and database applications. However, in the heterogeneous distributed
    database, the hardware, OS, or database applications can be found in a different
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an object-oriented database, items are created by using object-oriented programming
    such as Java and C++, which are stored in relational databases. But for those
    items, an object-oriented database is well-suited. An object-oriented database
    is sorted out around objects as opposed to activities, and information instead
    of rationale.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A NoSQL database is normally used for a large set of distributed data. This
    database is very effective for big data where an organization analyzes large chunks
    of unorganized data stored in multiple virtual servers in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Graph database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graph database is a type of NoSQL database that uses graph theory to store,
    map, and query the relationships of the data. It is a collection of lots of nodes
    and edges. The nodes represent the entity and the edges represent the connection
    between nodes. This database is used a lot in social media platforms such as Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cloud database is mainly built for a virtualized environment. The virtualized
    environment can be a hybrid cloud, public cloud, or private cloud. These databases
    provide various benefits, such as the ability to pay for storage capacity and
    per-user basis bandwidth. As a software-as-a-server, it provides support to enterprise
    business applications.
  prefs: []
  type: TYPE_NORMAL
- en: Database management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **database management system** (**DBMS**) is system software that is made
    for creating and managing databases. With the help of the **DBMS**, a user or
    a developer can create, get, update, and manage data in a systemic way. This system
    is kind of an interface between a user and a database. It also ensures that data
    is consistently organized and easily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram regarding the use of a **DBMS**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d25e9f1c-fb8a-4046-8422-fa9d3ca02d48.png)'
  prefs: []
  type: TYPE_IMG
- en: There are three important features of a **DBMS**, and these are the data, the
    database engine, and the database schema. The data is a collection of information,
    the database engine allows data to be locked, accessed, and modified, and the
    database schema defines the logical structure of the database.
  prefs: []
  type: TYPE_NORMAL
- en: The **DBMS** provides a general view of how data can be accessed by multiple
    users from multiple locations in a controlled manner. It also limits a user's
    access to user data. The database schema provides the logic of how a user can
    view the data. The **DBMS** handles all the requests and executes them on the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Both logical and physical data independence is offered by the **DBMS**. This
    means that an application can use APIs to utilize the data from the database.
    In addition, clients and applications don't need to worry about the locations
    of the stored data and changes to the physical structure of the data, such as
    storage and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Popular database models and their management systems include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relational database management system** (**RDMS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL DBMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-memory database management system** (**IMDBMS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Columnar database management system** (**CDBMS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-based data management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access in the Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data access is responsible for authorizing access to data repositories. It helps
    to distinguish the *role* ability, like users or administrators in the application.
    It maintains the data access system, such as insert, retrieve, update, or delete
    based on the role. In [Chapter 3](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml),
    *Overview of Spring Framework*, we have learned about the architecture of Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of the Spring architecture, where **Data Access** is one
    of the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76a06808-b5d5-4223-957f-a4c24fa9088a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, **Data Access** is one of the layers of Spring architecture.
    This part is concerned with data access. **JDBC**, **ORM**, **OXM**, **JMS**,
    and **Transactions** modules are modules that are used in Spring. We have mentioned
    the details of this in [Chapter 3](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml),
    *Overview of Spring Framework*, under the Spring architecture topic. In this chapter,
    we will see the use of **JDBC** and **ORM** (**JPA**, **Hibernate**).
  prefs: []
  type: TYPE_NORMAL
- en: Java database connectivity in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Database Connectivity** (**JDBC**) is an API specification for connecting
    and moving data from the frontend to the backend. The classes and interfaces are
    written in Java. Nowadays, it also supports Kotlin. We will write in Kotlin throughout
    this chapter. This basically acts as an interface or bridge between the Java-based
    application and database. JDBC is very similar to the **Open Database Connectivity**
    (**ODBC**).Like ODBC, JDBC enables a JDBC application to access a collection of
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring Framework, the JDBC is divided into the following four separate
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core**: This is the JDBC''s core functionality and `JdbcTemplate`, `SimpleJdbcInsert`,
    and `SimpleJdbcCall` are the important classes of this core part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataSource**: This is used to access data sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object**: The JDBC can access in an object-oriented manner. As a business
    object, it executes queries and returns the results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support**: Support classes work under core and object packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample project using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn JDBC using a project in which we will create REST APIs for users and
    show the list of user details. In this project, we will use JDBC, MySQL, and Spring
    Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a project, go to this link: [https://start.spring.io](https://start.spring.io)
    and create a Kotlin-based project. Here are the dependencies of JDBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDBC**: this will implement all the features regarding JDBC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MySQL**: this will implement all the features of MySQL database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you go to the `pom.xml` file, there you can see the dependencies for the
    JDBC, and we are using MySQL for the data. Here is a piece of code of the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating DataSource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We configure the DataSource and connection pool in the `application.properties`.
    Spring Boot uses the `spring.datasource` interface as a prefix to configure DataSource.
    Our database schema name is `packtpub_dbtest_schema`. You can create this on your
    own and rename it. Here are the details of `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: According to the previous code, `spring.datasource.url=jdbc:mysql:` `//localhost:3306/packtpub_dbtest_schema`
    means the URL for the database schema called `packtpub_dbtest_schema` to access
    the data in the project. `spring.datasource.username=root` means the username
    of the database is `root`, and `spring.datasource.password=12345678` means the
    username of the database is `12345678`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our system, the MySQL details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a table in database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the MySQL Workbench and select the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have included some user details for the `USERS` table. You can copy and
    paste the following code to create a `USERS` table and insert some demo data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After inserting the user details in the user table, you can see the content
    in your `users` table, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06df5d5d-6d98-4dfd-b94a-a44ed7f00a95.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a REST API to see the list of user details where
    we can get a username, email ID, and contact number. So let's create a model of
    a user; the class name is `UserModel.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have created a class named `UserModel`, where we have initialized `id`, `name`,
    `email`, and `contact_number`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating row mapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RowMapper` is an interface that is provided by the Spring JDBC. This is used
    to map a row with a Java object and to fetch data from the database. It uses the `query()`
    function of the `JdbcTemplate` class. Let''s create a `RowMapper` interface named `UserRowMapper.kt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we extended `RowMapper<UserModel>` and overrode the `mapRow` where
    we return the `UserModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a REST API response, we need to create an interface where we will mention
    what we want to do with the data, such as getting the user list, creating a new
    user, and deleting or updating the user details. Let's create an interface named
    `UserInterface.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used five functions, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAllUserList()`: This will return a list of the details of all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUserByID(id: Int)`: This will return the details of a specific user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addNewUser(userModel: UserModel)`: This will add new user details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateUser(userModel: UserModel)`: This will update an existing user''s details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteUser(id: Int)`: This will delete a specific user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will communicate with the database in this class. This is a repository class
    and so we annotate this class with `@Repository`. Let's create a repository class
    named `UserRepository.kt`, which implements the `UsersInterface.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have created a repository class named `UserRepository`, where we implement `UsersInterface`,
    and override all the functions of the interface. We use the `@Repository` annotation
    to make it a repository class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's complete this class step by step in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: JdbcTemplate implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`JdbcTemplate` is the heart of the JDBC. This is the center class of JDBC.
    SQL queries are executed by `JdbcTemplate`, which also fetches the results. To
    use this `JdbcTemplate`, we need to autowire the `JdbcTemplate` in this repository
    class. Here is the piece of code of this repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating HTTP methods for RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we will create **create, read, update, and delete** (**CRUD**)
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet pertaining to the create operation, where we will insert
    the user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `addQuery = "INSERT INTO users (name, email, contact_number) values (?,?,?)"`
    is the query to insert the user in the USER table.
  prefs: []
  type: TYPE_NORMAL
- en: The `jdbcTemplate.update()` is the function where we use the query and user
    details as the parameters to insert in the database.
  prefs: []
  type: TYPE_NORMAL
- en: READ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet pertaining to the read operation. The following function
    will return a list of all the user''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`selectAllSql = "SELECT * FROM users"` is the query to fetch all the users
    from user the table. `jdbcTemplate.query()` will execute the query and fetch the
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This following function will get a user''s details based on `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`selectAllSql = "SELECT * FROM users WHERE id = ?"` is the query to fetch a
    user from the user table by using the ID. `jdbcTemplate.queryForObjec()` will
    execute the query and fetch the data.'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for update operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`updateQuery = "UPDATE users SET name=?,email=?, contact_number=? WHERE id=?"`
    is the query to update a user from the user table by using the ID. `jdbcTemplate.update()`
    will execute the query and update the data.'
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for delete operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`deleteQuery = "DELETE FROM users WHERE id=?"` is the query to update a user
    from user table by using the ID. `jdbcTemplate.update()` will execute the query
    and delete the specific data.'
  prefs: []
  type: TYPE_NORMAL
- en: With these functions, we have finished our repository class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the repository class, let's create the service class where we
    will autowire the repository class using the `@autowired` annotation. Let's create
    a service class named `UserService.kt` with the `@Service` annotation that implements
    the `UserInterface` and overrides all functions.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the piece of code for the `UserService.kt`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s override and modify the functions with the help of `UserRepository`.
    Here is the full code of the `UserService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`getAllUserList()`: This function will fetch all the users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUserByID(id: Int)`: This function will fetch a user by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addNewUser(userModel: UserModel)`: This function will insert a new user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateUser(userModel: UserModel, id: Int)`: This function will update a user
    by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteUser(id: Int)`: This function will delete a user by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your model, repository, and service classes are complete, then you are ready
    to create the controller class, where we will create `GetMapping`, `PostMapping`, `PutMapping`,
    and `DeleteMapping` to create RESTful API URL paths. Let''s create a controller
    class named `UserController.kt` using the `@RestController` annotation to create
    the controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Autowired service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s autowire the `UserService` using the `@Autowired` annotation. Here is
    the piece of code for this `UserController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Getting the user list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for the `getAllUsers()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping(path = ["/users"])` annotation is the URL path of `/users` and
    it is a `GET`  request function. Here, we will get a list of the users from the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting one user by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for the `getAllUserByID()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a `GET` request with a specific ID. Here, we will get the specific user
    details from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `addNewUser()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `@PostMapping(path = ["/user/new"])` annotation is the URL path of `"/user/new"`,
    and it is a `POST` request. Here, we can insert user details into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `@RequestBody` is an annotation of the Spring MVC framework. This is used
    in a controller to implement object serialization and deserialization. It helps
    you to avoid boilerplate codes by extracting the logic. The `@RequestBody` annotated
    function returns a value that is bound to the HTTP web response body. Here, the object
    is `UserModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `updateUser()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `@PutMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a `PUT` request with a specific ID. Here, we will update the specific
    user details in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `deleteUser()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@DeleteMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a delete request with a specific ID. Here, we will delete the specific
    user details from the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you finish this controller class, then you are ready to run this application
    and test the REST API using Insomnia.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s *run* the project. If the project doesn''t experience an error, then
    you''ll be able to see the RUN tab of the IDE, as demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a54fe0a-7b95-4c30-9c1c-1d0e2a632881.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, open the Insomnia app. Let's apply the REST API request in this app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the user list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use this `GET` request with this URL: `http://localhost:8080/users`, and hit
    Send. The user details will be fetched from the database and you can see the return
    JSON value, as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71c87cb5-fd73-4546-89b8-355d4bb07264.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting one user by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `GET` function with this URL: `http://localhost:8080/user/1`, and
    hit Send. The user details will be fetched from the database and you can see the
    return JSON value of a user whose `id` is `1`, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/636d9fb9-4c4d-4cdd-9943-d39d4ac5596a.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `POST` function with this URL: `http://localhost:8080/user/new` a
    and hit Send. This will insert a user in the database and show the new user details,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3373d7b0-1c14-4c8b-801b-d4c4e6a811e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you use the `/users` `GET` request URL path, you can check the user list
    containing the new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/998d9d15-db95-4257-9342-9b940defbb2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `UPDATE` function with this URL: `http://localhost:8080/user/8`,
    and hit Send. It will update the user who has the ID number eight in the database
    and shows the updated user information, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/207e2708-513c-4c16-ac8b-a8be932f2d29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you use the `http://localhost:8080/user/8` `GET` request URL path, you can
    check the new user with the new details like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/957a9089-b535-4d62-be91-8a380315a01f.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `DELETE` function with this URL: `http://localhost:8080/users`, and
    hit Send. This will delete the specific user from the database, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c140f020-594e-4845-80ca-b03ae30ccd9e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you check all the users, then you will see that there are only seven.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have created an application that is using JDBC, and we have also
    created a REST API. You can check out our GitHub project for the latest update
    if there is any. I also add a SQL file with the MySQL code.
  prefs: []
  type: TYPE_NORMAL
- en: Java Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The**Java Persistence API** (**JPA**) is an approach to **object-relational
    mapping** (**ORM**). ORM is a system that maps Java objects to databases, tables,
    and vice-versa. JPA can be used in both Java enterprise and standard edition-based
    applications. Hibernate, TopLink, EclipseLink, and Apache OpenJPA are the implementations
    of the JPA. Among these, Hibernate is the most advanced and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: JPA helps the developer to work directly with the objects, and therefore, there
    is no need to worry about the SQL statements. With the help of the JPA, they can
    map, store, update, and fetch the data from a relational database to a Java object
    or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: JPA metadata is mainly defined by the annotation in a class. However, it also
    supports XML, which means it can be defined by XML. We will use the annotation
    to define the JPA metadata throughout this book. Now, we will see the architecture
    of JPA, and its uses.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the class-level architecture of JPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23abc5c8-a595-4dc1-9048-2070b34bd557.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s describe the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityManagerFactory`: A factory class of `EntityManager` that creates and
    manages multiple `EntityManager` instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntityManager`: This is an interface that manages the persistence operations
    on objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entity`: This is a persistence object that is stored as records in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntityTransaction`: This has a one-to-one relationship with `EntityManager`.
    For each `EntityManager`, operations are maintained by the `EntityTransaction`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query`: This is an interface that is implemented by each JPA vendor to obtain
    relational objects with the criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Persistence`: This is a class. To obtain an `EntityManagerFactory` instance,
    it contains static methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you look at the diagram again, you may notice that there is some relation
    between the classes and interfaces that belong to the `javax.presistence` package:'
  prefs: []
  type: TYPE_NORMAL
- en: Between `EntityManagerFactory` and `EntityManager`, there is a one-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between `EntityManager` and `EntityTransaction`, there is a one-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between `EntityManager` and `Query`, there is a one-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between `EntityManager` and `Entity`, there is a one-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project using JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a simple project using Spring Boot with JPA, as well as Hibernate
    and MySQL. We will build a RESTful CRUD API of a user list.
  prefs: []
  type: TYPE_NORMAL
- en: To create a project, go to this link: [https://start.spring.io](https://start.spring.io) and
    create a Kotlin-based project.
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you go to the `pom.xml` file, you can see the dependencies for the JDBC
    there. We are using MySQL for the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'According to this code, here are the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we have seen a new dependency named `h2`. This is one of the well known,
    in-memory databases. Spring Boot and H2 have a great combination between one another.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DataSource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We configure the *DataSource *and *connection pool* in the `application.properties`.
    Spring boot uses the `spring.datasource` interface as a prefix to configure DataSource.
    Our database schema name is `cha6_dbtest_schema`. You can create this on your
    own and rename it. Here are the details of `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In our system, the MySQL details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Host -- localhost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port -- 3306`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Username -- rootPassword -- 12345678`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Database Name - packtpub_dbtest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Database Schema Name - packtpub_dbtest_schema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a REST API to see the list of user details where
    we can get a username, email ID, and contact number. So let's create a model of
    a user where the class name is `UserModel.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our `UserModel` class has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: Primary key with auto increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`:  (NOT NULL field)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: (NOT NULL field)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact_number`: (NOT NULL field)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike JDBC, you don''t need to create any table manually in your database.
    JPA will create a table using the `UserModel`. Let''s look at how to create a
    table in our database using this `UserModel` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity`: All your domain models must be annotated with this annotation. This
    annotation is used to mark the class as a persistent Java class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Table`: This annotation is used to provide the details of the table. The
    entity will be mapped by it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Id`: This is used to define the primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GeneratedValue`: This annotation is used to define the primary key generation
    strategy. In the preceding case, we have declared the primary key as an auto increment
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotBlank`: This is used to verify that the annotated field is not null or
    empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Column`: This is used to verify the properties of the column that will be
    mapped to the annotated field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will communicate with the database in this repository class. This is a `Repository` class,
    and so we annotate it with `@Repository`. Let's create a `Repository` class named `UserRepository.kt`,
    which extends the `JpaRepository`.  By extending `JpaRepository`, this interface
    will get a set of generic CRUD functions to create, update, delete, and fetch
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the `Repository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some functions we will get from this `JPARepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<T> findAll()`: To fetch all the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> findAll(Sort var1)` : To fetch all the data in sort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> findAllById(Iterable<ID> var1)`: To fetch data by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<S extends T> List<S> saveAll(Iterable<S> var1)`: To insert data using the
    list of a data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your model and repository classes are complete, then you are ready to create
    the controller class where we will create the `GetMapping`, `PostMapping`, `PutMapping`,
    and `DeleteMapping` to create *RESTful API URL* paths. Let''s create a controller
    class named `UserController.kt` using the `@RestController` annotation to create
    the controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Autowired repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s autowire the `UserRepository` using the `@Autowired` annotation. Here
    is the piece of code of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Getting the user list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `getAllUsers()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping(path = ["/users"])` annotation means it is used to `GET` a
    request. Here, we will get a list of the users from the database using `findAll()` of
    the `UserRepository` interface, which implemented `JpaRepository`. Consequently,
    we don't need to create a *custom interface*, unlike *JDBC*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting one user by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet `getAllUserByID()` operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a  `GET` request with a specific ID. Here, we return `findById(id).get()` to
    get the specific user details from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `addNewUser()` operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `@PostMapping(path = ["/user/"])`  annotation is the URL path of `"/user/"`,
    and it is a `POST` request. Here, we enter the details of a user to insert the
    user data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To bind the request body with a method parameter, we are using the `@RequestBody` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Valid` annotation makes sure that the request body is valid and not null.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we return `save(userModel)` to insert new user details into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for the `updateUser()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `@PutMapping("/user/{id}")` annotation is the URL path of `"/user/{id}"`,
    and it is a `PUT` request with a specific ID. Here, we will update the specific
    user details in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find the code snippet for `deleteUser()` operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `@DeleteMapping("/user/{id}")` annotation is the URL path of `"/user/{id}"`
    and it is a `DELETE` request with a specific ID. Here we will delete the specific
    user details from the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you finish this controller class, then you are ready to run this application
    and test the *REST API* using *Insomnia*.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before running the project, go to the MySQL Workbench app, the `cha6_dbtest` table,
    and `cha6_dbtest_schema`. There you will notice that there will be no table named `user_jpa`,
    which was mentioned in the `UserModel` class as a table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the schema where we have no table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/188960bb-780e-4a2d-8682-c8b01b212ced.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run the application, check the database again, and *refresh* the schema.
    Notice that now there is a table as we mentioned in the `@Table` annotation of
    the `UserModel`. This has all the columns of that object, including—`id`, `name`, `email`,
    and `contact_number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the updated database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1218d344-9441-4430-8872-30c29dc0306b.png)'
  prefs: []
  type: TYPE_IMG
- en: The testing system is the same as the JDBC. Please check this yourself, and
    if you are confused, then go to the `Testing the Output of JDBC` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the REST API URL of this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://localhost:8080/users`: To get a list of all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://localhost:8080/user/1`: To get a specific user details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST http://localhost:8080/user/new`: To insert a new user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT http://localhost:8080/user/1`: To update a specific user details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE http://localhost:8080/user/2`: To delete a specific user details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database of client-side application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you have learned about databases for the server-side. Now
    we are going to understand databases for the client-side. The Android application
    will be our client-side application. The demand for Android is now rapidly increasing,
    and it has also surpassed the PC-based operating systems. Even nowadays, hardware
    is also more powerful than a PC or laptop.
  prefs: []
  type: TYPE_NORMAL
- en: The database is the essential part for a smart device, and it is the best way
    to store and manage the data on a device. This data can be handled in two ways.
    One way is online based, which means all the data is handled by a server-side
    or cloud and mobile communicates with them through the network. Without the internet
    connection, this system is almost useless. The second option is to store all the
    data in the local database. This means that it can be used offline and is also
    less dependent on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some criteria for the mobile-based database:'
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent from an online server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to handle using the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be shared publicly or privately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low power consumption and low memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are lots of mobile databases available on the market but very few databases
    have met these criteria. *SQLite*, *Realm* DB,and *ORMLite* are few of them.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the SQLite database throughout this book. However, we are not going
    to use the raw SQLite. We will instead use a library called **room persistence
    library**, which is part of the architecture components. IT provides an abstraction
    layer over the SQLite. This allows database access that is more robust and helps with
    much less code.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **architecture components** are one of the components of Android Jetpack.
    This is a guideline for application architecture. This component is built on some
    libraries to do common tasks in an easier way. With the help of this component,
    a developer can develop their project, which can be robust, maintainable, and
    testable.
  prefs: []
  type: TYPE_NORMAL
- en: Today we will create an Android offline application where we will use Android
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the diagram of this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4036109a-4261-42a4-8c4a-827082753e00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a brief description of all the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UI Controller`: UI components like activities and fragments are under this
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModel`: This fetches data with the help of model and provides it to the
    UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveData`: This class holds the observable data. This is lifecycle-aware,
    unlike the regular observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repository`: This manages multiple data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Room Database`: This is a top database layer, which is from the SQLite database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entity`: This describes a database table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAO`: The full form is **a data access object** (**DAO**). It maps SQL queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite database`: Data is stored using this in the device. It is created and
    maintained by the room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a simple Android app that has a database. This will store the details
    of users (including name, contact number, and email ID) and show these details
    in a list using `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create an app from Android Studio, write down your
    project, and the company domain. Don''t forget to check Include Kotlin support
    to make it a Kotlin-based application. The following screenshot shows the Create Android Project window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aa17e9c-f14d-4317-8c77-eb74dd4679b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now select the minimum API version from the Phone and Tablet option. There is
    no need to add other options for this project. After clicking Next in the Add
    an Activity to Mobile, you can select Basic Activity and then, after renaming
    the **Activity Name** and **layout**, click Finish. After building the project,
    you will be ready to start creating an Android app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the Add an Activity to Mobile window and here we
    select the Basic Activity template like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26c14aa1-f124-4f41-9194-6b8143ecb1f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final files of this project are shown in the following screenshot, where
    you can see all the files and resources after finishing this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60d4d013-e5f3-4f79-a3c5-23a86660368c.png)'
  prefs: []
  type: TYPE_IMG
- en: Gradle information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the details of my Android Studio''s Gradle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This file injects the dependencies of the Gradle and Kotlin. In this project,
    the Gradle version is 3.2.1 and the Kotlin version is 1.3.10
  prefs: []
  type: TYPE_NORMAL
- en: Gradle dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Gradle file is for the application. It contains all the dependencies and
    other Android SDK versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the following code in the dependencies block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the coroutines features, add the following code end of the app''s
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Creating entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a class of user named `UserModel.kt` with the `@Entity` annotation
    so that each user is an entity. All variables columns shouldn''t be private and
    so that `Room` will able to instantiate your objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what is in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity(tableName = "users")`: An entity class represents a table, and our
    table name is `users`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ColumnInfo(name = "**")`: This specifies a name in the table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PrimaryKey(autoGenerate = true)`: This means the `ID` is our primary key
    and it will automatically increase the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NonNull`: This means there will be no null or empty value in the columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To pass this object from one activity to another, we need to convert this class
    into a `Parcelable` class. So let''s extend this class. In the traditional way,
    it will need lots of code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, it's really complex to understand and handle, though we don't need to modify
    the override functions and constructors. However, if you omit these lines, then,
    of course, you will be happy, and your code will look nice. To do this, we need
    to apply the lazy coder's way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need an annotation named `@Parcelize` on top of the model class. Here
    is the full code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So there is no more extra code. To enable this, you need to add the following
    code in the `android` block of the `build.gradle (Module: app)` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Creating the DAO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an interface named `UserDAO.kt`, and annotated with `@DAO` annotation.
    This will help `Room` to identify the `DAO` class. Here is the code for the `DAO`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this interface, we will create functions that will be responsible for inserting,
    deleting, and getting the user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `@Insert` is used to insert a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, `@Query("DELETE FROM USERS")` is used to delete all the
    users from the `USERS` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `@Query("SELECT * FROM USERS")` is used to get all the users as
    a list from the `USERS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LiveData class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data always changes dynamically and so we have to keep it updated and show the
    latest result to users. For this reason, we need to observe the data. `LiveData`
    is a lifecycle library class that can observe the data and react.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wrap the `getAllUsers()` function of `UserDao.kt` with the `LiveData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `@Query("SELECT * FROM USERS")` is to get all the information from the `USERS`
    table
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is the full code of the DAO interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the `MainActivity`, we will see how to create an `Observer` of the data and
    override the observer's `onChanged()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Room database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Room` is not a database but a layer of the `SQLite` database. It mainly uses
    `DAO` and the queries to make it easier to fetch the database for the clients.
    It doesn''t use the main thread, but runs asynchronously on a background thread
    and so the UI performance doesn''t fall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an abstract class named `UsersRoomDatabase` and extend `RoomDatabase`.
    Use the `@Database` annotation with an entity of `Users` class and add the version
    number. Lastly, initialize an abstract function of the `UserDao` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a singleton. This will handle multiple instances of the database
    when it opens at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `UsersRoomDatabase` object.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the `UsersRoomDatabase` is `"user_database"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the piece of code for this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Populating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store data in the database, we can input some demo data by using the code
    for the users. The rest of the data will be stored by using the `NewUserActivity.kt` class.
  prefs: []
  type: TYPE_NORMAL
- en: For the demo data, we are creating a simple function where we insert two demo
    user details and it will show after running the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s create an inner callback named `UserDatabaseCallback()`
    with the `CoroutineScope` parameter and extend `RoomDatabase.Callback()`. Lastly,
    we will override the `onOpen(db: SupportSQLiteDatabase)` and there we can add
    two random user objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here we have created the user details using the `userDao.addNewUser()`. These
    user details will show in the listview if we run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to add the callback to the database and call `build()` to finish
    this callback like this code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a callback class named `UserDatabaseCallback`
    where we populate the database using the `DAO` function named `userDAO()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add this callback in the `instance` of `getDatabase()` function using `addCallback().`
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repository class is the bridge between the `Room` database and the `ViewModel`.
    This provides data from multiple data sources and isolates the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: We can separate this repository into two sections; one is DAO, which is mainly
    used for the local database and to connect the local database with the application.
    Another section is the network, which is mainly used for handling and communicating
    between the cloud and application.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a repository class named `UsersRepository.kt` and declare `UserDAO`
    as the constructor of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of `UsersRepository.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have initialized the user list. Now the `Room` will execute all queries.
    The queries will be done in a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveData` will notify the callback function if there are any changes in the
    database. The `insert(user: Users)` is the function that is used to wrap the `addNewUser()`.
    This insert function has to run on a non-UI thread or the application will crash.
    To avoid this, we need to use `@WorkerThread` annotation, which helps to execute
    this function on a non-UI thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now create a `ViewModel` class named `MainViewModel.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `MainViewModel.kt` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This class gets the `Application` as a parameter and extends the `AndroidViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a private variable of `WordRepository` and a `LiveData`, which will
    cache the list of the users.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` block, add a `UserDAO` reference from the `UsersRoomDatabase`.
    Initialize the `mAllUsers` with the `mRepository.mAllUsers`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need an activity where we will create a function to insert the user
    details and save into the database. Right-click on the app folder and create Empty
    Activity named `NewUserActivity.kt` like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a210195e-3448-4fc6-a628-916ba645cdb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code of the layout of this class named `activity_new_user.xml`.
    (The entire code can be found at GitHub link):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added four `EditText` where we can input—`username`, `contactNumber`,
    `email`, `address`, and a button named `buttonSave` to save this information into
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the `NewUserActivity.kt` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `View.OnClickListener` and override the `onClick(view: View?)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `onCreate()`,  `setOnClickListener()` for the `buttonSave`, and override
    the `onClick(view: View?)` that we want to execute with the button. Lastly, we
    call an `Intent`, which will change the activity from the **`UserModel`** to the
    `MainActivity` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isTextFieldEmpty()` is designed to check whether the `EditText` fields
    are empty or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we get all the text, make a `UserObject`, and pass this *Parcelable user
    object* to the `MainActivity` using `intent.putExtra(getString(R.string.result_replay),
    users)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom RecyclerView adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show all the user list, we will use the `RecyclerView`. For our project,
    we need to customize the `RecyclerView` adapter in our own way. In this adapter,
    we mainly pass the user model. This will show the username, email, and contact
    number. Let''s create an adapter named `UserListAdapter.kt` and extend `RecyclerView.Adapter<UserListAdapter.UserViewHolder>()`. Here
    is the code for the `UserListAdapter.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we initialize four attributes of the `activity_new_user.xml` in the `UserViewHolder`
    inner class :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We have set the **userModel**''s value in these four attributes in `onBindViewHolder()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Implementing RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RecyclerView` is a list where we can see all the user list. `RecyclerView`
    is a part of design material that helps to make the list smoother and faster to
    load the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainActivity`, we set `RecycleView` in the `onCreate()` function as
    shown by this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Modifying main activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's modify this `MainActivity` class to complete our project. Let's start
    by connecting the UI to the database. We will use the `RecyclerView` to show the
    list of data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a variable of `ViewModel` as shown by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ViewModelProviders` to connect the `MainViewModel` with `MainActivity`. In
    `onCreate()`, we will get the `ViewModel` from the `ViewModelProvider` as shown
    by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `LiveData` observer let''s add this `observe()` for `getAllUsers()` as
    shown by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Getting data from another activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned in the *Creating new activity* section that we have passed the *Parcelable*
    user object to the `MainActivity`. To get this object, we need to create a request
    code. Let''s create a request code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now override the `onActivityResult()` function, where we will retrieve the passed
    object of the `NewUserActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of `onActivityResult()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `getParcelableExtra()` is used to retrieve a `Parcelable` object. After
    then, we call the `mMainViewModel.insert(users)` to insert the returned `User`
    into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding XML layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `content_main.xml`, we add the `RecyclerView`. Here is the code of this
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Switching another activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `activity_main.xml`, we have added a `FloatingActionButton`, which we
    will use to go to **`NewUserActivity`. **To complete this task, use the following
    code in the `onCreate()` with the mentioned request code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here is the complete code of `MainAcivity.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have completed the project, *run* the application. We will explore
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Run the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After running the app on your Android device or emulator, you will see this
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e30c6d3-fb11-45ab-99ad-43a3e6d4ab73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see our pre-added user details here. Now click the float button and
    go to the new user activity where you can write down the information of a user
    as shown by this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02cff585-854a-4cb1-bed2-014976dcde08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, click the Save button. You can now see the new username, which is displayed
    as **Naruto** in this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a347746d-1a37-4c8a-8e10-fdd0e2378794.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in this way we have learned how to use `Room` for the local database. In
    the next chapter, you will see more use of this library in an Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database itself is a large platform and we have covered those parts that
    are relevant to our Spring and Android projects and contents. In this chapter,
    we have learned what the database is, as well as looking at the various types
    of it. We have seen a brief description of the DBMs. After that, we have learned
    about the JDBC, which is an API specification for connecting and moving data from
    frontend to backend. Then we have developed a project using JDBC where we created,
    read, updated, and deleted data from the databases. After this topic, we have
    learned another API called JPA, which is an approach to ORM and a system that
    maps Java objects to database tables and vice-versa. Then we have learned more
    about the JPA and its use with the help of a project. There, we have also learned
    about CRUD-based REST API. Lastly, we have learned about the latest technology
    of Android called architecture components. Also, we looked at one of the components
    called `Room`, which is a wrap of the top level of the SQLite database. Finally,
    I want to reiterate that this database chapter has not explained everything. If
    you want to learn more about the database, you can read our recommended books,
    and we have mentioned the links with the names of the books and authors under
    the *Further reading* section. In the next chapter, you can learn about the concurrency,
    which means the ability of different units of a program, algorithm, or problem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the H2 in the Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a resource in REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the full meaning of CRUD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the DAO and repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SQLite?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What datatypes does SQLite support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the standard SQLite commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the disadvantages of SQLite?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Spring Persistence with Hibernate* ([https://www.packtpub.com/application-development/spring-persistence-hibernate](https://www.packtpub.com/application-development/spring-persistence-hibernate))
    by Ahmad Seddighi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Full Stack Development with Spring Boot 2.0 and React* ([https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react](https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react))
    by Juha Hinkula'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with Data and Cloud in Spring 5.0 [Video]* ([https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video)[)
    by Ranga Rao Karanam](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Android Database Programming* ([https://www.packtpub.com/application-development/android-database-programming](https://www.packtpub.com/application-development/android-database-programming))
    by Jason Wei'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
