- en: Accessing the Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数据库
- en: In this chapter, we will learn about the database in the Spring Framework. The
    database is a collection of data that is stored in the server in an organized
    way, so that an application can retrieve the data in the way that the user requests.
    In this chapter, you will learn how to use the database on both the client and
    server side. In addition to this, we will explore the usage of JDBC, JPA, Hibernate,
    and MySQL from the server side, and we will look at the room persistence library
    from the client side.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Spring 框架中的数据库。数据库是一个以有组织的方式存储在服务器上的数据集合，以便应用程序可以以用户请求的方式检索数据。在本章中，您将学习如何在客户端和服务器端使用数据库。此外，我们将从服务器端探索
    JDBC、JPA、Hibernate 和 MySQL 的使用，并从客户端端查看 room 持久库。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: What is a database?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是数据库？
- en: What is a database management system?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是数据库管理系统？
- en: Data access in Spring.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 中的数据访问。
- en: Data access with JDBC in Spring.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 中的 JDBC 数据访问。
- en: Creating a sample project using JDBC.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDBC 创建示例项目。
- en: Data access with JPA and Hibernate in Spring.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring 中使用 JPA 和 Hibernate 进行数据访问。
- en: Creating a sample project using JPA + Hibernate.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JPA + Hibernate 创建示例项目。
- en: What is the room persistence library?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 room 持久库？
- en: Creating an Android application using the room persistence library.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 room 持久库创建 Android 应用程序。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We have previously demonstrated how to set up the environment and what tools,
    software, and IDE are needed in order to develop Spring. To create your project,
    visit this link: [https://start.spring.io/](https://start.spring.io/). The following
    options will be available here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经演示了如何设置环境以及开发 Spring 所需的工具、软件和 IDE。要创建您的项目，请访问此链接：[https://start.spring.io/](https://start.spring.io/)。这里将提供以下选项：
- en: Maven project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 项目
- en: Language – Kotlin
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言 – Kotlin
- en: Spring Boot version – 2.1.1 (SNAPSHOT)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 版本 – 2.1.1 (SNAPSHOT)
- en: When you create the project, you need to provide some information, such as—**Group**,
    **Artifact**, **Name**, **Description**, **Package Name**, **Packaging**, and
    **Java Version**.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您创建项目时，您需要提供一些信息，例如——**组别**、**工件**、**名称**、**描述**、**包名**、**打包方式**和**Java 版本**。
- en: 'We will use MySQL in upcoming projects. Consequently, you need to download
    the tools for MySQL from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)
    and install it. Please try to configure the MySQL database with the given information
    to make your project easier:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在即将到来的项目中使用 MySQL。因此，您需要从 [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)
    下载 MySQL 工具并安装它。请尝试使用给定信息配置 MySQL 数据库，以便使您的项目更容易：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code with an example for this chapter is available on GitHub at the
    following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可在 GitHub 上的以下链接找到：[https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06)。
- en: Database
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: A **database** is a collection of information that is stored in the server in
    an organized way. A user can fetch and use this data from the server in various
    systems. In the database, a user can add, delete, update, get, or manage the data.
    Normally, data is assembled into tables, columns, and rows, making it easier to
    find relevant data. A computer database contains aggregations of data records
    or files. A company's data can include their statistics or client information,
    or it can be top secret documents. A database manager provides the client or the
    user with the ability to control read and/or write access, analyze the data, and
    so on. We will now look at various types of database and their uses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**是一个以有组织的方式存储在服务器上的信息集合。用户可以从服务器在各种系统中检索和使用这些数据。在数据库中，用户可以添加、删除、更新、获取或管理数据。通常，数据被组装成表格、列和行，这使得查找相关数据变得更容易。计算机数据库包含数据记录或文件的聚合。公司的数据可以包括他们的统计数据或客户信息，或者可能是绝密文件。数据库管理员为客户提供或用户控制读写访问、分析数据等的能力。现在我们将探讨各种数据库类型及其用途。'
- en: Types of database
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库类型
- en: Databases are used for a variety of purposes, such as to store personal or company
    information. There are several databases available on the market, as described
    in the following sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库用于各种目的，例如存储个人或公司信息。市场上有几种数据库，如下文所述。
- en: Personal database
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人数据库
- en: A personal database is designed for data stored on a personal computer. This
    database is small and very easy to manage, and it is normally used by a small
    group of people or a small organization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 个人数据库是为存储在个人计算机上的数据设计的。这个数据库很小，非常易于管理，通常由一小群人或一个小组织使用。
- en: Relational database
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: The relational database is created on a set of tables that fit into a pre-defined
    category. These databases are sorted by an arrangement of tables where information
    gets fit into a pre-characterized class. The table is comprised of rows and columns.
    The column has a passage for information for an explicit classification. On the
    other side, rows contain a case for that information characterized by the classification.
    The relational database has a standard user and application program interface
    named **Structured Query Language** (**SQL**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是在一组适合预定义类别的表中创建的。这些数据库通过表格的排列进行排序，其中信息适合预定义的类别。表由行和列组成。列有一个信息传递的通道，用于明确的分类。另一方面，行包含一个信息案例，该信息由分类所表征。关系型数据库有一个名为**结构化查询语言**（**SQL**）的标准用户和应用程序程序接口。
- en: Distributed database
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式数据库
- en: A distributed database is stored in multiple physical locations and distributed
    at various sites of an organization. The sites are connected with the help of
    communication links, so the user can access the distributed data easily. There
    are two kinds of distributed database—homogeneous and heterogeneous. In a homogenous
    distributed database, the physical locations have the same hardware and run in
    the same OS and database applications. However, in the heterogeneous distributed
    database, the hardware, OS, or database applications can be found in a different
    location.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式数据库存储在多个物理位置，并在组织的各个地点进行分布。这些地点通过通信链路连接，因此用户可以轻松访问分布式数据。分布式数据库有两种类型——同构和异构。在同构分布式数据库中，物理位置具有相同的硬件，运行在相同的操作系统和数据库应用程序中。然而，在异构分布式数据库中，硬件、操作系统或数据库应用程序可能位于不同的位置。
- en: Object-oriented database
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象数据库
- en: In an object-oriented database, items are created by using object-oriented programming
    such as Java and C++, which are stored in relational databases. But for those
    items, an object-oriented database is well-suited. An object-oriented database
    is sorted out around objects as opposed to activities, and information instead
    of rationale.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在面向对象的数据库中，项目是通过使用面向对象编程（如Java和C++）创建的，这些项目存储在关系型数据库中。但对于这些项目，面向对象的数据库非常适合。面向对象的数据库是围绕对象而不是活动，以及信息而不是理由来排序的。 '
- en: NoSQL database
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: A NoSQL database is normally used for a large set of distributed data. This
    database is very effective for big data where an organization analyzes large chunks
    of unorganized data stored in multiple virtual servers in the cloud.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库通常用于大量分布式数据。这种数据库在处理大数据方面非常有效，其中组织分析存储在云中多个虚拟服务器上的大量未组织数据。
- en: Graph database
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据库
- en: A graph database is a type of NoSQL database that uses graph theory to store,
    map, and query the relationships of the data. It is a collection of lots of nodes
    and edges. The nodes represent the entity and the edges represent the connection
    between nodes. This database is used a lot in social media platforms such as Facebook.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库是一种使用图论来存储、映射和查询数据关系的NoSQL数据库。它是由许多节点和边组成的集合。节点代表实体，边代表节点之间的连接。这种数据库在社交媒体平台如Facebook上使用得很多。
- en: Cloud database
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云数据库
- en: A cloud database is mainly built for a virtualized environment. The virtualized
    environment can be a hybrid cloud, public cloud, or private cloud. These databases
    provide various benefits, such as the ability to pay for storage capacity and
    per-user basis bandwidth. As a software-as-a-server, it provides support to enterprise
    business applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 云数据库主要是为虚拟化环境构建的。虚拟化环境可以是混合云、公有云或私有云。这些数据库提供了各种好处，例如按存储容量和按用户基础带宽付费的能力。作为一个软件即服务（SaaS），它为企业的业务应用提供支持。
- en: Database management system
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库管理系统
- en: A **database management system** (**DBMS**) is system software that is made
    for creating and managing databases. With the help of the **DBMS**, a user or
    a developer can create, get, update, and manage data in a systemic way. This system
    is kind of an interface between a user and a database. It also ensures that data
    is consistently organized and easily accessible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库管理系统（DBMS**）是一种系统软件，用于创建和管理数据库。借助 **DBMS**，用户或开发者可以以系统化的方式创建、获取、更新和管理数据。这个系统在用户和数据库之间充当一种接口。它还确保数据得到一致的组织并易于访问。'
- en: 'Here is a diagram regarding the use of a **DBMS**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于使用 **DBMS** 的图示：
- en: '![](img/d25e9f1c-fb8a-4046-8422-fa9d3ca02d48.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d25e9f1c-fb8a-4046-8422-fa9d3ca02d48.png)'
- en: There are three important features of a **DBMS**, and these are the data, the
    database engine, and the database schema. The data is a collection of information,
    the database engine allows data to be locked, accessed, and modified, and the
    database schema defines the logical structure of the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库管理系统（DBMS**）有三个重要特性，这些特性包括数据、数据库引擎和数据库模式。数据是一系列信息的集合，数据库引擎允许数据被锁定、访问和修改，而数据库模式定义了数据库的逻辑结构。'
- en: The **DBMS** provides a general view of how data can be accessed by multiple
    users from multiple locations in a controlled manner. It also limits a user's
    access to user data. The database schema provides the logic of how a user can
    view the data. The **DBMS** handles all the requests and executes them on the
    database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**DBMS** 提供了一个通用的视图，说明多个用户可以从多个位置以受控的方式访问数据。它还限制了用户对用户数据的访问。数据库模式提供了用户如何查看数据的逻辑。**DBMS**
    处理所有请求并在数据库上执行它们。'
- en: Both logical and physical data independence is offered by the **DBMS**. This
    means that an application can use APIs to utilize the data from the database.
    In addition, clients and applications don't need to worry about the locations
    of the stored data and changes to the physical structure of the data, such as
    storage and hardware.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**DBMS** 提供了逻辑和物理数据独立性。这意味着应用程序可以使用 API 来利用数据库中的数据。此外，客户端和应用程序无需担心存储数据的地点以及数据物理结构的更改，如存储和硬件。'
- en: 'Popular database models and their management systems include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 流行数据库模型及其管理系统包括以下内容：
- en: '**Relational database management system** (**RDMS**)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系数据库管理系统（RDBMS**）'
- en: NoSQL DBMS
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL DBMS
- en: '**In-memory database management system** (**IMDBMS**)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存数据库管理系统（IMDBMS**）'
- en: '**Columnar database management system** (**CDBMS**)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列式数据库管理系统（CDBMS**）'
- en: Cloud-based data management system
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于云的数据管理系统
- en: Data access in the Spring
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 中的数据访问
- en: Data access is responsible for authorizing access to data repositories. It helps
    to distinguish the *role* ability, like users or administrators in the application.
    It maintains the data access system, such as insert, retrieve, update, or delete
    based on the role. In [Chapter 3](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml),
    *Overview of Spring Framework*, we have learned about the architecture of Spring.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问负责授权访问数据存储库。它有助于区分 *角色* 能力，如应用程序中的用户或管理员。它维护数据访问系统，如基于角色的插入、检索、更新或删除。在 [第
    3 章](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml)，*Spring 框架概述* 中，我们学习了 Spring
    的架构。
- en: 'Here is a diagram of the Spring architecture, where **Data Access** is one
    of the layers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Spring 架构的图示，其中 **数据访问** 是其中一层：
- en: '![](img/76a06808-b5d5-4223-957f-a4c24fa9088a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76a06808-b5d5-4223-957f-a4c24fa9088a.png)'
- en: As you can see, **Data Access** is one of the layers of Spring architecture.
    This part is concerned with data access. **JDBC**, **ORM**, **OXM**, **JMS**,
    and **Transactions** modules are modules that are used in Spring. We have mentioned
    the details of this in [Chapter 3](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml),
    *Overview of Spring Framework*, under the Spring architecture topic. In this chapter,
    we will see the use of **JDBC** and **ORM** (**JPA**, **Hibernate**).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**数据访问** 是 Spring 架构的层之一。这部分关注数据访问。**JDBC**、**ORM**、**OXM**、**JMS** 和 **事务**
    模块是 Spring 中使用的模块。我们已在 [第 3 章](5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml)，*Spring
    框架概述* 下的 Spring 架构主题中提到了这些细节。在本章中，我们将看到 **JDBC** 和 **ORM**（**JPA**、**Hibernate**）的使用。
- en: Java database connectivity in Spring
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 中的 Java 数据库连接
- en: '**Java Database Connectivity** (**JDBC**) is an API specification for connecting
    and moving data from the frontend to the backend. The classes and interfaces are
    written in Java. Nowadays, it also supports Kotlin. We will write in Kotlin throughout
    this chapter. This basically acts as an interface or bridge between the Java-based
    application and database. JDBC is very similar to the **Open Database Connectivity**
    (**ODBC**).Like ODBC, JDBC enables a JDBC application to access a collection of
    data.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 数据库连接**（**JDBC**）是一个连接和从前端到后端移动数据的 API 规范。类和接口是用 Java 编写的。如今，它也支持 Kotlin。我们将在本章中用
    Kotlin 编写。这基本上充当了基于 Java 的应用程序和数据库之间的接口或桥梁。JDBC 与 **开放数据库连接**（**ODBC**）非常相似。像
    ODBC 一样，JDBC 允许 JDBC 应用程序访问数据集合。'
- en: 'In the Spring Framework, the JDBC is divided into the following four separate
    packages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 框架中，JDBC 被分为以下四个独立的包：
- en: '**Core**: This is the JDBC''s core functionality and `JdbcTemplate`, `SimpleJdbcInsert`,
    and `SimpleJdbcCall` are the important classes of this core part'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心**：这是 JDBC 的核心功能，`JdbcTemplate`、`SimpleJdbcInsert` 和 `SimpleJdbcCall` 是这个核心部分的重要类'
- en: '**DataSource**: This is used to access data sources'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**：用于访问数据源'
- en: '**Object**: The JDBC can access in an object-oriented manner. As a business
    object, it executes queries and returns the results'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：JDBC 可以以面向对象的方式访问。作为一个业务对象，它执行查询并返回结果'
- en: '**Support**: Support classes work under core and object packages'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：支持类在核心和对象包下工作'
- en: Creating a sample project using JDBC
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 创建示例项目
- en: Let's learn JDBC using a project in which we will create REST APIs for users and
    show the list of user details. In this project, we will use JDBC, MySQL, and Spring
    Boot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个项目来学习 JDBC，在这个项目中，我们将为用户创建 REST API 并显示用户详情列表。在这个项目中，我们将使用 JDBC、MySQL
    和 Spring Boot。
- en: 'To create a project, go to this link: [https://start.spring.io](https://start.spring.io)
    and create a Kotlin-based project. Here are the dependencies of JDBC:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个项目，请访问此链接：[https://start.spring.io](https://start.spring.io) 并创建一个基于 Kotlin
    的项目。以下是 JDBC 的依赖项：
- en: '**JDBC**: this will implement all the features regarding JDBC'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDBC**：这将实现与 JDBC 相关的所有功能'
- en: '**MySQL**: this will implement all the features of MySQL database'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL**：这将实现 MySQL 数据库的所有功能'
- en: Maven dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 依赖项
- en: 'If you go to the `pom.xml` file, there you can see the dependencies for the
    JDBC, and we are using MySQL for the data. Here is a piece of code of the `pom.xml` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您转到 `pom.xml` 文件，您将看到 JDBC 的依赖项，我们使用 MySQL 作为数据源。以下是 `pom.xml` 文件的代码片段：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating DataSource
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据源
- en: 'We configure the DataSource and connection pool in the `application.properties`.
    Spring Boot uses the `spring.datasource` interface as a prefix to configure DataSource.
    Our database schema name is `packtpub_dbtest_schema`. You can create this on your
    own and rename it. Here are the details of `application.properties`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `application.properties` 中配置了 DataSource 和连接池。Spring Boot 使用 `spring.datasource`
    接口作为前缀来配置 DataSource。我们的数据库模式名称是 `packtpub_dbtest_schema`。您可以自己创建它并重命名。以下是 `application.properties`
    的详情：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: According to the previous code, `spring.datasource.url=jdbc:mysql:` `//localhost:3306/packtpub_dbtest_schema`
    means the URL for the database schema called `packtpub_dbtest_schema` to access
    the data in the project. `spring.datasource.username=root` means the username
    of the database is `root`, and `spring.datasource.password=12345678` means the
    username of the database is `12345678`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，`spring.datasource.url=jdbc:mysql://localhost:3306/packtpub_dbtest_schema`
    表示访问项目中的数据时，名为 `packtpub_dbtest_schema` 的数据库模式的 URL。`spring.datasource.username=root`
    表示数据库的用户名为 `root`，而 `spring.datasource.password=12345678` 表示数据库的密码为 `12345678`。
- en: 'In our system, the MySQL details are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统中，MySQL 的详情如下：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a table in database
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据库中创建表
- en: Go to the MySQL Workbench and select the database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 MySQL Workbench 并选择数据库。
- en: 'We have included some user details for the `USERS` table. You can copy and
    paste the following code to create a `USERS` table and insert some demo data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `USERS` 表包含了一些用户详情。您可以将以下代码复制并粘贴以创建一个 `USERS` 表并插入一些示例数据：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After inserting the user details in the user table, you can see the content
    in your `users` table, as in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户表中插入用户详情后，您可以在您的 `users` 表中看到内容，如下面的截图所示：
- en: '![](img/06df5d5d-6d98-4dfd-b94a-a44ed7f00a95.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06df5d5d-6d98-4dfd-b94a-a44ed7f00a95.png)'
- en: Creating a model
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: In this project, we will create a REST API to see the list of user details where
    we can get a username, email ID, and contact number. So let's create a model of
    a user; the class name is `UserModel.kt`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个 REST API 来查看用户详情列表，我们可以获取用户名、电子邮件 ID 和联系电话。因此，让我们创建一个用户模型；类的名称是
    `UserModel.kt`。
- en: 'Here is the code of the model class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是模型类的代码：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have created a class named `UserModel`, where we have initialized `id`, `name`,
    `email`, and `contact_number`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `UserModel` 的类，其中我们初始化了 `id`、`name`、`email` 和 `contact_number`。
- en: Creating row mapper
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行映射器
- en: '`RowMapper` is an interface that is provided by the Spring JDBC. This is used
    to map a row with a Java object and to fetch data from the database. It uses the `query()`
    function of the `JdbcTemplate` class. Let''s create a `RowMapper` interface named `UserRowMapper.kt`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowMapper` 是由 Spring JDBC 提供的一个接口。这个接口用于将一行数据映射到一个 Java 对象，并从数据库中获取数据。它使用
    `JdbcTemplate` 类的 `query()` 函数。让我们创建一个名为 `UserRowMapper.kt` 的 `RowMapper` 接口。'
- en: 'Here is the code of this interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个接口的代码：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code, we extended `RowMapper<UserModel>` and overrode the `mapRow` where
    we return the `UserModel`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们扩展了 `RowMapper<UserModel>` 并覆盖了 `mapRow` 方法，其中我们返回 `UserModel`。
- en: Creating an API interface
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 API 接口
- en: To get a REST API response, we need to create an interface where we will mention
    what we want to do with the data, such as getting the user list, creating a new
    user, and deleting or updating the user details. Let's create an interface named
    `UserInterface.kt`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取 REST API 的响应，我们需要创建一个接口，在其中我们将说明我们想要对数据进行什么操作，例如获取用户列表、创建新用户或删除或更新用户详情。让我们创建一个名为
    `UserInterface.kt` 的接口。
- en: 'Here is the code of the interface:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个接口的代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have used five functions, which are explained as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了五个函数，下面将逐一解释：
- en: '`getAllUserList()`: This will return a list of the details of all users'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllUserList()`: 这将返回所有用户详情的列表'
- en: '`getUserByID(id: Int)`: This will return the details of a specific user'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUserByID(id: Int)`: 这将返回特定用户的详情'
- en: '`addNewUser(userModel: UserModel)`: This will add new user details'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNewUser(userModel: UserModel)`: 这将添加新的用户详情'
- en: '`updateUser(userModel: UserModel)`: This will update an existing user''s details'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateUser(userModel: UserModel)`: 这将更新现有用户的详情'
- en: '`deleteUser(id: Int)`: This will delete a specific user'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteUser(id: Int)`: 这将删除特定用户'
- en: Creating a user repository
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户仓库
- en: We will communicate with the database in this class. This is a repository class
    and so we annotate this class with `@Repository`. Let's create a repository class
    named `UserRepository.kt`, which implements the `UsersInterface.`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个类中与数据库进行通信。这是一个仓库类，因此我们使用 `@Repository` 注解来标记这个类。让我们创建一个名为 `UserRepository.kt`
    的仓库类，它实现了 `UsersInterface`。
- en: 'Here is the code of the repository class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个仓库类的代码：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have created a repository class named `UserRepository`, where we implement `UsersInterface`,
    and override all the functions of the interface. We use the `@Repository` annotation
    to make it a repository class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `UserRepository` 的仓库类，其中我们实现了 `UsersInterface` 并覆盖了接口中的所有函数。我们使用
    `@Repository` 注解使其成为一个仓库类。
- en: Let's complete this class step by step in the following section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节逐步完成这个类的创建。
- en: JdbcTemplate implementation
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JdbcTemplate 实现
- en: '`JdbcTemplate` is the heart of the JDBC. This is the center class of JDBC.
    SQL queries are executed by `JdbcTemplate`, which also fetches the results. To
    use this `JdbcTemplate`, we need to autowire the `JdbcTemplate` in this repository
    class. Here is the piece of code of this repository class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 是 JDBC 的核心。这是 JDBC 的中心类。SQL 查询由 `JdbcTemplate` 执行，它也获取结果。要使用这个
    `JdbcTemplate`，我们需要在这个仓库类中自动装配 `JdbcTemplate`。下面是这个仓库类的代码片段：'
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating HTTP methods for RESTful APIs
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RESTful API 的 HTTP 方法
- en: For this project, we will create **create, read, update, and delete** (**CRUD**)
    operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将创建 **创建、读取、更新和删除** （**CRUD**） 操作。
- en: Create
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建
- en: 'Find the code snippet pertaining to the create operation, where we will insert
    the user details:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查找与创建操作相关的代码片段，其中我们将插入用户详情：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `addQuery = "INSERT INTO users (name, email, contact_number) values (?,?,?)"`
    is the query to insert the user in the USER table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`addQuery = "INSERT INTO users (name, email, contact_number) values (?,?,?)"`
    是将用户插入 USER 表的查询。'
- en: The `jdbcTemplate.update()` is the function where we use the query and user
    details as the parameters to insert in the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdbcTemplate.update()` 是一个函数，我们使用查询和用户详情作为参数将其插入数据库。'
- en: READ
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: 'Find the code snippet pertaining to the read operation. The following function
    will return a list of all the user''s details:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查找与读取操作相关的代码片段。以下函数将返回所有用户详情的列表：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`selectAllSql = "SELECT * FROM users"` is the query to fetch all the users
    from user the table. `jdbcTemplate.query()` will execute the query and fetch the
    data.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectAllSql = "SELECT * FROM users"`是查询从用户表中获取所有用户的查询。`jdbcTemplate.query()`将执行查询并获取数据。'
- en: 'This following function will get a user''s details based on `id`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将根据`id`获取用户的详细信息：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`selectAllSql = "SELECT * FROM users WHERE id = ?"` is the query to fetch a
    user from the user table by using the ID. `jdbcTemplate.queryForObjec()` will
    execute the query and fetch the data.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectAllSql = "SELECT * FROM users WHERE id = ?"`是使用ID从用户表中获取用户的查询。`jdbcTemplate.queryForObject()`将执行查询并获取数据。'
- en: UPDATE
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Find the code snippet for update operation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查找更新操作的代码片段：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`updateQuery = "UPDATE users SET name=?,email=?, contact_number=? WHERE id=?"`
    is the query to update a user from the user table by using the ID. `jdbcTemplate.update()`
    will execute the query and update the data.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateQuery = "UPDATE users SET name=?,email=?, contact_number=? WHERE id=?"`是使用ID从用户表中更新用户的查询。`jdbcTemplate.update()`将执行查询并更新数据。'
- en: DELETE
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'Find the code snippet for delete operation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查找删除操作的代码片段：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`deleteQuery = "DELETE FROM users WHERE id=?"` is the query to update a user
    from user table by using the ID. `jdbcTemplate.update()` will execute the query
    and delete the specific data.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteQuery = "DELETE FROM users WHERE id=?"`是使用ID从用户表中更新用户的查询。`jdbcTemplate.update()`将执行查询并删除特定数据。'
- en: With these functions, we have finished our repository class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些函数，我们已经完成了我们的仓库类。
- en: Creating service
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: After creating the repository class, let's create the service class where we
    will autowire the repository class using the `@autowired` annotation. Let's create
    a service class named `UserService.kt` with the `@Service` annotation that implements
    the `UserInterface` and overrides all functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建仓库类之后，让我们创建一个服务类，在这个类中我们将使用`@autowired`注解来自动装配仓库类。让我们创建一个名为`UserService.kt`的服务类，并使用`@Service`注解，它实现了`UserInterface`并覆盖了所有函数。
- en: Here is the piece of code for the `UserService.kt`**:**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`UserService.kt`的代码片段**：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s override and modify the functions with the help of `UserRepository`.
    Here is the full code of the `UserService` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助`UserRepository`来覆盖和修改函数。以下是`UserService`类的完整代码：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`getAllUserList()`: This function will fetch all the users'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllUserList()`: 这个函数将获取所有用户'
- en: '`getUserByID(id: Int)`: This function will fetch a user by ID'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUserByID(id: Int)`: 这个函数将根据ID获取用户'
- en: '`addNewUser(userModel: UserModel)`: This function will insert a new user'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNewUser(userModel: UserModel)`: 这个函数将插入一个新用户'
- en: '`updateUser(userModel: UserModel, id: Int)`: This function will update a user
    by ID'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateUser(userModel: UserModel, id: Int)`: 这个函数将根据ID更新用户'
- en: '`deleteUser(id: Int)`: This function will delete a user by ID'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteUser(id: Int)`: 这个函数将根据ID删除用户'
- en: Creating controller
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'If your model, repository, and service classes are complete, then you are ready
    to create the controller class, where we will create `GetMapping`, `PostMapping`, `PutMapping`,
    and `DeleteMapping` to create RESTful API URL paths. Let''s create a controller
    class named `UserController.kt` using the `@RestController` annotation to create
    the controller class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模型、仓库和服务类都已完成，那么你就可以创建控制器类了，在这个类中我们将创建`GetMapping`、`PostMapping`、`PutMapping`和`DeleteMapping`来创建RESTful
    API URL路径。让我们使用`@RestController`注解创建一个名为`UserController.kt`的控制器类：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Autowired service
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配服务
- en: 'Let''s autowire the `UserService` using the `@Autowired` annotation. Here is
    the piece of code for this `UserController` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`@Autowired`注解来自动装配`UserService`。以下是`UserController`类的代码片段：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting the user list
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户列表
- en: 'Find the code snippet for the `getAllUsers()` operation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`getAllUsers()`操作的代码片段：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `@GetMapping(path = ["/users"])` annotation is the URL path of `/users` and
    it is a `GET`  request function. Here, we will get a list of the users from the
    database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping(path = ["/users"])`注解是`/users`的URL路径，它是一个`GET`请求函数。在这里，我们将从数据库中获取用户列表。'
- en: Getting one user by ID
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据ID获取一个用户
- en: 'Find the code snippet for the `getAllUserByID()` operation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`getAllUserByID()`操作的代码片段：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@GetMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a `GET` request with a specific ID. Here, we will get the specific user
    details from the database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping(path = ["/user/{id}"])`注解是`"/user/{id}"`的URL路径，它是一个带有特定ID的`GET`请求。在这里，我们将从数据库中获取特定用户的详细信息。'
- en: Inserting a new user
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入新用户
- en: 'Find the code snippet for `addNewUser()` operation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`addNewUser()`操作的代码片段：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `@PostMapping(path = ["/user/new"])` annotation is the URL path of `"/user/new"`,
    and it is a `POST` request. Here, we can insert user details into the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostMapping(path = ["/user/new"])`注解是`"/user/new"`的URL路径，它是一个`POST`请求。在这里，我们可以将用户详细信息插入到数据库中。'
- en: Here, `@RequestBody` is an annotation of the Spring MVC framework. This is used
    in a controller to implement object serialization and deserialization. It helps
    you to avoid boilerplate codes by extracting the logic. The `@RequestBody` annotated
    function returns a value that is bound to the HTTP web response body. Here, the object
    is `UserModel`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`@RequestBody`是Spring MVC框架的一个注解。它在控制器中用于实现对象序列化和反序列化。它通过提取逻辑来帮助您避免样板代码。`@RequestBody`注解的函数返回一个与HTTP网络响应体绑定的值。这里的对象是`UserModel`。
- en: Updating a user
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户
- en: 'Find the code snippet for `updateUser()` operation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`updateUser()`操作的代码片段：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `@PutMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a `PUT` request with a specific ID. Here, we will update the specific
    user details in the database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PutMapping(path = ["/user/{id}"])`注解是`"/user/{id}"`的URL路径，它是一个具有特定ID的`PUT`请求。在这里，我们将更新数据库中的特定用户详细信息。'
- en: Deleting a user
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'Find the code snippet for `deleteUser()` operation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`deleteUser()`操作的代码片段：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@DeleteMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a delete request with a specific ID. Here, we will delete the specific
    user details from the database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DeleteMapping(path = ["/user/{id}"])`注解是`"/user/{id}"`的URL路径，它是一个具有特定ID的删除请求。在这里，我们将从数据库中删除特定的用户详细信息。'
- en: If you finish this controller class, then you are ready to run this application
    and test the REST API using Insomnia.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成这个控制器类，那么您就可以运行这个应用程序并使用Insomnia测试REST API了。
- en: Testing the output
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试输出
- en: 'Let''s *run* the project. If the project doesn''t experience an error, then
    you''ll be able to see the RUN tab of the IDE, as demonstrated in the following
    screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们*运行*项目。如果项目没有遇到错误，那么您将能够在IDE中看到RUN标签，如下截图所示：
- en: '![](img/5a54fe0a-7b95-4c30-9c1c-1d0e2a632881.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a54fe0a-7b95-4c30-9c1c-1d0e2a632881.png)'
- en: Now, open the Insomnia app. Let's apply the REST API request in this app.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开Insomnia应用程序。让我们在这个应用程序中应用REST API请求。
- en: Getting the user list
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户列表
- en: 'Use this `GET` request with this URL: `http://localhost:8080/users`, and hit
    Send. The user details will be fetched from the database and you can see the return
    JSON value, as the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此`GET`请求与此URL：`http://localhost:8080/users`，然后点击发送。用户详细信息将从数据库中检索，您可以看到返回的JSON值，如下截图所示：
- en: '![](img/71c87cb5-fd73-4546-89b8-355d4bb07264.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71c87cb5-fd73-4546-89b8-355d4bb07264.png)'
- en: Getting one user by ID
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取一个用户
- en: 'Create a `GET` function with this URL: `http://localhost:8080/user/1`, and
    hit Send. The user details will be fetched from the database and you can see the
    return JSON value of a user whose `id` is `1`, as in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此URL：`http://localhost:8080/user/1`创建一个`GET`函数并点击发送。用户详细信息将从数据库中检索，您可以看到具有`id`为`1`的用户返回的JSON值，如下截图所示：
- en: '![](img/636d9fb9-4c4d-4cdd-9943-d39d4ac5596a.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/636d9fb9-4c4d-4cdd-9943-d39d4ac5596a.png)'
- en: Inserting a new user
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入新用户
- en: 'Create a `POST` function with this URL: `http://localhost:8080/user/new` a
    and hit Send. This will insert a user in the database and show the new user details,
    as in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此URL：`http://localhost:8080/user/new`创建一个`POST`函数并点击发送。这将向数据库中插入一个用户并显示新的用户详细信息，如下截图所示：
- en: '![](img/3373d7b0-1c14-4c8b-801b-d4c4e6a811e4.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3373d7b0-1c14-4c8b-801b-d4c4e6a811e4.png)'
- en: 'If you use the `/users` `GET` request URL path, you can check the user list
    containing the new user:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`/users`的`GET`请求URL路径，您可以检查包含新用户的用户列表：
- en: '![](img/998d9d15-db95-4257-9342-9b940defbb2e.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/998d9d15-db95-4257-9342-9b940defbb2e.png)'
- en: Updating a user
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户
- en: 'Create an `UPDATE` function with this URL: `http://localhost:8080/user/8`,
    and hit Send. It will update the user who has the ID number eight in the database
    and shows the updated user information, as in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此URL：`http://localhost:8080/user/8`创建一个`UPDATE`函数并点击发送。它将更新数据库中具有编号八的用户，并显示更新的用户信息，如下截图所示：
- en: '![](img/207e2708-513c-4c16-ac8b-a8be932f2d29.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/207e2708-513c-4c16-ac8b-a8be932f2d29.png)'
- en: 'If you use the `http://localhost:8080/user/8` `GET` request URL path, you can
    check the new user with the new details like the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`http://localhost:8080/user/8`的`GET`请求URL路径，您可以检查具有新详细信息的新的用户，如下截图所示：
- en: '![](img/957a9089-b535-4d62-be91-8a380315a01f.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/957a9089-b535-4d62-be91-8a380315a01f.png)'
- en: Deleting a user
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'Create a `DELETE` function with this URL: `http://localhost:8080/users`, and
    hit Send. This will delete the specific user from the database, as shown in the
    following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此URL创建一个`DELETE`函数：`http://localhost:8080/users`，然后点击发送。这将从数据库中删除特定的用户，如下面的截图所示：
- en: '![](img/c140f020-594e-4845-80ca-b03ae30ccd9e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c140f020-594e-4845-80ca-b03ae30ccd9e.png)'
- en: If you check all the users, then you will see that there are only seven.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查所有用户，那么你会看到只有七个。
- en: Finally, we have created an application that is using JDBC, and we have also
    created a REST API. You can check out our GitHub project for the latest update
    if there is any. I also add a SQL file with the MySQL code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经创建了一个使用JDBC的应用程序，我们还创建了一个REST API。如果您有任何更新，可以查看我们的GitHub项目。我还添加了一个包含MySQL代码的SQL文件。
- en: Java Persistence API
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java持久化API
- en: The**Java Persistence API** (**JPA**) is an approach to **object-relational
    mapping** (**ORM**). ORM is a system that maps Java objects to databases, tables,
    and vice-versa. JPA can be used in both Java enterprise and standard edition-based
    applications. Hibernate, TopLink, EclipseLink, and Apache OpenJPA are the implementations
    of the JPA. Among these, Hibernate is the most advanced and widely used.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java持久化API**（**JPA**）是**对象关系映射**（**ORM**）的一种方法。ORM是一个将Java对象映射到数据库、表以及反向映射的系统。JPA可以用于基于Java企业版和标准版的两种应用。Hibernate、TopLink、EclipseLink和Apache
    OpenJPA是JPA的实现。在这些实现中，Hibernate是最先进且最广泛使用的。'
- en: JPA helps the developer to work directly with the objects, and therefore, there
    is no need to worry about the SQL statements. With the help of the JPA, they can
    map, store, update, and fetch the data from a relational database to a Java object
    or vice versa.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JPA帮助开发者直接与对象工作，因此无需担心SQL语句。借助JPA，他们可以将数据从关系数据库映射、存储、更新和检索到Java对象或反之亦然。
- en: JPA metadata is mainly defined by the annotation in a class. However, it also
    supports XML, which means it can be defined by XML. We will use the annotation
    to define the JPA metadata throughout this book. Now, we will see the architecture
    of JPA, and its uses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JPA元数据主要由类中的注解定义。然而，它也支持XML，这意味着它可以通过XML定义。在这本书中，我们将使用注解来定义JPA元数据。现在，我们将看到JPA的架构及其用途。
- en: Architecture of JPA
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA架构
- en: 'The following diagram shows the class-level architecture of JPA:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了JPA的类级别架构：
- en: '![](img/23abc5c8-a595-4dc1-9048-2070b34bd557.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23abc5c8-a595-4dc1-9048-2070b34bd557.png)'
- en: 'Let''s describe the diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下这个图表：
- en: '`EntityManagerFactory`: A factory class of `EntityManager` that creates and
    manages multiple `EntityManager` instances.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityManagerFactory`：`EntityManager`的工厂类，用于创建和管理多个`EntityManager`实例。'
- en: '`EntityManager`: This is an interface that manages the persistence operations
    on objects.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityManager`：这是一个接口，用于管理对象上的持久化操作。'
- en: '`Entity`: This is a persistence object that is stored as records in the database'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entity`：这是一个以记录形式存储在数据库中的持久化对象'
- en: '`EntityTransaction`: This has a one-to-one relationship with `EntityManager`.
    For each `EntityManager`, operations are maintained by the `EntityTransaction`
    class.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityTransaction`：它与`EntityManager`有一个一对一的关系。对于每个`EntityManager`，操作都由`EntityTransaction`类维护。'
- en: '`Query`: This is an interface that is implemented by each JPA vendor to obtain
    relational objects with the criteria.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query`：这是一个接口，每个JPA供应商都通过它来实现使用标准来获取关系对象。'
- en: '`Persistence`: This is a class. To obtain an `EntityManagerFactory` instance,
    it contains static methods.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Persistence`：这是一个类。要获取`EntityManagerFactory`实例，它包含静态方法。'
- en: 'If you look at the diagram again, you may notice that there is some relation
    between the classes and interfaces that belong to the `javax.presistence` package:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看图表，可能会注意到属于`javax.presistence`包的类和接口之间存在某种关系：
- en: Between `EntityManagerFactory` and `EntityManager`, there is a one-to-many relationship
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`EntityManagerFactory`和`EntityManager`之间有一个一对多关系
- en: Between `EntityManager` and `EntityTransaction`, there is a one-to-one relationship
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`EntityManager`和`EntityTransaction`之间有一个一对一关系
- en: Between `EntityManager` and `Query`, there is a one-to-many relationship
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`EntityManager`和`Query`之间有一个一对多关系
- en: Between `EntityManager` and `Entity`, there is a one-to-many relationship
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`EntityManager`和`Entity`之间有一个一对多关系
- en: Creating a project using JPA
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA创建项目
- en: Let's create a simple project using Spring Boot with JPA, as well as Hibernate
    and MySQL. We will build a RESTful CRUD API of a user list.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Boot和JPA，以及Hibernate和MySQL创建一个简单的项目。我们将构建一个用户列表的RESTful CRUD API。
- en: To create a project, go to this link: [https://start.spring.io](https://start.spring.io) and
    create a Kotlin-based project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个项目，请访问此链接：[https://start.spring.io](https://start.spring.io)并创建一个基于Kotlin的项目。
- en: Maven dependencies
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖
- en: 'If you go to the `pom.xml` file, you can see the dependencies for the JDBC
    there. We are using MySQL for the database:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问`pom.xml`文件，你可以在那里看到JDBC的依赖项。我们正在使用MySQL作为数据库：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'According to this code, here are the dependencies:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这段代码，以下是依赖项：
- en: Web
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web
- en: JPA
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA
- en: MySQL
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: H2
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H2
- en: Here, we have seen a new dependency named `h2`. This is one of the well known,
    in-memory databases. Spring Boot and H2 have a great combination between one another.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了一个新的依赖项名称`h2`。这是众所周知的一种内存数据库。Spring Boot和H2之间有着很好的组合。
- en: Creating the DataSource
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据源
- en: 'We configure the *DataSource *and *connection pool* in the `application.properties`.
    Spring boot uses the `spring.datasource` interface as a prefix to configure DataSource.
    Our database schema name is `cha6_dbtest_schema`. You can create this on your
    own and rename it. Here are the details of `application.properties`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`application.properties`中配置了`DataSource`和`connection pool`。Spring Boot使用`spring.datasource`接口作为前缀来配置DataSource。我们的数据库模式名称是`cha6_dbtest_schema`。你可以自己创建它并重命名。以下是`application.properties`的详细信息：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our system, the MySQL details are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统中，MySQL的详细信息如下：
- en: '`Host -- localhost`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host -- localhost`'
- en: '`Port -- 3306`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Port -- 3306`'
- en: '`Username -- rootPassword -- 12345678`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Username -- rootPassword -- 12345678`'
- en: '`Database Name - packtpub_dbtest`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Database Name - packtpub_dbtest`'
- en: '`Database Schema Name - packtpub_dbtest_schema`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Database Schema Name - packtpub_dbtest_schema`'
- en: Creating a model
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模型
- en: In this project, we will create a REST API to see the list of user details where
    we can get a username, email ID, and contact number. So let's create a model of
    a user where the class name is `UserModel.kt`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个REST API来查看用户详情列表，我们可以获取用户名、电子邮件ID和联系电话。所以让我们创建一个用户模型，类名为`UserModel.kt`。
- en: 'Here is the code of the model class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是模型类的代码：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, our `UserModel` class has the following fields:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的`UserModel`类有以下字段：
- en: '`id`: Primary key with auto increment'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：具有自增的主键'
- en: '`name`:  (NOT NULL field)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`:  (非空字段)'
- en: '`email`: (NOT NULL field)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: (非空字段)'
- en: '`contact_number`: (NOT NULL field)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact_number`: (非空字段)'
- en: 'Unlike JDBC, you don''t need to create any table manually in your database.
    JPA will create a table using the `UserModel`. Let''s look at how to create a
    table in our database using this `UserModel` object:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与JDBC不同，你不需要在数据库中手动创建任何表。JPA将使用`UserModel`创建一个表。让我们看看如何使用这个`UserModel`对象在我们的数据库中创建一个表：
- en: '`@Entity`: All your domain models must be annotated with this annotation. This
    annotation is used to mark the class as a persistent Java class.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity`：所有你的领域模型都必须使用这个注解。这个注解用于标记类为一个持久的Java类。'
- en: '`@Table`: This annotation is used to provide the details of the table. The
    entity will be mapped by it.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Table`：这个注解用于提供表的详细信息。实体将通过它进行映射。'
- en: '`@Id`: This is used to define the primary key.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`：这个注解用于定义主键。'
- en: '`@GeneratedValue`: This annotation is used to define the primary key generation
    strategy. In the preceding case, we have declared the primary key as an auto increment
    field.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GeneratedValue`：这个注解用于定义主键生成策略。在前面的例子中，我们已经声明主键为一个自增字段。'
- en: '`@NotBlank`: This is used to verify that the annotated field is not null or
    empty.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotBlank`：这个注解用于验证被注解的字段不为空或为空字符串。'
- en: '`@Column`: This is used to verify the properties of the column that will be
    mapped to the annotated field.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Column`：这个注解用于验证将被映射到被注解字段上的列的属性。'
- en: Creating a user repository
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户仓库
- en: We will communicate with the database in this repository class. This is a `Repository` class,
    and so we annotate it with `@Repository`. Let's create a `Repository` class named `UserRepository.kt`,
    which extends the `JpaRepository`.  By extending `JpaRepository`, this interface
    will get a set of generic CRUD functions to create, update, delete, and fetch
    the data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个仓库类中与数据库进行通信。这是一个`Repository`类，因此我们使用`@Repository`注解它。让我们创建一个名为`UserRepository.kt`的`Repository`类，它扩展了`JpaRepository`。通过扩展`JpaRepository`，这个接口将获得一组通用的CRUD函数来创建、更新、删除和获取数据。
- en: 'Here is the code of the `Repository` class:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Repository`类的代码：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here are some functions we will get from this `JPARepository`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个`JPARepository`中，我们将获得以下一些函数：
- en: '`List<T> findAll()`: To fetch all the data'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAll()`: 获取所有数据'
- en: '`List<T> findAll(Sort var1)` : To fetch all the data in sort'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAll(Sort var1)`：用于获取排序后的所有数据。'
- en: '`List<T> findAllById(Iterable<ID> var1)`: To fetch data by ID'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAllById(Iterable<ID> var1)`: 通过 ID 获取数据'
- en: '`<S extends T> List<S> saveAll(Iterable<S> var1)`: To insert data using the
    list of a data'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<S extends T> List<S> saveAll(Iterable<S> var1)`: 使用数据列表插入数据'
- en: Creating controller
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'If your model and repository classes are complete, then you are ready to create
    the controller class where we will create the `GetMapping`, `PostMapping`, `PutMapping`,
    and `DeleteMapping` to create *RESTful API URL* paths. Let''s create a controller
    class named `UserController.kt` using the `@RestController` annotation to create
    the controller class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模型和仓库类已经完整，那么您就可以创建控制器类了，我们将创建 `GetMapping`、`PostMapping`、`PutMapping` 和
    `DeleteMapping` 来创建 *RESTful API URL* 路径。让我们使用 `@RestController` 注解创建一个名为 `UserController.kt`
    的控制器类：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Autowired repository
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配仓库
- en: 'Let''s autowire the `UserRepository` using the `@Autowired` annotation. Here
    is the piece of code of this class:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `@Autowired` 注解自动装配 `UserRepository`。以下是这个类的代码片段：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Getting the user list
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户列表
- en: 'Find the code snippet for `getAllUsers()` operation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `getAllUsers()` 操作的代码片段：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `@GetMapping(path = ["/users"])` annotation means it is used to `GET` a
    request. Here, we will get a list of the users from the database using `findAll()` of
    the `UserRepository` interface, which implemented `JpaRepository`. Consequently,
    we don't need to create a *custom interface*, unlike *JDBC*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping(path = ["/users"])` 注解表示它用于 `GET` 请求。在这里，我们将使用 `UserRepository`
    接口的 `findAll()` 方法从数据库获取用户列表，该接口实现了 `JpaRepository`。因此，我们不需要创建一个 *自定义接口*，与 *JDBC*
    不同。'
- en: Getting one user by ID
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 ID 获取一个用户
- en: 'Find the code snippet `getAllUserByID()` operation as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `getAllUserByID()` 操作的代码片段如下：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `@GetMapping(path = ["/user/{id}"])` annotation is the URL path of `"/user/{id}"`,
    and it is a  `GET` request with a specific ID. Here, we return `findById(id).get()` to
    get the specific user details from the database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping(path = ["/user/{id}"])` 注解是 URL 路径 `"/user/{id}"`，它是一个具有特定 ID
    的 `GET` 请求。在这里，我们返回 `findById(id).get()` 以从数据库获取特定用户详细信息。'
- en: Inserting new user
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入新用户
- en: 'Find the code snippet for `addNewUser()` operation as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `addNewUser()` 操作的代码片段如下：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `@PostMapping(path = ["/user/"])`  annotation is the URL path of `"/user/"`,
    and it is a `POST` request. Here, we enter the details of a user to insert the
    user data in the database.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostMapping(path = ["/user/"])` 注解是 URL 路径 `"/user/"`，它是一个 `POST` 请求。在这里，我们输入用户详细信息以将用户数据插入数据库。'
- en: To bind the request body with a method parameter, we are using the `@RequestBody` annotation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将请求体绑定到方法参数，我们使用 `@RequestBody` 注解。
- en: The `@Valid` annotation makes sure that the request body is valid and not null.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Valid` 注解确保请求体有效且非空。'
- en: Here, we return `save(userModel)` to insert new user details into the database.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回 `save(userModel)` 以将新用户详细信息插入数据库。
- en: Updating a user
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户
- en: 'Find the code snippet for the `updateUser()` operation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `updateUser()` 操作的代码片段：
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `@PutMapping("/user/{id}")` annotation is the URL path of `"/user/{id}"`,
    and it is a `PUT` request with a specific ID. Here, we will update the specific
    user details in the database.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PutMapping("/user/{id}")` 注解是 URL 路径 `"/user/{id}"`，它是一个具有特定 ID 的 `PUT` 请求。在这里，我们将更新数据库中的特定用户详细信息。'
- en: Deleting a user
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'Find the code snippet for `deleteUser()` operation as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `deleteUser()` 操作的代码片段如下：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `@DeleteMapping("/user/{id}")` annotation is the URL path of `"/user/{id}"`
    and it is a `DELETE` request with a specific ID. Here we will delete the specific
    user details from the database.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DeleteMapping("/user/{id}")` 注解是 URL 路径 `"/user/{id}"`，它是一个具有特定 ID 的 `DELETE`
    请求。在这里，我们将从数据库中删除特定用户详细信息。'
- en: If you finish this controller class, then you are ready to run this application
    and test the *REST API* using *Insomnia*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了这个控制器类，那么您就可以运行这个应用程序并使用 *Insomnia* 测试 *REST API*。
- en: Seeing the output
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看输出
- en: Before running the project, go to the MySQL Workbench app, the `cha6_dbtest` table,
    and `cha6_dbtest_schema`. There you will notice that there will be no table named `user_jpa`,
    which was mentioned in the `UserModel` class as a table name.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前，请转到 MySQL Workbench 应用程序，`cha6_dbtest` 表和 `cha6_dbtest_schema`。在那里，您将注意到将没有名为
    `user_jpa` 的表，正如在 `UserModel` 类中提到的表名。
- en: 'Here is the screenshot of the schema where we have no table:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是没有表的架构截图：
- en: '![](img/188960bb-780e-4a2d-8682-c8b01b212ced.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![架构截图](img/188960bb-780e-4a2d-8682-c8b01b212ced.png)'
- en: Let's run the application, check the database again, and *refresh* the schema.
    Notice that now there is a table as we mentioned in the `@Table` annotation of
    the `UserModel`. This has all the columns of that object, including—`id`, `name`, `email`,
    and `contact_number`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行应用程序，再次检查数据库，并*刷新*模式。注意现在有一个表格，正如我们在`UserModel`的`@Table`注解中提到的。这个表格包含该对象的所有列，包括`id`、`name`、`email`和`contact_number`。
- en: 'Here is the screenshot of the updated database:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的数据库截图：
- en: '![](img/1218d344-9441-4430-8872-30c29dc0306b.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1218d344-9441-4430-8872-30c29dc0306b.png)'
- en: The testing system is the same as the JDBC. Please check this yourself, and
    if you are confused, then go to the `Testing the Output of JDBC` project.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 测试系统与JDBC相同。请自行检查，如果您感到困惑，请访问`Testing the Output of JDBC`项目。
- en: 'Here is the REST API URL of this project:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本项目的REST API URL：
- en: '`GET http://localhost:8080/users`: To get a list of all users'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:8080/users`: 获取所有用户的列表'
- en: '`GET http://localhost:8080/user/1`: To get a specific user details'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:8080/user/1`: 获取特定用户详细信息'
- en: '`POST http://localhost:8080/user/new`: To insert a new user'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST http://localhost:8080/user/new`: 插入新用户'
- en: '`PUT http://localhost:8080/user/1`: To update a specific user details'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT http://localhost:8080/user/1`: 更新特定用户详细信息'
- en: '`DELETE http://localhost:8080/user/2`: To delete a specific user details'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE http://localhost:8080/user/2`: 删除特定用户详细信息'
- en: Database of client-side application
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端应用程序数据库
- en: Up to this point, you have learned about databases for the server-side. Now
    we are going to understand databases for the client-side. The Android application
    will be our client-side application. The demand for Android is now rapidly increasing,
    and it has also surpassed the PC-based operating systems. Even nowadays, hardware
    is also more powerful than a PC or laptop.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了服务器端数据库。现在我们将了解客户端数据库。Android应用程序将是我们的客户端应用程序。Android的需求现在正在迅速增长，并且已经超过了基于PC的操作系统。即使在当今，硬件也比PC或笔记本电脑更强大。
- en: The database is the essential part for a smart device, and it is the best way
    to store and manage the data on a device. This data can be handled in two ways.
    One way is online based, which means all the data is handled by a server-side
    or cloud and mobile communicates with them through the network. Without the internet
    connection, this system is almost useless. The second option is to store all the
    data in the local database. This means that it can be used offline and is also
    less dependent on the internet.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是智能设备的核心部分，它是存储和管理设备上数据的最佳方式。这些数据可以有两种处理方式。一种方式是基于在线的，这意味着所有数据都由服务器端或云处理，而移动设备通过网络与他们通信。没有互联网连接，这个系统几乎毫无用处。第二种选择是将所有数据存储在本地数据库中。这意味着它可以在离线状态下使用，并且对互联网的依赖性也更小。
- en: 'There are some criteria for the mobile-based database:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 移动数据库有一些标准：
- en: Lightweight and fast
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级和快速
- en: Secured
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Independent from an online server
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立于在线服务器
- en: Easy to handle using the code
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码易于处理
- en: Can be shared publicly or privately
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以公开或私下共享
- en: Low power consumption and low memory
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低功耗和低内存
- en: There are lots of mobile databases available on the market but very few databases
    have met these criteria. *SQLite*, *Realm* DB,and *ORMLite* are few of them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多移动数据库，但满足这些标准的数据库却很少。*SQLite*、*Realm* DB和*ORMLite*是其中的一些。
- en: We will use the SQLite database throughout this book. However, we are not going
    to use the raw SQLite. We will instead use a library called **room persistence
    library**, which is part of the architecture components. IT provides an abstraction
    layer over the SQLite. This allows database access that is more robust and helps with
    much less code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们将使用SQLite数据库。然而，我们不会使用原始的SQLite。相反，我们将使用一个名为**room持久化库**的库，它是架构组件的一部分。它为SQLite提供了一个抽象层。这允许更健壮的数据库访问，并有助于编写更少的代码。
- en: Architecture components
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构组件
- en: The **architecture components** are one of the components of Android Jetpack.
    This is a guideline for application architecture. This component is built on some
    libraries to do common tasks in an easier way. With the help of this component,
    a developer can develop their project, which can be robust, maintainable, and
    testable.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**架构组件**是Android Jetpack的组件之一。这是一份关于应用程序架构的指南。该组件基于一些库以更简单的方式执行常见任务。借助该组件，开发者可以开发他们的项目，这些项目可以更健壮、可维护和可测试。'
- en: Today we will create an Android offline application where we will use Android
    components.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们将创建一个Android离线应用程序，我们将使用Android组件。
- en: 'Here is the diagram of this architecture:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此架构的图示：
- en: '![](img/4036109a-4261-42a4-8c4a-827082753e00.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4036109a-4261-42a4-8c4a-827082753e00.png)'
- en: 'The following is a brief description of all the components:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对所有组件的简要描述：
- en: '`UI Controller`: UI components like activities and fragments are under this
    component.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UI控制器`：活动、片段等UI组件位于此组件下。'
- en: '`ViewModel`: This fetches data with the help of model and provides it to the
    UI.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`：这个通过模型获取数据，并将其提供给UI。'
- en: '`LiveData`: This class holds the observable data. This is lifecycle-aware,
    unlike the regular observable.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData`：这个类持有可观察的数据。这是生命周期感知的，与常规的可观察数据不同。'
- en: '`Repository`: This manages multiple data sources.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：这个用于管理多个数据源。'
- en: '`Room Database`: This is a top database layer, which is from the SQLite database.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Room数据库`：这是顶层数据库层，来自SQLite数据库。'
- en: '`Entity`: This describes a database table.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entity`：这描述了一个数据库表。'
- en: '`DAO`: The full form is **a data access object** (**DAO**). It maps SQL queries.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAO`：全称是**数据访问对象**（**DAO**），它映射SQL查询。'
- en: '`SQLite database`: Data is stored using this in the device. It is created and
    maintained by the room.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite数据库`：数据使用此在设备中存储。它由room创建和维护。'
- en: Creating an Android app
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android应用
- en: Let's create a simple Android app that has a database. This will store the details
    of users (including name, contact number, and email ID) and show these details
    in a list using `RecyclerView`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的具有数据库的Android应用。这将存储用户的详细信息（包括姓名、联系电话和电子邮件ID），并使用`RecyclerView`在列表中显示这些详细信息：
- en: 'First of all, we need to create an app from Android Studio, write down your
    project, and the company domain. Don''t forget to check Include Kotlin support
    to make it a Kotlin-based application. The following screenshot shows the Create Android Project window:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用Android Studio创建一个应用，写下你的项目名称和公司域名。别忘了勾选“包含Kotlin支持”，使其成为一个基于Kotlin的应用。以下截图显示了“创建Android项目”窗口：
- en: '![](img/5aa17e9c-f14d-4317-8c77-eb74dd4679b4.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5aa17e9c-f14d-4317-8c77-eb74dd4679b4.png)'
- en: Now select the minimum API version from the Phone and Tablet option. There is
    no need to add other options for this project. After clicking Next in the Add
    an Activity to Mobile, you can select Basic Activity and then, after renaming
    the **Activity Name** and **layout**, click Finish. After building the project,
    you will be ready to start creating an Android app.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从“手机和平板”选项中选择最低API版本。此项目不需要添加其他选项。在点击“添加活动到移动”中的“下一步”后，你可以选择“基本活动”，然后重命名**活动名称**和**布局**，点击“完成”。在构建项目后，你将准备好开始创建Android应用。
- en: 'Here is the screenshot of the Add an Activity to Mobile window and here we
    select the Basic Activity template like the following screenshot:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“添加活动到移动”窗口的截图，我们选择基本活动模板，如下截图所示：
- en: '![](img/26c14aa1-f124-4f41-9194-6b8143ecb1f0.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26c14aa1-f124-4f41-9194-6b8143ecb1f0.png)'
- en: 'The final files of this project are shown in the following screenshot, where
    you can see all the files and resources after finishing this project:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的最终文件如下截图所示，其中显示了完成此项目后所有文件和资源：
- en: '![](img/60d4d013-e5f3-4f79-a3c5-23a86660368c.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60d4d013-e5f3-4f79-a3c5-23a86660368c.png)'
- en: Gradle information
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle信息
- en: 'Here are the details of my Android Studio''s Gradle file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的Android Studio的Gradle文件详情：
- en: '[PRE35]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This file injects the dependencies of the Gradle and Kotlin. In this project,
    the Gradle version is 3.2.1 and the Kotlin version is 1.3.10
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件注入了Gradle和Kotlin的依赖项。在此项目中，Gradle版本是3.2.1，Kotlin版本是1.3.10
- en: Gradle dependencies
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle依赖项
- en: This Gradle file is for the application. It contains all the dependencies and
    other Android SDK versions.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此Gradle文件是用于应用的。它包含所有依赖项和其他Android SDK版本。
- en: 'Here is the following code in the dependencies block:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中的依赖项中是以下代码：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To enable the coroutines features, add the following code end of the app''s
    `build.gradle` file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用协程功能，请在应用的 `build.gradle` 文件末尾添加以下代码：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating entity
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体
- en: 'Let''s create a class of user named `UserModel.kt` with the `@Entity` annotation
    so that each user is an entity. All variables columns shouldn''t be private and
    so that `Room` will able to instantiate your objects:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`UserModel.kt`的用户类，并使用`@Entity`注解，以便每个用户都是一个实体。所有变量列不应是私有的，这样`Room`就能实例化你的对象：
- en: '[PRE38]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what is in this class:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类中有什么：
- en: '`@Entity(tableName = "users")`: An entity class represents a table, and our
    table name is `users`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity(tableName = "users")`：一个实体类代表一个表，我们的表名是`users`'
- en: '`@ColumnInfo(name = "**")`: This specifies a name in the table'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ColumnInfo(name = "**")`：这指定了表中的名称'
- en: '`@PrimaryKey(autoGenerate = true)`: This means the `ID` is our primary key
    and it will automatically increase the value'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PrimaryKey(autoGenerate = true)`: 这意味着`ID`是我们的主键，并且它的值将自动增加。'
- en: '`@NonNull`: This means there will be no null or empty value in the columns'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NonNull`: 这意味着列中不会有null或空值。'
- en: 'To pass this object from one activity to another, we need to convert this class
    into a `Parcelable` class. So let''s extend this class. In the traditional way,
    it will need lots of code like the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此对象从一个活动传递到另一个活动，我们需要将此类转换为`Parcelable`类。所以让我们扩展这个类。按照传统方式，它将需要像以下这样的大量代码：
- en: '[PRE39]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, it's really complex to understand and handle, though we don't need to modify
    the override functions and constructors. However, if you omit these lines, then,
    of course, you will be happy, and your code will look nice. To do this, we need
    to apply the lazy coder's way.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们不需要修改重写的函数和构造函数，但理解和处理它确实很复杂。然而，如果你省略这些行，当然你会很高兴，你的代码看起来也会很漂亮。为此，我们需要应用懒人编码者的方式。
- en: 'We just need an annotation named `@Parcelize` on top of the model class. Here
    is the full code for this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在模型类顶部添加一个名为`@Parcelize`的注解。以下是完整的代码：
- en: '[PRE40]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So there is no more extra code. To enable this, you need to add the following
    code in the `android` block of the `build.gradle (Module: app)` file:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，没有更多的额外代码。为了启用此功能，你需要在`build.gradle (Module: app)`文件的`android`块中添加以下代码：'
- en: '[PRE41]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Creating the DAO
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DAO
- en: 'Let''s create an interface named `UserDAO.kt`, and annotated with `@DAO` annotation.
    This will help `Room` to identify the `DAO` class. Here is the code for the `DAO`
    interface:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`UserDAO.kt`的接口，并使用`@DAO`注解。这将帮助`Room`识别`DAO`类。以下是`DAO`接口的代码：
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this interface, we will create functions that will be responsible for inserting,
    deleting, and getting the user details:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在此接口中，我们将创建负责插入、删除和获取用户详情的函数：
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, `@Insert` is used to insert a user:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Insert`用于插入一个用户：
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the previous code, `@Query("DELETE FROM USERS")` is used to delete all the
    users from the `USERS` table:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Query("DELETE FROM USERS")`用于从`USERS`表中删除所有用户：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this code, `@Query("SELECT * FROM USERS")` is used to get all the users as
    a list from the `USERS` table.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`@Query("SELECT * FROM USERS")`用于从`USERS`表中获取所有用户作为列表。
- en: Creating the LiveData class
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建LiveData类
- en: Data always changes dynamically and so we have to keep it updated and show the
    latest result to users. For this reason, we need to observe the data. `LiveData`
    is a lifecycle library class that can observe the data and react.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 数据总是动态变化的，因此我们必须保持其更新并显示最新的结果给用户。为此，我们需要观察数据。`LiveData`是一个生命周期库类，可以观察数据并做出反应。
- en: 'Let''s wrap the `getAllUsers()` function of `UserDao.kt` with the `LiveData`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`UserDao.kt`中的`getAllUsers()`函数用`LiveData`包装：
- en: '[PRE46]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `@Query("SELECT * FROM USERS")` is to get all the information from the `USERS`
    table
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query("SELECT * FROM USERS")`用于从`USERS`表中获取所有信息。'
- en: 'So here is the full code of the DAO interface:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是DAO接口的完整代码：
- en: '[PRE47]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `MainActivity`, we will see how to create an `Observer` of the data and
    override the observer's `onChanged()` function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，我们将看到如何创建数据的`Observer`并重写观察者的`onChanged()`函数。
- en: Creating a Room database
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Room数据库
- en: '`Room` is not a database but a layer of the `SQLite` database. It mainly uses
    `DAO` and the queries to make it easier to fetch the database for the clients.
    It doesn''t use the main thread, but runs asynchronously on a background thread
    and so the UI performance doesn''t fall.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Room`不是一个数据库，而是`SQLite`数据库的一层。它主要使用`DAO`和查询来简化客户端对数据库的获取。它不在主线程上使用，而是在后台线程上异步运行，因此UI性能不会下降。'
- en: 'Let''s create an abstract class named `UsersRoomDatabase` and extend `RoomDatabase`.
    Use the `@Database` annotation with an entity of `Users` class and add the version
    number. Lastly, initialize an abstract function of the `UserDao` class:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`UsersRoomDatabase`的抽象类并扩展`RoomDatabase`。使用`@Database`注解并指定`Users`类作为实体，并添加版本号。最后，初始化`UserDao`类的抽象函数：
- en: '[PRE48]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let's create a singleton. This will handle multiple instances of the database
    when it opens at the same time.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个单例。这将处理在同时打开时数据库的多个实例。
- en: Initialize the `UsersRoomDatabase` object.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`UsersRoomDatabase`对象。
- en: The name of the `UsersRoomDatabase` is `"user_database"`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersRoomDatabase`的名称是`"user_database"`。'
- en: 'Here is the piece of code for this object:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个对象的代码片段：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Populating the database
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充数据库
- en: To store data in the database, we can input some demo data by using the code
    for the users. The rest of the data will be stored by using the `NewUserActivity.kt` class.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中存储数据，我们可以通过使用用户的代码输入一些示例数据。其余的数据将通过使用`NewUserActivity.kt`类来存储。
- en: For the demo data, we are creating a simple function where we insert two demo
    user details and it will show after running the app.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于示例数据，我们创建了一个简单的函数，其中插入两个示例用户详情，并在运行应用程序后显示。
- en: 'To do this, let''s create an inner callback named `UserDatabaseCallback()`
    with the `CoroutineScope` parameter and extend `RoomDatabase.Callback()`. Lastly,
    we will override the `onOpen(db: SupportSQLiteDatabase)` and there we can add
    two random user objects:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '要做到这一点，让我们创建一个带有`CoroutineScope`参数的内部回调`UserDatabaseCallback()`并扩展`RoomDatabase.Callback()`。最后，我们将重写`onOpen(db:
    SupportSQLiteDatabase)`，在那里我们可以添加两个随机的用户对象：'
- en: '[PRE50]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here we have created the user details using the `userDao.addNewUser()`. These
    user details will show in the listview if we run the application.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用`userDao.addNewUser()`创建了用户详情。如果运行应用程序，这些用户详情将显示在列表视图中。
- en: 'Lastly, we need to add the callback to the database and call `build()` to finish
    this callback like this code shows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将回调函数添加到数据库中，并调用`build()`来完成这个回调，就像以下代码所示：
- en: '[PRE51]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, we created a callback class named `UserDatabaseCallback`
    where we populate the database using the `DAO` function named `userDAO()`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`UserDatabaseCallback`的回调类，我们使用名为`userDAO()`的`DAO`函数来填充数据库。
- en: Then we add this callback in the `instance` of `getDatabase()` function using `addCallback().`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`addCallback()`将这个回调添加到`getDatabase()`函数的`instance`中。
- en: Implementing the repository
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现仓库
- en: Repository class is the bridge between the `Room` database and the `ViewModel`.
    This provides data from multiple data sources and isolates the data layer.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库类是`Room`数据库和`ViewModel`之间的桥梁。这提供了来自多个数据源的数据，并隔离了数据层。
- en: We can separate this repository into two sections; one is DAO, which is mainly
    used for the local database and to connect the local database with the application.
    Another section is the network, which is mainly used for handling and communicating
    between the cloud and application.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个仓库分为两个部分；一个是DAO，主要用于本地数据库以及将本地数据库与应用程序连接起来。另一个部分是网络，主要用于处理和云与应用程序之间的通信。
- en: Now create a repository class named `UsersRepository.kt` and declare `UserDAO`
    as the constructor of this class.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`UsersRepository.kt`的仓库类，并将`UserDAO`声明为这个类的构造函数。
- en: 'Here is the code of `UsersRepository.kt`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UsersRepository.kt`的代码：
- en: '[PRE52]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have initialized the user list. Now the `Room` will execute all queries.
    The queries will be done in a different thread.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经初始化了用户列表。现在`Room`将执行所有查询。查询将在不同的线程上完成。
- en: '`LiveData` will notify the callback function if there are any changes in the
    database. The `insert(user: Users)` is the function that is used to wrap the `addNewUser()`.
    This insert function has to run on a non-UI thread or the application will crash.
    To avoid this, we need to use `@WorkerThread` annotation, which helps to execute
    this function on a non-UI thread.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData`会在数据库有任何变化时通知回调函数。`insert(user: Users)`是用于包装`addNewUser()`的函数。这个插入函数必须在非UI线程上运行，否则应用程序会崩溃。为了避免这种情况，我们需要使用`@WorkerThread`注解，这有助于在非UI线程上执行这个函数。'
- en: Creating the ViewModel
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ViewModel
- en: Now create a `ViewModel` class named `MainViewModel.kt`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`MainViewModel.kt`的`ViewModel`类。
- en: 'Here is the `MainViewModel.kt` class:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`MainViewModel.kt`类：
- en: '[PRE53]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This class gets the `Application` as a parameter and extends the `AndroidViewModel`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将`Application`作为参数获取并扩展了`AndroidViewModel`。
- en: Initialize a private variable of `WordRepository` and a `LiveData`, which will
    cache the list of the users.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个`WordRepository`的私有变量和一个`LiveData`，这将缓存用户列表。
- en: In the `init` block, add a `UserDAO` reference from the `UsersRoomDatabase`.
    Initialize the `mAllUsers` with the `mRepository.mAllUsers`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`块中，从`UsersRoomDatabase`添加一个`UserDAO`引用，并将`mAllUsers`初始化为`mRepository.mAllUsers`。
- en: Creating new activity
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的活动
- en: 'Now we need an activity where we will create a function to insert the user
    details and save into the database. Right-click on the app folder and create Empty
    Activity named `NewUserActivity.kt` like the following screenshot:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个活动，我们将在这里创建一个函数来插入用户详情并将其保存到数据库中。在app文件夹上右键单击，创建一个名为`NewUserActivity.kt`的空活动，如下截图所示：
- en: '![](img/a210195e-3448-4fc6-a628-916ba645cdb0.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a210195e-3448-4fc6-a628-916ba645cdb0.png)'
- en: 'Here is the code of the layout of this class named `activity_new_user.xml`.
    (The entire code can be found at GitHub link):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个名为`activity_new_user.xml`的布局类的代码。（完整代码可以在GitHub链接中找到）：
- en: '[PRE54]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here we have added four `EditText` where we can input—`username`, `contactNumber`,
    `email`, `address`, and a button named `buttonSave` to save this information into
    the database.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了四个`EditText`输入框，可以输入`用户名`、`联系电话`、`电子邮件`、`地址`，以及一个名为`buttonSave`的按钮来将此信息保存到数据库中。
- en: 'Here is the code of the `NewUserActivity.kt` class:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`NewUserActivity.kt`类的代码：
- en: '[PRE55]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'According to the preceding code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码：
- en: 'Implement the `View.OnClickListener` and override the `onClick(view: View?)`.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '实现`View.OnClickListener`并重写`onClick(view: View?)`。'
- en: 'In the `onCreate()`,  `setOnClickListener()` for the `buttonSave`, and override
    the `onClick(view: View?)` that we want to execute with the button. Lastly, we
    call an `Intent`, which will change the activity from the **`UserModel`** to the
    `MainActivity` class.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`onCreate()`方法中，为`buttonSave`按钮设置`setOnClickListener()`，并重写我们想要与按钮一起执行的`onClick(view:
    View?)`方法。最后，我们调用一个`Intent`，这将使活动从`**UserModel**`切换到`MainActivity`类。'
- en: The `isTextFieldEmpty()` is designed to check whether the `EditText` fields
    are empty or not.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTextFieldEmpty()`函数用于检查`EditText`字段是否为空。'
- en: Then we get all the text, make a `UserObject`, and pass this *Parcelable user
    object* to the `MainActivity` using `intent.putExtra(getString(R.string.result_replay),
    users)`.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们获取所有文本，创建一个`UserObject`，并使用`intent.putExtra(getString(R.string.result_replay),
    users)`将这个可序列化的用户对象传递给`MainActivity`。
- en: Creating custom RecyclerView adapter
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义RecyclerView适配器
- en: 'To show all the user list, we will use the `RecyclerView`. For our project,
    we need to customize the `RecyclerView` adapter in our own way. In this adapter,
    we mainly pass the user model. This will show the username, email, and contact
    number. Let''s create an adapter named `UserListAdapter.kt` and extend `RecyclerView.Adapter<UserListAdapter.UserViewHolder>()`. Here
    is the code for the `UserListAdapter.kt`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示所有用户列表，我们将使用`RecyclerView`。对于我们的项目，我们需要以我们自己的方式自定义`RecyclerView`适配器。在这个适配器中，我们主要传递用户模型。这将显示用户名、电子邮件和联系电话。让我们创建一个名为`UserListAdapter.kt`的适配器并扩展`RecyclerView.Adapter<UserListAdapter.UserViewHolder>()`。以下是`UserListAdapter.kt`的代码：
- en: '[PRE56]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'According to the code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码：
- en: '[PRE57]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here we initialize four attributes of the `activity_new_user.xml` in the `UserViewHolder`
    inner class :'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`UserViewHolder`内部类中初始化了`activity_new_user.xml`的四个属性：
- en: '[PRE58]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We have set the **userModel**''s value in these four attributes in `onBindViewHolder()`
    function as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`onBindViewHolder()`函数中设置了`userModel`的这四个属性值，如下所示：
- en: '[PRE59]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Implementing RecyclerView
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现RecyclerView
- en: '`RecyclerView` is a list where we can see all the user list. `RecyclerView`
    is a part of design material that helps to make the list smoother and faster to
    load the data.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`是一个列表，我们可以看到所有用户列表。`RecyclerView`是设计材料的一部分，有助于使列表更加平滑且快速加载数据。'
- en: 'In the `MainActivity`, we set `RecycleView` in the `onCreate()` function as
    shown by this code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，我们在`onCreate()`函数中设置`RecycleView`，如下所示：
- en: '[PRE60]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Modifying main activity
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主活动
- en: Let's modify this `MainActivity` class to complete our project. Let's start
    by connecting the UI to the database. We will use the `RecyclerView` to show the
    list of data from the database.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改这个`MainActivity`类来完成我们的项目。让我们首先将UI连接到数据库。我们将使用`RecyclerView`来显示数据库中的数据列表。
- en: 'Let''s create a variable of `ViewModel` as shown by the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`ViewModel`变量，如下所示：
- en: '[PRE61]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use `ViewModelProviders` to connect the `MainViewModel` with `MainActivity`. In
    `onCreate()`, we will get the `ViewModel` from the `ViewModelProvider` as shown
    by the following code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ViewModelProviders`将`MainViewModel`与`MainActivity`连接。在`onCreate()`中，我们将从`ViewModelProvider`获取`ViewModel`，如下所示：
- en: '[PRE62]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To add the `LiveData` observer let''s add this `observe()` for `getAllUsers()` as
    shown by the following code:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`LiveData`观察者，让我们添加以下`observe()`来观察`getAllUsers()`，如下所示：
- en: '[PRE63]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Getting data from another activity
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个活动获取数据
- en: 'We mentioned in the *Creating new activity* section that we have passed the *Parcelable*
    user object to the `MainActivity`. To get this object, we need to create a request
    code. Let''s create a request code like the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建新活动*部分中，我们提到已经将可序列化的用户对象传递给了`MainActivity`。为了获取这个对象，我们需要创建一个请求码。让我们创建一个如下所示的请求码：
- en: '[PRE64]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now override the `onActivityResult()` function, where we will retrieve the passed
    object of the `NewUserActivity`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重写`onActivityResult()`函数，我们将从中检索传递的`NewUserActivity`对象。
- en: 'Here is the code of `onActivityResult()` function:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`onActivityResult()`函数的代码：
- en: '[PRE65]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `getParcelableExtra()` is used to retrieve a `Parcelable` object. After
    then, we call the `mMainViewModel.insert(users)` to insert the returned `User`
    into the database.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`getParcelableExtra()`用于检索`Parcelable`对象。然后我们调用`mMainViewModel.insert(users)`将返回的`User`插入到数据库中。'
- en: Adding XML layouts
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加XML布局
- en: 'In the `content_main.xml`, we add the `RecyclerView`. Here is the code of this
    layout:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在`content_main.xml`中，我们添加了`RecyclerView`。这是这个布局的代码：
- en: '[PRE66]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Switching another activity
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换到另一个活动
- en: 'In the `activity_main.xml`, we have added a `FloatingActionButton`, which we
    will use to go to **`NewUserActivity`. **To complete this task, use the following
    code in the `onCreate()` with the mentioned request code:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中，我们添加了一个`FloatingActionButton`，我们将使用它来进入**`NewUserActivity`**。为了完成这个任务，在`onCreate()`中使用以下代码，并指定提到的请求代码：
- en: '[PRE67]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'So, here is the complete code of `MainAcivity.kt`:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是`MainAcivity.kt`的完整代码：
- en: '[PRE68]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have completed the project, *run* the application. We will explore
    this in the next section.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了项目，*运行*应用程序。我们将在下一节中探讨这一点。
- en: Run the app
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用
- en: 'After running the app on your Android device or emulator, you will see this
    screen:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Android设备或模拟器上运行应用后，你会看到这个屏幕：
- en: '![](img/4e30c6d3-fb11-45ab-99ad-43a3e6d4ab73.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e30c6d3-fb11-45ab-99ad-43a3e6d4ab73.png)'
- en: 'We can see our pre-added user details here. Now click the float button and
    go to the new user activity where you can write down the information of a user
    as shown by this screenshot:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到我们预先添加的用户详细信息。现在点击浮动按钮，进入新用户活动页面，在那里你可以写下用户信息，如图所示：
- en: '![](img/02cff585-854a-4cb1-bed2-014976dcde08.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02cff585-854a-4cb1-bed2-014976dcde08.png)'
- en: 'Lastly, click the Save button. You can now see the new username, which is displayed
    as **Naruto** in this image:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击保存按钮。你现在可以看到新的用户名，如图中所示为**Naruto**：
- en: '![](img/a347746d-1a37-4c8a-8e10-fdd0e2378794.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a347746d-1a37-4c8a-8e10-fdd0e2378794.png)'
- en: So, in this way we have learned how to use `Room` for the local database. In
    the next chapter, you will see more use of this library in an Android application.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这样我们就学会了如何使用`Room`进行本地数据库。在下一章中，你将看到这个库在Android应用程序中的更多使用。
- en: Summary
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The database itself is a large platform and we have covered those parts that
    are relevant to our Spring and Android projects and contents. In this chapter,
    we have learned what the database is, as well as looking at the various types
    of it. We have seen a brief description of the DBMs. After that, we have learned
    about the JDBC, which is an API specification for connecting and moving data from
    frontend to backend. Then we have developed a project using JDBC where we created,
    read, updated, and deleted data from the databases. After this topic, we have
    learned another API called JPA, which is an approach to ORM and a system that
    maps Java objects to database tables and vice-versa. Then we have learned more
    about the JPA and its use with the help of a project. There, we have also learned
    about CRUD-based REST API. Lastly, we have learned about the latest technology
    of Android called architecture components. Also, we looked at one of the components
    called `Room`, which is a wrap of the top level of the SQLite database. Finally,
    I want to reiterate that this database chapter has not explained everything. If
    you want to learn more about the database, you can read our recommended books,
    and we have mentioned the links with the names of the books and authors under
    the *Further reading* section. In the next chapter, you can learn about the concurrency,
    which means the ability of different units of a program, algorithm, or problem.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库本身是一个大型平台，我们已经涵盖了与我们的Spring和Android项目及内容相关的部分。在本章中，我们学习了数据库是什么，以及查看其各种类型。我们看到了DBMs的简要描述。之后，我们学习了JDBC，它是一个连接和从前端到后端移动数据的API规范。然后我们使用JDBC开发了一个项目，在该项目中，我们从数据库中创建、读取、更新和删除数据。在这个主题之后，我们学习了另一个名为JPA的API，它是一种ORM方法，以及一个将Java对象映射到数据库表并反之亦然的系统。然后我们通过一个项目学习了更多关于JPA及其使用的内容。在那里，我们还学习了基于CRUD的REST
    API。最后，我们学习了Android的最新技术，称为架构组件。我们还查看了一个名为`Room`的组件，它是SQLite数据库顶级封装。最后，我想重申，这一章并没有解释所有内容。如果你想了解更多关于数据库的信息，你可以阅读我们推荐的书籍，我们已经在*进一步阅读*部分提到了书籍和作者的名字。在下一章中，你可以了解并发性，这意味着程序、算法或问题的不同单元的能力。
- en: Questions
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the H2 in the Spring Boot?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Boot中的H2是什么？
- en: What is a resource in REST API?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API中的资源是什么？
- en: What is the full meaning of CRUD?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRUD的全称是什么？
- en: What is the difference between the DAO and repository?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAO 和仓库之间的区别是什么？
- en: What is SQLite?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 SQLite？
- en: What datatypes does SQLite support?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLite 支持哪些数据类型？
- en: What are the standard SQLite commands?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准的 SQLite 命令有哪些？
- en: What are the disadvantages of SQLite?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLite 的缺点是什么？
- en: Further reading
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Spring Persistence with Hibernate* ([https://www.packtpub.com/application-development/spring-persistence-hibernate](https://www.packtpub.com/application-development/spring-persistence-hibernate))
    by Ahmad Seddighi'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 Hibernate 进行 Spring 持久化》* ([https://www.packtpub.com/application-development/spring-persistence-hibernate](https://www.packtpub.com/application-development/spring-persistence-hibernate))
    由 Ahmad Seddighi 著'
- en: '*Hands-On Full Stack Development with Spring Boot 2.0 and React* ([https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react](https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react))
    by Juha Hinkula'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 Spring Boot 2.0 和 React 进行全栈开发实践》* ([https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react](https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react))
    由 Juha Hinkula 著'
- en: '*Working with Data and Cloud in Spring 5.0 [Video]* ([https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video)[)
    by Ranga Rao Karanam](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《在 Spring 5.0 中处理数据和云 [视频]》* ([https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video))
    由 Ranga Rao Karanam 著](https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video)'
- en: '*Android Database Programming* ([https://www.packtpub.com/application-development/android-database-programming](https://www.packtpub.com/application-development/android-database-programming))
    by Jason Wei'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Android 数据库编程》* ([https://www.packtpub.com/application-development/android-database-programming](https://www.packtpub.com/application-development/android-database-programming))
    由 Jason Wei 著'
