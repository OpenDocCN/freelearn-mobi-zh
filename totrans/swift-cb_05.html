<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Beyond the Standard Library&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p class="p1">Apple's intention when open-sourcing Swift was to provide a cross-platform, general-purpose programming language that is ready to use. The Swift standard library provides core language features and common collection types. However, this does not provide everything needed to get up and running.</p>&#13;
<p>Therefore, Apple provides a framework called <strong>Foundation</strong> to help you perform common programming tasks that aren't covered by the core Swift language and the standard library.</p>&#13;
<p>The Foundation framework that you will use when developing for Apple platforms is <em>closed-sourced</em>, which means the underlying code is not accessible and only the API is visible. However, when Apple open-sourced Swift and made it available for Linux, it became necessary to provide the Foundation framework as well. To this end, Apple has released an open source, Swift-based version of Foundation as a core library, available here: <a href="https://github.com/apple/swift-corelibs-foundation">https://github.com/apple/swift-corelibs-foundation</a>.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Comparing dates with Foundation</li>&#13;
<li>Fetching data with <kbd>URLSession</kbd></li>&#13;
<li>Working with JSON</li>&#13;
<li>Working with XML</li>&#13;
</ul>&#13;
<h1 id="uuid-7950368a-1e86-4794-a491-48971eaa2ee5">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3cIcNUK" target="_blank">https://bit.ly/3cIcNUK</a></p>&#13;
<h1 id="uuid-5ab981ce-2d92-42f7-8028-60cd870a57f2">Comparing dates with Foundation</h1>&#13;
<p class="p1">This recipe will focus on one area of Foundation that is very widely used, that is, date and time manipulation and formatting.</p>&#13;
<p>We will create a function that determines how long there is until Christmas and returns this information as a string that can be displayed to a user.</p>&#13;
<h2 id="uuid-d8ede9db-68c6-4ccd-9e1c-0ef20ab4c81b" class="p1">Getting ready</h2>&#13;
<p>Create a new iOS playground and import the Foundation framework at the top of the playground:</p>&#13;
<pre>import Foundation</pre>&#13;
<h2 id="uuid-ccd29e90-a1b2-49c2-b971-180e108cd082" class="p1">How to do it...</h2>&#13;
<p>Let's create a function that will return a string telling us how long there is until Christmas that we can then print:</p>&#13;
<ol>&#13;
<li>Define the function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func howLongUntilChristmas() -&gt; String {<br/><br/>}</pre>&#13;
<ol start="2">&#13;
<li>Within the function, get the current calendar and time zone:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let calendar = Calendar.current<br/>let timeZone = TimeZone.current</pre>&#13;
<ol start="3">&#13;
<li>Get the current date and time and use the calendar to get the current year:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let now = Date()<br/>let yearOfNextChristmas = calendar.component(.year, from: now)</pre>&#13;
<ol start="4">&#13;
<li>Define date components that correspond to midnight on Christmas Day:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var components = DateComponents(calendar: calendar, <br/>                                timeZone: timeZone, <br/>                                year: yearOfNextChristmas, <br/>                                month: 12, <br/>                                day: 25, <br/>                                hour: 0, <br/>                                minute: 0, <br/>                                second: 0)</pre>&#13;
<ol start="5">&#13;
<li>Get a <kbd>Date</kbd> object from those components:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var christmas = components.date!</pre>&#13;
<ol start="6">&#13;
<li>If we have already passed Christmas for this year, we need to adjust the component to refer to Christmas of the next year:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// If we have already had Christmas this year, <br/>// then we need to use Christmas next year.<br/>if christmas &lt; now {<br/>  components.year = yearOfNextChristmas + 1 <br/>  christmas = components.date!<br/>}</pre>&#13;
<ol start="7">&#13;
<li>Create <kbd>DateComponentsFormatter</kbd> to format how the time until Christmas is displayed:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let componentFormatter = DateComponentsFormatter()<br/>componentFormatter.unitsStyle = .full<br/>componentFormatter.allowedUnits = [.month, .day, .hour, .minute, <br/>  .second]</pre>&#13;
<ol start="8">&#13;
<li>Use <kbd>DateComponentFormatter</kbd> to return a string for the time between now and next Christmas:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">return componentFormatter.string(from: now, to: christmas)!</pre>&#13;
<ol start="9">&#13;
<li>Below the <kbd>howLongUntilChristmas</kbd> function, use this function to create a string, and print the outcome:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let timeUntilChristmas = howLongUntilChristmas()<br/>print("Time until Christmas: \(timeUntilChristmas)")</pre>&#13;
<h2 id="uuid-df7979b8-9cdf-4e22-ba09-c023f7744894">How it works...</h2>&#13;
<p class="p1">In <em>Step 1</em>, we create our <kbd>howLongUntilChristmas</kbd> function, then in <em>Step 2</em>, we get the currently set calendar and time zone as they will be needed for the date calculations to come:</p>&#13;
<pre>let calendar = Calendar.current<br/>let timeZone = TimeZone.current</pre>&#13;
<p class="p1">While retrieving the current time zone is self-explanatory, it is not immediately obvious what the <kbd>Calendar</kbd> type represents and why we need to retrieve it.</p>&#13;
<p class="p1">How dates are represented is not as universally agreed as you might believe. Certain time components are mostly universal, such as the length of years and days, as they are connected to astronomical events, such as the time it takes for the Earth to perform one revolution of the Sun, and for the Earth to complete one rotation around its own axis, respectively. However, other time components, such as months and weeks and how the years are numbered, are rooted in the culture that created them.</p>&#13;
<div>The calendar used throughout Europe and most of the world is known as the <strong>Gregorian calendar</strong>, introduced in 1582 by Pope Gregory XIII, replacing the Julian calendar. There are about 40 different calendars currently in use around the world, including Gregorian, Chinese, Hebrew, Islamic, Persian, Ethiopian, and Balinese Pawukon.</p>&#13;
<p class="p1">The way in which we present how long there is until Christmas will depend on the calendar that is relevant to the user. This is why we ask for the current calendar, which the user can change if they want a different representation.</p>&#13;
<p class="p1">Our next task is to get the current date and time:</p>&#13;
<pre>let now = Date()</pre>&#13;
<p class="p1">In <em>Step 3</em>, the default initializer for the <kbd>Date</kbd> value type uses the current date and time as its value. Note that this date value is set at the point of creation; it does not continually update with the current date and time.</p>&#13;
<p class="p1">In this step, we get a date and time for the next Christmas. We know the time, day, and month of Christmas, so to construct a date for Christmas, we just need to know the year. There is a method on <kbd>Calendar</kbd> called <kbd>component</kbd> that allows us to retrieve specific components from a <kbd>Date</kbd> value:</p>&#13;
<pre>let yearOfNextChristmas = calendar.component(.year, from: now)</pre>&#13;
<p class="p1">We now have the current year, within the user's current calendar; we can use it to create the Christmas date.</p>&#13;
<p class="p1">In <em>Step 4</em>, we create an instance of <kbd>DateComponents</kbd>, passing in the calendar, time zone, and the fact that we are defining December 25 at midnight, for the current year:</p>&#13;
<pre>var components = DateComponents(calendar: calendar,<br/>                                timeZone: timeZone,<br/>                                year: yearOfNextChristmas,<br/>                                month: 12,<br/>                                day: 25,<br/>                                hour: 0,<br/>                                minute: 0,<br/>                                second: 0)<br/></pre>&#13;
<p class="p4">In <em>Step 5</em>, we create a <kbd>Date</kbd> object from <kbd>DateComponents</kbd>. This is of an optional type as we may not have provided enough information to the components to generate a date; however, since we know that we have, we can force-unwrap this optional:</p>&#13;
<pre>var christmas = components.date!</pre>&#13;
<p class="p1">Next, we need to handle an edge case; what if we have already had Christmas this year? For example, let's imagine that the current date is December 27, 2020; we are trying to find the date of the next Christmas, but if we use the current year, we will get December 25, 2020, which is the Christmas just gone. So, in <em>Step 6</em>, we add 1 to the current year to get next Christmas, December 25, 2021:</p>&#13;
<pre>if christmas &lt; now {<br/>   components.year = yearOfNextChristmas + 1<br/>   christmas = components.date!<br/>}</pre>&#13;
<p class="p1">To account for this, we check whether the Christmas for this year is before <kbd>now</kbd>; if it is, we bump the year component to next year and recreate the Christmas date from <kbd>DateComponent</kbd>.</p>&#13;
<p class="p1">We now have the current <kbd>Date</kbd> and the next Christmas <kbd>Date</kbd>, and Foundation provides functionality to calculate the time difference between two dates and format it to display to a user, through the use of <kbd>DateComponentsFormatter</kbd>.</p>&#13;
<p>In <em>Step 7</em>, we create <kbd>DateComponentsFormatter</kbd>, and set <kbd>unitStyle</kbd> to <kbd>full</kbd>, which will provide a string using the full unit name, without abbreviation. We configure how we want the date and time divided for display, using <kbd>allowedUnits</kbd>:</p>&#13;
<pre>let componentFormatter = DateComponentsFormatter()<br/>componentFormatter.unitsStyle = .full<br/>componentFormatter.allowedUnits = [.month, .day, .hour, .minute, <br/>  .second]<br/><br/></pre>&#13;
<p class="p1">In <em>Step 8</em>, we can retrieve a string from the formatter that describes the time between the two dates given, with the settings provided to the formatter. Since <kbd>DateComponentsFormatter</kbd> returns an optional string, we unwrap and return it:</p>&#13;
<pre>return componentFormatter.string(from: now, to: christmas)!</pre>&#13;
<p class="p1">Our <kbd>howLongUntilChristmas</kbd> method will provide a string describing how long until Christmas, which we can then print out.</p>&#13;
<h2 id="uuid-e2b4f89b-5222-42d9-9e38-5992bcbe2745" class="p1">See also</h2>&#13;
<p class="p1">There is a lot more to discover in Foundation, so check out the documentation for further functionality:</p>&#13;
<ul>&#13;
<li class="p3">Swift 3 documentation for Foundation: <a href="http://swiftbook.link/docs/foundation">http://swiftbook.link/docs/foundation</a></li>&#13;
<li class="p3">Open source repository for Foundation: <a href="https://github.com/apple/swift-corelibs-foundation">https://github.com/apple/swift-corelibs-foundation</a></li>&#13;
</ul>&#13;
<h1 id="uuid-95c259be-9920-4b6a-9fff-4100d7d9dd75">Fetching data with URLSession</h1>&#13;
<p>Every app worth building will need to send or receive information from the internet at some point and therefore, networking support is a critical part of any development platform. In Swift, this support for networking is provided by the Foundation framework.</p>&#13;
<p class="p1">When we need to retrieve information from the internet, we send out a request to a server on the internet, and that server sends a response that hopefully contains the information we requested.</p>&#13;
<p>In this recipe, we will learn how to send network requests and receive a response using the Foundation framework.</p>&#13;
<h2 id="uuid-1e479e06-4b93-4f7b-ab0d-4a463cf1a919" class="p1">Getting ready</h2>&#13;
<p class="p1">It is helpful to know of the different components that Foundation provides that deal with networking and what they do:</p>&#13;
<ul>&#13;
<li><kbd>URL</kbd>: The address of a resource on a remote server. It contains information about the server and where the resource can be found on the server.</li>&#13;
<li><kbd>URLRequest</kbd>: Represents the request that will be made to the remote server. Defines the URL of the resource, how the request should be sent, metadata in the form of headers, and data that should be sent with it.</li>&#13;
</ul>&#13;
<ul>&#13;
<li><kbd>URLSession</kbd>: Manages the communication with remote servers, holds the configuration for that communication, and creates and optimizes the underlying connections.</li>&#13;
<li><kbd>URLSessionDataTask</kbd>: An object that manages the state of the request and delivers the response.</li>&#13;
<li><kbd>URLResponse</kbd>: Holds the metadata of the response from the remote server.</li>&#13;
</ul>&#13;
<h2 id="uuid-e2a38b2b-6fc1-49e7-b0e9-c7adc9ca9059" class="p1">How to do it...</h2>&#13;
<p>Let's use these networking tools to retrieve an image from a remote server:</p>&#13;
<ol>&#13;
<li>Import <kbd>PlaygroundSupport</kbd> and set up indefinite execution for this playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true</pre>&#13;
<ol start="2">&#13;
<li>Import Foundation and create an instance of <kbd>URLSession</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import Foundation<br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<ol start="3">&#13;
<li>Next, we will construct a request for a remote image:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let urlString = "https://imgs.xkcd.com/comics/api.png"<br/>let url = URL(string: urlString)!<br/>let request = URLRequest(url: url)</pre>&#13;
<ol start="4">&#13;
<li>Now that we have our <kbd>URLRequest</kbd>, we can create a data task to retrieve the image from the remote server:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let task = session.dataTask(with: request, completionHandler: { <br/>  (data, response, error) in<br/><br/>})</pre>&#13;
<ol start="5">&#13;
<li>We will take the image data and put it in a <kbd>UIImage</kbd> object to display it. So, we need to import the <kbd>UIKit</kbd> framework, which provides <kbd>UIImage</kbd>. So, let's import <kbd>UIKit</kbd> at the top of the playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import UIKit</pre>&#13;
<ol start="6">&#13;
<li>Check for image data in the completion handler and create a <kbd>UIImage</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let task = session.dataTask(with: request) { (data, response, error)<br/>  in<br/>    guard let imageData = data else {<br/>        return // No Image, handle error<br/>    }<br/>    _ = UIImage(data: imageData)<br/>}</pre>&#13;
<ol start="7">&#13;
<li>Call <kbd>resume</kbd> on the task to start it:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">task.resume()</pre>&#13;
<h2 id="uuid-a1087811-8578-4e95-b118-0aefafa433f5">How it works...</h2>&#13;
<p>Let's walk through the previously mentioned steps to understand what we are doing:</p>&#13;
<pre>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true</pre>&#13;
<p class="p1"><strong>Playgrounds</strong> execute the code they contain from top to bottom. When the end of the playground page is reached, the playground stops executing. In our example, the task is created and started, but then the playground reaches the end of the page before the image has been fully retrieved, because this happens asynchronously. If the playground were to stop execution here, the completion handler would never be executed, and we wouldn't see the image. This isn't a problem in a normal app that is continually running while it is in use; it is just specific to how Swift playgrounds work.</p>&#13;
<p class="p1">To solve this, we need to tell the playground that we don't want it to stop executing when it reaches the end of the page and instead, it should run indefinitely while we wait for the response to be received. This is done by importing the <kbd>PlaygroundSupport</kbd> framework in <em>Step 1 </em>and setting <kbd>needsIndefiniteExecution</kbd> to be <kbd>true</kbd> on the current <kbd>PlaygroundPage</kbd>.</p>&#13;
<pre>import Foundation<br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<p>In <em>Step 2</em>, when creating <kbd>URLSession</kbd>, we pass in a <kbd>URLSessionConfiguration</kbd> object, which allows configuring the time it takes for a request to time out and cache responses, among other things. For our purposes, we will just use the default configuration.</p>&#13;
<pre>let urlString = "https://imgs.xkcd.com/comics/api.png"<br/>let url = URL(string: urlString)!<br/>let request = URLRequest(url: url)</pre>&#13;
<p>In  <em>Step 3</em>, we will be requesting the image from the excellent webcomic <em>XKCD</em> (<a href="https://xkcd.com/">http://xkcd.com</a>). We can create the URL from a string, and then create a <kbd>URLRequest</kbd> request from the URL.</p>&#13;
<pre>let task = session.dataTask(with: request, completionHandler: { (data,<br/>  response, error) in<br/><br/>})</pre>&#13;
<p>In <em>Step 4</em>, we do not create a data task directly; instead, we ask our <kbd>URLSession</kbd> instance to create the data task, and we pass in <kbd>URLRequest</kbd> and a completion handler. The completion handler will be fired once a response has been received from the remote server or some error has occurred.</p>&#13;
<p class="p1">The completion handler has three inputs, all optional:</p>&#13;
<ul>&#13;
<li class="p1"><kbd>data: Data</kbd>: The data returned in the body of the response; if our request was successful, this will contain our image data.</li>&#13;
<li class="p1"><kbd>response: URLResponse</kbd>: The response metadata, including response headers. If the request was over HTTP/HTTPS, then this will be <kbd>HTTPURLResponse</kbd>, which will contain the HTTP status code.</li>&#13;
<li class="p1"><kbd>error: Error</kbd>: If the request was unsuccessful, due to a network issue, for example, this value will have the error, and the data and response value will be <kbd>nil</kbd>. If the request was successful, this error value will be <kbd>nil</kbd>.</li>&#13;
</ul>&#13;
<pre>let task = session.dataTask(with: request) { (data, response, error) in<br/>    guard let imageData = data else {<br/>        return // No Image, handle error<br/>    }<br/>    _ = UIImage(data: imageData)<br/>}</pre>&#13;
<p>In <em>Step 6</em>, we check for response data and turn it into an image. To do this, we will need to construct a <kbd>UIImage</kbd> object from the data. <kbd>UIImage</kbd> is a class that represents an image on iOS and can be found in the <kbd>UIKit</kbd> framework. So, we also needed to import <kbd>UIKit</kbd> at the top of the playground, as we have done in <em>Step 5</em>.</p>&#13;
<p>Since we don't plan on doing anything with the image in this example, we are just going to view it in a playground preview; the compiler will complain if we assign it to a value that is never used. Therefore, we replace a normal value assignment with <kbd>_</kbd>, which allows the <kbd>UIImage</kbd> object to be generated without it being assigned to anything.</p>&#13;
<pre>task.resume()</pre>&#13;
<p>In <em>Step 7</em>, we have created the data task to retrieve the image, but we need to actually start the task to make the request. To do that, we call <kbd>resume</kbd> on the task.</p>&#13;
<p class="p1">When we run the playground, you will eventually see that the image value has been populated in the playground's right sidebar, and you can click on the preview icon to see the image that has been downloaded:</p>&#13;
<div><img src="img/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png" style="" width="940" height="977"/></div>&#13;
<p>Figure 5.1 – Retrieved image displayed in the playground timeline </p>&#13;
<h2 id="uuid-b9c3b999-0481-4b71-9839-06b1ed1d82cc" class="p1">See also</h2>&#13;
<ul>&#13;
<li>Further information about networking can be found in Apple's networking overview: <a href="http://swiftbook.link/docs/networking">http://swiftbook.link/docs/networking</a></li>&#13;
<li>More information can also be found in Apple's URL Session programming guide: <a href="http://swiftbook.link/docs/urlsession-guide">http://swiftbook.link/docs/urlsession-guide</a></li>&#13;
</ul>&#13;
<h1 id="uuid-6431d8ec-2328-4a3e-8d30-b5b5febb77fc">Working with JSON</h1>&#13;
<p class="p1">As discussed in the last recipe, almost every app will need to exchange information with the internet at some point, and in that recipe, we retrieved an image from a remote server. Very often, your app will need to retrieve more varied data, perhaps relating to the result of a search, or information about a shared state held on the server.</p>&#13;
<p class="p1">This information can be represented in any number of ways, but one of the most common ways is as <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>), which is a text-based structure for representing information. A JSON object contains key-value pairs, where the keys are strings and the values can be strings, numbers, Booleans, null, other objects, or arrays.</p>&#13;
<p class="p1">For example, information about a person could be expressed with this JSON object:</p>&#13;
<pre>{<br/>  "name": { <br/>    "givenName": "Keith",<br/>    "middleName": "David",<br/>    "familyName": "Moon"<br/>  },<br/>  "age": 40,<br/>  "heightInMetres": 1.778,<br/>  "isBritish": true,<br/>  "favouriteFootballTeam": null<br/>}</pre>&#13;
<p class="p1">The following is an example of an array of JSON objects:</p>&#13;
<pre>[<br/>  {<br/>    "name": { <br/>      "givenName": "Keith",<br/>      "middleName": "David",<br/>      "familyName": "Moon"<br/>    },<br/>    "age": 40,<br/>    "heightInMetres": 1.778,<br/>    "isBritish": true,<br/>    "favouriteFootballTeam": null<br/>  },<br/>  {<br/>    "name": { <br/>      "givenName": "Alissa",<br/>      "middleName": "May",<br/>      "familyName": "Moon"<br/>    },<br/>    "age": 35,<br/>    "heightInMetres": 1.765,<br/>    "isBritish": false,<br/>    "favouriteFootballTeam": null<br/>  }<br/>]</pre>&#13;
<p class="p1">Foundation provides tools for reading information from and writing information as JSON data. In this recipe, we will interact with a JSON-based <strong>Application Programming Interface</strong> (<strong>API</strong>), to both send and receive information.</p>&#13;
<h2 id="uuid-9e1260f8-35df-4d95-bb44-4e0dc960d252" class="p1">Getting ready</h2>&#13;
<p class="p1">Our goal is to interact with the GitHub API and create an issue for this book's repository. A full explanation of Git and GitHub is beyond the scope of this book; suffice to say that it's a service that stores versioned copies of your source code. Resources relevant to this book are stored in repositories on GitHub, and a GitHub user can create <em>issues</em> that serve as bug reports or feature requests.</p>&#13;
<p class="p1">If you don't already have one, then you will need to sign up for a GitHub account:</p>&#13;
<ol>&#13;
<li class="p3">Go to <a href="https://github.com">https://github.com</a>.</li>&#13;
<li class="p1">Fill in your details and press Sign up for GitHub.</li>&#13;
</ol>&#13;
<p class="p1">Once you have created a GitHub account, you will need to create a personal access token, which we will use to authenticate some of the requests to the GitHub API. To create a personal access token, use the following steps:</p>&#13;
<ol>&#13;
<li class="p1">Go to the settings page (<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>) and click on Generate new token.</li>&#13;
<li class="p1">Give the token a name and check the box next to repo:</li>&#13;
</ol>&#13;
<div><img src="img/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png" style="" width="1457" height="869"/></div>&#13;
<p>Figure 5.2 – Creating a personal access token</p>&#13;
<ol start="3">&#13;
<li>Click on Generate token at the bottom of the page. You will now see your newly generated personal access token.</li>&#13;
<li>Copy this token and paste it somewhere, as we will need it later:</li>&#13;
</ol>&#13;
<div><img src="img/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png" style="" width="1384" height="461"/></div>&#13;
<p>Figure 5.3 – The generated personal access token</p>&#13;
<h2 id="uuid-9b3e2d0c-fd00-4e27-8400-261946091116" class="p1">How to do it...</h2>&#13;
<p class="p1">To create our issue, we will first retrieve all of Packt Publishing's public repositories, and then find the relevant repository for this book. We will then create a new issue in this repository.</p>&#13;
<p>As in the preceding recipe, we will need a <kbd>URLSession</kbd> object to perform our requests, and we need to tell the playground not to finish executing when it reaches the end of the playground:</p>&#13;
<pre>import Foundation<br/>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true<br/><br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<p>Our first step is to fetch all the public repositories for a given user:</p>&#13;
<ol>&#13;
<li>Let's create a function to do that:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fetchRepos(forUsername username: String) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json", <br/>    forHTTPHeaderField: "Accept")<br/> <br/>  let task = session.dataTask(with: request) { (data, response, <br/>    error) in<br/> <br/>  }<br/>  task.resume()<br/>}</pre>&#13;
<p style="padding-left: 60px">You will note that after creating <kbd>URLRequest</kbd>, we set an HTTP header; this particular header ensures that we will always get back version 3 of the GitHub API.</p>&#13;
<p>We know from the GitHub API documentation (<a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a>) that this response data is in JSON format. We need to parse the JSON data to turn it into something that we can use; enter <kbd>JSONSerialization</kbd>. <kbd>JSONSerialization</kbd> is part of the Foundation framework and provides class methods for turning Swift dictionaries and arrays into JSON data (known as <strong>serialization</strong>) and back again (known as <strong>deserialization</strong>).</p>&#13;
<ol start="2">&#13;
<li>Let's use <kbd>JSONSerialization</kbd> to turn our JSON response data into something more useful:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fetchRepos(forUsername username: String) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json",<br/>    forHTTPHeaderField: "Accept")<br/>  let task = session.dataTask(with: request) { (data, response, <br/>    error) in<br/> <br/>    // Once we have handled this response, the Playground<br/>    // can finish executing.<br/>    defer {<br/>      PlaygroundPage.current.finishExecution()<br/>    }<br/> <br/>    // First unwrap the optional data<br/>    guard let jsonData = data else {<br/>      // If it is nil, there was probably a network error<br/>      print(error ?? "Network Error")<br/>      return<br/>    }<br/> <br/>    do {<br/>      // Deserialisation can throw an error, so we have to `try` and <br/>        // catch errors<br/>      let deserialised = try JSONSerialization.jsonObject(with: <br/>        jsonData, options: [])<br/>      print(deserialised)<br/> <br/>    } catch {<br/>      print(error)<br/>    }<br/>  }<br/>  task.resume()<br/>}</pre>&#13;
<ol start="3">&#13;
<li>Now, let's fetch the public Packt repositories by executing our function and passing <kbd>PacktPublishing</kbd> in as the GitHub username:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">fetchRepos(forUsername: "PacktPublishing")</pre>&#13;
<p style="padding-left: 60px">Once executed, the print output should look like this:</p>&#13;
<div><img src="img/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png" style="" width="1952" height="565"/></div>&#13;
<p>Figure 5.4 – Public GitHub repositories API response</p>&#13;
<p style="padding-left: 60px" class="p1"><kbd>JSONSerializer</kbd> has turned our JSON data into familiar arrays and dictionaries that can be used to retrieve the information we need in the normal way. The JSON data is deserialized with the <kbd>Any</kbd> type, as the JSON can have a JSON object or an array at its root.</p>&#13;
<p class="p1">Since, from the preceding output, we know that the response has an array of JSON objects at its root, we need to turn the value from type <kbd>Any</kbd> to an array of dictionaries of the <kbd>[String: Any]</kbd> type. This is referred to as <strong>casting</strong> from one type to another, which we can do by using the <kbd>as</kbd> keyword and then specifying the new type. This keyword can be used in three different ways:</p>&#13;
<ul>&#13;
<li class="p1"><kbd>as</kbd> will perform a trivial cast. This is possible if the existing type is synonymous with the intended type, for instance, casting from a subclass to a superclass.</li>&#13;
<li class="p1"><kbd>as?</kbd> will conditionally perform a cast, returning an optional value. If it is not possible to represent the value as the intended type, the value will be <kbd>nil</kbd>.</li>&#13;
<li class="p1"><kbd>as!</kbd> will perform a forced cast. If it is not possible to represent the value as the intended type, you will get a crash.</li>&#13;
</ul>&#13;
<p>So, let's cast the deserialized data to an array of dictionaries with string keys, with the <kbd>[[String: Any]]</kbd> type:</p>&#13;
<pre>func fetchRepos(forUsername username: String) {<br/>   //...<br/>   let task = session.dataTask(with: request) { (data, response, error) <br/>     in<br/>     //...<br/>     do {<br/>       // Deserialisation can throw an error, so we have to `try` and <br/>         // catch errors<br/>       let deserialised = try JSONSerialization.jsonObject(with:<br/>         jsonData, options: [])<br/>       print(deserialised)<br/>       // As `deserialised` has type `Any` we need to cast<br/>       guard let repos = deserialised as? [[String: Any]] else {<br/>         print("Unexpected Response")<br/>         return<br/>       }<br/>       print(repos)<br/>     } catch {<br/>       print(error)<br/>     }<br/>   }<br/>}</pre>&#13;
<p class="p1">Now, we have an array of dictionaries for the repositories in the API response, which we need to provide as input for this function. A common pattern for providing results for asynchronous work is to provide a completion handler as a parameter. A completion handler is a closure that can be executed once the asynchronous work is completed.</p>&#13;
<p>Since the output we want to provide is the array of repository dictionaries, we will define this as an input for the closure if the request was successful, and an error if it wasn't:</p>&#13;
<pre>func fetchRepos(forUsername username: String, completionHandler: <br/>  @escaping ([[String: Any]]?, Error?) -&gt; Void) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json",<br/>    forHTTPHeaderField: "Accept")<br/>  let task = session.dataTask(with: request) { (data, response, error) <br/>    in<br/> <br/>    // Once we have handled this response, the Playground<br/>    // can finish executing.<br/>    defer {<br/>      PlaygroundPage.current.finishExecution()<br/>    }<br/> <br/>    // First unwrap the optional data<br/>    guard let jsonData = data else {<br/>      // If it is nil, there was probably a network error<br/>      completionHandler(nil, ResponseError.requestUnsuccessful)<br/>      return<br/>    }<br/> <br/>    do {<br/>      // Deserialisation can throw an error, so we have to `try` and <br/>       // catch errors<br/>      let deserialised = try JSONSerialization.jsonObject(with: <br/>        jsonData, options: [])<br/>       // As `deserialised` has type `Any` we need to cast<br/>      guard let repos = deserialised as? [[String: Any]] else {<br/>        completionHandler(nil, <br/>          ResponseError.unexpectedResponseStructure)<br/>        return<br/>      }<br/> <br/>      completionHandler(repos, nil)<br/> <br/>    } catch {<br/>      completionHandler(nil, error)<br/>    }<br/>  }<br/>  task.resume()<br/>}</pre>&#13;
<p>Now, whenever an error is generated, we execute <kbd>completionHandler</kbd>, passing in the error and <kbd>nil</kbd> for the results value. Also, when we have the repository results, we execute the completion handler, passing in the parsed JSON and <kbd>nil</kbd> for the error.</p>&#13;
<p>We passed in a few new errors in the preceding code, so let's define those errors:</p>&#13;
<pre>enum ResponseError: Error {<br/>  case requestUnsuccessful<br/>  case unexpectedResponseStructure<br/>}</pre>&#13;
<p>This changes how we call this <kbd>fetchRepos</kbd> function:</p>&#13;
<pre>fetchRepos(forUsername: "PacktPublishing") { (repos, error) in<br/><br/>  if let repos = repos {<br/>    print(repos)<br/>  } else if let error = error {<br/>    print(error)<br/>  }<br/>}</pre>&#13;
<p class="p1">Now that we have retrieved the details of the public repositories, we will submit an issue to the repository for this chapter. This issue can be any feedback you would like to give about this book; it can be a review, a suggestion for new content, or you can tell me about a Swift project you are currently working on.</p>&#13;
<p class="p1">This request to the GitHub API will be authenticated against your user account and therefore, we will need to include details of the personal access token that we created at the beginning of this recipe. There are a number of ways to authenticate requests to the GitHub API, but the simplest is basic authentication, which involves adding an authorization string to the request header.</p>&#13;
<p class="p1">Let's create a method to format the personal access token correctly for authentication:</p>&#13;
<pre>func authHeaderValue(for token: String) -&gt; String {<br/>  let authorisationValue = Data("\(token):x-oauth-<br/>    basic".utf8).base64EncodedString()<br/>  return "Basic \(authorisationValue)"<br/>}</pre>&#13;
<p>Next, let's create our function to submit our issue. From the API documentation at <a href="https://developer.github.com/v3/issues/#create-an-issue">https://developer.github.com/v3/issues/#create-an-issue</a>, we can see that unless you have push access, you can only create an issue with the following components:</p>&#13;
<ul>&#13;
<li class="p1"><kbd>title</kbd> (required)</li>&#13;
<li class="p1"><kbd>body</kbd> (optional)</li>&#13;
</ul>&#13;
<p>So, our function will take this information as input, along with the repository name and username:</p>&#13;
<pre>func createIssue(inRepo repo: String, <br/>                 forUser user: String, <br/>                 title: String, <br/>                 body: String?) {<br/><br/>}</pre>&#13;
<p>Creating an issue is achieved by sending a <kbd>POST</kbd> request, and information about the issue is provided as JSON data in the request body. To create our request, we can use <kbd>JSONSerialization</kbd>, but we will take our intended JSON structure and serialize it into <kbd>Data</kbd> this time:</p>&#13;
<pre>func createIssue(inRepo repo: String, <br/>                 forUser user: String, <br/>                 title: String, <br/>                 body: String?) {<br/>    <br/>    // Create the URL and Request<br/>    <br/>    let urlString = "https://api.github.com/repos/\(user)/\<br/>      (repo)/issues"<br/>    let url = URL(string: urlString)!<br/>    var request = URLRequest(url: url)<br/>    request.httpMethod = "POST"<br/>    request.setValue("application/vnd.github.v3+json", <br/>                     forHTTPHeaderField: "Accept")<br/>    let authorisationValue = authHeaderValue(for: &lt;#your personal <br/>      access token&gt;)<br/>    request.setValue(authorisationValue, forHTTPHeaderField: <br/>      "Authorization")<br/>    // Put the issue information into the JSON structure required<br/>    var json = ["title": title]<br/>    <br/>    if let body = body {<br/>        json["body"] = body<br/>    }<br/>    <br/>    // Serialise the json into Data. We can use try! as we know it is <br/>     // valid JSON.<br/>    // Just be aware that the this will fail if provided value can't be<br/>     //  converted into valid JSON.<br/>    let jsonData = try! JSONSerialization.data(withJSONObject: json, <br/>      options: .prettyPrinted)<br/>    request.httpBody = jsonData<br/>    <br/>    session.dataTask(with: request) { (data, response, error) in<br/>        // TO FINISH<br/>    }<br/>}</pre>&#13;
<p>As with the previous API request, we need a way to provide the result of creating the issue, so let's provide a completion handler, try to deserialize the response, and provide it to the completion handler:</p>&#13;
<pre>func createIssue(inRepo repo: String, <br/>                 forUser user: String, <br/>                 title: String, <br/>                 body: String?, <br/>                 completionHandler: @escaping ([String: Any]?, Error?) <br/>                   -&gt; Void) {<br/>    //...<br/>    <br/>    session.dataTask(with: request) { (data, response, error) in<br/>        <br/>        guard let jsonData = data else { <br/>            completionHandler(nil, ResponseError.requestUnsuccessful)<br/>            return<br/>        }<br/>        <br/>        do {<br/>            // Deserialisation can throw an error, so we have to `try` <br/>            // and catch errors<br/>            let deserialised = try JSONSerialization.jsonObject(with: <br/>              jsonData, options: [])<br/>            // As `deserialised` has type `Any` we need to cast<br/>            guard let createdIssue = deserialised as? [String: Any]<br/>              else {<br/>                completionHandler(nil, <br/>                  ResponseError.unexpectedResponseStructure)<br/>                return<br/>            }<br/>            <br/>            completionHandler(createdIssue, nil)<br/>            <br/>        } catch {<br/>            completionHandler(nil, error)<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="p1">The API response to a successfully created issue provides a JSON representation of that issue. Our function will return this representation if it was successful, or an error if it was not.</p>&#13;
<p>Now that we have a function to create issues in a repository, it's time to use it to create an issue:</p>&#13;
<pre>createIssue(inRepo: "Swift-5-Cookbook-Second-Edition", <br/>            forUser: "PacktPublishing", <br/>            title: &lt;#The title of your feedback#&gt;, <br/>            body: &lt;#Extra detail#&gt;) { (issue, error) in<br/>                <br/>                if let issue = issue {<br/>                    print(issue)<br/>                } else if let error = error {<br/>                    print(error)<br/>                }<br/>}</pre>&#13;
<p>I will check these created issues, so please provide genuine feedback on this book. How have you found the content? Too detailed? Not detailed enough? Anything I've missed or not fully explained? Any questions that you have? This is your opportunity to let me know.</p>&#13;
<h2 id="uuid-5717d8ec-4388-4b23-83e7-c7b405e3838d" class="p1">There's more...</h2>&#13;
<p class="p1">When we created our completion handlers, we gave them two inputs: the successful result (either the repository information or the created issue) or an error if there is a failure. Both these values are optional; one will be <kbd>nil</kbd>, and the other has a value. However, this convention is not enforced by the language, and a user of this function will have to consider the possibility that it may not be the case. What should the user of this function do if the <kbd>fetchRepos</kbd> function fires the completion handler with non-<kbd>nil</kbd> values for both the repository and the error? What if both are <kbd>nil</kbd>?</p>&#13;
<p class="p1">The user of this function, without viewing the function's internal code, can't be sure that this won't happen, which means they may need to write functionality and tests to account for this possibility, even though it may never happen.</p>&#13;
<p class="p1">It would be better if we could more accurately represent the intended behavior of our function, providing the user with a clear indication of the possible outcomes and leaving no room for ambiguity. We know that there are two possible outcomes from calling the function: it will either succeed and return the relevant value, or it will fail and return an error to indicate the reason for the failure.</p>&#13;
<p class="p1">Instead of optional values, we can use an enum to represent these possibilities, and the Foundation framework provides a generic enum for this purpose, called <kbd>Result</kbd>.</p>&#13;
<p>The <kbd>Result</kbd> enum has a <kbd>success</kbd> case, which has an associated type for a successful result, and a <kbd>failure</kbd> case with an associated type for the relevant error. Both associated types are defined as generic constraints, with the failure type needing to conform to the <kbd>Error</kbd> protocol.</p>&#13;
<p class="p1">We can now define the success and failure states and use associated values to hold the value that is relevant for each state, which is the repository information for the success state and the error for the failure state.</p>&#13;
<p class="p1">Now, let's amend our <kbd>fetchRepos</kbd> function to provide a <kbd>Result</kbd> enum in <kbd>completionHandler</kbd>:</p>&#13;
<pre>func fetchRepos(forUsername username: String,<br/>    completionHandler: @escaping (Result&lt;[[String: Any]], Error?) - <br/>      -&gt; Void) {<br/> <br/>    //...<br/>  <br/>    let task = session.dataTask(with: request) { (data, response, <br/>      error) in<br/> <br/>        //...<br/> <br/>        // First unwrap the optional data<br/>        guard let jsonData = data else {<br/>            // If it is nil, there was probably a network error<br/>            completionHandler(.failure(ResponseError.<br/>              requestUnsuccessful))<br/>            return<br/>        }<br/> <br/>        do {<br/>            // Deserialisation can throw an error, <br/>            // so we have to `try` and catch errors<br/>            let deserialised = try JSONSerialization.jsonObject(with: <br/>              jsonData, options: [] ) <br/>            // As `deserialised` has type `Any` we need to cast<br/>            guard let repos = deserialised as? [[String: Any]] else {<br/>                let error = ResponseError.unexpectedResponseStructure<br/>                completionHandler(.failure(error))<br/>                return<br/>            }<br/>            completionHandler(.success(repos))<br/>        } catch {<br/>            completionHandler(.failure(error))<br/>        }<br/>    }<br/>    task.resume()<br/>}</pre>&#13;
<p class="p1">We need to update how we call the <kbd>fetchRepos</kbd> function:</p>&#13;
<pre>fetchRepos(forUsername: "PacktPublishing", completionHandler:{ result<br/>  in<br/>    switch result {<br/>        case .success(let repos):<br/>            print(repos)<br/> <br/>        case .failure(let error):<br/>            print(error)<br/>    }<br/>})</pre>&#13;
<p class="p1">We now use a <kbd>switch</kbd> statement instead of <kbd>if/else</kbd>, and we get the added benefit that the compiler will ensure that we have covered all possible outcomes.</p>&#13;
<p class="p1">Having made this improvement to the <kbd>fetchRepos</kbd> function, we can similarly improve the <kbd>createIssue</kbd> function:</p>&#13;
<pre>func createIssue(inRepo repo: String, <br/>                 forUser user: String, <br/>                 title: String, <br/>                 body: String?, <br/>                 completionHandler: @escaping (Result&lt;[[String:   <br/>                   Any]], Error?) -&gt; Void) {<br/>    //...<br/>    let task = session.dataTask(with: request) { (data, response, <br/>      error) in<br/> <br/>        guard let jsonData = data else { <br/>            completionHandler(.failure(ResponseError.<br/>              requestUnsuccessful))<br/>            return<br/>        }<br/> <br/>        do {<br/>            // Deserialisation can throw an error, <br/>            // so we have to `try` and catch errors<br/>            let deserialised = try JSONSerialization.jsonObject(with: <br/>              jsonData, options: [])<br/> <br/>            // As `deserialised` has type `Any` we need to cast<br/>            guard let createdIssue = deserialised as? [String: Any] <br/>              else {<br/>                let error = ResponseError.unexpectedResponseStructure<br/>                completionHandler(.failure(error))<br/>                return<br/>            }<br/> <br/>            completionHandler(.success(createdIssue))<br/> <br/>        } catch {<br/>            completionHandler(.failure(error))<br/>        }<br/>    }<br/>    task.resume()<br/>}</pre>&#13;
<p class="mce-root">Lastly, we need to update the contents of the completion handler that we provide to the <kbd>createIssue</kbd> function:</p>&#13;
<pre>createIssue(inRepo: "Swift-5-Cookbook-Second-Edition", <br/>            forUser: "PacktPublishing", <br/>            title: &lt;#The title of your feedback#&gt;, <br/>            body: &lt;#Extra detail#&gt;) { result in<br/> <br/>    switch result {<br/>        case .success(let issue):<br/>            print(issue)<br/> <br/>        case .failure(let error):<br/>            print(error)<br/>    }<br/>}</pre>&#13;
<p class="p1">Working with JSON data and extracting relevant information from it can be frustrating. Consider the JSON response for our <kbd>fetchRepos</kbd> function:</p>&#13;
<pre>[<br/>    {<br/>        "id": 68144965,<br/>        "name": "JSONNode",<br/>        "full_name": "keefmoon/JSONNode",<br/>        "owner": {<br/>            "login": "keefmoon",<br/>            "id": 271298,<br/>            "avatar_url": <br/>              "https://avatars.githubusercontent.com/u/271298?v=3",<br/>            "gravatar_id": "",<br/>            "url": "https://api.github.com/users/keefmoon",<br/>            "html_url": "https://github.com/keefmoon",<br/>            "followers_url":<br/>              "https://api.github.com/users/keefmoon/followers",<br/>            //... Some more URLs<br/>            "received_events_url": <br/>            "https://api.github.com/users/keefmoon/received_events",<br/>            "type": "User",<br/>            "site_admin": false<br/>        },<br/>        "private": false,<br/>        //... more values<br/>    }<br/>    //... more repositories<br/>]</pre>&#13;
<p class="p1">If we want to get the username for the owner of the first repository, we need to deserialize the JSON and then conditionally unwrap multiple nested layers to get the username string:</p>&#13;
<pre>let jsonData = //... returned from the network<br/><br/>guard <br/>    let deserialised = try? JSONSerialization.jsonObject(with: <br/>      jsonData, options: []), <br/>    let repoArray = deserialised as? [[String: Any]], <br/>    let firstRepo = repoArray.first, <br/>    let ownerDictionary = firstRepo["owner"] as? [String: Any], <br/>    let username = ownerDictionary["login"] as? String <br/>    else {<br/>        return<br/>}<br/>print(username)</pre>&#13;
<p class="p1">That's a lot of optional unwrapping and casting just to get one value! Swift's strongly typed nature doesn't work well with JSON's loosely defined schema, which is why you have to do a lot of work to turn loosely typed information into strongly typed values.</p>&#13;
<p class="p1">To help with these problems, a number of open source frameworks are available, which make working with JSON in Swift easier. <kbd>SwiftyJSON</kbd> is a popular framework that can be found on GitHub at <a href="https://github.com/SwiftyJSON/SwiftyJSON">https://github.com/SwiftyJSON/SwiftyJSON</a>.</p>&#13;
<p class="p1">I have also built a lightweight JSON helper called <kbd>JSONNode</kbd>, which can also be found on GitHub at <a href="https://github.com/keefmoon/JSONnode">https://github.com/keefmoon/JSONnode</a>.</p>&#13;
<p class="p1">With <kbd>JSONNode</kbd>, you can perform the same task of retrieving the owner's username for the first repository with the following code:</p>&#13;
<pre>let jsonData = //... returned from the network<br/>guard <br/>    let jsonNode = try? JSONNode(data: jsonData),<br/>    let username = jsonNode[0]["owner"]["username"].string <br/>    else {<br/>        return<br/>}<br/><br/>print(username)</pre>&#13;
<p class="p1">Information within JSON, of any depth, can be retrieved in one line using subscripts.</p>&#13;
<h1 id="uuid-181f0194-07c1-4d52-bbe7-c6314100a4ab" class="p1">Working with XML</h1>&#13;
<p class="p1"><strong>XML</strong> stands for <strong>eXtensible Markup Language</strong> and is a popular way of representing data for storage and transfer across a network. XML is a very flexible format and is used to represent many types of data. The current specification of HTML, which powers most of the web, is an implementation of XML.</p>&#13;
<p class="p1">The version of XML that we will concern ourselves with in this recipe is <strong>RSS</strong>, which stands for <strong>Really Simple Syndication</strong>. RSS is used to define a collection of time-ordered pieces of digestible content; these RSS feeds can then be used to aggregate content from a number of different sources. RSS is typically used as a distribution mechanism for news articles and podcasts.</p>&#13;
<p>In this recipe, we will learn how to read and write XML data by fetching and parsing the BBC News RSS feed.</p>&#13;
<h2 id="uuid-1f1c02c2-e25e-427c-b010-7e38ba66b880" class="p1">Getting ready</h2>&#13;
<p class="p1">The functionality to deal with XML data is provided by the Foundation framework. However, while the classes that help with reading XML data are available on all of Apple's platforms, the classes that assist with writing XML data are only available on the macOS platform.</p>&#13;
<p class="p1">This is an unfortunate oversight and means that if you need to write XML data within an iOS app, you will likely need to look for a third-party helper or build your own. We will investigate third-party helpers at the end of this recipe.</p>&#13;
<p>To investigate both reading and writing XML using the Foundation framework, we need to create a new macOS-based playground instead of an iOS-based playground, which we have been using so far in this book.</p>&#13;
<p>Create a new Swift playground as usual, but choose a Blank template from the macOS tab:</p>&#13;
<div><img src="img/a958f28d-123d-464f-9a57-0a9754f2b163.png" style="" width="1142" height="501"/></div>&#13;
<p>Figure 5.5 – Choosing a template</p>&#13;
<p>The RSS feed that we will retrieve and parse is from the front page of the BBC News website, which is <a href="http://feeds.bbci.co.uk/news/rss.xml">http://feeds.bbci.co.uk/news/rss.xml</a>.</p>&#13;
<p>Our first step is to retrieve the data at this URL so that we can start making sense of it. Since we previously covered retrieving information over the network, I'll add the code without further comment; check out the <em>Fetching data with URLSession</em> recipe in this chapter for more information:</p>&#13;
<pre>import Foundation<br/>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true<br/><br/>func fetchBBCNewsRSSFeed() {<br/> <br/>    let session = URLSession.shared<br/>    let url = URL(string: "http://feeds.bbci.co.uk/news/rss.xml")!<br/>    let dataTask = session.dataTask(with: url) { (data, response, <br/>      error) in<br/> <br/>        guard let data = data, error == nil else {<br/>            print(error ?? "Unexpected response")<br/>            return<br/>        }<br/> <br/>        let dataAsString = String(data: data, encoding: .utf8)!<br/>        print(dataAsString)<br/>    }<br/>    dataTask.resume()<br/>}<br/><br/>fetchBBCNewsRSSFeed()</pre>&#13;
<p>When you run the playground, you will get an output that looks like the following:</p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;?xml-stylesheet title="XSL_formatting" type="text/xsl" href="/shared/bsp/xsl/rss/nolsol.xsl"?&gt;<br/>&lt;rss    version="2.0" &gt;<br/>  &lt;channel&gt;<br/>    &lt;title&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/title&gt;;<br/>    &lt;description&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/description&gt;<br/>    &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>    &lt;image&gt;<br/> &lt;url&gt;https://news.bbcimg.co.uk/nol/shared/img/bbc_news_120x60.gif&lt;/url&gt;<br/> &lt;title&gt;BBC News - Home&lt;/title&gt;<br/> &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>  &lt;/image&gt;<br/>    &lt;generator&gt;RSS for Node&lt;/generator&gt;<br/>    &lt;lastBuildDate&gt;Sat, 15 Aug 2020 00:41:41 GMT&lt;/lastBuildDate&gt;<br/>   &lt;copyright&gt;&lt;![CDATA[Copyright: (C) British Broadcasting <br/>       Corporation, see http://news.bbc.co.uk/2/hi/help/rss/4498287.stm <br/>         for terms and conditions of reuse.]]&gt;&lt;/copyright&gt;<br/>    &lt;language&gt;&lt;![CDATA[en-gb]]&gt;&lt;/language&gt;<br/>    &lt;ttl&gt;15&lt;/ttl&gt;<br/>    &lt;item&gt;<br/>      &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat <br/>         France quarantine]]&gt;&lt;/title&gt;<br/>      &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to return to <br/>         the UK to avoid the 14-day self-isolation requirement.]]&gt;<br/>     &lt;/description&gt;<br/>      &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>      &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>         53782019&lt;/guid&gt;<br/>      &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>    &lt;/item&gt;<br/>    //... More items<br/>  &lt;/channel&gt;<br/>&lt;/rss&gt;</pre>&#13;
<h2 id="uuid-ac610b8f-bb93-4c8a-92f7-1f104f5a3d7f" class="p1">How to do it...</h2>&#13;
<p class="p1">The overall structure should be familiar to anyone who has seen HTML. Apart from the first two lines, which define the version and formatting of the XML, the information is structured with opening and closing tags. Consider the following example:</p>&#13;
<pre>&lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;</pre>&#13;
<p class="p1">The name of the opening tag defines the content of this element of XML; in this case, it is a link. Then follows the content of the element, and the end of the content is defined by a closing tag that has a <kbd>/</kbd> character before its name.</p>&#13;
<p class="p1">In addition to this simple example, an XML element can have attributes that describe extra information about the content of the element:</p>&#13;
<pre>&lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/guid&gt;</pre>&#13;
<p class="p1">These are defined as key-value pairs within the opening tag.</p>&#13;
<p class="p1">The content of the XML element may be a string, as in the preceding examples, or it can be nested child XML elements:</p>&#13;
<pre>&lt;image&gt;<br/>    &lt;url&gt;http://news.bbcimg.co.uk/nol/shared/img/bbc_news_120x60.gif&lt;/url&gt;<br/>    &lt;title&gt;BBC News - Home&lt;/title&gt;<br/>    &lt;link&gt;http://www.bbc.co.uk/news/&lt;/link&gt;<br/>&lt;/image&gt;</pre>&#13;
<p class="p1">Lastly, the content of an XML element can be data. This data might be represented as a string, especially if the string is likely to be longer, and may include line breaks, special characters, and other components that may be confused for being part of the enclosing XML formatting:</p>&#13;
<pre>&lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat France <br/>   quarantine]]&gt;&lt;/title&gt;</pre>&#13;
<p class="p1">Now that we have retrieved the XML, we want to parse it into something useful. The parser we will be using is provided by the Foundation framework and is available on iOS and macOS. It is called <kbd>XMLParser</kbd>. <kbd>XMLParser</kbd> is a <strong>SAX</strong> parser, which stands for <strong>Simple API for XML</strong>. The features of a SAX parser are as follows:</p>&#13;
<ul>&#13;
<li class="p1">Event-driven</li>&#13;
<li class="p1">Low memory overhead</li>&#13;
<li class="p1">Only retains relevant information</li>&#13;
<li class="p1">One pass</li>&#13;
</ul>&#13;
<p class="p1">The parser takes a delegate object that it will deliver event information to as it parses the document. It is the delegate object's responsibility to take and retain the relevant information from these delegate callbacks as the XML data is parsed, as the parser will not retain the parsed data.</p>&#13;
<p>We will step through a simple example to see how the parser reports events to the delegate. Here's the simple XML that we intend to parse:</p>&#13;
<pre>&lt;xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<p class="p1">The parser will start parsing the XML, character by character, and as an event is triggered, the delegate will be informed:</p>&#13;
<ol>&#13;
<li class="p1">The first event will be the start of the document, where the parser will call this:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parserDidStartDocument(_ parser: XMLParser)</pre>&#13;
<p style="padding-left: 60px">Here, we can do any setup or resetting of the state that is required.</p>&#13;
<ol start="2">&#13;
<li>Then, the parser will move through the document until it reaches this point:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/><strong>** Parser is here **</strong><br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="3">&#13;
<li>The parser has finished parsing the opening tag for the first element and so it fires the delegate callback:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didStartElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?,<br/>            attributes attributeDict: [String : String] = [:]) {<br/>    /*<br/>    elementName = quotes<br/>    namespaceURI = nil<br/>    qName = nil<br/>    attributeDict = [:]<br/>    */<br/>}</pre>&#13;
<ol start="4">&#13;
<li>The parser then continues until it reaches this point:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/><strong>** Parser is here **</strong><br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="5">&#13;
<li>Since the parser has seen another starting tag, it fires the same delegate callback with information about this new element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didStartElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?,<br/>            attributes attributeDict: [String : String] = [:]) {<br/>    /*<br/>    elementName = quote<br/>    namespaceURI = nil<br/>    qName = nil<br/>    attributeDict = ["attribution": "Homer Simpson"]<br/>    */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">This time, as the element has attribute information, it is provided by the delegate callback in the <kbd>attributeDict</kbd> dictionary.</p>&#13;
<ol start="6">&#13;
<li>The parser now moves through the content of the first <kbd>quote</kbd> element. At some point, it fires the delegate callback with the content it has collected up to that point:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, <strong>** Parser is here **</strong>where's the <br/>          any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>           OCT31=DEC25<br/>   &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<p style="padding-left: 60px" class="p1">It then provides this content collected so far to the delegate:</p>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser, foundCharacters string: String) {<br/>    /*<br/>    string = "Press any key to continue, "<br/>    */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The reason the parser stops halfway through the content to fire the delegate callback is to make the most efficient use of memory. All the data that the parser processes must be kept in memory by the parser until it can be delivered to the delegate. Therefore, if the parser determines that memory usage is getting high, it will take the content it has collected so far and deliver it to the delegate. Once it has done this, it can free up the memory and start collecting further content afresh.</p>&#13;
<p style="padding-left: 60px" class="p1">In this simple example, it is very unlikely that the parser will not provide all the content of the element in one delegate callback. It is, however, useful to see an example of this, as we have to account for the possibility, and it will affect how we implement the delegate later.</p>&#13;
<ol start="7">&#13;
<li>The parser will fire the same <kbd>foundCharacters</kbd> delegate callback until all of the content of an element has been delivered to the delegate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/><strong>           ** Parser is here **</strong><br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="8">&#13;
<li class="p1">It then provides the new content since the last call to the delegate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser, foundCharacters string: String) {<br/>    /*<br/>    string = "where's the any key?"<br/>    */<br/>}</pre>&#13;
<ol start="9">&#13;
<li class="p5">The parser now processes the closing tag for the first <kbd>quote</kbd> element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/><strong>** Parser is here **</strong><br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="10">&#13;
<li class="p1">Then, it fires the delegate callback, signaling the end of the element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/> didEndElement elementName: String,<br/> namespaceURI: String?,<br/> qualifiedName qName: String?) {<br/> /*<br/> elementName = "quote"<br/> namespaceURI = nil<br/> qName = nil<br/> */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The parser will then continue to process the next <kbd>quote</kbd> element in the same way, firing the same sequence of <kbd>didStartElement</kbd>, followed by a number of <kbd>foundCharacters</kbd> callbacks, and finishing with a call to <kbd>didEndElement</kbd>.</p>&#13;
<ol start="11">&#13;
<li>Having finished processing the last <kbd>quote</kbd> element, the parser will process the closing tag of the <kbd>quotes</kbd> element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;<br/><strong>** Parser is here **</strong></pre>&#13;
<p style="padding-left: 60px" class="p1">It will fire another <kbd>didEndElement</kbd> callback for the <kbd>quotes</kbd> element:</p>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didEndElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?) {<br/>    /*<br/>    elementName = "quotes"<br/>    namespaceURI = nil<br/>    qName = nil<br/>    */<br/>}</pre>&#13;
<ol start="12">&#13;
<li>Finally, the parser will fire a delegate callback to indicate that the parsing of the document is complete:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parserDidEndDocument(_ parser: XMLParser) {<br/> <br/>}</pre>&#13;
<p>Now that you understand how the parser passes information to the delegate, we can return to our RSS example.</p>&#13;
<h2 id="uuid-9092063e-2113-4cb9-8146-4fb6100b4711" class="p1">How it works...<br/></h2>&#13;
<p class="p1">You will remember that we retrieved XML data that looks like this:</p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;?xml-stylesheet title="XSL_formatting" type="text/xsl" href="/shared/bsp/xsl/rss/nolsol.xsl"?&gt;<br/>&lt;rss    version="2.0" &gt;<br/>    &lt;channel&gt;<br/>        &lt;title&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/title&gt;<br/>        &lt;description&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/description&gt;<br/>        &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>        &lt;image&gt;<br/>            &lt;url&gt;https://news.bbcimg.co.uk/nol/shared/img/<br/>               bbc_news_120x60.gif&lt;/url&gt;<br/>            &lt;title&gt;BBC News - Home&lt;/title&gt;<br/>            &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>        &lt;/image&gt;<br/>        &lt;generator&gt;RSS for Node&lt;/generator&gt;<br/>        &lt;lastBuildDate&gt;Sat, 15 Aug 2020 00:41:41 GMT&lt;/lastBuildDate&gt;<br/>        &lt;copyright&gt;&lt;![CDATA[Copyright: (C) British Broadcasting <br/>          Corporation, see http://news.bbc.co.uk/2/hi/help/rss/<br/>           4498287.stm for terms and conditions of reuse.]]&gt;<br/>            &lt;/copyright&gt;<br/>        &lt;language&gt;&lt;![CDATA[en-gb]]&gt;&lt;/language&gt;<br/>        &lt;ttl&gt;15&lt;/ttl&gt;<br/>        &lt;item&gt;<br/>            &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat <br/>               France quarantine]]&gt;&lt;/title&gt;<br/>            &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to <br/>                return to the UK to avoid the 14-day self-isolation <br/>                   requirement.]]&gt;&lt;/description&gt;<br/>            &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>            &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>               53782019&lt;/guid&gt;<br/>            &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>        &lt;/item&gt;<br/>        //... More items<br/>    &lt;/channel&gt;<br/>&lt;/rss&gt;<br/><br/></pre>&#13;
<p>From this, we want to extract the news articles in a usable form, so let's define a <kbd>NewsArticle</kbd> model containing some useful information and place it near the top of the playground:</p>&#13;
<pre>struct NewsArticle {<br/>    let title: String<br/>    let url: URL<br/>}</pre>&#13;
<p class="p1">Since the information we require will be spread over multiple delegate callbacks, our delegate will need to keep track of the information it has received, so it can be pieced together at the appropriate time.</p>&#13;
<p>Let's create a class object to be the delegate for the parser and have it conform to <kbd>XMLParserDelegate</kbd>:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/> <br/>}</pre>&#13;
<p>In the preceding XML, each news article is contained in an <kbd>item</kbd> element, so our delegate will need to keep track of when the parser is delivering content for the <kbd>item</kbd> element so that it can ignore content from other elements:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/> <br/>    var inItem = false<br/> <br/>    func parser(_ parser: XMLParser,<br/>                didStartElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?,<br/>                attributes attributeDict: [String : String] = [:]) {<br/> <br/>        switch elementName {<br/> <br/>        case "item":<br/>            inItem = true<br/> <br/>        default:<br/>            break<br/> <br/>        }<br/>    }<br/> <br/>    func parser(_ parser: XMLParser,<br/>                didEndElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?) {<br/> <br/>        switch elementName {<br/> <br/>        case "item":<br/>            inItem = false<br/> <br/>        default:<br/>            break<br/>        }<br/>    }<br/>}</pre>&#13;
<p>The two parts we want to extract from the <kbd>item</kbd> element to create our <kbd>NewsArticle</kbd> are the title and the URL. As we can see from the XML, the title is contained in a <kbd>CDATA</kbd> wrapper within a <kbd>title</kbd> element, and the URL is within a <kbd>link</kbd> element:</p>&#13;
<pre>&lt;item&gt;<br/>  &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat France <br/>     quarantine]]&gt;&lt;/title&gt;<br/>  &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to return to the <br/>      UK to avoid the 14-day self-isolation requirement.]]&gt;<br/>       &lt;/description&gt;<br/>  &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>  &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>     53782019&lt;/guid&gt;<br/>  &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>&lt;/item&gt;</pre>&#13;
<p class="p1">We will, therefore, also need to keep track of when the parser is in the <kbd>link</kbd> element, and while it is within the link element, append the received content to a <kbd>String</kbd> property. Similarly, we need to keep track of when the parser is in the <kbd>title</kbd> element, and when it is, append the received content to a <kbd>Data</kbd> property.</p>&#13;
<p>Let's add the extra properties we need to our <kbd>RSSNewsArticleBuilder</kbd> object:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/>    <br/>    var inItem = false<br/>    var inTitle = false<br/>    var inLink = false<br/>    var titleData: Data?<br/>    var linkString: String?<br/><br/>    //...<br/>}</pre>&#13;
<p>In the <kbd>didStartElement</kbd> method, we can check for these new element names we need to track. We must also remember to reset the link and title properties as we start the relevant element. This way, we don't continue to append content meant for the next item element onto content from the previous one:</p>&#13;
<pre>func parser(_ parser: XMLParser,<br/>            didStartElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?,<br/>            attributes attributeDict: [String : String] = [:]) {<br/>        <br/>    switch elementName {<br/>            <br/>    case "item":<br/>        inItem = true<br/>            <br/>    case "title":<br/>        inTitle = true<br/>        titleData = Data()<br/>            <br/>    case "link":<br/>        inLink = true<br/>        linkString = ""<br/>            <br/>    default:<br/>        break<br/>    }<br/>}</pre>&#13;
<p>Now that we know when we are in the right elements, we can implement two of the <kbd>XMLParserDelegate</kbd> methods to receive the relevant content and store it:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/><br/>    //...<br/>    func parser(_ parser: XMLParser, foundCDATA CDATABlock: Data) {<br/>        <br/>        if inTitle {<br/>            titleData?.append(CDATABlock)<br/>        }<br/>    }<br/>    <br/>    func parser(_ parser: XMLParser, foundCharacters string: String) {<br/>        <br/>        if inLink {<br/>            linkString?.append(string)<br/>        }<br/>    }<br/>}</pre>&#13;
<p>In the <kbd>didEndElement</kbd> method, we need to update our new properties and we can print out the values we have retrieved from the XML:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/>    //...<br/>    func parser(_ parser: XMLParser,<br/>                didEndElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?) {<br/>        <br/>        switch elementName {<br/>            <br/>        case "item":<br/>            inItem = false<br/>            <br/>            guard<br/>                let titleData = titleData,<br/>                let titleString = String(data: titleData, encoding: <br/>                  .utf8),<br/>                let linkString = linkString,<br/>                let link = URL(string: linkString)<br/>                else { break }<br/>            <br/>            print(titleString)<br/>            print(link)<br/>            <br/>        case "title":<br/>            inTitle = false<br/>            <br/>        case "link":<br/>            inLink = false<br/>            <br/>        default:<br/>            break<br/>        }<br/>    }<br/>    //...<br/>}</pre>&#13;
<p>Now that we have extracted the title and URL of the news article, we can use this to create a <kbd>NewsArticle</kbd> model object. First, let's create an array to hold the <kbd>NewsArticle</kbd> objects we will be creating:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/>    <br/>    var inItem = false<br/>    var inTitle = false<br/>    var inLink = false<br/>    var titleData: Data?<br/>    var linkString: String?<br/>    var articles = [NewsArticle]()<br/>    <br/>    //...<br/>}</pre>&#13;
<p>We can create the <kbd>NewsArticle</kbd> object at the end of the <kbd>item</kbd> element as this is when we will have all the relevant content:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/>    <br/>    //...<br/>    func parser(_ parser: XMLParser,<br/>                didEndElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?) {<br/>        <br/>        switch elementName {<br/>            <br/>        case "item":<br/>            inItem = false<br/>            <br/>            guard<br/>                let titleData = titleData,<br/>                let titleString = String(data: titleData, encoding: <br/>                  .utf8),<br/>                let linkString = linkString,<br/>                let link = URL(string: linkString)<br/>                else { break }<br/>            <br/>            let article = NewsArticle(title: titleString, url: link)<br/>            articles.append(article)<br/>            <br/>        case "title":<br/>            inTitle = false<br/>            <br/>        case "link":<br/>            inLink = false<br/>            <br/>        default:<br/>            break<br/>        }<br/>    }<br/>    //...<br/>}</pre>&#13;
<p>Lastly, when the document starts, we should ensure that all the properties are reset:</p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/>    //...<br/>    func parserDidStartDocument(_ parser: XMLParser) {<br/>        inItem = false<br/>        inTitle = false<br/>        inLink = false<br/>        titleData = nil<br/>        linkString = nil<br/>        articles = [NewsArticle]()<br/>    }<br/>    //...<br/>}</pre>&#13;
<p>Now that we have completed the parser delegate, let's go back to our <kbd>fetchBBCNewsRSSFeed</kbd> function:</p>&#13;
<pre>func fetchBBCNewsRSSFeed() {<br/>    <br/>    let session = URLSession.shared<br/>    let url = URL(string: "http://feeds.bbci.co.uk/news/rss.xml")!<br/>    let dataTask = session.dataTask(with: url) { (data, response, <br/>      error) in<br/>        <br/>        guard let data = data, error == nil else {<br/>            print(error ?? "Unexpected response")<br/>            return<br/>        }<br/>        <br/>        let dataAsString = String(data: data, encoding: .utf8)!<br/>        print(dataAsString)<br/>    }<br/>    dataTask.resume()<br/>}</pre>&#13;
<p>Once the XML data has been retrieved, we'll pass it to <kbd>XMLParser</kbd>, set up the delegate, and tell the parser to parse the data:</p>&#13;
<pre>func fetchBBCNewsRSSFeed() {<br/>    <br/>    let session = URLSession.shared<br/>    let url = URL(string: "http://feeds.bbci.co.uk/news/rss.xml")!<br/>    let dataTask = session.dataTask(with: url) { (data, response,<br/>      error) in<br/>        <br/>        guard let data = data, error == nil else {<br/>            print(error ?? "Unexpected response")<br/>            return<br/>        }<br/>        <br/>        let parser = XMLParser(data: data)<br/>        let articleBuilder = RSSNewsArticleBuilder()<br/>        parser.delegate = articleBuilder<br/>        parser.parse()<br/>        let articles = articleBuilder.articles<br/>        print(articles)<br/>    }<br/>    dataTask.resume()<br/>}</pre>&#13;
<p>We want to provide the articles as an output from this function, so we can add a completion handler to provide an array of news articles or an error:</p>&#13;
<pre>func fetchBBCNewsRSSFeed(completion: @escaping ([NewsArticle]?, Error?)<br/>  -&gt; Void) {<br/>    <br/>    let session = URLSession.shared<br/>    let url = URL(string: "http://feeds.bbci.co.uk/news/rss.xml")!<br/>    let dataTask = session.dataTask(with: url) { (data, response, <br/>      error) in<br/>        <br/>        guard let data = data, error == nil else {<br/>            completion(nil, error)<br/>            return<br/>        }<br/>        <br/>        let parser = XMLParser(data: data)<br/>        let articleBuilder = RSSNewsArticleBuilder()<br/>        parser.delegate = articleBuilder<br/>        parser.parse()<br/>        let articles = articleBuilder.articles<br/>        completion(articles, nil)<br/>    }<br/>    dataTask.resume()<br/>}</pre>&#13;
<p>Finally, we can call this function, which will retrieve the RSS feed, parse it, and return an array of news articles:</p>&#13;
<pre>fetchBBCNewsRSSFeed() { (articles, error) in<br/>    <br/>    if let articles = articles {<br/>        print(articles)<br/>    } else if let error = error {<br/>        print(error)<br/>    }<br/>}</pre>&#13;
<h2 id="uuid-a1e4c304-67af-42b3-abbc-74357701c393" class="p1">There's more...</h2>&#13;
<p class="p1">Foundation also provides the ability to write XML data, although currently, this functionality is only available on macOS.</p>&#13;
<p class="p1">Having retrieved the RSS feed and created our news articles, let's write this information to an XML data structure and save it to disk. This XML will take the following form:</p>&#13;
<pre>&lt;articles&gt;<br/>    &lt;article&gt;<br/>        &lt;title&gt;Donald Trump calls Fidel Castro 'brutal dictator'<br/>          &lt;/title&gt;<br/>        &lt;url&gt;http://www.bbc.co.uk/news/world-latin-america-<br/>           38118739&lt;/url&gt;<br/>    &lt;/article&gt;<br/>    &lt;article&gt;<br/>        &lt;title&gt;Fidel Castro: Jeremy Corbyn praises 'huge figure'<br/>           &lt;/title&gt;<br/>        &lt;url&gt;http://www.bbc.co.uk/news/uk-38117068&lt;/url&gt;<br/>    &lt;/article&gt;<br/>&lt;/articles&gt;</pre>&#13;
<p class="p1">At the root of the XML structure is an <kbd>articles</kbd> element, which contains multiple <kbd>article</kbd> elements, which in turn contain a <kbd>title</kbd> element and a <kbd>url</kbd> element.</p>&#13;
<p class="p1">To write the XML data, we will recreate the preceding structure using the <kbd>XMLDocument</kbd> and <kbd>XMLElement</kbd> objects. Once constructed, the <kbd>xmlData</kbd> property of the <kbd>XMLDocument</kbd> object provides the document as data.</p>&#13;
<p class="p1">Let's create a function to produce XML data from an array of <kbd>NewsArticle</kbd>:</p>&#13;
<pre>func createXML(representing articles: [NewsArticle]) -&gt; Data {<br/>    <br/>    let root = XMLElement(name: "articles")<br/>    let document = XMLDocument(rootElement: root)<br/>    <br/>    for article in articles {<br/>        <br/>        let articleElement = XMLElement(name: "article")<br/>        let titleElement = XMLElement(name: "title", <br/>                                      stringValue: article.title)<br/>        let urlElement = XMLElement(name: "url", <br/>                         stringValue: article.url.absoluteString)<br/>        <br/>        articleElement.addChild(titleElement)<br/>        articleElement.addChild(urlElement)<br/>        root.addChild(articleElement)<br/>    }<br/>    print(document.xmlString)<br/>    return document.xmlData<br/>}</pre>&#13;
<p class="p1">We create each <kbd>XMLElement</kbd> and add it as a child to the element that we want to nest it within.</p>&#13;
<p class="p1">If you are building this in a storyboard, ensure that you place this function after <kbd>RSSNewsArticleBuilder</kbd>, and before the code that calls <kbd>fetchBBCNewsRSSFeed</kbd>, as this function will need to be available to the completion handler soon.</p>&#13;
<p class="p1">Our call to <kbd>fetchBBCNewsRSSFeed</kbd> will provide an array of <kbd>NewsArticle</kbd>, so we can pass this to our new function to write this information to XML data:</p>&#13;
<pre>fetchBBCNewsRSSFeed() { (articles, error) in<br/>    <br/>    if let articles = articles {<br/>        <br/>        let articleXMLData = createXML(representing: articles)<br/>        print(articleXMLData.length)<br/>        <br/>    } else if let error = error {<br/>        print(error)<br/>    }<br/>}</pre>&#13;
<p class="p1">Now that we have the data, we can obtain a URL for the <kbd>documents</kbd> directory, append the name of the file we will create, and write it to disk:</p>&#13;
<pre>fetchBBCNewsRSSFeed() { (articles, error) in<br/>    <br/>    if let articles = articles {<br/>        <br/>        let xmlData = createXML(representing: articles)<br/>        <br/>        let documentsURL = FileManager.default.urls(for: <br/>          .documentDirectory, in: .userDomainMask).first!<br/>        let writeURL = documentsURL.appendingPathComponent(<br/>          "articles.xml")<br/>        print("Writing data to: \(writeURL)")<br/>        try! xmlData.write(to: writeURL)<br/>        <br/>    } else if let error = error {<br/>        print(error)<br/>    }<br/>}</pre>&#13;
<p class="p1">We have now retrieved an RSS feed, extracted useful information from it, written that information to a custom XML format, and saved that data to disk. Give yourself a pat on the back!</p>&#13;
<h2 id="uuid-50c14aea-bbf5-4bc6-83f8-f00ddf89e774" class="p1">See also</h2>&#13;
<p>Further information about <kbd>XMLParser</kbd> can be found in Apple's Foundation reference at <a href="http://swiftbook.link/docs/xmlparser">http://swiftbook.link/docs/xmlparser</a>.</p>&#13;
<p>Other XML parsers are available, which may have advantages over Apple's, including being able to write XML on iOS. They are as follows:</p>&#13;
<ul>&#13;
<li>RaptureXML: <a href="https://github.com/ZaBlanc/RaptureXML">https://github.com/ZaBlanc/RaptureXML</a></li>&#13;
<li>TBXML: <a href="https://github.com/71squared/TBXML">https://github.com/71squared/TBXML</a></li>&#13;
</ul>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>