<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    Beyond the Standard Library&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p class="p1"><span>Apple's intention when open-sourcing Swift was to provide a cross-platform,</span> general-purpose <span>programming language that is ready to use. The Swift standard library provides core language features and common collection types. However, this does not provide everything needed to get up and running.</span></p>&#13;
<p>Therefore, Apple provides a framework called <strong>Foundation</strong> to help you perform common programming tasks that aren't covered by the core Swift language and the standard library.</p>&#13;
<p><span class="s1">The Foundation framework that you will use when developing for Apple platforms is <em>closed-sourced</em>, which means the underlying code is not accessible and only the API is visible. However, when Apple open-sourced Swift and made it available for Linux, it became necessary to provide the Foundation framework as well. To this end, Apple has released an open source, Swift-based version of Foundation as a core library, available here:</span><span> </span><a href="https://github.com/apple/swift-corelibs-foundation"><span class="s3">https://github.com/apple/swift-corelibs-foundation</span></a>.</p>&#13;
<p>In this chapter, we will cover the following<span> </span>recipes:</p>&#13;
<ul>&#13;
<li>Comparing dates with Foundation</li>&#13;
<li>Fetching data with <kbd>URLSession</kbd></li>&#13;
<li>Working with JSON</li>&#13;
<li>Working with XML</li>&#13;
</ul>&#13;
<h1 id="uuid-7950368a-1e86-4794-a491-48971eaa2ee5">Technical requirements</h1>&#13;
<p><span>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05</a></span></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3cIcNUK" target="_blank">https://bit.ly/3cIcNUK</a></p>&#13;
<h1 id="uuid-5ab981ce-2d92-42f7-8028-60cd870a57f2">Comparing dates with Foundation</h1>&#13;
<p class="p1"><span class="s1">This recipe will focus on one area of Foundation that is very widely used, that is, date and time manipulation and formatting.</span></p>&#13;
<p><span>We will create a function that determines how long there is until Christmas and returns this information as a string that can be displayed to a user.</span></p>&#13;
<h2 id="uuid-d8ede9db-68c6-4ccd-9e1c-0ef20ab4c81b" class="p1">Getting ready</h2>&#13;
<p>Create a new iOS playground and import the Foundation framework at the top of the playground:</p>&#13;
<pre><span class="s1">import Foundation</span></pre>&#13;
<h2 id="uuid-ccd29e90-a1b2-49c2-b971-180e108cd082" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p>Let's create a function that will return a string telling us how long there is until Christmas that we can then print:</p>&#13;
<ol>&#13;
<li>Define the function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func howLongUntilChristmas() <span>-&gt;</span> String {<br/><br/>}</pre>&#13;
<ol start="2">&#13;
<li>Within the function, get the current calendar and time zone:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">let calendar = Calendar.current<br/>let timeZone = TimeZone.current</span></pre>&#13;
<ol start="3">&#13;
<li>Get the current date and time and use the calendar to get the current year:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">let now = Date()<br/>let yearOfNextChristmas = calendar.component(.year, from: now)</span></pre>&#13;
<ol start="4">&#13;
<li>Define date components that correspond to midnight on Christmas Day:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">var components = DateComponents(calendar: calendar, <br/>                                timeZone: timeZone, <br/>                                year: yearOfNextChristmas, <br/>                                month: 12, <br/>                                day: 25, <br/>                                hour: 0, <br/>                                minute: 0, <br/>                                second: 0)</span></pre>&#13;
<ol start="5">&#13;
<li>Get a <kbd>Date</kbd> object from those components:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">var christmas = components.date!</span></pre>&#13;
<ol start="6">&#13;
<li>If we have already passed Christmas for this year, we need to adjust the component to refer to Christmas of the next year:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">// If we have already had Christmas this year, <br/>// then we need to use Christmas next year.<br/>if christmas &lt; now {<br/>  components.year = yearOfNextChristmas + 1 <br/>  christmas = components.date!<br/>}</span></pre>&#13;
<ol start="7">&#13;
<li>Create <kbd>DateComponentsFormatter</kbd> to format how the time until Christmas is displayed:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">let componentFormatter = DateComponentsFormatter()<br/>componentFormatter.unitsStyle = .full<br/>componentFormatter.allowedUnits = [.month, .day, .hour, .minute, <br/>  .second]</span></pre>&#13;
<ol start="8">&#13;
<li>Use <kbd>DateComponentFormatter</kbd> to return a string for the time between now and next Christmas:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">return componentFormatter.string(from: now, to: christmas)!</span></pre>&#13;
<ol start="9">&#13;
<li>Below the <kbd>howLongUntilChristmas</kbd> function, use this function to create a string, and print the outcome:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s1">let timeUntilChristmas = howLongUntilChristmas()<br/>print("Time until Christmas: \(timeUntilChristmas)")</span></pre>&#13;
<h2 id="uuid-df7979b8-9cdf-4e22-ba09-c023f7744894">How it works...</h2>&#13;
<p class="p1"><span class="s1">In <em>Step 1</em>, we create our <kbd>howLongUntilChristmas</kbd> function, then in <em>Step 2</em>, <span>we</span> get the currently set calendar and time zone as they will be needed for the date calculations to come:</span></p>&#13;
<pre><span class="s4">let</span><span class="s7"> calendar = </span><span class="s1">Calendar</span><span class="s7">.</span><span class="s1">current</span><span class="s1"><br/></span><span class="s4">let</span><span class="s7"> timeZone = </span><span class="s1">TimeZone</span><span class="s7">.</span><span class="s1">current</span></pre>&#13;
<p class="p1"><span class="s1">While retrieving the current time zone is self-explanatory, it is not immediately obvious what the <kbd>Calendar</kbd> type represents and why we need to retrieve it.</span></p>&#13;
<p class="p1"><span class="s1">How dates are represented is not as universally agreed as you might believe. Certain time components are mostly universal, such as the length of years and days, as they are connected to astronomical events, such as the time it takes for the Earth to perform one revolution of the Sun, and for the Earth to complete one rotation <span>around its own axis</span>, respectively. However, other time components, such as months and weeks and how the years are numbered, are rooted in the culture that created them.</span></p>&#13;
<div class="p1 packt_infobox"><span class="s1">The calendar used throughout Europe and most of the world is known as the <strong>Gregorian calendar</strong>, introduced in 1582 by Pope Gregory XIII, replacing the Julian calendar. There are about 40 different calendars currently in use around the world, including Gregorian, Chinese, Hebrew, Islamic, Persian, Ethiopian, and Balinese Pawukon.</span></div>&#13;
<p class="p1"><span class="s1">The way in which we present how long there is until Christmas will depend on the calendar that is relevant to the user. This is why we ask for the current calendar, which the user can change if they want a different representation.</span></p>&#13;
<p class="p1"><span class="s1">Our next task is to get the current date and time:</span></p>&#13;
<pre><span class="s4">let</span><span class="s1"> now = </span><span class="s5">Date</span><span class="s1">()</span></pre>&#13;
<p class="p1"><span>In <em>Step 3</em>, the default</span> initializer <span>for the <kbd>Date</kbd> value type uses the current date and time as its value. Note that this date value is set at the point of creation; it does not continually update with the current date and time.</span></p>&#13;
<p class="p1"><span class="s1">In this step, we get a date and time for the next Christmas. We know the time, day, and month of Christmas, so to construct a date for Christmas, we just need to know the year. There is a method on <kbd>Calendar</kbd> called <kbd>component</kbd> that allows us to retrieve specific components from a <kbd>Date</kbd> value:</span></p>&#13;
<pre><span class="s4">let</span><span class="s1"> yearOfNextChristmas = </span><span class="s8">calendar</span><span class="s1">.</span><span class="s5">component</span><span class="s1">(.</span><span class="s5">year</span><span class="s1">, from: </span><span class="s8">now</span><span class="s1">)</span></pre>&#13;
<p class="p1"><span>We now have the current year, within the user's current calendar; we can use it to create the Christmas date.</span></p>&#13;
<p class="p1"><span class="s1">In <em>Step 4</em>, we create an instance of <kbd>DateComponents</kbd>, passing in the calendar, time zone, and the fact that we are defining December 25 at midnight, for the current year:</span></p>&#13;
<pre><span class="s1">var components = DateComponents(calendar: calendar,<br/>                                timeZone: timeZone,<br/>                                year: yearOfNextChristmas,<br/>                                month: 12,<br/>                                day: 25,<br/>                                hour: 0,<br/>                                minute: 0,<br/>                                second: 0)<br/></span></pre>&#13;
<p class="p4"><span>In <em>Step 5</em>, we create a <kbd>Date</kbd> object from <kbd>DateComponents</kbd>. This is of an optional type as we may not have</span> provided <span>enough information to the components to generate a date; however, since we know that we have, we can force-unwrap this optional:</span></p>&#13;
<pre><span class="s1">var christmas = components.date!</span></pre>&#13;
<p class="p1"><span class="s1">Next, we need to handle an edge case; what if we have already had Christmas this year? For example, let's imagine that the current date is December 27, 2020; we are trying to find the date of the next Christmas, but if we use the current year, we will get December 25, 2020, which is the Christmas just gone. So, in <em>Step 6</em>, we add 1 to the current year to get next Christmas, December 25, 2021:</span></p>&#13;
<pre>if christmas &lt; now {<br/>   components.year = yearOfNextChristmas + 1<br/>   christmas = components.date!<br/>}</pre>&#13;
<p class="p1"><span class="s1">To account for this, we check whether the Christmas for this year is before <kbd>now</kbd>; if it is, we bump the year component to next year and recreate the Christmas date from <kbd>DateComponent</kbd>.</span></p>&#13;
<p class="p1"><span class="s1">We now have the current <kbd>Date</kbd> and the next Christmas <kbd>Date</kbd>, and Foundation provides functionality to calculate the time difference between two dates and format it to display to a user, through the use of <kbd>DateComponentsFormatter</kbd>.</span></p>&#13;
<p><span>In <em>Step 7</em>, we create <kbd>DateComponentsFormatter</kbd>, and set <kbd>unitStyle</kbd> to <kbd>full</kbd>, which will provide a string using the full unit name, without abbreviation.</span><span> We </span><span>configure how we want the date and time divided for display, using <kbd>allowedUnits</kbd>:</span></p>&#13;
<pre>let componentFormatter = DateComponentsFormatter()<br/>componentFormatter.unitsStyle = .full<br/>componentFormatter.allowedUnits = [.month, .day, .hour, .minute, <br/>  .second]<br/><br/></pre>&#13;
<p class="p1"><span class="s1">In <em>Step 8</em>, we can retrieve a string from the formatter that describes the time between the two dates given, with the settings provided to the formatter. <span>Since</span> <kbd>DateComponentsFormatter</kbd><span> returns an optional string, we unwrap and return it:</span></span></p>&#13;
<pre>return componentFormatter.string(from: now, to: christmas)!</pre>&#13;
<p class="p1">Our <kbd>howLongUntilChristmas</kbd> method will provide a string describing how long until Christmas, which we can then print out.</p>&#13;
<h2 id="uuid-e2b4f89b-5222-42d9-9e38-5992bcbe2745" class="p1"><span class="s1">See also</span></h2>&#13;
<p class="p1"><span class="s1">There is a lot more to discover in Foundation, so check out the documentation for further functionality:</span></p>&#13;
<ul>&#13;
<li class="p3"><span class="s2">Swift 3 documentation for Foundation: </span><span class="s2"><a href="http://swiftbook.link/docs/foundation">http://swiftbook.link/docs/foundation</a></span></li>&#13;
<li class="p3"><span class="s2">Open source repository for Foundation:</span> <a href="https://github.com/apple/swift-corelibs-foundation"><span class="s2">https://github.com/apple/swift-corelibs-foundation</span></a></li>&#13;
</ul>&#13;
<h1 id="uuid-95c259be-9920-4b6a-9fff-4100d7d9dd75">Fetching data with URLSession</h1>&#13;
<p>Every app worth building will need to send or receive information from the internet at some point and therefore, networking support is a critical part of any development platform. In Swift, this support for networking is provided by the Foundation framework.</p>&#13;
<p class="p1"><span class="s1">When we need to retrieve information from the internet, we send out a request to a server on the internet, and that server sends a response that hopefully contains the information we requested.</span></p>&#13;
<p>In this recipe, we will learn how to send network requests and receive a response using the Foundation framework.</p>&#13;
<h2 id="uuid-1e479e06-4b93-4f7b-ab0d-4a463cf1a919" class="p1">Getting ready</h2>&#13;
<p class="p1"><span class="s1">It is helpful to know of the different components that Foundation provides that deal with networking and what they do:</span></p>&#13;
<ul>&#13;
<li><span class="s1"><kbd>URL</kbd>: The address of a resource on a remote server. It contains information about the server and where the resource can be found on the server.</span></li>&#13;
<li><span class="s1"><kbd>URLRequest</kbd>: Represents the request that will be made to the remote server. Defines the URL of the resource, how the request should be sent, metadata in the form of headers, and data that should be sent with it.</span></li>&#13;
</ul>&#13;
<ul>&#13;
<li><span class="s1"><kbd>URLSession</kbd>: Manages the communication with remote servers, holds the configuration for that communication, and creates and optimizes the underlying connections.</span></li>&#13;
<li><span class="s1"><kbd>URLSessionDataTask</kbd>: An object that manages the state of the request and delivers the response.</span></li>&#13;
<li><span class="s1"><kbd>URLResponse</kbd>: Holds the metadata of the response from the remote server.</span></li>&#13;
</ul>&#13;
<h2 id="uuid-e2a38b2b-6fc1-49e7-b0e9-c7adc9ca9059" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p><span class="s1">Let's use these networking tools to retrieve an image from a remote server:</span></p>&#13;
<ol>&#13;
<li>Import <kbd>PlaygroundSupport</kbd> and set up indefinite execution for this playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s2">import</span><span class="s1"> PlaygroundSupport<br/><br/></span><span class="s1">PlaygroundPage</span><span class="s3">.</span><span class="s1">current</span><span class="s3">.</span><span class="s1">needsIndefiniteExecution</span><span class="s3"> = </span><span class="s2">true</span></pre>&#13;
<ol start="2">&#13;
<li><span class="s1">Import Foundation and create an instance of <kbd>URLSession</kbd>:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import Foundation<br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<ol start="3">&#13;
<li>Next, we will construct a request for a remote image:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let urlString = "https://imgs.xkcd.com/comics/api.png"<br/>let url = URL(string: urlString)!<br/>let request = URLRequest(url: url)</pre>&#13;
<ol start="4">&#13;
<li>Now that we have our <kbd>URLRequest</kbd>, we can create a data task to retrieve the image from the remote server:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let task = session.dataTask(with: request, completionHandler: { <br/>  (data, response, error) in<br/><br/>})</pre>&#13;
<ol start="5">&#13;
<li>We will take the image data and put it in a <kbd>UIImage</kbd> object to display it. So, we need to import the <kbd>UIKit</kbd> framework, which provides <kbd>UIImage</kbd>. So, let's import <kbd>UIKit</kbd> at the top of the playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import UIKit</pre>&#13;
<ol start="6">&#13;
<li>Check for image data in the completion handler and create a <kbd>UIImage</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let task = session.dataTask(with: request) { (data, response, error)<br/>  in<br/>    guard let imageData = data else {<br/>        return // No Image, handle error<br/>    }<br/>    _ = UIImage(data: imageData)<br/>}</pre>&#13;
<ol start="7">&#13;
<li>Call <kbd>resume</kbd> on the task to start it:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">task.resume()</pre>&#13;
<h2 id="uuid-a1087811-8578-4e95-b118-0aefafa433f5">How it works...</h2>&#13;
<p>Let's walk through the previously mentioned steps to understand what we are doing:</p>&#13;
<pre><span class="s2">import</span><span class="s1"> PlaygroundSupport<br/><br/></span><span class="s1">PlaygroundPage</span><span class="s3">.</span><span class="s1">current</span><span class="s3">.</span><span class="s1">needsIndefiniteExecution</span><span class="s3"> = </span><span class="s2">true</span></pre>&#13;
<p class="p1"><span class="s1"><strong>Playgrounds</strong> execute the code they contain from top to bottom. When the end of the playground page is reached, the playground stops executing. In our example, the task is created and started, but then the playground reaches the end of the page before the image has been fully retrieved, because this happens asynchronously. If the playground were to stop execution here, the<span> </span></span>completion handler<span class="s1"><span> </span>would never be executed, and we wouldn't see the image. This isn't a problem in a normal app that is continually running while it is in use; it is just specific to how Swift playgrounds work.</span></p>&#13;
<p class="p1"><span class="s1">To solve this, we need to tell the playground that we don't want it to stop executing when it reaches the end of the page and instead, it should run indefinitely while we wait for the response to be received. This is done by importing the <kbd>PlaygroundSupport</kbd> framework <span>in </span><em>Step 1 </em>and setting <kbd>needsIndefiniteExecution</kbd> to be <kbd>true</kbd> on the current <kbd>PlaygroundPage</kbd>.</span></p>&#13;
<pre>import Foundation<br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<p>In <em>Step 2</em>, when creating <kbd>URLSession</kbd>, we pass in a<span> </span><kbd>URLSessionConfiguration</kbd><span> </span>object, which allows configuring the time it takes for a request to time out and cache responses, among other things. For our purposes, we will just use the default configuration.</p>&#13;
<pre>let urlString = "https://imgs.xkcd.com/comics/api.png"<br/>let url = URL(string: urlString)!<br/>let request = URLRequest(url: url)</pre>&#13;
<p>In  <em>Step 3</em>, we will be requesting the image from the excellent webcomic <em>XKCD</em> (<a href="https://xkcd.com/">http://xkcd.com</a>). We can create the URL from a string, and then create a<span> </span><kbd>URLRequest</kbd><span> request </span>from the URL.</p>&#13;
<pre>let task = session.dataTask(with: request, completionHandler: { (data,<br/>  response, error) in<br/><br/>})</pre>&#13;
<p>In <em>Step 4</em>, we do not create a data task directly; instead, we ask our<span> </span><kbd>URLSession</kbd><span> </span>instance to create the data task, and we pass in <kbd>URLRequest</kbd><span> </span>and a completion handler. The completion handler will be fired once a response has been received from the remote server or some error has occurred.</p>&#13;
<p class="p1"><span class="s1">The completion handler has three inputs, all optional:</span></p>&#13;
<ul>&#13;
<li class="p1"><span class="s1"><kbd>data: Data</kbd>: The data returned in the body of the response; if our request was successful, this will contain our image data.</span></li>&#13;
<li class="p1"><span class="s1"><kbd>response: URLResponse</kbd>: The response metadata, including response headers. If the request was over HTTP/HTTPS, then this will be <kbd>HTTPURLResponse</kbd>, which will contain the HTTP status code.</span></li>&#13;
<li class="p1"><span class="s1"><kbd>error: Error</kbd>: If the request was unsuccessful, due to a network issue, for example, this value will have the error, and the data and response value will be<span> </span><kbd>nil</kbd>. If the request was successful, this error value will be<span> </span><kbd>nil</kbd>.</span></li>&#13;
</ul>&#13;
<pre>let task = session.dataTask(with: request) { (data, response, error) in<br/>    guard let imageData = data else {<br/>        return // No Image, handle error<br/>    }<br/>    _ = UIImage(data: imageData)<br/>}</pre>&#13;
<p>In <em>Step 6</em>, we check for response data and turn it into an image. To do this, we will need to construct a<span> </span><kbd>UIImage</kbd><span> object </span>from the data.<span> </span><kbd>UIImage</kbd><span> </span>is a class that represents an image on iOS and can be found in the<span> </span><kbd>UIKit</kbd><span> </span>framework. So, we also needed to import<span> </span><kbd>UIKit</kbd><span> </span>at the top of the playground, as we have done in <em>Step 5</em>.</p>&#13;
<div class="packt_infobox">Since we don't plan on doing anything with the image in this example, we are just going to view it in a playground preview; the compiler will complain if we assign it to a value that is never used. Therefore, we replace a normal value assignment with <kbd>_</kbd>, which allows the <kbd>UIImage</kbd> object to be generated without it being assigned to anything.</div>&#13;
<pre>task.resume()</pre>&#13;
<p>In <em>Step 7</em>, we have created the data task to retrieve the image, but we need to actually start the task to make the request. To do that, we call<span> </span><kbd>resume</kbd><span> </span>on the task.</p>&#13;
<p class="p1"><span class="s1">When we run the playground, you will eventually see that the image value has been populated in the playground's right sidebar, and you can click on the preview icon to see the image that has been downloaded:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png" style="" width="940" height="977"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.1 – Retrieved image displayed in the playground timeline </div>&#13;
<h2 id="uuid-b9c3b999-0481-4b71-9839-06b1ed1d82cc" class="p1"><span class="s1">See also</span></h2>&#13;
<ul>&#13;
<li>Further information about networking can be found in Apple's networking overview: <a href="http://swiftbook.link/docs/networking">http://swiftbook.link/docs/networking</a></li>&#13;
<li>More information can also be found in Apple's <span>URL Session programming guide:</span><span> </span><a href="http://swiftbook.link/docs/urlsession-guide">http://swiftbook.link/docs/urlsession-guide</a></li>&#13;
</ul>&#13;
<h1 id="uuid-6431d8ec-2328-4a3e-8d30-b5b5febb77fc">Working with JSON</h1>&#13;
<p class="p1"><span class="s1">As discussed in the last recipe, almost every app will need to exchange information with the internet at some point, and in that recipe, we retrieved an image from a remote server. Very often, your app will need to retrieve more varied data, perhaps relating to the result of a search, or information about a shared state held on the server.</span></p>&#13;
<p class="p1"><span class="s1">This information can be represented in any number of ways, but one of the most common ways is as </span><span><strong>JavaScript Object Notation</strong> </span><span class="s1">(</span><strong><span>JSON</span></strong><span>), which is a text-based structure for representing information. A JSON object contains key-value pairs, where the keys are strings and the values can be strings, numbers, Booleans, null, other objects, or arrays.</span></p>&#13;
<p class="p1"><span class="s1">For example, information about a person could be expressed with this JSON object:</span></p>&#13;
<pre>{<br/>  "name": { <br/>    "givenName": "Keith",<br/>    "middleName": "David",<br/>    "familyName": "Moon"<br/>  },<br/>  "age": 40,<br/>  "heightInMetres": 1.778,<br/>  "isBritish": true,<br/>  "favouriteFootballTeam": null<br/>}</pre>&#13;
<p class="p1"><span>The following is an example of</span> an <span>array of JSON objects:</span></p>&#13;
<pre>[<br/>  {<br/>    "name": { <br/>      "givenName": "Keith",<br/>      "middleName": "David",<br/>      "familyName": "Moon"<br/>    },<br/>    "age": 40,<br/>    "heightInMetres": 1.778,<br/>    "isBritish": true,<br/>    "favouriteFootballTeam": null<br/>  },<br/>  {<br/>    "name": { <br/>      "givenName": "Alissa",<br/>      "middleName": "May",<br/>      "familyName": "Moon"<br/>    },<br/>    "age": 35,<br/>    "heightInMetres": 1.765,<br/>    "isBritish": false,<br/>    "favouriteFootballTeam": null<br/>  }<br/>]</pre>&#13;
<p class="p1"><span class="s1">Foundation provides tools for reading information from and writing information as JSON data. In this recipe, we will interact with a JSON-based</span><span> </span><strong><span>Application Programming Interface</span></strong><span class="s1"> (</span><strong><span>API</span></strong><span>), to both send and receive information.</span></p>&#13;
<h2 id="uuid-9e1260f8-35df-4d95-bb44-4e0dc960d252" class="p1"><span class="s1">Getting ready</span></h2>&#13;
<p class="p1"><span class="s1">Our goal is to interact with the GitHub API and create an issue for this book's repository. A full explanation of Git and GitHub is beyond the scope of this book; suffice to say that it's a service that stores versioned copies of your source code. Resources relevant to this book are stored in repositories on GitHub, and a GitHub user can create <em>issues</em> that serve as bug reports or feature requests.</span></p>&#13;
<p class="p1"><span class="s1">If you don't already have one, then you will need to sign up for a GitHub account:</span></p>&#13;
<ol>&#13;
<li class="p3"><span class="s2">Go to <a href="https://github.com"><span class="s3">https://github.com</span></a></span>.</li>&#13;
<li class="p1"><span class="s1">Fill in your details and press <span class="packt_screen">Sign up for GitHub</span></span>.</li>&#13;
</ol>&#13;
<p class="p1"><span class="s1">Once you have created a GitHub account, you will need to create a personal access token, which we will use to authenticate some of the requests to the GitHub API. </span><span class="s1">To create a personal access token, use the following steps:</span></p>&#13;
<ol>&#13;
<li class="p1"><span class="s1">Go to the settings page (<a href="https://github.com/settings/tokens"><span class="s3">https://github.com/settings/tokens</span></a>) and click on <span class="packt_screen">Generate new token</span>.</span></li>&#13;
<li class="p1">Give the token a name and check the box next to <span class="packt_screen">repo</span><span>:</span></li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png" style="" width="1457" height="869"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.2 – Creating a personal access token</div>&#13;
<ol start="3">&#13;
<li>Click on <span class="packt_screen">Generate token</span> at the bottom of the page. You will now see your newly generated personal access token.</li>&#13;
<li>Copy this token and paste it somewhere, as we will need it later:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png" style="" width="1384" height="461"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 5.3 – The generated personal access token</span></div>&#13;
<h2 id="uuid-9b3e2d0c-fd00-4e27-8400-261946091116" class="p1"><span class="s1">How to do it...</span></h2>&#13;
<p class="p1"><span class="s1">To create our issue, we will first retrieve all of Packt Publishing's public repositories, and then find the relevant repository for this book. We will then create a new issue in this repository.</span></p>&#13;
<p><span class="s1">As in the preceding recipe, we will need a <kbd>URLSession</kbd> object to perform our requests, and we need to tell the playground not to finish executing when it reaches the end of the playground:</span></p>&#13;
<pre>import Foundation<br/>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true<br/><br/>let config = URLSessionConfiguration.default<br/>let session = URLSession(configuration: config)</pre>&#13;
<p>Our first step is to fetch all the public repositories for a given user:</p>&#13;
<ol>&#13;
<li>Let's create a function to do that:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fetchRepos(forUsername username: String) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json", <br/>    forHTTPHeaderField: "Accept")<br/> <br/>  let task = session.dataTask(with: request) { (data, response, <br/>    error) in<br/> <br/>  }<br/>  task.resume()<br/>}</pre>&#13;
<p style="padding-left: 60px">You will note that after creating <kbd>URLRequest</kbd>, we set an HTTP header; this particular header ensures that we will always get back version 3 of the GitHub API.</p>&#13;
<div class="p1 packt_infobox"><span class="s1">We know from the GitHub API documentation (<a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a>) <span>that this response data is in JSON format.</span> We need to parse the JSON data to turn it into something that we can use; enter <kbd>JSONSerialization</kbd>. <kbd>JSONSerialization</kbd> is part of the Foundation framework and provides class methods for turning Swift dictionaries and arrays into JSON data (known as <strong>serialization</strong>) and back again (known as <strong>deserialization</strong>).</span></div>&#13;
<ol start="2">&#13;
<li>Let's use <kbd>JSONSerialization</kbd> to turn our JSON response data into something more useful:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span>func fetchRepos(forUsername username: String) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json",<br/>    forHTTPHeaderField: "Accept")<br/>  let task = session.dataTask(with: request) { (data, response, <br/>    error) in<br/> <br/>    // Once we have handled this response, the Playground<br/>    // can finish executing.<br/>    defer {<br/>      PlaygroundPage.current.finishExecution()<br/>    }<br/> <br/>    // First unwrap the optional data<br/>    guard let jsonData = data else {<br/>      // If it is nil, there was probably a network error<br/>      print(error ?? "Network Error")<br/>      return<br/>    }<br/> <br/>    do {<br/>      // Deserialisation can throw an error, so we have to `try` and <br/>        // catch errors<br/>      let deserialised = try JSONSerialization.jsonObject(with: <br/>        jsonData, options: [])<br/>      print(deserialised)<br/> <br/>    } catch {<br/>      print(error)<br/>    }<br/>  }<br/></span>  task<span>.resume()<br/>}</span></pre>&#13;
<ol start="3">&#13;
<li>Now, let's fetch the public Packt repositories by executing our function and passing <kbd>PacktPublishing</kbd> <span>in as the GitHub username:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s9">fetchRepos</span><span class="s1">(forUsername: </span><span class="s10">"PacktPublishing"</span><span class="s1">)</span></pre>&#13;
<p style="padding-left: 60px">Once executed, the print output should look like this:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png" style="" width="1952" height="565"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 5.4 – Public GitHub repositories API response</span></div>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1"><kbd>JSONSerializer</kbd> has turned our JSON data into familiar arrays and dictionaries that can be used to retrieve the information we need in the normal way. The JSON data is deserialized with the <kbd>Any</kbd> <span>type,</span> as the JSON can have a JSON object or an array at its root.</span></p>&#13;
<p class="p1"><span class="s1">Since, from the preceding output, <span>we know</span> that the response has an array of JSON objects <span>at its root</span>, we need to turn the value from type <kbd>Any</kbd> to an array of dictionaries of the <kbd>[String: Any]</kbd> <span>type.</span> This is referred to as <strong>casting</strong> from one type to another, which we can do by using the <kbd>as</kbd> keyword and then specifying the new type. This keyword can be used in three different ways:</span></p>&#13;
<ul>&#13;
<li class="p1"><span class="s1"><kbd>as</kbd> will perform a trivial cast. This is possible if the existing type is synonymous with the intended type, for instance, casting from a subclass to a superclass.</span></li>&#13;
<li class="p1"><span class="s1"><kbd>as?</kbd> will conditionally perform a cast, returning an optional value. If it is not possible to represent the value as the intended type, the value will be <kbd>nil</kbd>.</span></li>&#13;
<li class="p1"><span class="s1"><kbd>as!</kbd> will perform a forced cast. If it is not possible to represent the value as the intended type, you will get a crash.</span></li>&#13;
</ul>&#13;
<p>So, let's cast the deserialized data to an array of dictionaries with string keys, with the <span class="s1"><kbd>[[String: Any]]</kbd> <span>type:</span></span></p>&#13;
<pre>func fetchRepos(forUsername username: String) {<br/>   //...<br/>   let task = session.dataTask(with: request) { (data, response, error) <br/>     in<br/>     //...<br/>     do {<br/>       // Deserialisation can throw an error, so we have to `try` and <br/>         // catch errors<br/>       let deserialised = try JSONSerialization.jsonObject(with:<br/>         jsonData, options: [])<br/>       print(deserialised)<br/>       // As `deserialised` has type `Any` we need to cast<br/>       guard let repos = deserialised as? [[String: Any]] else {<br/>         print("Unexpected Response")<br/>         return<br/>       }<br/>       print(repos)<br/>     } catch {<br/>       print(error)<br/>     }<br/>   }<br/>}</pre>&#13;
<p class="p1"><span class="s1">Now, we have an array of dictionaries for the repositories in the API response, which we need to provide as input for this function. A common pattern for providing results for asynchronous work is to provide a completion handler as a parameter. A completion handler is a closure that can be executed once the asynchronous work is completed.</span></p>&#13;
<p>Since the output we want to provide is the array of repository dictionaries, we will define this as an input for the closure if the request was successful, and an error if it wasn't:</p>&#13;
<pre>func fetchRepos(forUsername username: String, completionHandler: <br/>  @escaping ([[String: Any]]?, Error?) -&gt; Void) {<br/> <br/>  let urlString = "https://api.github.com/users/\(username)/repos"<br/>  let url = URL(string: urlString)!<br/>  var request = URLRequest(url: url)<br/>  request.setValue("application/vnd.github.v3+json",<br/>    forHTTPHeaderField: "Accept")<br/>  let task = session.dataTask(with: request) { (data, response, error) <br/>    in<br/> <br/>    // Once we have handled this response, the Playground<br/>    // can finish executing.<br/>    defer {<br/>      PlaygroundPage.current.finishExecution()<br/>    }<br/> <br/>    // First unwrap the optional data<br/>    guard let jsonData = data else {<br/>      // If it is nil, there was probably a network error<br/>      completionHandler(nil, ResponseError.requestUnsuccessful)<br/>      return<br/>    }<br/> <br/>    do {<br/>      // Deserialisation can throw an error, so we have to `try` and <br/>       // catch errors<br/>      let deserialised = try JSONSerialization.jsonObject(with: <br/>        jsonData, options: [])<br/>       // As `deserialised` has type `Any` we need to cast<br/>      guard let repos = deserialised as? [[String: Any]] else {<br/>        completionHandler(nil, <br/>          ResponseError.unexpectedResponseStructure)<br/>        return<br/>      }<br/> <br/>      completionHandler(repos, nil)<br/> <br/>    } catch {<br/>      completionHandler(nil, error)<br/>    }<br/>  }<br/>  task.resume()<br/>}</pre>&#13;
<p>Now, whenever an error is generated, we execute <span class="s1"><kbd>completionHandler</kbd>, passing in the error and <kbd>nil</kbd> for the results value. Also, when we have the repository results, we execute the completion handler, passing in the parsed JSON and <kbd>nil</kbd> for the error.</span></p>&#13;
<p>We passed in a few new errors in the preceding code, so let's define those errors:</p>&#13;
<pre>enum ResponseError: Error {<br/>  case requestUnsuccessful<br/>  case unexpectedResponseStructure<br/>}</pre>&#13;
<p>This changes how we call this <span class="s1"><kbd>fetchRepos</kbd> function:</span></p>&#13;
<pre>fetchRepos(forUsername: "PacktPublishing") { (repos, error) in<br/><br/>  if let repos = repos {<br/>    print(repos)<br/>  } else if let error = error {<br/>    print(error)<br/>  }<br/>}</pre>&#13;
<p class="p1"><span class="s1">Now that we have retrieved the details of the public repositories, we will submit an issue to the repository for this chapter. This issue can be any feedback you would like to give about this book; it can be a review, a suggestion for new content, or you can tell me about a Swift project you are currently working on.</span></p>&#13;
<p class="p1"><span class="s1">This request to the GitHub API will be authenticated against your user account and therefore, we will need to include details of the personal access token that we created at the beginning of this recipe. There are a number of ways to authenticate requests to the GitHub API, but the simplest is</span> basic authentication<span class="s1">, which involves adding an authorization string to the request header.</span></p>&#13;
<p class="p1"><span class="s1">Let's create a method to format the personal access token correctly for authentication:</span></p>&#13;
<pre><span class="s2">func</span><span class="s1"> authHeaderValue(for token: </span><span class="s3">String</span><span class="s1">) -&gt; </span><span class="s3">String</span><span class="s1"> {<br/></span><span class="s2">  let</span><span class="s1"> authorisationValue = </span><span class="s3">Data</span><span class="s1">(</span><span class="s4">"</span><span class="s1">\</span><span class="s4">(</span><span class="s1">token</span><span class="s4">):x-oauth-<br/>    basic"</span><span class="s1">.</span><span class="s3">utf8</span><span class="s1">).</span><span class="s5">base64EncodedString</span><span class="s1">()<br/></span><span class="s2">  return</span><span class="s1"> </span><span class="s4">"Basic </span><span class="s1">\</span><span class="s4">(</span><span class="s1">authorisationValue</span><span class="s4">)"<br/></span><span class="s1">}</span></pre>&#13;
<p>Next, let's create our function to submit our issue. <span class="s1">From the API documentation at <a href="https://developer.github.com/v3/issues/#create-an-issue"><span class="s6">https://developer.github.com/v3/issues/#create-an-issue</span></a>, we can see that unless you have push access, you can only create an issue with the following components:</span></p>&#13;
<ul>&#13;
<li class="p1"><span class="s1"><kbd>title</kbd> (required)</span></li>&#13;
<li class="p1"><kbd>body</kbd> (optional)</li>&#13;
</ul>&#13;
<p>So, our function will take this information as input, along with the repository name and username<span class="s1">:</span></p>&#13;
<pre><span class="s2">func</span><span class="s1"> createIssue(inRepo repo: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>forUser user: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>title: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>body: </span><span class="s3">String</span><span class="s1">?) {<br/><br/></span><span class="s1">}</span></pre>&#13;
<p>Creating an issue is achieved by sending a <kbd>POST</kbd> request<span>, and information about the issue is provided as JSON data in the request body. To create our request, we can use <kbd>JSONSerialization</kbd>, but we will take our intended JSON structure and serialize it into <kbd>Data</kbd> this time:</span></p>&#13;
<pre><span class="s2">func</span><span class="s1"> createIssue(inRepo repo: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>forUser user: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>title: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>body: </span><span class="s3">String</span><span class="s1">?) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s7"><span class="Apple-converted-space">    </span></span><span class="s1">// Create the URL and Request<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s7"><span class="Apple-converted-space">    </span></span><span class="s2">let</span><span class="s7"> urlString = </span><span class="s1">"https://api.github.com/repos/</span><span class="s7">\</span><span class="s1">(</span><span class="s7">user</span><span class="s1">)/</span><span class="s7">\<br/></span><span class="s1">      (</span><span class="s7">repo</span><span class="s1">)/issues"<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">let</span><span class="s1"> url = </span><span class="s3">URL</span><span class="s1">(string: urlString)!<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> request = </span><span class="s3">URLRequest</span><span class="s1">(url: url)<br/>    request.httpMethod = "POST"<br/></span><span class="s7"><span class="Apple-converted-space">    </span>request.</span><span class="s5">setValue</span><span class="s7">(</span><span class="s1">"application/vnd.github.v3+json"</span><span class="s7">, <br/>                     forHTTPHeaderField: </span><span class="s1">"Accept"</span><span class="s7">)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">l</span><span class="s2">et</span><span class="s1"> authorisationValue = </span><span class="s8">authH</span><span class="s8">eaderValue</span><span class="s1">(for: &lt;#your personal <br/>      access token&gt;)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>request.</span><span class="s5">setValue</span><span class="s1">(authorisationValue, forHTTPHeaderField: <br/></span><span class="s4">      "Authorization"</span><span class="s1">)<br/></span><span class="s7"><span class="Apple-converted-space">    </span></span><span class="s1">// Put the issue information into the JSON structure required<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">var</span><span class="s1"> json = [</span><span class="s4">"title"</span><span class="s1">: title]<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">if</span><span class="s1"> </span><span class="s2">let</span><span class="s1"> body = body {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>json[</span><span class="s4">"body"</span><span class="s1">] = body<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s7"><span class="Apple-converted-space">    </span></span><span class="s1">// Serialise the json into Data. We can use try! as we know it is <br/>     // valid JSON.<br/>    // Just be aware that the this will fail if </span><span class="s1">provided value can't be<br/>     //  converted into valid JSON.</span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s2">let</span><span class="s1"> jsonData = </span><span class="s2">try</span><span class="s1">! </span><span class="s3">JSONSerialization</span><span class="s1">.</span><span class="s5">data</span><span class="s1">(withJSONObject: json, <br/>      options: .</span><span class="s3">prettyPrinted</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>request.</span><span class="s3">httpBody</span><span class="s1"> = jsonData<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s9">session</span><span class="s1">.</span><span class="s5">dataTask</span><span class="s1">(with: request) { (data, response, error) </span><span class="s2">in<br/></span><span class="s7"><span class="Apple-converted-space">        </span></span><span class="s1">// TO FINISH<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p>As with the previous API request, we need a way to provide the result of creating <span class="s1">the issue, so let's provide a completion handler, try to deserialize the response, and provide it to the completion handler:</span></p>&#13;
<pre><span class="s2">func</span><span class="s1"> createIssue</span><span class="s1">(inRep</span><span class="s1">o repo: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>forUser user: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>title: </span><span class="s3">String</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>body: </span><span class="s3">String</span><span class="s1">?, <br/></span><span class="s1"><span class="Apple-converted-space">                 </span>completionHandler: </span><span class="s2">@escaping</span><span class="s1"> ([</span><span class="s3">String</span><span class="s1">: </span><span class="s2">Any</span><span class="s1">]?, </span><span class="s3">Error</span><span class="s1">?) <br/>                   <span>-&gt;</span> </span><span class="s3">Void</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    //...</span></span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s9">session</span><span class="s1">.</span><span class="s5">dataTask</span><span class="s1">(with: request) { (data, response, error) </span><span class="s2">in<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">guard</span><span class="s1"> </span><span class="s2">let</span><span class="s1"> jsonData = data </span><span class="s2">else</span><span class="s1"> { <br/></span><span class="s1"><span class="Apple-converted-space">            </span>completionHandler(</span><span class="s2">nil</span><span class="s1">, </span><span class="s9">ResponseError</span><span class="s1">.</span><span class="s8">requestUnsuccessful</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s2">return<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s2">do</span><span class="s1"> {<br/></span><span class="s7"><span class="Apple-converted-space">            </span></span><span class="s1">// Deserialisation can throw an error, so we have to `try` <br/>            // and catch errors<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s2">let</span><span class="s1"> deserialised = </span><span class="s2">try</span><span class="s1"> </span><span class="s3">JSONSerialization</span><span class="s1">.</span><span class="s5">jsonObject</span><span class="s1">(with: <br/>              jsonData, options: [])</span><span class="s1"><span class="Apple-converted-space"><br/></span></span><span class="s7"><span class="Apple-converted-space">            </span></span><span class="s1">// As `deserialised` has type `Any` we need to cast<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s2">guard</span><span class="s1"> </span><span class="s2">let</span><span class="s1"> createdIssue = deserialised </span><span class="s2">as</span><span class="s1">? [</span><span class="s3">String</span><span class="s1">: </span><span class="s2">Any</span><span class="s1">]<br/>              </span><span class="s2">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">                </span>completionHandler(</span><span class="s2">nil</span><span class="s1">, <br/></span><span class="s9">                  ResponseError</span><span class="s1">.</span><span class="s8">unexpectedResponseStructure</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s2">return<br/></span><span class="s1"><span class="Apple-converted-space">            </span>}<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">            </span>completionHandler(createdIssue, </span><span class="s2">nil</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>} </span><span class="s2">catch</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span>completionHandler(</span><span class="s2">nil</span><span class="s1">, error)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span>The API response to a successfully created</span> issue <span>provides a JSON representation of that issue. Our function will return this representation if it was successful, or an error if it was not.</span></p>&#13;
<p>Now that we have a function to create issues in a repository, it's time to use it to create an issue:</p>&#13;
<pre><span class="s8">createIssue</span><span class="s7">(inRepo: <span class="s1">"Swift</span></span><span class="s7"><span class="s1">-5-Cookbook-Second-Edition"</span><span class="s7">, <br/></span><span class="s1"><span class="Apple-converted-space">            </span>forUser: </span><span class="s4">"PacktPublishing"</span><span class="s1">, <br/></span><span class="s1"><span class="Apple-converted-space">            </span>title: &lt;#The title of your feedback#&gt;, <br/></span><span class="s1"><span class="Apple-converted-space">            </span>body: &lt;#Extra detail#&gt;) { (issue, error) </span><span class="s2">in<br/></span><span class="s1"><span class="Apple-converted-space">                <br/></span></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s2">if</span><span class="s1"> </span><span class="s2">let</span><span class="s1"> issue = issue {<br/></span><span class="s1"><span class="Apple-converted-space">                    </span></span><span class="s5">print</span><span class="s1">(issue)<br/></span><span class="s1"><span class="Apple-converted-space">                </span>} </span><span class="s2">else</span><span class="s1"> </span><span class="s2">if</span><span class="s1"> </span><span class="s2">let</span><span class="s1"> error = error {<br/></span><span class="s1"><span class="Apple-converted-space">                    </span></span><span class="s5">print</span><span class="s1">(error)<br/></span><span class="s1"><span class="Apple-converted-space">                </span>}<br/></span><span class="s1">}</span></span></pre>&#13;
<div class="p1 packt_tip"><span class="s1">I will check these created issues, so please provide genuine feedback on this book. How have you found the content? Too detailed? Not detailed enough? Anything I've missed or not fully explained? Any questions that you have? This is your opportunity to let me know.</span></div>&#13;
<h2 id="uuid-5717d8ec-4388-4b23-83e7-c7b405e3838d" class="p1"><span class="s1">There's more...</span></h2>&#13;
<p class="p1"><span class="s1">When we created our completion handlers, we gave them two inputs: the successful result (either the repository information or the created issue) or an error if there is a failure. Both these values are optional; one will be <kbd>nil</kbd>, and the other has a value. However, this convention is not enforced by the language, and a user of this function will have to consider the possibility that it may not be the case. What should the user of this function do if the <kbd>fetchRepos</kbd> function fires the completion handler with non-<kbd>nil</kbd> values for both the repository and the error? What if both are <kbd>nil</kbd>?</span></p>&#13;
<p class="p1"><span class="s1">The user of this function, without viewing the function's internal code, can't be sure that this won't happen, which means they may need to write functionality and tests to account for this possibility, even though it may never happen.</span></p>&#13;
<p class="p1"><span class="s1">It would be better if we could more accurately represent the intended behavior of our function, providing the user with a clear indication of the possible outcomes and leaving no room for ambiguity. We know that there are two possible outcomes from calling the function: it will either succeed and return the relevant value, or it will fail and return an error to indicate the reason for the failure.</span></p>&#13;
<p class="p1"><span class="s1">Instead of optional values, we can use an enum to represent these possibilities, and the Foundation framework provides a generic enum for this purpose, called <kbd>Result</kbd>.</span></p>&#13;
<p>The <kbd>Result</kbd> enum has a <kbd>success</kbd> case, which has an associated type for a successful result, and a <kbd>failure</kbd> case with an associated type for the relevant error. Both associated types are defined as generic constraints, with the failure type needing to conform to the <kbd>Error</kbd> protocol.</p>&#13;
<p class="p1"><span class="s1">We can now define the success and failure states and use associated values to hold the value that is relevant for each state, which is the repository information for the success state and the error for the failure state.</span></p>&#13;
<p class="p1"><span class="s1">Now, let's amend our <kbd>fetchRepos</kbd> function to provide a <kbd>Result</kbd> enum in <kbd>completionHandler</kbd>:</span></p>&#13;
<pre>func fetchRepos(forUsername username: String,<br/>    completionHandler: @escaping (Result&lt;[[String: Any]], Error?) - <br/>      <span>-&gt;</span> Void) {<br/> <br/>    //...<br/>  <br/>    let task = session.dataTask(with: request) { (data, response, <br/>      error) in<br/> <br/>        //...<br/> <br/>        // First unwrap the optional data<br/>        guard let jsonData = data else {<br/>            // If it is nil, there was probably a network error<br/>            completionHandler(.failure(ResponseError.<br/>              requestUnsuccessful))<br/>            return<br/>        }<br/> <br/>        do {<br/>            // Deserialisation can throw an error, <br/>            // so we have to `try` and catch errors<br/>            let deserialised = try JSONSerialization.jsonObject(with: <br/>              jsonData, options: [] ) <br/>            // As `deserialised` has type `Any` we need to cast<br/>            guard let repos = deserialised as? [[String: Any]] else {<br/>                let error = ResponseError.unexpectedResponseStructure<br/>                completionHandler(.failure(error))<br/>                return<br/>            }<br/>            completionHandler(.success(repos))<br/>        } catch {<br/>            completionHandler(.failure(error))<br/>        }<br/>    }<br/>    task.resume()<br/>}</pre>&#13;
<p class="p1"><span class="s1">We need to update how we call the <kbd>fetchRepos</kbd> function:</span></p>&#13;
<pre>fetchRepos(forUsername: "PacktPublishing", completionHandler:{ result<br/>  in<br/>    switch result {<br/>        case .success(let repos):<br/>            print(repos)<br/> <br/>        case .failure(let error):<br/>            print(error)<br/>    }<br/>})</pre>&#13;
<p class="p1"><span class="s1">We now use a <kbd>switch</kbd> statement instead of <kbd>if/else</kbd>, and we get the added benefit that the compiler will ensure that we have covered all possible outcomes.</span></p>&#13;
<p class="p1"><span class="s1">Having made this improvement to the <kbd>fetchRepos</kbd> function, we can similarly improve the <kbd>createIssue</kbd> function</span><span class="s1">:</span></p>&#13;
<pre>func createIssue(inRepo repo: String, <br/>                 forUser user: String, <br/>                 title: String, <br/>                 body: String?, <br/>                 completionHandler: @escaping (Result&lt;[[String:   <br/>                   Any]], Error?) <span>-&gt;</span> Void) {<br/>    //...<br/>    let task = session.dataTask(with: request) { (data, response, <br/>      error) in<br/> <br/>        guard let jsonData = data else { <br/>            completionHandler(.failure(ResponseError.<br/>              requestUnsuccessful))<br/>            return<br/>        }<br/> <br/>        do {<br/>            // Deserialisation can throw an error, <br/>            // so we have to `try` and catch errors<br/>            let deserialised = try JSONSerialization.jsonObject(with: <br/>              jsonData, options: [])<br/> <br/>            // As `deserialised` has type `Any` we need to cast<br/>            guard let createdIssue = deserialised as? [String: Any] <br/>              else {<br/>                let error = ResponseError.unexpectedResponseStructure<br/>                completionHandler(.failure(error))<br/>                return<br/>            }<br/> <br/>            completionHandler(.success(createdIssue))<br/> <br/>        } catch {<br/>            completionHandler(.failure(error))<br/>        }<br/>    }<br/>    task.resume()<br/>}</pre>&#13;
<p class="mce-root">Lastly, we need to update the contents of the completion handler that we provide to the <kbd>createIssue</kbd> function:</p>&#13;
<pre>createIssue(inRepo: "Swift-5-Cookbook-Second-Edition", <br/>            forUser: "PacktPublishing", <br/>            title: &lt;#The title of your feedback#&gt;, <br/>            body: &lt;#Extra detail#&gt;) { result in<br/> <br/>    switch result {<br/>        case .success(let issue):<br/>            print(issue)<br/> <br/>        case .failure(let error):<br/>            print(error)<br/>    }<br/>}</pre>&#13;
<p class="p1"><span class="s1">Working with JSON data and extracting relevant information from it can be frustrating. Consider the JSON response for our <kbd>fetchRepos</kbd> function:</span></p>&#13;
<pre>[<br/>    {<br/>        "id": 68144965,<br/>        "name": "JSONNode",<br/>        "full_name": "keefmoon/JSONNode",<br/>        "owner": {<br/>            "login": "keefmoon",<br/>            "id": 271298,<br/>            "avatar_url": <br/>              "https://avatars.githubusercontent.com/u/271298?v=3",<br/>            "gravatar_id": "",<br/>            "url": "https://api.github.com/users/keefmoon",<br/>            "html_url": "https://github.com/keefmoon",<br/>            "followers_url":<br/>              "https://api.github.com/users/keefmoon/followers",<br/>            //... Some more URLs<br/>            "received_events_url": <br/>            "https://api.github.com/users/keefmoon/received_events",<br/>            "type": "User",<br/>            "site_admin": false<br/>        },<br/>        "private": false,<br/>        //... more values<br/>    }<br/>    //... more repositories<br/>]</pre>&#13;
<p class="p1"><span class="s1">If we want to get the username for the owner of the first repository, we need to deserialize the JSON and then conditionally unwrap multiple nested layers to get the username string:</span></p>&#13;
<pre>let jsonData = //... returned from the network<br/><br/>guard <br/>    let deserialised = try? JSONSerialization.jsonObject(with: <br/>      jsonData, options: []), <br/>    let repoArray = deserialised as? [[String: Any]], <br/>    let firstRepo = repoArray.first, <br/>    let ownerDictionary = firstRepo["owner"] as? [String: Any], <br/>    let username = ownerDictionary["login"] as? String <br/>    else {<br/>        return<br/>}<br/>print(username)</pre>&#13;
<p class="p1"><span class="s1">That's a lot of optional unwrapping and casting just to get one value! Swift's strongly typed nature doesn't work well with JSON's loosely defined schema, which is why you have to do a lot of work to turn loosely typed information into strongly typed values.</span></p>&#13;
<p class="p1"><span class="s1">To help with these problems, a number of open source frameworks are available, which make working with JSON in Swift easier. <kbd>SwiftyJSON</kbd> is a popular framework that can be found on GitHub at</span> <span class="s2"><a href="https://github.com/SwiftyJSON/SwiftyJSON"><span class="s3">https://github.com/SwiftyJSON/SwiftyJSON</span></a></span>.</p>&#13;
<p class="p1"><span class="s1">I have also built a lightweight JSON helper called <kbd>JSONNode</kbd>, which can also be found on GitHub at</span> <span class="s2"><a href="https://github.com/keefmoon/JSONnode"><span class="s3">https://github.com/keefmoon/JSONnode</span></a></span>.</p>&#13;
<p class="p1"><span class="s1">With <kbd>JSONNode</kbd>, you can perform the same task of retrieving the owner's username for the first repository with the following code:</span></p>&#13;
<pre>let jsonData = //... returned from the network<br/>guard <br/>    let jsonNode = try? JSONNode(data: jsonData),<br/>    let username = jsonNode[0]["owner"]["username"].string <br/>    else {<br/>        return<br/>}<br/><br/>print(username)</pre>&#13;
<p class="p1"><span>Information within JSON, of any depth, can be retrieved in one line using subscripts.</span></p>&#13;
<h1 id="uuid-181f0194-07c1-4d52-bbe7-c6314100a4ab" class="p1">Working with XML</h1>&#13;
<p class="p1"><span class="s1"><strong>XML</strong> stands for <strong>eXtensible Markup Language</strong> and is a popular way of representing data for storage and transfer across a network. XML is a very flexible format and is used to represent many types of data. The current specification of HTML, which powers most of the web, is an implementation of XML.</span></p>&#13;
<p class="p1"><span class="s1">The version of XML that we will concern ourselves with in this recipe is <strong>RSS</strong>, which stands for <strong>Really Simple Syndication</strong>. RSS is used to define a collection of time-ordered pieces of digestible content; these RSS feeds can then be used to aggregate content from a number of different sources. RSS is typically used as a distribution mechanism for news articles and podcasts.</span></p>&#13;
<p>In this recipe, we will learn how to read and write XML data by fetching and parsing the BBC News RSS feed.</p>&#13;
<h2 id="uuid-1f1c02c2-e25e-427c-b010-7e38ba66b880" class="p1"><span class="s1">Getting ready</span></h2>&#13;
<p class="p1"><span class="s1">The functionality to deal with XML data is provided by the Foundation framework. However, while the classes that help with reading XML data are available on all of Apple's platforms, the classes that assist with writing XML data are only available on the macOS platform.</span></p>&#13;
<p class="p1"><span class="s1">This is an unfortunate oversight and means that if you need to write XML data within an iOS app, you will likely need to look for a third-party helper or build your own. We will investigate third-party helpers at the end of this recipe.</span></p>&#13;
<p><span class="s1">To investigate both reading and writing XML using the Foundation framework, we need to create a new macOS-based playground instead of an iOS-based playground, which we have been using so far in this book.</span></p>&#13;
<p><span class="s1">Create a new Swift playground as usual, but choose a <span class="packt_screen">Blank</span> template from the <span class="packt_screen">macOS</span> tab:</span></p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/a958f28d-123d-464f-9a57-0a9754f2b163.png" style="" width="1142" height="501"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 5.5 – Choosing a template</span></div>&#13;
<p>The RSS feed that we will retrieve and parse is from the front page of the BBC News website, which is <a href="http://feeds.bbci.co.uk/news/rss.xml">http://feeds.bbci.co.uk/news/rss.xml</a>.</p>&#13;
<p>Our first step is to retrieve the data at this URL <span class="s1">so that we can start making sense of it. Since we previously covered retrieving information over the network, I'll add the code without further comment; check out the <em>Fetching data with URLSession</em> recipe in this chapter for more information:</span></p>&#13;
<pre>import Foundation<br/>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true<br/><br/>func fetchBBCNewsRSSFeed() {<br/> <br/>    let session = URLSession.shared<br/>    let url = URL(string: "http://feeds.bbci.co.uk/news/rss.xml")!<br/>    let dataTask = session.dataTask(with: url) { (data, response, <br/>      error) in<br/> <br/>        guard let data = data, error == nil else {<br/>            print(error ?? "Unexpected response")<br/>            return<br/>        }<br/> <br/>        let dataAsString = String(data: data, encoding: .utf8)!<br/>        print(dataAsString)<br/>    }<br/>    dataTask.resume()<br/>}<br/><br/>fetchBBCNewsRSSFeed()</pre>&#13;
<p>When you run the playground, you will get an output that looks like the following<span class="s1">:</span></p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;?xml-stylesheet title="XSL_formatting" type="text/xsl" href="/shared/bsp/xsl/rss/nolsol.xsl"?&gt;<br/>&lt;rss    version="2.0" &gt;<br/>  &lt;channel&gt;<br/>    &lt;title&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/title&gt;;<br/>    &lt;description&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/description&gt;<br/>    &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>    &lt;image&gt;<br/> &lt;url&gt;https://news.bbcimg.co.uk/nol/shared/img/bbc_news_120x60.gif&lt;/url&gt;<br/> &lt;title&gt;BBC News - Home&lt;/title&gt;<br/> &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>  &lt;/image&gt;<br/>    &lt;generator&gt;RSS for Node&lt;/generator&gt;<br/>    &lt;lastBuildDate&gt;Sat, 15 Aug 2020 00:41:41 GMT&lt;/lastBuildDate&gt;<br/>   &lt;copyright&gt;&lt;![CDATA[Copyright: (C) British Broadcasting <br/>       Corporation, see http://news.bbc.co.uk/2/hi/help/rss/4498287.stm <br/>         for terms and conditions of reuse.]]&gt;&lt;/copyright&gt;<br/>    &lt;language&gt;&lt;![CDATA[en-gb]]&gt;&lt;/language&gt;<br/>    &lt;ttl&gt;15&lt;/ttl&gt;<br/>    &lt;item&gt;<br/>      &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat <br/>         France quarantine]]&gt;&lt;/title&gt;<br/>      &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to return to <br/>         the UK to avoid the 14-day self-isolation requirement.]]&gt;<br/>     &lt;/description&gt;<br/>      &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>      &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>         53782019&lt;/guid&gt;<br/>      &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>    &lt;/item&gt;<br/>    //... More items<br/>  &lt;/channel&gt;<br/>&lt;/rss&gt;</pre>&#13;
<h2 id="uuid-ac610b8f-bb93-4c8a-92f7-1f104f5a3d7f" class="p1">How to do it...</h2>&#13;
<p class="p1"><span class="s1">The overall structure should be familiar to anyone who has seen HTML. Apart from the first two lines, which define the version and formatting of the XML, the information is structured with opening and closing</span> tags. Consider the following example:</p>&#13;
<pre>&lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;</pre>&#13;
<p class="p1"><span class="s1">The name of the opening tag defines the content of this element of XML; in this case, it is a link. Then follows the content of the element, and the end of the content is defined by a closing tag that has a <kbd>/</kbd> character before its name.</span></p>&#13;
<p class="p1"><span class="s1">In addition to this simple example, an XML element can have attributes that describe extra information about the content of the element:</span></p>&#13;
<pre>&lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/guid&gt;</pre>&#13;
<p class="p1"><span class="s1">These are defined as key-value pairs within the opening tag.</span></p>&#13;
<p class="p1"><span class="s1">The content of the XML element may be a string, as in the preceding examples, or it can be nested child XML elements:</span></p>&#13;
<pre>&lt;image&gt;<br/>    &lt;url&gt;http://news.bbcimg.co.uk/nol/shared/img/bbc_news_120x60.gif&lt;/url&gt;<br/>    &lt;title&gt;BBC News - Home&lt;/title&gt;<br/>    &lt;link&gt;http://www.bbc.co.uk/news/&lt;/link&gt;<br/>&lt;/image&gt;</pre>&#13;
<p class="p1"><span class="s1">Lastly, the content of an XML element can be data. This data might be represented as a string, especially if the string is likely to be longer, and may include line breaks, special characters, and other components that may be confused for being part of the enclosing XML formatting:</span></p>&#13;
<pre>&lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat France <br/>   quarantine]]&gt;&lt;/title&gt;</pre>&#13;
<p class="p1"><span class="s1">Now that we have retrieved the XML, we want to parse it into something useful. The parser we will be using is provided by the Foundation framework and is available on iOS and macOS. It is called <kbd>XMLParser</kbd>. <kbd>XMLParser</kbd> is a <strong>SAX</strong> parser, which stands for <strong>Simple API for XML</strong>. The features of a SAX parser are as follows:</span></p>&#13;
<ul>&#13;
<li class="p1"><span class="s1">Event-driven</span></li>&#13;
<li class="p1"><span class="s1">Low memory overhead</span></li>&#13;
<li class="p1"><span class="s1">Only retains relevant information</span></li>&#13;
<li class="p1"><span class="s1">One pass</span></li>&#13;
</ul>&#13;
<p class="p1"><span class="s1">The parser takes a delegate object that it will deliver event information to as it parses the document. It is the delegate object's responsibility to take and retain the relevant information from these delegate callbacks as the XML data is parsed, as the parser will not retain the parsed data.</span></p>&#13;
<p>We will step through a simple example to see how the parser reports events to the <span class="s1">delegate. Here's the simple XML that we intend to parse:</span></p>&#13;
<pre>&lt;xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<p class="p1"><span class="s1">The parser will start parsing the XML, character by character, and as an event is triggered, the delegate will be informed:</span></p>&#13;
<ol>&#13;
<li class="p1"><span class="s1">The first event will be the start of the document, where the parser will call this:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><span class="s4">func</span><span class="s1"> parserDidStartDocument(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">)</span></pre>&#13;
<p style="padding-left: 60px">Here, we can do any setup or resetting of the state that is required<span class="s1">.</span></p>&#13;
<ol start="2">&#13;
<li>Then, the parser will move through the document until it reaches this point:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<br/><span class="s1"><strong>** Parser is here **</strong><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="3">&#13;
<li>The parser has finished parsing the opening tag for the first element and so it fires the <span class="s1">delegate callback:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didStartElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?,<br/>            attributes attributeDict: [String : String] = [:]) {<br/>    /*<br/>    elementName = quotes<br/>    namespaceURI = nil<br/>    qName = nil<br/>    attributeDict = [:]<br/>    */<br/>}</pre>&#13;
<ol start="4">&#13;
<li>The parser then continues until it reaches this poi<span>nt:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"&gt;<br/>&lt;quotes&gt;<span class="s1"><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/><strong>** Parser is here **</strong><br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="5">&#13;
<li>Since the parser has seen another starting tag<span class="s1">, it fires the same delegate callback with information about this new element:</span></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didStartElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?,<br/>            attributes attributeDict: [String : String] = [:]) {<br/>    /*<br/>    elementName = quote<br/>    namespaceURI = nil<br/>    qName = nil<br/>    attributeDict = ["attribution": "Homer Simpson"]<br/>    */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">This time, as the element has attribute information, it is provided by the delegate callback in the <kbd>attributeDict</kbd> dictionary.</span></p>&#13;
<ol start="6">&#13;
<li>The parser now moves through the content of the first <kbd>quote</kbd> element. At some point, it fires the delegate callback with the content it has collected up to that point:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<span class="s1"><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, <strong>** Parser is here **</strong>where's the <br/>          any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>           OCT31=DEC25<br/>   &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<p style="padding-left: 60px" class="p1">It then provides this content collected so far to the delegate:</p>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser, foundCharacters string: String) {<br/>    /*<br/>    string = "Press any key to continue, "<br/>    */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">The reason the parser stops halfway through the content to fire the delegate callback is to make the most efficient use of memory. All the data that the parser processes must be kept in memory by the parser until it can be delivered to the delegate. Therefore, if the parser determines that memory usage is getting high, it will take the content it has collected so far and deliver it to the delegate. Once it has done this, it can free up the memory and start collecting further content afresh.</span></p>&#13;
<p style="padding-left: 60px" class="p1"><span class="s1">In this simple example, it is very unlikely that the parser will not provide all the content of the element in one delegate callback. It is, however, useful to see an example of this, as we have to account for the possibility, and it will affect how we implement the delegate later.</span></p>&#13;
<ol start="7">&#13;
<li>The parser will fire the same <kbd>foundCharacters</kbd> delegate callback until all of the content of an element has been delivered to the delegate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<span class="s1"><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/><strong>           ** Parser is here **</strong><br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="8">&#13;
<li class="p1">It then provides the new content since the last call to the delegate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser, foundCharacters string: String) {<br/>    /*<br/>    string = "<span>where's the any key?</span>"<br/>    */<br/>}</pre>&#13;
<ol start="9">&#13;
<li class="p5">The parser now processes the closing tag for the first <kbd>quote</kbd> element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<span class="s1"><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/><strong>** Parser is here **</strong><br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;</pre>&#13;
<ol start="10">&#13;
<li class="p1">Then, it fires the delegate callback, signaling the end of the element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/> didEndElement elementName: String,<br/> namespaceURI: String?,<br/> qualifiedName qName: String?) {<br/> /*<br/> elementName = "quote"<br/> namespaceURI = nil<br/> qName = nil<br/> */<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The parser will then continue to process the next <kbd>quote</kbd> element in the same way, firing the same sequence of <kbd>didStartElement</kbd>, followed by a number of <kbd>foundCharacters</kbd> callbacks, and finishing with a call to <kbd>didEndElement</kbd>.</p>&#13;
<ol start="11">&#13;
<li>Having finished processing the last <kbd>quote</kbd> element, the parser will process the closing tag of the <kbd>quotes</kbd> element:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;quotes&gt;<span class="s1"><br/></span>    &lt;quote attribution="Homer Simpson"&gt;<br/>        Press any key to continue, where's the any key?<br/>    &lt;/quote&gt;<br/>    &lt;quote attribution="Unknown"&gt;<br/>        Why do nerds confuse Halloween and Christmas? Because <br/>          OCT31=DEC25<br/>    &lt;/quote&gt;<br/>&lt;/quotes&gt;<br/><strong>** Parser is here **</strong></pre>&#13;
<p style="padding-left: 60px" class="p1">It will fire another <kbd>didEndElement</kbd> callback for the <kbd>quotes</kbd> element:</p>&#13;
<pre style="padding-left: 60px">func parser(_ parser: XMLParser,<br/>            didEndElement elementName: String,<br/>            namespaceURI: String?,<br/>            qualifiedName qName: String?) {<br/>    /*<br/>    elementName = "quotes"<br/>    namespaceURI = nil<br/>    qName = nil<br/>    */<br/>}</pre>&#13;
<ol start="12">&#13;
<li>Finally, the parser will fire a delegate callback to indicate that the parsing of the document is complete:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func parserDidEndDocument(_ parser: XMLParser) {<br/> <br/>}</pre>&#13;
<p><span class="s1">Now that you understand how the parser passes information to the delegate, we can return to our RSS example.</span></p>&#13;
<h2 id="uuid-9092063e-2113-4cb9-8146-4fb6100b4711" class="p1"><span class="s1">How it works...<br/></span></h2>&#13;
<p class="p1"><span class="s1">You will remember that we retrieved XML data that looks like this:</span></p>&#13;
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;?xml-stylesheet title="XSL_formatting" type="text/xsl" href="/shared/bsp/xsl/rss/nolsol.xsl"?&gt;<br/>&lt;rss    version="2.0" &gt;<br/>    &lt;channel&gt;<br/>        &lt;title&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/title&gt;<br/>        &lt;description&gt;&lt;![CDATA[BBC News - Home]]&gt;&lt;/description&gt;<br/>        &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>        &lt;image&gt;<br/>            &lt;url&gt;https://news.bbcimg.co.uk/nol/shared/img/<br/>               bbc_news_120x60.gif&lt;/url&gt;<br/>            &lt;title&gt;BBC News - Home&lt;/title&gt;<br/>            &lt;link&gt;https://www.bbc.co.uk/news/&lt;/link&gt;<br/>        &lt;/image&gt;<br/>        &lt;generator&gt;RSS for Node&lt;/generator&gt;<br/>        &lt;lastBuildDate&gt;Sat, 15 Aug 2020 00:41:41 GMT&lt;/lastBuildDate&gt;<br/>        &lt;copyright&gt;&lt;![CDATA[Copyright: (C) British Broadcasting <br/>          Corporation, see http://news.bbc.co.uk/2/hi/help/rss/<br/>           4498287.stm for terms and conditions of reuse.]]&gt;<br/>            &lt;/copyright&gt;<br/>        &lt;language&gt;&lt;![CDATA[en-gb]]&gt;&lt;/language&gt;<br/>        &lt;ttl&gt;15&lt;/ttl&gt;<br/>        &lt;item&gt;<br/>            &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat <br/>               France quarantine]]&gt;&lt;/title&gt;<br/>            &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to <br/>                return to the UK to avoid the 14-day self-isolation <br/>                   requirement.]]&gt;&lt;/description&gt;<br/>            &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>            &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>               53782019&lt;/guid&gt;<br/>            &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>        &lt;/item&gt;<br/>        //... More items<br/>    &lt;/channel&gt;<br/>&lt;/rss&gt;<br/><br/></pre>&#13;
<p><span class="s1">From this, we want to extract the news articles in a usable form, so let's define a <kbd>NewsArticle</kbd> model containing some useful information and place it near the top of the playground:</span></p>&#13;
<pre>struct NewsArticle {<br/>    let title: String<br/>    let url: URL<br/>}</pre>&#13;
<p class="p1"><span class="s1">Since the information we require will be spread over multiple delegate callbacks, our delegate will need to keep track of the information it has received, so it can be pieced together at the appropriate time.</span></p>&#13;
<p>Let's create a class object to be the delegate for the parser <span class="s1">and have it conform to <kbd>XMLParserDelegate</kbd>:</span></p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/> <br/>}</pre>&#13;
<p>In the preceding XML, each news article is contained in an <span class="s1"><kbd>item</kbd> element, so our delegate will need to keep track of when the parser is delivering content for the <kbd>item</kbd> element so that it can ignore content from other elements:</span></p>&#13;
<pre>class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/> <br/>    var inItem = false<br/> <br/>    func parser(_ parser: XMLParser,<br/>                didStartElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?,<br/>                attributes attributeDict: [String : String] = [:]) {<br/> <br/>        switch elementName {<br/> <br/>        case "item":<br/>            inItem = true<br/> <br/>        default:<br/>            break<br/> <br/>        }<br/>    }<br/> <br/>    func parser(_ parser: XMLParser,<br/>                didEndElement elementName: String,<br/>                namespaceURI: String?,<br/>                qualifiedName qName: String?) {<br/> <br/>        switch elementName {<br/> <br/>        case "item":<br/>            inItem = false<br/> <br/>        default:<br/>            break<br/>        }<br/>    }<br/>}</pre>&#13;
<p>The two parts we want to extract from the <span class="s1"><kbd>item</kbd> element to create our <kbd>NewsArticle</kbd> are the title and the URL. As we can see from the XML, the title is contained in a <kbd>CDATA</kbd> wrapper within a <kbd>title</kbd> element, and the URL is within a <kbd>link</kbd> element:</span></p>&#13;
<pre>&lt;item&gt;<br/>  &lt;title&gt;&lt;![CDATA[Coronavirus: Thousands return to UK to beat France <br/>     quarantine]]&gt;&lt;/title&gt;<br/>  &lt;description&gt;&lt;![CDATA[Holidaymakers have just hours to return to the <br/>      UK to avoid the 14-day self-isolation requirement.]]&gt;<br/>       &lt;/description&gt;<br/>  &lt;link&gt;https://www.bbc.co.uk/news/uk-53782019&lt;/link&gt;<br/>  &lt;guid isPermaLink="true"&gt;https://www.bbc.co.uk/news/uk-<br/>     53782019&lt;/guid&gt;<br/>  &lt;pubDate&gt;Fri, 14 Aug 2020 21:21:54 GMT&lt;/pubDate&gt;<br/>&lt;/item&gt;</pre>&#13;
<p class="p1"><span class="s1">We will, therefore, also need to keep track of when the parser is in the <kbd>link</kbd> element, and while it is within the link element, append the received content to a <kbd>String</kbd> property. Similarly, we need to keep track of when the parser is in the <kbd>title</kbd> element, and when it is, append the received content to a <kbd>Data</kbd> property.</span></p>&#13;
<p>Let's add the extra properties we need to our <kbd>RSSNewsArticleBuilder</kbd> object:</p>&#13;
<pre><span class="s4">class</span><span class="s1"> RSSNewsArticleBui</span><span class="s1">lder: </span><span class="s6">N</span><span class="s6">SObject</span><span class="s1">, </span><span class="s6">XMLParserDelegate</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inItem = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inTitle = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inLink = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> titleData: </span><span class="s6">Data</span><span class="s1">?<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> linkString: </span><span class="s6">String</span><span class="s1">?<br/><br/>    //...<br/>}</span></pre>&#13;
<p>In the <kbd>didStartElement</kbd> method, we can check for these new element names we need to track. <span class="s1">We must also remember to reset the link and title properties as we start the relevant element. This way, we don't continue to append content meant for the next item element onto content from the previous one:</span></p>&#13;
<pre><span class="s4">func</span><span class="s1"> parser(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">            </span>didStartElement elementName: </span><span class="s6">String</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">            </span>namespaceURI: </span><span class="s6">String</span><span class="s1">?,<br/></span><span class="s1"><span class="Apple-converted-space">            </span>qualifiedName qName: </span><span class="s6">String</span><span class="s1">?,<br/></span><span class="s1"><span class="Apple-converted-space">            </span>attributes attributeDict: [</span><span class="s6">String</span><span class="s1"> : </span><span class="s6">String</span><span class="s1">] = [:]) {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">switch</span><span class="s1"> elementName {<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"item"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s9">inItem</span><span class="s1"> = </span><span class="s4">true<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"title"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s9">inTitle</span><span class="s1"> = </span><span class="s4">true<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s9">titleData</span><span class="s1"> = </span><span class="s6">Data</span><span class="s1">()<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"link"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s9">inLink</span><span class="s1"> = </span><span class="s4">true<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s9">linkString</span><span class="s1"> = </span><span class="s8">""<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">default</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">break<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p>Now that we know when we are in the right elements, we can implement two of the <kbd>XMLParserDelegate</kbd> methods to receive the relevant content and store it:</p>&#13;
<pre><span class="s4">class RSSNewsArticleBuilder: NSObject, XMLParserDelegate {<br/><br/>    //...<br/>    func</span><span class="s1"> parser(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">, foundCDATA CDATABlock: </span><span class="s6">Data</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">if</span><span class="s1"> </span><span class="s9">inTitle</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">titleData</span><span class="s1">?.</span><span class="s7">append</span><span class="s1">(CDATABlock)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">func</span><span class="s1"> parser(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">, foundCharacters string: </span><span class="s6">String</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">if</span><span class="s1"> </span><span class="s9">inLink</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">linkString</span><span class="s1">?.</span><span class="s7">append</span><span class="s1">(string)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/>}</span></pre>&#13;
<p>In the <kbd>didEndElement</kbd> method, we need to update our new properties and we can print out the values we have retrieved from the XML:</p>&#13;
<pre><span class="s4">class</span><span class="s1"> RSSNewsArticleBuilder: </span><span class="s6">N</span><span class="s6">SObject</span><span class="s1">, </span><span class="s6">XMLParserDelegate</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    //...</span></span><span class="s1"><span class="Apple-converted-space"><br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">func</span><span class="s1"> parser(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>didEndElement elementName: </span><span class="s6">String</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>namespaceURI: </span><span class="s6">String</span><span class="s1">?,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>qualifiedName qName: </span><span class="s6">String</span><span class="s1">?) {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">switch</span><span class="s1"> elementName {<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"item"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inItem</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">guard<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s4">let</span><span class="s1"> titleData = </span><span class="s9">titleData</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s1">let titleString = </span><span class="s6">String</span><span class="s1">(</span><span class="s1">data: titleData, encoding: <br/>                  .</span><span class="s6">utf8</span><span class="s1">),<br/></span><span class="s1"><span class="Apple-converted-space">                </span>let linkString = </span><span class="s9">linkString</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>let link = </span><span class="s6">URL</span><span class="s1">(string: linkString)<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s4">else</span><span class="s1"> { </span><span class="s4">break</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s7">print</span><span class="s1">(titleString)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s7">print</span><span class="s1">(link)<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"title"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inTitle</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"link"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inLink</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">default</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">break<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">    //...<br/></span><span class="s1">}</span></pre>&#13;
<p>Now that we have extracted the title and URL of the news article<span class="s1">, we can use this to create a <kbd>NewsArticle</kbd> model object. First, </span>let's create an array to hold the <kbd>NewsArticle</kbd> objects we will be creating:</p>&#13;
<pre><span class="s4">class</span><span class="s1"> RSSNewsArticleB</span><span class="s1">uilder: </span><span class="s6">NSObject</span><span class="s1">, </span><span class="s6">XMLParserDelegate</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inItem = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inTitle = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> inLink = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> titleData: </span><span class="s6">Data</span><span class="s1">?<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> linkString: </span><span class="s6">String</span><span class="s1">?<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">var</span><span class="s1"> articles = [</span><span class="s9">NewsArticle</span><span class="s1">]()<br/>    <br/>    //...<br/>}</span></pre>&#13;
<p><span>We can create the <kbd>NewsArticle</kbd> object at the end of the </span><kbd>item</kbd><span> element as this is when we will have all the relevant content:</span></p>&#13;
<pre><span class="s4">class</span><span class="s1"> RSSNewsArticleB</span><span class="s1">uilder: </span><span class="s6">NSObject</span><span class="s1">, </span><span class="s6">XMLParserDelegate</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    //...</span></span><span class="s1"><span class="Apple-converted-space"><br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">func</span><span class="s1"> parser(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>didEndElement elementName: </span><span class="s6">String</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>namespaceURI: </span><span class="s6">String</span><span class="s1">?,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>qualifiedName qName: </span><span class="s6">String</span><span class="s1">?) {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">switch</span><span class="s1"> elementName {<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"item"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inItem</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">guard<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s4">let</span><span class="s1"> titleData = </span><span class="s9">titleData</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>let titleString = </span><span class="s6">String</span><span class="s1">(data: titleData, encoding: <br/>                  .</span><span class="s6">utf8</span><span class="s1">),<br/></span><span class="s1"><span class="Apple-converted-space">                </span>let linkString = </span><span class="s9">linkString</span><span class="s1">,<br/></span><span class="s1"><span class="Apple-converted-space">                </span>let link = </span><span class="s6">URL</span><span class="s1">(string: linkString)<br/></span><span class="s1"><span class="Apple-converted-space">                </span></span><span class="s4">else</span><span class="s1"> { </span><span class="s4">break</span><span class="s1"> }<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">let</span><span class="s1"> article = </span><span class="s9">NewsArticle</span><span class="s1">(title: titleString, url: link)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">articles</span><span class="s1">.</span><span class="s7">append</span><span class="s1">(article)<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"title"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inTitle</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">case</span><span class="s1"> </span><span class="s8">"link"</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s9">inLink</span><span class="s1"> = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">            <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">default</span><span class="s1">:<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">break<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    //...</span></span><span class="s1"><br/></span><span class="s1">}</span></pre>&#13;
<p>Lastly, when the document starts, we should ensure that all the properties are reset:</p>&#13;
<pre><span class="s4">class</span><span class="s1"> RSSNewsArticleBuilder: </span><span class="s6">NSObject</span><span class="s1">, </span><span class="s6">XMLParserDelegate</span><span class="s1"> {<br/></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">//...<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">func</span><span class="s1"> parserDidStartDocument(</span><span class="s4">_</span><span class="s1"> parser: </span><span class="s6">XMLParser</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>inItem = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">        </span>inTitle = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">        </span>inLink = </span><span class="s4">false<br/></span><span class="s1"><span class="Apple-converted-space">        </span>titleData = </span><span class="s4">nil<br/></span><span class="s1"><span class="Apple-converted-space">        </span>linkString = </span><span class="s4">nil<br/></span><span class="s1"><span class="Apple-converted-space">        </span>articles = [</span><span class="s9">NewsArticle</span><span class="s1">]()<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">//...<br/></span><span class="s1">}</span></pre>&#13;
<p>Now that we have completed the parser delegate<span class="s1">, let's go back to our <kbd>fetchBBCNewsRSSFeed</kbd> function:</span></p>&#13;
<pre><span class="s4">func</span><span class="s1"> fetchBBCNewsRSSFeed() {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> session = </span><span class="s6">URLSession</span><span class="s1">.</span><span class="s6">shared<br/></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s5"> url = </span><span class="s6">URL</span><span class="s5">(string: </span><span class="s1">"http://feeds.bbci.co.uk/news/rss.xml"</span><span class="s5">)!<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> dataTask = session.</span><span class="s7">dataTask</span><span class="s1">(with: url) { (data, response, <br/>      error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> data = data, error == </span><span class="s4">nil</span><span class="s1"> </span><span class="s4">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s7">print</span><span class="s1">(error ?? </span><span class="s8">"Unexpected response"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">return<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> dataAsString = </span><span class="s6">String</span><span class="s1">(data: data, encoding: .</span><span class="s6">utf8</span><span class="s1">)!<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s7">print</span><span class="s1">(dataAsString)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>dataTask.</span><span class="s7">resume</span><span class="s1">()<br/></span><span class="s1">}</span></pre>&#13;
<p>Once the XML data has been retrieved, we'll pass it to <span class="s1"><kbd>XMLParser</kbd>, set up the delegate, and tell the parser to parse the data:</span></p>&#13;
<pre><span class="s4">func</span><span class="s1"> fetchBBCNewsRSSFeed() {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> session = </span><span class="s6">URLSession</span><span class="s1">.</span><span class="s6">shared<br/></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s5"> url = </span><span class="s6">URL</span><span class="s5">(string: </span><span class="s1">"http://feeds.bbci.co.uk/news/rss.xml"</span><span class="s5">)!<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> dataTask = session.</span><span class="s7">dataTask</span><span class="s1">(with: url) { (data, response,<br/>      error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> data = data, error == </span><span class="s4">nil</span><span class="s1"> </span><span class="s4">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s7">print</span><span class="s1">(error ?? </span><span class="s8">"Unexpected response"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">return<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> parser = </span><span class="s6">XMLParser</span><span class="s1">(data: data)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articleBuilder = </span><span class="s9">RSSNewsArticleBuilder</span><span class="s1">()<br/></span><span class="s1"><span class="Apple-converted-space">        </span>parser.</span><span class="s6">delegate</span><span class="s1"> = articleBuilder<br/></span><span class="s1"><span class="Apple-converted-space">        </span>parser.</span><span class="s7">parse</span><span class="s1">()<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articles = articleBuilder.articles<br/></span><span class="s1"><span class="Apple-converted-space">        </span>print(articles)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>dataTask.</span><span class="s7">resume</span><span class="s1">()<br/></span><span class="s1">}</span></pre>&#13;
<p>We want to provide the articles as an output from this function<span class="s1">, so we can add a completion handler to provide an array of news articles or an error:</span></p>&#13;
<pre><span class="s4">func</span><span class="s1"> fetchBBCNewsRSSFeed(completion: </span><span class="s4">@escaping</span><span class="s1"> ([</span><span class="s9">NewsArticle</span><span class="s1">]?, </span><span class="s6">Error</span><span class="s1">?)<br/>  -&gt; </span><span class="s6">Void</span><span class="s1">) {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> session = </span><span class="s6">URLSession</span><span class="s1">.</span><span class="s6">shared<br/></span><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s5"> url = </span><span class="s6">URL</span><span class="s5">(string: </span><span class="s1">"http://feeds.bbci.co.uk/news/rss.xml"</span><span class="s5">)!<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> dataTask = session.</span><span class="s7">dataTask</span><span class="s1">(with: url) { (data, response, <br/>      error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">guard</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> data = data, error == </span><span class="s4">nil</span><span class="s1"> </span><span class="s4">else</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">            </span>completion(</span><span class="s4">nil</span><span class="s1">, error)<br/></span><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s4">return<br/></span><span class="s1"><span class="Apple-converted-space">        </span>}<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> parser = </span><span class="s6">XMLParser</span><span class="s1">(data: data)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articleBuilder = </span><span class="s9">RSSNewsArticleBuilder</span><span class="s1">()<br/></span><span class="s1"><span class="Apple-converted-space">        </span>parser.</span><span class="s6">delegate</span><span class="s1"> = articleBuilder<br/></span><span class="s1"><span class="Apple-converted-space">        </span>parser.</span><span class="s7">parse</span><span class="s1">()<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articles = articleBuilder.articles<br/></span><span class="s1"><span class="Apple-converted-space">        </span>completion(articles, </span><span class="s4">nil</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span>dataTask.</span><span class="s7">resume</span><span class="s1">()<br/></span><span class="s1">}</span></pre>&#13;
<p>Finally, we can call this function, which will retrieve the RSS feed, parse it, and return an array of news articles:</p>&#13;
<pre><span class="s10">fetchBBCNewsRSSFeed</span><span class="s1">() { (articles, error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> articles = articles {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s7">print</span><span class="s1">(articles)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>} </span><span class="s4">else</span><span class="s1"> </span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> error = error {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s7">print</span><span class="s1">(error)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<h2 id="uuid-a1e4c304-67af-42b3-abbc-74357701c393" class="p1">There's more...</h2>&#13;
<p class="p1"><span class="s1">Foundation also provides the ability to write XML data, although currently, this functionality is only available on macOS.</span></p>&#13;
<p class="p1"><span class="s1">Having retrieved the RSS feed and created our news articles, let's write this information to an XML data structure and save it to disk. This XML will take the following form:</span></p>&#13;
<pre><span class="s1">&lt;articles&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;article&gt;<br/></span><span class="s1"><span class="Apple-converted-space">        </span>&lt;title&gt;Donald Trump calls Fidel Castro 'brutal dictator'<br/>          &lt;/title&gt;<br/></span><span class="s2"><span class="Apple-converted-space">        </span>&lt;url&gt;<span class="s3">http://www.bbc.co.uk/news/world-latin-america-<br/>           38118739</span>&lt;/url&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;/article&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;article&gt;<br/></span><span class="s1"><span class="Apple-converted-space">        </span>&lt;title&gt;Fidel Castro: Jeremy Corbyn praises 'huge figure'<br/>           &lt;/title&gt;<br/></span><span class="s2"><span class="Apple-converted-space">        </span>&lt;url&gt;<span class="s3">http://www.bbc.co.uk/news/uk-38117068</span>&lt;/url&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;/article&gt;<br/></span><span class="s1">&lt;/articles&gt;</span></pre>&#13;
<p class="p1"><span class="s1">At the root of the XML structure is an <kbd>articles</kbd> element, which contains multiple <kbd>article</kbd> elements, which in turn contain a <kbd>title</kbd> element and a <kbd>url</kbd> element.</span></p>&#13;
<p class="p1"><span class="s1">To write the XML data, we will recreate the preceding structure using the <kbd>XMLDocument</kbd> and <kbd>XMLElement</kbd> objects. Once constructed, the <kbd>xmlData</kbd> property of the <kbd>XMLDocument</kbd> object provides the document as data.</span></p>&#13;
<p class="p1"><span class="s1">Let's create a function to produce XML data from an array of <kbd>NewsArticle</kbd></span>:</p>&#13;
<pre><span class="s4">func</span><span class="s1"> createXML(representing articles: [</span><span class="s5">NewsArticle</span><span class="s1">]) -&gt; </span><span class="s5">Data</span><span class="s1"> {<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> root = </span><span class="s5">XMLElement</span><span class="s1">(name: </span><span class="s6">"articles"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">let</span><span class="s1"> document = </span><span class="s5">XMLDocument</span><span class="s1">(rootElement: root)<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">for</span><span class="s1"> article </span><span class="s4">in</span><span class="s1"> articles {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articleElement = XMLElement(name: </span><span class="s6">"article"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> titleElement = XMLElement(name: </span><span class="s6">"title"</span><span class="s1">, <br/>                                      stringValue: article.title)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> urlElement = XMLElement(name: </span><span class="s6">"url"</span><span class="s1">, <br/>                         stringValue: article.url.absoluteString)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span>articleElement.addChild(titleElement)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>articleElement.addChild(urlElement)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>root.addChild(articleElement)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s7">print</span><span class="s1">(document.</span><span class="s5">xmlString</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">return</span><span class="s1"> document.xmlData<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">We create each <kbd>XMLElement</kbd> and add it as a child to the element that we want to nest it within.</span></p>&#13;
<p class="p1"><span class="s1">If you are building this in a storyboard, ensure that you place this function after <kbd>RSSNewsArticleBuilder</kbd>, and before the code that calls <kbd>fetchBBCNewsRSSFeed</kbd>, as this function will need to be available to the completion handler <span>soon</span>.</span></p>&#13;
<p class="p1"><span class="s1">Our call to <kbd>fetchBBCNewsRSSFeed</kbd> will provide an array of <kbd>NewsArticle</kbd>, so we can pass this to our new function to write this information to XML data:</span></p>&#13;
<pre><span class="s1">fetchBBCNewsRSSFeed() { (articles, error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> articles = articles {<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> articleXMLData = createXML(representing: articles)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>print(articleXMLData.length)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>} </span><span class="s4">else</span><span class="s1"> </span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> error = error {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>print(error)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">Now that we have the data, we can obtain a URL for the <kbd>documents</kbd> directory, append the name of the file we will create, and write it to disk:</span></p>&#13;
<pre><span class="s1">fetchBBCNewsRSSFeed() { (articles, error) </span><span class="s4">in<br/></span><span class="s1"><span class="Apple-converted-space">    <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> articles = articles {<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s1"><br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> xmlData = createXML(representing: articles)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> documentsURL = FileManager.</span><span class="s4">default</span><span class="s1">.urls(for: <br/>          .documentDirectory, in: .userDomainMask).first!<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">let</span><span class="s1"> writeURL = documentsURL.appendingPathComponent(<br/></span><span class="s6">          "articles.xml"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">        </span>print(</span><span class="s6">"Writing data to: </span><span class="s1">\</span><span class="s6">(</span><span class="s1">writeURL</span><span class="s6">)"</span><span class="s1">)<br/></span><span class="s1"><span class="Apple-converted-space">        </span></span><span class="s4">try</span><span class="s1">! xmlData.write(to: writeURL)<br/></span><span class="s1"><span class="Apple-converted-space">        <br/></span></span><span class="s1"><span class="Apple-converted-space">    </span>} </span><span class="s4">else</span><span class="s1"> </span><span class="s4">if</span><span class="s1"> </span><span class="s4">let</span><span class="s1"> error = error {<br/></span><span class="s1"><span class="Apple-converted-space">        </span>print(error)<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1">}</span></pre>&#13;
<p class="p1"><span class="s1">We have now retrieved an RSS feed, extracted useful information from it, written that information to a custom XML format, and saved that data to disk. Give yourself a pat on the back!</span></p>&#13;
<h2 id="uuid-50c14aea-bbf5-4bc6-83f8-f00ddf89e774" class="p1"><span class="s1">See also</span></h2>&#13;
<p><span class="s1">Further information about <kbd>XMLParser</kbd> can be found in Apple's Foundation reference at</span> <a href="http://swiftbook.link/docs/xmlparser">http://swiftbook.link/docs/xmlparser</a>.</p>&#13;
<p><span class="s1">Other XML parsers are available, which may have advantages over Apple's, including being able to write XML on iOS. They are as follows:</span></p>&#13;
<ul>&#13;
<li><span class="s2"><span class="s3">RaptureXML: <a href="https://github.com/ZaBlanc/RaptureXML">https://github.com/ZaBlanc/RaptureXML</a></span></span></li>&#13;
<li>TBXML: <a href="https://github.com/71squared/TBXML">https://github.com/71squared/TBXML</a></li>&#13;
</ul>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>