["```swift\n[[[CCDirector sharedDirector] view] addSubview:tblScores];\n```", "```swift\n-(NSInteger)saveHighScore\n{\n  //save top 20 scores\n\n  //an array of Dictionaries...\n  //keys in each dictionary:\n  //  [DictTotalScore]\n  //  [DictTurnsSurvived]\n  //  [DictUnitsKilled]\n\n//read the array of high scores saved on the user's device\n  NSMutableArray *arrScores = [[[NSUserDefaults standardUserDefaults] arrayForKey:DataHighScores] mutableCopy];\n\n//sentinel value of -1 (in other words, if a high score was not found on this play through)\n  NSInteger index = -1;\n//loop through the scores in the array\n  for (NSDictionary *dictHighScore in arrScores)\n  {\n//if the current game's total score is greater than the score stored in the current index of the array...\n    if (numTotalScore > [dictHighScore[DictTotalScore] integerValue])\n    {\n//then store that index and break out of the loop\n      index = [arrScores indexOfObject:dictHighScore];\n      break;\n    }\n  }\n\n//if a new high score was found\n  if (index > -1)\n  {\n//create a dictionary to store the score, turns survived, and units killed\n    NSDictionary *newHighScore = @{ DictTotalScore : @(numTotalScore),\n    DictTurnsSurvived : @(numTurnSurvived),\n    DictUnitsKilled : @(numUnitsKilled) };\n\n//then insert that dictionary into the array of high scores\n    [arrScores insertObject:newHighScore atIndex:index];\n\n//remove the very last object in the high score list (in other words, limit the number of scores)\n    [arrScores removeLastObject];\n\n//then save the array\n    [[NSUserDefaults standardUserDefaults] setObject:arrScores forKey:DataHighScores];\n    [[NSUserDefaults standardUserDefaults] synchronize];\n  }\n\n//finally return the index of the high score (whether it's -1 or an actual value within the array)\n  return index;\n}\n```", "```swift\n-(void)endGame\n{\n  //call the method here to save the high score, then grab the index of the high score within the array\n  NSInteger hsIndex = [self saveHighScore];\n\n  NSDictionary *scoreData = @{ DictTotalScore : @(numTotalScore),\n  DictTurnsSurvived : @(numTurnSurvived),\n  DictUnitsKilled : @(numUnitsKilled),\n  DictHighScoreIndex : @(hsIndex)};\n\n  [[CCDirector sharedDirector] replaceScene:[GameOverScene sceneWithScoreData:scoreData]];\n\n}\n```", "```swift\n@interface GameOverScene : CCScene <CCTableViewDataSource>\n```", "```swift\n//get the high score array from the user's device\narrScores = [[NSUserDefaults standardUserDefaults] arrayForKey:DataHighScores];\n\n//create labels\nCCLabelBMFont *lblTableTotalScore = [CCLabelBMFont labelWithString:@\"Total Score:\" fntFile:@\"bmFont.fnt\"];\n\nCCLabelBMFont *lblTableUnitsKilled = [CCLabelBMFont labelWithString:@\"Units Killed:\" fntFile:@\"bmFont.fnt\"];\n\nCCLabelBMFont *lblTableTurnsSurvived = [CCLabelBMFont labelWithString:@\"Turns Survived:\" fntFile:@\"bmFont.fnt\"];\n\n//position the labels\nlblTableTotalScore.position = ccp(winSize.width * 0.5, winSize.height * 0.85);\nlblTableUnitsKilled.position = ccp(winSize.width * 0.675, winSize.height * 0.85);\nlblTableTurnsSurvived.position = ccp(winSize.width * 0.875, winSize.height * 0.85);\n\n//add the labels to the scene\n[self addChild:lblTableTurnsSurvived];\n[self addChild:lblTableTotalScore];\n[self addChild:lblTableUnitsKilled];\n\n//create the tableview and add it to the scene\nCCTableView * tblScores = [CCTableView node];\ntblScores.contentSize = CGSizeMake(0.6, 0.4);\nCGFloat ratioX = (1.0 - tblScores.contentSize.width) * 0.75;\nCGFloat ratioY = (1.0 - tblScores.contentSize.height) / 2;\ntblScores.position = ccp(winSize.width * ratioX, winSize.height * ratioY);\ntblScores.dataSource = self;\ntblScores.block = ^(CCTableView *table){\n    //if the press a cell, do something here.\n    //NSLog(@\"Cell %ld\", (long)table.selectedRow);\n};\n[self addChild: tblScores]; \n```", "```swift\n-(CCTableViewCell*)tableView:(CCTableView *)tableView nodeForRowAtIndex:(NSUInteger)index\n{\n  CCTableViewCell* cell = [CCTableViewCell node];\n\n  cell.contentSizeType = CCSizeTypeMake(CCSizeUnitNormalized, CCSizeUnitPoints);\n  cell.contentSize = CGSizeMake(1, 40);\n\n  // Color every other row differently\n  CCNodeColor* bg;\n  if (index % 2 != 0) bg = [CCNodeColor nodeWithColor:[CCColor colorWithRed:0 green:0 blue:0 alpha:0.3]];\n  else bg = [CCNodeColor nodeWithColor: [CCColor colorWithRed:0 green:0 blue:0 alpha:0.2]];\n\n  bg.userInteractionEnabled = NO;\n  bg.contentSizeType = CCSizeTypeNormalized;\n  bg.contentSize = CGSizeMake(1, 1);\n  [cell addChild:bg];\n  return cell;\n}\n\n-(NSUInteger)tableViewNumberOfRows:(CCTableView *)tableView\n{\n  return [arrScores count];\n}\n\n-(float)tableView:(CCTableView *)tableView heightForRowAtIndex:(NSUInteger)index\n{\n  return 40.f;\n}\n```", "```swift\n//Create the 4 labels that will be used within the cell (row). \nCCLabelBMFont *lblScoreNumber = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@\"%d)\", index+1] fntFile:@\"bmFont.fnt\"];\n//Set the anchor point to the middle-right (default middle-middle)\nlblScoreNumber.anchorPoint = ccp(1,0.5);\n\nCCLabelBMFont *lblTotalScore = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@\"%d\", [arrScores[index][DictTotalScore] integerValue]] fntFile:@\"bmFont.fnt\"];\n\nCCLabelBMFont *lblUnitsKilled = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@\"%d\", [arrScores[index][DictUnitsKilled] integerValue]] fntFile:@\"bmFont.fnt\"];\n\nCCLabelBMFont *lblTurnsSurvived = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@\"%d\", [arrScores[index][DictTurnsSurvived] integerValue]] fntFile:@\"bmFont.fnt\"];\n\n//set the position type of each label to normalized (where (0,0) is the bottom left of its parent and (1,1) is the top right of its parent)\nlblScoreNumber.positionType = lblTotalScore.positionType = lblUnitsKilled.positionType = lblTurnsSurvived.positionType = CCPositionTypeNormalized;\n\n//position all of the labels within the cell\nlblScoreNumber.position = ccp(0.15,0.5);\nlblTotalScore.position = ccp(0.35,0.5);\nlblUnitsKilled.position = ccp(0.6,0.5);\nlblTurnsSurvived.position = ccp(0.9,0.5);\n\n//if the index we're iterating through is the same index as our High Score index...\nif (index == highScoreIndex)\n{\n//then set the color of all the labels to a golden color\n    lblScoreNumber.color =\n    lblTotalScore.color =\n    lblUnitsKilled.color =\n    lblTurnsSurvived.color = [CCColor colorWithRed:1 green:183/255.f blue:0];\n}\n\n//add all of the labels to the individual cell\n[cell addChild:lblScoreNumber];\n[cell addChild:lblTurnsSurvived];\n[cell addChild:lblTotalScore];\n[cell addChild:lblUnitsKilled];\n```", "```swift\n@property (nonatomic, assign) CGPoint previousTouchPos;\n```", "```swift\nif (!self.isBeingDragged && ccpDistance(touchPos, self.touchDownPos) > 20)\n{\n  self.isBeingDragged = YES;\n  //add it here:\n  self.previousTouchPos = self.touchDownPos;\n```", "```swift\n//only if the unit is currently being dragged\nif (self.isBeingDragged)\n{\n    CGFloat dist = 0;\n    //if the direction the unit is being dragged is either UP or DOWN\n    if (self.dragDirection == DirUp || self.dragDirection == DirDown)\n    //then subtract the current touch position's Y-value from the previously-recorded Y-value to determine the distance to move\n      dist = touchPos.y - self.previousTouchPos.y;\n      //else if the direction the unit is being dragged is either LEFT or RIGHT\n    else if (self.dragDirection == DirLeft || \n        self.dragDirection == DirRight)\n        //then subtract the current touch position's Y-value from the previously-recorded Y-value to determine the distance to move\n      dist = touchPos.x - self.previousTouchPos.x; \n\n//then assign the touch position for the next iteration of touchMoved to work properly\nself.previousTouchPos = touchPos;\n\n}\n```", "```swift\ndist /= 2; //optional\n[self slideUnitWithDistance:dist withDragDirection:self.dragDirection];\n```", "```swift\n-(void)slideUnitWithDistance:(CGFloat)dist withDragDirection:(enum UnitDirection)dir\n{\n}\n```", "```swift\nCGFloat newX = self.position.x, newY = self.position.y;\n```", "```swift\nCGPoint originalPos = [MainScene getPositionForGridCoord:self.gridPos];\n```", "```swift\nif (self.dragDirection == DirUp)\n{\n    newY += dist;\n    if (newY > originalPos.y + self.gridWidth)\n      newY = originalPos.y + self.gridWidth;\n    else if (newY < originalPos.y)\n      newY = originalPos.y;\n}\n```", "```swift\nelse if (self.dragDirection == DirDown)\n{\n    newY += dist;\n    if (newY < originalPos.y - self.gridWidth)\n      newY = originalPos.y - self.gridWidth;\n    else if (newY > originalPos.y)\n      newY = originalPos.y;\n}\nelse if (self.dragDirection == DirLeft)\n{\n    newX += dist;\n    if (newX < originalPos.x - self.gridWidth)\n      newX = originalPos.x - self.gridWidth;\n    else if (newX > originalPos.x)\n      newX = originalPos.x;\n}\nelse if (self.dragDirection == DirRight)\n{\n    newX += dist;\n    if (newX > originalPos.x + self.gridWidth)\n      newX = originalPos.x + self.gridWidth;\n    else if (newX < originalPos.x)\n      newX = originalPos.x;\n}\n```", "```swift\nself.position = ccp(newX, newY);\n```", "```swift\nif (ccpDistance(touchPos, self.touchDownPos) > self.boundingBox.size.width/2)\n```", "```swift\nCGPoint oldSelfPos = [MainScene getPositionForGridCoord:self.gridPos];\n\nCGFloat dist = ccpDistance(oldSelfPos, self.position);\nif (dist > self.gridWidth/2)\n```", "```swift\n[(MainScene*)self.parent slideAllUnitsWithDistance:dist withDragDirection:self.dragDirection];\n//[self slideUnitWithDistance:dist withDragDirection:self.dragDirection];\n```", "```swift\n-(void)slideAllUnitsWithDistance:(CGFloat)dist withDragDirection:(enum UnitDirection)dir;\n```", "```swift\n-(void)slideAllUnitsWithDistance:(CGFloat)dist withDragDirection:(enum UnitDirection)dir\n{\n  for (Unit *u in arrFriendlies)\n    [u slideUnitWithDistance:dist withDragDirection:dir];\n\n  for (Unit *u in arrEnemies)\n    [u slideUnitWithDistance:dist withDragDirection:dir];\n}\n```", "```swift\n-(void)slideUnitWithDistance:(CGFloat)dist withDragDirection:(enum UnitDirection)dir;\n```", "```swift\n-(void)slideUnitWithDistance:(CGFloat)dist withDragDirection:(enum UnitDirection)dir\n{\n  CGFloat newX = self.position.x, newY = self.position.y;\n  CGPoint originalPos = [MainScene getPositionForGridCoord:self.gridPos];\n\nif (!self.isBeingDragged && \n\n(((self.direction == DirUp || self.direction == DirRight) && \n(dir == DirDown || dir == DirLeft)) ||\n\n((self.direction == DirDown || self.direction == DirLeft) && \n(dir == DirUp || dir == DirRight))))\n{\n    dist *= -1;\n}\n}\n```", "```swift\nif (self.dragDirection == DirUp || (!self.isBeingDragged && self.direction == DirUp))\n{}\nelse if (self.dragDirection == DirDown || (!self.isBeingDragged && self.direction == DirDown))\n{}\nelse if (self.dragDirection == DirLeft || (!self.isBeingDragged && self.direction == DirLeft))\n{}\nelse if (self.dragDirection == DirRight || (!self.isBeingDragged && self.direction == DirRight))\n{}\n```", "```swift\nCCNodeColor *unitBezier;\n```", "```swift\nunitBezier = [[CCNodeColor alloc] initWithColor:[CCColor colorWithRed:1 green:1 blue:0] width:50 height:50];\n[self addChild:unitBezier];\nCCNodeColor *shadow2 = [[CCNodeColor alloc] initWithColor:[CCColor blackColor] width:50 height:50];\nshadow2.anchorPoint = ccp(0.5,0.5);\nshadow2.position = ccp(26,24);\nshadow2.opacity = 0.5;\n[unitBezier addChild:shadow2 z:-1];\n```", "```swift\n-(void)sendFirstUnit\n{\n  unitRegular.position = ccp(0,0);\n\n  //Add these 2 lines\n  unitBezier.position = ccp(0,0);\n  [self scheduleOnce:@selector(sendSecondUnit) delay:2];\n\n  CCActionMoveTo *move1 = [CCActionMoveTo actionWithDuration:0.5 position:ccp(winSize.width/4, winSize.height * 0.75)];\n  CCActionMoveTo *move2 = [CCActionMoveTo actionWithDuration:0.5 position:ccp(winSize.width/2, winSize.height/4)];\n  CCActionMoveTo *move3 = [CCActionMoveTo actionWithDuration:0.5 position:ccp(winSize.width*3/4, winSize.height * 0.75)];\n  CCActionMoveTo *move4 = [CCActionMoveTo actionWithDuration:0.5 position:ccp(winSize.width - 50, 0)];\n\n  [unitRegular runAction:[CCActionSequence actions:move1, move2, move3, move4, nil]];\n}\n```", "```swift\n-(void)sendSecondUnit\n{\n  ccBezierConfig bezConfig1;\n  bezConfig1.controlPoint_1 = ccp(0, winSize.height);\n  bezConfig1.controlPoint_2 = ccp(winSize.width*3/8, winSize.height);\n  bezConfig1.endPosition = ccp(winSize.width*3/8, winSize.height/2);\n  CCActionBezierTo *bez1 = [CCActionBezierTo actionWithDuration:1.0 bezier:bezConfig1];\n\n  ccBezierConfig bezConfig2;\n  bezConfig2.controlPoint_1 = ccp(winSize.width*3/8, 0);\n  bezConfig2.controlPoint_2 = ccp(winSize.width*5/8, 0);\n  bezConfig2.endPosition = ccp(winSize.width*5/8, winSize.height/2);\n  CCActionBezierBy *bez2 = [CCActionBezierTo actionWithDuration:1.0 bezier:bezConfig2];\n\n  ccBezierConfig bezConfig3;\n  bezConfig3.controlPoint_1 = ccp(winSize.width*5/8, winSize.height);\n  bezConfig3.controlPoint_2 = ccp(winSize.width, winSize.height);\n  bezConfig3.endPosition = ccp(winSize.width - 50, 0);\n  CCActionBezierTo *bez3 = [CCActionBezierTo actionWithDuration:1.0 bezier:bezConfig3];\n\n  [unitBezier runAction:[CCActionSequence actions:bez1, bez2, \nbez3, nil]];\n}\n```", "```swift\n[unitBezier stopAllActions];\n```", "```swift\n#import <CoreMotion/CoreMotion.h>\n@interface MainScene : CCNode\n{\n  CGSize winSize;\n\n  //add these\n  CCParallaxNode *parallax;\n  CMMotionManager *motionManager;\n  CGFloat xFiltered, yFiltered ;yFiltered\n}\n```", "```swift\n//[self addChild:layout];\n\nparallax = [CCParallaxNode node];\n//Ratio: For every 1 pixel moved, move the child that amount\nparallax.position = ccp(winSize.width/2, winSize.height/2);\n[parallax addChild:layout z:0 parallaxRatio:ccp(1,1) positionOffset:ccp(0,0)];\n[self addChild:parallax];\n```", "```swift\n//60 times per second. In theory once per frame\nCGFloat interval = 1/60.f; \nmotionManager = [[CMMotionManager alloc] init];\nmotionManager.accelerometerUpdateInterval = interval;\n[motionManager startAccelerometerUpdates];\n[self schedule:@selector(getAccelerometerData:) interval:interval]; \n```", "```swift\n-(void)getAccelerometerData:(CCTime)delta\n{\n  CMAcceleration accel = motionManager.accelerometerData.acceleration;\n\n  CGFloat filterValue  = 0.8f;\n\n  xFiltered = filterValue * xFiltered + (1.0 - filterValue) * accel.x;\n  yFiltered = filterValue * yFiltered + (1.0 - filterValue) * accel.y;\n\n  parallax.position = ccp(winSize.width/2 + 50 * yFiltered, winSize.height/2 - 50 * xFiltered);\n}\n```", "```swift\nCGFloat avgXValue, avgYValue;\n```", "```swift\navgXValue = (avgXValue * 99 + xFiltered)/100.f;\navgYValue = (avgYValue * 99 + yFiltered)/100.f;\n\nparallax.position = ccp(winSize.width/2 + 50 * (yFiltered - avgYValue), winSize.height/2 - 50 * (xFiltered - avgXValue));\n```", "```swift\n#import \"GameScene.h\" \n```", "```swift\n[[CCDirector sharedDirector] replaceScene:[GameScene scene]];\n```", "```swift\n@interface GameScene : CCScene\n{\n  CGSize winSize;\n\n  //add this:\n  CCParallaxNode *parallax;\n}\n```", "```swift\nCCSprite *bg1 = [CCSprite spriteWithImageNamed:@\"mountains.png\"];\nCCSprite *bg2 = [CCSprite spriteWithImageNamed:@\"mountains.png\"];\n\nCCSprite *mg1 = [CCSprite spriteWithImageNamed:@\"midground.png\"];\nCCSprite *mg2 = [CCSprite spriteWithImageNamed:@\"midground.png\"];\n\nCCSprite *fg1 = [CCSprite spriteWithImageNamed:@\"foreground.png\"];\nCCSprite *fg2 = [CCSprite spriteWithImageNamed:@\"foreground.png\"];\nfg1.anchorPoint = fg2.anchorPoint = ccp(0.5,0);\n\nCCSprite *sun = [CCSprite spriteWithImageNamed:@\"sun.png\"];\n\nparallax = [CCParallaxNode node];\nparallax.anchorPoint = ccp(0,0);\nparallax.position = ccp(0,0);\n\n[parallax addChild:bg1 z:0 parallaxRatio:ccp(0.35,0) positionOffset:ccp(winSize.width/2, winSize.height/2)];\n\n[parallax addChild:bg2 z:0 parallaxRatio:ccp(0.35,0) positionOffset:ccp(winSize.width/2 + winSize.width - 2,winSize.height/2)];\n\n[parallax addChild:sun z:1 parallaxRatio:ccp(0.5,0) positionOffset:ccp(winSize.width, winSize.height * 0.8)];\n\n[parallax addChild:mg1 z:1 parallaxRatio:ccp(0.5,0) positionOffset:ccp(winSize.width/2, winSize.height/2)];\n[parallax addChild:mg2 z:1 parallaxRatio:ccp(0.5,0) positionOffset:ccp(winSize.width/2 + winSize.width, winSize.height/2)];\n\n[parallax addChild:fg1 z:2 parallaxRatio:ccp(1,0) positionOffset:ccp(winSize.width/2, 0)];\n[parallax addChild:fg2 z:2 parallaxRatio:ccp(1,0) positionOffset:ccp(winSize.width/2 + winSize.width, 0)];\n\n[self addChild:parallax];\n```", "```swift\n[self setUserInteractionEnabled:YES];\n```", "```swift\nCGPoint previousPosition;\n```", "```swift\n-(void)touchBegan:(CCTouch *)touch withEvent:(CCTouchEvent *)event\n{\n  previousPosition = [touch locationInNode:self];\n}\n\n-(void)touchMoved:(CCTouch *)touch withEvent:(CCTouchEvent *)event\n{\n  CGPoint newPosition = [touch locationInNode:self];\n\n  parallax.position = ccp(parallax.position.x + (newPosition.x - previousPosition.x), 0);\n\n  if (parallax.position.x < -winSize.width)\n    parallax.position = ccp(-winSize.width,0);\n  if (parallax.position.x > 0)\n    parallax.position = ccp(0,0);\n\n  previousPosition = newPosition;\n}\n```", "```swift\nCCParticleSystem *smokeParticle;\n```", "```swift\nsmokeParticle = [CCParticleSystem \n  particleWithFile:@\"SmokeParticle.plist\"];\n[self addChild:smokeParticle];\n```", "```swift\nsmokeParticle.sourcePosition = startPosition;\n```", "```swift\n-(void)startSystem;\n```", "```swift\n-(void)startSystem\n{\n  _active = YES;\n  _elapsed = _duration;\n  _emitCounter = 0;\n}\n```", "```swift\n[smokeParticle stopSystem];\n```", "```swift\n-(void)touchEnded:(CCTouch *)touch withEvent:(CCTouchEvent *)event\n{\n\tisStreaming = NO;\n\t[smokeParticle stopSystem];\n}\n```", "```swift\n[smokeParticle startSystem];\n```", "```swift\nCCSprite *heart = [CCSprite spriteWithImageNamed:@\"heart.png\"];\nheart.color = [CCColor redColor];\nheart.position = startPosition;\n[self addChild:heart];\n\nCCActionScaleTo *shrink = [CCActionScaleTo actionWithDuration:0.5 scale:0];\nCCActionCallBlock *block = [CCActionCallBlock actionWithBlock:^{\n  [self removeChild:heart];\n}];\n\n[heart runAction:[CCActionSequence actions:shrink, block, nil]];\n```", "```swift\nCCSprite *heart = [CCSprite spriteWithImageNamed:@\"heart.png\"];\nheart.color = [CCColor redColor];\nheart.position = startPosition;\n[self addChild:heart];\n\nCCActionTintTo *tint = [CCActionTintTo actionWithDuration:0.5 color:[CCColor greenColor]];\n\nccBézierConfig bezConfig;\nbezConfig.controlPoint_1 = ccp(0,100);\nbezConfig.controlPoint_2 = ccp(100,100);\nbezConfig.endPosition = ccp(100,0);\nCCActionBézierTo *move = [CCActionBézierBy actionWithDuration:0.5 Bézier:bezConfig];\n\nCCActionRotateBy *rotate = [CCActionRotateBy actionWithDuration:0.5 angle:360];\n\nCCActionScaleTo *shrink = [CCActionScaleTo actionWithDuration:0.5 scale:0];\nCCActionCallBlock *remove = [CCActionCallBlock actionWithBlock:^{\n  [self removeChild:heart];\n}];\n\n[heart runAction:tint];\n[heart runAction:[CCActionSequence actions:move, rotate, shrink, remove, nil]];\n```", "```swift\n{\n  CGSize winSize;\n  CGPoint startPosition;\n\n  CCMotionStreak *streak;\n}\n```", "```swift\nstreak = [CCMotionStreak streakWithFade:0.35 minSeg:1 width:15 color:[CCColor yellowColor] textureFilename:@\"blade.png\"];\n[self addChild:streak];\n```", "```swift\nstreak.position = startPosition;\n[streak reset];\n```", "```swift\nstreak.position = startPosition;\n```", "```swift\n-(void)update:(CCTime)delta\n{\n  streak.position = ship.position;\n}\n```"]