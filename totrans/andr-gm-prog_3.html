<html><head></head><body><div><div><div><div><h1 class="title"><a id="part03"/>Part 3. Module 3</h1></div></div></div><div><div><div><blockquote class="blockquote"><p><em><strong>Mastering Android Game Development</strong></em></p><p><em>Master game development with the Android SDK to develop highly interactive and amazing games</em></p></blockquote></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch21"/>Chapter 1. Setting Up the Project</h1></div></div></div><p>In this chapter, we will describe the situations in which it makes sense to use the Android SDK for a game and those where it is best to use an external engine, explaining the pros and cons of each case.</p><p>We will create a simple project that we will be improving throughout the book, until it becomes a complete game. The particular game we are going to build is a Space Shooter.</p><p>A few top-level decisions will be made and explained, such as which orientation to use and how are we going to use activities and fragments.</p><p>We will describe the top-level architecture of a game engine, study how it is different from a typical app's, explaining why there is an <code class="literal">UpdateThread</code> and how it interacts with the user input and why it is separated from the <code class="literal">DrawThread</code>; we will include those elements in our project.</p><p>Once the game engine is completed, we will expand the project to show a pause dialog, handle the Android back key properly, be consistent with the <code class="literal">Activity</code> lifecycle, and make it fullscreen.</p><p>Finally, we will summarize some best practices in writing code for games.</p><p>Topics that will be covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The right tool for the right game</li><li class="listitem" style="list-style-type: disc">Setting up the project with Android Studio</li><li class="listitem" style="list-style-type: disc">Game architecture</li><li class="listitem" style="list-style-type: disc">Alert dialogs</li><li class="listitem" style="list-style-type: disc">Handling the back key</li><li class="listitem" style="list-style-type: disc">Dealing with the fullscreen mode</li><li class="listitem" style="list-style-type: disc">Good practices for game developers</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec00008"/>The right tool for the right game</h1></div></div></div><p>Before we begin entering the details about making games with the Android SDK, let's first take a step back and consider why are we doing this and what the other alternatives are for making a game that runs on Android.</p><p>People tend to reinvent the <a class="indexterm" id="id0000"/>wheel quite often and developers use to do it ever more, especially in the case of video games. While creating a complete engine from scratch is a great learning experience, it also takes a lot of time. So, if you want to just make a game, it may be more cost-efficient for you to use one of the existing engines instead.</p><p>We are in a golden age of tools for creating video games. Not only are there lots of them, but most of them are free as well. This makes choosing the right one a little bit more complicated.</p><p>Let's take a look at several questions to help us decide which tool to use to suit the needs of a specific game. Since you are already reading this book, I consider that multiplatform is not high on your list of priorities and that reusing your existing Java and Android knowledge is a plus.</p><div><img alt="The right tool for the right game" src="img/B04757_01_01.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00008"/>Do you want to use 3D?</h2></div></div></div><p>If the answer is yes; I would <a class="indexterm" id="id0001"/>definitely recommend you to use an already existing engine. There are some well-known tasks you'll need to implement to build even the simplest 3D engine such as loading models, loading and applying textures, handling transformations, and dealing with cameras. On top of this, you'd need to be writing OpenGL. All this is a lot of work.</p><p>Writing an OpenGL engine is the very definition of reinventing the wheel. It is fine if what you want is to learn the internals of a 3D engine, but if you go this road you'll spend a few months before you can even start with the game. If you want to go straight into making the game, you'd better start with an existing 3D engine.</p><p>The second question on this road is: do you prefer to work with code or are you more comfortable with a complete editor? For code, you can use jPCT-AE and libGDX, while, on the editor side, the most <a class="indexterm" id="id0002"/>common alternative is Unity.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00009"/>Do you want to use physics?</h2></div></div></div><a class="indexterm" id="id0003"/><p>An affirmative answer to this question should point you straight to an existing engine.</p><p>Physics simulation is a very well-known area where there is a lot of documentation, and you should be able to implement your own physics engine. Again, this is a great learning experience, but if you want to go straight into making the game it is much more convenient to use an existing engine that supports physics. The most used physics engine around is Box2D, which is written in C++ and it has been ported to Android using the NDK.</p><p>While we are going to talk about collision detection later in the book, physics is out beyond the scope of this book. Anything more complex than two spheres colliding can become quite complex to handle.</p><p>Once again, it depends whether you prefer to work with code or if you want a complete editor. To work with code, AndEngine should be your weapon of choice. In the case of an editor, Corona and Unity are among the most popular choices.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00010"/>Do you want to use Java?</h2></div></div></div><p>Most of the feature-rich <a class="indexterm" id="id0004"/>environments we are mentioning have their own environment, including a specific IDE. It takes effort to learn them and some of them use a different language (for example Unity has its own environment and uses JavaScript or C#).</p><p>On the other hand, the frameworks are simpler. You just have to include them and you'll still be writing an Android game. This is an interesting middle ground, where you still can reuse your Android and Java knowledge and make use of features such as physics or 3D models. In this section, we can mention AndEngine for 2D and physics and jPCT-AE for 3D as good options.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00011"/>Pros of building games with the Android SDK</h2></div></div></div><p>There are <a class="indexterm" id="id0005"/>several advantages to building games using the Android SDK:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is faster to build a prototype</li><li class="listitem" style="list-style-type: disc">You have full control over the engine</li><li class="listitem" style="list-style-type: disc">It has a smaller learning curve (you already know Android, Java, and Android Studio)</li><li class="listitem" style="list-style-type: disc">Most of your knowledge can be applied to apps</li><li class="listitem" style="list-style-type: disc">You can use <a class="indexterm" id="id0006"/>Google Play services and other libraries natively</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00012"/>Cons of building games with the Android SDK</h2></div></div></div><p>Of course, not <a class="indexterm" id="id0007"/>everything is awesome. There are some serious disadvantages, most of them already mentioned, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code is not portable to other platforms (namely iOS).</li><li class="listitem" style="list-style-type: disc">Performance can be an issue. If the game gets to a certain complexity, you may need to use OpenGL.</li><li class="listitem" style="list-style-type: disc">It lacks a physics engine; you'd need to write it yourself.</li><li class="listitem" style="list-style-type: disc">The support for OpenGL is just primitives; you need to build everything (or use a library).</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00013"/>I want the Android SDK!</h2></div></div></div><p>Are you still here? Congratulations, you have chosen the right book!</p><p>If you want to explore other options, there are books available for Unity, AndEngine, and libGDX, and published by Packt.</p><p>Now that we are all on the same page, let's get down to business.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00009"/>The project – YASS (Yet Another Space Shooter)</h1></div></div></div><p>Along the <a class="indexterm" id="id0008"/>book, we will be building a game as a demo of the concepts we will be studying in each chapter. The game is going to be a classic Space Shooter arcade game. We'll call it YASS—Yet Another Space Shooter.</p><p>This means some decisions will be taken for this particular type of game, but other options will also be commented since the book is meant for generic video game development.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00014"/>Activities and Fragments</h2></div></div></div><p>We are going to create a <a class="indexterm" id="id0009"/>project with a single <code class="literal">Activity</code> and we will add <a class="indexterm" id="id00010"/>fragments when necessary.</p><p>In the versions prior to Android 5.0 Lollipop, the transitions between activities could be modified, but only in a very limited way. The user can even disable them in a setting. All in all, this will make your game look clunky while transitioning from one <code class="literal">Activity</code> to another. You will need to save the state of the <code class="literal">Activity</code> in case it gets destroyed. Since each <code class="literal">Activity</code> is a separate instance, you will need to take care of communication among them, if required.</p><p>On the other hand, when <a class="indexterm" id="id00011"/>you work with fragments, you never exit the <code class="literal">Activity</code> and <a class="indexterm" id="id00012"/>you have complete control over the transition animations. In addition to these, you still have the code and layout of each section separated, so modularity and encapsulation are not compromised.</p><p>Finally, when it comes to handling third-party libraries such as In-App Billing or Google Play services, you have to take care if initialization and configuration only once, since those are linked at the <code class="literal">Activity</code> level.</p><div><div><h3 class="title"><a id="note00002"/>Note</h3><p>For games, it is more efficient to use only one Activity with multiple Fragments.</p></div></div><p>One good practice is to have a base <code class="literal">Fragment</code> for our game (<code class="literal">YassBaseFragment</code>) from which all the other fragments will inherit. One good use of this fragment is to have a method to replace <code class="literal">getActivity</code> that returns our specific <code class="literal">Activity</code>, but there are other cases in which having a common base fragment is handy.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00015"/>Project setup</h2></div></div></div><p>We are going to use <a class="indexterm" id="id00013"/>Android Studio as the IDE. We are going to create the project with <code class="literal">minSDK</code> 15 (Ice Cream Sandwich—ICS). As a good practice, we don't want to move the minimum SDK, unless we are using some features that were not available before. By keeping the <code class="literal">minSDK</code> low, you make your game available to as many devices as possible.</p><p>The two main features we are going to use from ICS are <code class="literal">Fragments</code>, <code class="literal">ValueAnimators</code>, and <code class="literal">ViewPropertyAnimators</code>. All of these were already available in Honeycomb, but 3.x is considered little more than a test for ICS; it was not mature and has been replaced by ICS in almost all devices.</p><p>In the unlikely case that you want to support older versions such as Gingerbread, you can make use of the compatibility library and NineOldAndroids to add backwards-compatibility for the features we are using.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00001"/>Creating the stub project</h3></div></div></div><p>Let's go on and <a class="indexterm" id="id00014"/>navigate to <strong>File</strong> &gt; <strong>New Project</strong>. We are going to use <code class="literal">YASS</code> as the <strong>Application name</strong> and <code class="literal">example.com</code> as the <strong>Company Domain</strong>.</p><div><img alt="Creating the stub project" src="img/B04757_01_02.jpg"/></div><p>We include support for Android TV, since we want to be able to run our game on the big screen. This will create an extra module that we can compile for, but we are not going to touch this until the last chapter.</p><p>As explained before, we <a class="indexterm" id="id00015"/>will use <strong>Minimum SDK</strong> version 15 for phones and 21 for Android TV, since this is when it was made available.</p><p>For the <strong>Package name</strong> of the application, we are going to use <code class="literal">com.example.yass</code>.</p><div><img alt="Creating the stub project" src="img/B04757_01_03.jpg"/></div><p>We are not going to use any of the default wizards, since all of them include the action bar/toolbar that is great for <a class="indexterm" id="id00016"/>apps, but of no use for games. So, we'll go with the empty project options:</p><div><img alt="Creating the stub project" src="img/B04757_01_04.jpg"/></div><p>Similarly, we are not <a class="indexterm" id="id00017"/>going to create any Activity for TV:</p><div><img alt="Creating the stub project" src="img/B04757_01_05.jpg"/></div><p>Once the project is created, we <a class="indexterm" id="id00018"/>will create a single <code class="literal">Activity</code> with one <code class="literal">Fragment</code>. This is done via the menu option <strong>New</strong> &gt; <strong>Activity</strong> &gt; <strong>Blank Activity with Fragment</strong>.</p><div><img alt="Creating the stub project" src="img/B04757_01_06.jpg"/></div><p>We are going to customize the <a class="indexterm" id="id00019"/>
<code class="literal">Activity</code> by filling the dialog as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Activity Name</strong>: <code class="literal">YassActivity</code></li><li class="listitem" style="list-style-type: disc"><strong>Layout Name</strong>: <code class="literal">activity_yass</code> (will be the default as soon as we change the Activity name)</li><li class="listitem" style="list-style-type: disc"><strong>Fragment Layout Name</strong>: <code class="literal">fragment_yass</code> (will be the default as soon as we change the Activity name)</li><li class="listitem" style="list-style-type: disc"><strong>Title</strong>: <code class="literal">YassActivity</code></li></ul></div><p>This will create the following files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">YassActivity.java</code> with the code for <code class="literal">YassActivity</code> and <code class="literal">PlaceholderFragment</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">activity_main.xml</code>: A <code class="literal">FrameLayout</code> with  <code class="literal">@+id/container</code>, which will be used to load the fragments into</li><li class="listitem" style="list-style-type: disc"><code class="literal">fragment_main.xml</code>: A placeholder layout with the text <code class="literal">Hello World!</code></li></ul></div><p>Since we did not tell Android <a class="indexterm" id="id00020"/>Studio that this activity is going to be our launch activity, we need to edit the <code class="literal">AndroidManifest.xml</code> to configure it as such, by adding the proper intent filter:</p><div><pre class="programlisting">&lt;intent-filter&gt;
  &lt;action android:name="android.intent.action.MAIN" /&gt;
  &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00002"/>Cleaning up</h3></div></div></div><p>We are not going to use menus <a class="indexterm" id="id00021"/>at all, so there are a few methods and files we will not need and we can delete them. You can leave all those methods there if you want, but it is better to have a clean environment, free of unused code.</p><p>So, we can remove the <code class="literal">menu</code> folder under <code class="literal">resources</code> and the files in it, which are meant to be the menu for the <code class="literal">YassActivity</code>.</p><p>The methods that handle menu-creation and menu-item-selection are also useless, so we can remove the following methods from <code class="literal">YassActivity</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onCreateOptionsMenu</code>: Invoked when the menu is created</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnOptionsItemSelected</code>: Invoked when an option from the menu is selected</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00016"/>Choosing an orientation</h2></div></div></div><p>Deciding the <a class="indexterm" id="id00022"/>orientation of a game is a very important point. Given the diversity of Android phones, the resolution and aspect ratio are a couple of things we have to deal with.</p><p>Gaming is traditionally done in landscape orientation: computers have monitors in landscape mode, and so do TV screens when you play with your gaming console. Almost all handheld consoles are designed with landscape orientation as well. Even more, most tablets consider landscape to be the default orientation.</p><div><div><h3 class="title"><a id="note00003"/>Note</h3><p>Landscape is the traditional orientation for gaming.</p></div></div><p>YASS is going to be a landscape game. The key reason why we are doing it is to be able to port the game to Android consoles later on, both on Android TV and OUYA. This does not mean that the portrait mode is not a valid orientation for games, but it is a less familiar one for players.</p><p>We are going to use <code class="literal">sensorLandscape</code> instead of just <code class="literal">landscape</code>, so the device can rotate 180 degrees to adjust to whatever side is down. We have to update the <code class="literal">AndroidManifest.xml</code> to look like this:</p><div><pre class="programlisting">&lt;application
  android:icon="@mipmap/ic_launcher"
  android:label="@string/app_name"
  android:theme="@style/AppTheme" &gt;
  &lt;activity
    <strong>android:screenOrientation="sensorLandscape"</strong>
    android:name=".YassActivity"
    android:label="@string/title_activity_yass" &gt;
    &lt;intent-filter&gt;
      &lt;action android:name="android.intent.action.MAIN" /&gt;
      &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
  &lt;/activity&gt;
&lt;/application&gt;</pre></div><p>As you probably know, when <a class="indexterm" id="id00023"/>an <code class="literal">Activity</code> changes orientation on Android, it is destroyed and recreated and so are all the fragments inside it. This means that, unless you explicitly save and restore information, the fragments will not remember the previous state.</p><div><div><h3 class="title"><a id="note00004"/>Note</h3><p>The <code class="literal">sensorLandscape</code> and <code class="literal">sensorPortrait</code> modes do not destroy activities on rotation.</p></div></div><p>Some good news here: while using <code class="literal">sensorLandscape</code>, the rotation does not kill the Activity, so no extra work is required. This happens because the layout is exactly the same and nothing needs to be recreated.</p><p>If you plan to make a game that can rotate, you must pay extra attention to saving and restoring the status of the game when the orientation changes. This in itself is another good reason to keep the game locked to a particular orientation, be it landscape or portrait.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00003"/>Dealing with aspect ratios</h3></div></div></div><p>Android devices <a class="indexterm" id="id00024"/>come in a lot of different aspect ratios, form 4:3 to 16:9 at least. This is not counting the number of pixels.</p><p>While designing a game for multiple aspect ratios, there are basically two ways of doing it. For each of them, we design for the most extreme aspect ratio. We will be using the extra space for "smart letterboxes," which means that we can have more game view.</p><div><img alt="Dealing with aspect ratios" src="img/B04757_01_07.jpg"/><div><p>Several ways of designing for different aspect ratios</p></div></div><p>The most common option is to make the camera centered and fix the smallest size (the height for the landscape orientation). This allows for more view space on the sides, while making sure that the smallest screen will have enough display space. This is the equivalent of viewing 4:3 images on a 16:9 screen.</p><p>You can also fix the bigger size <a class="indexterm" id="id00025"/>if the game design makes sense. This will add extra space on the top and bottom if the screen is square. This is the equivalent of viewing 16:9 images on a 4:3 screen.</p><p>There is an alternative approach: simply having "more camera space." We can, as well, make the game view a certain size and use the extra space for other controls such as scores, levels, and so on.</p><p>If you take this approach to the extreme, you can design the game area completely square and put the extra information in "smart letterboxes" for both landscape and portrait. One very good example of this approach is done by Candy Crush Saga. This is the best approach for versatility, but it is also the one that requires the most work.</p><p>For our game, we are going to use a "more camera space" approach with fixed size letterboxes to display scores and lives.</p><p>For the difference in resolution and pixel density, we will be designing for a low density screen. We will read the resolution of the device programmatically and apply a conversion factor. Some in-depth details of this approach are given in the chapters dedicated to low-level drawing, menus, and dialogs.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00010"/>Game architecture</h1></div></div></div><p>Games have a different <a class="indexterm" id="id00026"/>architecture and control flow than apps. Both seem to respond to user input instantly, but while an app does this by setting listeners and reacting to events with method calls (most commonly the <code class="literal">onClick</code> method calls the <code class="literal">OnClickListener</code>), this approach is not valid for a real-time game (although it is valid for non-real-time games).</p><p>Once a game is running, it must evaluate and update everything as fast as possible. This is the reason why it cannot be interrupted by user events. Those events or states should be recorded instead and then read by the game objects during its update.</p><p>The game engine should be created inside the fragment that runs the game, because we only need the game engine running while we are playing. This has the advantage that we can use our existing Android knowledge to create and handle the rest of the screens of the game.</p><div><img alt="Game architecture" src="img/B04757_01_08.jpg"/><div><p>Simplified architecture of a game engine</p></div></div><p>The basic <strong>Game Engine</strong> architecture is composed of an <strong>Update Thread</strong>, a <strong>Draw Thread</strong>, and a series of <strong>Game Objects</strong> that belong to the <strong>Game Engine</strong>.</p><p>The <strong>Game Engine</strong> is the component through which the rest of the program interacts with the game. Its mission is also to encapsulate the existence of the update and draw threads as well as to handle the game objects.</p><p>A game is composed of <strong>Game </strong><a class="indexterm" id="id00027"/>
<strong>Objects</strong> that are both updated and drawn. These objects are held inside the <strong>Game Engine</strong>.</p><p>The <strong>Update Thread</strong> is responsible for updating the state of the game objects as fast as it can. It will run through all the game objects calling an update method.</p><p>The UI has to also be constantly <a class="indexterm" id="id00028"/>updating and be independent of the update thread. It will draw all the game objects by calling a draw method on them.</p><p>Let's analyze each component in detail.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00017"/>GameEngine and GameObjects</h2></div></div></div><p>The <code class="literal">GameEngine</code> <a class="indexterm" id="id00029"/>contains the three elements already mentioned.</p><p><code class="literal">GameObject</code> is an abstract <a class="indexterm" id="id00030"/>class that all game objects in our <a class="indexterm" id="id00031"/>game must extend from. This interface connects them with the <a class="indexterm" id="id00032"/>
<code class="literal">Update</code> and <code class="literal">Draw</code> threads.</p><div><pre class="programlisting">public abstract class GameObject {
  public abstract void startGame();
  public abstract void onUpdate(long elapsedMillis, GameEngine gameEngine);
  public abstract void onDraw();
  public final Runnable mOnAddedRunnable = new Runnable() {
    @Override
    public void run() {
      onAddedToGameUiThread();
    }
  };

  public final Runnable mOnRemovedRunnable = new Runnable() {
    @Override
    public void run() {
      onRemovedFromGameUiThread();
    }
  };

  public void onRemovedFromGameUiThread(){
  }

  public void onAddedToGameUiThread(){
  }
}</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">startGame</code> is used for the initialization of the object before a game can start.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onUpdate</code> is called by the game engine as fast as possible, providing the number of milliseconds that have passed since the previous call and a reference to the <code class="literal">GameEngine</code> itself for future uses such as accessing user input.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDraw</code> makes the component render itself. We are not using any parameters just yet, but later we will pass a <code class="literal">Canvas</code> to draw on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onRemovedFromGameUiThread</code> contains code that must be run on the <code class="literal">UIThread</code> when the object is removed from the game.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onAddedToGameUiThread</code> contains code that must be run on the <code class="literal">UIThread</code> when the object is added to the game.</li><li class="listitem" style="list-style-type: disc">The two <code class="literal">Runnable</code> objects are used to call <code class="literal">onRemovedFromGameUiThread</code> and <code class="literal">onAddedToGameUiThread</code> inside the <code class="literal">UIThread</code>.</li></ul></div><p>The <code class="literal">GameEngine</code> will <a class="indexterm" id="id00033"/>provide us with easy methods to start, stop, pause, and resume the game, so we don't have to worry about the threads or the game objects <a class="indexterm" id="id00034"/>from the outside.</p><p>The game engine is composed of three items: the list of game objects, the <code class="literal">UpdateThread</code>, and the <a class="indexterm" id="id00035"/>
<code class="literal">DrawThread</code>.</p><div><pre class="programlisting">private List&lt;GameObject&gt; mGameObjects = new ArrayList&lt;GameObject&gt;();

private UpdateThread mUpdateThread;
private DrawThread mDrawThread;</pre></div><p>Let's take a look at the <a class="indexterm" id="id00036"/>different methods of the engine to handle a game.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00004"/>Starting a game</h3></div></div></div><p>The code to start a <a class="indexterm" id="id00037"/>game from the <code class="literal">GameEngine</code> is as follows:</p><div><pre class="programlisting">public void startGame() {
  // Stop a game if it is running
  stopGame();

  // Setup the game objects
  int numGameObjects = mGameObjects.size();
  for (int i=0; i&lt;numGameObjects; i++) {
    mGameObjects.get(i).startGame();
  }

  // Start the update thread
  mUpdateThread = new UpdateThread(this);
  mUpdateThread.start();

  // Start the drawing thread
  mDrawThread = new DrawThread(this);
  mDrawThread.start();
}</pre></div><p>First of all, we have to make sure that no game is running, so we call <code class="literal">stopGame</code> at the beginning to stop a game if there is one in progress.</p><p>Secondly, we reset all the <a class="indexterm" id="id00038"/>game objects that are linked to the engine. It is important to do this before we start the threads, so everything starts from the initial position.</p><p>Finally, we create and start the <code class="literal">UpdateThread</code> and the <code class="literal">DrawThread</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00005"/>Stopping a game</h3></div></div></div><p>Stopping a game is even <a class="indexterm" id="id00039"/>simpler. We just have to stop the <code class="literal">Update</code> and <code class="literal">Draw</code> threads if they exist:</p><div><pre class="programlisting">public void stopGame() {
  if (mUpdateThread != null) {
    mUpdateThread.stopGame();
  }
  if (mDrawThread != null) {
    mDrawThread.stopGame();
  }
}</pre></div><p>We also have methods for <code class="literal">pauseGame</code> and <code class="literal">resumeGame</code> that are functionally equivalent to this one. In these methods, the logic of the action belongs to each thread. We are not including the code of these methods here, because they are redundant.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00006"/>Managing game objects</h3></div></div></div><p>The engine has to <a class="indexterm" id="id00040"/>manage the addition and removal of game objects. We cannot just handle the list directly, since it will be used intensively during <code class="literal">onUpdate</code> and <code class="literal">onDraw</code>.</p><div><pre class="programlisting">public void addGameObject(final GameObject gameObject) {
  if (isRunning()){
    mObjectsToAdd.add(gameObject);
  }
  else {
    mGameObjects.add(gameObject);
  }
  mActivity.runOnUiThread(gameObject.mOnAddedRunnable);
}

public void removeGameObject(final GameObject gameObject) {
  mObjectsToRemove.add(gameObject);
  mActivity.runOnUiThread(gameObject.mOnRemovedRunnable);
}</pre></div><p>We use the lists <code class="literal">mObjectsToAdd</code> and <code class="literal">mObjectsToRemove</code> to keep track of the objects that must be added or removed. We will do both as the last step of the <code class="literal">onUpdate</code> method with the exception of when the game engine is not running, in which case it is safe to add and remove them directly.</p><p>We are also running the <a class="indexterm" id="id00041"/>corresponding <code class="literal">Runnable</code> object from the <code class="literal">GameObject</code> on the <code class="literal">UIThread</code>.</p><p>To update the game objects from the engine, we just call <code class="literal">onUpdate</code> on all of them. Once the update loop has finished, we take care of the objects that must be removed or added to <code class="literal">mGameObjects</code>. This part is done using a <code class="literal">synchronized</code> section that is also important for the <code class="literal">onDraw</code> method.</p><div><pre class="programlisting">public void onUpdate(long elapsedMillis) {
  int numGameObjects = mGameObjects.size();
  for (int i=0; i&lt;numGameObjects; i++) {
    mGameObjects.get(i).onUpdate(elapsedMillis, this);
  }
  synchronized (mGameObjects) {
    while (!mObjectsToRemove.isEmpty()) {
      mGameObjects.remove(mObjectsToRemove.remove(0));
    }
    while (!mObjectsToAdd.isEmpty()) {
       mGameObjects.add(mObjectsToAdd.remove(0));
    }
  }
}</pre></div><p>We do the same for drawing, except that the drawing must be done on the <code class="literal">UIThread</code>. So, we create a <code class="literal">Runnable</code> object that we pass to the <code class="literal">runOnUIThread</code> method of the activity.</p><div><pre class="programlisting">private Runnable mDrawRunnable = new Runnable() {
  @Override
  public void run() {
    synchronized (mGameObjects) {
      int numGameObjects = mGameObjects.size();
      for (int i = 0; i &lt; numGameObjects; i++) {
        mGameObjects.get(i).onDraw();
      }
    }
  }
};

public void onDraw(Canvas canvas) {
  mActivity.runOnUiThread(mDrawRunnable);
}</pre></div><p>Note that we synchronize the run method using <code class="literal">mGameObjects</code>. We do it so we are sure that the list is not modified while we iterate it.</p><p>It is also important that only the last part of the <code class="literal">onUpdate</code> is synchronized. If no objects are added or removed, the threads are independent. If we synchronize the complete <code class="literal">onUpdate</code> method, we will <a class="indexterm" id="id00042"/>be losing all the advantages of having the <code class="literal">Update</code> and <code class="literal">Draw</code> threads separated.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00018"/>UpdateThread</h2></div></div></div><p><code class="literal">UpdateThread</code> is a <a class="indexterm" id="id00043"/>thread that continuously runs updates on the game engine. For each call to <code class="literal">onUpdate</code>, it provides the number of milliseconds since the previous execution.</p><p>The basic <code class="literal">run</code> method of the update thread is as follows:</p><div><pre class="programlisting">@Override
public void run() {
  long previousTimeMillis;
  long currentTimeMillis;
  long elapsedMillis;
  previousTimeMillis = System.currentTimeMillis();

  while (mGameIsRunning) {
    currentTimeMillis = System.currentTimeMillis();
    elapsedMillis = currentTimeMillis - previousTimeMillis;           
    mGameEngine.onUpdate(elapsedMillis);
    previousTimeMillis = currentTimeMillis;
  }
}</pre></div><p>The thread stays in a loop for as long as the game is running. On each iteration, it will get the current time, calculate the <a class="indexterm" id="id00044"/>elapsed milliseconds since the previous run, and call <code class="literal">onUpdate</code> on the <code class="literal">GameEngine</code> object.</p><p>While this first version works and is very simple to follow, it can only start and stop a game. We want to be able to pause and resume it as well.</p><p>To pause and resume the game, we need a variable that we read inside the loop to check when to pause the execution. We'll need to keep track of the elapsed milliseconds and discount the time spent paused. A simple way to do it is like this:</p><div><pre class="programlisting">while (mGameIsRunning) {
  currentTimeMillis = System.currentTimeMillis();
  elapsedMillis = currentTimeMillis - previousTimeMillis;
  if (mPauseGame) {
    while (mPauseGame) {
      try {
        Thread.sleep(20);
      } catch (InterruptedException e) {
        // We stay on the loop
      }
    }
    currentTimeMillis = System.currentTimeMillis();
  }
  mGameEngine.onUpdate(elapsedMillis);
  previousTimeMillis = currentTimeMillis;
}</pre></div><p>The code for the <code class="literal">pauseGame</code> and <code class="literal">resumeGame</code> methods is just setting the variable <code class="literal">mPauseGame</code> to true or false.</p><p>If the game is paused, we enter a while loop in which we will remain until the game is resumed. To avoid having an empty loop that runs continuously, we can put the thread to sleep for a short amount of time (20 milliseconds). <a class="indexterm" id="id00045"/>Note that <code class="literal">Thread.sleep</code> can trigger an <code class="literal">InterruptedException</code>. If that happens we can just continue since it is going to be run in 20 milliseconds again. Besides, we are going to improve it right now.</p><p>This approach works, but there is still a lot of idle processing being done. For threads, there are mechanisms to pause <a class="indexterm" id="id00046"/>and resume in a much more efficient way. We are going to improve this using <code class="literal">wait</code>/<code class="literal">notify</code>.</p><p>The code can be updated to be like this:</p><div><pre class="programlisting">while (mGameIsRunning) {
  currentTimeMillis = System.currentTimeMillis();
  elapsedMillis = currentTimeMillis - previousTimeMillis;
  if (mPauseGame) {
    while (mPauseGame) {
      try {
        synchronized (mLock) {
          mLock.wait();
        }
      } catch (InterruptedException e) {
        // We stay on the loop
      }
    }
    currentTimeMillis = System.currentTimeMillis();
  }
  mGameEngine.onUpdate(elapsedMillis);
  previousTimeMillis = currentTimeMillis;
}</pre></div><p>The <code class="literal">pauseGame</code> method is the same as before, but we need to update <code class="literal">resumeGame</code> to be at the place from where the lock is notified and released:</p><div><pre class="programlisting">public void resumeGame() {
  if (mPauseGame == true) {
    mPauseGame = false;
    synchronized (mLock) {
      mLock.notify();
    }
  }
}</pre></div><p>With the use of <code class="literal">wait</code>/<code class="literal">notify</code>, we ensure that the thread will not do any work while it is idle and we also know that it will be woken up as soon as we notify it. It is important to first set <code class="literal">mPauseGame</code> to <code class="literal">false</code> and then awake the thread, otherwise the main loop could stop again.</p><p>Finally, to start and stop the <a class="indexterm" id="id00047"/>game, we just need to change the values of <a class="indexterm" id="id00048"/>the variables:</p><div><pre class="programlisting">public void start() {
  mGameIsRunning = true;
  mPauseGame = false;
  super.start();
}

public void stopGame() {
  mGameIsRunning = false;
  resumeGame();
}</pre></div><p>The game never starts in a paused state. To stop a game, we just need to set the <code class="literal">mGameIsRunning</code> value to <code class="literal">false</code> and the loop inside the <code class="literal">run</code> method will end.</p><p>It is important to call <code class="literal">resumeGame</code> as a part of the <code class="literal">stopGame</code> method. If we call stop while the game is paused, the thread will be waiting, so nothing will happen unless we resume the game. If the game is not paused, nothing is done inside <code class="literal">resumeGame</code>, so it does not matter if we called it.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00019"/>DrawThread</h2></div></div></div><p>There are several ways to <a class="indexterm" id="id00049"/>implement <code class="literal">DrawThread</code>. It could be <a class="indexterm" id="id00050"/>done in a similar way to the update thread, but we are going to use a much simpler approach that does not use a <code class="literal">Thread</code>.</p><p>We are going to use the <code class="literal">Timer</code> and <code class="literal">TimerTask</code> classes to send the <code class="literal">onDraw</code> callback to the game engine with a high-enough frequency to render at 30 frames per second:</p><div><pre class="programlisting">private static int EXPECTED_FPS = 30;
private static final long TIME_BETWEEN_DRAWS = 1000 / EXPECTED_FPS;

public void start() {
  stopGame();
  mTimer = new Timer();
  mTimer.schedule(new TimerTask() {
    @Override
    public void run() {
      mGameEngine.onDraw();
    }
  }, 0, TIME_BETWEEN_DRAWS);
}</pre></div><p>We have this method called every 33 milliseconds. In simple implementations, this method will just call <code class="literal">invalidate</code> in the <code class="literal">GameView</code>, which will cause a call to the <code class="literal">onDraw</code> method of the <code class="literal">View</code>.</p><p>This implementation relies on one feature of the Android UI. To redisplay views, Android has a contingency <a class="indexterm" id="id00051"/>system that is built in to avoid recurrent invalidates. If an invalidation is requested while the view is being drawn, it will be queued. If more than <a class="indexterm" id="id00052"/>one invalidations are queued, they will be discarded as they won't have any effect.</p><p>With this, if the view takes longer than <code class="literal">TIME_BETWEEN_DRAWS</code> to be drawn, the system will fall back to fewer frames per second automatically.</p><p>Later in the book, we will revisit this thread for more complex implementations but, for now, let's keep it simple.</p><p>Stopping, pausing, and resuming the <code class="literal">DrawThread</code> is also simple:</p><div><pre class="programlisting">public void stopGame() {
  if (mTimer != null) {
    mTimer.cancel();
    mTimer.purge();
  }
}

public void pauseGame() {
  stopGame();
}

public void resumeGame() {
  start();
}</pre></div><p>To stop the game, we only need to <code class="literal">cancel</code> and <code class="literal">purge</code> the timer. The <code class="literal">cancel</code> method will cancel the timer and all scheduled tasks, while <code class="literal">purge</code> will remove all the canceled tasks from the queue.</p><p>Since we do not need to keep track of any state, we can just make the <code class="literal">pauseGame</code> and <code class="literal">resumeGame</code> equivalents to <code class="literal">stopGame</code> and start.</p><p>Note that, if we want to have <a class="indexterm" id="id00053"/>a smooth game at 30fps, the drawing of all the items on the screen must be performed in less than 33 milliseconds. This implies that the <a class="indexterm" id="id00054"/>code of these methods usually needs to be optimized.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00020"/>User input</h2></div></div></div><p>As we mentioned, user <a class="indexterm" id="id00055"/>input is to be processed by some input controller and then read by the objects that need it, when they need it. We will go into the details of such an input controller in the next chapter. For now, we just want to check whether the game engine works as expected and handles the start, stop, pause, and resume calls properly.</p><p>Pause, resume, and start are different from the other user inputs, because they affect the state of the engine and threads themselves instead of modifying the state of the game objects. For this reason, we are going to use standard event-oriented programming to trigger these functions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00011"/>Putting everything together</h1></div></div></div><p>Let's pick up our stub project, add all the classes we need to have a working game engine, and then modify the code so it allows us to start, stop, pause, and resume the game engine and display the <a class="indexterm" id="id00056"/>number of milliseconds since the game was started.</p><p>We will put our current implementation of <code class="literal">GameEngine</code>, <code class="literal">UpdateThread</code>, <code class="literal">DrawThread</code>, and <code class="literal">GameObject</code> inside the <code class="literal">com.example.yass.engine </code>package.</p><p>Next, we will create another package named <code class="literal">com.example.yass.counter</code>, which we will use for the code of this example.</p><p>Inside <code class="literal">YassActivity</code>, we have an inner class named <code class="literal">PlaceholderFragment</code>. We are going to rename it to <code class="literal">GameFragment</code>, refactor it to a separate file, and put it under the <code class="literal">com.example.yass.counter </code>package.</p><p>We are going to add a <code class="literal">TextView</code> that will show the number of milliseconds and two buttons: one to start and stop the game engine and another one to pause and resume it.</p><p>We are going to add them to the layout of <code class="literal">fragment_yass_main.xml</code>, which will look like this:</p><div><pre class="programlisting">&lt;LinearLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  android:padding="@dimen/activity_horizontal_margin"
  android:paddingLeft="@dimen/activity_horizontal_margin"
  tools:context="com.example.yass.counter.PlaceholderFragment"&gt;

  &lt;TextView
    android:id="@+id/txt_score"
   android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" /&gt;

  &lt;Button
    android:id="@+id/btn_start_stop"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/start" /&gt;

  &lt;Button
    android:id="@+id/btn_play_pause"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/pause" /&gt;
&lt;/LinearLayout&gt;</pre></div><p>For the game fragment, we <a class="indexterm" id="id00057"/>need to add the following code inside <code class="literal">onViewCreated</code>:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  mGameEngine = new GameEngine(getActivity());
  mGameEngine.addGameObject(
    new ScoreGameObject(view, R.id.txt_score));
  view.findViewById(R.id.btn_start_stop)
    .setOnClickListener(this);
  view.findViewById(R.id.btn_play_pause)
    .setOnClickListener(this);
}</pre></div><p>Once the view is created, we create the game engine and add a new <code class="literal">ScoreGameObject</code> to it. Then we set the current fragment as the listener for the two buttons we have added.</p><p>The code for <code class="literal">onClick</code> is very simple; just decide which method to call for each button:</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  if (v.getId() == R.id.btn_play_pause) {
    playOrPause();
  }
  if (v.getId() == R.id.btn_start_stop) {
    startOrStop();
  }
}</pre></div><p>Deciding whether the game should be paused or resumed is as simple as this:</p><div><pre class="programlisting">private void playOrPause() {
  Button button = (Button)
  getView().findViewById(R.id.btn_play_pause);
  if (mGameEngine.isPaused()) {
    mGameEngine.resumeGame();
    button.setText(R.string.pause);
  }
  else {
    mGameEngine.pauseGame();
    button.setText(R.string.resume);
  }
}</pre></div><p>We also handle a name change on the button to make sure the UI is consistent. In the code, we are making use of <a class="indexterm" id="id00058"/>the <code class="literal">isPaused</code> method from <code class="literal">GameEngine</code>. This method just returns the status of the <code class="literal">UpdateThread</code> object as long as it is not null:</p><div><pre class="programlisting">public boolean isPaused() {
  return mUpdateThread != null &amp;&amp; mUpdateThread.isGamePaused();
}</pre></div><p>Similarly, to play/pause the game and keep the state of the buttons, we will add this method:</p><div><pre class="programlisting">private void startOrStop() {
  Button button = (Button)
    getView().findViewById(R.id.btn_start_stop);
  Button playPauseButton = (Button)
    getView().findViewById(R.id.btn_play_pause);
  if (mGameEngine.isRunning()) {
    mGameEngine.stopGame();
    button.setText(R.string.start);
    playPauseButton.setEnabled(false);
  }
  else {
    mGameEngine.startGame();
    button.setText(R.string.stop);
    playPauseButton.setEnabled(true);
    playPauseButton.setText(R.string.pause);
  }
}</pre></div><p>Once again, we need a method in the <code class="literal">GameEngine</code> to know whether it is running or not. As we did for the previous one, we just mirror the status of <code class="literal">UpdateThread</code>:</p><div><pre class="programlisting">public boolean isRunning() {
  return mUpdateThread != null &amp;&amp; mUpdateThread.isGameRunning();
}</pre></div><p>Once the basic connections are done, we can move to the really interesting bit: the game object we are creating. This object illustrates the use of each method from the <code class="literal">GameObject</code> class that we <a class="indexterm" id="id00059"/>have been talking about:</p><div><pre class="programlisting">public class ScoreGameObject extends GameObject {

  private final TextView mText;
  private long mTotalMilis;

  public ScoreGameObject(View view, int viewResId) {
    mText = (TextView) view.findViewById(viewResId);
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine)
  {
    mTotalMilis += elapsedMillis;
  }

  @Override
  public void startGame() {
    mTotalMilis = 0;
  }

  @Override
  public void onDraw() {
    mText.setText(String.valueOf(mTotalMilis));
  }
}</pre></div><p>The <code class="literal">onUpdate</code> method just keeps adding milliseconds to the total. The total is reset when a new game starts and <code class="literal">onDraw</code> sets the value of the total number of milliseconds in the text view.</p><p>As expected, <code class="literal">onUpdate</code> is called a lot more often than <code class="literal">onDraw</code>. On the other hand, <code class="literal">onDraw</code> is executed on the <code class="literal">UIThread</code>, which is something we cannot afford to do with <code class="literal">onUpdate</code>.</p><p>We can now compile and run the example and check that the timer starts and stops when we start and stop the game <a class="indexterm" id="id00060"/>engine. We can also check that pause and resume work as expected.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00012"/>Moving forward with the example</h1></div></div></div><p>Now we are going to <a class="indexterm" id="id00061"/>change the example a bit. We are going to make a pause dialog from which we can resume or stop the game. This dialog will be shown if the user taps on the pause button and if he or she hits the back key.</p><p>Finally, we are going to add one fragment from which the player can start the game and we will separate the game fragment from the menu.</p><p>So, we'll be creating <code class="literal">MainMenuFragment.java</code> and <code class="literal">fragment_main_menu.xml</code>. The content of the layout will be extremely simple:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout 
  android:layout_width="match_parent" 
  android:layout_height="match_parent"&gt;

  &lt;TextView
    android:layout_gravity="center_horizontal|top"
    style="@android:style/TextAppearance.DeviceDefault.Large"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:text="@string/game_title"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" /&gt;

  &lt;Button
    android:id="@+id/btn_start"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:text="@string/start" /&gt;

&lt;/FrameLayout&gt;</pre></div><p>This includes the app title on the screen and a button to start playing:</p><div><img alt="Moving forward with the example" src="img/B04757_01_09.jpg"/></div><p>Inside this fragment, we add a <a class="indexterm" id="id00062"/>listener to the start button and we make it call the <code class="literal">startGame</code> method. The code of the <code class="literal">startGame</code> method is very simple as well:</p><div><pre class="programlisting">public void startGame() {
  getFragmentManager()
    .beginTransaction()
    .replace(R.id.container, new GameFragment(), TAG_FRAGMENT)
    .addToBackStack(null)
    .commit();
}</pre></div><p>We are using the fragment manager to transition from the current fragment to <code class="literal">GameFragment</code>.</p><p>The <code class="literal">beginTransition</code> method creates the transition itself and we can configure it with chained methods.</p><p>We are replacing the fragment inside the view with the <code class="literal">R.id.container</code> id with a <code class="literal">GameFragment</code>. This will remove the old fragment. If we use <code class="literal">add</code>, both fragments will be shown instead.</p><p>Then, we add the fragment to the back stack with no tag, since we don't need any. This is very important, because it allows the system to handle the back key properly. Everything that is on the back stack of the fragment manager will pop up when the back key is pressed.</p><p>If we do not add the fragment to the back stack, the default behavior when we tap on the back key will be to close the app. With the fragment on the back stack, we can just rely on the system to handle fragment navigation properly.</p><p>Finally, we commit the transition so the fragment is replaced.</p><p>Inside the game fragment we have already, we will remove the start/stop dialog and modify the pause button to show a dialog from where we can resume or exit the current game.</p><p>We want the game to start <a class="indexterm" id="id00063"/>immediately, so the <code class="literal">onViewCreated</code> method of the <code class="literal">GameFragment</code> will now look like this:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  mGameEngine = new GameEngine(getActivity());
  mGameEngine.addGameObject(
    new ScoreGameObject(view, R.id.txt_score));
  view.findViewById(R.id.btn_play_pause)
    .setOnClickListener(this);
  mGameEngine.startGame();
}</pre></div><p>We will also modify the <code class="literal">onClick</code> method, removing the old code to start or stop, so it looks like this:</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  if (v.getId() == R.id.btn_play_pause) {
    pauseGameAndShowPauseDialog();
  }
}</pre></div><p>This simpler version only cares about pausing the game and showing a dialog when the pause button is clicked.</p><p>For now, we are going to create a default dialog using the <code class="literal">AlertDialog</code> framework:</p><div><pre class="programlisting">private void pauseGameAndShowPauseDialog() {
  mGameEngine.pauseGame();
  new AlertDialog.Builder(getActivity())
  .setTitle(R.string.pause_dialog_title)
  .setMessage(R.string.pause_dialog_message)
  .setPositiveButton(R.string.resume, 
  new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
      dialog.dismiss();
      mGameEngine.resumeGame();
    }
  })
  .setNegativeButton(R.string.stop, 
    new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
      dialog.dismiss();
      mGameEngine.stopGame();
      ((MainActivity)getActivity()).navigateBack();
    }
  })
  .create()
  .show();
}</pre></div><p>The positive button will resume the game, so it calls <code class="literal">resumeGame</code> in the game engine.</p><p>The negative button will <a class="indexterm" id="id00064"/>exit the game, so it calls <code class="literal">stopGame</code> in the <code class="literal">GameEngine</code> and then <code class="literal">navigateBack</code> in the parent <code class="literal">Activity</code>.</p><p>The <code class="literal">navigateBack</code> method is nothing more than handling a back key pressed in the activity:</p><div><pre class="programlisting">public void navigateBack() {
  super.onBackPressed();
}</pre></div><p>Since we put the fragment in the navigation stack, the <code class="literal">MainMenuFragment</code> will be loaded again and the <code class="literal">GameFragment</code> will be destroyed. The following is how the <code class="literal">Pause</code> dialog looks:</p><div><img alt="Moving forward with the example" src="img/B04757_01_10.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00021"/>Handling the back key</h2></div></div></div><p>One of the things we <a class="indexterm" id="id00065"/>want to do is to handle the back key properly. This is something that upsets Android users when it does not work as expected inside games, so we'll be <a class="indexterm" id="id00066"/>paying some special attention to it. There are two places where it does not work as expected right now.</p><div><div><h3 class="title"><a id="note00005"/>Note</h3><p>Handling the back key properly is very important on Android.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If we dismiss the <strong>Pause</strong> dialog using the back key, the game will not resume.</li><li class="listitem" style="list-style-type: disc">While in the game fragment, the back key should pause the game. At the moment, the back key goes back to the <code class="literal">GameFragment</code>.</li></ul></div><p>For the first problem, we need to add an <code class="literal">OnCancelListener</code> to the dialog. This is different from <code class="literal">OnDismissListener</code>, which is called every time the dialog is dismissed. The <code class="literal">cancel</code> method is only called when the dialog is canceled.</p><p>Also, <code class="literal">OnDismissListener</code> was introduced in API level 17. Since we don't need it, we will not worry about raising the <code class="literal">minSDK</code> of the game.</p><p>We update the creation of the <strong>Pause</strong> dialog with the following code:</p><div><pre class="programlisting">new AlertDialog.Builder(getActivity())
  [...]
  .setOnCancelListener(new DialogInterface.OnCancelListener() {
    @Override
    public void onCancel(DialogInterface dialog) {
      mGameEngine.resumeGame();
    }
  })
  .create()
  show();</pre></div><p>The remaining item is to pause the game when the back key is pressed during the game. This is something that needs to be <a class="indexterm" id="id00067"/>handled in the fragment. As it happens, <code class="literal">onBakPressed</code> <a class="indexterm" id="id00068"/>is a method available only for activities. We need to code a way to expand this to the current fragment.</p><p>We are going to make use of our <code class="literal">YassBaseFragment</code>, the base class for all the fragments in our game, to add the <a class="indexterm" id="id00069"/>support to <code class="literal">onBackPressed</code>. We will create one <code class="literal">onBackPressed</code> method here:</p><div><pre class="programlisting">public class YassBaseFragment extends Fragment {
  public boolean onBackPressed() {
    return false;
  }
}</pre></div><p>In the <code class="literal">Activity</code>, we update <code class="literal">onBackClicked</code> to allow the fragments to override it if needed:</p><div><pre class="programlisting">@Override
public void onBackPressed() {
  final YassFragment fragment = (YassFragment)
    getFragmentManager().findFragmentByTag(TAG_FRAGMENT);
  if (!fragment.onBackPressed()) { 
    super.onBackPressed();
  }
}</pre></div><p>If the fragment does not handle the back key press, it will return false. Then, we just call the super method to allow the default behavior.</p><p><code class="literal">TAG_FRAGMENT</code> is very important; it allows us to get the fragment we are adding and it is set when we add the fragment to <code class="literal">FragmentTransition</code>. Let's review the <code class="literal">onCreate</code> method of <code class="literal">MainActivity</code>, which was created by the wizard, and add the <code class="literal">TAG_FRAGMENT</code> to the initial <code class="literal">FragmentTransition</code>:</p><div><pre class="programlisting">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_yass);
  if (savedInstanceState == null) {
    getFragmentManager().beginTransaction()
      <strong>.add(R.id.container, new MainMenuFragment(), TAG_FRAGMENT)</strong>
      .commit();
  }
}</pre></div><p>It is also very important that all the fragments of the application must extend from <code class="literal">YassBaseFragment</code>, otherwise <a class="indexterm" id="id00070"/>this method will throw a <code class="literal">ClassCastException</code>.</p><p>With all the pieces in place, we now override the <code class="literal">onBackPressed</code> method inside <code class="literal">GameFragment</code> to show the <a class="indexterm" id="id00071"/>
<strong>Pause</strong> dialog:</p><div><pre class="programlisting">@Override
public boolean onBackPressed() {
  if (mGameEngine.isRunning()) {
    pauseGameAndShowPauseDialog();
    return true;
  }
  return false;
}</pre></div><p>With this, the <strong>Pause</strong> dialog is shown when we click back while in the <code class="literal">GameFragment</code>. Note that we will only show the <a class="indexterm" id="id00072"/>pause dialog if the <code class="literal">GameEngine</code> is running. When it is not running, we return <code class="literal">false</code>. The default behavior of Android will trigger and the <strong>Pause</strong> dialog, which must be showing, will be canceled.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00022"/>Honoring the lifecycle</h2></div></div></div><p>Our game should also be <a class="indexterm" id="id00073"/>consistent with the Activity lifecycle; especially, it should pause whenever the <code class="literal">Activity</code> pauses. This is very important for mainly two reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the game is put in the background, the user wants it to be paused when it returns</li><li class="listitem" style="list-style-type: disc">As long as the game is running, the update thread will be updating as fast as it can, so it will make the phone feel slower</li></ul></div><p>With the current implementation, none of this will happen. You can try pressing the home button, you will see that the device does not feel responsive. Also, if you put the game again in the foreground using the recent activities button, you will see that the timer is still counting.</p><div><div><h3 class="title"><a id="note00006"/>Note</h3><p>Not respecting the fragment lifecycle will result in performance problems and unhappy players.</p></div></div><p>Solving this is very simple, we just need to be consistent with the fragment lifecycle, by adding this code to the <a class="indexterm" id="id00074"/>
<code class="literal">GameFragment</code>:</p><div><pre class="programlisting">@Override
public void onPause() {
  super.onPause();
  if (mGameEngine.isRunning()){
    pauseGameAndShowPauseDialog();
  }
}

@Override
public void onDestroy() {
  super.onDestroy();
  mGameEngine.stopGame();
}</pre></div><p>With this, whenever the fragment is paused, we pause the game and show the dialog, so the player can resume again. Also, whenever the fragment is destroyed, we stop the game engine.</p><p>It is important to check whether the game engine is running or not before we pause it, since <code class="literal">onPause</code> is also called when we exit the game. So, if we forget to do this, exiting via the pause dialog will make the app crash.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00023"/>Using as much screen as we can</h2></div></div></div><p>We are building a game. We want to have all the screen space of the device and no distractions. There are two items that take this from us:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The Status bar</strong>: The bar <a class="indexterm" id="id00075"/>on the top of the screen where the <a class="indexterm" id="id00076"/>time, battery, WiFi, mobile signal, and notifications are displayed.</li><li class="listitem" style="list-style-type: disc"><strong>The Navigation bar</strong>: This is the <a class="indexterm" id="id00077"/>bar where the <code class="literal">back</code>, <code class="literal">home</code>, and <code class="literal">recent</code> <a class="indexterm" id="id00078"/>buttons are placed. It may be located in different places according to the orientation of the device.</li></ul></div><div><img alt="Using as much screen as we can" src="img/B04757_01_11.jpg"/><div><p>The Status and Navigation bars take up a significant amount of space on the screen</p></div></div><p>The <strong>Navigation bar</strong> was <a class="indexterm" id="id00079"/>introduced on Ice Cream Sandwich as a replacement for physical buttons. But, even today, some manufacturers decide to use physical buttons instead, so it may or may not be there.</p><p>The first thing we can do is to tell the system that we want to be fullscreen. There is a flag with the <code class="literal">SYSTEM_UI_FLAG_FULLSCREEN</code> name, which seems to be what we are looking for.</p><p>The problem is that this flag was <a class="indexterm" id="id00080"/>introduced in the early versions of Android when there was no <strong>Navigation bar</strong>. Back then, it really meant fullscreen but, from Ice Cream Sandwich onwards, it just means "remove the <strong>Status bar</strong>".</p><div><div><h3 class="title"><a id="note00007"/>Note</h3><p>The<code class="literal"> SYSTEM_UI_FLAG_FULLSCREEN</code> mode is not really fullscreen.</p></div></div><div><img alt="Using as much screen as we can" src="img/B04757_01_12.jpg"/><div><p>Fullscreen only makes the Status bar go away.</p></div></div><p>Along with the <strong>Navigation </strong><a class="indexterm" id="id00081"/>
<strong>bar</strong>, some ways to handle fullscreen were added. The approach was <a class="indexterm" id="id00082"/>revisited in KitKat. So, let's look at our options.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00007"/>Before Android 4.4 – almost fullscreen</h3></div></div></div><p>On Android 4.0, together with the <strong>Navigation bar</strong>, two new flags were added to handle the <strong>Navigation bar</strong> in addition to the existing fullscreen flag:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>: This tells the system to hide the <strong>Navigation bar</strong></li><li class="listitem" style="list-style-type: disc"><code class="literal">SYSTEM_UI_FLAG_LOW_PROFILE</code>: This puts the device in "low profile" mode, dimming the icons on the <strong>Navigation bar</strong> and replacing them with just dots</li></ul></div><p>While it is true that the "hide <a class="indexterm" id="id00083"/>navigation" flag hides the Navigation bar completely, the bar will reappear as soon as you touch anywhere on the screen, since this mode is designed to be used for noninteractive activities such as video playback. So, <code class="literal">SYSTEM_UI_FLAG_HIDE_NAVIGATION</code> is not much use to us.</p><p>Using low profile to dim the navigation bar is a much more logical solution. Although we are not getting any extra screen space, the fact that the icons on the bar are reduced to small dots allows players to focus a lot more on the content. These icons will show when necessary (essentially, when the user taps on the bar) and dim again as soon as they are not needed.</p><div><div><h3 class="title"><a id="note00008"/>Note</h3><p>Hiding the navigation bar will only work fine for noninteractive apps. The Navigation bar will appear again as soon as you touch the screen.</p></div></div><p>All in all, we have to be happy with just dimming the Navigation bar and getting rid of the Status bar.</p><div><img alt="Before Android 4.4 – almost fullscreen" src="img/B04757_01_13.jpg"/><div><p>The low profile mode dims the Navigation bar so it is less obtrusive</p></div></div><p>This is the code we need <a class="indexterm" id="id00084"/>to add to the <code class="literal">MainActivity</code> to remove the Status bar and put the device in a low profile mode:</p><div><pre class="programlisting">@Override
public void onWindowFocusChanged(boolean hasFocus) {
  super.onWindowFocusChanged(hasFocus);
  if (hasFocus) {
    View decorView = getWindow().getDecorView();
    decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
      | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
      | View.SYSTEM_UI_FLAG_FULLSCREEN
      | View.SYSTEM_UI_FLAG_LOW_PROFILE);
  }
}</pre></div><p>We are overriding the <code class="literal">onWindowFocusChanged</code> method in the main <code class="literal">Activity</code>. This is the recommended place to handle the flags, since it is called whenever the window focus changes. When the app regains focus, we don't know in which status the bars are. So, it is a good practice to ensure that things are the way we want them.</p><p>There are two more flags we haven't mentioned yet. They were introduced in API level 16 and are designed to take care of how the layout reacts to the appearance and disappearance of elements.</p><p>The<code class="literal"> SYSTEM_UI_FLAG_LAYOUT_STABLE</code> flag means that the layout will be consistent, independent of the elements being shown or hidden.</p><p>The<code class="literal"> SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code> flag tells the system that our stable layout will be the one in the fullscreen mode—without the navigation bar.</p><p>This means that if/when the status bar is shown, the layout will not change, which is good, otherwise it will look <a class="indexterm" id="id00085"/>like it is a glitch. It also means that we need to be careful with margins, so nothing important gets covered by the Status bar.</p><div><div><h3 class="title"><a id="note00009"/>Note</h3><p>Stable layout only exists from the Jelly Bean version onwards (API level 16 +).</p></div></div><p>For Ice Cream Sandwich, <code class="literal">SYSTEM_UI_FLAG_LAYOUT_STABLE</code> does not work. But there are very few devices with this version and the Status bar is shown on very few occasions, so it is acceptable.</p><p>The real fullscreen mode was introduced in KitKat.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00008"/>Android 4.4 and beyond – immersive mode</h3></div></div></div><p>On KiKat, a new <a class="indexterm" id="id00086"/>mode was introduced: the <strong>immersive mode</strong>.</p><p>Immersive mode hides the Status and Navigation bars completely. It is designed, as the name indicates, for fully-immersive experiences, which means games mostly. Even when the Navigation bar appears again, it is semitransparent instead of black and overlaid on top of the game.</p><div><div><h3 class="title"><a id="note00010"/>Note</h3><p>The sticky immersive mode has been designed almost specifically for games.</p></div></div><p>Immersive mode can be used in two ways: <strong>normal</strong> and <strong>sticky</strong>. Both of them are fullscreen and the user is shown a tip the first time the app is put in this mode with an explanation of how to get out of it:</p><div><img alt="Android 4.4 and beyond – immersive mode" src="img/B04757_01_14.jpg"/></div><p>The immersive nonsticky mode will keep the Status and Navigation bars visible once they are shown, while the immersive sticky mode will hide them after a couple of seconds have passed, returning to the real fullscreen. The recommended mode for games is to use sticky immersion.</p><p>The code to put the app <a class="indexterm" id="id00087"/>in the fullscreen sticky immersion mode is as follows:</p><div><pre class="programlisting">@Override
public void onWindowFocusChanged(boolean hasFocus) {
  super.onWindowFocusChanged(hasFocus);
  if (hasFocus) {
    View decorView = getWindow().getDecorView();
    decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
      | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
      | View.SYSTEM_UI_FLAG_FULLSCREEN
      | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
      | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
      | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
  }
}</pre></div><p>In this case, as in the previous one, we are requesting the use of a stable layout, and we are making it as if it is fullscreen. This time, we include a flag to make the stable layout the one with no Navigation bar (<code class="literal">SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</code>).</p><p>We also add the flags to hide the Status bar (fullscreen) and the Navigation bar (hide navigation). Finally, we <a class="indexterm" id="id00088"/>ask for the immersive sticky mode. The result is a real fullscreen game:</p><div><img alt="Android 4.4 and beyond – immersive mode" src="img/B04757_01_15.jpg"/><div><p>Immersive mode gives us all the screen space on the device</p></div></div><p>With this configuration, even when the user does a gesture to show the Status and Navigation bars, they are shown in a semitransparent way overlaid on top of our UI:</p><div><img alt="Android 4.4 and beyond – immersive mode" src="img/B04757_01_16.jpg"/><div><p>When the bars are shown while in sticky immersion mode, they are overlaid and semi transparent</p></div></div><p>Unfortunately, the sticky mode requires us to add the <code class="literal">SYSTEM_UI_FLAG_HIDE_NAVIGATION</code> flag to put the Navigation bar in the sticky mode. This has a very bad side-effect in the previous versions of Android, making the Navigation bar appear and disappear continuously as soon as you touch the screen, since this flag without the immersive mode means something different.</p><p>In addition to this, the <code class="literal">SYSTEM_UI_FLAG_LOW_PROFILE</code> flag does not have any effect on the versions in which the immersive mode is available. This makes sense, since it is considered a replacement and <a class="indexterm" id="id00089"/>an improvement on it.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec00009"/>Putting fullscreen together</h3></div></div></div><p>Since we have two different <a class="indexterm" id="id00090"/>modes for requesting fullscreen, one prior to KitKat (low profile) and one from KitKat (immersive mode), and the flags for hiding the Navigation bar do not play together nicely, we need to make a different configuration based on which version of Android the device is running on:</p><div><pre class="programlisting">@Override
public void onWindowFocusChanged(boolean hasFocus) {
  super.onWindowFocusChanged(hasFocus);
  if (hasFocus) {
    View decorView = getWindow().getDecorView();
    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {
      decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
        | View.SYSTEM_UI_FLAG_FULLSCREEN
        | View.SYSTEM_UI_FLAG_LOW_PROFILE);
    }
    else {
      decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
        | View.SYSTEM_UI_FLAG_FULLSCREEN
        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
    }
  }
}</pre></div><p>With this code, we give the expected game experience to each one of the Android versions; a low profile with a dimmed Navigation bar on the versions older than KitKat and the full-immersive mode <a class="indexterm" id="id00091"/>on the newer devices.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00013"/>Good practices for game developers</h1></div></div></div><p>In general, you should <a class="indexterm" id="id00092"/>avoid premature optimization. This means, do not optimize your code unless you have a performance problem.</p><p>Nevertheless, in games, we have two methods (<code class="literal">onUpdate</code> and <code class="literal">onDraw</code>) for which the execution time is critical. So, we will be providing a few tips that should be enough to get performance under a reasonable threshold.</p><p>For the rest of the cases, your code will be probably good. If you find a performance problem, you should measure it carefully to find where the bottleneck is and only then optimize it. Most of the time, the problem is not where we think it is. Premature optimization can lead to a less readable code without significant improvement.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00024"/>Object pools</h2></div></div></div><p>The creation and <a class="indexterm" id="id00093"/>destruction of objects is an expensive operation that should be limited. This is one area where a real-time game is a lot more sensitive than an app.</p><p>Every time you create an object, the garbage collector has a chance to be run. In the old versions of Android, it meant that everything stopped for 200ms. While it is no longer this bad, it may still be noticeable.</p><div><div><h3 class="title"><a id="note00011"/>Note</h3><p>We should avoid object creation as much as we can.</p></div></div><p>We want to avoid any expensive operation to be performed inside the <code class="literal">onUpdate</code> method—which must run as fast as it can—so we are going to take the creation and destruction of objects out of it.</p><p>The solution for this is a well-known software pattern called <strong>object pool</strong>.</p><p>Before we start the game, we will precreate the objects we are going to need and put them in a pool. The pool can <a class="indexterm" id="id00094"/>be something as simple as a stack or list.</p><p>Instead of creating an object, we will pick one from the pool and initialize it. If the pool is empty, it means that we underestimated the number of objects. So as a lesser evil, a new instance of the object must be created.</p><p>Instead of destroying an object, we will put it back into the pool.</p><p>The fact that we have to return objects to the pool forces us to figure out when an object is no longer needed instead of just relying on the garbage collector to do that for us. While it requires a bit of effort, this mental exercise will improve the game performance and structure. If you have ever worked with C++, this should be easy-peasy for you.</p><p>We will use object pools for all the game objects in the code; this means enemies and bullets basically.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00025"/>Avoiding enhanced loop syntax in lists</h2></div></div></div><p>Related to the <a class="indexterm" id="id00095"/>object creation, we should avoid the use of an enhanced loop syntax in the lists. While the for-each syntax is easier to read, it creates an iterator on-the-fly, which makes the execution slower and gives the garbage collector a chance to be run.</p><p>In the case of the <code class="literal">onUpdate</code> method of <code class="literal">GameEngine</code>, we could have written it using the for-each syntax like this:</p><div><pre class="programlisting">public void onUpdate(long elapsedMillis) {    
  for (GameObject gameObject : mGameObjects) {
    gameObject.onUpdate(elapsedMillis, this);
  }
}</pre></div><p>But this is significantly slower than using the standard for loop syntax. This is why it looks like this instead:</p><div><pre class="programlisting">public void onUpdate(long elapsedMillis) {
  int numGameObjects = mGameObjects.size();
  for (int i=0; i&lt;numGameObjects; i++) {
    mGameObjects.get(i).onUpdate(elapsedMillis, this);
  }
}</pre></div><p>In the particular case of arrays, the enhanced syntax is as fast as the traditional one on the devices with the <strong>JIT</strong> (<strong>just-in-time</strong>) compiler—which should be the case for all devices nowadays—so there is no drawback in always using the default loop syntax instead of the enhanced one.</p><p>It is also important to <a class="indexterm" id="id00096"/>use a variable for the size instead of requesting it for every iteration, which leads us to the next tip.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00026"/>Precreating objects</h2></div></div></div><p>Related to the <a class="indexterm" id="id00097"/>inefficiency of creating objects inside the <code class="literal">onUpdate</code> loop, we should always precreate the objects we are going to use.</p><p>A good example of this practice is the <code class="literal">Runnable</code> objects that are created inside the <code class="literal">GameObject</code> to run <code class="literal">onRemovedFromGameUiThread</code> and <code class="literal">onAddedToGameUiThread</code>.</p><p>We could create them on-demand inside the game engine as a part of <code class="literal">addGameObject</code> and <code class="literal">removeGameObject</code>, but it will be much less efficient.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00027"/>Accessing variables directly</h2></div></div></div><p>As often as we can, we <a class="indexterm" id="id00098"/>will use a direct variable access instead of using getters and setters. This is a good practice in general, since accessors are expensive and the compiler does not inline them.</p><p>In the case of games, it makes sense to extend this practice to variables of other classes. As we mentioned several times before, the execution time of <code class="literal">onUpdate</code> and <code class="literal">onDraw</code> is critical; a difference of just milliseconds counts. This is why, when variables from the game objects are accessed by other game objects, we make them public and work with them directly.</p><p>This is a bit counter-intuitive for Java developers, since we are used to encapsulating everything through getters and setters. In this case, efficiency is more important than encapsulation.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00028"/>Being careful with floating points</h2></div></div></div><p>In the case of doing <a class="indexterm" id="id00099"/>calculations, integer operations are about twice as fast as float operations.</p><p>When integers are not enough, there is no real difference in speed between float and double. The only difference is in space, where doubles are twice as large.</p><p>Also, even for integers, some processors have hardware multiply, but lack hardware divide. In such cases, integer division and modulus operations are performed in the software. All in all, this is <a class="indexterm" id="id000100"/>a case where premature optimization can harm you.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec00029"/>Performance myths – avoid interfaces</h2></div></div></div><p>On the older versions of Android, before the JIT compiler was introduced, accessing methods via an interface <a class="indexterm" id="id000101"/>instead of the exact type was slightly more efficient. In these versions, it made sense to declare a variable of <code class="literal">ArrayList</code> instead of the generic List interface to access the class directly.</p><p>In the modern versions of Android, however, there is no difference between accessing a variable via an interface and doing it directly. So, for the sake of generality, we will be using the generic interface instead of the class, as seen inside the <code class="literal">GameEngine</code>:</p><div><pre class="programlisting">private List&lt;GameObject&gt; mGameObjects = new ArrayList&lt;GameObject&gt;();</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec00014"/>Summary</h1></div></div></div><p>After a quick introduction to the question of which tools are best to make which types of games, we have described the pros and cons of using the bare Android SDK for making games.</p><p>We have set up a project and defined the main activity and its orientation. We have created a basic game engine, included it in the project, and checked whether it works as expected.</p><p>Later, we have extended the project with a second fragment and a pause dialog, managed the lifecycle of the game properly, and defined a way to get a proper fullscreen for different Android versions.</p><p>Finally, we have covered a few tips on optimizing the code inside the critical sections of the game.</p><p>We are ready to start handling the user input.</p></div>
<div><div><div><div><h1 class="title"><a id="ch22"/>Chapter 2. Managing User Input</h1></div></div></div><p>In this chapter, we will learn how to handle user input in a generic way and later expand it to be either a virtual joystick, sensors, or an external controller.</p><p>To get a visual feedback of the input, we will be placing a spaceship on the screen and moving it around. We will also make it fire some bullets. This will also help you understand the interaction between the game objects and the game engine.</p><p>We will extend the generic <code class="literal">InputController</code> class to make the simplest keypad controller possible to understand how the class fits in the existing architecture and how the input is processed and read inside the game objects.</p><p>Once we get the basic keypad working, we will implement a virtual joystick, which is a much better way of handling user input.</p><p>Managing physical controllers is also important for the game we are writing, so we will see how to detect them and handle different options.</p><p>Finally, we will talk a bit about using sensors as controls. They are not a good fit for this type of game, but we will cover the basics and provide some links if you want to explore further.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec00015"/>The InputController base class</h1></div></div></div><p>It does not <a class="indexterm" id="id000102"/>matter how we want to control the game; it can always be abstracted as a two-axis joystick and a button to fire. For other games this could be different, but you should always be able to extract basic actions from the user and create an <code class="literal">InputController</code> that handles them. The <code class="literal">InputController</code> we are building is useful for any game that uses directional control.</p><div><div><h3 class="title"><a id="note00012"/>Note</h3><p>Input controllers are quite specific to each type of game.</p></div></div><p>We are going to consider a normalized horizontal and vertical axis as an input (going from -1 to 1). In the case of a controller that does not have a range, we will just set it to the maximum. This will allow us to handle user input with precision when the type of input allows us to, as is the case with virtual and real joysticks as well as with sensors.</p><div><img alt="The InputController base class" src="img/B04757_02_01.jpg"/><div><p>The coordinate system of a phone screen</p></div></div><p>Just as a reminder, the coordinates on a computer screen have [0,0] in the top-left corner and go positive towards to the right and down. The bottom-right corner has coordinates <strong>[width, height]</strong>. This is different from the standard coordinate system we are used to, but it is very <a class="indexterm" id="id000103"/>important that you remember it.</p><p>This is why moving left is -1 and moving to the top is -1 as well.</p><p>The base class for all the input controllers in our game is going to be as follows:</p><div><pre class="programlisting">public class InputController {

  public double mHorizontalFactor;
  public double mVerticalFactor;

  public boolean mIsFiring;

  public void onStart() {
  }

  public void onStop() {
  }

  public void onPause() {
  }

  public void onResume() {
  }
}</pre></div><p>Note that this is a class with public variables. It is done this way to avoid reading the values via a method. We mentioned that in the previous chapter as a performance improvement.</p><p>Each implementation of this class will be responsible for having these variables populated with the updated values. The game objects can read them during <code class="literal">onUpdate</code>. By doing this, we separate the action of <a class="indexterm" id="id000104"/>using the values from the game objects from the reading of the user input.</p><div><div><h3 class="title"><a id="note00013"/>Note</h3><p><code class="literal">InputController</code> isolates the reading of the input from its usage via the game objects.</p></div></div><p><code class="literal">InputController</code> is a part of the <code class="literal">GameEngine</code>. We just add a variable of this type to the engine and create a method to set it:</p><div><pre class="programlisting">public InputController mInputController;

public void setInputController(InputController controller) {
  mInputController = controller;
}</pre></div><p>The methods <code class="literal">onStart</code>, <code class="literal">onStop</code>, <code class="literal">onPause</code>, and <code class="literal">onResume</code> are called from the <code class="literal">GameEngine</code>, when the game is started, stopped, paused, or resumed. Some input controllers will need to do special actions in such situations.</p><p>Finally, we add the input controller to the <code class="literal">GameEngine</code> during the initialization of the engine inside the <code class="literal">GameFragment</code>:</p><div><pre class="programlisting">mGameEngine = new GameEngine(getActivity());
mGameEngine.addGameObject(new ScoreGameObject(view, R.id.txt_score));
view.findViewById(R.id.btn_play_pause).setOnClickListener(this);
<strong>mGameEngine.setInputController(new InputController());</strong>
mGameEngine.addGameObject(new Player(getView()));
mGameEngine.startGame();</pre></div><p>For now, we are adding an input controller that does nothing. We are also adding a <code class="literal">Player</code> game object, which we are going to work on before going into the different input controllers in more detail.</p><p>Note that we are no <a class="indexterm" id="id000105"/>longer using the <code class="literal">ScoreGameObject</code> from the previous example and it should not be added to the game engine.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00030"/>The Player object</h2></div></div></div><p>The first version of the <a class="indexterm" id="id000106"/>
<code class="literal">Player</code> game object we are going to <a class="indexterm" id="id000107"/>build will just initialize its coordinates in the middle of the screen. Then, it will update them based on the information in the input controller and, finally, it will display the value as [x, y] in the <code class="literal">TextView</code> we have on the layout.</p><p>After this, we will make it display a spaceship located at the coordinates. But for now, we will focus on how <code class="literal">onUpdate</code> is implemented.</p><p>The code for <code class="literal">onUpdate</code> and <code class="literal">onDraw</code> of the first version of the <code class="literal">Player</code> class is as follows:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  InputController inputController = gameEngine.inputController;
  mPositionX += mSpeedFactor*inputController.mHorizontalFactor*elapsedMillis;
  if (mPositionX &lt; 0) {
    mPositionX = 0;
  }
  if (mPositionX &gt; mMaxX) {
    mPositionX = mMaxX;
  }
  mPositionY += mSpeedFactor*inputController.mVerticalFactor*elapsedMillis ;
  if (mPositionY &lt; 0) {
    mPositionY = 0;
  }
  if (mPositionY &gt; mMaxY) {
    mPositionY = mMaxY;
  }
}

@Override
public void onDraw() {
  mTextView.setText("["+(int) (mPositionX)+","+(int) (mPositionY)+"]");
}</pre></div><p>So, in each run of <code class="literal">onUpdate</code>, we will increase the <code class="literal">x</code> and <code class="literal">y</code> position using the corresponding factor (which we read from the input controller), a speed factor, and the elapsed milliseconds. This is nothing more than the classic formula <em>distance = speed * time</em>.</p><p>The rest of the code ensures that the <em>x</em> and <em>y</em> positions stay inside the boundaries of the screen.</p><p>The <code class="literal">onDraw</code> method is equivalent to the one of <code class="literal">ScoreGameObject</code>, but it just sets text in <code class="literal">TextView</code>.</p><p>Now there are a few values in this code that we have not initialized. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mSpeedFactor</code>: The speed converted into pixels per millisecond.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mMaxX</code>: The maximum value for <code class="literal">x</code>. It will be the width of the view minus the paddings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mMaxY</code>: The maximum value for <code class="literal">y</code>. It is the height of the view minus the padding.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mTextView</code>: The view in which we set the current coordinates.</li></ul></div><p>All these elements are <a class="indexterm" id="id000108"/>initialized on the constructor of the <code class="literal">Player</code> object that receives the parent view as a parameter:</p><div><pre class="programlisting">public Player(final View view) {
  // We read the size of the view
  double pixelFactor = view.getHeight() / 400d;
  mSpeedFactor = pixelFactor * 100d / 1000d;
  mMaxX = view.getWidth() - view.getPaddingRight() - view.getPaddingRight();
  mMaxY = view.getHeight() - view.getPaddingTop() - view.getPaddingBottom();

  mTextView = (TextView) view.findViewById(R.id.txt_score);
}</pre></div><p>We calculate the pixel factor of our screen, taking a height of 400 units as a reference. This is an arbitrary number and you can use whatever makes sense to you. It will help if you think of working with a 400 px tall screen and then let the code convert it to the real amount of pixels.</p><p>This is a concept that is similar to dips, but also different. While dips are meant to have the same physical size among all devices, the units make our game scale. So, all the items of the game will take the same amount of screen space regardless of the resolution or size of the device.</p><div><div><h3 class="title"><a id="note00014"/>Note</h3><p>We will define the game space in "units" so all the devices have the same screen height.</p></div></div><p>We want our ship to move at a speed of 100 units per second, so moving across the screen from its bottom to the top takes 4 seconds. Since we need the speed in pixels per millisecond, we need to multiply the desired speed with the pixel factor (pixels/unit) and divide it by 1,000 (milliseconds/second).</p><p>The next step is to read the width and height of the parent view and use them as the maximum width and height after subtracting the padding.</p><p>Finally, we get a hook into the <code class="literal">TextView</code> that we are going to use to display the coordinates.</p><p>Once we have finished the initialization, we still have the <code class="literal">startGame</code> method. In this one, we will position our player in the middle of the screen.</p><div><pre class="programlisting">@Override
public void startGame() {
  mPositionX = mMaxX / 2;
  mPositionY = mMaxY / 2;
}</pre></div><p>If you try and run the example now, you will see that the position stays at [0,0], indicating that something is going wrong.</p><p>The problem is that we are reading the width and height of a view straight after it is created (inside the <code class="literal">onViewCreated</code> method of the <code class="literal">GameFragment</code>). At this moment, the view has not yet been measured.</p><div><div><h3 class="title"><a id="note00015"/>Note</h3><p>You cannot obtain the <a class="indexterm" id="id000109"/>width and/or height of a view during the constructor, as it has not been measured yet.</p></div></div><p>The solution for this is to delay the initialization of the <code class="literal">GameEngine</code> until the view has been measured. The best way to do this is to use <code class="literal">ViewTreeObserver</code>. Let's go to the <code class="literal">onViewCreated</code> of the <code class="literal">GameFragment</code> and update it:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  view.findViewById(R.id.btn_play_pause).setOnClickListener(this);
  final ViewTreeObserver obs = view.getViewTreeObserver();
  obs.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
      @Override
      public void onGlobalLayout() {
        if(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {
          obs.removeGlobalOnLayoutListener(this);
        }
        else {
          obs.removeOnGlobalLayoutListener(this);
        }
        mGameEngine = new GameEngine(getActivity());
        mGameEngine.setInputController(new BasicInputController(getView()));
        mGameEngine.addGameObject(new Player(getView()));
        mGameEngine.startGame();
      }
  });
}</pre></div><p>We get the <code class="literal">ViewTreeObserver</code> of the view that has just been created for the layout and add a new <code class="literal">OnGlobalLayoutListener</code> to it. We create the listener as an anonymous inner class.</p><p>This listener will be called every time a global layout is performed. To avoid being called multiple times and, therefore, initializing multiple engines, we need to remove the listener as soon as it is called.</p><p>Unfortunately, there was a typo in the name of the method used to remove the listener in Android versions prior to Jelly Bean, so we have to use one method name for versions before Jelly Bean and another one for later versions.</p><p>The rest of the code inside the <a class="indexterm" id="id000110"/>method is the engine initialization, which was previously done directly inside <code class="literal">onViewCreated</code>. We just moved it inside <code class="literal">onGlobalLayout</code>.</p><p>Note that, while the views have not been measured yet, they have been created and they exist. So, there is no need to move the code that sets the <code class="literal">OnClickListener</code> for the pause button to the layout observer.</p><p>If we go on and run this version, we will see that the coordinates show the value of the center of the screen in pixels.</p><div><img alt="The Player object" src="img/B04757_02_02.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec00010"/>Displaying a spaceship</h3></div></div></div><p>All this is not fun if we <a class="indexterm" id="id000111"/>don't at least show a spaceship, so we can see that something is really happening.</p><p>We are going to take the graphics for the game from the OpenGameArt website (<a class="ulink" href="http://opengameart.org">http://opengameart.org</a>), which contains multiple free—as in freedom—graphics for games, most of them under a Creative Commons license, which means you have to credit the author.</p><div><div><h3 class="title"><a id="note00016"/>Note</h3><p>The OpenGameArt.org website is a great resource for game graphics.</p></div></div><p>The spaceships we are going to show were created by Eikesteer and we will use them throughout the game.</p><div><img alt="Displaying a spaceship" src="img/B04757_02_03.jpg"/><div><p>The spaceship set made by Eikesteer that we picked from Open Game Art</p></div></div><p>From the set, we will use the third from the right. We can extract it to a new image using a simple editor such as GIMP and place it under the <code class="literal">drawable-nodpi</code> directory.</p><p>Note that we are going to scale everything to be consistent with our 400 units of screen height, so it does not make sense to put the image in a drawable directory that has a density qualifier. This is why we are going to use <code class="literal">drawable-nodpi</code>.</p><p>The <code class="literal">drawable-nodpi</code> directory is meant to be independent from any density, while <code class="literal">drawable</code> is meant for images that do not have a qualifier. This means that the behavior is different when we try to read the intrinsic size of a drawable image. The intrinsic size will return the real size <a class="indexterm" id="id000112"/>when placed under <code class="literal">nodpi</code> and will depend on the device when read from <code class="literal">drawable</code>.</p><div><div><h3 class="title"><a id="note00017"/>Note</h3><p>We will place our game object images in the <code class="literal">drawable-nodpi</code> folder.</p></div></div><p>The next step is to create an <code class="literal">ImageView</code> to display our spaceship. We are going to do this inside the constructor of the <code class="literal">Player</code> object:</p><div><pre class="programlisting">public Player(final View view) {

  [...]

  // We create an image view and add it to the view
  mShip = new ImageView(view.getContext());
  Drawable shipDrawable = view.getContext().getResources()
    .getDrawable(R.drawable.ship);
  mShip.setLayoutParams(new ViewGroup.LayoutParams(
    (int) (shipDrawable.getIntrinsicWidth() * mPixelFactor),
    (int) (shipDrawable.getIntrinsicHeight() * mPixelFactor)));
  mShip.setImageDrawable(shipDrawable);

  mMaxX -= (shipDrawable.getIntrinsicWidth()*mPixelFactor);
  mMaxY -= (shipDrawable.getIntrinsicHeight()*mPixelFactor);

  ((FrameLayout) view).addView(mShip);
}</pre></div><p>The first part of the constructor remains unchanged. We then add the code to create the <code class="literal">ImageView</code> and load the <code class="literal">Drawable</code> into it.</p><p>First, we create an <code class="literal">ImageView</code> using the <code class="literal">Context</code> of the parent view and we store it as a class variable.</p><p>Then, we load the <code class="literal">Drawable</code> of the ship from the resources and assign it to the <code class="literal">shipDrawable</code> local variable.</p><p>We proceed to create a <code class="literal">LayoutParams</code> object for the <code class="literal">ImageView</code> and set it. Since we already have the drawable, we can specify the exact dimensions for it. For this, we read the intrinsic width and height of the <code class="literal">shipDrawable</code> and multiply it by the pixel factor.</p><p>This means that the <code class="literal">ImageView</code> of the spaceship will be scaled to the equivalent of a 400-unit screen in pixels. Another way to say this is that the spaceship is the exact same size as it would be if displayed on a 400-pixel-tall screen. The drawable is then set to the <code class="literal">ImageView</code>.</p><p>We also have to update the maximum value of <em>x</em> and <em>y</em> by subtracting the size of the ship. With this, it gets placed in the center and it does not go outside the borders.</p><p>Finally, the <code class="literal">ImageView</code> is added to the parent view, which is expected to be a <code class="literal">FrameLayout</code>. This new requirement comes from the need to be able to position the image anywhere.</p><p>This is something we need to <a class="indexterm" id="id000113"/>update or we will get a <code class="literal">ClassCastException</code>. We are updating the <code class="literal">fragment_game.xml</code> layout to have a top layout of the <code class="literal">FrameLayout</code> type.</p><p>Now that we are touching the layout, we will also align the pause button to the top right, which is where the pause button for most games is:</p><div><pre class="programlisting">&lt;FrameLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  android:paddingTop="@dimen/activity_vertical_margin"
  android:paddingLeft="@dimen/activity_horizontal_margin"
  android:paddingRight="@dimen/activity_horizontal_margin"
  tools:context="com.plattysoft.yass.counter.GameFragment"&gt;

  &lt;TextView
    android:layout_gravity="top|left"
    android:id="@+id/txt_score"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" /&gt;

  &lt;Button
    android:layout_gravity="top|right"
    android:id="@+id/btn_play_pause"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/pause" /&gt;
&lt;/FrameLayout&gt;</pre></div><p>Finally, we need to update the <code class="literal">onDraw</code> method to make it display the spaceship in the right position. For this, we just translate the <code class="literal">ImageView</code> to the expected position on the screen using <code class="literal">translateX</code> and <code class="literal">translateY</code>.</p><p>This is far from optimal, but we will work on the drawing in the next chapter. For now, it serves the purpose of displaying the image at the right position:</p><div><pre class="programlisting">@Override
public void onDraw() {
  mTextView.setText("["+(int) (mPositionX)+","+(int) (mPositionY)+"]");
  mShip.setTranslationX((int) mPositionX);
  mShip.setTranslationY((int) mPositionY);
}</pre></div><p>If we launch our game, we can <a class="indexterm" id="id000114"/>see the spaceship in the middle of the screen:</p><div><img alt="Displaying a spaceship" src="img/B04757_02_04.jpg"/></div><p>Now that we have a spaceship, it is time to add some bullets to the mix.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec00011"/>Firing bullets</h3></div></div></div><p>The spaceship will fire <a class="indexterm" id="id000115"/>bullets that will move upward until they are outside the screen.</p><p>As we mentioned in the <code class="literal">Good practices for game developers</code> section of the previous chapter, we will use an object pool for the bullets that we will create inside the <code class="literal">Player</code> class:</p><div><pre class="programlisting">List&lt;Bullet&gt; mBullets = new ArrayList&lt;Bullet&gt;();

private void initBulletPool() {
  for (int i=0; i&lt;INITIAL_BULLET_POOL_AMOUNT; i++) {
    mBullets.add(new Bullet(mPixelFactor));
  }
}

private Bullet getBullet() {
  if (mBullets.isEmpty()) {
    return null;
  }
  return mBullets.remove(0);
}

private void releaseBullet(Bullet b) {
  mBullets.add(b);
}</pre></div><p>It initializes the number of bullets we want to have on the screen at a certain point. If you ask for a bullet when the pool has items it will just remove one and return it, but if the list is empty, it will return null. You can make this number a limitation to impact the gameplay or you can do the math and make the pool large enough.</p><p>In our case, we cannot fire more than 6 bullets, given the speed of the bullets and the time between shots.</p><p>Back to the pool, to release a bullet we will simply put it back into the list.</p><p>Now, during the <code class="literal">onUpdate</code> of the player, we check if we should fire a bullet:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  updatePosition(elapsedMillis, gameEngine.mInputController);
  checkFiring(elapsedMillis, gameEngine);
}

private void checkFiring(long elapsedMillis, GameEngine gameEngine) {
  if (gameEngine.mInputController.mIsFiring
      &amp;&amp; mTimeSinceLastFire &gt; TIME_BETWEEN_BULLETS) {
    Bullet b = getBullet();
    if (b == null) {
      return;
    }
    b.init(mPositionX + mShip.getWidth()/2, mPositionY);
    gameEngine.addGameObject(b);
    mTimeSinceLastFire = 0;
  }
  else {
    mTimeSinceLastFire += elapsedMillis;
  }
}</pre></div><p>We check whether the <a class="indexterm" id="id000116"/>input controller has the fire button pressed and whether the cool down time has passed. If we want and can fire a bullet we take one from the pool.</p><p>If there is no bullet available (the object b is null), we do nothing else and return.</p><p>Once we get a <code class="literal">Bullet</code> from the pool, we initialize it using the current position and place it in the middle of the spaceship. Then, we add it to the engine. To conclude, we reset the time since the last fire.</p><p>If we cannot or do not want to fire, we just add the elapsed milliseconds to the time since the last bullet was fired.</p><div><img alt="Firing bullets" src="img/B04757_02_05.jpg"/></div><p>In the preceding image, we can see the relative position of the bullet with the spaceship and why passing the <em>x</em> coordinate as the center of the spaceship gives the right information to the bullet. But we still need to add some offsets to it.</p><p>From this moment on, all the <a class="indexterm" id="id000117"/>logic regarding the movement of the bullet is done inside the <code class="literal">Bullet</code> object.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00031"/>The Bullet game object</h2></div></div></div><p>The <code class="literal">Bullet</code> <a class="indexterm" id="id000118"/>extends <code class="literal">GameObject</code> as well. <a class="indexterm" id="id000119"/>And, as the spaceship does, it also creates an <code class="literal">ImageView</code> and loads the drawable into it as part of the constructor:</p><div><pre class="programlisting">public Bullet(View view, double pixelFactor) {
  Context c = view.getContext();

  mSpeedFactor = pixelFactor * -300d / 1000d;

  mImageView = new ImageView(c);
  Drawable bulletDrawable = c.getResources().getDrawable(R.drawable.bullet);

  mImageHeight = bulletDrawable.getIntrinsicHeight() * pixelFactor;
  mImageWidth = bulletDrawable.getIntrinsicWidth() * pixelFactor;

  mImageView.setLayoutParams(new ViewGroup.LayoutParams(
    (int) (mImageWidth),
    (int) (mImageHeight)));
  mImageView.setImageDrawable(bulletDrawable);

  mImageView.setVisibility(View.GONE);
  ((FrameLayout) view).addView(mImageView);
}</pre></div><p>The only difference between this constructor and the one for the <code class="literal">Player</code> object is that we set the visibility of <code class="literal">ImageView</code> to <code class="literal">GONE</code>, since the bullets are not supposed to be displayed unless they are being fired. The <code class="literal">Bullet</code> also has an <code class="literal">mPositionX</code> and <code class="literal">mPositionY</code> used for drawing.</p><p>These similarities come from the fact that both the game objects are what we call<strong> sprites</strong>. Sprite is a <a class="indexterm" id="id000120"/>
<code class="literal">GameObject</code> that has an image associated with it and gets rendered on the screen.</p><div><div><h3 class="title"><a id="note00018"/>Note</h3><p>Sprite is a game object (generally a 2D image) that is displayed in a game and manipulated as a single entity.</p></div></div><p>In the next chapter, we will extract the common concepts of sprite and put them in a base class.</p><p>In the constructor, we also set the speed of the bullet to 300 units per second. This is 3 times faster than the spaceship. You can play with the values of speed and time between bullets, but remember to test that they do not overlap during continuous fire while the spaceship moves upward.</p><p>If you modify the bullet speed, you may also need to check the size of the pool. The worst case is to continuously fire with the spaceship placed at the bottom of the screen.</p><p>The next interesting point is initialization. This is done using the <code class="literal">init</code> method that receives the position of the spaceship:</p><div><pre class="programlisting">public void init(Player parent, double positionX, double positionY) {
  mPositionX = positionX - mImageWidth/2;
  mPositionY = positionY - mImageHeight/2;
  mParent = parent;
}</pre></div><p>It is worth mentioning <a class="indexterm" id="id000121"/>that we want to position the bullet a bit ahead of the spaceship and properly centered. Since the member variables <code class="literal">mPositionX</code> and <code class="literal">mPositionY</code> are pointing to the top-left corner of the image, we have to apply an offset to the initial parameters based on the size of the bullet.</p><p>We are positioning the bullet only half way outside the spaceship on the vertical axis (<em>mImageHeight/2</em>) to improve the feeling of it being shot from the spaceship. We are also displaying it centered on the horizontal axis, which is why we also subtract <em>mImageWidth/2</em>.</p><p>The image in the previous section will also help you visualize this offset.</p><p>Because the <code class="literal">Bullets</code> are added and removed from the <code class="literal">GameEngine</code>, we need to change the visibility of the view when <a class="indexterm" id="id000122"/>they are added and removed. This needs to be done on the <code class="literal">UIThread</code>. For this purpose, we use the callbacks we created in the previous chapter:</p><div><pre class="programlisting">@Override
public void onRemovedFromGameUiThread() {
  mImageView.setVisibility(View.GONE);
}

@Override
public void onAddedToGameUiThread() {
  mImageView.setVisibility(View.VISIBLE);
}</pre></div><div><div><h3 class="title"><a id="note00019"/>Note</h3><p>All changes to the view must be done on the <code class="literal">UIThread</code>, otherwise an exception will be thrown.</p></div></div><p>Since these bullets are also <a class="indexterm" id="id000123"/>sprites, the <code class="literal">onDraw</code> method is almost identical to the one of the player. We do it again by animating the view and translating it:</p><div><pre class="programlisting">@Override
public void onDraw() {
  mImageView.setTranslationX((int) mPositionX);
  mImageView.setTranslationY((int) mPositionY);
}</pre></div><p>On the other hand, the <code class="literal">onUpdate</code> method is a bit different and it is interesting to look at it in detail:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  mPositionY += mSpeedFactor * elapsedMillis;
  if (mPositionY &lt; -mImageHeight) {
    gameEngine.removeGameObject(this);
    // And return it to the pool
    mParent.releaseBullet(this);
  }
}</pre></div><p>Similar to what we did with the player, we use the <em>distance = speed * time</em> formula. But, in this case, there is no influence from the <code class="literal">InputController</code> at all. The bullet has a fixed vertical speed.</p><p>We also check whether the bullet is out of the screen. Since we draw the items in the top-left corner, we need it to be completely gone. This is why we compare with <code class="literal">mImageHeight</code>.</p><p>If the bullet is out, we remove it from the <code class="literal">GameEngine</code> and we return it to the pool by calling <code class="literal">releaseBullet</code>.</p><p>This game object removal is done inside the <code class="literal">onUpdate</code> loop of the <code class="literal">GameEngine</code>. If we modify the list at this moment, we will get an <code class="literal">ArrayIndexOutOfBoundsException</code> while executing <code class="literal">onUpdate</code> in the <code class="literal">GameEngine</code>. This is why the <code class="literal">removeGameObject</code> method puts the objects in a separate list to be removed after <code class="literal">onUpdate</code> is called.</p><p>Now, all this is useless <a class="indexterm" id="id000124"/>unless we can move the spaceship and <a class="indexterm" id="id000125"/>fire the bullets. Let's build the most basic <code class="literal">InputController</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00016"/>The most basic virtual keypad</h1></div></div></div><p>The simplest we can go <a class="indexterm" id="id000126"/>is to build a simple keypad in the shape of a cross on the left-hand side of the screen and a fire button on its right-hand side. For this layout, we are going to create a new file under the <code class="literal">layout</code> folder and call it <code class="literal">view_keypad.xml</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_gravity="bottom"
  android:padding="@dimen/keypad_size"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"&gt;

  &lt;Button
    android:id="@+id/keypad_up"
    android:layout_alignParentTop="true"
    android:layout_toRightOf="@+id/keypad_left"
    android:layout_width="@dimen/keypad_size"
    android:layout_height="@dimen/keypad_size" /&gt;

  &lt;Button
    android:id="@+id/keypad_down"
    android:layout_below="@+id/keypad_left"
    android:layout_toRightOf="@+id/keypad_left"
    android:layout_width="@dimen/keypad_size"
    android:layout_height="@dimen/keypad_size" /&gt;

  &lt;Button
    android:id="@+id/keypad_left"
    android:layout_alignParentLeft="true"
    android:layout_below="@+id/keypad_up"
    android:layout_width="@dimen/keypad_size"
    android:layout_height="@dimen/keypad_size" /&gt;

  &lt;Button
    android:id="@+id/keypad_right"
    android:layout_toRightOf="@+id/keypad_up"
    android:layout_below="@+id/keypad_up"
    android:layout_width="@dimen/keypad_size"
    android:layout_height="@dimen/keypad_size" /&gt;

  &lt;Button
    android:id="@+id/keypad_fire"
    android:layout_alignParentRight="true"
    android:layout_alignTop="@+id/keypad_left"
    android:layout_width="@dimen/keypad_size"
    android:layout_height="@dimen/keypad_size" /&gt;
&lt;/RelativeLayout&gt;</pre></div><p>We have a relative layout that covers the screen's full width. It has a <code class="literal">layout_gravity</code> set to <code class="literal">bottom</code>, so we are assured that it will be properly aligned.</p><p>We have our four-button pad arranged in a <code class="literal">RelativeLayout</code>. The left button is aligned to the left of the layout and the up button is aligned to the top of the layout. Then, the top and bottom buttons are set to the <a class="indexterm" id="id000127"/>right of the left button. The right one is set below and to the right of the up button. Finally, the left one is set below the up button and the down button is just below the left. Sounds a bit too complicated, but the image is much clearer.</p><div><img alt="The most basic virtual keypad" src="img/B04757_02_06.jpg"/></div><p>On the other side of the screen, aligned to the right of the parent and to the top of the left button, we have a fire button.</p><p>You may have noticed that all the buttons are using a special dimension named <code class="literal">keypad_size</code>. This is a very important point, not only to make them all look the same, but for usability in general. We are setting it to 42 dp, which is the recommended minimum size for a touch target.</p><div><div><h3 class="title"><a id="note00020"/>Note</h3><p>The smallest size a touchable item should have is 42 dp.</p></div></div><p>Feel free to play with the size of the buttons and observe by yourself that a smaller size button is very hard to touch. In fact, for a game, we should always use large-sized touch targets, sometimes larger than the <a class="indexterm" id="id000128"/>area that provides visual feedback. The bigger you can make the touch area for a control, the better it is. In this example, the touch area of the fire button could be as large as the right half of the screen.</p><p>We are going to include this layout inside the game fragment, so we can see how it overlays. Since we already updated the top layout to be a <code class="literal">FrameLayout</code>, we just need to use an <code class="literal">include</code> tag.</p><div><pre class="programlisting">&lt;FrameLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:paddingTop="@dimen/activity_vertical_margin"
  android:paddingLeft="@dimen/activity_horizontal_margin"
  android:paddingRight="@dimen/activity_horizontal_margin"
  tools:context="com.plattysoft.yass.counter.GameFragment"&gt;

  &lt;TextView
    android:layout_gravity="top|left"
    android:id="@+id/txt_score"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" /&gt;

  &lt;Button
    android:layout_gravity="top|right"
    android:id="@+id/btn_play_pause"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/pause" /&gt;
  <strong>&lt;include layout="@layout/view_keypad" /&gt;</strong>
&lt;/FrameLayout&gt;</pre></div><p>If we just go on and run it, we can see how it looks all together.</p><div><img alt="The most basic virtual keypad" src="img/B04757_02_07a.jpg"/></div><p>Now let's write the code for the <code class="literal">BasicInputController</code> to handle the buttons. Starting with the constructor, the code is as follows:</p><div><pre class="programlisting">public BasicInputController(View view) {
  view.findViewById(R.id.keypad_up).setOnTouchListener(this);
  view.findViewById(R.id.keypad_down).setOnTouchListener(this);
  view.findViewById(R.id.keypad_left).setOnTouchListener(this);
  view.findViewById(R.id.keypad_right).setOnTouchListener(this);
  view.findViewById(R.id.keypad_fire).setOnTouchListener(this);
}</pre></div><p>We are setting the game <a class="indexterm" id="id000129"/>controller as the touch listener for all the buttons: up, down, left, right, and fire. It is important to note that we have to use <code class="literal">OnTouchListener</code> and not <code class="literal">OnClickListener</code>.</p><p>The <code class="literal">onClick</code> callback is only triggered when the button is pressed and then released. In our case, we need to know when the button is pressed and when it is released. We need to move the spaceship while the button is being pressed. This is why we need the more detailed callback that <code class="literal">OnTouchListener</code> provides.</p><p>The implementation of the method from <code class="literal">OnTouchListener</code> in the <code class="literal">BasicInputController</code> is as follows:</p><div><pre class="programlisting">@Override
public boolean onTouch(View v, MotionEvent event) {
  int action = event.getActionMasked();
  int id = v.getId();
  if (action == MotionEvent.ACTION_DOWN) {
    // User started pressing a key
    if (id == R.id.keypad_up) {
      mVerticalFactor -= 1;
    }
    else if (id == R.id.keypad_down) {
      mVerticalFactor += 1;
    }
    else if (id == R.id.keypad_left) {
      mHorizontalFactor -= 1;
    }
    else if (id == R.id.keypad_right) {
      mHorizontalFactor += 1;
    }
    else if (id == R.id.keypad_fire) {
      mIsFiring = false;
    }
  }
  else if (action == MotionEvent.ACTION_UP) {
    if (id == R.id.keypad_up) {
      mVerticalFactor += 1;
    }
    else if (id == R.id.keypad_down) {
      mVerticalFactor -= 1;
    }
    else if (id == R.id.keypad_left) {
      mHorizontalFactor += 1;
    }
    else if (id == R.id.keypad_right) {
      mHorizontalFactor -= 1;
    }
    else if (id == R.id.keypad_fire) {
      mIsFiring = false;
    }
  }
  return false;
}</pre></div><p>It is important to note that we are calling <code class="literal">getActionMasked</code> instead of <code class="literal">getAction</code>. In the case of multiple touch pointers, <code class="literal">getAction</code> includes pointer information while that information is removed when requested as a masked action. This is why the recommended way to handle multitouch is to to use <code class="literal">getActionMasked</code> and <code class="literal">getActionPointer</code>. Otherwise, you need to use the <code class="literal">OR</code> operation to check for the action instead of the equal or it won't work when the pointers above the first one are being read.</p><div><div><h3 class="title"><a id="note00021"/>Note</h3><p>Using <code class="literal">getActionMasked</code> and <code class="literal">getPointerIndex</code> is the recommended way to deal with multitouch.</p></div></div><p>We have two cases. When the action is <code class="literal">MotionEvent.ACTION_DOWN</code>, it means that the user has pressed a button, so we check for the ID of the view that was touched and act accordingly.</p><p>If the view is up or down, we subtract or add 1 to the vertical factor. Similarly, we subtract or add 1 to the horizontal factor if the touched button was left or right.</p><p>The second part, where we <a class="indexterm" id="id000130"/>handle the <code class="literal">MotionEvent.ACTION_UP</code> action, reverses the addition or subtraction to the corresponding factor.</p><p>We are adding and subtracting instead of setting the value to 1 or -1 for multitouch. For example, if you first tap on right and then on left, the spaceship should stop, since you are pressing on both buttons at the same time. Once you release one of them, the movement is restored.</p><p>For the fire button, we set <code class="literal">mIsFiring</code> to <code class="literal">true</code> when it is down and to <code class="literal">false</code> when it is up. Simple.</p><p>Finally, we return <code class="literal">false</code>. This is important, because it tells the system that the event was not consumed by our listener and, therefore, the chain of listeners can continue. This chain of listeners includes the button's own click listener, which is responsible for changing the background image to one consistent with the button's state. If we return true, updating the background will not happen.</p><div><div><h3 class="title"><a id="note00022"/>Note</h3><p><code class="literal">OnTouch</code> implementation returns whether the event was consumed by this listener or not.</p></div></div><p>As simple as this—we can run the game now. We will see that the spaceship moves around the screen and also fires some bullets. At last, YASS starts to look like a game.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00032"/>Limitations and problems</h2></div></div></div><p>There are several <a class="indexterm" id="id000131"/>limitations and problems with such a simple keypad. Apart <a class="indexterm" id="id000132"/>from the fact that the buttons are quite small and hard to handle, the rest of the issues come from when users move the touch pointer.</p><p>If the user moves outside the button, Android versions before API level 17 will trigger an event of the <code class="literal">MotionEvent.ACTION_DOWN</code> type, but from this API level onwards they will not. If you want to handle this situation properly, you need to check on every move or action and validate whether it gets out of the rectangle for the original view to do a manual cancel. But this is not the only problem with move. If you tap on one button and move towards the opposite one, a new tap on the other button will not be detected, since it is an <code class="literal">ACTION_MOVE</code> and not an <code class="literal">ACTION_DOWN</code>.</p><p>The solution for this is to check the position of each pointer in each event, see whether it is inside the rectangle of a button, and act accordingly.</p><p>There is also the problem of <a class="indexterm" id="id000133"/>not being able to handle diagonal movements.</p><p>We could try and solve these <a class="indexterm" id="id000134"/>problems for this keypad. But since it is not a very elegant input controller anyway, we will just move forward and make an <code class="literal">InputController</code> that is a proper virtual joystick instead.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00017"/>Creating a virtual joystick</h1></div></div></div><p>We are going to improve <a class="indexterm" id="id000135"/>the user input and we are going to do it by creating a virtual joystick.</p><p>A <strong>virtual joystick</strong> measures the distance from the touch position to its center and uses this information to set the values on the two axes. It behaves as a traditional analog joystick.</p><p>Since it is virtual, we are not constrained to have it at a specific position on the screen, so we can place it anywhere the player touches it.</p><p>We cannot, however, take the entire screen for the virtual joystick. There needs to be a fire button too.</p><p>We have experienced the frustration of small touch targets, so we are going to make the fire button as big as we can. This means that we are going to use half the screen for the virtual joystick and half the screen for the fire button.</p><p>The layout that we are going to use will have two views that fill the screen, each of them covering half of the width. We will name this layout <code class="literal">view_vjoystick.xml</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout 
  android:orientation="horizontal"
  android:layout_width="match_parent"
  android:layout_height="match_parent"&gt;

  &lt;View android:id="@+id/vjoystick_main"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:layout_weight="1"
  /&gt;
  &lt;View android:id="@+id/vjoystick_touch"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:layout_weight="1"
  /&gt;
&lt;/LinearLayout&gt;</pre></div><p>The interesting bit of this layout is the usage of Android:<code class="literal">layout_weight</code> to equally divide the screen into two halves. You can modify the weight value to make one view larger than the other if you want a larger space for the virtual joystick or the fire button.</p><p>We will create a class to handle this user <code class="literal">InputController</code>. We will call it <code class="literal">VirtualJoystickInputController</code> and it will, obviously, extend <code class="literal">InputController</code>.</p><p>To handle the events <a class="indexterm" id="id000136"/>of this <code class="literal">InputController</code>, we are going to use two internal classes. One for each view we want to listen to the events to:</p><div><pre class="programlisting">public VirtualJoystickInputController(View view) {
  view.findViewById(R.id.vjoystick_main)
    .setOnTouchListener(new VJoystickTouchListener());
  view.findViewById(R.id.vjoystick_touch)
    .setOnTouchListener(new VFireButtonTouchListener());

  double pixelFactor = view.getHeight() / 400d;
  mMaxDistance = 50*pixelFactor;
}</pre></div><p>The <code class="literal">mMaxDistance</code> variable defines how far from the touch we consider the user to have reached the maximum. The value is, again, in screen units. You can imagine the maximum distance as the radius of the virtual gamepad. The smaller this distance is, the more sensitive the joystick is.</p><p>A small maximum distance will allow quick reactions, while a large one will allow better precision. Feel free to experiment with its size to make it work as you'd like.</p><div><img alt="Creating a virtual joystick" src="img/B04757_02_07.jpg"/></div><p>The fire button is easier to handle than the virtual joystick. We use the same logic as in the previous example. Set <code class="literal">mIsFiring</code> to <code class="literal">true</code> when <a class="indexterm" id="id000137"/>the event is a down action and set it to <code class="literal">false</code> when the event is an up action:</p><div><pre class="programlisting">private class VFireButtonTouchListener implements View.OnTouchListener {
  @Override
  public boolean onTouch(View v, MotionEvent event) {
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
      mIsFiring = true;
    }
    else if (action == MotionEvent.ACTION_UP) {
      mIsFiring = false;
    }
    return true;
  }
}</pre></div><p>The listener for the virtual joystick is more interesting. We record the position of the touch when a down action is performed, we also reset the values when the touch goes up. But, as long as it moves, we update the values of <code class="literal">mHorizontalFactor</code> and <code class="literal">mVerticalFactor</code> based on the distance to the original touch:</p><div><pre class="programlisting">private class VJoystickTouchListener implements View.OnTouchListener {
  @Override
  public boolean onTouch(View v, MotionEvent event) {
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
      mStartingPositionX = event.getX(0);
      mStartingPositionY = event.getY(0);
    }
    else if (action == MotionEvent.ACTION_UP) {
      mHorizontalFactor = 0;
      mVerticalFactor = 0;
    }
    else if (action == MotionEvent.ACTION_MOVE) {
      // Get the proportion to the max
      mHorizontalFactor = (event.getX(0) - mStartingPositionX) / mMaxDistance;
      if (mHorizontalFactor &gt; 1) {
        mHorizontalFactor = 1;
      }
      else if (mHorizontalFactor &lt; -1) {
        mHorizontalFactor = -1;
      }
      mVerticalFactor = (event.getY(0) - mStartingPositionY) / mMaxDistance;
      if (mVerticalFactor &gt; 1) {
        mVerticalFactor = 1;
      }
      else if (mVerticalFactor &lt; -1) {
        mVerticalFactor = -1;
      }
    }
    return true;
  }
}</pre></div><p>Please note that we want to <a class="indexterm" id="id000138"/>keep <code class="literal">mHorizontalFactor</code> and <code class="literal">mVerticalFactor</code> between -1 and 1; thus, whenever the distance is larger than <code class="literal">mMaxDistance</code>, we do not consider it.</p><p>Finally, time to connect this new controller to the <code class="literal">GameEngine</code>. It is quite simple. We just have to update the layout for <code class="literal">fragment_game.xml</code>, including <code class="literal">view_vjoystick.xml</code> instead of <code class="literal">view_keypad.xml</code>, and then update the initialization of the <code class="literal">GameEngine</code>:</p><div><pre class="programlisting">&lt;FrameLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  android:paddingTop="@dimen/activity_vertical_margin"
  android:paddingLeft="@dimen/activity_horizontal_margin"
  android:paddingRight="@dimen/activity_horizontal_margin"
  tools:context="com.plattysoft.yass.counter.GameFragment"&gt;

  &lt;TextView
    android:layout_gravity="top|left"
    android:id="@+id/txt_score"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" /&gt;

  &lt;Button
    android:layout_gravity="top|right"
    android:id="@+id/btn_play_pause"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/pause" /&gt;

  <strong>&lt;include layout="@layout/view_vjoystick" /&gt;</strong>

&lt;/FrameLayout&gt;</pre></div><p>As a reminder, the initialization of the <code class="literal">GameEngine</code> is done inside <code class="literal">onViewCreated</code> of the <code class="literal">GameFragment</code>. We only need to create an instance of the proper <code class="literal">InputController</code>:</p><div><pre class="programlisting">mGameEngine = new GameEngine(getActivity());
<strong>mGameEngine.setInputController(new </strong>
<strong>    VirtualJoystickInputController(get View()));</strong>
mGameEngine.addGameObject(new Player(getView()));
mGameEngine.startGame();</pre></div><p>Time to run the <a class="indexterm" id="id000139"/>game and try this controller.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00033"/>General considerations and improvements</h2></div></div></div><p>This input method is a <a class="indexterm" id="id000140"/>huge improvement over the basic keypad we did before. The touch area is as big as the screen and the player does not need to look at this area of the screen to tap on small buttons. It will work anywhere.</p><p>This system handles diagonal as well as horizontal and vertical movements and also anything in between.</p><p>The player does not need to remove his/her finger from the screen to change the directions.</p><p>There is a lack of visual feedback, which can be solved by drawing the virtual gamepad as two circles when the player is using it. A big circle will show the range of the virtual joystick, while a smaller one will show the current touch pointer. On the other hand, you may not want to, since the lack of visual clutter makes the screen cleaner.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00018"/>Physical controllers</h1></div></div></div><p>Time to move into a <a class="indexterm" id="id000141"/>type of controller that hardcore gamers love: physical ones.</p><p>There are a few devices that have a controller included as a part of their hardware. Some notable examples are XPeria Play—one of the pioneer phones that had a sliding gamepad—and Nvidia Shield, the latest in this category.</p><p>XPeria Play was one of the first devices with an integrated gamepad:</p><div><img alt="Physical controllers" src="img/B04757_02_08.jpg"/></div><p>Nvidia Shield is one of the most powerful Android devices with a gamepad:</p><div><img alt="Physical controllers" src="img/B04757_02_09.jpg"/></div><p>On the other hand, there are many brands that build game controllers for smartphones and they have been fairly popular among traditional gamers. All of them are Bluetooth controllers that can be connected to your phone or tablet. Some of them are designed to make your phone fit into it <a class="indexterm" id="id000142"/>like Gametel (another pioneer) and most of the MOGA models.</p><div><img alt="Physical controllers" src="img/B04757_02_10.jpg"/><div><p>MOGA controller with an adjustable strip to hold your phone</p></div></div><p>There are also a few Android-powered devices that use controllers as the main input source. Here, we are talking about microconsoles such as the OUYA or other TV-like devices such as the Amazon FireTV or Android TV.</p><div><img alt="Physical controllers" src="img/B04757_02_11.jpg"/><div><p>The OUYA was the first of the Android microconsoles</p></div></div><p>These devices work in a very similar way to HID devices, either in the form of keyboards or as directional controls based on an axis (analog joysticks). All we have to do to handle them is to set the correct listeners.</p><p>Some controllers do have their own proprietary library. We won't cover this, since they are very specific and they provide <a class="indexterm" id="id000143"/>detailed documentation on how to integrate them. This is the case with the MOGA Pocket (more advanced MOGA controllers support two modes: proprietary and HID).</p><div><div><h3 class="title"><a id="note00023"/>Note</h3><p>Most controllers work as HID, which is standard.</p></div></div><p>We can set listeners for the controller at the <code class="literal">Activity</code> level or <code class="literal">View</code> level. In any case, we will need to extend the class. There is no way to add a listener for these methods, they must be overridden. Since we are already extending the <code class="literal">Activity</code> class, we'll do it this way.</p><div><div><h3 class="title"><a id="note00024"/>Note</h3><p>We listen to <code class="literal">KeyEvent</code> and <code class="literal">MotionEvent</code> inside the Activity.</p></div></div><p>There are two types of events we need to listen for. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">KeyEvent</code>: For all the button presses and, in some gamepads, also the directional cross</li><li class="listitem" style="list-style-type: disc"><code class="literal">MotionEvent</code>: Events related to the movement along an axis: joysticks</li></ul></div><p>We want to have the input controller separated from the <code class="literal">Activity</code>, so we will make a special listener that combines the two events we need and then make the <code class="literal">Activity</code> delegate on it.</p><p>The interface we need is very simple, we will call it <code class="literal">GamepadControllerListener</code>:</p><div><pre class="programlisting">public interface GamepadControllerListener {

  boolean dispatchGenericMotionEvent(MotionEvent event);

  boolean dispatchKeyEvent(KeyEvent event);
}</pre></div><p>Inside the <code class="literal">Activity</code>, we create a method to set a listener of <code class="literal">GamepadControllerListener</code> type. Since we only require one listener at a time, the method is set instead of add. To remove the listener, we just need to set it to null:</p><div><pre class="programlisting">public void setGamepadControllerListener(GamepadControllerListener listener) {
  mGamepadControllerListener = listener;
}</pre></div><p>Finally, we have to override <a class="indexterm" id="id000144"/>
<code class="literal">dispatchGenericMotionEvent</code> and <code class="literal">dispatchKeyEvent</code> inside our <code class="literal">Activity</code>:</p><div><pre class="programlisting">@Override
public boolean dispatchGenericMotionEvent(MotionEvent event) {
  if (mGamepadControllerListener != null) {
    if (mGamepadControllerListener.dispatchGenericMotionEvent(event)) {
      return true;
    }
  }
  return super.dispatchGenericMotionEvent(event);
}

@Override
public boolean dispatchKeyEvent (KeyEvent event) {
  if (mGamepadControllerListener != null) {
    if (mGamepadControllerListener.dispatchKeyEvent(event)) {
      return true;
    }
  }
  return super.dispatchKeyEvent(event);
}</pre></div><p>Note that this method uses the convention of returning true if the event was consumed and false if it was not. In our case, we will return true only if the event was consumed by the listener. In other cases, we will return the result to delegate the event to the base class.</p><p>It is very important to call the corresponding method in the super class, as there is a lot of processing done inside the <code class="literal">Activity</code> class that we do not want to discard accidentally.</p><p>With these components in place, we <a class="indexterm" id="id000145"/>can proceed to create our <code class="literal">GamepadInputController</code>, which will extend <code class="literal">InputController</code> and implement <code class="literal">GamepadControllerListener</code>:</p><div><pre class="programlisting">public class GamepadInputController
  extends InputController
  implements GamepadControllerListener {

  public GamepadInputController(YassActivity activity) {
    mActivity = activity;
  }

  @Override
  public void onStart() {
    mActivity.setGamepadControllerListener(this);
  }

  @Override
  public void onStop() {
    mActivity.setGamepadControllerListener(null);
  }

  [...]
}</pre></div><p>Hooking into the key and motion events of the <code class="literal">Activity</code> is something we want to limit as much as possible. This is why we override the <code class="literal">onStop</code> and <code class="literal">onStart</code> methods of the <code class="literal">InputController</code> to only set the listener while a game is running.</p><p>There are several possible controller layouts. In general, they usually have a cross control and/or an analog joystick. Some have several analog joysticks and, of course, buttons. All in all there are some important details about the events and how different gamepads may be configured:</p><div><img alt="Physical controllers" src="img/B04757_02_12.jpg"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The cross control can be made of buttons or it can be another analog joystick. If it has buttons, it will be handled as a <code class="literal">KeyEvent</code> with the same constants as a D-Pad. If it is an analog joystick, it will use <code class="literal">AXIS_HAT_X</code> and <code class="literal">AXIS_HAT_Y</code>.</li><li class="listitem" style="list-style-type: disc">Analog joysticks are handled via <code class="literal">MotionEvent</code> and we can read them using the <code class="literal">getAxisValue</code> method of the <code class="literal">MotionEvent</code>. The default joystick will use <code class="literal">AXIS_X</code> and <code class="literal">AXIS_Y</code>.</li><li class="listitem" style="list-style-type: disc">We are not going to <a class="indexterm" id="id000146"/>map the second analog joystick for this game, but it is mapped on the <code class="literal">AXIS_Z</code> and <code class="literal">AXIS_RZ</code>.</li><li class="listitem" style="list-style-type: disc">The buttons are mapped as a <code class="literal">KeyEvent</code> with the name of each button.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00034"/>Handling MotionEvents</h2></div></div></div><p>When we receive <a class="indexterm" id="id000147"/>a <code class="literal">MotionEvent</code>, we need to first <a class="indexterm" id="id000148"/>validate that the event is from a source we should read.</p><p>The source is part of the event and it is a composition of flags. The ones we are interested in are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SOURCE_GAMEPAD</code>: It indicates that the device has gamepad buttons such as <strong>A</strong>, <strong>B</strong>, <strong>X</strong>, or <strong>Y</strong>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SOURCE_DPAD</code>: It indicates that the device has a D-Pad.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SOURCE_JOYSTICK</code>: It indicates that the device has analog control sticks.</li></ul></div><p>The only motion events we should process are the ones in which the source has the joystick flag set. Both gamepad and D-Pad sources will be sent as a <code class="literal">KeyEvent</code>.</p><p>The handling of receiving a <code class="literal">MotionEvent</code> is as follows:</p><div><pre class="programlisting">@Override
public boolean dispatchGenericMotionEvent(MotionEvent event) {
  int source = event.getSource();

  if ((source &amp; InputDevice.SOURCE_JOYSTICK) != InputDevice.SOURCE_JOYSTICK) {
    return false
  }
  mHorizontalFactor = event.getAxisValue(MotionEvent.AXIS_X);
  mVerticalFactor = event.getAxisValue(MotionEvent.AXIS_Y);

  InputDevice device = event.getDevice();
  MotionRange rangeX = device.getMotionRange(MotionEvent.AXIS_X, source);
  if (Math.abs(mHorizontalFactor) &lt;= rangeX.getFlat()) {
    mHorizontalFactor = event.getAxisValue(MotionEvent.AXIS_HAT_X);
    MotionRange rangeHatX = device.getMotionRange(MotionEvent.AXIS_HAT_X, source);
    if (Math.abs(mHorizontalFactor) &lt;= rangeHatX.getFlat()) {
      mHorizontalFactor = 0;
    }
  }
  MotionRange rangeY = device.getMotionRange(MotionEvent.AXIS_Y, source);
  if (Math.abs(mVerticalFactor) &lt;= rangeY.getFlat()) {
    mVerticalFactor = event.getAxisValue(MotionEvent.AXIS_HAT_Y);
    MotionRange rangeHatY = device.getMotionRange(MotionEvent.AXIS_HAT_Y, source);
    if (Math.abs(mVerticalFactor) &lt;= rangeHatY.getFlat()) {
      mVerticalFactor = 0;
    }
  }
  return true;
}</pre></div><p>First, we check the source. If it is not from a joystick, we just return <code class="literal">false</code>, since we won't be consuming this event.</p><p>Then we read the axis values for <code class="literal">MotionEvent.AXIS_X</code> and <code class="literal">MotionEvent.AXIS_Y</code> and assign them to our variables. This is meant to read the default joystick. But we are not done. It is possible that the controller has a cross that works as an analog joystick.</p><p>To decide whether we <a class="indexterm" id="id000149"/>read the secondary joystick, we <a class="indexterm" id="id000150"/>check if there was input on the default one. If not, we assign the value from the secondary one to our variables.</p><p>It is important to note that most analog joysticks are not perfectly aligned at 0, so comparing the value of <code class="literal">mHorizontalFactor</code> and <code class="literal">mVerticalFactor</code> with 0 is not a valid way to detect if the joystick was moved.</p><div><div><h3 class="title"><a id="note00025"/>Note</h3><p>Analog joysticks are not perfectly centered at 0.</p></div></div><p>What we need to do is to read the flat value of the motion range of the device. It is much simpler than it sounds, since all this information is a part of the <code class="literal">MotionEvent</code>.</p><p>Then, if there was no <a class="indexterm" id="id000151"/>input from the default axis, we assign the <a class="indexterm" id="id000152"/>value of <code class="literal">AXIS_HAT_X</code> and <code class="literal">AXIS_HAT_Y</code> to our variables. We also check whether the input of the axis is above its flat value and set it to 0 if it is not. We need to do this or the spaceship will move very slowly without any input at all.</p><p>Finally, we return <code class="literal">true</code> to indicate that we have consumed the event.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00035"/>Handling KeyEvents</h2></div></div></div><p>The implementation <a class="indexterm" id="id000153"/>of <code class="literal">dispatchKeyEvent</code> is <a class="indexterm" id="id000154"/>very similar to the one we did for the basic controller with buttons on the screen:</p><div><pre class="programlisting">@Override
public boolean dispatchKeyEvent(KeyEvent event) {
  int action = event.getAction();
  int keyCode = event.getKeyCode();
  if (action == MotionEvent.ACTION_DOWN) {
    if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {
      mVerticalFactor -= 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
      mVerticalFactor += 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) {
      mHorizontalFactor -= 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
      mHorizontalFactor += 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_BUTTON_A) {
      mIsFiring = true;
      return true;
    }
  }
  else if (action == MotionEvent.ACTION_UP) {
    if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {
      mVerticalFactor += 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
      mVerticalFactor -= 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) {
      mHorizontalFactor += 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
      mHorizontalFactor -= 1;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_BUTTON_A) {
      mIsFiring = false;
      return true;
    }
    else if (keyCode == KeyEvent.KEYCODE_BUTTON_B) {
      mActivity.onBackPressed();
      return true;
    }
  }
  return false;
}</pre></div><p>The only significant difference is that we are comparing key codes to the constants for the D-Pad instead of <a class="indexterm" id="id000155"/>view ID. But apart from this, the logic <a class="indexterm" id="id000156"/>is exactly the same.</p><p>We also have to take care of mapping the button <strong>B</strong> to act as the back key. While this is already done on the latest versions of Android, it was not always the case, so we need to handle it. For this, we use the <code class="literal">onBackPressed</code> callback we already created in <code class="literal">YassActivity</code>.</p><p>Also, on Android 4.2 (API level 17) and before it, the system treated <code class="literal">BUTTON_A</code> as the Android back key by default. This is why we should always use <code class="literal">BUTTON_A</code> as the primary game action.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec00036"/>Detecting gamepads</h2></div></div></div><p>It is a good practice <a class="indexterm" id="id000157"/>to check whether a controller is connected when we launch the game. This allows us to display a help screen on how to play with a controller before the user starts playing. We should also check whether the controller is disconnected while the game is already running to pause it.</p><p>While checking for <a class="indexterm" id="id000158"/>controllers can be done via the <code class="literal">InputDevice</code> class, checking for changes in the controllers was only introduced in API level 16 (we are using minSDK=15).</p><div><div><h3 class="title"><a id="note00026"/>Note</h3><p>Detecting changes in the controllers being connected or disconnected was only introduced in Jelly Bean.</p></div></div><p>We are not going to provide a backward-compatible solution to detect the connection and disconnection of controllers. If you need to do it, there are detailed steps in the official documentation at <a class="ulink" href="http://developer.android.com/training/game-controllers/compatibility.html">http://developer.android.com/training/game-controllers/compatibility.html</a>; these basically use a polling mechanism over input devices and check for changes in the list.</p><p>We are going to check for gamepads during the <code class="literal">onResume</code> of the <code class="literal">MainMenuFragment</code>. The first time a controller is detected, we will show an <code class="literal">AlertDialog</code> that shows how to use the gamepad:</p><div><pre class="programlisting">@Override
public void onResume() {
  super.onResume();
  if (isGameControllerConnected() &amp;&amp; shouldDisplayGamepadHelp()) {
    displayGamepadHelp();
    // Do not show the dialog again
    PreferenceManager.getDefaultSharedPreferences(getActivity())
      .edit()
      .putBoolean(PREF_SHOULD_DISPLAY_GAMEPAD_HELP, false)
      .commit();
  }
}

private boolean shouldDisplayGamepadHelp() {
  return PreferenceManager.getDefaultSharedPreferences(getActivity())
    .getBoolean(PREF_SHOULD_DISPLAY_GAMEPAD_HELP, true);
}</pre></div><p>We are using default shared preferences to store whether we have displayed the dialog already or not. Once it is displayed we set the value to false, so it is not shown again.</p><p>The method to check if there is a controller connected is as follows:</p><div><pre class="programlisting">public boolean isGameControllerConnected() {
  int[] deviceIds = InputDevice.getDeviceIds();
  for (int deviceId : deviceIds) {
    InputDevice dev = InputDevice.getDevice(deviceId);
    int sources = dev.getSources();
    if (((sources &amp; InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD) ||
        ((sources &amp; InputDevice.SOURCE_JOYSTICK) == InputDevice.SOURCE_JOYSTICK)) {
      return true;
    }
  }
  return false;
}</pre></div><p>We iterate over the input devices and, if the source of any of them is a gamepad or a joystick, we return true.</p><p>If no device is found <a class="indexterm" id="id000159"/>with these sources, we return false.</p><p>Note that each <code class="literal">InputDevice</code> also has a name. This can be useful to identify specific gamepads in case you want to show different help screens such as for Nvidia Shield.</p><p>To check whether a controller <a class="indexterm" id="id000160"/>gets disconnected during gameplay, we need to register an <code class="literal">InputDeviceListener</code> on the <code class="literal">InputManager</code> and process the events. We will make <code class="literal">GameFragment</code> implement <code class="literal">InputDeviceListener</code>.</p><p>We do the registration right after creating the <code class="literal">GameEngine</code> and the unregistration after stopping the game in <code class="literal">onDestroy</code>. You need to either add some annotations to prevent int from giving an error for the method not being available on the minimum SDK or wrap it into an <code class="literal">if</code> block that checks the version, as we did before.</p><p>Then, it is as simple as pausing the game when a device is disconnected:</p><div><pre class="programlisting">@Override
public void onInputDeviceRemoved(int deviceId) {
  if (!mGameEngine.isRunning()) {
    pauseGameAndShowPauseDialog();
  }
}</pre></div><p>Note that this pauses the game when <em>any</em> device gets disconnected. It is unlikely that a device that is not a controller gets disconnected, but we could make sure it is a controller just by checking the source, as we did for <code class="literal">isGameControllerConnected</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00019"/>Sensors and InputControllers</h1></div></div></div><p>Sensors are a common <a class="indexterm" id="id000161"/>way to control games on smartphones. They work fine when the only controls in the game are left and right (like a car racing game). If you plan to also move up and down, you need to ask the player to do a calibration at the beginning of the game to make it usable. Note that, when you are using only one axis, such calibration is not necessary.</p><p>In addition to this, the up and down movement tends to interfere with the <code class="literal">sensorLandscape</code> orientation. So, the use of sensors is not a very good idea for YASS.</p><div><div><h3 class="title"><a id="note00027"/>Note</h3><p>Sensors are good controls only in certain cases.</p></div></div><p>You also have to consider that, while sensors are a replacement for directions, you still need to place the action buttons on the screen—in our case, the fire button.</p><p>We are not going to use sensors for YASS but, if you want to make a game that uses them, we will cover the basics.</p><p>You need to register a listener for the accelerometer and another one for the magnetic field. You should only listen to the sensors while the game is running, so we will override the life cycle methods to register and unregister sensors accordingly:</p><div><pre class="programlisting">private void registerListeners() {
  SensorManager sm = (SensorManager)
    mActivity.getSystemService(Activity.SENSOR_SERVICE);
  sm.registerListener(mAccelerometerChangesListener,
    sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),
    SensorManager.SENSOR_DELAY_FASTEST);
  sm.registerListener(mMagneticChangesListener,
    sm.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD),
    SensorManager.SENSOR_DELAY_FASTEST);
}

private void unregisterListeners() {
  SensorManager sm = (SensorManager)
    mActivity.getSystemService(Activity.SENSOR_SERVICE);
  sm.unregisterListener(mAccelerometerChangesListener);
  sm.unregisterListener(mMagneticChangesListener);
}

@Override
public void onStart() {
  registerListeners();
}
@Override
public void onStop() {
  unregisterListeners();
}
@Override
public void onResume() {
  registerListeners();
}
@Override
public void onPause() {
  unregisterListeners();
}</pre></div><p>Note that we are using <code class="literal">SensorManager.SENSOR_DELAY_FASTEST</code>, which means that the sensors will give feedback as fast and as often as they can. This is very important for real-time games.</p><p>We are setting objects as listeners. Each listener will just copy the values of the sensor into a local array that we will process later on. For example, in the case of an accelerometer, we will do:</p><div><pre class="programlisting">@Override
public void onSensorChanged(SensorEvent event) {
  System.arraycopy(event.values, 0, mLastAccels, 0, 3);
}</pre></div><p>To obtain the final value, we <a class="indexterm" id="id000162"/>have to do some calculations. So, we will add a <code class="literal">onPreUpdate</code> method that will be called by the <code class="literal">GameEngine</code> just before calling <code class="literal">onUpdate</code>.</p><p>It is important to note that there are some special cases. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are devices that lack a magnetic field sensor. In such cases, we can use a simplified version using the value of the accelerometer. Nvidia Shield and specific versions of Nook are some of these devices.</li><li class="listitem" style="list-style-type: disc">In all cases, the sensors are related to the default orientation of the device, which can be either landscape or portrait. We have to take this into consideration while processing the values.</li></ul></div><p>All in all, the conversion for the horizontal axis can be done like this:</p><div><pre class="programlisting">private double getHorizontalAxis() {
  if (SensorManager.getRotationMatrix(mRotationMatrix, null, mLastAccels, mLastMagFields)) {
    if (mRotation == Surface.ROTATION_0) {
      SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_Y, SensorManager.AXIS_MINUS_X, mRotationMatrix);
      SensorManager.getOrientation(mRotationMatrix, mOrientation);
      return mOrientation[1] * DEGREES_PER_RADIAN;
    }
    else {
      SensorManager.getOrientation(mRotationMatrix, mOrientation);
      return -mOrientation[1] * DEGREES_PER_RADIAN;
    }
  }
  else {
    // Case for devices which do NOT have magnetic sensors
    if (mRotation == Surface.ROTATION_0) {
      return -mLastAccels[0]* 5;
    }
    else {
      return -mLastAccels[1] * -5;
    }
  }
}</pre></div><p>The <code class="literal">getHorizontalAxis</code> code does the following steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculates the rotation matrix using the last data from the accelerometer and the magnetic sensor.</li><li class="listitem" style="list-style-type: disc">If it returns true, all <a class="indexterm" id="id000163"/>goes well. Based on the rotation of the device, we decide whether we need to remap the coordinate system or not and then return the orientation that is converted into degrees.</li><li class="listitem" style="list-style-type: disc">If it could not be calculated (lack of a magnetic field sensor), the method returns false. We have to rely on an approximation using the accelerometer values. Based on the rotation of the device, we should use one or another axis.</li></ul></div><p>The rotation of the device can be read in the constructor of the <code class="literal">InputController</code> with a single line of code.</p><div><pre class="programlisting">mRotation = yassActivity.getWindowManager().getDefaultDisplay().getRotation();</pre></div><p>Finally, the <code class="literal">onPreUpdate</code> method:</p><div><pre class="programlisting">@Override
public void onPreUpdate() {
  mHorizontalFactor = getHorizontalAxis()/ MAX_ANGLE;
  if (mHorizontalFactor &gt; 1) {
    mHorizontalFactor = 1;
  }
  else if (mHorizontalFactor &lt; -1) {
    mHorizontalFactor = -1;
  }
  mVerticalFactor = 0;
}</pre></div><p>The is method just converts the reading (in degrees) into values in the range [-1,1] by using the maximum angle at which we consider it to be fully tilted. I recommend you to play with this constant and start with 30 degrees.</p><p>For more information on <a class="indexterm" id="id000164"/>handling sensors, you can check the official documentation <a class="ulink" href="http://developer.android.com/guide/topics/sensors/sensors_overview.html">http://developer.android.com/guide/topics/sensors/sensors_overview.html</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00020"/>Selecting control modes</h1></div></div></div><p>It is common for games to ask the user to select the control mode they prefer, but it is also a good practice to avoid friction as much as possible by not asking what is not necessary.</p><p>YASS is only using a <a class="indexterm" id="id000165"/>virtual joystick and the gamepad controls. There is no need to ask the user which one he or she wants. Both input modes are compatible, especially because the virtual joystick does not display anything on the screen when it is not used. The only thing we need to do is to modify the <code class="literal">GameEngine</code> to support more than one <code class="literal">InputController</code>.</p><div><div><h3 class="title"><a id="note00028"/>Note</h3><p>We will support both input modes simultaneously.</p></div></div><p>The way to support both input modes at the same time is to create a <code class="literal">CompositeInputController</code> that uses the composition pattern to have both a <code class="literal">VirtualJoystickInputController</code> and a <code class="literal">GamepadInputController</code>, and combines the input from both.</p><p>To synchronize the readings from the two input controllers, we are going to use a method on the <code class="literal">InputController</code> called <code class="literal">onPreUpdate</code>, which will be called just before <code class="literal">onUpdate</code>. We will use it to populate the values of <code class="literal">mHorizontalFactor</code>, <code class="literal">mVerticalFactor</code>, and <code class="literal">mIsFiring</code> with the ones read from the other controllers.</p><div><pre class="programlisting">public void onPreUpdate() {
  mIsFiring = mGamepadInputController.mIsFiring || mVJoystickInputController.mIsFiring;
  mHorizontalFactor = mGamepadInputController.mHorizontalFactor + mVJoystickInputController.mHorizontalFactor;
  mVerticalFactor = mGamepadInputController.mVerticalFactor + mVJoystickInputController.mVerticalFactor;
}</pre></div><p>We now have a game that can <a class="indexterm" id="id000166"/>be controlled with a virtual joystick and a gamepad.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec00021"/>Summary</h1></div></div></div><p>We have learned how to deal with input from users in several ways and how to make it transparent for the <code class="literal">GameEngine</code>.</p><p>To get a proper visual feedback from the controller, we created a <code class="literal">Player</code> game object that updates its position based on the values from the <code class="literal">InputController</code>. We also learned how to add and remove game objects to and from the <code class="literal">GameEngine</code> while playing.</p><p>We created a very basic keypad that later evolved into a virtual joystick. We also learned how to handle external controllers.</p><p>At this point, our game has a spaceship that moves along the screen and fires bullets. It can be controlled using a virtual joystick or a gamepad, independently.</p><p>The current implementation does lag occasionally and we have barely started drawing objects on the screen. It is time to fix this. Next stop: improve the rendering by drawing directly on the view instead of relying on positioning views on the screen.</p></div>
<div><div><div><div><h1 class="title"><a id="ch23"/>Chapter 3. Into the Draw Thread</h1></div></div></div><p>In this chapter, we are going to improve the rendering of sprites for our game. For this, we are going to use a custom <code class="literal">GameView</code> that will perform low-level drawing. We will make two different implementations: one that extends from <code class="literal">View</code> and another one that extends from <code class="literal">SurfaceView</code>. We will let <code class="literal">DrawThread</code> be a real thread, to work better with this <code class="literal">GameView</code>.</p><p>We will refactor the project, creating a <code class="literal">Sprite</code> class that will be used for all the items that are drawn in the game. We will draw bitmaps on a <code class="literal">Canvas</code> and learn about the transformation matrix used to do this.</p><p>To continue improving the game, we will add enemies. They will be a wave of asteroids moving towards our spaceship. For this, we will learn the concept of <code class="literal">GameController</code> and the different ways of doing it, from static to procedural level generation.</p><p>As part of the rendering techniques, we will learn about occlusion culling and parallax backgrounds, which we will use to make the game look nicer.</p><p>Finally, we will add support for layers in the engine.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec00022"/>Using GameView</h1></div></div></div><p>Until now, we <a class="indexterm" id="id000167"/>have been using standard views and translating them to render the different elements of the game. While this is an easy way to draw elements on the screen, it is far from being efficient. We are relying on the system layout to do the drawing.</p><p>While this technique is fine for a turn-based game or any non-real-time game in general, it cannot render enough frames per second for a real-time game.</p><div><div><h3 class="title"><a id="note00029"/>Note</h3><p>Working with standard Views is fine for non-real-time games.</p></div></div><p>We are going to create a custom <code class="literal">View</code> that we are going to call <code class="literal">GameView</code>. This view will be responsible for drawing the sprites.</p><p>We already noted the duplication of code and mentioned the concept of sprite in the previous chapter. We will now move forward and create a <code class="literal">Sprite</code> class that will take care of drawing an image at specific coordinates inside the <code class="literal">GameView</code>.</p><p>There are two ways of drawing at low level on Android. They are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extending <code class="literal">View</code> and overriding <code class="literal">onDraw</code></li><li class="listitem" style="list-style-type: disc">Extending <code class="literal">SurfaceView</code> and using <code class="literal">SurfaceHolder</code></li></ul></div><p>In both cases, we will get a <code class="literal">Canvas</code> and draw our <code class="literal">GameObjects</code> on it. The main difference is that the <code class="literal">onDraw</code> method of the <code class="literal">View</code> is executed on the <code class="literal">UIThread</code>, while <code class="literal">SurfaceView</code> and <code class="literal">SurfaceHolder</code> are designed to perform the draw on a separate thread.</p><div><div><h3 class="title"><a id="note00030"/>Note</h3><p>Low-level drawing on Android is always done using a canvas.</p></div></div><p>According to the official documentation, it is more efficient to use <code class="literal">SurfaceView</code>. But, since Android 4.0, view rendering is hardware-accelerated (while <code class="literal">SurfaceView</code> is not). In the case of modern phones with high-resolution screens and faster processors, this may not always be the case.</p><div><div><h3 class="title"><a id="note00031"/>Note</h3><p><code class="literal">SurfaceView</code> is not <a class="indexterm" id="id000168"/>hardware-accelerated and may perform worse than normal <code class="literal">View</code>.</p></div></div><p>Anyway, you should know both and be able to swap them easily, even if it is just for testing purposes. We will create an interface named <code class="literal">GameView</code>, which will be implemented by the two classes, so they can be changed easily. The classes we will make are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StandardGameView</code>: This will extend from <code class="literal">View</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SurfaceGameView</code>: This will extend from <code class="literal">SurfaceView</code></li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00037"/>The GameView interface</h2></div></div></div><p>The <code class="literal">GameView</code> <a class="indexterm" id="id000169"/>interface will have all the methods that are needed by the <code class="literal">GameEngine</code> to handle the <code class="literal">View</code>:</p><div><pre class="programlisting">public interface GameView {
  void draw();
  void setGameObjects(List&lt;GameObject&gt; gameObjects);
  // Generic methods from View
  int getWidth();
  int getHeight();
  int getPaddingLeft();
  int getPaddingRight();
  int getPaddingTop();
  int getPaddingBottom();
  Context getContext();
}</pre></div><p>There are basically two methods we need, one to trigger the drawing and one to pass the list of game objects to the <code class="literal">GameView</code>, so they can be drawn there:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">draw</code>: This will trigger a draw on the <code class="literal">GameView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setGameObjects</code>: This will set the list of <code class="literal">GameObjects</code> for the <code class="literal">View</code></li></ul></div><p>The rest of the methods <a class="indexterm" id="id000170"/>are implemented in the <code class="literal">View</code>. We need to declare them, because we are using them on the <code class="literal">GameEngine</code>.</p><p>Let's explore each implementation in detail.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00038"/>StandardGameView</h2></div></div></div><p>The <code class="literal">StandardGameView</code> <a class="indexterm" id="id000171"/>class extends <code class="literal">View</code>. We just provide the basic constructors for <code class="literal">View</code>, override the <code class="literal">onDraw</code> method, and then implement the methods from <code class="literal">GameView</code>:</p><div><pre class="programlisting">public class StandardGameView extends View implements GameView {

  private List&lt;GameObject&gt; mGameObjects;

  public GameView(Context context) {
    super(context);
  }

  public GameView(Context context, AttributeSet attrs) {
    super(context, attrs);
  }

  public GameView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
  }

  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    synchronized (mGameObjects) {
      int numObjects = mGameObjects.size();
      for (int i = 0; i &lt; numObjects; i++) {
        mGameObjects.get(i).onDraw(canvas);
      }
    }
  }

  @Override
  public void draw() {
    postInvalidate();
  }

  @Override
  public void setGameObjects(List&lt;GameObject&gt; gameObjects) {
    mGameObjects = gameObjects;
  }
}</pre></div><p>Basically, <code class="literal">setGameObjects</code> stores a reference to the game objects. The adding and removing of <code class="literal">GameObjects</code> are done in the <code class="literal">GameEngine</code>. When we draw the view, we iterate over the list of game objects, calling <code class="literal">onDraw</code> on all of them and passing the <code class="literal">Canvas</code> object on which we are drawing.</p><p>Note that the method is <a class="indexterm" id="id000172"/>synchronized using the <code class="literal">mGameObjects</code> variable. This is important because, as we mentioned in <a class="link" href="ch21.html" title="Chapter 1. Setting Up the Project">Chapter 1</a>, <em>Setting Up the Project</em>, the contents of the list can change during <code class="literal">onUpdate</code> and we do not want this to happen while we are iterating over the list.</p><p>The other important point is that the list of <code class="literal">GameObjects</code> is a reference to the one inside the <code class="literal">GameEngine</code> and not a copy, so whenever the list gets modified, the latest values are accessible from both places. This is also why synchronization is required.</p><div><div><h3 class="title"><a id="note00032"/>Note</h3><p>The list of GameObjects is shared between the GameEngine and the GameView.</p></div></div><p>Performance-wise, it would not make sense to copy all the elements in the list to a new one in each execution of <code class="literal">onDraw</code>.</p><p>To trigger a draw, we just need to call <code class="literal">postInvalidate</code>. Remember that invalidating a view has to be done on the <code class="literal">UIThread</code>. This is why we need to call <code class="literal">postInvalidate</code>. This method will post a <code class="literal">Runnable</code> to be run on the <code class="literal">UIThread</code> that will then invalidate the <code class="literal">View</code>.</p><p>As we mentioned in the earlier chapters, once the view gets invalidated, Android makes sure that the <code class="literal">onDraw</code> method of the <code class="literal">View</code> is called and then the UI is updated. This is the connection between invalidating the view and the <code class="literal">onDraw</code> method, where we draw the game objects.</p><p>The <code class="literal">onDraw</code> method is obviously time-critical. We should avoid all unnecessary operations. In particular, lint shows a warning if you create an object inside <code class="literal">onDraw</code>. This is, to reiterate, a best practice for game developers: to always create the objects in advance.</p><div><div><h3 class="title"><a id="note00033"/>Note</h3><p>Never do object creation inside <code class="literal">onDraw</code>.</p></div></div><p>Also, it is worth remembering that Android has a fallback mechanism to avoid overload on the drawing. If a view <a class="indexterm" id="id000173"/>has been invalidated but not yet redrawn, the call to invalidate will be ignored (the view is already going to be redrawn).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00039"/>SurfaceGameView</h2></div></div></div><p>To implement a <code class="literal">GameView</code> <a class="indexterm" id="id000174"/>that extends <code class="literal">SurfaceView</code>, we need to define a <code class="literal">Callback</code> for <code class="literal">SurfaceHolder</code>—the class used to access the <code class="literal">SurfaceView</code>—and then, whenever we want to draw, we lock the canvas, draw on it, and unlock it again so it can be rendered by <code class="literal">SurfaceView</code>.</p><p>Let's see the code of <code class="literal">SurfaceGameView</code>:</p><div><pre class="programlisting">public class SurfaceGameView extends SurfaceView implements SurfaceHolder.Callback, GameView {

  private List&lt;GameObject&gt; mGameObjects;
  private boolean mReady;

  public SurfaceGameView(Context context) {
    super(context);
    getHolder().addCallback(this);
  }

  public SurfaceGameView(Context context, AttributeSet attrs) {
    super(context, attrs);
    getHolder().addCallback(this);
  }

  public SurfaceGameView(Context c, AttributeSet attrs, int defStyleAttr) {
    super(c, attrs, defStyleAttr);
    getHolder().addCallback(this);
  }

  @Override
  public void surfaceCreated(SurfaceHolder holder) {
    mReady = true;
  }

  @Override
  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {

  }

  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
    mReady = false;
  }

  @Override
  public void setGameObjects(List&lt;GameObject&gt; gameObjects) {
    mGameObjects = gameObjects;
  }

  @Override
  public void draw() {
    if (!mReady) {
      return;
    }
    Canvas canvas = getHolder().lockCanvas();
    if (canvas == null) {
      return;
    }
    canvas.drawRGB(0,0,0);
    synchronized (mGameObjects) {
      int numObjects = mGameObjects.size();
      for (int i = 0; i &lt; numObjects; i++) {
        mGameObjects.get(i).onDraw(canvas);
      }
    }
    getHolder().unlockCanvasAndPost(canvas);
  }
}</pre></div><p>First, we have three constructors with different arguments that are intrinsic to <code class="literal">SurfaceView</code>. Note that they all include a call to set a <code class="literal">Callback</code> to the <code class="literal">SurfaceHolder</code>, which is also implemented by <code class="literal">SurfaceGameView</code>. This callback will inform us of when <code class="literal">SurfaceView</code> is ready or when things have changed.</p><p>The next methods are <a class="indexterm" id="id000175"/>the implementation of the <code class="literal">Callback</code> interface. Those are the methods that are called when the <code class="literal">SurfaceView</code> is created, modified, or destroyed. We store the status of the view to know whether it is ready or not, so that it can be used to draw. A <code class="literal">View</code> is ready any time after it is created until it is destroyed.</p><p>Then, we move into implementing the methods from <code class="literal">GameView</code>.</p><p>To set the <code class="literal">GameObjects</code>, we do exactly as we did for <code class="literal">StandardGameView</code>, also with the same implications when it comes to handling a reference.</p><p>The <code class="literal">draw</code> method is where things are a bit different. We have to check whether the view is ready. If so, we lock the <code class="literal">Canvas</code> so we can draw on it.</p><p>Once we have the <a class="indexterm" id="id000176"/>canvas, we need to clean it before we draw each frame. The canvas will have the previous image on it. (If we do not clean it, we will get rendering artifacts as shown in the following screenshot.) This cleaning is done by filling the canvas with a solid color using <code class="literal">drawRGB</code>.</p><div><img alt="SurfaceGameView" src="img/B04757_03_01.jpg"/></div><p>Once we have cleaned the canvas, we take the same drawing as for <code class="literal">StandardGameView</code> and just iterate over the game objects.</p><p>Finally, we unlock the canvas and post it. This is the point when we pass the <code class="literal">Canvas</code> back to the <code class="literal">SurfaceView</code> and post it to the <code class="literal">UIThread</code>. Note that all of the drawing has been done outside the <code class="literal">UIThread</code>. Only once the <code class="literal">Canvas</code> is fully rendered will it be passed back for drawing.</p><div><div><h3 class="title"><a id="note00034"/>Note</h3><p><code class="literal">SurfaceView</code> performs the drawing on the <code class="literal">Canvas</code> outside the <code class="literal">UIThread</code>.</p></div></div><p>As mentioned before, <code class="literal">SurfaceView</code> is supposed to give better performance. But, since it is only software accelerated, in modern phones a standard <code class="literal">View</code>—with hardware acceleration—may be more efficient in some cases. A particular situation when <code class="literal">SurfaceView</code> <a class="indexterm" id="id000177"/>performance is impacted is if we put other views on top of it (like the pause button), since a full alpha-blended composite will be performed each time the surface changes.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00040"/>Updating GameEngine</h2></div></div></div><p>The use of <code class="literal">GameView</code> <a class="indexterm" id="id000178"/>has some implications from the <code class="literal">GameEngine</code> point of view. It means that it has to initialize the <code class="literal">GameView</code> and then trigger draws using the generic interface.</p><p>The <code class="literal">GameView</code> will be a parameter of the constructor of <code class="literal">GameEngine</code>. It will be initialized, passing a reference to the list of game objects. The updated constructor of <code class="literal">GameEngine</code> is like this:</p><div><pre class="programlisting">public GameEngine (Activity a, GameView gameView) {
  mActivity = a;
  mGameView = gameView;
  mGameView.setGameObjects(mGameObjects);

  mWidth = gameView.getWidth()
    - gameView.getPaddingRight() - gameView.getPaddingRight();
  mHeight = gameView.getHeight()
    - gameView.getPaddingTop() - gameView.getPaddingBottom();

  mPixelFactor = mHeight / 400d;
}</pre></div><p>From now on, we will also calculate the <code class="literal">pixelFactor</code> inside the <code class="literal">GameEngine</code>. We will store it in a public variable so it can be read by the game objects. This has several advantages, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If we decide to change the number of units of the screen, this is done in a single place</li><li class="listitem" style="list-style-type: disc">Removing code duplications is always good for maintenance</li></ul></div><p>On the other hand, the <code class="literal">onDraw</code> method of the <code class="literal">GameEngine</code> becomes extremely simple:</p><div><pre class="programlisting">public void onDraw() {
  mGameView.draw();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00041"/>Updating the game layout</h2></div></div></div><p>Of course, we <a class="indexterm" id="id000179"/>have to modify the <code class="literal">fragment_game.xml</code> layout to include the <code class="literal">GameView</code>. We will take this chance to do some other modifications to it, such as removing the <code class="literal">TextView</code> and changing the padding of the layout to be the margins on the pause button instead. This makes sure that the <code class="literal">GameView</code> is fullscreen while keeping the button margins as they were.</p><p>It is important to remember that in a <code class="literal">FrameLayout</code>, the order in the XML specifies the order in which the items are drawn (the z-index). We will put the <code class="literal">GameView</code> at the beginning of the layout to have the pause button drawn on top of it.</p><p>The new version of <code class="literal">fragment_game.xml</code> is as follows:</p><div><pre class="programlisting">&lt;FrameLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  tools:context="com.example.yass.counter.GameFragment"&gt;

  &lt;com.example.yass.engine.SurfaceGameView
    android:id="@+id/gameView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" /&gt;

  &lt;Button
    android:layout_gravity="top|right"
    android:id="@+id/btn_play_pause"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:layout_marginRight="@dimen/activity_vertical_margin"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/pause" /&gt;

  &lt;include layout="@layout/view_vjoystick" /&gt;

&lt;/FrameLayout&gt;</pre></div><p>Note that this is the place where we decide which variant of the <code class="literal">GameView</code> we are going to use. The rest of the code will access the methods via the <code class="literal">GameView</code> interface, so nothing else needs to be changed. We are going to use the <code class="literal">SurfaceGameView</code> from now on, but feel free to experiment with <code class="literal">StandardGameView</code> as well.</p><div><div><h3 class="title"><a id="note00035"/>Note</h3><p>The layout is where we set which variant of <code class="literal">GameView</code> we are going to use.</p></div></div><p>Finally, inside <code class="literal">GameFragment</code>, we update the creation of the <code class="literal">GameEngine</code> by adding the <code class="literal">GameView</code> parameter:</p><div><pre class="programlisting">GameView gameView = (GameView) getView().findViewById(R.id.gameView);
mGameEngine = new GameEngine(getActivity(), gameView);</pre></div><p>Now we have a <code class="literal">GameEngine</code> that relies on a <code class="literal">GameView</code> to do the rendering. We still need to update the <code class="literal">GameObject</code> class to make use of it.</p><p>Before we get to <a class="indexterm" id="id000180"/>the <code class="literal">GameObject</code> class, let's take a moment to improve <code class="literal">DrawThread</code> as well.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00023"/>Improving DrawThread</h1></div></div></div><p>To trigger the draw we have <a class="indexterm" id="id000181"/>been using a <code class="literal">Timer</code> and <code class="literal">TimerTask</code> scheduled so we could get 30 frames per second. While this works, it gives better performance to do it like the <code class="literal">UpdateThread</code>: run as many calls to <code class="literal">onDraw</code> as we can.</p><p>This approach works great for <code class="literal">SurfaceView</code> since the drawing is done on the same thread. But it may give some message overflow problems while using <code class="literal">StandardGameView</code>, which just calls <code class="literal">postInvalidate</code>. To prevent the overflow, we will ensure that the time between the calls to <code class="literal">onDraw</code> is never shorter than 20 milliseconds, which is enough for 50 frames per second.</p><p>The code for the new <code class="literal">DrawThread</code> is exactly the same as for <code class="literal">UpdateThread</code>, except for the part in the run method that takes care of the overflow. It looks like this:</p><div><pre class="programlisting">@Override
public void run() {
  long elapsedMillis;
  long currentTimeMillis;
  long previousTimeMillis = System.currentTimeMillis();

  while (mGameIsRunning) {
    currentTimeMillis = System.currentTimeMillis();
    elapsedMillis = currentTimeMillis - previousTimeMillis;
    if (mPauseGame) {
      while (mPauseGame) {
        try {
          synchronized (mLock) {
            mLock.wait();
          }
        } catch (InterruptedException e) {
          // We stay on the loop
        }
      }
      currentTimeMillis = System.currentTimeMillis();
    }
    if (elapsedMillis &lt; 20) { // This is 50 fps
      try {
        Thread.sleep(20-elapsedMillis);
      } catch (InterruptedException e) {
        // We just continue.
      }
    }
    mGameEngine.onDraw();
    previousTimeMillis = currentTimeMillis;
  }
}</pre></div><p>In the case of running two <a class="indexterm" id="id000182"/>calls too close, we put the thread to sleep from the remaining time to a minimum of 20 milliseconds.</p><p>If an <code class="literal">InterruptedException</code> happens, we don't really have much to handle. So, we can just move on and call <code class="literal">onDraw</code> in the <code class="literal">GameEngine</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00024"/>Sprites</h1></div></div></div><p>We have already mentioned <a class="indexterm" id="id000183"/>the concept of a sprite being an entity that is drawn and handled at a specific position on a screen. Essentially, everything we see in a game are sprites. There are exceptions, such as game controllers (which do not draw anything) and backgrounds (which are drawn in a different way), but we will talk about them later in the chapter.</p><p>So, this is the code for the <code class="literal">Sprite</code> class that extends <code class="literal">GameObject</code>:</p><div><pre class="programlisting">public abstract class Sprite extends GameObject {

  protected double mPositionX;
  protected double mPositionY;

  protected final double mPixelFactor;

  private final Bitmap mBitmap;
  protected final int mImageHeight;
  protected final int mImageWidth;

  private final Matrix mMatrix = new Matrix();

  protected Sprite (GameEngine gameEngine, int drawableRes) {
    Resources r = gameEngine.getContext().getResources();
    Drawable spriteDrawable = r.getDrawable(drawableRes);
    mPixelFactor = gameEngine.mPixelFactor;

    mImageHeight = (int) (spriteDrawable.getIntrinsicHeight()*mPixelFactor);
    mImageWidth = (int) (spriteDrawable.getIntrinsicWidth()*mPixelFactor);

    mBitmap = ((BitmapDrawable) spriteDrawable).getBitmap();
  }

  @Override
  public void onDraw(Canvas canvas) {
    mMatrix.reset();
    mMatrix.postScale((float) mPixelFactor, (float) mPixelFactor);
    mMatrix.postTranslate((float) mPositionX, (float) mPositionY);
    canvas.drawBitmap(mBitmap, mMatrix, null);
  }
}</pre></div><p><code class="literal">Sprite</code> is an abstract class <a class="indexterm" id="id000184"/>and there is no implementation of <code class="literal">onUpdate</code> at all. Sprites care about displaying an item on the screen, not about how this item moves.</p><p>The class has a series of <a class="indexterm" id="id000185"/>member variables. Let's go through them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mPositionX</code>, <code class="literal">mPositionY</code>: The position of the <code class="literal">Sprite</code> on the screen. The same concept we used for the <code class="literal">Player</code> and the <code class="literal">Bullet</code> objects. This position is in the top-left corner of the image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mPixelFactor</code>: The same concept as before. The factor to convert screen units into pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mBitmap</code>: The bitmap we are going to draw.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mImageWidth</code>, <code class="literal">mImageHeight</code>: The size of the bitmap as drawn on the screen. It is set here for convenience. We could always calculate it using the bitmap and the pixel factor, but it is faster to just store it for future use by the subclasses.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mMatrix</code>: This object is a transformation matrix. It is used for scaling, moving, and rotating the bitmap before rendering it on the canvas. For optimization purposes, it is reused among the <code class="literal">onDraw</code> executions instead of being created for each run.</li></ul></div><p>The next piece of code is the constructor. We are passing a reference to the <code class="literal">GameEngine</code> and a drawable resource. In the previous chapter, we were passing the parent <code class="literal">View</code>, so we could add the newly created <code class="literal">ImageView</code> to it. This is no longer necessary. We just need the <code class="literal">Context</code> and the pixel factor, which we can get from the <code class="literal">GameEngine</code>.</p><p>The code in the constructor is very similar to the ones we have seen before. It does several things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loads the <code class="literal">Drawable</code> from resources via the <code class="literal">Context</code></li><li class="listitem" style="list-style-type: disc">Gets the intrinsic size of the drawable and multiplies it by the pixel factor to store the width and height that the sprite will use in pixels for this particular device</li><li class="listitem" style="list-style-type: disc">Gets the <code class="literal">Bitmap</code> from the <code class="literal">Drawable</code> and stores it in a class variable to use it during <code class="literal">onDraw</code></li></ul></div><p>Finally, we have the <code class="literal">onDraw</code> method that receives a <code class="literal">Canvas</code>. This method is now called from the <code class="literal">GameView</code>. The <code class="literal">Canvas</code> is obtained in a different way from a <code class="literal">StandardGameView</code> and <code class="literal">SurfaceGameView</code>, but the logic of drawing on it is the same in both cases.</p><p>A canvas works as a drawing interface for the actual surface upon which your graphics will be drawn. It provides us with a set of primitives to draw, including bitmaps, text, lines, rectangles, ovals, and so <a class="indexterm" id="id000186"/>on. When using a canvas, the drawing is actually performed upon an underlying bitmap, which is then placed in the window.</p><div><div><h3 class="title"><a id="note00036"/>Note</h3><p>Canvas acts as a drawing interface that provides us with primitives.</p></div></div><p>To draw the sprite, we use the <a class="indexterm" id="id000187"/>
<code class="literal">drawBitmap</code> method from the <code class="literal">Canvas</code> class. This method receives a transformation matrix as a parameter. Let's see what we can do with the <code class="literal">Matrix</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reset</code>: We reset the transformation matrix from the values of the previous run. This is required to reuse the <code class="literal">Matrix</code> object from the previous run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">postScale</code>: We add a scale transformation at the end of the transformation list. The scale is the same as the <code class="literal">mPixelFactor</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">postTranslate</code>: This adds a translation transformation at the end of the transformation list. This means that this transformation will be performed after the scale. We translate the item to the location (<code class="literal">mPositionX</code>, <code class="literal">mPositionY</code>).</li></ul></div><p>For now, this is all we will do with the transformation matrix. Later in the chapter, we will add rotation.</p><div><div><h3 class="title"><a id="note00037"/>Note</h3><p>The order of actions in a transformation matrix is very important. The results are impacted by the order of the transformations.</p></div></div><p>The transformation matrix is a very powerful tool to transform bitmaps. The key point while creating the matrix is to keep in mind that the order is very important. It does not matter when we only <a class="indexterm" id="id000188"/>use translation and scale. But with rotation, the results are impacted by the order of the transformations.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00042"/>Updating the spaceship and bullets</h2></div></div></div><p>Now that we have a <a class="indexterm" id="id000189"/>
<code class="literal">Sprite</code> base class, we have to update the existing <a class="indexterm" id="id000190"/>
<code class="literal">Player</code> and <code class="literal">Bullet</code> classes to extend from it.</p><p>Most of the member variables from the <code class="literal">Player</code> object are now a part of the <code class="literal">Sprite</code>. We can also remove the old implementation of <code class="literal">onDraw</code> and rely on the one from the <code class="literal">Sprite</code>.</p><p>Finally, we have new simpler constructors that just receive the <code class="literal">GameEngine</code>. The one for the <code class="literal">Player</code> class is:</p><div><pre class="programlisting">public Player(GameEngine gameEngine) {
  super(gameEngine, R.drawable.ship);
  mSpeedFactor = mPixelFactor * 100d / 1000d;

  mMaxX = gameEngine.mWidth - mImageWidth;
  mMaxY = gameEngine.mHeight - mImageHeight;

  initBulletPool(gameEngine);
}</pre></div><p>The one for the <code class="literal">Bullet</code> object is:</p><div><pre class="programlisting">public Bullet(GameEngine gameEngine) {
  super(gameEngine, R.drawable.bullet);
  mSpeedFactor = gameEngine.mPixelFactor * -300d / 1000d;
}
</pre></div><p>All in all, we have pushed a lot of code to the <code class="literal">Sprite</code> class, which will make the inclusion of new game elements easier.</p><p>Before this, let's also add a frame-per-second counter to the <code class="literal">GameView</code> and see how it is performing to be able to compare <code class="literal">StandardGameView</code> and <code class="literal">SurfaceGameView</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00025"/>Adding a frames-per-second (fps) counter</h1></div></div></div><p>We have updated the <a class="indexterm" id="id000191"/>
<code class="literal">DrawThread</code> to run at an arbitrary number of frames per second, adapting to the time required to render instead of a fixed 30 fps, and we are using sprites. Now is the perfect time to add a frames-per-second counter. It is a very easy tool and is also handy to check performance.</p><p>We could have used a <code class="literal">TextView</code>, but there are some good reasons to draw it on the <code class="literal">Canvas</code> directly instead:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The performance of <code class="literal">SurfaceView</code> suffers when we overlay other views on top of it</li><li class="listitem" style="list-style-type: disc">It is an interesting example of other methods of drawing on the <code class="literal">Canvas</code></li><li class="listitem" style="list-style-type: disc">We can remove and add it without touching the layout</li></ul></div><p>We will make a class named <code class="literal">FPSCounter</code> that extends from <code class="literal">GameObject</code> and looks like this:</p><div><pre class="programlisting">public class FPSCounter extends GameObject {
  private final double mPixelFactor;
  private final float mTextWidth;
  private final float mTextHeight;

  private Paint mPaint;
  private long mTotalMillis;
  private int mDraws;
  private float mFps;

  private String mFpsText = "";

  public FPSCounter(GameEngine gameEngine) {
    mPaint = new Paint();
    mPaint.setTextAlign(Paint.Align.CENTER);
    mTextHeight = (float) (25*gameEngine.mPixelFactor);
    mTextWidth = (float) (50*gameEngine.mPixelFactor);
    mPaint.setTextSize(mTextHeight/2);
  }

  @Override
  public void startGame() {
    mTotalMillis = 0;
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
    mTotalMillis += elapsedMillis;
    if (mTotalMillis &gt; 1000) {
      mFps = mDraws*1000 / mTotalMillis;
      mFpsText = mFps+" fps";
      mTotalMillis = 0;
      mDraws = 0;
    }
  }

  @Override
  public void onDraw(Canvas canvas) {
    mPaint.setColor(Color.BLACK);
    canvas.drawRect(0,(int)(canvas.getHeight()-mTextHeight), mTextWidth, canvas.getHeight(), mPaint);
    mPaint.setColor(Color.WHITE);
    canvas.drawText(mFpsText, mTextWidth/2, (int) (canvas.getHeight()-mTextHeight/2), mPaint);
    mDraws++;
  }
}</pre></div><p>The logic is quite simple; we count the number of calls to <code class="literal">onDraw</code> and during <code class="literal">onUpdate</code>. Whenever we have been running for more than 1000 milliseconds, we do the calculation, store the result, and reset both variables.</p><p>The <code class="literal">onDraw</code> method draws a black square and then renders the text on it centered. We set the size of the square to <a class="indexterm" id="id000192"/>50 by 25 units and the text size to half the height of the square, so there is a margin. For this, we also need to use a <code class="literal">Paint</code> object.</p><p>The <code class="literal">Paint</code> class has methods to set colors, alignments, stroke width and type, and so on. Since we are mostly drawing bitmaps, we won't go into more detail on this.</p><p>Note that the <code class="literal">Paint</code> object is created once and reused, as we did with the <code class="literal">Matrix</code> on the <code class="literal">Sprite</code>, with (yet again) the premise that we should not do any object allocations inside <code class="literal">onDraw</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00026"/>Spawning enemies – the GameController</h1></div></div></div><p>Now we are ready to <a class="indexterm" id="id000193"/>spawn some enemies. For this, we are going to introduce a <a class="indexterm" id="id000194"/>new concept: the <code class="literal">GameController</code>.</p><p>A <code class="literal">GameController</code> is a special type of <code class="literal">GameObject</code> that has no visual representation (it is not a sprite) and its mission is to control the evolution of the game using the calls to <code class="literal">onUpdate</code>.</p><p>One of the most typical tasks of a <code class="literal">GameController</code> is managing the environment. This includes spawning enemies with the right parameters when necessary.</p><a class="indexterm" id="id000195"/><p>Game controllers fall into two main groups:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Procedural/random</li><li class="listitem" style="list-style-type: disc">Deterministic/static</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00043"/>Procedural/random</h2></div></div></div><p>This is a type of <a class="indexterm" id="id000196"/>
<code class="literal">GameController</code> that generates levels or enemies based on a set of parameters (or a function) that include some sort of random input.</p><p>The main advantage of procedural generation is that you do not have to create all the levels in detail, you just provide the parameters and an algorithm. It is complicated to tune it properly, but, once it is right, it potentially presents you with a different setup each time you play it. This improves replayability.</p><p>Some games that use procedural game controllers are Chalk Ball (survival mode), Fruit Ninja, and Eufloria. The most classic example of procedural-level generation are Rogue-like games, where each level of the dungeon is generated when you enter it.</p><div><img alt="Procedural/random" src="img/B04757_03_02.jpg"/><div><p>Nethack, one of the first games to use procedural-level generation.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00044"/>Deterministic/static</h2></div></div></div><p>Deterministic-level <a class="indexterm" id="id000197"/>generation is used when the levels are fixed and they are always the same.</p><p>This implies a lot of attention to detail, which allows for fine-tuning difficulty in the levels. Obviously, it also takes a lot of time.</p><p>Most game puzzles and tower defense games are examples of this: Angry Birds, Cut the Rope, Anomaly, SpaceCat, among many others.</p><p>As a rule of thumb, while using a deterministic <code class="literal">GameController</code> you want to have the definition of the levels stored in some files that can be modified without touching the code. This allows you to tune a level or add new sets of levels independently of the code. You can even create an external editor to manage the levels.</p><p>The format of these files <a class="indexterm" id="id000198"/>is completely up to you. I, personally, recommend the use of a structured language such as XML or JSON.</p><div><img alt="Deterministic/static" src="img/B04757_03_03.jpg"/><div><p>A level of SpaceCat as seen in the level editor</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00045"/>Hybrid approach</h2></div></div></div><p>Game-level design is not <a class="indexterm" id="id000199"/>black or white. There are many ways to define a <code class="literal">GameController</code> that is somewhere in between a procedural and a deterministic controller.</p><p>For example, Candy Crush Saga has a hybrid-level generation when the layout of the level is settled, but the candies that drop are different each time you play.</p><p>This gets the best of both worlds. It allows you to fine-tune the design of a level while it is still different each time you play it. It also takes a lot of time, because you have to tune both the static design and the algorithm.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00046"/>Our approach</h2></div></div></div><p>It does not make sense to <a class="indexterm" id="id000200"/>have a deterministic <code class="literal">GameController</code> for YASS, so we will go for the procedural generation.</p><p>We are going to make asteroids fall from the top of the screen with an angle that varies in the range of [-30,30] degrees. We will restrict their position on the <em>x</em> axis to be in the 50 percent central area of the screen.</p><p>The speed is going to be constant and they will spawn at a given interval, also a constant.</p><p>The code of the <code class="literal">GameController</code> for handling the generation of <code class="literal">Asteroids</code> is as follows:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  mCurrentMillis += elapsedMillis;
  long waveTimestamp = mEnemiesSpawned*TIME_BETWEEN_ENEMIES;
  if (mCurrentMillis &gt; waveTimestamp) {
    // Spawn a new enemy
    Asteroid a = mAsteroidPool.remove(0);
    a.init(gameEngine);
    gameEngine.addGameObject(a);
    mEnemiesSpawned++;
  }
}
</pre></div><p>We count the time the game has been running, then we calculate the time for the next enemy to spawn. This is the number of enemies we already created multiplied by the time between enemies.</p><p>If the current time of the game is greater than the time when the next enemy has to appear, then we spawn one and add it to the <code class="literal">GameEngine</code>.</p><p>To do so, we get an <code class="literal">Asteroid</code> from the pool of objects, just as we did with the bullets. We initialize it and add it to the <code class="literal">GameEngine</code>. Then, we add one to the number of enemies spawned.</p><p>The code spawns a new enemy, separating them by the number of milliseconds stated by <code class="literal">TIME_BETWEEN_ENEMIES</code>. We have set this at 500 milliseconds.</p><p>The object pool we are using for the asteroids is essentially the same as the one for the bullets. I won't bore you with the same details again.</p><p>The rest of the procedural <a class="indexterm" id="id000201"/>generation is inside the <code class="literal">init</code> method of the <code class="literal">Asteroid</code>, which looks like this:</p><div><pre class="programlisting">
public void init(GameEngine gameEngine) {
  // They initialize in a [-30, 30] degrees angle
  double angle = gameEngine.mRandom.nextDouble()*Math.PI/3d-Math.PI/6d;
  mSpeedX = mSpeed * Math.sin(angle);
  mSpeedY = mSpeed * Math.cos(angle);
  // Asteroids initialize in the central 50% of the screen
  mPositionX = gameEngine.mRandom.nextInt(gameEngine.mWidth/2)+gameEngine.mWidth/4;
  // They initialize outside of the screen vertically
  mPositionY = -mImageHeight;
}</pre></div><p>The <code class="literal">cos</code> and <code class="literal">sin</code> methods require the parameter to be radians, so we use <code class="literal">Random.getDouble</code> to get a double between [0,1], multiply it by PI/3, and then subtract PI/6. With this, we get a random value between [-PI/6,PI/6].</p><p>We use a random angle to get the components of speed on <code class="literal">X</code> and <code class="literal">Y</code> using <code class="literal">sin</code> and <code class="literal">cos</code>.</p><p>For the starting position we use the same technique. We get a random integer in the range [0,width/2] and then we add width/4, so the final value is in the range [width/4,width*3/4].</p><div><img alt="Our approach" src="img/B04757_03_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00047"/>The asteroids</h2></div></div></div><p>Finally, we need our <a class="indexterm" id="id000202"/>
<code class="literal">Asteroid</code> class, which is going to be a <code class="literal">Sprite</code>. As we did for the other graphics, we downloaded our art from the OpenGameArt website. This time we get a few asteroids with different shapes and colors.</p><p>The asteroid's implementation is reminiscent of the one for the  bullets, except that this time the object is removed from the <code class="literal">GameEngine</code> when it gets out of the screen from the bottom and it has speed components on both axes.</p><p>The code for the <code class="literal">Asteroid</code> is as follows:</p><div><pre class="programlisting">public class Asteroid extends Sprite {

  private final GameController mController;

  private final double mSpeed;
  private double mSpeedX;
  private double mSpeedY;

  public Asteroid(GameController gameController, GameEngine gameEngine) {
    super(gameEngine.getContext(), R.drawable.a10000, gameEngine.mPixelFactor);
    mSpeed = 200d*mPixelFactor/1000d;
    mController = gameController;
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
    mPositionX += mSpeedX * elapsedMillis;
    mPositionY += mSpeedY * elapsedMillis;
    // Check of the sprite goes out of the screen
    if (mPositionY &gt; gameEngine.mHeight) {
      // Return to the pool
      gameEngine.removeGameObject(this);
      mController.returnToPool(this);
    }
  }

  public void init(GameEngine gameEngine) {
    // We already saw that
  }
}</pre></div><p>Thanks to the <code class="literal">Sprite</code> <a class="indexterm" id="id000203"/>base class, this implementation is very easy. We just need to set the speed in the construction and then update the position on both axes using the speed and <code class="literal">elapsedMillis</code>.</p><p>Lastly, we check whether the object is out of bounds and, if so, we remove it from the engine and return it to the pool.</p><p>We can now compile and run and can see asteroids coming towards our spaceship.</p><div><img alt="The asteroids" src="img/B04757_03_05.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec00012"/>More on the transformation matrix</h3></div></div></div><p>You may have noticed <a class="indexterm" id="id000204"/>that the asteroids looked quite static. This is because the image is always the same. We can improve this with a nice simple trick: by adding rotation to them.</p><p>The first thing we need to do is to update the <code class="literal">Sprite</code> class to make it handle rotation as a part of the configuration of the transformation matrix:</p><div><pre class="programlisting">@Override
public void onDraw(Canvas canvas) {
  mMatrix.reset();
  mMatrix.postScale((float) mPixelFactor, (float) mPixelFactor);
  mMatrix.postTranslate((float) mPositionX, (float) mPositionY);
  mMatrix.postRotate((float) mRotation,
    (float) (mPositionX + mImageWidth/2),
    (float) (mPositionY + mImageHeight/2));
  canvas.drawBitmap(mBitmap, mMatrix, null);
}</pre></div><p>The order of the transformations is extremely important. The transformations are applied in order and a rotation does transform the reference axes. So, if we rotate 45 degrees and then translate 40 units to the right, since the initial rotation changes the reference for the coordinates, the end position will be down and left. On the other hand, if we first translate and then rotate, the coordinate system only gets affected at the end.</p><div><img alt="More on the transformation matrix" src="img/B04757_03_06.jpg"/></div><p>This can be counter-intuitive at first, but it is a very powerful tool to describe nonlinear movements. We will see more about transformations in <a class="link" href="ch28.html" title="Chapter 8. The Animation Framework">Chapter 8</a>, <em>The Animation Framework</em>.</p><p>For the sprites, we first <a class="indexterm" id="id000205"/>do a translation and then a rotation, using the center of the sprite at the final position as the pivot for it.</p><div><div><h3 class="title"><a id="note00038"/>Note</h3><p>A rotation also affects the reference coordinate system of the object.</p></div></div><p>Once the <code class="literal">Sprite</code> knows how to handle rotation, we just need to initialize the rotation of the asteroid to a value that makes sense and is different for each asteroid.</p><p>First, we initialize the rotation to a random angle, so each asteroid has a different value. We add this line to the <code class="literal">init</code> method of the <code class="literal">Asteroid</code>:</p><div><pre class="programlisting">mRotation = gameEngine.mRandom.nextInt(360);</pre></div><p>Then we set the rotation speed proportional to the angle of the linear speed, so each asteroid has a rotation speed based on the inclination of the trajectory. This also goes inside the <code class="literal">init</code> method:</p><div><pre class="programlisting">mRotationSpeed = angle*(180d / Math.PI)/250d;</pre></div><p>We make the asteroid perform a rotation equivalent to the inclination angle for times each second.</p><p>Once the values have been initialized, we need to update them during the <code class="literal">onUpdate</code> call. We will add the following code to <code class="literal">onUpdate</code>:</p><div><pre class="programlisting">mRotation += mRotationSpeed * elapsedMillis;
if (mRotation &gt; 360) {
  mRotation = 0;
}
else if (mRotation &lt; 0) {
  mRotation = 360;
}</pre></div><p>We update the rotation <a class="indexterm" id="id000206"/>and ensure that it is under the values that are valid [0-360].</p><div><div><h3 class="title"><a id="note00039"/>Note</h3><p>The rotation of a transformation matrix is provided in degrees.</p></div></div><p>Note that the transformation matrix uses the angles in degrees and not in radians, while the mathematical operators we used for the speed expect it in radians. Always double-check in which units the angles are expected.</p><p>If you run the game now, you will notice how such a simple tweak makes it look much nicer.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00027"/>Occlusion culling</h1></div></div></div><p>Occlusion culling is a <a class="indexterm" id="id000207"/>technique that is broadly used in games, especially 3D ones. Since drawing is very expensive and has to be done many times, every optimization counts. The obvious optimization is to not draw the parts that are not going to be seen (for example hidden by something else). If we can draw each pixel on the screen only once, we are saving a lot of processing time.</p><p>The fact of drawing each pixel more than once is called overdraw. Having a high overdraw is one of the factors that impact performance the most.</p><p>In the case of 3D, drawing is especially expensive, and occlusion culling is something that most engines do automatically to a certain extent.</p><div><div><h3 class="title"><a id="note00040"/>Note</h3><p>Occlusion culling optimizes the drawing time by not drawing what is not shown.</p></div></div><p>In our case, we may be drawing some pixels twice, but since we are only doing 2D, the cost of drawing is not that high and it is something we don't need to do.</p><p>There is one special case, however: drawing sprites that are outside the <code class="literal">GameView</code>.</p><p>Until now, we have been spawning the sprites as we needed them and removing them once they are out of the <code class="literal">GameView</code>. We could instead put them into place in the initialization of the level and just rely on the calls to <code class="literal">onUpdate</code> to make them appear on the screen. This is quite common for elements that are a part of the scenery or static enemies. In the case of a rogue-like game, we would be generating each dungeon level in the beginning and then spawning all the sprites and putting them into place.</p><p>Obviously, drawing things that are out of the player's view is a waste. So, we will make sure that the <code class="literal">Sprite</code> class performs this simple occlusion culling-like optimization:</p><div><pre class="programlisting">@Override
public void onDraw(Canvas canvas) {
  if (mPositionX &gt; canvas.getWidth()
      || mPositionY &gt; canvas.getHeight()
      || mPositionX &lt; -mImageWidth
      || mPositionY &lt; -mImageHeight) {
    return;
  }
  mMatrix.reset();
  mMatrix.postScale((float) mPixelFactor, (float) mPixelFactor);
  mMatrix.postRotate((float) mRotation,
    (float) mImageWidth/2, (float) mImageHeight/2);
  mMatrix.postTranslate((float) mPositionX, (float) mPositionY);
  canvas.drawBitmap(mBitmap, mMatrix, null);
}</pre></div><p>We just have to check if the <a class="indexterm" id="id000208"/>positions on the <em>x</em> and <em>y</em> axes and see if the sprite is inside the drawing area. Remember that we use the points at the top-left corner of the image. This is why we have to check against the width and height in negative.</p><p>This will not make any difference in our game, but it may be crucial for other types of games, especially those with static content.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00028"/>Parallax backgrounds</h1></div></div></div><p>Another typical feature of <a class="indexterm" id="id000209"/>2D games that is deeply related to the <code class="literal">DrawThread</code> is parallax backgrounds.</p><p>The idea of a parallax background is to have an image that moves slower than the elements in the foreground, giving the impression of depth.</p><div><div><h3 class="title"><a id="note00041"/>Note</h3><p>Parallax backgrounds are used to create an illusion of depth in 2D games.</p></div></div><p>To make this effect better, we can use multiple background images at different speeds. This is commonly used in 2D scrollers. For example with trees in the near plane and mountains and clouds at the very back.</p><p>For YASS, we will use a star field that moves down slowly as a background.</p><p>We are going to use the same convention of units as we used for the sprites. The image we use for the background <a class="indexterm" id="id000210"/>should be designed to be tiled, vertically in our case. This means that the end of the image fits with its beginning, so they are placed one after another and have continuity.</p><p>It should also be designed in a way that it is larger than the biggest screen. We can consider the tallest screens the ones with an 16:9 aspect ratio. So for a height of 400 pixels, this image should be at least 720 pixels wide (400 * 16 / 9 = 711.11).</p><p>A background is quite different from a sprite, mainly because of the size of the image and the fact that we may need to draw two of them to cover the screen is some cases.</p><p>We will create a new <code class="literal">ParallaxBackground</code> class for this:</p><div><pre class="programlisting">public ParallaxBackground(GameEngine gameEngine, int speed, int drawableResId) {
  Drawable spriteDrawable = gameEngine.getContext().getResources()
    .getDrawable(drawableResId);
  mBitmap = ((BitmapDrawable) spriteDrawable).getBitmap();

  mPixelFactor = gameEngine.mPixelFactor;
  mSpeedY = speed*mPixelFactor/1000d;

  mImageHeight = spriteDrawable.getIntrinsicHeight()*mPixelFactor;
  mImageWidth = spriteDrawable.getIntrinsicWidth()*mPixelFactor;

  mScreenHeight = gameEngine.mHeight;
  mScreenWidth = gameEngine.mWidth;

  mTargetWidth = Math.min(mImageWidth, mScreenWidth);
}</pre></div><p>The constructor is similar to the one <code class="literal">Sprite</code>. We load a bitmap, calculate the speed, and store the height and width of both the screen and image at its display size.</p><p>We have a new concept: the target width. This is used for optimization in case the image is larger than the screen, so we do not draw what is not going to be seen.</p><p>To begin with, we will do a simple implementation using the same transformation matrix concept that <a class="indexterm" id="id000211"/>we used on the sprites:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  mPositionY += mSpeedY * elapsedMillis;
}

@Override
public void onDraw(Canvas canvas) {
  if (mPositionY &gt; 0) {
    mMatrix.reset();
    mMatrix.postScale((float) (mPixelFactor), (float) (mPixelFactor));
    mMatrix.postTranslate(0, (float) (mPositionY - mImageHeight));
    canvas.drawBitmap(mBitmap, mMatrix, null);
  }
  mMatrix.reset();
  mMatrix.postScale((float) (mPixelFactor), (float) (mPixelFactor));
  mMatrix.postTranslate(0, (float) mPositionY);
  canvas.drawBitmap(mBitmap, mMatrix, null);

  if (mPositionY &gt; mScreenHeight) {
    mPositionY -= mImageHeight;
  }
}</pre></div><p>We are drawing the image at the <em>y</em> coordinate. When this coordinate is greater than 0, there will be space on the top of the view that needs to be filled with another image. This is what the first part of the code does; it draws the image one more time, but translates all the height of the image, so they tile.</p><p>In any case, we have to draw the background at <code class="literal">mPositionY</code>, which is what the second block does. Note that, when the position is smaller than 0, we only need to draw one image. The logic of the class ensures that the value of <code class="literal">Y</code> is never smaller than <code class="literal">mImageHeight</code> – <code class="literal">mScreenHeight</code>.</p><p>Once the <code class="literal">Y</code> position gets out of the screen, the second part of the drawing is no longer needed, so we subtract the image's height. With this, the image keeps the same position and scrolls smoothly, because the second part of the draw is now equivalent to the first one, which is not entered.</p><div><img alt="Parallax backgrounds" src="img/B04757_03_07.jpg"/><div><p>The different states of the background drawable.</p></div></div><p>While this code works, it is quite inefficient, because it does a lot of drawing that is not visible.</p><p>We can implement the drawing <a class="indexterm" id="id000212"/>on <code class="literal">ParallaxBackground</code> using another variant of <code class="literal">drawBitmap</code> that receives the rectangle of the image we want to draw and the rectangle on the screen when it should be drawn.</p><p>The math for this case looks a bit complicated. Let's first look at the code:</p><div><pre class="programlisting">private void efficientDraw(Canvas canvas) {
  if (mPositionY &lt; 0) {
    mSrcRect.set(0,
      (int) (-mPositionY/mPixelFactor),
      (int) (mTargetWidth/mPixelFactor),
      (int) ((mScreenHeight - mPositionY)/mPixelFactor));
    mDstRect.set(0,
      0,
      (int) mTargetWidth,
      (int) mScreenHeight);
    canvas.drawBitmap(mBitmap, mSrcRect, mDstRect, null);
  }
  else {
    mSrcRect.set(0,
      0,
      (int) (mTargetWidth/mPixelFactor),
      (int) ((mScreenHeight - mPositionY) / mPixelFactor));
    mDstRect.set(0,
      (int) mPositionY,
      (int) mTargetWidth,
      (int) mScreenHeight);
    canvas.drawBitmap(mBitmap, mSrcRect, mDstRect, null);
    // We need to draw the previous block
    mSrcRect.set(0,
      (int) ((mImageHeight - mPositionY) / mPixelFactor),
      (int) (mTargetWidth/mPixelFactor),
      (int) (mImageHeight/mPixelFactor));
    mDstRect.set(0,
      0,
      (int) mTargetWidth,
      (int) mPositionY);
    canvas.drawBitmap(mBitmap, mSrcRect, mDstRect, null);
  }

  if (mPositionY &gt; mScreenHeight) {
    mPositionY -= mImageHeight;
  }
}</pre></div><p>The handling is conceptually the same as for the previous algorithm, but now you have to keep in mind that the source rectangle has the original scale of the image, while the destination rectangle has the scale of the <code class="literal">GameView</code>. Other than this, the cases and how they work are the same.</p><p>While this drawing is more efficient under the draw-what-is-needed criteria, it is not so efficient in some cases.</p><p>When we use <code class="literal">drawBitmap</code> with <a class="indexterm" id="id000213"/>two rectangles, a new bitmap is created and used. This bitmap is then discarded and another one is created for the next call to <code class="literal">onDraw</code>. With the other implementation, the bitmaps are not touched, so they can remain loaded in the memory, saving some processing time.</p><p>All in all, the performance depends on the size of the bitmaps, if you are using a <code class="literal">SurfaceView</code> or a normal <code class="literal">View</code>, and how good is the hardware of the device.</p><div><div><h3 class="title"><a id="note00042"/>Note</h3><p>Though efficient, this way of drawing may not be faster. Bitmap manipulation and allocating memory are also time-consuming.</p></div></div><p>To add a background to the <code class="literal">GameEngine</code>, we have to remember that the drawing order in the <code class="literal">GameView</code> is the order in which the <code class="literal">GameObjects</code> were added to the <code class="literal">GameEngine</code>, so we must ensure that we add the background in the beginning, before the rest of the game objects.</p><p>The initialization of <code class="literal">GameEngine</code> inside <code class="literal">GameFragment</code> should look like this now:</p><div><pre class="programlisting">mGameEngine = new GameEngine(getActivity(), (GameView) getView().findViewById(R.id.gameView));
mGameEngine.setInputController(
  new CompositeInputController(getView(), getYassActivity()));
mGameEngine.addGameObject(
  new ParallaxBackground(mGameEngine, 20, R.drawable.seamless_space_0));
mGameEngine.addGameObject(new GameController(mGameEngine));
mGameEngine.addGameObject(new Player(mGameEngine));
mGameEngine.startGame();</pre></div><p>Our game is starting to <a class="indexterm" id="id000214"/>look really good.</p><div><img alt="Parallax backgrounds" src="img/B04757_03_08.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec00048"/>Multiple backgrounds</h2></div></div></div><p>It is fairly easy to add <a class="indexterm" id="id000215"/>another <code class="literal">ParallaxBackground</code> to the game with an additional set of stars at a different speed, so the two of them together give a better feeling of depth. This is as simple as adding another <code class="literal">ParallaxBackground</code> object with a different speed and a drawable that has transparency.</p><p>If we do it, we are going to see a dramatic decrease in performance.</p><p>This performance problem is caused by the number of pixel overdraws. With the second background, every point on the screen gets drawn at least twice (once for each background), and some of them thrice, when there is a sprite involved. Transparent pixels do count as overdraw.</p><div><div><h3 class="title"><a id="note00043"/>Note</h3><p>Using two overlapping parallax backgrounds forces each pixel to be drawn at least twice per frame.</p></div></div><p>All in all, there are many parameters involved in the performance. In most cases, <code class="literal">SurfaceGameView</code>, together with efficient background drawing, will give the best results. But as soon as we overlay another <code class="literal">View</code> on top of <code class="literal">GameView</code>, the performance plummets. <code class="literal">StandardGameView</code> performance decays slower in this case.</p><p>There is not much of a difference in performance between the two implementations of <code class="literal">GameView</code> or background rendering methods when we use only one background. But again, it depends on the size of the bitmap used for the background. I recommend you to experiment and see the differences yourself.</p><p>While the effect of two <a class="indexterm" id="id000216"/>parallax backgrounds is nice and our <code class="literal">GameView</code> can handle it with a decent refresh rate, we are going to use only one background in YASS. With this amount of overdraw, we are getting into the performance limit of what can be done with the standard Android SDK without using OpenGL.</p><p>If you want more complex backgrounds, you may want to move into using an OpenGL engine such as AndEngine, which uses the same concepts we have been using here.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00029"/>Layers</h1></div></div></div><p>Until now, the drawing sequence for the GameObjects is the order in which they are added to the GameEngine. This is inconvenient to say the least. We should improve it.</p><p>As most other drawing systems do, our engine should use layers.</p><p>Whenever we add a <code class="literal">GameObject</code> to the <code class="literal">GameEngine</code>, we will pass an integer to indicate the layer we want it to be added to. We will consider 0 to be the layer to add the background to. Think of layers as a z-index for the game objects.</p><p>We are going to use four layers. From the foreground to the background, we will display:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Player</code> object: The spaceship</li><li class="listitem" style="list-style-type: disc">Asteroids</li><li class="listitem" style="list-style-type: disc">Bullets</li><li class="listitem" style="list-style-type: disc">The background</li></ul></div><div><img alt="Layers" src="img/B04757_03_09.jpg"/></div><p>To add layer support, we need to modify the <code class="literal">GameEngine</code>, <code class="literal">StandardGameView</code>, and <code class="literal">SurfaceGameView</code> classes. For convenience, we will also update <code class="literal">GameObject</code> to know its layer.</p><p>On the top level, we will <a class="indexterm" id="id000217"/>handle the layers as a list of lists of game objects. This is the data structure that we will store in the <code class="literal">GameEngine</code> and pass to the implementations of <code class="literal">GameView</code>. We will keep the old <code class="literal">mGameObject</code> list as a simple way to iterate over all the <code class="literal">GameObjects</code>.</p><p>We initialize the layers inside the constructor of <code class="literal">GameEngine</code>. We will add a parameter to the constructor showing the number of layers we expect to have, so they can be precreated:</p><div><pre class="programlisting">private List&lt;List&lt;GameObject&gt;&gt; mLayers = new ArrayList&lt;List&lt;GameObject&gt;&gt;();

public GameEngine (Activity a, GameView gameView, int numLayers) {
  [...]
  for (int i=0; i&lt;numLayers; i++) {
    mLayers.add(new ArrayList&lt;GameObject&gt;());
  }
}</pre></div><p>The major changes are <a class="indexterm" id="id000218"/>inside <code class="literal">onUpdate</code>:</p><div><pre class="programlisting">public void onUpdate(long elapsedMillis) {
  mInputController.onPreUpdate();
  int numObjects = mGameObjects.size();
  for (int i=0; i&lt;numObjects; i++) {
    mGameObjects.get(i).onUpdate(elapsedMillis, this);
  }
  synchronized (mLayers) {
    while (!mObjectsToRemove.isEmpty()) {
      GameObject objectToRemove = mObjectsToRemove.remove(0);
      mGameObjects.remove(objectToRemove);
      mLayers.get(objectToRemove.mLayer).remove(objectToRemove);
    }
    while (!mObjectsToAdd.isEmpty()) {
      GameObject gameObject = mObjectsToAdd.remove(0);
      addToLayerNow(gameObject);
    }
  }
}</pre></div><p>The first part is the same as before. It iterates along all the <code class="literal">GameObjects</code>, calling <code class="literal">onUpdate</code>.</p><p>For the removal of objects, it is important that the <code class="literal">GameObject</code> knows its layer. Because of this, removing the object from the list of layers is just one more line of code.</p><p>Knowing the layer is also important when it comes to adding the <code class="literal">GameObjects</code>, especially when such addition is delayed to the end of <code class="literal">onUpdate</code>.</p><p>There is one new method called <code class="literal">addToLayerNow</code>. It is used also when the objects are added before the game starts. We can see how it is used in the <code class="literal">addGameObject</code> method of the <code class="literal">GameEngine</code>:</p><div><pre class="programlisting">public void addGameObject(final GameObject gameObject, int layer) {
  gameObject.mLayer = layer;
  if (isRunning()){
    mObjectsToAdd.add(gameObject);
  }
  else {
    addToLayerNow(gameObject);
  }
  mActivity.runOnUiThread(gameObject.mOnAddedRunnable);
}</pre></div><p>Note that the first thing we do when we add a new <code class="literal">GameObject</code> is to set the layer it is to be added to.</p><p>The <code class="literal">addToLayerNow</code> method takes care of the situation when we want to add a <code class="literal">GameObject</code> to a layer we have not defined. This should not happen if we defined the correct number of layers to be precreated. But it is a good safety measure to have in place, especially when you <a class="indexterm" id="id000219"/>are not sure how many layers you will use:</p><div><pre class="programlisting">private void addToLayerNow (GameObject object) {
  int layer = object.mLayer;
  while (mLayers.size() &lt;= layer) {
    mLayers.add(new ArrayList&lt;GameObject&gt;());
  }
  mLayers.get(layer).add(object);
  mGameObjects.add(object);
}</pre></div><p>The fact that <code class="literal">GameObject</code> knows the layer it has to be added to allows us to add it to the right layer in a single line of code. Note that we also add the <code class="literal">GameObject</code> to the list of all game objects.</p><p>Finally, the code that draws the game objects into the canvas has to be changed in both implementations of <code class="literal">GameView</code>. This is the place where the order of the layers is used to provide the drawing order:</p><div><pre class="programlisting">int numLayers = mLayers.size();
for (int i = 0; i &lt; numLayers; i++) {
  List&lt;GameObject&gt; currentLayer = mLayers.get(i);
  int numObjects = currentLayer.size();
  for (int j=0; j&lt;numObjects; j++) {
    currentLayer.get(j).onDraw(canvas);
  }
}</pre></div><p>Note that, inside each layer, the order of drawing is still the order of addition. Since we can now isolate the same type of items to the same layer, this should not be something to worry about any longer.</p><p>Also, note that the synchronization object is the same in the <code class="literal">GameViews</code> and in the <code class="literal">GameEngine</code>, now that synchronization is done using <code class="literal">mLayers</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec00030"/>Summary</h1></div></div></div><p>We have learned how to draw at low level using a standard <code class="literal">View</code> and also a <code class="literal">SurfaceView</code>. We have created a <code class="literal">Sprite</code> class to reuse the code of the items that are displayed on the screen.</p><p>The <code class="literal">DrawThread</code> has been updated to a more efficient one and we also added a frames-per-second counter to check the efficiency of each configuration.</p><p>Along the way, we learned about game controllers and the different ways to create levels. We also decided to spawn asteroids YASS using procedural generation, and put this into effect.</p><p>We also added support for parallax backgrounds and layers to the engine.</p><p>All in all, YASS is starting to look good, but we are clearly missing something: the bullets do nothing when they hit an asteroid and neither does our spaceship.</p><p>It is time to implement collision detection.</p></div>
<div><div><div><div><h1 class="title"><a id="ch24"/>Chapter 4. Collision Detection</h1></div></div></div><p>In most games we need to detect when objects intersect with each other to trigger actions; this is called collision detection. We will use it to detect when a bullet hits an asteroid (to destroy it) and when the player is hit by an asteroid (to end the game). This detection can be done in a discrete or in a continuous way, and it can involve different types of shapes. We will use discrete detection with rectangular and circular shapes.</p><p>As mentioned in <a class="link" href="ch21.html" title="Chapter 1. Setting Up the Project">Chapter 1</a>, <em>Setting Up the Project</em>, we are not going to do any Physics simulation. That is a completely separate topic and it is long enough to deserve its own book.</p><p>We will also discuss optimization techniques and implement one method called spatial partitioning that splits the area into smaller ones based on object density.</p><p>As a side note, all the concepts in this chapter can be easily extrapolated to collisions in 3D.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec00031"/>Detecting collisions</h1></div></div></div><p>There are two <a class="indexterm" id="id000220"/>main approaches to checking collisions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discrete, or a posteriori</li><li class="listitem" style="list-style-type: disc">Continuous, or a priori</li></ul></div><p>For the discrete approach, we advance the state of the game items and then check if any of them are intersecting. It is a discrete simulation because we only do the evaluation at the end of each step. It is called a posteriori because it is done after the objects have moved. It is reactive. Most of the time we lack the exact point of contact; we only know that at the end of the simulation step the objects are colliding.</p><p>On the other hand, a continuous approach predicts the collision before applying the movement, based on the parameters of each object. It is calculated before the movement is performed. That's why it is <a class="indexterm" id="id000221"/>called a priori. This method provides the exact point of contact and it is extremely useful when we require precision—such as for physics simulation.</p><p>The discrete method is generally one dimension simpler than the continuous one. This makes it much easier to understand and implement. It trades speed for precision.</p><div><div><h3 class="title"><a id="note00044"/>Note</h3><p>Discrete collision detection is faster but less precise.</p></div></div><p>Since we are not going to <a class="indexterm" id="id000222"/>use physics and we don't really care about the exact point of contact, we will use the discrete approach.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00049"/>Who can collide?</h2></div></div></div><p>To be able to calculate <a class="indexterm" id="id000223"/>
<code class="literal">GameObject</code> collisions, we need to associate a shape (or body) to a <code class="literal">GameObject</code>. This association requires some information about the object on the screen, such as position on the <em>x</em> and <em>y</em> axes and also the width and height.</p><p>We are going to create a class named <code class="literal">ScreenGameObject</code> that extends from <code class="literal">GameObject</code> and will contain that information. In our game, <code class="literal">Sprite</code> is the only class that will extend from <code class="literal">ScreenGameObject</code>, but it may come in handy if you want to place non-visual items on the screen that trigger something when the player crosses them, which is a common technique in games.</p><div><img alt="Who can collide?" src="img/B04757_04_01.jpg"/><div><p>GameObject classes hierarchy</p></div></div><p>To collide with other objects you need a position on the screen and a size. <code class="literal">ScreenGameObject</code> will provide that.</p><p>All the logic for <a class="indexterm" id="id000224"/>calculation collisions will be placed inside the <code class="literal">ScreenGameObject</code> class. The stub of the class is like this:</p><div><pre class="programlisting">public abstract class ScreenGameObject extends GameObject {

  protected double mX;
  protected double mY;

  protected int mHeight;
  protected int mWidth;

  public Rect mBoundingRect = new Rect(-1, -1, -1, -1);

  public boolean checkCollision(ScreenGameObject otherObject) {
    return false;
  }

  public void onCollision(GameEngine gameEngine, ScreenGameObject sgo) {
  }
}</pre></div><p>We take this opportunity to refactor the variables <code class="literal">width</code>, <code class="literal">height</code>, <code class="literal">X</code>, and <code class="literal">Y</code> to have shorter, more generic names. We will continue working with this class throughout the chapter.</p><p>The method <code class="literal">checkCollision</code> is where the action happens. That method will have a different implementation <a class="indexterm" id="id000225"/>depending on the shapes we use to calculate the collisions.</p><p>Finally, <code class="literal">onCollision</code> is used to trigger an action when a collision occurs.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00050"/>Updating GameEngine</h2></div></div></div><p>To run discrete <a class="indexterm" id="id000226"/>collision detection, we will use a method named <code class="literal">checkCollisions</code> during the execution of <code class="literal">onUpdate</code> on the <code class="literal">GameEngine</code>, so it will run every time the game objects are updated. We will place this method call after the update of the game objects and before the code that removes objects. Collisions are a typical reason why objects get removed.</p><p>Since only <code class="literal">ScreenGameObjects</code> can have collisions, we will create a special list containing them.</p><div><pre class="programlisting">private List&lt;ScreenGameObject&gt; mCollisionableObjects;</pre></div><p>And we will keep it updated whenever an object is added to or removed from the <code class="literal">GameEngine</code>, as we did for the separate layers in the previous chapter.</p><p>The code to check for collisions and to notify the game objects involved is as follows.</p><div><pre class="programlisting">private void checkCollisions() {
  int numObjects = mCollisionableObjects.size();
  for (int i = 0; i &lt; numObjects; i++) {
    ScreenGameObject objectA = mCollisionableObjects.get(i);
    for (int j = i + 1; j &lt; numObjects; j++) {
      ScreenGameObject objectB = mCollisionableObjects.get(j);
      if (objectA.checkCollision(objectB)) {
        objectA.onCollision(gameEngine, objectB);
        objectB.onCollision(gameEngine, objectA);
      }
    }
  }
}
</pre></div><p>The code is as simple as a nested <code class="literal">for</code> loop that checks every <code class="literal">ScreenGameObject</code> against all the others. If a collision is detected, we will execute the method <code class="literal">onCollision</code> on both screen game objects involved in it, passing the object they have collided with as a parameter.</p><p>Keep in mind that this method has quadratic complexity, while all the other methods involved in <code class="literal">onUpdate</code> <a class="indexterm" id="id000227"/>have linear complexity instead. Running collision detection is expensive.</p><div><div><h3 class="title"><a id="note00045"/>Note</h3><p>Checking for collisions has quadratic complexity O(n<sup>2</sup>).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00051"/>Handling collisions</h2></div></div></div><p>Regardless of the method <a class="indexterm" id="id000228"/>we use to calculate the collisions, the actions we have to take for the player and the bullets are the same. Let's override the method <code class="literal">onCollision</code> for them.</p><p>In the case of the bullets, we have to check if the object it collides with is an asteroid and, if that's the case, we remove both objects from the <code class="literal">GameEngine</code>.</p><div><pre class="programlisting">public void onCollision(GameEngine gameEngine, ScreenGameObject otherObject) {
  if (otherObject instanceof Asteroid) {
    // Remove both from the game (and return them to their pools)
    removeObject(gameEngine);
    Asteroid a = (Asteroid) otherObject;
    a.removeObject(gameEngine);
  }
}</pre></div><p>Note that we are calling a method <code class="literal">removeObject</code> on the objects themselves. This method takes care of removing the <code class="literal">GameObject</code> from the <code class="literal">GameEngine</code>, and also returning it to the object pool.</p><p>The code for the player is almost identical to the one for the bullet: we just remove both colliding objects in the case of an asteroid.</p><p>It is worth mentioning that because of the way we are spawning the bullets, they do collide with the <code class="literal">Player</code> object when added to the scene because we want it to look like they appear from the spaceship. We have to discard that collision. It is good practice to always check what the object is colliding against.</p><p>If we want to make a game with several lives, we should signal the <code class="literal">GameEngine</code> at that point to stop spawning waves, remove one life, spawn a new <code class="literal">Player</code> object, and then continue the game.</p><p>Let's see how the collisions are actually calculated.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec00032"/>Rectangular bodies</h1></div></div></div><p>The first way we are going to <a class="indexterm" id="id000229"/>implement detection is through the intersection of rectangles, which is also the simplest method.</p><p>We will use the <a class="indexterm" id="id000230"/>bounding rectangle of the <code class="literal">ScreenGameObject</code> and check if it intersects with the bounding rectangle of the other <code class="literal">ScreenGameObject</code>.</p><p>The bounding rectangle changes each time we update the position of the sprite and, since we may be required to check with many other objects, it is best if we recalculate it after <code class="literal">onUpdate</code>. We are going to make a new method called <code class="literal">onPostUpdate</code> and do that inside it.</p><p>We have to add a new method to <code class="literal">ScreenGameObject</code>.</p><div><pre class="programlisting">public void onPostUpdate(GameEngine gameEngine) {
  mBoundingRect.set(
    (int) mX,
    (int) mY,
    (int) mX + mWidth,
    (int) mY + mHeight);
}</pre></div><p>If you need to override <code class="literal">onPostUpdate</code> on other objects, remember to always call the super method, otherwise collisions will misbehave.</p><p>Then, when checking for collisions, we do a check for rectangular ones:</p><div><pre class="programlisting">@Override
public boolean checkCollision(ScreenGameObject otherObject) {
  return checkRectangularCollision(otherObject);
}</pre></div><p>Finally, although calculating intersections of rectangles is a very easy operation, since the class <code class="literal">Rect</code> already provides us with a utility method to do it, we will use it.</p><div><pre class="programlisting">private boolean checkRectangularCollision(ScreenGameObject other) {
  return Rect.intersects(mBoundingRect, other.mBoundingRect);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00052"/>Adding visual feedback</h2></div></div></div><p>Something that really <a class="indexterm" id="id000231"/>helps when working with collisions is to get some visual feedback on what is happening. For that we are going to draw the bounding rectangle in yellow as a background for the sprites:</p><div><pre class="programlisting">@Override
public void onDraw(Canvas canvas) {
  if (mX &gt; canvas.getWidth() || mY &gt; canvas.getHeight()
    || mX &lt; -mWidth || mY &lt; -mHeight) {
    return;
  }
  mPaint.setColor(Color.YELLOW);
  canvas.drawRect(mBoundingRect, mPaint);

  mMatrix.reset();
  [...]
  canvas.drawBitmap(mBitmap, mMatrix, null);
}</pre></div><div><img alt="Adding visual feedback" src="img/B04757_04_02.jpg"/></div><p>And it is time to try out <a class="indexterm" id="id000232"/>our shiny collision detection method and see how it performs. Spoiler alert: not too good.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00053"/>Pros and cons</h2></div></div></div><p>This collision <a class="indexterm" id="id000233"/>detection has some advantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy to implement</li><li class="listitem" style="list-style-type: disc">Fast to evaluate</li></ul></div><p>But it also has some important flaws:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the sprite has padding, the collision area is too big and unrealistic.</li><li class="listitem" style="list-style-type: disc">We are not rotating the rectangles when the Sprite rotates.</li><li class="listitem" style="list-style-type: disc">Collisions are very strict. The system detects collisions where there are only transparent pixels. This is especially bad when the corners touch.</li></ul></div><p>We can solve the first problem by clipping the sprites or by adding the possibility to set margins on the <code class="literal">ScreenGameObject</code>.</p><p>The second problem can be solved with some simple math, but it complicates the code and the <a class="indexterm" id="id000234"/>result isn't a better solution than a circular collision body. This is outside the scope of this book and is left as an exercise for the reader.</p><div><img alt="Pros and cons" src="img/B04757_04_03.jpg"/><div><p>Rectangular bodies require no padding on the images and can still create false positives</p></div></div><p>Unfortunately, the last problem is something that is inherent to this approach and cannot be solved unless we use a bounding polygon or a combination of rectangles.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec00033"/>Circular bodies</h1></div></div></div><p>The next type of body <a class="indexterm" id="id000235"/>we can use to detect collisions is a circle. For that we <a class="indexterm" id="id000236"/>are going to consider the diameter of the circle to be the largest of the dimensions of the sprite. We have to add a member variable to <code class="literal">ScreenGameObject</code> named <code class="literal">mRadius</code> and this code to the constructor of the sprite:</p><div><pre class="programlisting">mRadius = Math.max(mHeight, mWidth)/2;</pre></div><p>Note that other elements that inherit from <code class="literal">ScreenGameObject</code> may want to initialize the radius in a different way.</p><p>The calculation of a circular collision is fairly simple: we just have to measure the distance between the centers of the two circles and check if it is smaller than the sum of the radius.</p><div><img alt="Circular bodies" src="img/B04757_04_04.jpg"/><div><p>With circular bodies, the collision can occur outside the rectangle of the sprite</p></div></div><p>Because calculating square roots is a much more time consuming operation than a multiplication, we will use the square of the distance as defined by the Pythagorean theorem: <em>distance</em><em><sup>2</sup></em><em> = Δx</em><em><sup>2</sup></em><em> + Δy</em><em><sup>2</sup></em>.</p><p>The code to check circular collisions is like this:</p><div><pre class="programlisting">private boolean checkCircularCollision(ScreenGameObject other) {
  double distanceX = (mX + mWidth /2) - (other.mX + other.mWidth /2);
  double distanceY = (mY + mHeight /2) - (other.mY + other.mHeight /2);
  double squareDistance = distanceX*distanceX + distanceY*distanceY;
  double collisionDistance = (mRadius + other.mRadius);
  return squareDistance &lt;= collisionDistance*collisionDistance;
}</pre></div><p>We calculate the <a class="indexterm" id="id000237"/>distance on each axis, then get the <code class="literal">squareDistance</code> as the <a class="indexterm" id="id000238"/>sum of the squares. The <code class="literal">collisionDistance</code> is the sum of the radius, and then we compare it with the square of the <code class="literal">collisionDistance</code>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00054"/>Adding visual feedback</h2></div></div></div><p>As we did for rectangle <a class="indexterm" id="id000239"/>collision detection, we will add some visual feedback to the sprite to show the collision area while playing. In this case we just need to draw a circle:</p><div><pre class="programlisting">canvas.drawCircle(
  (int) (mX + mWidth / 2), 
  (int) (mY + mHeight / 2), 
  (int) mRadius, 
  mPaint);</pre></div><p>And, as simple <a class="indexterm" id="id000240"/>as that, we can see the collision area of the sprites on the game.</p><div><img alt="Adding visual feedback" src="img/B04757_04_05.jpg"/><div><p>Circular bodies fit great the Asteroids, but are terrible for the Bullets</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00055"/>Pros and cons</h2></div></div></div><p>This approach is not <a class="indexterm" id="id000241"/>perfect either, but it has some advantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It works better than rectangles for most sprites</li><li class="listitem" style="list-style-type: disc">It is easy to implement</li><li class="listitem" style="list-style-type: disc">It does not involve complex calculations</li></ul></div><p>But it also has some <a class="indexterm" id="id000242"/>problems— the most notable one is that when the image is mostly rectangular, the area of the collision is too big. We can see that clearly in the case of the bullets.</p><p>So, some sprites work better with rectangles, while others work better with circles. We could just have different <a class="indexterm" id="id000243"/>body types for each <code class="literal">ScreenGameObject</code> and calculate collisions accordingly.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec00034"/>Mixed collision detection</h1></div></div></div><p>We have seen that a <a class="indexterm" id="id000244"/>single shape does not fit all cases, so we are going to update our game to allow us to define which body shape each <code class="literal">ScreenGameObject</code> uses for collisions. For this, we are going to create an enum of body types and have a variable to store that information in <code class="literal">ScreenGameObject</code>.</p><p>The enum <code class="literal">BodyType</code> is as follows:</p><div><pre class="programlisting">public enum BodyType {
  None,
  Circular,
  Rectangular
}</pre></div><p>In the case of sprites, we will add a parameter to the constructor that specifies body type. Note that we have a special type called <code class="literal">None</code>. This is used for sprites that do not collide with others. While there are none of those in our game yet, other types of games can have them—for example, floor tiles on a dungeon crawler.</p><div><div><h3 class="title"><a id="note00046"/>Note</h3><p>We may want to have some sprites that do not trigger collisions. This is done using <code class="literal">BodyType.None</code>.</p></div></div><p>We are going to use circular bodies for the asteroids and the player, and rectangular ones for the bullets.</p><p>Since we have a list of bodies that can collide, if a <code class="literal">ScreenGameObject</code> has a <code class="literal">BodyType</code> of <code class="literal">None</code> we will not add it to the list; therefore, we do not need to check its collisions. This piece of code goes inside the method <code class="literal">addToLayerNow</code> of <code class="literal">GameEngine</code>.</p><div><pre class="programlisting">if (object instanceof ScreenGameObject) {
  ScreenGameObject sgo = (ScreenGameObject) object;
  if (sgo.mBodyType != BodyType.None) {
    mCollisionableObjects.add(sgo);
  }
}</pre></div><p>Then we have to update the <code class="literal">checkCollision</code> method of the <code class="literal">ScreenGameObject</code> to check which types the bodies of the two objects are, and which method we have to apply:</p><div><pre class="programlisting">@Override
public boolean checkCollision(ScreenGameObject otherObject) {
  if (mBodyType == BodyType.Circular 
    &amp;&amp; otherObject.mBodyType == BodyType.Circular) {
    return checkCircularCollision(otherObject);
  }
  else if (mBodyType == BodyType.Rectangular 
    &amp;&amp; otherObject.mBodyType == BodyType.Rectangular) {
    return checkRectangularCollision(otherObject);
  }
  else {
    return checkMixedCollision(otherObject);
  }
}</pre></div><p>Note that at this point in the execution, we know that the object is a <code class="literal">ScreenGameObject</code> and that it has a <code class="literal">BodyType</code> that is not <code class="literal">None</code>.</p><p>If both objects involved have rectangular bodies, we use the rectangular collision detection method. If both have circular bodies, we use the circular collision detection method. In any other case one of them is circular and the other is rectangular, so we have a new method for this case: <code class="literal">checkMixedCollision</code>.</p><p>To calculate if a rectangle and a circle collide, we have to check if the point of the rectangle that is closest to <a class="indexterm" id="id000245"/>the circle is inside it (the distance to the center of the circle is smaller than the radius).</p><p>The point of the rectangle that is closest to the circle can be easily calculated if we isolate the problem on each coordinate.</p><div><img alt="Mixed collision detection" src="img/B04757_04_06.jpg"/><div><p>Possible relative positions of a circle and a rectangle and its closest point</p></div></div><p>We are going to discuss the vertical axis (this is easier to distinguish because the bullets are tall). The horizontal axis follows an equivalent logic:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We draw a horizontal line that goes through the center of the circle.</li><li class="listitem" style="list-style-type: disc">If that line intersects the rectangle, the point of intersection is the closest point. As we are considering only the vertical axis, that value is the <em>y</em> coordinate of the center of the circle.</li><li class="listitem" style="list-style-type: disc">If the rectangle is below the line, the <em>y</em> coordinate of the closest point to the circle is the top position of the rectangle (the <em>y</em> coordinate).</li><li class="listitem" style="list-style-type: disc">If the rectangle is above the line, the <em>y</em> coordinate of the closest point to the circle is the bottom position of the rectangle (<em>y</em> + <code class="literal">height</code>).</li></ul></div><p>Remember that in computer <a class="indexterm" id="id000246"/>graphics the [0,0] point is at the top left of the screen and the <em>y</em> axis is positive downwards.</p><p>Now that the algorithm is clear, let's look at the code:</p><div><pre class="programlisting">private boolean checkMixedCollision(ScreenGameObject other) {
  ScreenGameObject circularSprite;
  ScreenGameObject rectangularSprite;
  if (mBodyType == BodyType.Rectangular) {
    circularSprite = this;
    rectangularSprite = other;
  }
  else {
    circularSprite = other;
    rectangularSprite = this;
  }

  double circleCenterX = circularSprite.mX + circularSprite.mWidth /2;
  double positionXToCheck = circleCenterX;
  if (circleCenterX &lt; rectangularSprite.mX) {
    positionXToCheck = rectangularSprite.mX;
  }
  else if (circleCenterX &gt; rectangularSprite.mX + rectangularSprite.mWidth) {
    positionXToCheck = rectangularSprite.mX + rectangularSprite.mWidth;
  }
  double distanceX = circleCenterX - positionXToCheck;

  double circleCenterY = circularSprite.mY + circularSprite.mHeight /2;
  double positionYToCheck = circleCenterY;
  if (circleCenterY &lt; rectangularSprite.mY) {
    positionYToCheck = rectangularSprite.mY;
  }
  else if (circleCenterY &gt; rectangularSprite.mY + rectangularSprite.mHeight) {
    positionYToCheck = rectangularSprite.mY + rectangularSprite.mHeight;
  }
  double distanceY = circleCenterY - positionYToCheck;

  double squareDistance = distanceX*distanceX + distanceY*distanceY;
  if (squareDistance &lt;= circularSprite.mRadius*circularSprite.mRadius) {
    // They are overlapping
    return true;
  }
  return false;
}</pre></div><p>We first identify which object has a circular body and which a rectangular one, and we set them to local variables.</p><p>Then we calculate the <em>x</em> and <em>y</em> <a class="indexterm" id="id000247"/>coordinates of the closest point, following the logic we already described. This combination gives us nine possible relative positions, which you can see in the image.</p><p>Finally, we calculate the square distance from that point to the center of the circle and check if it is smaller than the square of the radius.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00056"/>Adding visual feedback</h2></div></div></div><p>Adding visual <a class="indexterm" id="id000248"/>feedback is again very simple. We just need to run the code to draw a rectangle or the one to draw a circle, according to the type of body the sprite has.</p><div><pre class="programlisting">mPaint.setColor(Color.YELLOW);
if (mBodyType == BodyType.Circular) {
  canvas.drawCircle(
    (int) (mX + mWidth / 2), 
    (int) (mY + mHeight / 2), 
    (int) mRadius, 
    mPaint);
}
else if (mBodyType == BodyType.Rectangular) {
  canvas.drawRect(mBoundingRect, mPaint);
}</pre></div><div><img alt="Adding visual feedback" src="img/B04757_04_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00057"/>Other options for shapes</h2></div></div></div><p>With this, we <a class="indexterm" id="id000249"/>have covered the basic options for collision detection using simple shapes. To get a good feel for a game, you will need to pay special attention to the shape of each sprite and see which shape fits it best, maybe with modifications such as a smaller radius. For this I recommend you to keep the visual feedback on to check the approximation.</p><p>There is also the possibility of using polygons as shapes or multiple rectangles. These are reasonably easy ways to improve collision detection, and not too hard to implement. We leave it to the reader to explore the subject in more depth, as it requires fine-tuning.</p><p>In the case of the spaceship, the best shape would be a combination of 2 rectangles but, as we are happy with the circular body, we will leave it like that.</p><div><img alt="Other options for shapes" src="img/B04757_04_08.jpg"/><div><p>Different shape options for the spaceship</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00058"/>Optimization</h2></div></div></div><p>Checking for collisions <a class="indexterm" id="id000250"/>is an algorithm of quadratic complexity. If the number of objects to be checked grows, it may quickly become a bottleneck.</p><p>One option is to keep a record of the previous state of the comparison between the objects, and then either return the old value if both objects have not changed since the last check or use the old state as a parameter to the calculation of the new one. This is particularly handy for 3D games, where collision detection requires much more complex algorithms.</p><p>There is another optimization called spatial partitioning that exploits the proximity of the objects. This technique is based on the idea that objects can only collide with other elements that are close to them on the screen. Pretty obvious, right?</p><p>To implement spatial partitioning, we are going to use a data structure known as <code class="literal">QuadTree</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec00059"/>Spatial partitioning and QuadTree</h2></div></div></div><p>A <code class="literal">QuadTree</code> is similar <a class="indexterm" id="id000251"/>to a binary tree, except that each node that is not a leaf has four <a class="indexterm" id="id000252"/>children instead of two.</p><p>This is meant to <a class="indexterm" id="id000253"/>represent the spatial partitioning of a space into four sectors, each sector represented by one of the children. Each child can have another four nodes, or just be a leaf. This design makes it possible to apply the partition recursively when it is needed.</p><div><img alt="Spatial partitioning and QuadTree" src="img/B04757_04_09.jpg"/><div><p>Example of recursive partitioning where the density is high.</p></div></div><p>We only need to partition the space if the number of objects in it is too large. This means that some sections <a class="indexterm" id="id000254"/>with a high density of objects may be partitioned several times while others aren't.</p><p>When applying this concept to 3D games the data structure is called <code class="literal">OctTree</code>, because when we have three <a class="indexterm" id="id000255"/>dimensions the space is divided into eight sections.</p><p>The algorithm to populate a <code class="literal">QuadTree</code> is quite straight forward:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We check how many objects are in the space, and if the number is not too large (we use the constant <code class="literal">MAX_OBJECTS_TO_CHECK</code> for that), we will<a class="indexterm" id="id000256"/> run the collision detection as before, checking each object with every other one</li><li class="listitem" style="list-style-type: disc">Otherwise, divide the space into four quadrants or areas</li><li class="listitem" style="list-style-type: disc">For each quadrant, check which objects are inside (an object may be in more than one quadrant)</li><li class="listitem" style="list-style-type: disc">For each quadrant, apply this same algorithm recursively</li></ul></div><p>Each <code class="literal">QuadTree</code> has a <code class="literal">Rect</code> member that designates its area and a list of objects to check.</p><p>Inside <code class="literal">GameEngine</code>, we will replace the list of objects to check for collision with the root node of a <code class="literal">QuadTree</code>. We will add objects to or remove them from this node as they are added to or removed from the <code class="literal">GameEngine</code> and delegate the <code class="literal">QuadTree</code> to check the collisions.</p><p>On the constructor of the <code class="literal">GameEngine</code>, we will set the area of the root node:</p><div><pre class="programlisting">mQuadTreeRoot.setArea(new Rect(0,0,mWidth, mHeight));</pre></div><p>The code to check the collisions on the <code class="literal">GameEngine</code> gets simplified to a single line:</p><div><pre class="programlisting">private void checkCollisions() {
  mQuadTreeRoot.checkCollisions(this);
}</pre></div><p>Then, inside <a class="indexterm" id="id000257"/>
<code class="literal">QuadTree</code>, the code for checking <a class="indexterm" id="id000258"/>the collisions is as follows:</p><div><pre class="programlisting">public void checkCollisions(GameEngine gameEngine) {
  int numObjects = mGameObjects.size();
  if (numObjects &gt; MAX_OBJECTS_TO_CHECK &amp;&amp; sQuadTreePool.size() &gt;= 4) {
    splitAndCheck(gameEngine);
  }
  else {
    for (int i = 0; i &lt; numObjects; i++) {
      ScreenGameObject objectA = mGameObjects.get(i);
      for (int j = i + 1; j &lt; numObjects; j++) {
        ScreenGameObject objectB = mGameObjects.get(j);
        if (objectA.checkCollision(objectB)) {
          objectA.onCollision(gameEngine, objectB);
          objectB.onCollision(gameEngine, objectA);
        }
      }
    }
  }
}</pre></div><p>There are two possibilities. If we have too many objects and more than four <code class="literal">QuadTree</code> objects in the pool, we split the space <a class="indexterm" id="id000259"/>and check the collisions on the children. If this isn't so, we just run the collision detection method as we did before, iterating among all the objects on the list.</p><p>The method <code class="literal">splitAndCheck</code> looks like this:</p><div><pre class="programlisting">private void splitAndCheck(GameEngine gameEngine) {
  for (int i=0 ; i&lt;4; i++) {
    mChildren[i] = sQuadTreePool.remove(0);
  }
  for (int i=0 ; i&lt;4; i++) {
    mChildren[i].setArea(getArea(i));
    mChildren[i].checkObjects(mGameObjects);
    mChildren[i].checkCollisions(gameEngine);
    // Clear and return to the pool
    mChildren[i].mGameObjects.clear();
    sQuadTreePool.add(mChildren[i]);
  }
}</pre></div><p>We take four <code class="literal">QuadTree</code> objects from the pool and assign them to the elements on the array of children. It is important to do this at the beginning, given the recursive nature of the algorithm.</p><p>For each child we define <a class="indexterm" id="id000260"/>the area, which means dividing <a class="indexterm" id="id000261"/>the current area into four equal rectangles, checking <a class="indexterm" id="id000262"/>which objects are inside the area, and then checking for collisions, which is the recursive function again. Once that is done, we clear the child and return it to the pool.</p><p>On a final note—<code class="literal">getArea</code> just reuses a <code class="literal">Rect</code> object to set it to the values of the four quadrants.</p><div><pre class="programlisting">private Rect getArea(int area) {
  int startX = mArea.left;
  int startY = mArea.top;
  int width = mArea.width();
  int height = mArea.height();
  switch (area) {
    case 0:
      mTmpRect.set(startX, startY, 
        startX + width / 2, startY + height / 2);
      break;
    case 1:
      mTmpRect.set(startX + width / 2, startY, 
        startX + width, startY + height / 2);
      break;
    case 2:
      mTmpRect.set(startX, startY + height / 2, 
        startX + width / 2, startY + height);
      break;
    case 3:
      mTmpRect.set(startX + width / 2, startY + height / 2, 
        startX + width, startY + height);
      break;
  }
  return mTmpRect;
}</pre></div><p>To get an idea of the level of optimization of QuadTrees, let's imagine that we have 100 objects on the screen and that they are distributed in only two quadrants. This is one of those cases when this <a class="indexterm" id="id000263"/>algorithm provides the best <a class="indexterm" id="id000264"/>optimization.</p><div><img alt="Spatial partitioning and QuadTree" src="img/B04757_04_10.jpg"/></div><p>If we don't use the <code class="literal">QuadTree</code> technique, the number of collisions that need to be evaluated is 50.000. Iterating over the list twice gives n<sup>2</sup>/2 collision checks.</p><p>When we split the space into four, the amount of collisions checked is 1.250 on the first and fourth quadrants (50<sup>2</sup>/2) and none on the others. We have to add 400 operations, which are needed to see in which section each object is located (100 objects in four quadrants).</p><p>For us, checking which <a class="indexterm" id="id000265"/>quadrant an object is in is of similar complexity to checking a collision, but for collisions in 3D the collision check is much more expensive.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec00013"/>Duplicated collisions</h3></div></div></div><p>There is a special <a class="indexterm" id="id000266"/>case we should be aware of when using spatial partitioning: some collisions can be detected twice.</p><p>When a collision occurs between two objects that are on the intersection of two quadrants, both objects are in both quadrants; when the algorithm checks for collisions, it is detected in each of them. In the worst case it would be detected four times, when the objects are placed on the intersection of the four quadrants.</p><p>To solve this, we will keep a list of collisions that have been detected and only process a collision if it has not been detected before.</p><p>The <code class="literal">Collision</code> class <a class="indexterm" id="id000267"/>is very simple. It just contains two <code class="literal">ScreenGameObject</code> instances, an <code class="literal">equals</code> method, and a couple of static methods to handle its pool:</p><div><pre class="programlisting">public class Collision {
  private static List&lt;Collision&gt; sCollisionPool = new ArrayList&lt;Collision&gt;();

  public static Collision init(ScreenGameObject objectA, ScreenGameObject objectB) {
    if (sCollisionPool.isEmpty()) {
      return new Collision(objectA, objectB);
    }
    Collision c = sCollisionPool.remove(0);
    c.mObjectA = objectA;
    c.mObjectB = objectB;
    return c;
  }

  public static void release(Collision c) {
    c.mObjectA = null;
    c.mObjectB = null;
    sCollisionPool.add(c);
  }

  public ScreenGameObject mObjectA;
  public ScreenGameObject mObjectB;

  public Collision(ScreenGameObject objectA, ScreenGameObject objectB) {
    mObjectA = objectA;
    mObjectB = objectB;
  }

  public boolean equals (Collision c) {
    return (mObjectA == c.mObjectA &amp;&amp; mObjectB == c.mObjectB)
      || (mObjectA == c.mObjectB &amp;&amp; mObjectB == c.mObjectA);
  }
}</pre></div><p>We add the list of detected collisions as a parameter to the <code class="literal">checkCollisions</code> method, and we make sure we clean it on <code class="literal">GameEngine</code> before checking it again. The updated <code class="literal">checkCollisions</code> <a class="indexterm" id="id000268"/>on the <code class="literal">GameEngine</code> is like this:</p><div><pre class="programlisting">private List&lt;Collision&gt; mDetectedCollisions = new ArrayList&lt;Collision&gt;();

private void checkCollisions() {
  // Release the collisions from the previous step
  while (!mDetectedCollisions.isEmpty()) {
    Collision.release(mDetectedCollisions.remove(0));
  }
  mQuadTreeRoot.checkCollisions(this, mDetectedCollisions);
}</pre></div><p>Note that, because we are using a pool, we cannot just clear the list; we need to release each element individually.</p><p>Finally, we verify that the collision has not been detected before, checking it on the <code class="literal">QuadTree</code>.</p><div><pre class="programlisting">public void checkCollisions(GameEngine gameEngine, List&lt;Collision&gt; detectedCollisions) {
  int numObjects = mGameObjects.size();
  if (numObjects &gt; MAX_OBJECTS_TO_CHECK &amp;&amp; sQuadTreePool.size() &gt;= 4) {
    // Split this area in 4
    splitAndCheck(gameEngine, detectedCollisions);
  }
  else {
    for (int i = 0; i &lt; numObjects; i++) {
      ScreenGameObject objectA = mGameObjects.get(i);
      for (int j = i + 1; j &lt; numObjects; j++) {
        ScreenGameObject objectB = mGameObjects.get(j);
        if (objectA.checkCollision(objectB)) {
          Collision c = Collision.init(objectA, objectB);
          if (!hasBeenDetected(detectedCollisions, c)) {
            detectedCollisions.add(c);
            objectA.onCollision(gameEngine, objectB);
            objectB.onCollision(gameEngine, objectA);
          }
        }
      }
    }
  }
}</pre></div><p>Note that the list of collisions is required throughout the process, and it must be passed to the recursive method as <a class="indexterm" id="id000269"/>part of the state of the calculation.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec00035"/>Summary</h1></div></div></div><p>Now our game is really playable, we can detect when the bullets touch the asteroids and destroy them; additionally, we have to be careful because our ship can be destroyed by them as well.</p><p>We have learned how to do simple collision detection with rectangular and circular bodies, adjusting the body for each particular sprite.</p><p>We also learned some optimization techniques for collision detection and implemented one that makes use of spatial partitioning.</p><p>The next step in our roadmap is to add some juiciness to the game. Didn't you notice that the asteroids are missing some explosions? In the next chapter, we are going to talk about how to create particle systems for effects.</p></div>
<div><div><div><div><h1 class="title"><a id="ch25"/>Chapter 5. Particle Systems</h1></div></div></div><p>Particle systems are a technique used widely in video games to simulate phenomena that are complicated to render with other methods. The typical usages for them include explosions, fireworks, smoke, fire, water, and so on. They are usually highly chaotic systems.</p><p>Their foundation is to use a <a class="indexterm" id="id000270"/>large number of small sprites called particles. Their behavior is parametrized, so each particle has a different set of pseudo-random values. This makes each usage of the particle system different while it still looks similar.</p><p>Most game engines include a way to implement particle systems. Our engine will have them too.</p><p>We will base our code on the free software project Leonids, which is a library to display particle systems in the standard Android UI. We will adapt it to be used by our engine.</p><p>After explaining the basics of particle systems, we will implement a couple of examples of one-shot particle systems to simulate explosions, and also some continuous emitters to simulate a trail for the asteroids and the smoke of the spaceship's engine.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec00036"/>General concepts</h1></div></div></div><p>We are going to make our <a class="indexterm" id="id000271"/>particle system in a way that mimics the Leonids particle system library at <a class="ulink" href="http://plattysoft.github.io/Leonids/">http://plattysoft.github.io/Leonids/</a>. This project is a free software library I made to use particle systems in the standard Android UI.</p><div><img alt="General concepts" src="img/B04757_05_01.jpg"/><div><p>A demo of the Leonids library is available on Google Play</p></div></div><p>As a result of this, Leonids implements its own update and draw threads, as well as a simplified <code class="literal">GameView</code>. We already have all these, so we will adapt the code to suit our needs.</p><p>The concepts we are going to work with in this chapter are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Particle</strong>: Each of <a class="indexterm" id="id000272"/>the sprites that are rendered</li><li class="listitem" style="list-style-type: disc"><strong>Particle system</strong>: The <a class="indexterm" id="id000273"/>entity that takes care of spawning, updating, and keeping track of the particles</li><li class="listitem" style="list-style-type: disc"><strong>Initializer</strong>: A class that <a class="indexterm" id="id000274"/>sets a value for a particle based on certain parameters (before being active)</li><li class="listitem" style="list-style-type: disc"><strong>Modifier</strong>: A class that <a class="indexterm" id="id000275"/>updates a value for a particle based on the elapsed time (while being active)</li></ul></div><p>In our game, we will use only a few initializers and modifiers. If you need to extend the functionality of the particle system, you can visit Leonids' GitHub page to get ideas from it.</p><p>Let's get into the concepts.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00060"/>Particles</h2></div></div></div><p>Particles are a subclass of <a class="indexterm" id="id000276"/>
<code class="literal">Sprites</code>. Each particle is a small image with several particularities:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Particles do not have a collision body</li><li class="listitem" style="list-style-type: disc">Their movement is based on linear and angular speed</li><li class="listitem" style="list-style-type: disc">They have a limited time to live</li></ul></div><p>While, in theory, you could have a particle system in which the particles can collide—and this is handy to simulate effects such as a waterfall— the truth is that, unless you also have physics, this will not work properly. For simplicity, we are going to define our particles to have a <code class="literal">BodyType</code> of <code class="literal">None</code>.</p><p>A particle does have linear and angular speed and its <code class="literal">onUpdate</code> method is based on these variables. Each particle has these values initialized by the particle system.</p><p>There are a few properties of <a class="indexterm" id="id000277"/>sprites that particles usually modify. They are alpha and scale. We are not using them on sprites yet, so we will modify the <code class="literal">onDraw</code> method of <code class="literal">Sprite</code> for it:</p><div><pre class="programlisting">float scaleFactor = (float) (mPixelFactor*mScale);
mMatrix.reset();
mMatrix.postScale(scaleFactor, scaleFactor);
mMatrix.postTranslate((float) mX, (float) mY);
mMatrix.postRotate((float) mRotation, 
  (float) (mX + mWidth*mScale / 2), 
  (float) (mY + mHeight*mScale / 2));
mPaint.setAlpha(mAlpha);
canvas.drawBitmap(mBitmap, mMatrix, mPaint);</pre></div><p>As it happens, we were using the scale as part of the transformation matrix to scale the sprite based on the pixel factor. Now, we also multiply this by the perceived scale and we are done.</p><p>Note that we also need to multiply the width and height by the scale to put the center of the rotation at the center of the scaled sprite.</p><p>Also, note that we do the scaling in the beginning. If we were to do the scaling after the translation, the movement would be scaled as well and this is not what we want. Again, the order of the transformations affects the result.</p><p>While the scale is a part of the transformation matrix, the alpha is a parameter of <code class="literal">Paint</code>. Its value goes from 0 (transparent) to 255 (opaque). It is important that you remember to initialize it to 255 or all our sprites will be transparent.</p><div><div><h3 class="title"><a id="note00047"/>Note</h3><p>Alpha values go from 0 (transparent) to 255 (opaque).</p></div></div><p>With regard to the time to live, we just need to check the total amount of time the particle has been active during <code class="literal">onUpdate</code> to remove it from the <code class="literal">GameEngine</code> and return it to the particle system when it has expired.</p><p><code class="literal">Particle</code> is then a class that extends <code class="literal">Sprite</code>, which has a method to <code class="literal">activate</code> it. It runs its updates based on the values <a class="indexterm" id="id000278"/>of linear and angular speed:</p><div><pre class="programlisting">public class Particle extends Sprite {

  private long mTimeToLive;
  private long mTotalMillis;

  public double mSpeedX;
  public double mSpeedY;

  public double mRotationSpeed;

  protected Particle(
    ParticleSystem particleSystem, 
    GameEngine gameEngine, 
    int drawableRes) {
    super(gameEngine, drawableRes, BodyType.None);
    mParent = particleSystem;
  }

  @Override
  public void removeFromGameEngine(GameEngine gameEngine) {
    super.removeFromGameEngine(gameEngine);
    mParent.returnToPool(this);
  }

  public void activate(
    GameEngine gameEngine, 
    long timeToLive, 
    double x, 
    double y, 
    ArrayList&lt;ParticleModifier&gt; modifiers
    int layer) {
    mTimeToLive = timeToLive;
    mX = x-mWidth/2;
    mY = y-mHeight/2;
    addToGameEngine(gameEngine, layer);
    mModifiers = modifiers;
    mTotalMillis = 0;
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
    mTotalMillis += elapsedMillis;
    if (mTotalMillis &gt; mTimeToLive) {
      removeFromGameEngine(gameEngine);
    }
    else {
      mX += mSpeedX*elapsedMillis;
      mY += mSpeedY*elapsedMillis;
      mRotation += mRotationSpeed*elapsedMillis/1000d;
      for (int i=0; i&lt;mModifiers.size(); i++) {
        mModifiers.get(i).apply(this, mTotalMillis);
      }
    }
  }
}</pre></div><p>In the constructor, we pass a reference to the parent <code class="literal">ParticleSystem</code>, which we will use to return the particle to it when it is removed from the game engine. We also pass <code class="literal">BodyType.None</code> to the base class constructor so the particle is not involved in the collision detection.</p><p>When we activate the <a class="indexterm" id="id000279"/>particle, we do several actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set a time to live</li><li class="listitem" style="list-style-type: disc">Initialize the position on the <em>x</em> and <em>y</em> axes, adjusting it with the width and height of the image</li><li class="listitem" style="list-style-type: disc">Add it to the specific layer of the <code class="literal">GameEngine</code></li><li class="listitem" style="list-style-type: disc">Store a reference to the list of modifiers to be used during <code class="literal">onUpdate</code></li><li class="listitem" style="list-style-type: disc">Set the total milliseconds to 0 to indicate that this particle has just been activated</li></ul></div><p>It is worth noticing that we are keeping a reference to the list of modifiers. This list is shared among all the particles in the system and it is managed by the <code class="literal">ParticleSystem</code> class.</p><p>During <code class="literal">onUpdate</code>, we add the elapsed milliseconds to the total time and check whether the <code class="literal">Particle</code> has passed its time to live. If this is the case, we remove it from the <code class="literal">GameEngine</code>. Otherwise, we update the position and rotation based on the speed (linear and angular) and then apply all the modifiers.</p><p>You may have realized that we are using linear and angular speed values but, so far, we have not set them. This is done by the <code class="literal">ParticleSystem</code> through the initializers. This is why these variables are public.</p><p>Let's look at the system that handles the particles.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00061"/>ParticleSystem</h2></div></div></div><p>The <code class="literal">ParticleSystem</code> itself is <a class="indexterm" id="id000280"/>the one that controls the emission of particles. It is similar to the <code class="literal">GameController</code> class in some ways. <code class="literal">ParticleSystem</code> takes care of the initializing, activating, and spawning of particles.</p><p>One of the responsibilities of the <code class="literal">ParticleSystem</code> is to manage the pool of <code class="literal">Particle </code>objects. Given that particle systems have a large number of particles that expire and get reused, this is one of the cases when using an object pool is most important.</p><div><div><h3 class="title"><a id="note00048"/>Note</h3><p>The <code class="literal">ParticleSystem</code> has a pool of <code class="literal">Particles</code>.</p></div></div><p>The pool is populated in the constructor of the <code class="literal">ParticleSystem</code>:</p><div><pre class="programlisting">public ParticleSystem(
    GameEngine gameEngine,
    int maxParticles,
    int drawableRedId,
    long timeToLive) {
  mRandom = new Random();

  mModifiers = new ArrayList&lt;ParticleModifier&gt;();
  mInitializers = new ArrayList&lt;ParticleInitializer&gt;();

  mTimeToLive = timeToLive;
  mPixelFactor = gameEngine.mPixelFactor;
  for (int i=0; i&lt;maxParticles; i++) {
    mParticlePool.add(new Particle(this, gameEngine, drawableRedId));
  }
}</pre></div><p>The constructor receives the maximum number of particles that will be used simultaneously. This is what we will use for the size of the pool.</p><p>Another important point about our particle system is that all the particles have the same image. This is passed to the <code class="literal">ParticleSystem</code> in construction. If you want to have different images, you should use a <code class="literal">ParticleSystem</code> for each one of them as we will do in one of the examples.</p><div><div><h3 class="title"><a id="note00049"/>Note</h3><p>All particles of a <code class="literal">ParticleSystem</code> have the same image.</p></div></div><p>In the constructor, we also create the lists of <code class="literal">ParticleInitializer</code> and <code class="literal">ParticleModifiers</code>. The initializers will be used while activating each particle. The modifiers list will be passed to each particle and it will be used inside the <code class="literal">onUpdate</code> method of <code class="literal">Particle</code> as we have already seen.</p><p>This is how the initializers are used during the activation of a particle:</p><div><pre class="programlisting">private void activateParticle(GameEngine gameEngine) {
  Particle p = mParticlePool.remove(0);        
  for (int i=0; i&lt;mInitializers.size(); i++) {
    mInitializers.get(i).initParticle(p, mRandom);
  }
  p.activate(gameEngine, mTimeToLive, mX, mY, mModifiers, mLayer);
  mActivatedParticles++;
}</pre></div><p>An important design concept in <code class="literal">ParticleSystem</code> is that it abstracts the initializers and modifiers via utility methods and <a class="indexterm" id="id000281"/>each one of these utility methods return the <code class="literal">ParticleSystem</code> object, so the initialization can be chained, making the code shorter and easier to read.</p><p>Let's look at <code class="literal">ParticleInitializers</code> and <code class="literal">ParticleModifiers</code> in detail.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00062"/>Initializers</h2></div></div></div><p><strong>Initializers</strong> are used by the <a class="indexterm" id="id000282"/>
<code class="literal">ParticleSystem</code> to set values for the particles based on parameters. To do this, we define <code class="literal">ParticleInitializer</code> as a very simple interface:</p><div><pre class="programlisting">public interface ParticleInitializer {
  void initParticle(Particle p, Random r);
}</pre></div><p>As an example, we will look at the utility method of <code class="literal">ParticleSytem</code> to set the initial rotation of the particles:</p><div><pre class="programlisting">public ParticleSystem setInitialRotationRange (int minAngle, int maxAngle) {
  mInitializers.add(new RotationInitiazer(minAngle, maxAngle));
  return this;
}</pre></div><p>When we set the initial rotation range for a <code class="literal">Particle</code>, we add an initializer of the <code class="literal">RotationInitializer</code> type to the <code class="literal">ParticleSystem</code>. Then we return this, so the methods can be chained.</p><p>Other methods that we can use to configure the initialization of particles are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setSpeedRange(double speedMin, double speedMax)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setSpeedModuleAndAngleRange(double speedMin, double speedMax, int minAngle, int maxAngle)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setRotationSpeedRange(double minRotationSpeed, double maxRotationSpeed)</code></li></ul></div><p>We are not going to include the code of all the initializers we are going to use since all of them follow the same pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Receive a set of parameters and define the range(s)</li><li class="listitem" style="list-style-type: disc">Generate a random value(s) from the range(s)</li><li class="listitem" style="list-style-type: disc">Set the value(s) to the proper variable(s) of <code class="literal">Particle</code> (this may involve more than one field)</li></ul></div><div><div><h3 class="title"><a id="note00050"/>Note</h3><p>Initializers get a random value(s) from a range and set it to a variable(s) of <code class="literal">Particle</code>.</p></div></div><p>As an example on how <a class="indexterm" id="id000283"/>
<code class="literal">ParticleInitializer</code> is implemented, let's look at the code of <code class="literal">RotationInitializer</code>:</p><div><pre class="programlisting">public class RotationInitiazer implements ParticleInitializer {

  private int mMinAngle;
  private int mMaxAngle;

  public RotationInitiazer(int minAngle, int maxAngle) {
    mMinAngle = minAngle;
    mMaxAngle = maxAngle;
  }

  @Override
  public void initParticle(Particle p, Random r) {
    int value = r.nextInt(mMaxAngle-mMinAngle)+mMinAngle;
    p.mRotation = value;
  }
}</pre></div><p>Straightforward enough; the initializer stores the minimum and maximum values of the angle in member variables (<code class="literal">mMinAngle</code>, <code class="literal">mMaxAngle</code>). When it initializes a particle, it generates a random value in the range and sets it to the rotation variable of the particle.</p><p>All initializers work the same way; some are a bit more complex than others. For example, <code class="literal">SpeedModuleAndRangeInitializer</code> uses trigonometry to convert the speed from angle and module to coordinates:</p><div><pre class="programlisting">public class SpeedModuleAndRangeInitializer implements ParticleInitializer {

  private double mSpeedMin;
  private double mSpeedMax;
  private int mMinAngle;
  private int mMaxAngle;

  public SpeedModuleAndRangeInitializer(
      double speedMin, double speedMax, 
      int minAngle, int maxAngle) {
    mSpeedMin = speedMin;
    mSpeedMax = speedMax;
    mMinAngle = minAngle;
    mMaxAngle = maxAngle;
  }

  @Override
  public void initParticle(Particle p, Random r) {
    double speed = r.nextDouble()*(mSpeedMax-mSpeedMin) + mSpeedMin;
    int angle;
    if (mMaxAngle == mMinAngle) {
      angle = mMinAngle;
    }
    else {
      angle = r.nextInt(mMaxAngle - mMinAngle) + mMinAngle;
    }
    double angleInRads = angle*Math.PI/180d;
    p.mSpeedX = speed * Math.cos(angleInRads)/1000d;
    p.mSpeedY = speed * Math.sin(angleInRads)/1000d;
  }
}</pre></div><p>In this case, we have two ranges, one for the speed module and another for the angle. When we initialize a particle, we get a value for each one of them from their range, but then we need to use <code class="literal">sin</code> and <code class="literal">cos</code> to convert them into values that can be used for <code class="literal">Particle</code>, which are <code class="literal">mSpeedX</code> and <code class="literal">mSpeedY</code>.</p><p>In this case, we are <a class="indexterm" id="id000284"/>initializing two variables of <code class="literal">Particle</code>. Note again that these fields of the <code class="literal">Particle</code> class are public, so we can modify them from this class easily.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00063"/>Modifiers</h2></div></div></div><p><strong>Modifiers</strong> are a concept <a class="indexterm" id="id000285"/>similar to initializers, but they are applied when the particle is active.</p><p>As for initializers, we define an interface that allows them to interact with the <code class="literal">Particle</code> class:</p><div><pre class="programlisting">public interface ParticleModifier {
  void apply(Particle particle, long milliseconds);
}</pre></div><p>For us, a modifier will have the same parameters for all the particles, while an initializer will generate a value for each particle. This is why the linear and angular speeds are <em>not</em> handled by modifiers and are variables of each particle that can—and most likely will—have different values for each one of them.</p><p>The<code class="literal"> ParticleModifier</code> instances are also managed via utility methods of <code class="literal">ParticleSystem</code>, such as the one to set a fade out:</p><div><pre class="programlisting">public ParticleSystem setFadeOut(long millisecondsBeforeEnd) {
  mModifiers.add(
    new AlphaModifier(255, 0, mTimeToLive-millisecondsBeforeEnd, mTimeToLive));
  return this;
}</pre></div><p>This method creates an <code class="literal">AlphaModifier</code> to set a fade out (from an alpha of 255 to 0) based on the particle's <a class="indexterm" id="id000286"/>time to live in the system.</p><p>In general, we can create our own <code class="literal">ParticleModifier</code> instances and add them to the <code class="literal">ParticleSystem</code> by calling <code class="literal">addModifier</code>:</p><div><pre class="programlisting">public ParticleSystem addModifier(ParticleModifier modifier) {
  mModifiers.add(modifier);
  return this;
}</pre></div><p>We are going to use only two modifiers: <code class="literal">AlphaModifier</code> for fade outs and <code class="literal">ScaleModifier</code>.</p><p>Let's examine the code for <code class="literal">AlphaModifier</code>:</p><div><pre class="programlisting">public class AlphaModifier implements ParticleModifier {

  private int mInitialValue;
  private int mFinalValue;
  private long mStartTime;
  private long mEndTime;
  private float mDuration;
  private float mValueIncrement;

  public AlphaModifier(int initialValue, int finalValue, long startMilis, long endMilis) {
    mInitialValue = initialValue;
    mFinalValue = finalValue;
    mStartTime = startMilis;
    mEndTime = endMilis;
    mDuration = mEndTime - mStartTime;
    mValueIncrement = mFinalValue-mInitialValue;
  }

  @Override
  public void apply(Particle particle, long milliseconds) {
    if (milliseconds &lt; mStartTime) {
      particle.mAlpha = mInitialValue;
    }
    else if (milliseconds &gt; mEndTime) {
      particle.mAlpha = mFinalValue;
    }
    else {
      double percentageValue = (miliseconds- mStartTime)*1d/mDuration;
      int newAlphaValue = (int) (mInitialValue + mValueIncrement*percentageValue);
      particle.mAlpha = newAlphaValue;
    }
  }
}</pre></div><p>Note that we have an initial value and a final value; we will set the alpha to the initial value if the time is less than the starting one and set it to the final value when the time is greater than the end one.</p><p>This allows us to do both, a fade in and a fade out, using the same class.</p><p>For modifiers, it is important to emphasize that the <code class="literal">apply</code> method receives the total amount of milliseconds spent. This is <a class="indexterm" id="id000287"/>required because the modifier does not know anything about the <code class="literal">Particle</code>. It does not have any state, so all the information must be passed as parameters to the <code class="literal">apply</code> method.</p><div><div><h3 class="title"><a id="note00051"/>Note</h3><p>Modifiers are the same for all the particles and do not save any state.</p></div></div><p>The modifier has a start and an end time. When the time is outside the interval, we set it to the initial or final value. When the time is between these boundaries, it returns the value as a linear interpolation of the increment between the initial and final values.</p><p>It is quite easy to modify this code to use other types of interpolators. If you are curious about it, you can check the code of Leonids on GitHub, which supports interpolators.</p><p><code class="literal">ScaleModifier</code> is almost identical to this one, except that the value is set to <code class="literal">mScale</code> instead of <code class="literal">mAlpha</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00064"/>Composite GameObjects and GameEngine</h2></div></div></div><p>Until now, the <a class="indexterm" id="id000288"/>
<code class="literal">GameObjects</code> that we have been using are a single entity. From now on, we will also have <code class="literal">GameObjects</code> that include other <code class="literal">GameObjects</code>. In particular, the <code class="literal">ParticleSystems</code> used by each object will be owned by them.</p><p>This implies that the <a class="indexterm" id="id000289"/>addition and removal of <code class="literal">GameObjects</code> to the <code class="literal">GameEngine</code> must be updated. The object will have two methods to add and remove itself from the <code class="literal">GameEngine</code> and we can override this method when we use a composite object to take care of them.</p><p>Our change will be to stop using the <code class="literal">addGameObject</code> and <code class="literal">removeGameObject</code> methods from <code class="literal">GameEngine</code> and start using new equivalent methods such as <code class="literal">addToGameEngine</code> and <code class="literal">removeFromGameEngine</code> on the <code class="literal">GameObject</code> instead.</p><p>This implies that we should go over the code of the project and replace all their occurrences. This is especially important in the case of the <code class="literal">GameController</code>, where the asteroids are spawned, and the initialization of the <code class="literal">GameEngine</code> inside <code class="literal">GameFragment</code>, when we add the <code class="literal">Player</code> object:</p><div><pre class="programlisting">mGameEngine = new GameEngine(getActivity(), gameView, 4);
mGameEngine.setInputController(
  new CompositeInputController(getView(), getYassActivity()));
new ParallaxBackground(mGameEngine, 20, R.drawable.seamless_space_0)
  .addToGameEngine(mGameEngine, 0);
new GameController(mGameEngine).addToGameEngine(mGameEngine, 2);
new Player(mGameEngine).addToGameEngine(mGameEngine, 3);
new FPSCounter(mGameEngine).addToGameEngine(mGameEngine, 2);</pre></div><p>Even though the use of the old methods would produce the same result on noncomposite objects, it is better to add all the <code class="literal">GameObjects</code> to the <code class="literal">GameEngine</code> in the same way to have consistent code.</p><p>The default implementations of <code class="literal">addToGameEngine</code> and <code class="literal">removeFromGameEngine</code> are actually extremely simple for a noncomposite <code class="literal">GameObject</code>:</p><div><pre class="programlisting">public void addToGameEngine (GameEngine gameEngine, int layer) {
  gameEngine.addGameObject(this, layer);
}

public void removeFromGameEngine (GameEngine gameEngine) {
  gameEngine.removeGameObject(this);
}</pre></div><p>When we override this methods on composite items, we must remember to call the super method to add and remove the object.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec00037"/>Making good particle systems</h1></div></div></div><p>As a side note, particle systems are very powerful, but it is not trivial to tweak and design them.</p><p>The implementation details of a <a class="indexterm" id="id000290"/>particle system are straightforward, as we have seen. But making a particle system that looks realistic and good is something else entirely.</p><p>The key to fine-tuning them is to play with the parameters and see how they look, again, and again, and again until we are happy with the result.</p><p>To try and throw some light on the obscure art of tweaking particle systems, we are going to do a few examples. You can play with the particles and parameters on your own to see how much of a difference small changes make.</p><p>There are two ways of using particle systems: one-shot and continuous emitter. Let's make some examples of both.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec00038"/>One shot</h1></div></div></div><p>While using one <a class="indexterm" id="id000291"/>shot, we make the <code class="literal">ParticleSystem</code> launch all the particles at once.</p><p>In this case, we do not need to add or remove the <code class="literal">ParticleSystem</code> to or from the <code class="literal">GameEngine</code>, because the <code class="literal">onUpdate</code> method of the <code class="literal">ParticleSystem</code> does not need to be called (it is only used to emit new particles).</p><p>While using one shot, it is only logical to initialize the particle pool with the same number of particles that we plan to use for the shot.</p><p>The <code class="literal">oneShot</code> method of the <code class="literal">ParticleSystem</code> class is as follows:</p><div><pre class="programlisting">public void oneShot(GameEngine gameEngine, double x, double y,
    int numParticles) {
  mX = x;
  mY = y;
  mIsEmiting = false;
  for (int i=0; !mParticlePool.isEmpty() &amp;&amp; i&lt;numParticles; i++) {
    activateParticle(gameEngine);
  }
}</pre></div><p>We set the <em>x</em> and <em>y</em> coordinates from which we will emit and then set <code class="literal">isEmitting</code> to <code class="literal">false</code>. While updating <code class="literal">isEmitting</code> is only necessary when the <code class="literal">ParticleSystem</code> is added to the <code class="literal">GameEngine</code>, we do it just to be safe. In this case, setting <code class="literal">isEmitting</code> to false will make <code class="literal">onUpdate</code> simply do nothing.</p><p>Once the parameters are set, we get the particles from the pool and <code class="literal">activate</code> them. Remember that we already saw the <code class="literal">activate</code> method while explaining the <code class="literal">ParticleSystem</code> class. As part of the activation, the particles are added to the <code class="literal">GameEngine</code>.</p><p>We are going to use this <a class="indexterm" id="id000292"/>type of particle system for the explosion of <code class="literal">Asteroids</code> and the <code class="literal">Player</code>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00065"/>Asteroid explosions</h2></div></div></div><p>For the explosion of <a class="indexterm" id="id000293"/>asteroids, we are going to use a particle that has three small fragments of rock, so it will look like the asteroid has broken into multiple pieces. To enforce this effect, we will make the particles rotate and move in any direction, but not too far away.</p><p>We create and configure the <code class="literal">ParticleSystem</code> as part of the <code class="literal">Asteroid</code> creation. This will ensure that each asteroid has its own independent pool of particles:</p><div><pre class="programlisting">public Asteroid(GameController gameController, GameEngine gameEngine) {
  super(gameEngine, R.drawable.a10000, BodyType.Circular);
  mSpeed = 200d*mPixelFactor/1000d;
  mController = gameController;
  mExplisionParticleSystem = new ParticleSystem(gameEngine, EXPLOSION_PARTICLES, R.drawable.particle_asteroid_1, 700)
    .setSpeedRange(15, 40)
    .setFadeOut(300)
    .setInitialRotationRange(0, 360)
    .setRotationSpeedRange(-180, 180);
}

public void explode(GameEngine gameEngine) {
  mExplisionParticleSystem.oneShot(gameEngine, mX + mWidth / 2, mY + mHeight / 2, EXPLOSION_PARTICLES);
}</pre></div><p>The configuration of the particle system does the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The particles will live for 700 milliseconds.</li><li class="listitem" style="list-style-type: disc">They will be spawned in all directions with a speed that will vary between 15 and 40 units per second.</li><li class="listitem" style="list-style-type: disc">In the last 300 milliseconds, they will have an alpha modifier to fade out smoothly.</li><li class="listitem" style="list-style-type: disc">The particles will have any initial rotation. Note that the particle is not symmetrical; this is very important to prevent the particle from looking static.</li><li class="listitem" style="list-style-type: disc">Finally, each particle will have an angular rotation speed between -180 and 180 degrees per second.</li><li class="listitem" style="list-style-type: disc"><code class="literal">EXPLOSION_PARTICLES</code> is a constant for the <code class="literal">Asteroid</code>. We have set it at 15.</li></ul></div><p>The <code class="literal">explode</code> method does trigger <code class="literal">oneShot</code> from the center of the asteroid, which will put all the particles in motion.</p><p>The last connection point is <a class="indexterm" id="id000294"/>to trigger the <code class="literal">explode</code> method. This happens when a bullet collides with an asteroid or when the player collides with an asteroid. This is how it is done inside the <code class="literal">Bullet</code> class:</p><div><pre class="programlisting">@Override
public void onCollision(GameEngine gameEngine, ScreenGameObject otherObject) {
  if (otherObject instanceof Asteroid) {
    removeFromGameEngine(gameEngine);
    Asteroid a = (Asteroid) otherObject;
    a.explode(gameEngine);
    a.removeFromGameEngine(gameEngine);
  }
}</pre></div><p>This is it. Quite simple, right? Since the <code class="literal">ParticleSystem</code> is using a <code class="literal">oneShot</code>, it does not need to be added or removed to or from the <code class="literal">GameEngine</code>.</p><div><img alt="Asteroid explosions" src="img/B04757_05_02.jpg"/><div><p>Detail of the explosion particle and particle system.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00066"/>Spaceship explosions</h2></div></div></div><p>For the <code class="literal">Player</code> <a class="indexterm" id="id000295"/>explosion, we will use a different approach. We want it to look more dramatic. We will have a larger value for the speed than for the asteroid to give the impression of a much more aggressive explosion with an extended range. We will also use two different particles with different colors instead of one with several shards.</p><p>Since each <code class="literal">ParticleSystem</code> is designed to hold only one type of <code class="literal">Particle</code> (one image), we will have two <code class="literal">ParticleSystem</code> instances in the <code class="literal">Player</code> class that will be initialized in the constructor:</p><div><pre class="programlisting">mExplisionParticleSystem1 = new ParticleSystem(gameEngine,
EXPLOSION_PARTICLES, R.drawable.particle_ship_explosion_1, 600)
  .setSpeedRange(30, 150)
  .setInitialRotationRange(0,360)
  .setFadeOut(200);
mExplisionParticleSystem2 = new ParticleSystem(gameEngine,
EXPLOSION_PARTICLES, R.drawable.particle_ship_explosion_2, 600)
  .setSpeedRange(30, 150)
  .setInitialRotationRange(0,360)
  .setFadeOut(200);</pre></div><p>In this case, each particle is very small and symmetrical, so we don't need rotational speed. Since they are much faster than before, the time to live is also a bit shorter and the fade out is sharper.</p><p>In this case, <code class="literal">EXPLOSION_PARTICLES</code> is set to 20, so there are 40 particles in total.</p><p>When the <code class="literal">Player</code> object explodes (as a part of <code class="literal">onCollision</code>), we trigger <code class="literal">oneShot</code> on both <code class="literal">ParticleSystem</code> instances:</p><div><pre class="programlisting">mExplisionParticleSystem1.oneShot(gameEngine, mX + mWidth / 2, mY+mWidth/2, EXPLOSION_PARTICLES);
mExplisionParticleSystem2.oneShot(gameEngine, mX+mWidth/2, mY+mWidth/2, EXPLOSION_PARTICLES);</pre></div><p>As you can see, if you run it now, the explosion has a completely different feeling from the one for the asteroid:</p><div><img alt="Spaceship explosions" src="img/B04757_05_03.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec00039"/>Emitters</h1></div></div></div><p>The other way to use <a class="indexterm" id="id000296"/>particle systems is to configure them as emitters. This means that there is a ratio of particles per second that your system emits while it is active.</p><p>Calculating the right pool size is quite easy. It is just a formula based on the particle's time to live and the number of particles per second you want. For example, using 20 particles per second with 500 milliseconds time to live, you only need a pool of 10 particles, since they are returned to the pool as they die.</p><p>It is important to remember that a <code class="literal">ParticleSystem</code> working as an emitter needs to be added and removed from the <code class="literal">GameEngine</code>, since the <code class="literal">onUpdate</code> method is required to check for the spawning of more particles. The <code class="literal">onUpdate</code> method of the <code class="literal">ParticleSystem</code> looks like this:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  if (!mIsEmiting){
    return;
  }
  mTotalMillis += elapsedMillis;
  // We have to make sure that we have to keep emiting
  while ( !mParticlePool.isEmpty() &amp;&amp; // We have particles in the pool
    mActivatedParticles &lt; mParticlesPerMillisecond*mTotalMillis) {
    // and we are under the number of particles that should be launched
    // Activate a new particle
    activateParticle(gameEngine);
  }
}</pre></div><p>The code is quite simple. First we check weather the system is emitting or not. If the system is not emitting, we do not need to update anything, so we can simply return.</p><p>If it is emitting, we check whether we have to activate a particle. For this, we compare the number of particles that we have activated with the number of particles that should have been activated (<em>particlesPerMillisecond*totalMilliseconds</em>). We also need to be sure that we can have a particle from the pool (it is not empty).</p><p>Once we know that we need to spawn a particle and we have some particles available, we proceed to the activation. The last line on the <code class="literal">activateParticle</code> method increases the counter of activated particles.</p><p>Note that the number of activated particles is the total number of particles that have been activated by the emitter and not the current number of active particles.</p><p>The emit method from <a class="indexterm" id="id000297"/>
<code class="literal">ParticleSystem</code> is as follows:</p><div><pre class="programlisting">public void emit (int particlesPerSecond) {
  mActivatedParticles = 0;
  mTotalMillis = 0;
  mParticlesPerMillisecond = particlesPerSecond/1000d;
  mIsEmiting = true;
}</pre></div><p>Easy enough; it resets the number of activated particles and the time counter. It also calculates the rate of particles per millisecond (the parameter is passed as particles per second) and then sets <code class="literal">mIsEmitting</code> to <code class="literal">true</code>, so the <code class="literal">onUpdate</code> method should work.</p><p>Finally, to stop emitting we just need to set <code class="literal">mIsEmitting</code> to <code class="literal">false</code>:</p><div><pre class="programlisting">public void stopEmiting() {
  mIsEmiting = false;
}</pre></div><p>Let's look at some examples of emitters.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00067"/>Asteroid trails</h2></div></div></div><p>Asteroids will look a <a class="indexterm" id="id000298"/>lot cooler if they leave a trail behind them. Inside the constructor of the <code class="literal">Asteroid</code> class, we will create a <code class="literal">ParticleSystem</code> for the trail in the same place as the one for the explosion:</p><div><pre class="programlisting">mTrailParticleSystem = new ParticleSystem(gameEngine, 50, R.drawable.particle_dust, 600)
  .addModifier(new ScaleModifier(1, 2, 200, 600))
  .setFadeOut(200);</pre></div><p>For this trail, we are using a particle, that is two small pieces. To give a better feel of a trail, we add a <code class="literal">ScaleModifier</code> together with the fade out.</p><p>We want an initialization that depends on the values of the asteroid. To do so, we will set all the initializers during the call to <code class="literal">init</code> of the asteroid:</p><div><pre class="programlisting">public void init(GameEngine gameEngine) {
  […] // Standard initialization
  mTrailParticleSystem.clearInitializers()
    .setInitialRotationRange(0,360)
    .setRotationSpeed(mRotationSpeed * 1000);      
    .setSpeedByComponentsRange(
      -mSpeedY * 100, mSpeedY * 100, 
      mSpeedX * 100, mSpeedX * 100);
}</pre></div><p>First, we clean all the initializers and then set it to have any rotation. The rotation speed will be the same as the rotation speed of the asteroid. Then, the linear speed will be proportional and swapped from the asteroid components. This will make the trail move perpendicular to the asteroid.</p><p>The point of emission of the <code class="literal">ParticleSystem</code> needs to be updated on each run of <code class="literal">onUpdate</code> on the asteroid to keep emitting from the right position:</p><div><pre class="programlisting">mTrailParticleSystem.setPosition(mX + mWidth / 2, mY + mHeight / 2);</pre></div><p>Since it is an emitter, it needs to be added to and removed from the <code class="literal">GameEngine</code> together with the <code class="literal">Asteroid</code>. For this, we have already defined the <code class="literal">addToGameEngine</code> and <code class="literal">removeFromGameEngine</code> methods. We will override them now:</p><div><pre class="programlisting">@Override
public void addToGameEngine (GameEngine gameEngine, int layer) {
  super.addToGameEngine(gameEngine, layer);
  mTrailParticleSystem.addToGameEngine(gameEngine, mLayer-1);
  mTrailParticleSystem.emit(15);
}

@Override
public void removeFromGameEngine(GameEngine gameEngine) {
  super.removeFromGameEngine(gameEngine);
  mTrailParticleSystem.stopEmiting();
  mTrailParticleSystem.removeFromGameEngine(gameEngine);
}</pre></div><p>Note that we add it to the <code class="literal">GameEngine</code> one layer below the asteroids, so the particle system always goes behind them and not the other way around.</p><p>With this, we have all the <a class="indexterm" id="id000299"/>pieces in place and we can see how much nicer our asteroids look now:</p><div><img alt="Asteroid trails" src="img/B04757_05_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec00068"/>The spaceship's engine</h2></div></div></div><p>For the last effect, we will <a class="indexterm" id="id000300"/>add some smoke to the spaceship. Because it is an emitter, it needs to honor the <code class="literal">GameObject</code> lifecycle by adding and removing it from the <code class="literal">GameEngine</code> together with the player object, as we did for the asteroid trail:</p><div><pre class="programlisting">@Override
public void removeFromGameEngine(GameEngine gameEngine) {
  super.removeFromGameEngine(gameEngine);
  mEngineFireParticle.removeFromGameEngine(gameEngine);
}

@Override
public void addToGameEngine(GameEngine gameEngine, int layer) {
  super.addToGameEngine(gameEngine, layer);
  mEngineFireParticle.addToGameEngine(gameEngine, mLayer - 1);
  mEngineFireParticle.emit(12);
}</pre></div><p>Inside the <code class="literal">onUpdate </code>method, we have to synchronize the position of the player with the emitter of the <code class="literal">ParticleSystem</code>, as we did with the asteroid:</p><div><pre class="programlisting">mEngineFireParticle.setPosition(mX+mWidth/2, mY+mHeight);</pre></div><p>Note that we are setting the emitter at the bottom of the spaceship instead of the center. This makes the smoke appear in the right place.</p><p>Finally, we will create the <code class="literal">ParticleSystem</code> in the constructor of the <code class="literal">Player</code> object at the same place we are already creating the other two for the explosions:</p><div><pre class="programlisting">mEngineFireParticle = new ParticleSystem(gameEngine, 50, R.drawable.particle_smoke, 600)
  .setInitialRotationRange(0, 360)
  .setRotationSpeedRange(-30, 30)
  .setSpeedModuleAndAngleRange(50, 80, 60, 120)
  .setFadeOut(400);</pre></div><p>These configuration methods <a class="indexterm" id="id000301"/>are all well-known to us by now.</p><p>We have the whole range of the initial rotation [0-360] and a rotation speed that goes from -30 to 30 degrees per second. We also have a much longer fade out for other systems to make it dissolve in a smooth way.</p><p>We also use <code class="literal">setSpeedModuleAndAngleRange</code>, which sets the speed in terms of the angle and module. We want the smoke to get out of the spaceship in the range of [60-120] degrees (that is, an arc of 60 degrees going to the bottom of the spaceship) and with a speed that does not vary much.</p><p>You can run it now and see how it looks:</p><div><img alt="The spaceship's engine" src="img/B04757_05_05.jpg"/></div><p>While looking at a static image, you can see each particle, but when they are in motion, it feels really good.</p><p>Optionally, you could start <a class="indexterm" id="id000302"/>this particle system if there is some user input during <code class="literal">onUpdate</code> and stop it if not, which will give a more dynamic look and feel, since the smoke will appear only when the spaceship is moving.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec00040"/>Summary</h1></div></div></div><p>We have learned how particle systems work and how to integrate them into our game. We included <code class="literal">ParticleSystem</code> and the particles themselves into our <code class="literal">GameEngine</code>. We also learned about initializers and modifiers and how to create new ones to extend the system if we want to.</p><p>Then we saw how to compose a <code class="literal">GameObject</code> that has other <code class="literal">GameObject</code> instances inside it. In particular, particle systems do normally belong to another <code class="literal">GameObject</code>. For this, the <code class="literal">ParticleSystem</code> hooks into the lifecycle of the <code class="literal">GameObject</code>. We updated the <code class="literal">GameEngine</code> to make it easier to add <code class="literal">GameObjects</code> that are compositions.</p><p>Finally, we examined two examples of one shots and two examples of emitters that covered a variety of different parameters.</p><p>All in all, these four <code class="literal">ParticleSystem</code> instances make the game feel much more alive. Let's move on to the last step of making the game feel alive: sound effects.</p></div>
<div><div><div><div><h1 class="title"><a id="ch26"/>Chapter 6. Sound FX and Music</h1></div></div></div><p>A game feels incomplete without sound. In this chapter we will explore the different options for playing sound effects and music in Android, we will build a <code class="literal">SoundManager</code> class to handle them, and we will see how it interacts with the <code class="literal">GameEngine</code>.</p><p>For sound effects we will use <code class="literal">SoundPool</code>, which has been specifically designed for playing small sounds by preloading them in memory. To trigger the sound effects, we will introduce the concept of <code class="literal">GameEvent</code> and learn how they are propagated through the <code class="literal">GameEngine</code>.</p><p>In the case of background music, we will use <code class="literal">MediaPlayer</code> directly since long tracks do not work well with <code class="literal">SoundPool</code>, and <code class="literal">MediaPlayer</code> is the generic solution for playing all types of media files.</p><p>Finally, we will add controls to enable and disable sound effects and music on the home screen and make <code class="literal">SoundManager</code> take care of them.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec00041"/>SoundManager</h1></div></div></div><p>To manage sounds <a class="indexterm" id="id000303"/>and music, we are going to have a class called <code class="literal">SoundManager</code>. This class will be instantiated only once along the <code class="literal">Application</code> code and it will be done at <code class="literal">onCreate</code> of <code class="literal">YassActivity</code>. There are several reasons to do this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sound effects do take a little time to be loaded, so it is better to load them in advance</li><li class="listitem" style="list-style-type: disc">We may want to use sounds and music in the menus</li><li class="listitem" style="list-style-type: disc">Loading sounds and music requires memory; it does not make sense to duplicate that</li></ul></div><p>Let's look at the modifications we need to make to <code class="literal">YassActivity</code>:</p><div><pre class="programlisting">private SoundManager mSoundManager;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  [...]
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
  mSoundManager = new SoundManager(getApplicationContext());
}

public SoundManager getSoundManager() {
  return mSoundManager;
}</pre></div><p>We have a field that contains the <code class="literal">SoundManager</code>, and we initialize it during the <code class="literal">onCreate</code> method. We also provide a getter method for it.</p><p>There is another line that requires special mention:</p><div><pre class="programlisting">setVolumeControlStream(AudioManager.STREAM_MUSIC);</pre></div><p>This code sets the volume control stream of the application to be music. It tells the operating system that, when we press the physical volume keys while our application is running, we want it to modify the music volume instead of the default volume. There are seven stream types on <a class="indexterm" id="id000304"/>Android, one for each sound type, from system and ring tone volumes to alarms and notifications.</p><div><div><h3 class="title"><a id="note00052"/>Note</h3><p>To make the volume keys act over the music volume if pressed while the game is running, we should call <code class="literal">setVolumeControlStream(AudioManager.STREAM_MUSIC)</code> in the Activity.</p></div></div><p>Since we will be playing sound, this small tweak is very important to allow the user to control the volume of sounds during the course of the game.</p><p><code class="literal">SoundManager</code> will take care of the sounds and music using different classes from the Android SDK. It will also provide different methods to access them. Sound effects and music are independent features in the <code class="literal">SoundManager</code> class, so we will look at each of them separately.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec00042"/>Sound FX</h1></div></div></div><p>Sound effects will be used for <a class="indexterm" id="id000305"/>events in the game such as explosions, firing bullets, and so on, but also could be used in other cases such as menu clicks and dialogs  appearing. In our game we will add sound effects to the explosions of the asteroids and the spaceship as well as for laser firing.</p><p>We will begin discussing some ways to get sound effects for games. We cannot work if we don't have sound files, right?</p><p>Once we have our sounds in place, we will update <code class="literal">GameEngine</code> to provide a way to signal events in the game, and we will let <code class="literal">SoundManager</code> know when one of those events happens.</p><p>Finally we will explain how <a class="indexterm" id="id000306"/>
<code class="literal">SoundPool</code> works and how to include it in our <code class="literal">SoundManager</code>, associating a game event to a sound effect.</p><p>Hands on—let's get some sound files.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00069"/>How to create sound FXs</h2></div></div></div><p>For indie developers, there <a class="indexterm" id="id000307"/>are a few places where you can get sound effects. The already mentioned <code class="literal">OpenGameArt</code> not only has graphics but also sounds. One of the best places to find sound effects for games is the website <a class="ulink" href="http://www.freesound.org">www.freesound.org</a> (formerly "The Free Sound Project").</p><div><img alt="How to create sound FXs" src="img/B04757_06_01.jpg"/></div><p>In its own words: Freesound aims to create a huge collaborative database of audio snippets, samples, recordings, bleeps, and so on released under Creative Commons licenses that allow their reuse. Freesound provides new and interesting ways to access these samples, allowing users to browse the sounds in new ways using keywords, a "sounds-like" type of browsing, and more.</p><div><div><h3 class="title"><a id="note00053"/>Note</h3><p>Freesound.org is a great sound database under Creative Commons licenses.</p></div></div><p>It may take you a while to browse to the sounds you need, but this is a really useful resource. We used it when making Chalk Ball and SpaceCat at The Pill Tree.</p><p>For games that require simple sounds in a retro style, there is another project that is interesting: Bfxr (<a class="ulink" href="http://www.bfxr.net/">www.bfxr.net/</a>)</p><div><div><h3 class="title"><a id="note00054"/>Note</h3><p>Bfxr is a simple and handy utility to create retro-style sound effects.</p></div></div><p>Bfxr allows you to do a lot with sound waves, but you do not need to be an expert because it also has some buttons that will generate a new random sound based on certain parameters. These buttons are used for shoots, pickup, powerups, hits, and so on. Bfxr is inspired by as3sfxr, which is also simpler.</p><div><img alt="How to create sound FXs" src="img/B04757_06_02.jpg"/><div><p>The UI of the web version of bfxr</p></div></div><p>You have full rights to all sounds made with bfxr, therefore you are free to use them for any purposes, commercial or otherwise.</p><p>For YASS we have used bfxr to generate a few explosions and laser sounds and then picked the ones we liked <a class="indexterm" id="id000308"/>better. You can make your own and it will take you only a few minutes.</p><p>Now that we have the sounds, we need a place to put them inside our project. We could store the sounds as raw resources (under <code class="literal">res/raw</code>) but it is more handy to have them inside the <code class="literal">assets</code> folder, where we can have a hierarchical structure and there is no restriction on the file naming.</p><div><div><h3 class="title"><a id="note00055"/>Note</h3><p>We store the sound files under the <code class="literal">assets</code> folder.</p></div></div><p>We have to create the <code class="literal">assets</code> folder under the <code class="literal">src/main</code> directory of the project. Inside the <code class="literal">assets</code> folder we will <a class="indexterm" id="id000309"/>create another folder called <code class="literal">sfx</code> for all our sound files.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00070"/>GameEvents</h2></div></div></div><p>As we mentioned, we are <a class="indexterm" id="id000310"/>going to link sound effects to <code class="literal">GameEvents</code>, so first we <a class="indexterm" id="id000311"/>need our <code class="literal">GameEngine</code> to have support for such <code class="literal">GameEvents</code>. For that we create an enum that contains the <code class="literal">GameEvents</code> we are interested in:</p><div><pre class="programlisting">public enum GameEvent {
  AsteroidHit,
  SpaceshipHit,
  LaserFired
}</pre></div><p><code class="literal">GameEvents</code> will be propagated across the <code class="literal">GameEngine</code> in a way similar to a <code class="literal">BroadcastReceiver</code> or an <code class="literal">EventBus</code>. We create a new method <code class="literal">onGameEvent</code> in <code class="literal">GameEngine</code>. This method will be called when a <code class="literal">GameEvent</code> happens.</p><div><pre class="programlisting">public void onGameEvent (GameEvent gameEvent) {
  mSoundManager.playSoundForGameEvent(gameEvent);
}</pre></div><p>When a <code class="literal">GameEvent</code> arrives, we communicate it to the <code class="literal">SoundManager</code>. It will be easy to have all <code class="literal">GameObjects</code> subscribed to <code class="literal">GameEvents</code> by just adding a loop over the <code class="literal">GameObjects</code> inside this method.</p><p>The only thing left is to trigger the events when they happen. Let's see the ones triggered from the <code class="literal">Player</code> object:</p><div><pre class="programlisting">private void checkFiring(long elapsedMillis, GameEngine gameEngine) {
  if (gameEngine.mInputController.mIsFiring
    &amp;&amp; mTimeSinceLastFire &gt; TIME_BETWEEN_BULLETS) {
    [...]
<strong>    gameEngine.onGameEvent(GameEvent.LaserFired);</strong>
  }
  else {
    mTimeSinceLastFire += elapsedMillis;
  }
}

@Override
public void onCollision(GameEngine gameEngine, ScreenGameObject otherObject) {
  if (otherObject instanceof Asteroid) {
    [...]
<strong>    gameEngine.onGameEvent(GameEvent.SpaceshipHit);</strong>
  }
}</pre></div><p>Because the <code class="literal">GameEvents</code> happen during <code class="literal">onUpdate</code>, we always have a reference to the <code class="literal">GameEngine</code> at hand, and sending the event is as simple as adding a method call in the right place. The <code class="literal">Player</code> object now communicates the events of <code class="literal">LaserFired</code> and <code class="literal">SpaceshipHit</code> to the <code class="literal">GameEngine</code>.</p><p>Bullet does trigger a <code class="literal">GameEvent</code> as well.</p><div><pre class="programlisting">@Override
public void onCollision(GameEngine gameEngine, ScreenGameObject otherObject) {
  if (otherObject instanceof Asteroid) {
    [...]
<strong>    gameEngine.onGameEvent(GameEvent.AsteroidHit);</strong>
  }
}</pre></div><p>Now that the events are <a class="indexterm" id="id000312"/>triggered and they reach the <code class="literal">SoundManager</code>, we have to <a class="indexterm" id="id000313"/>actually play the specific sound when the event arrives. For that we need to build and configure the <code class="literal">SoundPool</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00071"/>Using SoundPool</h2></div></div></div><p><code class="literal">SoundPool</code> is a utility <a class="indexterm" id="id000314"/>designed to play multiple short sound files with <a class="indexterm" id="id000315"/>low latency playback. It does preloading of the files and it allows us to play several of them at the same time. The initial constructor for <code class="literal">SoundManager</code> will look like this:</p><div><pre class="programlisting">public SoundManager(Context context) {
  mContext = context;
  loadSounds();
}</pre></div><p>We are going to have a method that loads the sounds. At the moment this is used only once but later on, when we add a setting to enable or disable them, the sounds could be loaded and unloaded multiple times.</p><p>There is a specific method to handle the creation of the <code class="literal">SoundPool</code> because the default constructor has been deprecated on Lollipop and the new way of building it is quite verbose and not backwards-compatible; we need to branch the code based on the OS version.</p><div><pre class="programlisting">private void createSoundPool() {
  if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) {
    mSoundPool = new SoundPool(MAX_STREAMS, AudioManager.STREAM_MUSIC, 0);
  }
  else {
    AudioAttributes audioAttributes = new AudioAttributes.Builder()
      .setUsage(AudioAttributes.USAGE_GAME)
      .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
      .build();
    mSoundPool = new SoundPool.Builder()
      .setAudioAttributes(audioAttributes)
      .setMaxStreams(MAX_STREAMS)
      .build();
  }
}</pre></div><p>Both ways of building the <code class="literal">SoundPool</code> receive the same kind of parameters, but while the old one is just one constructor, the new one uses a builder and <code class="literal">AudioAttributes</code>.</p><p>The parameters of the now deprecated constructor are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Max streams</strong>: Maximum number of simultaneous streams to be played.</li><li class="listitem" style="list-style-type: disc"><strong>Stream type</strong>: the audio stream type as described in <code class="literal">AudioManager</code>. Games should use <code class="literal">STREAM_MUSIC</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Src quality</strong>: The <a class="indexterm" id="id000316"/>sample-rate converter quality. It has no <a class="indexterm" id="id000317"/>effect, so we just use 0.</li></ul></div><p>The new way of building the <code class="literal">SoundPool</code> replaces the stream type with the usage and content type of <code class="literal">AudioAttributes</code>, but you could use the legacy system type instead of these parameters and set it to <code class="literal">AudioManager.STREAM_MUSIC</code> if you prefer.</p><p>The parameter of max streams has the exact same meaning as before. <code class="literal">SoundPool</code> tracks the number of active streams. If the maximum number of streams is exceeded, <code class="literal">SoundPool</code> will automatically stop a previously playing one, based first on priority and then by age within that priority.</p><div><div><h3 class="title"><a id="note00056"/>Note</h3><p><code class="literal">SoundPool</code> is designed to play small sound files with low latency playback.</p></div></div><p>Using <code class="literal">SoundPool</code> is quite easy. When we load a file into the <code class="literal">SoundPool</code>, it will return a sound ID, which we need to use to play the sound later.</p><p>To store those sound IDs we will have a map inside <code class="literal">SoundManager</code> that has a <code class="literal">GameEvent</code> as key and <code class="literal">Integer</code> as the type of the values.</p><div><pre class="programlisting">private HashMap&lt;GameEvent, Integer&gt; mSoundsMap;</pre></div><p>We now create a method that loads a file into the <code class="literal">SoundPool</code> and associates it to a <code class="literal">GameEvent</code>:</p><div><pre class="programlisting">private void loadEventSound(Context context, GameEvent event, String filename) {
  try {
    AssetFileDescriptor descriptor = context.getAssets().openFd("sfx/" + filename);
    int soundId = mSoundPool.load(descriptor, 1);
    mSoundsMap.put(event, soundId);
  } catch (IOException e) {
    e.printStackTrace();
  }
}</pre></div><p><code class="literal">SoundPool</code> has several methods for loading files regarding of where they are located. Since our sound files are in <code class="literal">assets</code>, we need to use the one that receives an <code class="literal">AssetFileDescriptor</code>.</p><p>The load method also receives the priority as a parameter. The official documentation says that this currently has no effect and we should use 1 for future compatibility, so we do.</p><p>Finally we store the sound ID into the map.</p><p>We can get an <code class="literal">IOException</code> if the file we are trying to open does not exist. It is interesting to print the <a class="indexterm" id="id000318"/>stack trace if we miss some sounds while playing, to <a class="indexterm" id="id000319"/>check for possible typos.</p><p>It is time to look at <code class="literal">loadSounds</code>, which effectively combines all the code that we have seen until now:</p><div><pre class="programlisting">private void loadSounds() {
  createSoundPool();
  mSoundsMap = new HashMap&lt;GameEvent, Integer&gt;();
  loadEventSound(mContext, GameEvent.AsteroidHit, "Asteroid_explosion_1.wav");
  loadEventSound(mContext, GameEvent.SpaceshipHit, "Spaceship_explosion.wav");
  loadEventSound(mContext, GameEvent.LaserFired, "Laser_shoot.wav");
}</pre></div><p>Simple enough—we create the <code class="literal">SoundPool</code> and the sounds map. Then we load three sound files and associate them to the <code class="literal">GameEvents</code>.</p><p>We also have a method to unload the sounds:</p><div><pre class="programlisting">private void unloadSounds() {
  mSoundPool.release();
  mSoundPool = null;
  mSoundsMap.clear();
}</pre></div><p>To unload the sounds, we release the sound pool and clear the sound map.</p><p>The official documentation tells us to release the <code class="literal">SoundPool</code> and set it to null; then create a new one when loading a new set of sounds instead of unloading each of the sound effects. That is why a new <code class="literal">SoundPool</code> is created at the beginning of <code class="literal">loadSounds</code> instead of in the constructor of <code class="literal">SoundManager</code>.</p><p>At last we are ready to play a sound when a <code class="literal">GameEvent</code> arrives:</p><div><pre class="programlisting">public void playSoundForGameEvent(GameEvent event) {
  Integer soundId = mSoundsMap.get(event);
  if (soundId != null) {
    mSoundPool.play(soundId, 1.0f, 1.0f, 0, 0, 1.0f);
  }
}</pre></div><p>We get the sound ID from <a class="indexterm" id="id000320"/>the map and, if it is not null, we play it. This check is <a class="indexterm" id="id000321"/>important to make the game future-proof, when we evolve it to support more <code class="literal">GameEvents</code> and some of them do not have sound associated.</p><p>The parameters for the play method of <code class="literal">SoundPool</code> are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Left volume</strong>: Self-explanatory. A float value between 0.0 and 1.0.</li><li class="listitem" style="list-style-type: disc"><strong>Right volume</strong>: Also self-explanatory. A float value between 0.0 and 1.0.</li><li class="listitem" style="list-style-type: disc"><strong>Priority</strong>: 0 means lowest priority; all our sounds will have the same priority. It is used to select the sound to stop when the maximum number of streams is reached.</li><li class="listitem" style="list-style-type: disc"><strong>Loop</strong>: A loop value of -1 means loop forever, a value of 0 means don't loop, and other values indicate the number of repeats. We don't want to loop our sounds, so we pass 0.</li><li class="listitem" style="list-style-type: disc"><strong>Rate</strong>: A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed. The range is from 0.5 to 2.0.</li></ul></div><p>You could improve the feeling of the sound by tweaking the left and right volume based on the position of the event on the screen but we are not going to get into that, so we just use 1.0 for both left and right volumes.</p><p>The play method will return a stream ID that we could use to pause or resume this sound. Since we are using very short sounds that do not loop and are not interrupted, we do not need to store the stream ID at all.</p><p>Note that calling play may cause another sound to stop playing if the maximum number of active streams is exceeded.</p><p>With this architecture of <code class="literal">SoundManager</code>, it is very easy to add new sound effects by just associating them to a <code class="literal">GameEvent</code> <a class="indexterm" id="id000322"/>and triggering the event from whatever <a class="indexterm" id="id000323"/>
<code class="literal">GameObject</code> produces it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec00043"/>Playing music</h1></div></div></div><p>The other type of sound that a <a class="indexterm" id="id000324"/>game contains is background music. These tracks are usually longer than the sound effects and are played in a loop. In some cases there may be more than one track, for example, if we want a music for the menu and another one for the level, or if we want several levels with different background music tracks. We will work with a single one, but it is very easy to extend it to multiple tracks.</p><p>We are going to use <code class="literal">MediaPlayer</code> to play the background music in our game and we are going to abstract it via <code class="literal">SoundManager</code> as well, providing methods to pause and resume the music when the activity is paused and resumed.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00072"/>Obtaining music</h2></div></div></div><p>As with sound effects, we <a class="indexterm" id="id000325"/>need some tracks to work with. When it comes to making games on a budget, one of the best places to look for music that can be used for free is Jamendo.com. There are lots of albums under Creative Commons license, some of them very reasonably priced when it comes to using them to make commercial products, and most of them only require attribution (also known as giving credit to the artist).</p><div><img alt="Obtaining music" src="img/B04757_06_03.jpg"/><div><p>Jamendo is a great resource for Creative Commons music</p></div></div><p>We are going to use a track from Riccardo Colombo, entitled "Something mental", which has a nice ambient sound. We will also place that sound under the <code class="literal">sfx</code> folder we created inside <code class="literal">assets</code>.</p><p>On Android, MP3 files normally work fine, but OGG usually produces more consistent and reliable behavior among the <a class="indexterm" id="id000326"/>different devices and hardware capabilities. You can convert any MP3 to <a class="indexterm" id="id000327"/>OGG using an audio editor such as Audacity (<a class="ulink" href="http://audacity.sourceforge.net/">http://audacity.sourceforge.net/</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00073"/>MediaPlayer</h2></div></div></div><p><code class="literal">MediaPlayer</code> is quite <a class="indexterm" id="id000328"/>straight forward to use, but it also has a complicated life cycle and it is very strict in its usage. It can give problems if not used exactly as intended.</p><p>The life cycle consists<a class="indexterm" id="id000329"/> of several states and methods. While in a state, only a few methods can be called. Because of this, the invocation of the method calls must be done in precise sequence to move from one state to the next. If you call a method that is not allowed in the current state of <code class="literal">MediaPlayer</code>, it will crash with a cryptic error. Also, there is no method to know the current state of the MediaPlayer.</p><div><div><h3 class="title"><a id="note00057"/>Note</h3><p>If you call a method that is not allowed in the current state of <code class="literal">MediaPlayer</code>, it will crash with a cryptic error.</p></div></div><div><img alt="MediaPlayer" src="img/B04757_06_04.jpg"/></div><p>But do not worry, we are going to use it in the simplest way possible.</p><p>What we are going to do is <a class="indexterm" id="id000330"/>take the following actions to load the track:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <a class="indexterm" id="id000331"/><code class="literal">MediaPlayer</code> object, so it is in the <strong>Idle</strong> state.</li><li class="listitem">Set the data source, so it becomes <strong>Initialized</strong>.</li><li class="listitem">Call <code class="literal">prepare</code>. This moves <code class="literal">MediaPlayer</code> to the <strong>Prepared</strong> state.</li><li class="listitem">From <strong>Prepared</strong>, we will call <code class="literal">start</code>, so it moves to <strong>Started</strong>.</li><li class="listitem">While playing we may <code class="literal">pause</code> the stream, moving to <strong>Paused</strong>. And from <strong>Paused</strong> we can call <code class="literal">start</code> again to go back to <strong>Started</strong>.</li></ol></div><p>We will also have a method to unload the track so the music can be enabled and disabled at any moment. To unload the track we just have to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Call stop</strong>. This will work from either <strong>Started</strong> or <strong>Paused</strong>. This call will make the music stop.</li><li class="listitem" style="list-style-type: disc"><strong>Call release</strong>. This will move to the <strong>End</strong> status from any other state. Note that there is no way to get out of the <strong>End</strong> state, so when we want to load the music again, we need to create a new <code class="literal">MediaPlayer</code> and start again from the beginning.</li></ul></div><p>The situation we need to take care of the most is to avoid calling <code class="literal">pause</code> while in the <strong>Prepared</strong> or <strong>Paused</strong> states. That <a class="indexterm" id="id000332"/>method is not allowed there, and will <code class="literal">MediaPlayer</code> in to a non-working state. However, if you follow the steps provided here, you <a class="indexterm" id="id000333"/>will not have to worry about it.</p><p>Let's look at the methods we have in <code class="literal">SoundManager</code> to handle background music:</p><div><pre class="programlisting">private void loadMusic() {
  try {
    mBgPlayer = new MediaPlayer();
    AssetFileDescriptor afd = mContext.getAssets()
      .openFd("sfx/Riccardo_Colombo_-_11_-_Something_mental.mp3");
    mBgPlayer.setDataSource(
      afd.getFileDescriptor(),
      afd.getStartOffset(),
      afd.getLength());
    mBgPlayer.setLooping(true);
    mBgPlayer.setVolume(DEFAULT_MUSIC_VOLUME, DEFAULT_MUSIC_VOLUME);
    mBgPlayer.prepare();
  }
  catch (IOException e) {
    e.printStackTrace();
  }
}

private void unloadMusic() {
  mBgPlayer.stop();
  mBgPlayer.release();
}

public void pauseBgMusic() {
  mBgPlayer.pause();
}

public void resumeBgMusic() {
  mBgPlayer.start();
}</pre></div><p>The only points we haven't covered yet are the calls to <code class="literal">setLooping</code> and <code class="literal">setVolume</code>. They are quite clear on their own: <code class="literal">setLooping</code> sets the media player into looping or not-looping mode based on the parameter; <code class="literal">setVolume</code> sets the left and right volumes for this instance of <code class="literal">MediaPlayer</code>. For the volume we are using a constant <code class="literal">DEFAULT_MUSIC_VOLUME</code> that we have set to a value of 0.6, so the music is played more softly than the sound effects.</p><p>We can get an <code class="literal">IOException</code> when loading the music for the same reason we might have one with the sound effects: if the file does not exist. As we did earlier, if that happens we just log it and continue.</p><p>Of course we also need to load <a class="indexterm" id="id000334"/>the music when we initialize the <code class="literal">SoundManager</code>, calling <a class="indexterm" id="id000335"/>
<code class="literal">loadMusic</code> just after we call <code class="literal">loadSounds</code>.</p><div><pre class="programlisting">public SoundManager(Context context) {
  mContext = context;
  loadSounds();
<strong>  loadMusic();</strong>
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00074"/>Music and Activity life cycle</h2></div></div></div><p>In this section we will handle <a class="indexterm" id="id000336"/>pausing and resuming the music. For that, the only thing <a class="indexterm" id="id000337"/>we need to do is link the <code class="literal">SoundManager</code> to the Activity life cycle. In the next section we will take care of unloading and loading the music on-demand when the user changes the preferences:</p><div><pre class="programlisting">@Override
protected void onPause() {
  super.onPause();
  mSoundManager.pauseBgMusic();
}

@Override
protected void onResume() {
  super.onResume();
  mSoundManager.resumeBgMusic();
}</pre></div><p>Remember that we create the <code class="literal">SoundManager</code> during <code class="literal">onCreate</code>. Now we add the method calls to pause the music when the activity calls <code class="literal">onPause</code> and resume it when the activity calls <code class="literal">onResume</code>.</p><p>This allows us to pause the music when another app comes to the foreground (or when the game is put to the background) and then resume it when it returns to the foreground.</p><p>Do not allow the user to manually pause or resume the background music; this can put <code class="literal">MediaPlayer</code> into an <a class="indexterm" id="id000338"/>inconsistent state. Instead of pausing the music, we will allow the user to disable music, which is a different process and one that we will cover in the next section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec00044"/>Enabling and disabling music and sound FX</h1></div></div></div><p>Now we have music <a class="indexterm" id="id000339"/>and sound effects working, but we are missing a very important <a class="indexterm" id="id000340"/>point: allowing the user to disable them. If you add sounds <a class="indexterm" id="id000341"/>to a game, you need to provide a way to disable them. Many people like to play in silence.</p><div><div><h3 class="title"><a id="note00058"/>Note</h3><p>Always provide a way for the user to disable music and sound effects individually.</p></div></div><p>To do this, we will add two buttons on the main screen (one for music and one for sounds) to enable and disable each one independently. These options should also be present on the <strong>Pause</strong> dialog, but we will get into that when we rework the dialogs in the next chapter.</p><p>On the one hand, we are going to update the layout and the code of <code class="literal">MainMenuFragment</code>; on the other hand, we will make <code class="literal">SoundManager</code> take care of this configuration.</p><p>To store the music and sound state we will use <code class="literal">SharedPreferences</code>, as it is the simplest and most convenient way to store key-value persistent data on Android.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00075"/>Updating MainMenuFragment</h2></div></div></div><p>Until now, a <code class="literal">FrameLayout</code> has been good enough for us. At this point we want to have the sound and music <a class="indexterm" id="id000342"/>buttons on one side and together, so we need to replace it with a <code class="literal">RelativeLayout</code>.</p><p>The updated version of <code class="literal">fragment_main.xml</code> is as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  &gt;

  &lt;TextView
    style="@android:style/TextAppearance.DeviceDefault.Large"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:text="@string/game_title"
    android:layout_centerHorizontal="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" /&gt;

  &lt;Button
    android:id="@+id/btn_start"
    android:layout_centerInParent="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/start" /&gt;

  &lt;Button
    android:id="@+id/btn_sound"
    android:layout_margin="@dimen/activity_vertical_margin"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:layout_alignParentRight="true"
    android:text="@string/sound_on" /&gt;

  &lt;Button
    android:id="@+id/btn_music"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignBottom="@+id/btn_sound"
    android:layout_toLeftOf="@+id/btn_sound"
    android:text="@string/music_on" /&gt;
&lt;/RelativeLayout&gt;</pre></div><p>No specific comments are <a class="indexterm" id="id000343"/>required. We just have <code class="literal">btn_sound</code> and <code class="literal">btn_music</code> added to the bottom right and with the correct margins, aligning the music button to the bottom of the sound one and placing it to the left of it.</p><div><img alt="Updating MainMenuFragment" src="img/B04757_06_06.jpg"/></div><p>The code is a bit more interesting. We have to modify <code class="literal">MainMenuFragment</code> to handle the click on the new buttons as well as to place the correct text on them. For this we will modify <code class="literal">onViewCreated</code> and <code class="literal">onClick</code> and add a new method to place the correct text on each button.</p><p>First we have to add <a class="indexterm" id="id000344"/>
<code class="literal">MainMenuFragment</code> as a click listener to these buttons during <code class="literal">onViewCreated</code>:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  view.findViewById(R.id.btn_start).setOnClickListener(this);
  view.findViewById(R.id.btn_sound).setOnClickListener(this);
  view.findViewById(R.id.btn_music).setOnClickListener(this);
  updateSoundAndMusicButtons();
}</pre></div><p>Then we have to handle the click. For that we rely on methods we will create inside <code class="literal">SoundManager</code> to toggle the values. Once that is done, we update the text on the buttons.</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  if (v.getId() == R.id.btn_start){
    ((YassActivity) getActivity()).startGame();
  }
  else if (v.getId() == R.id.btn_music) {
    SoundManager soundManager = getYassActivity().getSoundManager();
    soundManager.toggleMusicStatus();
    updateSoundAndMusicButtons();
  }
  else if (v.getId() == R.id.btn_sound) {
    SoundManager soundManager = getYassActivity().getSoundManager();
    soundManager.toggleSoundStatus();
    updateSoundAndMusicButtons();
  }
}</pre></div><p>Finally, the method <code class="literal">updateSoundAndMusicButtons</code> simply reads the state of sound and music from the <a class="indexterm" id="id000345"/>
<code class="literal">SoundManager</code> and sets the correct string resource on each button.</p><div><pre class="programlisting">private void updateSoundAndMusicButtons() {
  SoundManager soundManager = getYassActivity().getSoundManager();
  TextView btnMusic = (TextView) getView().findViewById(R.id.btn_music);
  if (soundManager.getMusicStatus()) {
    btnMusic.setText(R.string.music_on);
  }
  else {
    btnMusic.setText(R.string.music_off);
  }
  TextView btnSounds= (TextView) getView().findViewById(R.id.btn_sound);
  if (soundManager.getSoundStatus()) {
    btnSounds.setText(R.string.sound_on);
  }
  else {
    btnSounds.setText(R.string.sound_off);
  }
}</pre></div><p>As we mentioned, all the heavy work is done inside <code class="literal">SoundManager</code>, especially in the methods we have not implemented yet: <code class="literal">toggleMusicStatus</code> and <code class="literal">toggleSoundStatus</code>.</p><p>Let's get into <code class="literal">SoundManager</code> then.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec00076"/>Updating SoundManager</h2></div></div></div><p>Our <code class="literal">SoundManager</code> is <a class="indexterm" id="id000346"/>responsible for reading, changing, and restoring the values of the sound and music preferences. To do that we read them from <code class="literal">SharedPreferences</code> on construction and provide a method to change the setting that also takes care of the loading and unloading of the sound files as needed.</p><div><pre class="programlisting">private boolean mSoundEnabled;
private boolean mMusicEnabled;

public SoundManager(Context context) {
  SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
  mSoundEnabled = prefs.getBoolean(SOUNDS_PREF_KEY, true);
  mMusicEnabled = prefs.getBoolean(MUSIC_PREF_KEY, true);
  mContext = context;
  loadIfNeeded();
}

private void loadIfNeeded () {
  if (mSoundEnabled) {
    loadSounds();
  }
  if (mMusicEnabled) {	
    loadMusic();
  }
}

public boolean getSoundStatus() {
  return mSoundEnabled;
}

public boolean getMusicStatus() {
  return mMusicEnabled;
}</pre></div><p>With this initialization, we read the values from <code class="literal">SharedPreferences</code> and store them in the member variables <code class="literal">mSoundEnabled</code> and <code class="literal">mMusicEnabled</code>, which can be accessed at any time and don't need to be read from disk. Once the values are read, we load the sounds and music only if they <a class="indexterm" id="id000347"/>are enabled.</p><p>We also provide the accessor methods <code class="literal">getSoundStatus</code> and <code class="literal">getMusicStatus</code>, which we were already using on <code class="literal">MainMenuFragment</code> to update the text on the buttons.</p><p>To change the value of each of the variables we have to use a method that will take care of saving the status and also to load or unload the required files. Let's see the method for the sounds:</p><div><pre class="programlisting">public void toggleSoundStatus() {
  mSoundEnabled = !mSoundEnabled;
  if (mSoundEnabled) {
    loadSounds();
  }
  else {
    unloadSounds();
  }
  // Save it to preferences
  PreferenceManager.getDefaultSharedPreferences(mContext).edit()
    .putBoolean(SOUNDS_PREF_KEY, mSoundEnabled)
    .commit();
}</pre></div><p>The method switches the value of the setting to the logical negation of what it was. Then it loads or unloads the sounds based on the new value. Finally it stores the updated value on <code class="literal">SharedPreferences</code> so the member variable and the stored one are in sync.</p><p>In the case of music, the <a class="indexterm" id="id000348"/>method has the exact same logic but loads and unloads the music based on the value of <code class="literal">mMusicEnabled</code> and the preferences key is the constant <code class="literal">MUSIC_PREF_KEY</code> instead.</p><div><pre class="programlisting">public void toggleMusicStatus() {
  mMusicEnabled = !mMusicEnabled;
  if (mMusicEnabled) {
    loadMusic();
    resumeBgMusic();
  }
  else {
    unloadMusic();
  }
  // Save it to preferences
  PreferenceManager.getDefaultSharedPreferences(mContext).edit()
    .putBoolean(MUSIC_PREF_KEY, mMusicEnabled)
    .commit();
}</pre></div><p>To complete the functionality, we are yet to modify <code class="literal">playSoundForGameEvent</code> as well as <code class="literal">pauseBgMusic</code> and <code class="literal">resumeBgMusic</code> to only do something when the sounds or music are enabled. It is as simple as adding a check at the beginning of each one of the methods involved.</p><div><pre class="programlisting">public void playSoundForGameEvent(GameEvent event) {
  if (!mSoundEnabled) {
    return;
  }
  Integer soundId = mSoundsMap.get(event);
  if (soundId != null) {
    mSoundPool.play(soundId, 1.0f, 1.0f, 0, 0, 1.0f);
  }
}

public void pauseBgMusic() {
  if (mMusicEnabled) {
    mBgPlayer.pause();
  }
}

public void resumeBgMusic() {
  if (mMusicEnabled) {
    mBgPlayer.start();
  }
}</pre></div><p>Note that this check is very <a class="indexterm" id="id000349"/>important because we can easily get <code class="literal">NullPointerExceptions</code> when trying to access uninitialized components.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec00045"/>Disabling system sounds</h1></div></div></div><p>Android has default sounds for <a class="indexterm" id="id000350"/>button clicks. If you want to use your own sounds for the click action, you also have to disable the system sounds. This is something that we will want almost every time. Luckily it is very easy to do. We just have to modify the application style we have already defined in <code class="literal">res/styles.xml</code> and tell it that we want to disable sound effects:</p><div><pre class="programlisting">&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
  &lt;item name="android:soundEffectsEnabled"&gt;false&lt;/item&gt;
&lt;/style&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec00046"/>Summary</h1></div></div></div><p>We have created a <code class="literal">SoundManager</code> that loads and unloads sound effects and music tracks from the assets folder, using the classes Android has for it—<code class="literal">SoundPool</code> and <code class="literal">MediaPlayer</code>—and we have learned the best use for each of them.</p><p>To play sounds we have added a <code class="literal">GameEvent</code> messaging system to the <code class="literal">GameEngine</code> that can be used for other purposes; this is a common mechanism for synchronizing <code class="literal">GameObjects</code>.</p><p>For music we have linked pausing and resuming the music with the Activity life cycle.</p><p>We have also added the possibility of enabling and disabling sounds and music independently at any time and stored the states in a persistent storage.</p><p>At this point the <code class="literal">GameEngine</code> is mostly complete. In the following chapters we are going to focus on the tools that Android provides to make the UI nicer and more compelling, improving the look and feel of the game overall.</p></div>
<div><div><div><div><h1 class="title"><a id="ch27"/>Chapter 7. Menus and Dialogs</h1></div></div></div><p>Now that the game works, it is time to tweak the rest of the UI. When you make an app, the best practice is to use all the standard UI components. Games are different, they should have personality. For this we are going to see how to use custom fonts, buttons, and dialogs.</p><p>We will start by making all the fragments of the game use a custom font. Then we will tweak the main menu to make it look nicer by adding a background and customizing the buttons for sound and music; we will also customize the button that starts the game using special drawable types we can define in XML.</p><p>For <code class="literal">GameFragment</code>, we will make space to display the score and lives and will update the pause button as well. We will make the game take care of scoring and player deaths. For this we will also see how to use <code class="literal">GameEvents</code>, not just for playing sounds, but also for extending the functionality, and adding a few events.</p><p>We will also make <code class="literal">GameController</code> take more responsibility for the game situation by using a state machine. This technique can be applied to other cases such as new levels, etc.</p><p>Finally, since the Android framework for dialogs is quite limited, we'll see how we can create custom dialogs for quitting the game, pausing, and game over.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec00047"/>Custom fonts</h1></div></div></div><p>For app <a class="indexterm" id="id000351"/>developers, Google has always enforced the use of the system default font, especially since Robotto was introduced. That is the reason why there are no other fonts in the system. However, <code class="literal">TextView</code> can use custom fonts in True Type (<code class="literal">.ttf</code>) or Open Type (<code class="literal">.otf</code>) formats.</p><p>When choosing a font, you have lots of choices. There are websites that list lots of fonts that are free to use. Because YASS is meant to be a retro-style shooter, I picked a pixel-art style font called Adore64.</p><p>We will store the font files into a folder under <code class="literal">assets</code> that we will name <code class="literal">ttf</code>, in the same way as we did for sounds.</p><p>To load <a class="indexterm" id="id000352"/>the font in a format that can be used by <code class="literal">TextView</code>, we have the <code class="literal">Typeface</code> class. The process of loading a font is expensive, so we will do it only once (inside <code class="literal">onCreate</code>) and we will keep the <code class="literal">Typeface</code> variable as a member of the <code class="literal">Activity</code>.</p><div><div><h3 class="title"><a id="note00059"/>Note</h3><p>Loading a Typeface is expensive; we should keep it in memory (at the Activity level).</p></div></div><p>The code we have to add to <code class="literal">YassActivity</code> for loading a font is very simple:</p><div><pre class="programlisting">private Typeface mCustomTypeface;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  [...]
  mCustomTypeface = Typeface.createFromAsset(getAssets(), "ttf/Adore64.ttf");
}</pre></div><p>Once the font is loaded, we just need to apply it to all the text views of the hierarchy. This can be done easily using recursion:</p><div><pre class="programlisting">public void applyTypeface (View view) {
  if (view instanceof ViewGroup) {
    // Apply recursively to all the children
    ViewGroup viewGroup = (ViewGroup) view;
    for (int i=0; i&lt;viewGroup.getChildCount(); i++) {
      applyTypeface(viewGroup.getChildAt(i));
    }
  }
  else if (view instanceof TextView) {
    TextView tv = (TextView) view;
    tv.setTypeface(mCustomTypeface);
  }
}</pre></div><p>The method receives a <code class="literal">View</code>. If it is an instance of <code class="literal">ViewGroup</code>, it means that it has (or can have) more views as children, so we iterate over all the children using this same method recursively.</p><p>If the view is an instance of <code class="literal">TextView</code>, we just call the method <code class="literal">setTypeface</code>, which only exists on <code class="literal">TextView</code>, and we can move on.</p><p>For any other type of views, we do nothing.</p><div><div><h3 class="title"><a id="note00060"/>Note</h3><p>Applying a typeface to all our views is easy to do using recursive algorithms.</p></div></div><p>Note that <a class="indexterm" id="id000353"/>
<code class="literal">instanceof</code> checks if the object complies with the class given. This means that objects from classes that extend from it will return true. This is key for this algorithm to work, since all the <code class="literal">Layout</code> classes are children of <code class="literal">ViewGroup</code> and all views that hold text (that is <code class="literal">Button</code>) extend from <code class="literal">TextView</code>.</p><p>The missing link is, where do we invoke this method and with which parameters? We will do it using the method <code class="literal">onViewCreated</code> of <code class="literal">YassBaseFragment</code>.</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  getYassActivity().applyTypeface(view);
}</pre></div><p>Since all the fragments will extend from this one, they will all have the <code class="literal">Typeface</code> set automatically.</p><p>If we want to use more than one font in the game, the code starts to become complex and it is a better idea to use a library to take care of it. For this I recommend using Calligraphy (<a class="ulink" href="https://github.com/chrisjenx/Calligraphy">https://github.com/chrisjenx/Calligraphy</a>), which<a class="indexterm" id="id000354"/> hooks into the <code class="literal">ContextWrapper</code> to load the typeface when inflating the views instead of traversing the hierarchy later, and also supports XML attributes to set a specific font to a specific view.</p><div><div><h3 class="title"><a id="note00061"/>Note</h3><p>Calligraphy is a great library if you want to use multiple fonts in your Android project.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec00048"/>Working with backgrounds</h1></div></div></div><p>Something<a class="indexterm" id="id000355"/> that makes the game look bad is the plain white background we have at the moment. While we could set a background for the activity, this is not the best solution because background images are set to scale to fit, and that cannot be changed. When using a background image it will expand to cover all the view.</p><div><div><h3 class="title"><a id="note00062"/>Note</h3><p>The attribute <code class="literal">android:background</code> will stretch the image to make it fit in the view.</p></div></div><p>We do not want our background image to be stretched in one dimension. We want it to scale uniformly on both axes.</p><p>This can be <a class="indexterm" id="id000356"/>improved with the use of a 9-patch as the background image, but in our case we will just use an <code class="literal">ImageView</code> that covers all the layout with <code class="literal">scaleType</code> set to <code class="literal">centerCrop</code>. This parameter does scale the image uniformly (maintaining the image's aspect ratio) so that both dimensions of the image (width and height) will be equal to or larger than the corresponding dimension of the <code class="literal">View</code>.</p><p>We will add an <code class="literal">ImageView</code> at the beginning of <code class="literal">fragment_main_menu.xml</code> with the desired <code class="literal">scaleType</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_width="match_parent"
  android:layout_height="match_parent" &gt;
  &lt;ImageView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scaleType="centerCrop"
    android:src="img/seamless_space_0"/&gt;
[…]
&lt;/RelativeLayout&gt;</pre></div><p>And just with the fonts and the background, the main menu looks much better already!</p><div><img alt="Working with backgrounds" src="img/B04757_07_01.jpg"/></div><p>We could use a <code class="literal">GameView</code> instead of an <code class="literal">ImageView</code> to have a parallax background, I leave this as an exercise <a class="indexterm" id="id000357"/>for readers interested in tweaking backgrounds even more.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00077"/>The power of XML drawables</h2></div></div></div><p>Until <a class="indexterm" id="id000358"/>now <a class="indexterm" id="id000359"/>we have used drawables that are images, but Android provides a very complete framework that allows us to use other types of resources. A drawable resource is a general concept for a graphic that can be drawn to the screen. There are several types of drawables that you can define in XML.</p><p>We are going to describe state lists and shape drawables, but there are a few more. In particular if you are not familiar with 9-patches, you should check them out as well.</p><div><div><h3 class="title"><a id="note00063"/>Note</h3><p>You can learn about all drawable resources in the official documentation: <a class="ulink" href="http://developer.android.com/guide/topics/resources/drawable-resource.html">http://developer.android.com/guide/topics/resources/drawable-resource.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00078"/>State list drawables</h2></div></div></div><p><code class="literal">StateListDrawable</code> is <a class="indexterm" id="id000360"/>a drawable object defined in XML <a class="indexterm" id="id000361"/>that uses several other drawables to represent the same graphic depending on the state of the object. The framework defines many states, but we will only use <code class="literal">pressed</code>, <code class="literal">focused</code>, and <code class="literal">default</code> (no state). There is also a state named <code class="literal">selected</code> that should not be confused with <code class="literal">focused</code>. In fact selected is hardly ever used.</p><p>The state list is described in an XML file that has <code class="literal">&lt;selector&gt;</code> as the root tag. Each graphic is represented by an <code class="literal">&lt;item&gt;</code> element which can use various attributes to describe the state in which it should be used as the graphic for the drawable.</p><p>When the state changes, the list is checked in sequential order and the first item that matches the current state is used. It is important to remember that this selection of state is not based on a best match but on a first match. The best practice for defining state lists is to put the most restrictive states at the beginning and to have a default state as the last item.</p><div><div><h3 class="title"><a id="note00064"/>Note</h3><p>The order of the states is very important. The first match on the list is the one that is used.</p></div></div><p>We are going to use state list drawables for the music and sound buttons. We will then have four state list drawables—music on, music off, sound on &amp; sound off—and for each of them we will have three states: pressed, focused, and normal.</p><p>These <a class="indexterm" id="id000362"/>views will not be buttons any longer but an <code class="literal">ImageView</code> instead. A bit of a code tweaking will be needed in order to make this change, basically inside <code class="literal">updateSoundAndMusicButtons</code>, which should use drawables now instead of texts.</p><p>Regarding the look and feel, we are going to make a circle of a color that represents the state, and then use the same icon for all of the states, just changing the color. We will also make the pressed state a bit smaller—to give the feeling of being pressed—by adding margins to the image.</p><p>We are using white for normal state, yellow for pressed, and blue for focused.</p><div><img alt="State list drawables" src="img/B04757_07_02.jpg"/><div><p>All the composed drawables for the states of sound and music</p></div></div><p>The state drawable files should be placed into the <code class="literal">res/drawable</code> directory because they are just a list of references and therefore they are independent of the density. On the other hand, we should provide density-specific versions of the drawables that are referenced as states.</p><p>Now, instead of providing 12 icons, since all of them use the same background we can configure this using 4 icons, 3 background states and 1 state drawable that will be the background for all of them. This will also allow us to reuse the background for other buttons.</p><p>This is the<a class="indexterm" id="id000363"/> code of the state list drawable that we will use for the background:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector &gt;
  &lt;item
    android:drawable="@drawable/icon_button_bg_pressed"
    android:state_pressed="true"/&gt;
  &lt;item
    android:drawable="@drawable/icon_button_bg_selected"
    android:state_focused="true"/&gt;
  &lt;item
    android:drawable="@drawable/icon_button_bg_normal"/&gt;
&lt;/selector&gt;</pre></div><p>As we already said, the order is very important. We want to show the pressed state when it is pressed; we do not care if it is focused or not, so that is the first case. Then we want to show if it is focused. Finally  we have a default case with no parameters that covers "everything else".</p><p>The backgrounds have been created using GIMP and the base icons are free ones that we found using an icon search website such as <a class="indexterm" id="id000364"/>IconFinder (<a class="ulink" href="https://www.iconfinder.com">https://www.iconfinder.com</a>). There are many icon search websites. Try several and see which one you like best.</p><p>Note that the naming convention is to use a name for the state list and then the same name followed by pressed, selected, or normal for each state.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec00014"/>State lists colors</h3></div></div></div><p>We can use selectors to<a class="indexterm" id="id000365"/> define colors as well as images. This can be used on the text that goes into a button or the background of a view. It works the same way as for drawables, but uses the <code class="literal">color</code> keyword instead of <code class="literal">drawable</code>. The files that define colors must be placed under the <code class="literal">res/colors</code> directory.</p><p>An example of a color state list that we will reference later is <code class="literal">btn_background.xml</code>.</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector &gt;
  &lt;item
    android:color="@color/btn_pressed"
    android:state_pressed="true"/&gt;
  &lt;item
    android:color="@color/btn_focused"
    android:state_selected="true"/&gt;
  &lt;item
    android:color="@color/btn_normal"/&gt;
&lt;/selector&gt;

</pre></div><p>And of<a class="indexterm" id="id000366"/> course we need to define these colors as well. Note that these colors are not state lists, and therefore should be defined in a file under the <code class="literal">res/values</code> directory. We normally call this file <code class="literal">colors.xml</code> as a convention, but any name will work.</p><div><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;resources&gt;
  &lt;color name="btn_selected"&gt;#39a29c&lt;/color&gt;
  &lt;color name="btn_normal"&gt;#ffffff&lt;/color&gt;
  &lt;color name="btn_pressed"&gt;#fdd33f&lt;/color&gt;
&lt;/resources&gt;</pre></div><div><div><h3 class="title"><a id="note00065"/>Note</h3><p>State list color XML files are placed under <code class="literal">res/color</code>, but normal colors are defined as values in files under <code class="literal">res/values</code> instead.</p></div></div><p>As good practice, you should always externalize all the variables of the layouts . This is valid for colors, dimensions, and strings.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00079"/>Shape drawables</h2></div></div></div><p>Shape drawables <a class="indexterm" id="id000367"/>are exactly what the name suggests: a <a class="indexterm" id="id000368"/>way to define a generic shape in XML. We are going to use them to make all the button backgrounds.</p><p>The syntax for shape drawables is defined as this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape
  
  android:shape=["rectangle" | "oval" | "line" | "ring"] &gt;
  &lt;corners
    android:radius="integer"
    android:topLeftRadius="integer"
    android:topRightRadius="integer"
    android:bottomLeftRadius="integer"
    android:bottomRightRadius="integer" /&gt;
  &lt;gradient
    android:angle="integer"
    android:centerX="integer"
    android:centerY="integer"
    android:centerColor="integer"
    android:endColor="color"
    android:gradientRadius="integer"
    android:startColor="color"
    android:type=["linear" | "radial" | "sweep"]
    android:useLevel=["true" | "false"] /&gt;
  &lt;padding
    android:left="integer"
    android:top="integer"
    android:right="integer"
    android:bottom="integer" /&gt;
  &lt;size
    android:width="integer"
    android:height="integer" /&gt;
  &lt;solid
    android:color="color" /&gt;
  &lt;stroke
    android:width="integer"
    android:color="color"
    android:dashWidth="integer"
    android:dashGap="integer" /&gt;
&lt;/shape&gt;</pre></div><p>The top level <a class="indexterm" id="id000369"/>tag of the shape drawable is <code class="literal">&lt;shape&gt;</code> and it has an<a class="indexterm" id="id000370"/> attribute also named <code class="literal">shape</code> that defines its type. Possible values are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">rectangle</code>: a rectangle<a class="indexterm" id="id000371"/> that fills the containing view. This is the default shape if none is specified.</li><li class="listitem" style="list-style-type: disc"><code class="literal">oval</code>: an<a class="indexterm" id="id000372"/> oval shape that fits the dimensions of the containing view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">line</code>: a <a class="indexterm" id="id000373"/>horizontal line that spans the width of the containing view. This shape requires the <code class="literal">&lt;stroke&gt;</code> element to define the width of the line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ring</code>: a<a class="indexterm" id="id000374"/> ring shape. This shape allows some other attributes to be properly defined such as <code class="literal">innerRadius/innerRadiusRatio</code>, <code class="literal">thickness/thicknessRatio</code>, and <code class="literal">useLevel</code>.</li></ul></div><p>The content of the shape can be a solid color or a gradient. For this, we use the tags <code class="literal">&lt;solid&gt;</code> or <code class="literal">&lt;gradient&gt;</code>.</p><p>The tag <code class="literal">&lt;solid&gt;</code> has<a class="indexterm" id="id000375"/> the argument <code class="literal">color</code>, which can be provided as a hexadecimal value or a color resource. This color resource can also be a state list.</p><p>The tag <code class="literal">&lt;gradient&gt;</code> can<a class="indexterm" id="id000376"/> be used instead of <code class="literal">&lt;solid&gt;</code> and its arguments are self-explanatory. We are not going to use them in our game.</p><p>We can define the padding of the containing view elements using the <a class="indexterm" id="id000377"/>
<code class="literal">&lt;padding&gt;</code> tag. It has four different attributes—<code class="literal">left</code>, <code class="literal">top</code>, <code class="literal">right</code>, and <code class="literal">bottom</code>—that can be provided as a dimension value or dimension resource.</p><p>The size of the shape<a class="indexterm" id="id000378"/> is optional and can be defined using the tag <code class="literal">&lt;size&gt;</code>, which has <code class="literal">height</code> and <code class="literal">width</code> as attributes that can be a dimension value or resource.</p><div><div><h3 class="title"><a id="note00066"/>Note</h3><p>The shape scales to the size of the container <code class="literal">View</code> proportionate to the dimensions defined here, by default. When you use the shape in an <code class="literal">ImageView</code>, you can restrict scaling by setting <code class="literal">android:scaleType</code> to <code class="literal">"center"</code>.</p></div></div><p>The border <a class="indexterm" id="id000379"/>or outline of the shape is defined with the tag <code class="literal">&lt;stroke&gt;</code>. It<a class="indexterm" id="id000380"/> accepts the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Width</strong>: the<a class="indexterm" id="id000381"/> thickness of the line, as a dimension value or dimension resource.</li><li class="listitem" style="list-style-type: disc"><strong>Color</strong>: the<a class="indexterm" id="id000382"/> color of the line, as a hexadecimal value or color resource.</li><li class="listitem" style="list-style-type: disc"><strong>DashGap/DashWith</strong>: the <a class="indexterm" id="id000383"/>distance between line dashes and the size of each dash, both as dimension values and dimension resources. They need to be set together.</li></ul></div><p>When using a rectangular shape, we can specify the corners to be rounded by using the <code class="literal">&lt;corners&gt;</code> tag; for <a class="indexterm" id="id000384"/>that we can use just <code class="literal">radius</code> or we can specify a dimension for each of the corners: <code class="literal">topLeftRadius</code>, <code class="literal">topRightRadius</code>, <code class="literal">bottomLeftRadius</code>, and <code class="literal">bottomRightRadius</code>.</p><div><div><h3 class="title"><a id="note00067"/>Note</h3><p>The system requires every corner radius to be initialized with a value greater than 1 in the XML file. Otherwise no corners are rounded. To work around this you can override the corner radius value programmatically.</p></div></div><p>Now that we have seen the syntax in detail, let's create the shapes we are going to use in our game.</p><p>We are going to create an oval shape for the round buttons, and use a color that is also a color state list to replace the current drawable state list that has multiple shapes because it makes the code much more compact and easy to update.</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape 
  android:shape="oval"&gt;
  &lt;solid
    android:color="@color/btn_backgound" /&gt;
  &lt;padding android:bottom="@dimen/round_button_padding"
    android:left="@dimen/round_button_padding"
    android:right="@dimen/round_button_padding"
    android:top="@dimen/round_button_padding"/&gt;
&lt;/shape&gt;</pre></div><p>We define<a class="indexterm" id="id000385"/> the shape as oval, then set it to have a solid color that is the state list color resource we defined in the previous section. Finally we define some paddings that come from dimensions resources.</p><p>Next, we <a class="indexterm" id="id000386"/>are going to define a shape for the square buttons (at the moment it is only used for the button to start the game):</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape 
  android:shape="rectangle"&gt;
  &lt;solid
    android:color="@color/btn_backgound" /&gt;
  &lt;padding android:bottom="@dimen/square_button_padding"
    android:left="@dimen/square_button_padding"
    android:right="@dimen/square_button_padding"
    android:top="@dimen/square_button_padding"/&gt;
  &lt;stroke android:color="@color/btn_border"
    android:width="@dimen/square_button_border" /&gt;
&lt;/shape&gt;</pre></div><p>This shape is a rectangle with a border. The border is defined by the <code class="literal">stroke</code> tag.</p><p>All the dimensions we have used for this shape must be defined. We put them into a <code class="literal">dimens.xml</code> file under <code class="literal">res/values</code>.</p><div><pre class="programlisting">&lt;dimen name="square_button_padding"&gt;18dp&lt;/dimen&gt;
&lt;dimen name="square_button_border"&gt;6dp&lt;/dimen&gt;
&lt;dimen name="round_button_padding"&gt;6dp&lt;/dimen&gt;
&lt;dimen name="btn_sound_size"&gt;60dp&lt;/dimen&gt;</pre></div><p>We also added a couple more colors for the button border and the text color in <code class="literal">colors.xml</code>.</p><div><pre class="programlisting">&lt;color name="text_color"&gt;#FFFFFF&lt;/color&gt;
&lt;color name="btn_border"&gt;#AAAAAA&lt;/color&gt;</pre></div><p>Finally we are going to make use of styles to keep the code on the layouts cleaner. Styles on Android allow you to define several XML attributes and associate them with a name. Then you can reference the style by name on any layout and it will be applied.</p><p>The intention of styles is to define the look and feel in a single place so it can be changed and/or updated easily. The concept is similar to CSS for web pages.</p><div><div><h3 class="title"><a id="note00068"/>Note</h3><p>Styles are very handy for keeping layouts clean and having the definition of the look and feel in a single place.</p></div></div><p>We are going to define a style<a class="indexterm" id="id000387"/> for the round buttons. This goes into the <code class="literal">styles.xml</code> file under <code class="literal">res/values</code> (and again, any name for the file will work, but it is better to follow the conventions).</p><div><pre class="programlisting">&lt;resources&gt;
  &lt;style name="iconButton" &gt;
    &lt;item name="android:background"&gt;@drawable/icon_button_bg&lt;/item&gt;
    &lt;item name="android:layout_width"&gt;@dimen/btn_round_size&lt;/item&gt;
    &lt;item name="android:layout_height"&gt;@dimen/btn_round_size&lt;/item&gt;
  &lt;/style&gt;
&lt;/resources&gt;</pre></div><p>To <a class="indexterm" id="id000388"/>complete this section, let's look at the updated version of <code class="literal">fragment_main_menu.xml</code> with all these changes included:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  &gt;

  &lt;ImageView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scaleType="centerCrop"
    android:src="img/seamless_space_0"/&gt;

  &lt;TextView
    android:textColor="@color/text_color"
    android:id="@+id/main_title"
    style="@android:style/TextAppearance.DeviceDefault.Large"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:text="@string/game_title"
    android:layout_centerHorizontal="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" /&gt;

  &lt;TextView
    android:textColor="@color/text_color"
    android:layout_below="@+id/main_title"
    style="@android:style/TextAppearance.DeviceDefault.Medium"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:text="@string/game_subtitle"
    android:layout_centerHorizontal="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" /&gt;

  &lt;Button
    android:id="@+id/btn_start"
    android:layout_centerInParent="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/button_square_bg"
    android:text="@string/start" /&gt;

  &lt;ImageView
    android:background="@drawable/button_round_bg"
    android:id="@+id/btn_sound"
    android:layout_margin="@dimen/activity_vertical_margin"
    android:layout_width="@dimen/btn_sound_size"
    android:layout_height="@dimen/btn_sound_size"
    android:src="img/sounds_on_no_bg"
    android:layout_alignParentBottom="true"
    android:layout_alignParentRight="true"/&gt;

  &lt;ImageView
    android:background="@drawable/button_round_bg"
    android:id="@+id/btn_music"
    android:layout_width="@dimen/btn_sound_size"
    android:layout_height="@dimen/btn_sound_size"
    android:layout_alignBottom="@+id/btn_sound"
    android:src="img/music_on_no_bg"
    android:layout_toLeftOf="@+id/btn_sound"/&gt;
&lt;/RelativeLayout&gt;</pre></div><div><img alt="Shape drawables" src="img/B04757_07_03.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec00049"/>The GameFragment</h1></div></div></div><p>Now that <a class="indexterm" id="id000389"/>we have tweaked the main menu, it is time to work on the <code class="literal">GameFragment</code>.</p><p>There are two essential game features we have not even built yet: score and lives. We are going remedy that now. First we need to make space for them in the layout, then we have to write some code to actually take care of both features.</p><p>For the UI of the score and lives we are going to use standard Android components. We have built a lot of features into our <code class="literal">GameEngine</code>, but we do not want to reinvent the wheel. Since Android provides a good way to define layouts and make UIs we are familiar with, it would be a waste to not make use of it.</p><div><div><h3 class="title"><a id="note00069"/>Note</h3><p>Using the standard Android Views can save you a lot of time.</p></div></div><p>We are going to make the game area smaller by adding a column to each side. We will place the new UI elements there and we will link them to <code class="literal">GameObjects</code> to update them as the game progresses.</p><p>While we could overlay the controls on top of the <code class="literal">GameView</code> instead of having letterboxes, note that we are using a <code class="literal">SurfaceView</code>, and its performance plummets dramatically when other views are overlaid on top of it. We also think it looks nicer to have the gameplay area separated from the controls. If you want to use an overlay, you should change the <code class="literal">GameView</code> to be a <code class="literal">StandardGameView</code>.</p><p>Now that <a class="indexterm" id="id000390"/>we are working with <code class="literal">fragment_game.xml</code>, it is a good moment to also update the Pause button with the same style we created for sound and music.</p><p>The new version of <a class="indexterm" id="id000391"/>
<code class="literal">fragment_game.xml</code> is like this:</p><div><pre class="programlisting">&lt;FrameLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:background="@color/background"
  tools:context="com.plattysoft.yass.counter.GameFragment"&gt;

  &lt;RelativeLayout
    android:layout_width="@dimen/game_menu_width"
    android:layout_height="match_parent"&gt;
    &lt;!-- Lives and score go here --&gt;
  &lt;/RelativeLayout&gt;

  &lt;FrameLayout
    android:background="@color/game_view_frame"
    android:layout_weight="1"
    android:padding="4dp"
    android:layout_marginLeft="@dimen/game_menu_width"
    android:layout_marginRight="@dimen/game_menu_width"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;com.plattysoft.yass.engine.SurfaceGameView
      android:id="@+id/gameView"
      android:layout_weight="1"
      android:layout_width="match_parent"
      android:layout_height="match_parent" /&gt;
  &lt;/FrameLayout&gt;

  &lt;include layout="@layout/view_vjoystick" /&gt;

  &lt;ImageView
    style="@style/iconButton"
    android:layout_gravity="top|right"
    android:id="@+id/btn_play_pause"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:layout_marginRight="@dimen/activity_vertical_margin"
    android:src="img/pause" /&gt;
&lt;/FrameLayout&gt;</pre></div><p>The <code class="literal">GameView</code> in now inside a <code class="literal">FrameLayout</code> that is centered and has margins to each side with values for the columns (<code class="literal">R.dimen.game_menu_width</code>). The <code class="literal">FrameLayout</code> is used to display a red frame around the <code class="literal">GameView</code> to clearly separate the play area from the rest of the UI.</p><p>The frame <a class="indexterm" id="id000392"/>background is a rectangular shape drawable similar to the ones we have already defined:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape 
  android:shape="rectangle"&gt;
  &lt;solid
    android:color="@android:color/transparent" /&gt;
  &lt;padding android:bottom="@dimen/game_frame_width"
    android:left="@dimen/game_frame_width"
    android:right="@dimen/game_frame_width"
    android:top="@dimen/game_frame_width"/&gt;
  &lt;stroke android:color="@color/game_view_frame"
    android:width="@dimen/game_frame_width" /&gt;
&lt;/shape&gt;</pre></div><p>On the left we have a <code class="literal">RelativeLayout</code>, which we will use to place the controls for the score and lives. In front of this we have the virtual joystick we were already using, and that covers the entire screen. Finally, we have the pause button, which has to remain in the foreground, otherwise the virtual joystick will capture the touch event. As we have already mentioned, the pause button is now using the same look and feel as the music and sound buttons on the main menu.</p><div><img alt="The GameFragment" src="img/B04757_07_04.jpg"/></div><p>Now that we <a class="indexterm" id="id000393"/>have the space, let's start adding items there! We are going to just display scores and lives, but you could use the space for anything relevant to the game, from top scores to In-App Purchases buttons.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00080"/>Adding a score</h2></div></div></div><p>Let's implement <a class="indexterm" id="id000394"/>the score counter. For that we need to define a way to give points to the player as well.</p><p>We are going to use a <code class="literal">TextView</code> to display the score on the screen. To control this <code class="literal">TextView</code>, we will create a <code class="literal">ScoreGameObject</code> that is in many ways similar to the one we used in <a class="link" href="ch21.html" title="Chapter 1. Setting Up the Project">Chapter 1</a>, <em>Setting Up the Project</em> to show the coordinates of the <code class="literal">Player</code>.</p><p>The score will be calculated inside the <code class="literal">ScoreGameObject</code> class and it will be updated based on game events. This also implies that the <code class="literal">GameEngine</code> must propagate the events to the game objects (until now it has only propagated them to the <code class="literal">SoundEngine</code>).</p><p>We will give 50 points each time the player hits an asteroid, and remove one point each time an asteroid escapes. An <code class="literal">Asteroid</code> escaping is a new <code class="literal">GameEvent</code> we will have to create and trigger. Both score modification values will be set as constants as good practice for readability and ease of change.</p><p>First things first: let's make <code class="literal">GameEngine</code> propagate <code class="literal">GameEvents</code> to all the <code class="literal">GameObjects</code> that are currently active. For this, we modify the method <code class="literal">onGameEvent</code> of <code class="literal">GameEngine</code>.</p><div><pre class="programlisting">public void onGameEvent (GameEvent gameEvent) {
  // We notify all the GameObjects
  int numObjects = mGameObjects.size();
  for (int i=0; i&lt;numObjects; i++) {
    mGameObjects.get(i).onGameEvent(gameEvent);
  }
  // Also the sound manager
  mSoundManager.playSoundForGameEvent(gameEvent);
}</pre></div><p>Note that <a class="indexterm" id="id000395"/>this implies creating a method named <code class="literal">onGameEvent</code> in <code class="literal">GameObject</code>, which will be empty by default.</p><p>We are going to use a new <code class="literal">GameEvent</code> that is triggered when the asteroid goes out of the screen (<code class="literal">AsteroidMissed</code>). We have to add that value to the <code class="literal">GameEvents</code> enum and also trigger the event from the <code class="literal">onUpdate</code> method of the <code class="literal">Asteroid</code>.</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  [...]
  if (mY &gt; gameEngine.mHeight) {
    gameEngine.onGameEvent(GameEvent.AsteroidMissed);
    removeFromGameEngine(gameEngine);
  }
}</pre></div><p>Now let's add the <code class="literal">TextView</code> to the left column of our <code class="literal">fragment_game.xml</code>. We will have two new text views: one with the text "<code class="literal">Score:"</code> (<code class="literal">R.id.score_title</code>) and another one with the score itself (<code class="literal">R.id.score_value</code>).</p><div><pre class="programlisting">&lt;RelativeLayout
  android:layout_width="@dimen/game_menu_width"
  android:layout_height="match_parent"&gt;
  &lt;TextView
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:layout_marginLeft="@dimen/menu_margin"
    android:id="@+id/score_title"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentTop="true"
    android:textColor="@color/text_color"
    android:text="@string/score"/&gt;
  &lt;TextView
    android:id="@+id/score_value"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="@dimen/menu_margin"
    android:layout_below="@+id/score_title"
    android:layout_alignLeft="@+id/score_title"
    android:textColor="@color/text_color"
    android:text="000000"/&gt;
&lt;/RelativeLayout&gt;</pre></div><p>We have<a class="indexterm" id="id000396"/> everything in place, it is time to link them together with the <code class="literal">ScoreGameObject</code> class. It is a fairly simple one:</p><div><pre class="programlisting">public class ScoreGameObject extends GameObject {

  private final TextView mText;
  private int mPoints;
  private boolean mPointsHaveChanged;

  private static final int POINTS_LOSS_PER_ASTEROID_MISSED = 1;
  private static final int POINTS_GAINED_PER_ASTEROID_HIT = 50;

  public ScoreGameObject(View view, int viewResId) {
    mText = (TextView) view.findViewById(viewResId);
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {}

  @Override
  public void startGame() {
    mPoints = 0;
    mText.post(mUpdateTextRunnable);
  }

  @Override
  public void onGameEvent(GameEvent gameEvent) {
    if (gameEvent == GameEvent.AsteroidHit) {
      mPoints += POINTS_GAINED_PER_ASTEROID_HIT;
      mPointsHaveChanged = true;
    }
    else if (gameEvent == GameEvent.AsteroidMissed) {
      if (mPoints &gt; 0) {
        mPoints -= POINTS_LOSS_PER_ASTEROID_MISSED;
      }
      mPointsHaveChanged = true;
    }
  }

  private Runnable mUpdateTextRunnable = new Runnable() {
    @Override
    public void run() {
      String text = String.format("%06d", mPoints);
      mText.setText(text);
    }
  };

  @Override
  public void onDraw(Canvas canvas) {
    if (mPointsHaveChanged) {
      mText.post(mUpdateTextRunnable);
      mPointsHaveChanged = false;
    }
  }
}</pre></div><p>This class <a class="indexterm" id="id000397"/>sets the points to 0 when the game is started, and then reacts to <code class="literal">GameEvents</code> by modifying the total points of the player. Once the value of the score has been modified, we signal it with a boolean variable so we know it needs to be updated during the next call to <code class="literal">onDraw</code>. This is done to prevent unnecessary redraws on the <code class="literal">TextView</code>.</p><p>Remember that <code class="literal">onDraw</code> is invoked on the <code class="literal">UIThread</code> when we are using a <code class="literal">StandardGameView</code>, but it is called from the <code class="literal">UpdateThread</code> in the case of a <code class="literal">SurfaceGameView</code>. Since the views can only be updated on the <code class="literal">UIThread</code>, we use a <code class="literal">Runnable</code> that gets posted to the <code class="literal">UIThread</code>, which then updates the value of the <code class="literal">TextView</code> to make it work for both <code class="literal">StandardGameView</code> and <code class="literal">SurfaceGameView</code>.</p><div><div><h3 class="title"><a id="note00070"/>Note</h3><p>View modifications must always be done on the <code class="literal">UIThread</code>.</p></div></div><p>We use <code class="literal">String.format</code> to get a number consisting of 6 digits, filling in with 0s to the left if the integer does not have enough digits. This just makes the score look a lot nicer.</p><p>The only remaining link is to add this <code class="literal">GameObject</code> to the <code class="literal">GameEngine</code> initialization in the <code class="literal">GameFragment</code>.</p><div><pre class="programlisting">new ScoreGameObject(getView(),R.id.score_value).addToGameEngine(mGameEngine, 0);</pre></div><p>We can now play the game and finally score some points.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00081"/>Adding lives</h2></div></div></div><p>We are also <a class="indexterm" id="id000398"/>going to have a lives indicator in the left column. For this we have to update the game quite a lot since we only have one life currently and the game does not do anything when we die.</p><p>As we did for the score, we will have a <code class="literal">LivesCounter</code> object that takes care of the display, but in this case the lives count will rely on the <code class="literal">GameController</code>. The synchronization between the <code class="literal">GameController</code> and the <code class="literal">LivesCounter</code> will be done via <code class="literal">GameEvents</code>.</p><p>Another<a class="indexterm" id="id000399"/> thing to consider is that once the player dies, the wave must stop. Only once the screen is empty can we spawn a new <code class="literal">Player</code> object and then restart the wave after a few seconds.</p><p>To manage this, we will have <code class="literal">GameController</code> be a state machine and transition from one state to the other based on <code class="literal">GameEvents</code>. This is a common technique for the controllers of games in general.</p><div><div><h3 class="title"><a id="note00071"/>Note</h3><p>Having the <code class="literal">GameController</code> be a state machine is a common technique for games.</p></div></div><p>We are going to start with the modifications in <code class="literal">GameController</code> first and then <code class="literal">LivesCounter</code>.</p><p>For the state of the <code class="literal">GameController</code> we will create an enum that we will call <code class="literal">GameControllerState</code>.</p><div><pre class="programlisting">public enum GameControllerState {
  StoppingWave,
  SpawningEnemies,
  PlacingSpaceship,
  Waiting,
  GameOver;
}</pre></div><p>Let's describe each one of the states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StoppingWave</code>: this <a class="indexterm" id="id000400"/>state is time based. While the <code class="literal">GameController</code> is in it, no asteroids are spawned. Combined with the timeout it effectively stops the current wave. From this state the controller will transition either to <code class="literal">GameOver</code> if there are no lives left, or to <code class="literal">PlacingSpaceship</code> if there are.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SpawningEnemies</code>: the<a class="indexterm" id="id000401"/> normal state. This is the equivalent of the behavior of the previous version without states. It transitions to <code class="literal">StoppingWave</code> when the spaceship is destroyed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PlacingSpaceship</code>: the<a class="indexterm" id="id000402"/> controller puts a <code class="literal">Player</code> object into play and sends a <code class="literal">GameEvent</code> about it. This transitions automatically to <code class="literal">Waiting</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Waiting</code>: similar<a class="indexterm" id="id000403"/> to <code class="literal">StoppingWave</code>, this state is also time based but it always transitions to <code class="literal">SpawningEnemies</code>. This state exists to allow the player some time to relax after the new spaceship is placed on the screen.</li></ul></div><div><img alt="Adding lives" src="img/B04757_07_05.jpg"/></div><p>The <code class="literal">GameController</code> starts in the <code class="literal">PlacingSpaceship</code> state, which gets one life and places a spaceship on the screen. The <code class="literal">GameController</code> will move into <code class="literal">Waiting</code> and then into <code class="literal">SpawningEnemies</code>.</p><p>When a<a class="indexterm" id="id000404"/> <code class="literal">SpaceshipHit</code> event arrives we move into <code class="literal">StoppingWave</code>. Once there are no more <code class="literal">Asteroids</code> on the screen, we check the number of lives remaining. If it is 0, that's <code class="literal">GameOver</code>, otherwise, we go to <code class="literal">PlacingSpaceship</code> (which triggers a <code class="literal">LifeLost</code> game event) and then moves to <code class="literal">Waiting</code> again until we can move to <code class="literal">SpawningEnemies</code>.</p><p>Let's see the code to start a game:</p><div><pre class="programlisting">@Override
public void startGame(GameEngine gameEngine) {
  mCurrentMillis = 0;
  mEnemiesSpawned = 0;
  mWaitingTime = 0;
  for (int i=0; i&lt;INITIAL_LIFES; i++) {
    gameEngine.onGameEvent(GameEvent.LifeAdded);
  }
  mState = GameControllerState.PlacingSpaceship;
}</pre></div><p>First we reset all the counters and we run a loop over the amount of lives we have initially, sending the game event <code class="literal">LifeAdded</code>. This event is processed in this class as well as in the <code class="literal">LivesCounter</code>.</p><p>The main advantages to adding lives this way is that we can process lives that are given by other means than starting the game, that is, any extra lives. We also have the value of initial lives in a single place.</p><p>Finally we move to the state of <code class="literal">PlacingSpaceship</code> as we described before.</p><p>As an <a class="indexterm" id="id000405"/>important note: since we are starting on <code class="literal">PlacingSpaceship</code>, we now don't need to add the player object to the <code class="literal">GameEngine</code> anymore because we do it from this class. We must remove that code from the initialization of the engine.</p><div><div><h3 class="title"><a id="note00072"/>Note</h3><p>The <code class="literal">GameController</code> now takes care of adding the <code class="literal">Player</code> to the game. We don't have to add it by hand on the <code class="literal">GameEngine</code> creation anymore.</p></div></div><p>We could start the <code class="literal">GameController</code> in the <code class="literal">StoppingWave</code> state as well. That would give us some time before the life is removed and then added. Play with this, and decide which one you like better.</p><p>Next let's look at the <code class="literal">onGameEvent</code> method of <code class="literal">GameController</code>:</p><div><pre class="programlisting">@Override
public void onGameEvent(GameEvent gameEvent) {
  if (gameEvent == GameEvent.SpaceshipHit) {
    mState = GameControllerState.StoppingWave;
    mWaitingTime = 0;
  }
  else if (gameEvent == GameEvent.GameOver) {
    mState = GameControllerState.GameOver;
  }
  else if (gameEvent == GameEvent.LifeAdded) {
    mNumLives++;
  }
}</pre></div><p>This does react to a <code class="literal">SpaceshipHit</code> event by moving into the <code class="literal">StoppingWave</code> state, and it also resets the waiting time. That state will check if there are remaining lives to be used or not and trigger the <code class="literal">GameOver</code> event if needed. We will see that when we look into <code class="literal">onUpdate</code>.</p><p>The method reacts to the <code class="literal">GameOver</code> event by putting itself in <code class="literal">GameOver</code> state. This event is only sent by the <code class="literal">GameController</code> at the moment, but it is nice to have it like this for future usage. Maybe we will want to have a very powerful enemy that can end the game in one go.</p><p>Finally, when <code class="literal">LifeAdded</code> arrives it increases the lives counter. Again, this event is only sent on construction of this class, but we could implement an extra life mechanic and then trigger it from somewhere else.</p><p>The real juice<a class="indexterm" id="id000406"/> is inside the <code class="literal">onUpdate</code> method.</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  if (mState == GameControllerState.SpawningEnemies) {
    mCurrentMillis += elapsedMillis;
    long waveTimestamp = mEnemiesSpawned * TIME_BETWEEN_ENEMIES;
    if (mCurrentMillis &gt; waveTimestamp) {
      // Spawn a new enemy
      Asteroid a = mAsteroidPool.remove(0);
      a.init(gameEngine);
      a.addToGameEngine(gameEngine, mLayer);
      mEnemiesSpawned++;
      return;
    }
  }
  else if (mState == GameControllerState.StoppingWave) {
    mWaitingTime += elapsedMillis;
    if (mWaitingTime &gt; STOPPING_WAVE_WAITING_TIME) {
      mState = GameControllerState.PlacingSpaceship;
    }
  }
  else if (mState == GameControllerState.PlacingSpaceship) {
    if (mNumLifes == 0) {
      gameEngine.onGameEvent(GameEvent.GameOver);
    }
    else {
      mNumLives--;
      gameEngine.onGameEvent(GameEvent.LifeLost);
      Player newLife = new Player(gameEngine);
      newLife.addToGameEngine(gameEngine, 2);
      newLife.startGame(gameEngine);
      // We wait to start spawning more enemies
      mState = GameControllerState.Waiting;
      mWaitingTime = 0;
    }
  }
  else if (mState == GameControllerState.Waiting) {
    mWaitingTime += elapsedMillis;
    if (mWaitingTime &gt; WAITING_TIME) {
      mState = GameControllerState.SpawningEnemies;
    }
  }
}</pre></div><p>You can see that the code we had before is now the code for the <code class="literal">SpawningEnemies</code> state. There is nothing new about spawning asteroids.</p><p>To stop a wave <a class="indexterm" id="id000407"/>we just have to wait some milliseconds. Since there are no new <code class="literal">Asteroids</code> being spawned, this timeout just needs to be longer than the time it takes an <code class="literal">Asteroid</code> to cross the screen. We could count the asteroids when they are returned to the pool instead, but this method always waits the same amount of time and feels better to the player.</p><p>The <code class="literal">PlacingSpaceship</code> state only lasts for one iteration. It will either send a <code class="literal">GameOver</code> event (which will move it to the <code class="literal">GameOver</code> state) or use a life, which includes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sending the <code class="literal">LifeLost</code> event</li><li class="listitem" style="list-style-type: disc">Creating a <code class="literal">Player</code> object, initializing it and adding it to the <code class="literal">GameEngine</code></li><li class="listitem" style="list-style-type: disc">Moving to the <code class="literal">Waiting</code> state and resetting the waiting time</li></ul></div><p>At this time we are not doing anything when the <code class="literal">GameOver</code> event happens, but we will take care of this in the second part of the chapter, by showing a game over dialog.</p><p>Finally, while in the <code class="literal">Waiting</code> state we count the milliseconds, just as we do on the <code class="literal">StoppingWave</code>, and then we move to the <code class="literal">SpawningEnemies</code> state.</p><p>This is all we need to make the <code class="literal">GameController</code> handle the state machine properly. It is time to move on to the <code class="literal">LivesCounter</code>.</p><p>To show the lives on the screen we need to add some views to the layout and also implement the class that handles them. We want each life to be displayed as an icon of the spaceship on the left, under the score counter.</p><p>We need to add the following code to the left column of the <code class="literal">fragment_game.xml</code> layout:</p><div><pre class="programlisting">&lt;RelativeLayout&gt;
  [...]
  &lt;TextView
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:id="@+id/lives_title"
    android:layout_below="@+id/score_value"
    android:layout_alignLeft="@+id/score_value"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textColor="@color/text_color"
    android:text="@string/lives" /&gt;
  &lt;LinearLayout
    android:orientation="horizontal"
    android:id="@+id/lives_value"
    android:layout_marginTop="@dimen/menu_margin"
    android:layout_below="@+id/lives_title"
    android:layout_alignLeft="@+id/lives_title"
    android:layout_width="@dimen/game_menu_width"
    android:layout_height="wrap_content" /&gt;
&lt;/RelativeLayout&gt;</pre></div><p>We have a <code class="literal">TextView</code> that <a class="indexterm" id="id000408"/>displays the text "<code class="literal">Lives</code>"<code class="literal">:</code> and a horizontal <code class="literal">LinearLayout</code> in which we will add and remove <code class="literal">ImageViews</code> when we receive the respective <code class="literal">GameEvents</code>.</p><p>The code for <code class="literal">LivesCounter</code> is as easy as this:</p><div><pre class="programlisting">public class LivesCounter extends GameObject {

  private final LinearLayout mLayout;

  public LivesCounter(View view, int viewResId) {
    mLayout = (LinearLayout) view.findViewById(viewResId);
  }

  @Override
  public void startGame(GameEngine gameEngine) {}

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {}

  @Override
  public void onDraw(Canvas canvas) {}

  @Override
  public void onGameEvent(GameEvent gameEvent) {
    if (gameEvent == GameEvent.LifeLost) {
      mLayout.post(mRemoveLifeRunnable);
    }
    else if (gameEvent == GameEvent.LifeAdded) {
      mLayout.post(mAddLifeRunnable);
    }
  }

  private Runnable mRemoveLifeRunnable = new Runnable() {
    @Override
    public void run() {
      // Remove one life from the layout
      mLayout.removeViewAt(mLayout.getChildCount()-1);
    }
  };

  private Runnable mAddLifeRunnable = new Runnable() {
    @Override
    public void run() {
      // Remove one life from the layout
      View spaceship = View.inflate(mLayout.getContext(), R.layout.view_spaceship, mLayout);
    }
  };
}</pre></div><p>As you can see, this <a class="indexterm" id="id000409"/>class does not take into account the amount of lives that the player has. It only reacts to the events <code class="literal">LifeAdded</code> and <code class="literal">LifeLost</code> by adding or removing an item to the <code class="literal">LinearLayout</code>.</p><p>We add and remove views by posting a runnable object for the same reason as for the <code class="literal">ScoreGameObject</code>: modifying views must be done in the <code class="literal">UIThread</code>, and <code class="literal">onDraw</code> does run in the <code class="literal">UpdateThread</code> when we use <code class="literal">SurfaceGameView</code>.</p><p>The last piece is the layout <code class="literal">view_spaceship.xml</code> we are inflating, which is just an <code class="literal">ImageView</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ImageView 
  android:src="img/ship"
  android:scaleType="fitCenter"
  android:layout_width="@dimen/life_size"
  android:layout_height="@dimen/life_size" /&gt;</pre></div><p>The dimension <code class="literal">life_size</code> is set to 30dp in the file <code class="literal">dimens.xml</code> file, so there is enough horizontal space for three spaceships.</p><div><img alt="Adding lives" src="img/B04757_07_06.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec00050"/>Custom dialogs</h1></div></div></div><p>The next step in making <a class="indexterm" id="id000410"/>our UI nicer is to stop using the standard Android dialogs and create our own custom ones instead. Once again this is something completely discouraged for apps but it makes a lot of sense for games.</p><p>There are many<a class="indexterm" id="id000411"/> reasons why a custom dialog system is better for games:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The default dialogs will look different in different Android versions. This is in fact great when you use <code class="literal">AlertDialog</code> in an app, since it mimics the dialogs of all the rest of the apps, but not the games. We want consistency.</li><li class="listitem" style="list-style-type: disc">Default dialogs use the system font.</li><li class="listitem" style="list-style-type: disc">If you try to set a custom background or a custom content view, <code class="literal">AlertDialogs</code> look terrible. Again, you should never do that in an app, but you definitely want it in a game.</li><li class="listitem" style="list-style-type: disc">The standard dialogs ruin the immersive experience by showing the notifications and system bars when they are on screen.</li><li class="listitem" style="list-style-type: disc">It is hard to replace the animations of <code class="literal">AlertDialog</code> with custom ones.</li></ul></div><p>We are going to build a system that shows our dialogs on screen, with a gray semi‑transparent overlay behind them. These dialogs will have a custom background made out of a shape drawable and will use the custom font we have selected for the game.</p><p>Finally, the dialog itself is just a layout we put in front of the content.</p><p>It is worth <a class="indexterm" id="id000412"/>noting that we need to define a policy for what to do when we are showing a dialog and a new one is trying to display on top. In our game, the old dialog will stay and the new one will not be displayed, but nevertheless we will provide a method to dismiss the previous one and show the new one in case you want that behavior in your game.</p><p>We are going to describe the architecture first (including modifications to <code class="literal">YassBaseFragment</code>), and then we will start by making the dialog for quitting the game because it is the simplest one. After that we will replace the current pause dialog and finally we will make a new dialog for game over.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00082"/>BaseCustomDialog</h2></div></div></div><p>The custom dialog<a class="indexterm" id="id000413"/> framework we are going to create is <a class="indexterm" id="id000414"/>composed of three items:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BaseCustomDialog</code>: the base class of all the dialogs</li><li class="listitem" style="list-style-type: disc"><code class="literal">my_overlay_dialog</code>: a layout that is the parent of all the dialogs</li><li class="listitem" style="list-style-type: disc">Utility functions in the base fragment class</li></ul></div><p>Most of the work is done in the <code class="literal">BaseCustomDialog</code> class, which provides methods to <code class="literal">setContentView</code>, <code class="literal">show</code>, and <code class="literal">dismiss</code>.</p><p>The complete code of <code class="literal">BaseCustomDialog</code> class is as follows:</p><div><pre class="programlisting">public class BaseCustomDialog implements OnTouchListener {

  private boolean mIsShowing;

  protected final YassActivity mParent;
  private ViewGroup mRootLayout;
  private View mRootView;

  public BaseCustomDialog(YassActivity activity) {
    mParent = activity;
  }

  protected void onViewClicked() {
    // Ignore clicks on this view
  }

  protected void setContentView(int dialogResId) {
    ViewGroup activityRoot = (ViewGroup) mParent.findViewById(android.R.id.content);
    mRootView = LayoutInflater.from(mParent).inflate(dialogResId, activityRoot, false);
    mParent.applyTypeface(mRootView);
  }

  public void show() {
    if (mIsShowing) {
      return;
    }
    mIsShowing = true;

    ViewGroup activityRoot = (ViewGroup) mParent.findViewById(android.R.id.content);
    mRootLayout = (ViewGroup) LayoutInflater.from(mParent).inflate(R.layout.my_overlay_dialog, activityRoot, false);
    activityRoot.addView(mRootLayout);
    mRootLayout.setOnTouchListener(this);
    mRootLayout.addView(mRootView);
  }

  public void dismiss() {
    if (!mIsShowing) {
      return;
    }
    mIsShowing = false;
    hideViews();
  }

  private void hideViews() {
    mRootLayout.removeView(mRootView);
    ViewGroup activityRoot = (ViewGroup) mParent.findViewById(android.R.id.content);
    activityRoot.removeView(mRootLayout);
  }

  protected View findViewById(int id) {
    return mRootView.findViewById(id);
  }

  @Override
  public boolean onTouch(View v, MotionEvent event) {
    // Ignoring touch events on the gray outside
    return true;
  }

  public boolean isShowing() {
    return mIsShowing;
  }
}</pre></div><p>During <a class="indexterm" id="id000415"/>construction we store the reference to the main<a class="indexterm" id="id000416"/> activity into the <a class="indexterm" id="id000417"/>member variable <code class="literal">mParent</code>, to be used later.</p><p>There are a few other<a class="indexterm" id="id000418"/> member variables in the class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mRootLayout</code>: this<a class="indexterm" id="id000419"/> is the layout we inflate that is common to all dialogs and which is used as a background.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mRootView</code>: the<a class="indexterm" id="id000420"/> root of the content view. This is used to show and hide the dialog itself.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mIsShowing</code>: a <a class="indexterm" id="id000421"/>variable to determine whether the dialog is showing or not.</li></ul></div><p>During <code class="literal">setContentView</code>, we inflate the view for the dialog and store the reference in <code class="literal">mRootView</code>, but we do not add it to any <code class="literal">ViewGroup</code> yet. For inflation, we use the parameters of the content view of the app (<code class="literal">android.R.id.content</code>). The last parameter of the inflate method is used to determine if the system should add the view as a child of the parent or not. We pass <code class="literal">false</code>, so the view does not get added to the hierarchy. Finally we apply the custom typeface to it.</p><p>Note that <code class="literal">setContentView</code> is usually called during construction and not during show; that is the reason why the views are not added to the hierarchy at this point.</p><p>To show the dialog, we first check if it is already being shown and, if that is the case, we return and do nothing. Otherwise we set <code class="literal">mIsShowing</code> to <code class="literal">true</code> and proceed.</p><p>To properly show the dialog, we inflate the root layout and add it to the main content, then we add the root view to it. This makes the dialog the foremost item in the foreground of the view hierarchy.</p><p>We also add the class as a touch listener that does nothing to <code class="literal">mRootLayout</code>. This has the purpose of filtering out all the touch and click events in items that are behind the dialog. If we want a dialog to be dismissed when the user clicks outside its bounds, we just need to add a call to <code class="literal">dismiss</code> inside this listener.</p><p>Finally, <code class="literal">dismiss</code> first checks that the dialog is showing, and if so it removes the views from the hierarchy.</p><p>We also have <a class="indexterm" id="id000422"/>utility methods such as <code class="literal">findViewById</code> and <code class="literal">isShowing</code>.</p><p>The layout for <code class="literal">mRootLayout</code> is just a gray semi-transparent overlay and its code is like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout 
  android:background="#aa000000"
  android:layout_width="match_parent"
  android:layout_height="match_parent"/&gt;</pre></div><p>Note that this <a class="indexterm" id="id000423"/>is already designed to make it easy to add animations to the process of showing and dismissing the dialog (discussed in the next chapter). This is particularly true when it comes to having a completely gray background independent of the content view.</p><p>The last stage in our dialog framework is to provide some utility methods in the base fragment to facilitate using our custom dialogs.</p><div><pre class="programlisting">BaseCustomDialog mCurrentDialog;

public void showDialog (BaseCustomDialog newDialog) {
  showDialog(newDialog, false);
}

public void showDialog (BaseCustomDialog newDialog, boolean dismissOtherDialog) {
  if (mCurrentDialog != null &amp;&amp; mCurrentDialog.isShowing()) {
    if (dismissOtherDialog) {
      mCurrentDialog.dismiss();
    }
    else {
      return;
    }
  }
  mCurrentDialog = newDialog;
  mCurrentDialog.show();
}

public boolean onBackPressed() {
  if (mCurrentDialog != null &amp;&amp; mCurrentDialog.isShowing()) {
    mCurrentDialog.dismiss();
    return true;
  }
  return false;
}</pre></div><p>We are going to show a dialog by calling the <code class="literal">showDialog</code> method on the fragment. This will store a reference to the dialog currently being displayed that can be used to determine if there is something else being shown and dismiss it if required.</p><p>By default we <a class="indexterm" id="id000424"/>are going to not display a dialog if another <a class="indexterm" id="id000425"/>one is already on the screen but, in the event you want to do it in your game, there is a version of <code class="literal">showDialog</code> that receives a boolean parameter to dismiss other dialogs, if present.</p><p>We also take care of handling the back key presses and use them to dismiss a dialog if it is being shown and return <code class="literal">true</code>, to indicate that the event has been consumed by the fragment.</p><p>Now that we have all the foundations, let's make a quit dialog for our game.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00083"/>Quit dialog</h2></div></div></div><p>The <a class="indexterm" id="id000426"/>quit dialog has to appear when the back key is pressed while in the <code class="literal">MainMenuFragment</code>. It will display some text and two buttons to exit or continue playing.</p><p>This is a <a class="indexterm" id="id000427"/>simple dialog that will help us understand how all the pieces fit into the architecture before we start creating more complex dialogs.</p><p>We will create the file <code class="literal">dialog_game_over.xml</code> under the <code class="literal">layouts</code> folder to define it. We are using a naming convention that gives all dialog layout definitions a name that starts with dialog (similar to the convention for fragments and activities).</p><p>The layout is as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_gravity="center"
  android:background="@drawable/diablog_bg"
  android:layout_width="@dimen/dialog_width"
  android:layout_height="@dimen/dialog_height"&gt;

  &lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textColor="@color/text_color"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:layout_centerHorizontal="true"
    style="@android:style/TextAppearance.Large"
    android:text="@string/exit_confirm"/&gt;

  &lt;LinearLayout
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:layout_marginBottom="@dimen/activity_vertical_margin"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"&gt;
    &lt;ImageView
      style="@style/iconButton"
      android:layout_marginRight="@dimen/btn_sound_size"
      android:id="@+id/btn_resume"
      android:src="img/resume"/&gt;

    &lt;ImageView
      style="@style/iconButton"
      android:id="@+id/btn_exit"
      android:src="img/exit"/&gt;
  &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;</pre></div><p>This is quite simple, but <a class="indexterm" id="id000428"/>we still have a few remarks to make:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The buttons will have the IDs <code class="literal">btn_exit</code> and <code class="literal">btn_resume</code>, and they use a transparent image we got from a free icon set.</li><li class="listitem" style="list-style-type: disc">Both buttons use the style <code class="literal">iconButton</code> we created for the home screen, which sets the round state list background image.</li><li class="listitem" style="list-style-type: disc">To make the buttons centered, we place them into a <code class="literal">LinearLayout</code> that is itself centered in the <code class="literal">RelativeLayout</code>. This is the easiest way to center several buttons.</li><li class="listitem" style="list-style-type: disc">We use the drawable <code class="literal">dialog_bg</code> as background. It is a shape drawable similar to the one for the square buttons, but with different colors.</li><li class="listitem" style="list-style-type: disc">The width and height of the dialog are extracted as dimensions. They will be the same for all dialogs. We have set them at 400x250dp.</li></ul></div><p>The class <a class="indexterm" id="id000429"/>that extends from <code class="literal">BaseCustomDialog</code> is quite simple as well:</p><div><pre class="programlisting">public class QuitDialog extends BaseCustomDialog implements View.OnClickListener {
  private QuitDialogListener mListener;

  public QuitDialog(YassActivity activity) {
    super(activity);
    setContentView(R.layout.dialog_quit);
    findViewById(R.id.btn_exit).setOnClickListener(this);
    findViewById(R.id.btn_resume).setOnClickListener(this);
   }

  public void setListener(QuitDialogListener listener) {
    mListener = listener;
  }

  @Override
  public void onClick(View v) {
    if (v.getId() == R.id.btn_exit) {
      dismiss();
      mListener.exit();
    }
    else if (v.getId() == R.id.btn_resume) {
      dismiss();
    }
  }

  public interface QuitDialogListener {
    void exit();
  }
}</pre></div><p>In the <a class="indexterm" id="id000430"/>constructor <a class="indexterm" id="id000431"/>we set listeners to the buttons and then inside <code class="literal">onClick</code> we either just dismiss the dialog if resume is clicked, or dismiss the dialog and exit if exit is clicked.</p><p>This highlights the typical architecture we are going to use. The dialog has a custom listener associated, and there is a method in the listener for each particular action that can be triggered from the dialog.</p><div><div><h3 class="title"><a id="note00073"/>Note</h3><p>Each dialog will have a listener with methods for each particular option the dialog presents.</p></div></div><p>Using an interface instead of the fragment class from which the dialog is called allows us to decouple the functionality and invoke the dialog from other places. It is also good practice in itself.</p><p>Now, <code class="literal">MainFragment</code> is responsible for showing this dialog and is also the class that implements <code class="literal">QuitDialogListener</code>. Let's look at the code we have to change in the fragment to handle the dialog:</p><div><pre class="programlisting">@Override
public boolean onBackPressed() {
  boolean consumed = super.onBackPressed();
  if (!consumed){
    QuitDialog quitDialog = new QuitDialog(getYassActivity());
    quitDialog.setListener(this);
    showDialog(quitDialog);
  }
  return true;
}

@Override
public void exit() {
  getYassActivity().finish();
}</pre></div><p>This is fairly simple. In <a class="indexterm" id="id000432"/>the case of back pressed, we first check if the parent <a class="indexterm" id="id000433"/>fragment handles the event (that is, if a dialog is being shown). If <code class="literal">false</code> is returned we create a <code class="literal">QuitDialog</code>, set this fragment to be the listener, and use the method <code class="literal">showDialog</code> of the base class to show it.</p><p>Either way the event is consumed by this fragment, so <code class="literal">onBackPressed</code> always returns <code class="literal">true</code>.</p><p>The method we have to implement because of the <code class="literal">QuitDialogListener</code> interface is <code class="literal">exit</code>, which is as simple as getting the parent <code class="literal">Activity</code> and calling <code class="literal">finish</code> in it.</p><div><img alt="Quit dialog" src="img/B04757_07_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00084"/>Pause dialog</h2></div></div></div><p>Let's do<a class="indexterm" id="id000434"/> something a bit more complex. We are going to replace <a class="indexterm" id="id000435"/>the existing Pause dialog with a custom one, and we will also add buttons to control sounds and music.</p><p>Again, we have some pieces that have to come together:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A layout for the dialog</li><li class="listitem" style="list-style-type: disc">A class that extends <code class="literal">BaseCustomDialog</code> to handle it</li><li class="listitem" style="list-style-type: disc">A listener interface for the actions performed in the dialog</li><li class="listitem" style="list-style-type: disc">Code in the <code class="literal">GameFragment</code> to handle it</li></ul></div><p>Let's start with the layout. This one will have two groups of buttons, one at the bottom left for exit and resume, and one at the bottom right for the sound and music settings.</p><p>The layout is a simple <code class="literal">RelativeLayout</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_gravity="center"
  android:background="@drawable/diablog_bg"
  android:layout_width="@dimen/dialog_width"
  android:layout_height="@dimen/dialog_height"&gt;

  &lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textColor="@color/text_color"
    android:layout_marginTop="@dimen/activity_vertical_margin"
    android:layout_centerHorizontal="true"
    style="@android:style/TextAppearance.Large"
    android:text="@string/pause"/&gt;

  &lt;ImageView
    style="@style/iconButton"
    android:id="@+id/btn_resume"
    android:layout_margin="@dimen/activity_vertical_margin"
    android:src="img/resume"
    android:layout_alignParentBottom="true"
    android:layout_alignParentLeft="true"/&gt;

  &lt;ImageView
    style="@style/iconButton"
    android:id="@+id/btn_exit"
    android:layout_alignBottom="@+id/btn_resume"
    android:src="img/exit"
    android:layout_toRightOf="@+id/btn_resume"/&gt;

  &lt;ImageView
    style="@style/iconButton"
    android:id="@+id/btn_sound"
    android:layout_margin="@dimen/activity_vertical_margin"
    android:src="img/sounds_on_no_bg"
    android:layout_alignParentBottom="true"
    android:layout_alignParentRight="true"/&gt;

  &lt;ImageView
    style="@style/iconButton"
    android:id="@+id/btn_music"
    android:layout_alignBottom="@+id/btn_sound"
    android:src="img/music_on_no_bg"
    android:layout_toLeftOf="@+id/btn_sound"/&gt;

&lt;/RelativeLayout&gt;</pre></div><p>Each button is <a class="indexterm" id="id000436"/>aligned to the left or right of another button or the dialog itself. Given <a class="indexterm" id="id000437"/>how we have picked the dimensions of the dialog frame and the buttons, we can ensure that the four buttons will fit in the screen nicely. We are also sure that this dialog will look the same on all devices.</p><div><img alt="Pause dialog" src="img/B04757_07_08.jpg"/></div><p>The code for the <strong>Pause</strong> dialog itself is a little more complex than the one for <code class="literal">QuitDialog</code>, mainly<a class="indexterm" id="id000438"/> because it has four different actions; it also needs to check the sound and <a class="indexterm" id="id000439"/>music status to decide which image to use.</p><p>Let's dig into the code:</p><div><pre class="programlisting">public class PauseDialog extends BaseCustomDialog implements View.OnClickListener {
  private PauseDialogListener mListener;

  public PauseDialog(YassActivity activity) {
    super(activity);
    setContentView(R.layout.dialog_pause);
    findViewById(R.id.btn_music).setOnClickListener(this);
    findViewById(R.id.btn_sound).setOnClickListener(this);
    findViewById(R.id.btn_exit).setOnClickListener(this);
    findViewById(R.id.btn_resume).setOnClickListener(this);
    updateSoundAndMusicButtons();
  }

  public void setListener(PauseDialogListener listener) {
    mListener = listener;
  }

  @Override
  public void onClick(View v) {
    if (v.getId() == R.id.btn_sound) {
      mParent.getSoundManager().toggleSoundStatus();
      updateSoundAndMusicButtons();
    }
    else if (v.getId() == R.id.btn_music) {
      mParent.getSoundManager().toggleMusicStatus();
      updateSoundAndMusicButtons();
    }
    else if (v.getId() == R.id.btn_exit) {
      super.dismiss();
      mListener.exitGame();
    }
    else if (v.getId() == R.id.btn_resume) {
      dismiss();
    }
  }

  @Override
  public void dismiss() {
    super.dismiss();
    mListener.resumeGame();
  }

  public void updateSoundAndMusicButtons() {
    [...]
  }

  public interface PauseDialogListener {
    void exitGame();
    void resumeGame();
  }
}</pre></div><p>The structure<a class="indexterm" id="id000440"/> is the same as before. We set the class to be the click listener for each button, and react accordingly inside <code class="literal">onClick</code>. We have hidden the code of <code class="literal">updateSoundAndMusicButtons</code> because it is very similar to the one in <code class="literal">MainFragment</code>.</p><p>Note that <code class="literal">PauseDialogListener</code> only <a class="indexterm" id="id000441"/>cares about exiting and resuming the game. Modifications to the sound status are done directly through the <code class="literal">SoundManager</code>, which is accessed via the parent activity.</p><p>The last part is the modifications in <code class="literal">GameFragment</code>; this is basically replacing the old <code class="literal">AlertDialog.Builder</code> with the new class, since the other functionality was already there:</p><div><pre class="programlisting">@Override
public boolean onBackPressed() {
  if (mGameEngine.isRunning() &amp;&amp; !mGameEngine.isPaused()){
    pauseGameAndShowPauseDialog();
    return true;
  }
  return super.onBackPressed();
}

private void pauseGameAndShowPauseDialog() {
  if (mGameEngine.isPaused()) {
    return;
  }
  mGameEngine.pauseGame();
  PauseDialog dialog = new PauseDialog(getYassActivity());
  dialog.setListener(this);
  showDialog(dialog);
}

public void resumeGame() {
  mGameEngine.resumeGame();
}

public void exitGame() {
  mGameEngine.stopGame();
  getYassActivity().navigateBack();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00085"/>Game Over dialog</h2></div></div></div><p>Let's go <a class="indexterm" id="id000442"/>for one more dialog, the <strong>Game Over</strong> one that will ask us to choose between playing again or exiting to the main menu. To handle the<a class="indexterm" id="id000443"/> <code class="literal">GameOverDialog</code>, we need to add some code to the <code class="literal">GameFragment</code> to start a new game. We will extract the code we already have for that into a method that can be called from the fragment.</p><p>We also need access to the fragment from "somewhere" inside the <code class="literal">GameEngine</code> to be able to display the dialog when the event happens. We are going to do that by passing the fragment to the <code class="literal">GameController</code>.</p><p>The dialog itself is very similar to <code class="literal">PauseDialog</code>, so we will not include the layout or the code here, just the interface we have defined for it that we called <code class="literal">GameOverDialogListener</code>.</p><div><pre class="programlisting">public interface GameOverDialogListener {
  void exitGame();

  void startNewGame();
}</pre></div><div><img alt="Game Over dialog" src="img/B04757_07_09.jpg"/></div><p>Let's start<a class="indexterm" id="id000444"/> with the modifications to <code class="literal">GameFragment</code>. This class will be the one implementing <code class="literal">GameOverDialogListener</code>.</p><p>As it happens, <code class="literal">GameFragment</code> already has a method called <code class="literal">exitGame</code>, which we were invoking from the <code class="literal">PauseDialog</code>, so the only one to implement is <code class="literal">startNewGame</code>.</p><p>For that we are<a class="indexterm" id="id000445"/> going to extract all the logic for creating the <code class="literal">GameEngine</code> to a method and then we will call it from the two places where a game can start:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">onGlobalLayout</code> method when the fragment is created and measured</li><li class="listitem" style="list-style-type: disc"><code class="literal">startNewGame</code> when the "<strong>Play Again?</strong>" button is clicked on the <code class="literal">GameOver</code> dialog</li></ul></div><p>The code is like this:</p><div><pre class="programlisting">@Override
public void startNewGame() {
  // Exit the current game
  mGameEngine.stopGame();
  // Start a new one
  prepareAndStartGame();
}

private void prepareAndStartGame() {
  GameView gameView = (GameView) getView().findViewById(R.id.gameView);
  mGameEngine = new GameEngine(getActivity(), gameView, 4);
  mGameEngine.setInputController(new CompositeInputController(getView(), getYassActivity()));
  mGameEngine.setSoundManager(getYassActivity().getSoundManager());
  new ParallaxBackground(mGameEngine, 20, R.drawable.seamless_space_0).addToGameEngine(mGameEngine, 0);
  new GameController(mGameEngine, GameFragment.this).addToGameEngine(mGameEngine, 2);
  new FPSCounter(mGameEngine).addToGameEngine(mGameEngine, 2);
  new ScoreGameObject(getView(), R.id.score_value).addToGameEngine(mGameEngine, 0);
  new LivesCounter(getView(), R.id.lives_value).addToGameEngine(mGameEngine, 0);
  mGameEngine.startGame();
  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) {
    InputManager inputManager = (InputManager) getActivity().getSystemService(Context.INPUT_SERVICE);
    inputManager.registerInputDeviceListener(GameFragment.this, null);
  }
}</pre></div><p>When we<a class="indexterm" id="id000446"/> start the game, we first have to stop the previous one. Even when the <code class="literal">GameOverDialog</code> is in front, the <code class="literal">GameEngine</code> is not paused or stopped. In<a class="indexterm" id="id000447"/> fact we can see the parallax background moving behind the dialog. This is a nice effect and we want to keep it like that, but that means we need to stop the current game before starting a new one or we will have two engines running at the same time, which is terrible for performance and battery life.</p><p>Note that there is no creation of a <code class="literal">Player</code> in the initialization. This is something we removed when we made the <code class="literal">GameController</code> manage the lives, but it is worth highlighting this again.</p><p>On the other hand we need to be able to show a dialog from inside the <code class="literal">GameController</code> since the utility methods for showing dialogs are implemented on the base fragment. That is why we need to pass a parameter to the constructor and store it as a member variable.</p><div><pre class="programlisting">public GameController(GameEngine gameEngine, GameFragment parent) {
  mParent = parent;
  […]
}

@Override
public void onGameEvent(GameEvent gameEvent) {
  [...]
  else if (gameEvent == GameEvent.GameOver) {
    mState = GameControllerState.GameOver;
    showGameOverDialog();
  }
}

private void showGameOverDialog() {
  mParent.getActivity().runOnUiThread(new Runnable() {
    @Override
    public void run() {
      GameOverDialog quitDialog = new GameOverDialog(mParent);
      quitDialog.setListener(mParent);
      mParent.showDialog(quitDialog);
    }
  });
}</pre></div><p>As part of<a class="indexterm" id="id000448"/> the <a class="indexterm" id="id000449"/>handling of the <code class="literal">GameOver</code> event, we create and show the <code class="literal">GameOverDialog</code>. Note that since game events arrive in the <code class="literal">UpdateThread</code> and the creation and display of the dialog must be run on the <code class="literal">UIThread</code>, we need to use a <code class="literal">Runnable</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec00086"/>Other dialogs</h2></div></div></div><p>There are<a class="indexterm" id="id000450"/> two more dialogs in the game that we have not worked with yet. Those dialogs are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Notice dialog of a controller being connected.</li><li class="listitem" style="list-style-type: disc">The Touch Control information dialog</li></ul></div><p>Both dialogs are just an image, and tapping on them should dismiss them so there are neither complex layouts nor any need for custom listeners.</p><p>We will, however, work on the controller connected dialog in <a class="link" href="ch30.html" title="Chapter 10. To the Big Screen">Chapter 10</a>, <em>To the Big Screen</em> because we want to show it in different circumstances: on a TV rather than on a phone.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec00051"/>Designing for multiple screen sizes</h1></div></div></div><p>While <a class="indexterm" id="id000451"/>we have designed our <code class="literal">GameView</code> to scale equally in all screen sizes and aspect ratios by making use of the appropriate screen units, Android views do not work this way; however, we can follow the standard Android procedures for them.</p><p>For apps, it is recommended that you tweak the layout based on the screen size. For games it makes sense to keep the same layout across all screen sizes and only vary the size and margins of some items.</p><div><div><h3 class="title"><a id="note00074"/>Note</h3><p>Games should keep the same layout for all screen sizes.</p></div></div><p>As a rule of thumb, you should always use <code class="literal">RelativeLayout</code> to design your layouts, where every item on the screen is positioned relative to something else. This allows the layout to adapt smoothly to all screen sizes. This concept is at the core of responsive design.</p><p>To have a proper display in all screen sizes, we are going to qualify the dimensions; this is included on the Android SDK and is recommended practice.</p><div><div><h3 class="title"><a id="note00075"/>Note</h3><p>Qualifying dimensions<a class="indexterm" id="id000452"/> is a best practice for apps and games.</p></div></div><p>Qualifying resources <a class="indexterm" id="id000453"/>works by selecting different dimension specifications based on the screen sizes and applying them dynamically. Note that since Android 3.2 qualifying resources using <a class="indexterm" id="id000454"/>the <code class="literal">normal</code>, <code class="literal">large</code>, and <code class="literal">xlarge</code> keywords has been considered obsolete (although it is the first thing you find when looking at the documentation).</p><p>There are three ways to qualify resources based on screen size:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Smallest width</strong>: this <a class="indexterm" id="id000455"/>takes the smallest width of the device regardless of whether it is in landscape or in portrait. This is useful when you need to guarantee the minimum size of any dimension. It does not change on screen rotation.</li><li class="listitem" style="list-style-type: disc"><strong>Available screen width</strong>: the<a class="indexterm" id="id000456"/> current screen width. Note that this changes when the orientation changes, and other resources, such as layouts, may change as well.</li><li class="listitem" style="list-style-type: disc"><strong>Available screen height</strong>: complementary<a class="indexterm" id="id000457"/> to the previous one.</li></ul></div><p>The way to use these is to create a <code class="literal">resources</code> directory appending the qualifier, such as <code class="literal">values-sw720dp</code> or <code class="literal">values-w820dp</code>. Note that these qualifiers are defined in dips.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A normal phone will have values between 320x480dp and 480x800dp since they can vary from 3.2 to over 5 inches.</li><li class="listitem" style="list-style-type: disc">A 7'' tablet will start at around 600x960dp.</li><li class="listitem" style="list-style-type: disc">A 10'' tablet will typically have at least 720x1280dp.</li></ul></div><p>We are going to qualify some dimensions based on the available screen width and we are going to separate phones, small tablets, and large tablets. We will use the directories <code class="literal">values-w820dp</code> (which is already created by the wizard) and <code class="literal">values-w1024dp</code>.</p><p>Let's look at the dimensions we have defined for our game so far:</p><div><pre class="programlisting">&lt;resources&gt;
  &lt;dimen name="square_button_padding"&gt;18dp&lt;/dimen&gt;
  &lt;dimen name="square_button_border"&gt;6dp&lt;/dimen&gt;
  &lt;dimen name="round_button_padding"&gt;6dp&lt;/dimen&gt;
  &lt;dimen name="btn_round_size"&gt;60dp&lt;/dimen&gt;

  &lt;dimen name="menu_margin"&gt;8dp&lt;/dimen&gt;
  &lt;dimen name="game_frame_width"&gt;6dp&lt;/dimen&gt;
  &lt;dimen name="game_menu_width"&gt;100dp&lt;/dimen&gt;

  &lt;dimen name="life_size"&gt;30dp&lt;/dimen&gt;

  &lt;dimen name="activity_horizontal_margin"&gt;16dp&lt;/dimen&gt;
  &lt;dimen name="activity_vertical_margin"&gt;16dp&lt;/dimen&gt;

  &lt;dimen name="dialog_width"&gt;400dp&lt;/dimen&gt;
  &lt;dimen name="dialog_height"&gt;250dp&lt;/dimen&gt;
&lt;/resources&gt;</pre></div><p>Note that since <a class="indexterm" id="id000458"/>our <code class="literal">TextViews</code> are using the standard android styles, we have no dimensions for text sizes. If you are using your own styles for text, qualifying the text size is also advisable.</p><p>We will not modify the size of the touch targets. Because of that, we are keeping the square and round button dimensions for all sizes.</p><div><div><h3 class="title"><a id="note00076"/>Note</h3><p>The size of touch targets should not change in line with screen sizes.</p></div></div><p>The margins were defined by Android Studio for <code class="literal">w820dp</code> when we created the default project so we do not need to touch these either.</p><p>The margins of the game and the size of the dialogs are the dimensions we do need to update. This alone will make it look much better on 7" and 10" tablets.</p><p>Our worst case for phones is the narrowest one, when it has 480 dp width, because it leaves us with only 280 dp of game area. Even then though, this is more than 50 percent of the screen and looks OK.</p><p>On the other hand, the layout starts looking bad when the aspect ratio of the game is too wide. So for <code class="literal">w820dp</code> we will take 150 dp for the margin instead, and for <code class="literal">w1280dp</code> we will take 200 dp. You can easily play with the preview tool on Android Studio and tweak these values until you like the result. Life size should also be larger, since the space for three of them is also larger on those screens.</p><p>We will make the dialogs slightly larger on larger screens as well.</p><p>All in all, <code class="literal">values-w820dp</code> will have the following <code class="literal">dimens.xml</code>:</p><div><pre class="programlisting">&lt;dimen name="activity_horizontal_margin"&gt;64dp&lt;/dimen&gt;
&lt;dimen name="menu_margin"&gt;12dp&lt;/dimen&gt;

&lt;dimen name="game_menu_width"&gt;150dp&lt;/dimen&gt;
&lt;dimen name="life_size"&gt;45dp&lt;/dimen&gt;

&lt;dimen name="dialog_width"&gt;500dp&lt;/dimen&gt;
&lt;dimen name="dialog_height"&gt;300dp&lt;/dimen&gt;</pre></div><p>While<a class="indexterm" id="id000459"/> for <code class="literal">values-w1080dp</code> we will have these:</p><div><pre class="programlisting">&lt;dimen name="menu_margin"&gt;16dp&lt;/dimen&gt;

&lt;dimen name="game_menu_width"&gt;200dp&lt;/dimen&gt;
&lt;dimen name="life_size"&gt;60dp&lt;/dimen&gt;

&lt;dimen name="dialog_width"&gt;600dp&lt;/dimen&gt;
&lt;dimen name="dialog_height"&gt;400dp&lt;/dimen&gt;</pre></div><p>This technique allows us to modify the UI to adapt to larger screens without touching the layout at all.</p><div><img alt="Designing for multiple screen sizes" src="img/B04757_07_10.jpg"/><div><p>Before and after qualifying the layouts for w820dp</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec00052"/>Summary</h1></div></div></div><p>We have learned how to customize the UI of our game using the standard tools, drawables, and views that Android provides. This includes custom fonts, state lists drawables, shape drawables and, especially, custom dialogs that replace the default ones in a way that matches the look and feel of our game.</p><p>We also modified the game to include a score and multiple lives. We modified the UI of the <code class="literal">GameFragment</code> to display both of them. For that functionality. we extended the game event system to work as an event bus for all the <code class="literal">GameObjects</code>.</p><p>While the game is starting to look complete, it still feels a bit clunky at times and that is because we are not using any animations. In the next chapter we will learn the different techniques for animations that Android provides and will apply them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch28"/>Chapter 8. The Animation Framework</h1></div></div></div><p>Android provides a variety of powerful APIs to apply animation to UI elements. This chapter aims at providing an overview of the options available to help you decide which approach is best for your needs.</p><p>Before we start adding animations, we will refactor our code a bit to make the usage of animations easier by creating a callback on our base fragment once the layout has been completed.</p><p>Then, we will see how to define a traditional frame-by-frame animations that can be used in an <code class="literal">ImageView</code>. We will also see how to incorporate them in our <code class="literal">GameEngine</code> in the form of <code class="literal">AnimatedSprite</code>.</p><p>The core of the chapter is about the different ways to animate views. We will start talking about interpolators and their role in the Android Animation Framework. Then, we will learn about the old method called view animation and we will use it to animate some areas of the game, including how to show and hide our custom dialogs.</p><p>Then, we will talk about <code class="literal">ValueAnimator</code>, <code class="literal">PropertyAnimator</code>, and finally, <code class="literal">ViewPropertyAnimator</code>, explaining how they are different, more versatile, and complex than view animations and in which cases each of them are preferred. We will also do some examples of them.</p><p>Finally, we will animate the TextViews of the main screen using different approaches so you can check their differences and similarities.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec00053"/>Updating BaseFragment</h1></div></div></div><p>Usually <a class="indexterm" id="id000460"/>animations (especially <code class="literal">ViewPropertyAnimator</code>) require the layout of the views to be completed before they can be applied. We already have a method for this in the <code class="literal">GameFragment</code>, so we are going to generalize it and make it a part of the <code class="literal">BaseFragment</code>.</p><p>The method uses <code class="literal">ViewTreeObserver</code> to check when the layout of the view has been completed. The code we will add to the <code class="literal">BaseFragment</code> is like this:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  getYassActivity().applyTypeface(view);
  final ViewTreeObserver obs = view.getViewTreeObserver();
  obs.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public synchronized void onGlobalLayout() {
      ViewTreeObserver viewTreeObserver = getView().getViewTreeObserver();
      if (viewTreeObserver.isAlive()) {
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {
          viewTreeObserver.removeGlobalOnLayoutListener(this);
        } else {
          viewTreeObserver.removeOnGlobalLayoutListener(this);
        }
        onLayoutCompleted();
      }
    }
  });
}</pre></div><p>Since we have removed a <a class="indexterm" id="id000461"/>lot of code from <code class="literal">GameFragment</code>, the new version is much simpler:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  view.findViewById(R.id.btn_play_pause).setOnClickListener(this);
}

@Override
protected void onLayoutCompleted() {
  prepareAndStartGame();
}</pre></div><p>With these modifications, we can use <code class="literal">onLayoutCompleted</code> in the <code class="literal">MainMenuFragment</code> later in the chapter when we start adding animations.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec00054"/>AnimationDrawable</h1></div></div></div><p>The<code class="literal"> AnimationDrawable</code> <a class="indexterm" id="id000462"/>is how you define a frame-by-frame animation in Android. It describes a drawable as a list of other drawable resources that are played sequentially to create an animation. This is an animation in the most traditional sense: a sequence of independent images, played one after another.</p><p>We can define the frames of an animation in code using the <code class="literal">AnimationDrawable</code> class, but it is much easier to use XML. This file lists the frames that compose the animation and their duration. The XML is composed by a root node of the <code class="literal">&lt;animation-list&gt;</code> type and a series of child nodes of the <code class="literal">&lt;item&gt;</code> type that define a frame using a drawable resource and the frame duration:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;animation-list 
  android:oneshot=["true" | "false"] &gt;
  &lt;item
    android:drawable="@[package:]drawable/drawable_resource_name"
    android:duration="integer" /&gt;
&lt;/animation-list&gt;</pre></div><p>This XML file belongs to <a class="indexterm" id="id000463"/>the <code class="literal">res/drawable/</code> directory of your Android project, because it is considered a drawable.</p><div><div><h3 class="title"><a id="note00077"/>Note</h3><p>The<code class="literal"> AnimationDrawable</code> resources are placed in the <code class="literal">drawable</code> directory.</p></div></div><p>Let's see this with an example. We are going to make a simple animation that makes the lights of our spaceship blink. For this, we will use four frames:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lights off (normal spaceship)</li><li class="listitem" style="list-style-type: disc">Left light on</li><li class="listitem" style="list-style-type: disc">Lights off (again)</li><li class="listitem" style="list-style-type: disc">Right light on</li></ul></div><p>Note that we can reuse the same drawable for different frames, allowing us to save some space.</p><div><img alt="AnimationDrawable" src="img/B04757_08_01.jpg"/><div><p>The four frames of our spaceship animation</p></div></div><p>The definition of the <a class="indexterm" id="id000464"/>spaceship with blinking lights is like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;animation-list 
  android:oneshot="false"&gt;
  &lt;item android:drawable="@drawable/ship_2" android:duration="600" /&gt;
  &lt;item android:drawable="@drawable/ship_1" android:duration="400" /&gt;
  &lt;item android:drawable="@drawable/ship_2" android:duration="600" /&gt;
  &lt;item android:drawable="@drawable/ship_3" android:duration="400" /&gt;
&lt;/animation-list&gt;</pre></div><p>We make the light stay on only for 400 milliseconds and then no lights for 600 milliseconds. Then, we go for the other light.</p><p>We have defined <code class="literal">oneShot</code> to <code class="literal">false</code>. This makes the animation repeat from the beginning once the last frame has finished. If you want to have animations that are played only once, you should set <code class="literal">oneShot</code> to <code class="literal">true</code>.</p><p>To test this, we can add an <code class="literal">ImageView</code> to the layout of the main menu and set the <code class="literal">AnimationDrawable</code> for it:</p><div><pre class="programlisting">&lt;ImageView
  android:id="@+id/ship_animated"
  android:layout_width="50dp"
  android:layout_height="50dp"
  android:layout_centerHorizontal="true"
  android:src="img/ship_animated"
  android:layout_below="@+id/btn_start"
/&gt;</pre></div><p>If we try this, we will see that the animation does not work. <code class="literal">AnimationDrawable</code> is not auto played. Also, it's important to note that the <code class="literal">start</code> method of the <code class="literal">AnimationDrawable</code> cannot be called inside the activity's <code class="literal">onCreate</code> method, because the <code class="literal">AnimationDrawable</code> is not yet fully attached to the window. We will have to wait until the window is <a class="indexterm" id="id000465"/>fully created, which will be notified by the <code class="literal">onWindowFocusChanged</code> method in the activity.</p><div><div><h3 class="title"><a id="note00078"/>Note</h3><p>AnimationDrawables are not played automatically, we have to start them in code.</p></div></div><p>However, the animation can be started from the <code class="literal">onViewCreated</code> method of the fragment. Since we already have the <code class="literal">onLayoutCompleted</code> method that is called a bit later, we will use this one instead for consistency:</p><div><pre class="programlisting">@Override
protected void onLayoutCompleted() {
  ImageView iv = (ImageView) getView().findViewById(R.id.ship_animated);
  ((AnimationDrawable)iv.getDrawable()).start();
}</pre></div><p>But this is not enough for us: <code class="literal">AnimationDrawable</code> defines a frame-by-frame animation that can be used in <code class="literal">ImageView</code>. What is really interesting is to be able to use this same XML definition to describe animated sprites. For this, we are going to create a new class that extends from <code class="literal">Sprite</code> and takes care of the animation.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00087"/>Animated sprites</h2></div></div></div><p>To create animated <a class="indexterm" id="id000466"/>sprites, we need to take care of the <a class="indexterm" id="id000467"/>specifics of <code class="literal">AnimationDrawable</code>. Since we already have all the code that draws a <code class="literal">Sprite</code> on the screen, the new <code class="literal">AnimatedSprite</code> class will only have to take care of counting the time to select which bitmap should be drawn.</p><p>Note that this will only work for <code class="literal">AnimationDrawable</code> when all the frames are defined as bitmaps, other XML resources such as shapes are not supported by our <code class="literal">Sprite</code> base class.</p><p>Let's look at the code of <code class="literal">AnimatedSprite</code>:</p><div><pre class="programlisting">public abstract class AnimatedSprite extends Sprite {

  private final AnimationDrawable mAnimationDrawable;
  private int mTotalTime;
  private long mCurrentTime;

  public AnimatedSprite(GameEngine gameEngine, int drawableRes, BodyType bodyType) {
    super(gameEngine, drawableRes, bodyType);
    // Now, the drawable must be an animation drawable
    mAnimationDrawable = (AnimationDrawable) mSpriteDrawable;
    // Calculate the total time of the animation
    mTotalTime = 0;
    for (int i=0; i&lt;mAnimationDrawable.getNumberOfFrames(); i++) {
      mTotalTime += mAnimationDrawable.getDuration(i);
    }
  }

  @Override
  protected Bitmap obtainDefaultBitmap() {
    AnimationDrawable ad = (AnimationDrawable) mSpriteDrawable;
    return ((BitmapDrawable) ad.getFrame(0)).getBitmap();
  }

  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
    mCurrentTime += elapsedMillis;
    if (mCurrentTime &gt; mTotalTime) {
      if (mAnimationDrawable.isOneShot()) {
        return;
      }
      else {
        mCurrentTime = mCurrentTime % mTotalTime;
      }
    }
    long animationElapsedTime = 0;
    for (int i=0; i&lt;mAnimationDrawable.getNumberOfFrames(); i++) {
      animationElapsedTime += mAnimationDrawable.getDuration(i);
      if (animationElapsedTime &gt; mCurrentTime) {
        mBitmap = ((BitmapDrawable) mAnimationDrawable.getFrame(i)).getBitmap();
        break;
      }
    }
  }
}</pre></div><p>We have created a new method named <code class="literal">obtainDefaultBitmap</code> that is called from the constructor. For normal sprites, this method just returns the bitmap. In the case of <code class="literal">AnimatedDrawable</code>, we initialize it to the first frame.</p><p>The constructor has the same parameters as the normal sprite, but if the drawable resource is not an <code class="literal">AnimationDrawable</code>, a <code class="literal">ClassCastException</code> will be thrown. Error handling was not included to make the code easier to follow.</p><p>Another thing that is done in the constructor is the calculation of the total time of the <code class="literal">AnimationDrawable</code> by adding the duration of all the frames. We will need this value each time we run <code class="literal">onUpdate</code>, so we should get it in advance.</p><p>During <code class="literal">onUpdate</code>, we add the elapsed milliseconds to the total time, then we check whether the total time the <code class="literal">AnimatedSprite</code> has been running is longer than the total time of the animation. If <a class="indexterm" id="id000468"/>this is the case, we check <a class="indexterm" id="id000469"/>whether <code class="literal">AnimationDrawable</code> is set to <code class="literal">oneShot</code> or not. If it is <code class="literal">oneShot</code>, we do nothing, since the last image has already been set. If the animation is to be repeated, we just make <code class="literal">mCurrentTime</code> get back into the interval by applying the module operator.</p><p>Once we know that the current time will be in the animation time range, we iterate over the frames, checking which one is the current frame and setting the bitmap in this frame to the <code class="literal">mImage </code>member variable, which is the one used by the base class to draw on the canvas.</p><p>Drawing the bitmap on the canvas is already done by the parent <code class="literal">Sprite</code> class.</p><p>Note that all the classes that extend from <code class="literal">AnimatedSprite</code> must call the super method while overriding <code class="literal">onUpdate.</code> Otherwise, the code that updates the image will not be executed.</p><div><div><h3 class="title"><a id="note00079"/>Note</h3><p>When extending <code class="literal">AnimatedSprite</code>, don't forget to call super while overriding <code class="literal">onUpdate</code>.</p></div></div><p>Now, let's animate our in-game spaceship.</p><p>We just need to update <code class="literal">Player</code> to extend from <code class="literal">AnimatedSprite</code>, change the image resource we pass to the constructor, and remember to call the super method in <code class="literal">onUpdate</code>:</p><div><pre class="programlisting">public class Player extends AnimatedSprite {

  public Player(GameEngine gameEngine) {
    super(gameEngine, R.drawable.ship_animated, BodyType.Circular);
    […]
  }
  
  @Override
  public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
    super.onUpdate(elapsedMillis, gameEngine);
    […]
  }
}</pre></div><p>We have a spaceship <a class="indexterm" id="id000470"/>with blinking <a class="indexterm" id="id000471"/>lights!</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00088"/>Animating views</h2></div></div></div><p>The Android <a class="indexterm" id="id000472"/>framework provides two animation systems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">View animation</li><li class="listitem" style="list-style-type: disc">Property animation</li></ul></div><p>View animation has been <a class="indexterm" id="id000473"/>present since the first version of Android, while property animation was introduced in Android 3.0. The latter is recommended, because it is more consistent and offers more features.</p><p>The view animation system can only be used to animate views. It is also constrained in that it only exposes a few aspects of a <code class="literal">View</code> object to animate, such as the scaling and rotation of a view but not the background color for instance.</p><p>Another disadvantage of the view animation system is that it only modifies where the view is drawn and not the actual view itself. For example, if you animate a button to move across the screen, the button will draw correctly, but the actual location considered for a click on the button does not change and this can be problematic.</p><div><div><h3 class="title"><a id="note00080"/>Note</h3><p>View animation modifies the place where the view is drawn, not the view itself.</p></div></div><p>On the other hand, the property animation system allows us to animate any property of any object (views and nonviews) and the object itself is actually modified.</p><p>The view animation system, however, is easier to use and requires less code. If view animation accomplishes everything you need to do, there is no need to use the property animation system.</p><div><div><h3 class="title"><a id="note00081"/>Note</h3><p>View animation is simpler. Property animation is more advanced.</p></div></div><p>While using <code class="literal">ViewPropertyAnimation</code>, the animation only receives a parameter of the final value, because it is animated from the current one. This may require some initialization.</p><p>All in all, it is good to know both the animation systems and apply the one that fits best for each case.</p><p>Regardless of the <a class="indexterm" id="id000474"/>system, animations are usually easy to implement in Android, but it takes a lot of work to tweak the parameters to make the animation feel right. An <a class="indexterm" id="id000475"/>animation that does not feel good is worse than no animation at all, but an animation that is right makes the game feel much nicer and smoother. Be prepared to pay a lot of attention to the detail while working on them.</p><div><div><h3 class="title"><a id="note00082"/>Note</h3><p>Tweaking animations requires a lot of time.</p></div></div><p>As a rule of thumb, animations should be long enough to be noticeable (otherwise, adding them will be pointless), but not so long that they make the game feel slow. This means that a transition animation should have a duration between 300 and 400 milliseconds.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00089"/>XML versus code</h2></div></div></div><p>Both view animation <a class="indexterm" id="id000476"/>and property animation (as almost any resource) can be defined i<a class="indexterm" id="id000477"/>n code or XML. Unless you require some value that could only be obtained in runtime it is better to use XML because all the files are external to the code and the animation can be modified without touching the Java source.</p><p>Having the animations <a class="indexterm" id="id000478"/>defined as a resource also allows us to use them at different places in the code and be sure that any change in the animation will affect all the places where it is used. If we define the animations in code we will have to check each place where the animation is built or rely on utility classes, which are not nice to handle.</p><p>There is a middle ground where you can define the animation in XML and then read it and modify some of the parameters using code. This approach is quite powerful; it gives us control over the animation while keeping most of its definition outside the code.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00090"/>Interpolators</h2></div></div></div><p>The animation <a class="indexterm" id="id000479"/>system plays an animation between a start time <a class="indexterm" id="id000480"/>and end time. Every frame of the animation is displayed at a specific time between the start and end. By default it follows a linear function, but this can be changed. In games, this technique is usually known as <strong>tweening</strong>, but in Android it is called <strong>interpolation</strong>. Let's see how it works.</p><div><div><h3 class="title"><a id="note00083"/>Note</h3><p>Interpolators are the equivalent of tweening animations in general game jargon.</p></div></div><p>Animations use a time index to calculate the values. This time index is basically a normalized time, a value between 0.0 and 1.0.</p><p>In the simplest case, the value of the time index is taken to calculate the transformation of the object. In the case of a transformation, 0.0 corresponds to the start position, 1.0 to the end position, and 0.5 to halfway between the start and the end. This is exactly what the linear interpolator does.</p><p>In general, we can transform the time index into another value by using a mathematical function. This is exactly what an interpolator does.</p><p>A time interpolator is essentially a function that takes a value between 0.0 and 1.0 and transforms it into <a class="indexterm" id="id000481"/>another value that is used to calculate the animation as the time index.</p><p>Android provides a set of default interpolators that cover the basic configurations and should be enough for most cases. In case you need something very special, you can create your own interpolator that just needs to implement a one-method interface.</p><p>We are not going to enter the detail of the mathematical functions, but just an overview of what they look like. The <a class="indexterm" id="id000482"/>interpolators defined in Android are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Linear</strong>: a simple linear function.</li><li class="listitem" style="list-style-type: disc"><strong>Cycle</strong>: the animation follows a sinusoidal curve using time index 1 as a full circumference.</li><li class="listitem" style="list-style-type: disc"><strong>Bounce</strong>: the animation bounces back a few times when it reaches the end.</li><li class="listitem" style="list-style-type: disc"><strong>Decelerate</strong>: the animation slows towards the end.</li><li class="listitem" style="list-style-type: disc"><strong>Accelerate</strong>: the animation goes faster towards the end.</li><li class="listitem" style="list-style-type: disc"><strong>AccelerateDecelerate</strong>: The animation accelerates in the beginning and slows down at the end.</li><li class="listitem" style="list-style-type: disc"><strong>Overshoot</strong>: The animation goes over the end and then goes back.</li><li class="listitem" style="list-style-type: disc"><strong>Anticipate</strong>: Before starting, the animation goes back to get an impulse. This is the opposite of overshoot.</li><li class="listitem" style="list-style-type: disc"><strong>AnticipateOvershoot</strong>: This combines both overshoot and anticipate.</li></ul></div><div><img alt="Interpolators" src="img/B04757_08_02.jpg"/><div><p>The different interpolators of Android</p></div></div><p>There are a few more interpolators added to API level 21 for the animations that follow the Material Design guidelines. We do not really need them for a game. We want funny, good looking animations; we do not care if they do not look real, which is a core characteristic of Material Design.</p><p>Interpolators are a <a class="indexterm" id="id000483"/>common concept that can be applied to all the ways of <a class="indexterm" id="id000484"/>animating views we are going to work with.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec00055"/>View animation</h1></div></div></div><p>The original and <a class="indexterm" id="id000485"/>simpler way of animating views in Android is to use view animation. This creates an <code class="literal">Animation</code> object either by loading it from XML or programmatically, which is then applied to the view. They are relatively easy to set up and offer enough capabilities to meet most needs.</p><p>There are some important details about view animations. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When we animate a view, all the children of the view are affected as well.</li><li class="listitem" style="list-style-type: disc">Regardless of how your animation may move or resize, the bounds of the view that is animated will not automatically adjust to accommodate it. Even so, the animation will still be drawn beyond the bounds of its view and will not be clipped. However, clipping will occur if the animation exceeds the bounds of the parent view. This can be fixed by setting <code class="literal">clipChildren</code> to false in the parent view.</li><li class="listitem" style="list-style-type: disc">The views will return to their original state once the animation is completed. If you plan to use this type of animations to reveal or hide a view, you must be sure of setting its <a class="indexterm" id="id000486"/>visibility to the desired state before the animation starts and after the animation ends. This can be easily achieved using a listener.</li><li class="listitem" style="list-style-type: disc">The bounds of the view are not changed during animation. This implies that the touch area is the same regardless of the place where the view is drawn. This is one of the most relevant reasons why we would want to use property animations instead.</li></ul></div><p>The files that define the animations must be placed under the <code class="literal">res/animation</code> folder and their definition is as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;set 
  android:interpolator="@[package:]anim/interpolator_resource"
  android:shareInterpolator=["true" | "false"] &gt;
  &lt;alpha
    android:fromAlpha="float"
    android:toAlpha="float" /&gt;
  &lt;scale
    android:fromXScale="float"
    android:toXScale="float"
    android:fromYScale="float"
    android:toYScale="float"
    android:pivotX="float"
    android:pivotY="float" /&gt;
  &lt;translate
    android:fromXDelta="float"
    android:toXDelta="float"
    android:fromYDelta="float"
    android:toYDelta="float" /&gt;
  &lt;rotate
    android:fromDegrees="float"
    android:toDegrees="float"
    android:pivotX="float"
    android:pivotY="float" /&gt;
  &lt;set&gt;
    ...
  &lt;/set&gt;
&lt;/set&gt;</pre></div><p>Some of the attributes defined in the format are positions. They can be defined in three different ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pixels relative to the default position (for example 50)</li><li class="listitem" style="list-style-type: disc">Percentage relative to the View itself (for example 50%)</li><li class="listitem" style="list-style-type: disc">Percentage relative to the parent View (for example 50%p)</li></ul></div><p>The usage of pixels is discouraged, the percentage relative to the view or the parent view is normally the way to go.</p><p>A set is nothing more than a way to group other properties. Most of the times, you'll use only one, but they can be nested to define more complex animations.</p><p>The set can have an interpolator, which will be applied to all the children if the <code class="literal">shareInterpolator</code> attribute is set to true. This allows all the animations to flow together smoothly. This is how <a class="indexterm" id="id000487"/>it is used most of the time, but it is possible for each component to have its own interpolator.</p><p>The concepts are pretty much the same ones we already used when we used the transformation matrix on the <code class="literal">DrawThread</code>. We can scale, translate, rotate, and modify the alpha.</p><p>Alpha is the simplest one; it just has initial and final values.</p><p>Scale receives the initial and final scale on both axes and also the pivot point. This pivot point is the position from where the scale will be applied. It is usually provided as a percentage. The most common configuration is to put 50 percent on both axes, so it grows from the center of the view. But other configurations can work nicely like 0 percent on both, which will make it grow from the top left.</p><p>Translate receives the deltas of origin and the destination on both axes. They are also positions, and can be defined with references of the percentage to the parent view.</p><p>Rotate receives the from and to degrees and also the pivot point from which the rotation is applied. Note that this allows you to rotate a view from a position relative to the parent view or even outside the view itself, which may come in handy.</p><p>There are a few attributes that are common to all the tags. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">startOffset</code>: allows us to define an offset so the animation does not start straight away.</li><li class="listitem" style="list-style-type: disc"><code class="literal">duration</code>: defines how long the animation is going to last.</li><li class="listitem" style="list-style-type: disc"><code class="literal">repeatCount</code>: allows us to make the animation repeat, either infinitely or a specific number of times.</li><li class="listitem" style="list-style-type: disc"><code class="literal">repeatMode</code>: only used while repeating. It allows us to reverse the animation instead of repeating it from the beginning.</li><li class="listitem" style="list-style-type: disc"><code class="literal">interpolator</code>: The interpolator to use (in case <code class="literal">shareInterpolator</code> is set to false).</li></ul></div><p>There is a known issue of <code class="literal">repeatCount</code> not working for sets when defined in XML, although it does work for individual animations. You can, however, set the <code class="literal">repeatCount</code> in code after loading the animation and this works too.</p><div><div><h3 class="title"><a id="note00084"/>Note</h3><p>r<code class="literal">epeatCount</code> will not work when defined for sets in XML.</p></div></div><p>The way a repeating animation <a class="indexterm" id="id000488"/>interacts with <code class="literal">startOffset</code> could be counter intuitive. The offset is considered a part of the animation and it is therefore repeated. We will see an example of that later in this chapter.</p><p>Again, as happened with the transformation matrix, the order of the definition in the animation is very important. The result of first translate and then rotate is not the same as when we first rotate and then translate. This should be clear to everyone by now.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00091"/>Animating dialogs</h2></div></div></div><p>We are going to <a class="indexterm" id="id000489"/>animate the show and hide of dialogs in the game using view animations.</p><p>Although we are not using the platform's default animations for the dialogs, it is advised to be consistent in our game and to ensure all the dialogs have the same animations. This is why the changes are to be made in a single place, so all the dialogs will use the same animations.</p><p>Let's see the modifications we have to make to <code class="literal">BaseCustomDialog</code> to add animations:</p><div><pre class="programlisting">public void show() {
  if (mIsShowing) {
    return;
  }
  mIsHiding = true;
  [...]
  startShowAnimation();
}

private void startShowAnimation() {
  Animation dialogIn = AnimationUtils.loadAnimation(mParent, R.animator.dialog_in);
  mRootView.startAnimation(dialogIn);
}

public void dismiss() {
  if (!mIsShowing) {
    return;
  }

  if (mIsHiding) {
    return;
  }
  mIsHiding = true;
  startHideAnimation();
}

private void startHideAnimation() {
  Animation dialogOut = AnimationUtils.loadAnimation(mParent, R.animator.dialog_out);
  dialogOut.setAnimationListener(this);
  mRootView.startAnimation(dialogOut);
}

@Override
public void onAnimationEnd(Animation paramAnimation) {
  hideViews();
  mIsShowing = false;
  onDismissed();
}

protected void onDismissed() {
}</pre></div><p>We have a <code class="literal">startShowAnimation</code> method that is called at the end of <code class="literal">show</code>, and a <code class="literal">startHideAnimation</code> method that is called at the end of <code class="literal">dismiss</code>.</p><p>Both methods are quite simple; they load an <code class="literal">Animation</code> using <code class="literal">AnimationUtils</code> and then apply it to <code class="literal">mRootView</code> <a class="indexterm" id="id000490"/>using the <code class="literal">startAnimation</code> method.</p><p>However, there are some details that need comments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are adding views to the content just before starting the animation and removing them when the animation is done, so there is no need to change their visibility. In other cases (when the views remain in the hierarchy after the animation finishes), you may need to update the visibility of the view in the <code class="literal">AnimationListener</code>.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> BaseCustomDialog</code> implements <code class="literal">AnimationListener</code>, and we use it to detect when the hiding animation has finished to remove the views at that moment.</li><li class="listitem" style="list-style-type: disc">We have a new method named <code class="literal">onDismissed</code>. This is called once the animation has ended. Until now, the dismissal of the dialog was an instantaneous operation. This is no longer the case. The actions that were done when dismissing should be moved to <code class="literal">onDismiss</code>.</li><li class="listitem" style="list-style-type: disc">We are using two variables to determine the status of the dialog: <code class="literal">mIsShowing</code> and <code class="literal">mIsHiding</code>. The dialog is considered to be showing from the moment the show animation begins till the dismiss animation is completed. However we should not dismiss a dialog that is already being dismissed, so there is a need for <code class="literal">mIsHiding</code> to prevent this case.</li></ul></div><p>The animations themselves <a class="indexterm" id="id000491"/>are defined in XML, so they are independent of the fact that the dialogs are animated. We are going to see several animations for dialogs to get a deeper understanding of the framework and its possibilities. We will work with pairs of animations that are complementary:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Grow from center / shrink to center</li><li class="listitem" style="list-style-type: disc">Enter from top / exit through top</li></ul></div><p>To make the dialog grow and shrink from and to the center, we just need to use scale.</p><p>The code to grow from the center is like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;set 
  android:interpolator="@android:anim/decelerate_interpolator"
  &gt;
  &lt;scale
    android:fromXScale="0.5"
    android:toXScale="1.0"
    android:fromYScale="0.5"
    android:toYScale="1.0"
    android:pivotX="50%"
    android:pivotY="50%"          
    android:duration="400"
  /&gt;
&lt;/set&gt;</pre></div><p>The definition to shrink to the center is as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;set 
  android:interpolator="@android:anim/accelerate_interpolator"&gt;
  &lt;scale
    android:fromXScale="1.0"
    android:toXScale="0.5"
    android:fromYScale="1.0"
    android:toYScale="0.5"
    android:pivotX="50%"
    android:pivotY="50%"
    android:duration="400"
  /&gt;
&lt;/set&gt;</pre></div><p>As you can see, both animations are similar but the parameters of <code class="literal">from</code> and <code class="literal">to</code> are reversed.</p><p>Note that we start on a scale of 0.5 instead of 0. The animation of a smaller size is not really visible, mostly because of the decelerate interpolator, but you can set it to 0 if you want.</p><p>We also have the pivot point set to 50% on both axes. This is what makes it scale from the center.</p><p>An interesting variant is to apply the scale only on one axis. It feels like the view is unfolded from the middle of the screen. This is left as an exercise for the reader.</p><p>The other pair of animations <a class="indexterm" id="id000492"/>use translation instead of scale. We will make the dialog enter and exit from the top, but it is really easy to change the code to make it use any side of the screen.</p><p>This is the animation's definition to enter from the top:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;set 
  android:interpolator="@android:anim/overshoot_interpolator"&gt;
  &lt;translate
    android:fromYDelta="-100%p"
    android:toYDelta="0%p"
    android:duration="500" /&gt;
&lt;/set&gt;</pre></div><p>This the code to exit through the top:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;set  
    android:interpolator="@android:anim/anticipate_interpolator"&gt;
  &lt;translate
    android:fromYDelta="0%p"
    android:toYDelta="-100%p"
    android:duration="500" /&gt;
&lt;/set&gt;</pre></div><p>Note that the <em>y</em> delta is using the percentage relative to the parent view. The entering animation starts at -100 percent of the size of the parent from the top (one whole screen up). For the exiting animation, we only have to reverse the deltas.</p><p>Finally, there is another important decision to make about these animations, that is which interpolators to use. The most common configurations are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Linear on both: simple, but a bit boring</li><li class="listitem" style="list-style-type: disc">Decelerate to show / accelerate to hide: this feels smoother than the linear, and gives a more professional look</li><li class="listitem" style="list-style-type: disc">Overshoot to show / anticipate to hide: since the view goes over the end position and then goes back, it makes the animation feel more playful</li></ul></div><p>You can use any combination of the animations and interpolators or create your own look and feel. Modify the code and <a class="indexterm" id="id000493"/>try it until you are happy with the result. Just by changing the interpolator the animation feels different.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec00015"/>Delaying the action in the dialogs to onDismissed</h3></div></div></div><p>Because the animations take some time, the actions that were performed on the dialog when the user clicked on a button should be delayed until the animation is finished.</p><p>To do this, we are going to store the id of the view that was clicked, and then check on it in the <code class="literal">onDismissed</code> method to trigger the appropriate action. This is a change we have to make to each dialog.</p><p>Let's start by looking at the changes we have to make to <code class="literal">GameOverDialog</code>:</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  mSelectedId = v.getId();
  dismiss();
}

@Override
protected void onDismissed() {
  if (mSelectedId == R.id.btn_exit) {
    mListener.exitGame();
  }
  else if (mSelectedId == R.id.btn_resume) {
    mListener.startNewGame();
  }
}</pre></div><p>Simple, right? The code is almost the same as before but moved from <code class="literal">onClick</code> to <code class="literal">onDismiss</code>, so it is executed later.</p><p>Next, <code class="literal">PauseDialog</code> is similar:</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  [...]
  else if (v.getId() == R.id.btn_exit) {
    mSelectedId = v.getId();
    super.dismiss();
  }
  else if (v.getId() == R.id.btn_resume) {
    mSelectedId = v.getId();
    super.dismiss();
  }
}

@Override
protected void onDismissed () {
  if (mSelectedId == R.id.btn_exit) {
    mListener.exitGame();
  }
  else if (mSelectedId == R.id.btn_resume) {
    mListener.resumeGame();
  }
}

@Override
public void dismiss() {
  super.dismiss();
  mSelectedId = R.id.btn_resume;
}</pre></div><p>This case is a bit more complex, since there are buttons that still initiate some action (music and sound), but do not dismiss the dialog. We also add a default selected action (resume in this case) to be used when the user dismisses the dialog.</p><p>Note that both actions inside <code class="literal">onClick</code> call the <code class="literal">super.dismiss()</code> method explicitly to avoid being overwritten by the default action.</p><p>Finally, for <code class="literal">QuitDialog</code>, we have the same idea again:</p><div><pre class="programlisting">@Override
public void onClick(View v) {
  mSelectedId = v.getId();
  dismiss();
}

@Override
protected void onDismissed() {
  if (mSelectedId == R.id.btn_exit) {
    mListener.exit();
  }
}</pre></div><p>This is it. The dialogs are <a class="indexterm" id="id000494"/>animated and the actions are performed after the dialog is dismissed.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00092"/>Pulsating buttons</h2></div></div></div><p>Let's add one more <a class="indexterm" id="id000495"/>animation using animated views. We will animate the button to start the game, making it grow and shrink in both axes in a loop, simulating the button pulsating. The idea is that it is a button that "wants to be clicked".</p><p>For this, we are going to use a composite animation. The animation will scale the button on the X and Y axis, but the animations will be different. The X will grow for the complete duration of the animation, while the Y will only do it in the second part. Then we make the animations repeat indefinitely in reverse mode.</p><p>The code for the animation in XML is like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;set 
  android:interpolator="@android:anim/accelerate_decelerate_interpolator"&gt;
  &lt;scale
    android:fromXScale="1.0"
    android:toXScale="1.2"
    android:fromYScale="1.0"
    android:toYScale="1.0"
    android:pivotX="50%"
    android:pivotY="50%"
    android:duration="800"
    android:repeatMode="reverse"
    android:repeatCount="infinite"
  /&gt;
  &lt;scale
    android:fromXScale="1.0"
    android:toXScale="1.0"
    android:fromYScale="1.0"
    android:toYScale="1.1"
    android:pivotX="50%"
    android:pivotY="50%"
    android:startOffset="300"
    android:duration="500"
    android:repeatMode="reverse"
    android:repeatCount="infinite"
  /&gt;
&lt;/set&gt;</pre></div><p>As we mentioned in a previous section, the <code class="literal">repeatCount</code> attribute does not work for the <code class="literal">&lt;set&gt;</code> tag. We could do it in code, but it is simpler to just add it to each of the animations since we only have two. This is why <code class="literal">repeatCount</code> and <code class="literal">repeatMode</code> are set on both <code class="literal">&lt;scale&gt;</code> tags.</p><p>Note that the <code class="literal">infinite</code> keyword is accepted as <code class="literal">repeatCount</code>. We do not need to use awkward constants for it.</p><p>The way repeat interacts with <code class="literal">startOffset</code> is sometimes counter-intuitive. The value of <code class="literal">startOffset</code> will be applied to each iteration. In this particular case, this behavior comes in handy because we <a class="indexterm" id="id000496"/>want the animation on the <em>y</em> axis to start later than the one on <em>x</em> during every iteration. But if we were to make a repeating animation that has a delayed start, it would not work as expected.</p><div><div><h3 class="title"><a id="note00085"/>Note</h3><p>The<code class="literal"> startOffset</code> is part of the animation and it will be included in each repetition.</p></div></div><p>For a repeating animation with a delayed start, the best solution is to use a different method to add an initial delay. Android provides us with <code class="literal">Timer</code>/<code class="literal">TimerTask</code> and the possibility to post a <code class="literal">Runnable</code> with a delay for this.</p><p>Setting the animation to the view is very simple, just a couple lines of code in <code class="literal">MainMenuFragment</code>; one to load the <code class="literal">Animation</code> and one to start it:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  […]
  Animation pulseAnimation = AnimationUtils.loadAnimation(getActivity(), R.animator.button_pulse);
  view.findViewById(R.id.btn_start).startAnimation(pulseAnimation);
}</pre></div><p>Feel free to play with the parameters, even make the two components have different times, so they offset each other. The values we have in the example are chosen to make it very noticeable; you can make it more subtle using a smaller final scale and/or a longer period, which I recommend.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec00056"/>Property animation</h1></div></div></div><p>The second way to <a class="indexterm" id="id000497"/>manage animations in Android was introduced in Android 3.0 (API level 11). It is designed in a very generic way, so it can handle animations on any property of any object. The system is extensible and lets you animate properties of custom types as well.</p><p>There are many ways to use property animations. The simplest one is to use <code class="literal">ValueAnimator</code>. This is as easy as defining an animation that goes from one value to another, has a duration, and optionally an interpolator. Then you add a listener that is invoked each time there is a new value, and finally you start the animation.</p><p>This code will create a <code class="literal">ValueAnimator</code> that animates a float from 0 to 42 along 1,000 milliseconds:</p><div><pre class="programlisting">ValueAnimator animation = ValueAnimator.ofFloat(0f, 42f);
animation.setDuration(1000);
animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
  @Override
  public void onAnimationUpdate(ValueAnimator animation) {
    Float currentValue = (Float) animation.getAnimatedValue();
    // Do something with the value
  }
});
animation.start();</pre></div><p>Value animators do not modify values per se, but you have control over what you want to do with the animated value inside the <code class="literal">onAnimationUpdate</code> method of the listener.</p><p>We are not going to use any <code class="literal">ValueAnimator</code> in YASS, but they can be really useful for other types of games. We can use them whenever we want a smooth transition of a variable from one value to the next. Some cases where value animators are interesting for games are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding bonus scores after finishing a level</li><li class="listitem" style="list-style-type: disc">Adding XP points after finishing a quest / defeating an opponent</li><li class="listitem" style="list-style-type: disc">Decreasing HP points after a hit / increasing after a recovery potion</li></ul></div><p>In general, value animators can be used any time we have a value that we want to animate smoothly. You can even use a custom progress bar to display the value and just update it on the callback of the <code class="literal">ValueAnimator</code>.</p><p>You can use a <code class="literal">PropertyAnimator</code> instead of a <code class="literal">ValueAnimator</code> if you want Android to modify the value of the property in the object directly. For this particular case of views, we have a special class called <code class="literal">ViewPropertyAnimator</code> that is easier to use and read than <code class="literal">PropertyAnimator</code> and is designed specially to animate views.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00093"/>ViewPropertyAnimator</h2></div></div></div><p>This animation technique <a class="indexterm" id="id000498"/>provides a simple way to animate several properties of a view in parallel using a single underlying <code class="literal">Animator</code> object. It also modifies the actual values of the view's properties.</p><p>One drawback of <a class="indexterm" id="id000499"/>using <code class="literal">ViewPropertyAnimator</code> is that it is more limited. We can only animate the basic attributes of the view (position, scale, alpha, and rotation), while with <code class="literal">PropertyAnimation</code> we can animate virtually anything.</p><p>It is worth mentioning in advance that this animation technique only requires final values for an animation. It is meant to start the animation from the current values of the view. This means that sometimes, you may need to initialize the view to an initial position.</p><p>Because this type of animation works as a modification of the values of the view, animated views stay in their final state once the animation is completed. This makes them very useful for puzzle-like or board games.</p><div><div><h3 class="title"><a id="note00086"/>Note</h3><p>Views animated with <code class="literal">ViewPropertyAnimator</code> stay at the end position after the animation has ended.</p></div></div><p><code class="literal">ViewPropertyAnimator</code> uses two concepts to obtain the coordinates where the view is drawn: position and translation. You can animate the position or you can animate the translation. If you are going to use only one of them, it does not make much of a difference. Just remember that <code class="literal">translateX</code> will have the origin (also known as [0,0]) at the current position of the view and that a view will be drawn at the vectorial sum of its position and translation.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec00016"/>Moving a spaceship around</h3></div></div></div><p>To see the power <a class="indexterm" id="id000500"/>of <code class="literal">ViewPropertyAnimator</code>, we are going to add another animation to the main menu. We are going to take the spaceship we used to display the frame-by-frame animation and then make it move around the screen randomly.</p><p>I believe this animation is too much and makes the main menu feel too crowded, so I recommend removing it in the final game, but it is nevertheless a great example of how the framework works.</p><p>Because each animation starts from the previous position of the view, the resulting effect is something you cannot achieve with the old framework.</p><p>Let's look at the code:</p><div><pre class="programlisting">@Override
protected void onLayoutCompleted() {
  [...]
  animateShip();
}

private void animateShip() {
  View iv = getView().findViewById(R.id.ship_animated);
  // Get a random position on the screen
  Random r = new Random();
  int targetX = r.nextInt(getView().getWidth());
  int targetY = r.nextInt(getView().getHeight());
  // Animate
  iv.animate()
    .x(targetX)
    .y(targetY)
    .setDuration(500)
    .setInterpolator(new AccelerateDecelerateInterpolator())
    .setListener(new Animator.AnimatorListener() {
      @Override
      public void onAnimationEnd(Animator animation) {
        animateShip();
      }

      @Override
      public void onAnimationStart(Animator animation) {}

      @Override
      public void onAnimationCancel(Animator animation) {}

      @Override
      public void onAnimationRepeat(Animator animation) {}
    });
}</pre></div><p>We are invoking <code class="literal">animateShip</code> once the layout is completed and then we will do it again each time the animation is completed.</p><p>To animate the ship, we get the view we want to animate and then select a random position on the screen using <code class="literal">Random</code> and the dimensions of the root view of the fragment.</p><p>We call <code class="literal">animate</code> on <a class="indexterm" id="id000501"/>the view. This returns an object of <a class="indexterm" id="id000502"/>
<code class="literal">ViewPropertyAnimator</code> type. We can configure the animation using different methods on this object and each of them will return the object again, so they can be chained in a very easy to read code.</p><p>We are configuring the animation by setting the target <em>x</em> and <em>y</em> positions (we are not touching the translation at all), selecting the duration, and setting an interpolator of <code class="literal">AccelerateDecelerateInterpolator </code>type. We are also setting a listener, so we are notified when the animation ends and we can call <code class="literal">animateShip</code> to create another one. Note that <code class="literal">AnimationListener</code> is an interface and we must implement all its methods even if we don't use them.</p><p>Finally, we could call <code class="literal">start</code> to make the animation start immediately, but it is not necessary.</p><p>We are always using the same animation duration, so sometimes the ship will move much faster than others. We could make it have a constant speed by using the distance between the origin and the destination points to calculate the duration of the animation.</p><p>It is important to check <a class="indexterm" id="id000503"/>at which position in the layout the <a class="indexterm" id="id000504"/>
<code class="literal">ImageView</code> was added, since the z-index is provided by the order. I recommend you place the ship straight after the background image, so it goes behind the titles and buttons.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec00094"/>Animating the main menu</h2></div></div></div><p>To complete the <a class="indexterm" id="id000505"/>chapter, we are going to animate the game title and subtitle. To give a comparison of the different possibilities Android offers to make animations, we will create each of them in three different ways: view animation in XML, <code class="literal">ViewPropertyAnimation</code> in code, and object animator in XML.</p><p>First, we will animate the main title to make it enter from the left of the screen to its normal position at the center. We will use a bounce interpolator to make it look fun.</p><p>As good practice, we will externalize the start offset and the duration of the animation as integers using a file named <code class="literal">integers.xml</code> under the <code class="literal">res/values </code>folder:</p><div><pre class="programlisting">&lt;integer name="tittle_start_offset"&gt;400&lt;/integer&gt;
&lt;integer name="tittle_duration"&gt;1600&lt;/integer&gt;</pre></div><p>The animation will not start straight away to give the player some time to actually notice the screen. We have a long duration, because the bounce interpolator does not look good otherwise.</p><p>The first version using view animation in XML is defined like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;set 
  android:interpolator="@android:anim/bounce_interpolator"&gt;
  &lt;translate
    android:startOffset="@integer/tittle_start_offset"
    android:fromXDelta="-100%p"
    android:toXDelta="0%p"
    android:repeatCount="0"
    android:duration="@integer/tittle_duration" /&gt;
&lt;/set&gt;</pre></div><p>We use percentage related to the parent view as the original delta to put the view completely out of the screen. The -100%p means 100 percent of the parent width to the left.</p><p>The code to load the animation and start it is to be placed inside <code class="literal">onLayoutCompleted</code> and it is very simple:</p><div><pre class="programlisting">Animation titleAnimation = AnimationUtils.loadAnimation(getActivity(), R.animator.title_enter);
title.startAnimation(titleAnimation);</pre></div><p>Note that the animation is considered to be started as soon as we call <code class="literal">startAnimation</code>. This means that the <a class="indexterm" id="id000506"/>translation is also animated during the start offset and is set to the initial value of the animation.</p><div><div><h3 class="title"><a id="note00087"/>Note</h3><p>The start offset is considered a part of the animation for view animators and the value is set to the initial one while the animation is waiting to start.</p></div></div><p>Let's compare this definition with the one for <code class="literal">ViewPropertyAnimator</code> in code:</p><div><pre class="programlisting">View title = getView().findViewById(R.id.main_title);
title.setTranslationX(-getView().getWidth());

int duration = getResources().getInteger(R.integer.tittle_duration);
int startOffset = getResources().getInteger(R.integer.subtitle_start_offset);

title.animate()
  .translationX(0)
  .setStartDelay(startOffset)
  .setDuration(duration)
  .setInterpolator(new BounceInterpolator())
  .start();</pre></div><p>Because the duration and offset are defined as integers, we need to obtain them before running the animation.</p><p>Since the view is initially placed at the location we want it to finish, we are going to animate the translation and keep the position as it is.</p><p>Note that since <code class="literal">ViewPropertyAnimator</code> only receives the final value as a parameter, we need to set it to a default initial position outside the screen. To do this, we use the <code class="literal">setTranslationX</code> method of the view. By doing this, the final value of the translation is 0.</p><p>Finally, we set the interpolator and call <code class="literal">start</code>. The result is the same as with the previous method but, as you have seen, there are a few significant differences in the procedure.</p><p>The third approach is to define this same animation as an object animator in XML and then load and use it in code. The XML definition is as follows:</p><div><pre class="programlisting">&lt;set 
  android:interpolator="@android:anim/bounce_interpolator"&gt;
  &lt;objectAnimator
    android:interpolator="@android:anim/bounce_interpolator"
    android:propertyName="translationX"
    android:valueTo="0"
    android:startOffset="@integer/tittle_start_offset"
    android:duration="@integer/tittle_duration" /&gt;
&lt;/set&gt;</pre></div><p>The <code class="literal">&lt;objectAnimator&gt;</code> tag is generic in itself and uses <code class="literal">propertyName</code> as the name of the property to <a class="indexterm" id="id000507"/>modify using reflection.</p><p>Once the animation is defined, we have to load and start it:</p><div><pre class="programlisting">title.setTranslationX(-title.getX()-title.getWidth());

AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(getActivity(), R.animator.title_enter_property);
set.setTarget(title);
set.start();</pre></div><p>As happened in the previous example, we need to make an initialization of the translation. Although we could set a <code class="literal">valueFrom</code> in XML, we do not know the size of the screen when we define XML and we cannot use the values referenced to the parent view, so we have to initialize it in code.</p><p>All in all, the three versions perform the same animation conceptually, but the way they are defined is slightly different.</p><p>Let's see another example. For the subtitle, we are going to animate the alpha to make it appear after the animation of the title is finished. To make this animation run after the previous one, we can use start delay or we can set a listener to the previous animation and start it when this animation finishes.</p><p>Using a listener is more precise, but adding delay is way simpler so we will go for this. As we did for the title animation, we will define some integers for the duration and the start offset, which in this case is the sum of the duration and the start offset of the title animation:</p><div><pre class="programlisting">&lt;integer name="subtitle_start_offset"&gt;2000&lt;/integer&gt;
&lt;integer name="subtitle_duration"&gt;600&lt;/integer&gt;</pre></div><p>The XML for doing it using view animation is like this:</p><div><pre class="programlisting">&lt;set &gt;
  &lt;alpha android:fromAlpha="0.0"
    android:toAlpha="1.0"
    android:startOffset="@integer/subtitle_start_offset"
    android:duration="@integer/subtitle_duration"/&gt;
&lt;/set&gt;</pre></div><p>The code to run it is also very similar to what we just saw for the title:</p><div><pre class="programlisting">Animation subtitleAnimation = AnimationUtils.loadAnimation(context, R.animator.subtitle_enter);
subtitle.startAnimation(subtitleAnimation);</pre></div><p>Again, the fact that <code class="literal">startOffset</code> is considered a part of the animation is very convenient, because it allows us to set the alpha to 0 for the first 2,000 milliseconds without touching the view.</p><p>Let's compare it <a class="indexterm" id="id000508"/>with <code class="literal">ViewPropertyAnimation</code>:</p><div><pre class="programlisting">View subtitle = getView().findViewById(R.id.main_subtitle);
subtitle.setAlpha(0);

int subtitleDuration = getResources().getInteger(R.integer.subtitle_duration);
int subtitleStartOffset = getResources().getInteger(R.integer.subtitle_start_offset);

subtitle.animate()
  .alpha(1)
  .setDuration(subtitleDuration)
  .setStartDelay(subtitleStartOffset)
  .setInterpolator(new DecelerateInterpolator())
  .start();</pre></div><p>Also, very similarly to the previous one, we need to initialize the value of alpha in the view. We also need to load the integer values to use them in the configuration.</p><p>Lastly, the same animation is defined as a <code class="literal">PropertyAnimation</code> in XML:</p><div><pre class="programlisting">&lt;set &gt;
&lt;objectAnimator
  android:interpolator="@android:anim/decelerate_interpolator"
  android:propertyName="alpha" 
  android:valueFrom="0"
  android:valueTo="1"
  android:startOffset="@integer/subtitle_start_offset"
  android:duration="@integer/subtitle_duration" /&gt;
&lt;/set&gt;</pre></div><p>Then, it is loaded and assigned to the subtitle view:</p><div><pre class="programlisting">subtitle.setAlpha(0);
AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(context, R.animator.fade_in_property);
set.setTarget(subtitle);
set.start();</pre></div><p>In this case, we also need to preset the alpha to 0, because the start offset is not considered a part of the animation for <code class="literal">PropertyAnimator</code>. If we do not set it, it will stay set to 1 until the animation starts running.</p><p>In general, there is no <a class="indexterm" id="id000509"/>silver bullet and each type of animation is better for different cases. While using simple visual effects to make a game look nicer, view animators are usually enough and also easier to set up. If the view is going to be interactive and you use animation to translate the elements of the game, then <code class="literal">PropertyAnimation</code> (or any of its variants) is the only way to go.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec00057"/>Summary</h1></div></div></div><p>We have learned how to do frame-by-frame animations and how to animate views using the two different frameworks that Android provides, view animation and <code class="literal">PropertyAnimation</code>.</p><p>We have studied the differences between and limitations of each of them and learned when to use one or the other.</p><p>We have animated the dialogs and also the main menu. For the titles, we have seen how we could achieve the same result with different approaches.</p><p>All in all, the game looks much smoother since a lot of the content is animated now.</p><p>We could say that the game is finished, but we will add some more features to make it more interesting. Google provides us with an API to manage achievements and leaderboards. Both features are a part of Google Play services and this is what we will do next!</p></div>
<div><div><div><div><h1 class="title"><a id="ch29"/>Chapter 9. Integrating Google Play Services</h1></div></div></div><p>Google provides Google Play Services as a way to use special features in apps. Being the game services subset the one that interests us the most. Note that Google Play Services are updated as an app that is independent from the operating system. This allows us to assume that most of the players will have the latest version of Google Play Services installed.</p><p>More and more features are being moved from the Android SDK to the Play Services because of this.</p><p>Play Services offer much more than just services for games, but there is a whole section dedicated exclusively to games, <strong>Google Play Game Services</strong> (<strong>GPGS</strong>). These features include achievements, leaderboards, quests, save games, gifts, and even multiplayer support.</p><p>GPGS also comes with a <a class="indexterm" id="id000510"/>standalone app called "Play Games" that shows the user the games he or she has been playing, the latest achievements, and the games his or her friends play. It is a very interesting way to get exposure for your game.</p><p>Even as a standalone feature, achievements and leaderboards are two concepts that most games use nowadays, so why make your own custom ones when you can rely on the ones made by Google?</p><p>GPGS can be used on many platforms: Android, iOS and web among others. It is more used on Android, since it is included as a part of Google apps.</p><p>There is extensive step-by-step documentation online, but the details are scattered over different places. We will put them together here and link you to the official documentation for more detailed information.</p><p>For this chapter, you are supposed to have a developer account and have access to the Google Play Developer Console. It is also advisable for you to know the process of signing and releasing an app. If you are not familiar with it, there is very detailed official <a class="indexterm" id="id000511"/>documentation at <a class="ulink" href="http://developer.android.com/distribute/googleplay/start.html">http://developer.android.com/distribute/googleplay/start.html</a>.</p><p>There are two sides of GPGS: the developer console and the code. We will alternate from one to the other while talking about the different features.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec00058"/>Setting up the developer console</h1></div></div></div><p>Now that we are <a class="indexterm" id="id000512"/>approaching the release state, we have to start working with the developer console.</p><p>The first thing we need to do is to get into the <strong>Game services</strong> section of the console to create and configure a new game. In the left menu, we have an option labeled <strong>Game services</strong>. This is where you have to click. Once in the <strong>Game services</strong> section, click on <strong>Add new game</strong>:</p><div><img alt="Setting up the developer console" src="img/B04757_09_01.jpg"/></div><p>This bring us to the set up <a class="indexterm" id="id000513"/>dialog. If you are using other Google services like <strong>Google Maps</strong> or <strong>Google Cloud Messaging</strong> (<strong>GCM</strong>) in your game, you should select the second option and move forward. Otherwise, you can just fill in the fields for <strong>I don't use any Google APIs on my game yet</strong> and continue. If you don't know whether you are already using them, you probably aren't.</p><div><img alt="Setting up the developer console" src="img/B04757_09_02.jpg"/></div><p>Now, it is time to link a game to it. I recommend you publish your game beforehand as an alpha release. This <a class="indexterm" id="id000514"/>will let you select it from the list when you start typing the package name.</p><div><div><h3 class="title"><a id="note00088"/>Note</h3><p>Publishing the game to the alpha channel before adding it to Game services makes it much easier to configure.</p></div></div><p>If you are not familiar <a class="indexterm" id="id000515"/>with signing and releasing your app, check out the official documentation at <a class="ulink" href="http://developer.android.com/tools/publishing/app-signing.html">http://developer.android.com/tools/publishing/app-signing.html</a>.</p><p>Finally, there are only two steps that we have to take when we link the first app. We need to authorize it and provide branding information. The authorization will generate an OAuth key—that we don't need to use since it is required for other platforms—and also a game ID. This ID is unique to all the linked apps and we will need it to log in. But there is no need to write it down now, it can be found easily in the console at anytime.</p><div><div><h3 class="title"><a id="note00089"/>Note</h3><p>Authorizing the app will generate the game ID, which is unique to all linked apps.</p></div></div><p>Note that the app we have <a class="indexterm" id="id000516"/>added is configured with the release key. If you continue and try the login integration, you will get an error telling you that the app was signed with the wrong certificate:</p><div><img alt="Setting up the developer console" src="img/B04757_09_03.jpg"/></div><p>You have two ways to work with this limitation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Always make a release build to test GPGS integration</li><li class="listitem" style="list-style-type: disc">Add your debug-signed game as a linked app</li></ul></div><p>I recommend that you add the debug signed app as a linked app. To do this, we just need to link another app and configure it with the SHA1 fingerprint of the debug key. To obtain it, we have to open a terminal and run the keytool utility:</p><div><pre class="programlisting">keytool -exportcert -alias androiddebugkey -keystore &lt;path-to-debug-keystore&gt; -list -v</pre></div><p>Note that in Windows, the debug <code class="literal">keystore</code> can be found at <code class="literal">C:\Users\&lt;USERNAME&gt;\.android\debug.keystore</code>. On Mac and Linux, the debug <code class="literal">keystore</code> is typically <a class="indexterm" id="id000517"/>located at <code class="literal">~/.android/debug.keystore</code>.</p><div><img alt="Setting up the developer console" src="img/B04757_09_04.jpg"/><div><p>Dialog to link the debug application on the Game Services console</p></div></div><p>Now, we have the game configured. We could continue creating achievements and leaderboards in the console, but we will put it aside and make sure that we can sign in and connect with GPGS.</p><p>The only users who can sign in to GPGS while a game is not published are the testers. You can make the alpha and/or beta testers of a linked app become testers of the game services, and you can also add e-mail addresses by hand for this. You can modify this in the Testing tab.</p><div><div><h3 class="title"><a id="note00090"/>Note</h3><p>Only test accounts can access a game that is not published.</p></div></div><p>The e-mail of the owner of the developer console is prefilled as a tester. Just in case you have problems logging in, double-check the list of testers.</p><p>A game service that is not published will not appear in the feed of the Play Services app, but it will be possible to test and modify it. This is why it is a good idea to keep it in draft mode until the game itself is <a class="indexterm" id="id000518"/>ready and publish both the game and the game services at the same time.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00059"/>Setting up the code</h1></div></div></div><p>The first thing we need to do is to <a class="indexterm" id="id000519"/>add the Google Play Services library to our project. This should already have been done by the wizard when we created the project, but I recommend you to double-check it now.</p><p>The library needs to be added to the <code class="literal">build.gradle</code> file of the main module. Note that Android Studio projects contain a top-level <code class="literal">build.gradle</code> and a module-level <code class="literal">build.gradle</code> for each module. We will modify the one that is under the <code class="literal">mobile</code> module.</p><p>Make sure that the play services' library is listed under dependencies:</p><div><pre class="programlisting">apply plugin: 'com.android.application'


dependencies {
  compile 'com.android.support:appcompat-v7:22.1.1'
  <strong>compile 'com.google.android.gms:play-services:7.3.0'</strong>
}</pre></div><p>At the point of writing, the latest version is 7.3.0. The basic features have not changed much and they are unlikely to change. You could force Gradle to use a specific version of the library, but in general I recommend you use the latest version.</p><p>Once you have it, save the changes and click on <strong>Sync Project with Gradle Files</strong>.</p><p>To be able to connect with GPGS, we need to let the game know what the game ID is. This is done through the <code class="literal">&lt;meta-data&gt;</code> tag on <code class="literal">AndroidManifest.xml</code>. You could hardcode the value here, but it is highly recommended that you set it as a resource in your Android project.</p><p>We are going to create a new file for this under <code class="literal">res/values</code>, which we will name <code class="literal">play_services.xml</code>. In this file we will put the game ID, but later we will also have the achievements and leaderboard IDs in it. Using a separate file for these values is recommended because they are constants that do not need to be translated:</p><div><pre class="programlisting">&lt;application&gt;
  &lt;meta-data android:name="com.google.android.gms.games.APP_ID" android:value="@string/app_id" /&gt;
  &lt;meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version"/&gt;
  [...]
&lt;/application&gt;</pre></div><p>Adding this metadata is extremely important. If you forget to update the <code class="literal">AndroidManifest.xml</code>, the app will crash when you try to sign in to Google Play services. Note that the integer for the gms version is defined in the library and we do not need to add it to our file.</p><div><div><h3 class="title"><a id="note00091"/>Note</h3><p>If you forget to add the game ID to the strings the app will crash.</p></div></div><p>Now, it is time to proceed to sign in. The process is quite tedious and requires many checks, so Google has released <a class="indexterm" id="id000520"/>an open source project named BaseGameUtils, which makes it easier. Unfortunately this project is not a part of the play services' library and it is not even available as a library. So, we have to get it from GitHub (either check it out or download the source as a ZIP file).</p><div><div><h3 class="title"><a id="note00092"/>Note</h3><p>BaseGameUtils abstracts us from the complexity of handling the connection with Play Services.</p></div></div><p>Even more cumbersome, BaseGameUtils is not available as a standalone download and has to be downloaded together with another project. The fact that this significant piece of code is not a part of the official library makes it quite tedious to set up. Why it has been done like this is something that I do not comprehend myself.</p><p>The project that contains <a class="indexterm" id="id000521"/>BaseGameUtils is called <code class="literal">android-basic-samples</code> and it can be downloaded from <a class="ulink" href="https://github.com/playgameservices/android-basic-samples">https://github.com/playgameservices/android-basic-samples</a>.</p><div><div><h3 class="title"><a id="note00093"/>Note</h3><p>Adding BaseGameUtils is not as straightforward as we would like it to be.</p></div></div><p>Once <code class="literal">android-basic-samples</code> is downloaded, open your game project in Android Studio. Click on <strong>File</strong> &gt; <strong>Import Module</strong> and navigate to the directory where you downloaded <code class="literal">android-basic-samples</code>. Select the <code class="literal">BaseGameUtils</code> module in the <code class="literal">BasicSamples/libraries</code> directory and click on <strong>OK</strong>.</p><p>Finally, update the dependencies in the <code class="literal">build.gradle</code> file for the <code class="literal">mobile</code> module and sync gradle again:</p><div><pre class="programlisting">dependencies {
  compile project(':BaseGameUtils')
  [...]
}</pre></div><p>After all these steps to set up the project, we are finally ready to begin the sign in.</p><p>We will make our main <code class="literal">Activity</code> extend from <code class="literal">BaseGamesActivity</code>, which takes care of all the handling of the connections, and sign in with Google Play Services.</p><p>One more detail: until now, we were using <code class="literal">Activity</code> and not <code class="literal">FragmentActivity</code> as the base class for <code class="literal">YassActivity</code> (<code class="literal">BaseGameActivity</code> extends from <code class="literal">FragmentActivity</code>) and this change will mess with the behavior of our dialogs while calling <code class="literal">navigateBack</code>. We can change the base class of <code class="literal">BaseGameActivity</code> or modify <code class="literal">navigateBack</code> to perform a pop-on fragment navigation hierarchy. I recommend the second approach:</p><div><pre class="programlisting">public void navigateBack() {
  // Do a pop on the navigation history
  getFragmentManager().popBackStack();
}</pre></div><p>This util class has been designed to work with single-activity games. It can be used in multiple activities, but it is not straightforward. This is another good reason to keep the game in a single activity.</p><div><div><h3 class="title"><a id="note00094"/>Note</h3><p>The BaseGameUtils is designed to be used in single-activity games.</p></div></div><p>The default behavior of <code class="literal">BaseGameActivity</code> is to try to log in each time the <code class="literal">Activity</code> is started. If the user agrees to sign in, the sign in will happen automatically. But if the user rejects doing so, he or she will be asked again several times.</p><p>I personally find this intrusive and annoying, and I recommend you to only prompt to log in to Google Play services once (and again, if the user logs out). We can always provide a login entry point in the app.</p><p>This is very easy to change. The default number of attempts is set to 3 and it is a part of the code of <code class="literal">GameHelper</code>:</p><div><pre class="programlisting">// Should we start the flow to sign the user in automatically on startup? If
// so, up to
// how many times in the life of the application?
static final int DEFAULT_MAX_SIGN_IN_ATTEMPTS = 3;
int mMaxAutoSignInAttempts = DEFAULT_MAX_SIGN_IN_ATTEMPTS;</pre></div><p>So, we just have to configure it for our activity, adding one line of code during <code class="literal">onCreate</code> to change the default behavior with the one we want: just try it once:</p><div><pre class="programlisting">getGameHelper().setMaxAutoSignInAttempts(1);</pre></div><p>Finally, there are two methods that we can override to act when the user successfully logs in and when there is a problem: <code class="literal">onSignInSucceeded</code> and <code class="literal">onSignInFailed</code>. We will use them when we update the main menu at the end of the chapter.</p><p>Further use of GPGS is to be made via the <code class="literal">GameHelper</code> and/or the <code class="literal">GoogleApiClient</code>, which is a part of the <code class="literal">GameHelper</code>. We can obtain a reference to the <code class="literal">GameHelper</code> using the <code class="literal">getGameHelper</code> method of <code class="literal">BaseGameActivity</code>.</p><p>Now that the user can sign into Google Play services we can continue with achievements and leaderboards. Let's go back <a class="indexterm" id="id000522"/>to the developer console.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00060"/>Achievements</h1></div></div></div><p>We will first define a few <a class="indexterm" id="id000523"/>achievements in the developer console and then see how to unlock them in the game. Note that to publish any game with GPGS, you need to define at least five achievements. No other feature is mandatory, but achievements are.</p><div><div><h3 class="title"><a id="note00095"/>Note</h3><p>We need to define at least five achievements to publish a game with Google Play Game services.</p></div></div><p>If you want to use GPGS with a game that has no achievements, I recommend you to add five dummy secret achievements and let them be.</p><p>To add an achievement, we just need to navigate to the <strong>Achievements</strong> tab on the left and click on <strong>Add achievement</strong>:</p><div><img alt="Achievements" src="img/B04757_09_05.jpg"/></div><p>The menu to add a new achievement has a few fields that are mostly self-explanatory. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: the name that will be shown (can be localized to different languages).</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: the description of the achievement to be shown (can also be localized to different languages).</li><li class="listitem" style="list-style-type: disc"><strong>Icon</strong>: the icon of the achievement as a 512x512 px PNG image. This will be used to show the <a class="indexterm" id="id000524"/>achievement in the list and also to generate the locked image and the in-game popup when it is unlocked.</li><li class="listitem" style="list-style-type: disc"><strong>Incremental achievements</strong>: if the achievement requires a set of steps to be completed, it is called an incremental achievement and can be shown with a progress bar. We will have an incremental achievement to illustrate this.</li><li class="listitem" style="list-style-type: disc"><strong>Initial state</strong>: <strong>Revealed</strong>/<strong>Hidden</strong> depending on whether we want the achievement to be shown or not. When an achievement is shown, the name and description are visible, players know what they have to do to unlock it. A hidden achievement, on the other hand, is a secret and can be a funny surprise when unlocked. We will have two secret achievements.</li><li class="listitem" style="list-style-type: disc"><strong>Points</strong>: GPGS allows each game to have 1,000 points to give for unlocking achievements. This gets converted to XP in the player profile on Google Play games. This can be used to highlight that some achievements are harder than others, and therefore grant a bigger reward. You cannot change these once they are published, so if you plan to have more achievements in the future, plan ahead with the points.</li><li class="listitem" style="list-style-type: disc"><strong>List order</strong>: The order of the achievements is shown. It is not followed all the time, since on the Play Games app the unlocked ones are shown before the locked ones. It is still <a class="indexterm" id="id000525"/>handy to rearrange them.<div><img alt="Achievements" src="img/B04757_09_06.jpg"/><div><p>Dialog to add an achievement on the developer console</p></div></div></li></ul></div><p>As we already decided, we will have five achievements in our game and they will be as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Big Score</strong>: score over 100,000 points in one game. This is to be granted while playing.</li><li class="listitem" style="list-style-type: disc"><strong>Asteroid killer</strong>: destroy 100 asteroids. This will count them across different games and is an incremental achievement.</li><li class="listitem" style="list-style-type: disc"><strong>Survivor</strong>: survive for 60 seconds.</li><li class="listitem" style="list-style-type: disc"><strong>Target acquired</strong>: a hidden achievement. Hit 20 asteroids in a row without missing a hit. This is meant to reward players that only shoot when they should.</li><li class="listitem" style="list-style-type: disc"><strong>Target lost</strong>: this is supposed to be a funny achievement, granted when you miss with 10 bullets in a <a class="indexterm" id="id000526"/>row. It is also hidden, because otherwise it would be too easy to unlock.</li></ul></div><p>So, we created some images for them and added them to the console.</p><div><img alt="Achievements" src="img/B04757_09_07.jpg"/><div><p>The developer console with all the configured achievements</p></div></div><p>Each achievement has a string ID. We will need these ids to unlock the achievements in our game, but Google has made it easy for us. We have a link at the bottom named <strong>Get resources</strong> that pops up a dialog with the string resources we need. We can just copy them from there and paste them in our project in the <code class="literal">play_services.xml</code> file we have already created.</p><div><img alt="Achievements" src="img/B04757_09_08.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec00095"/>Architecture</h2></div></div></div><p>For our game, given <a class="indexterm" id="id000527"/>that we only have five achievements, we are going to add the code for achievements directly into the <code class="literal">ScoreObject</code>. This will make it less code for you to read so we can focus on how it is done. However, for a real production code I recommend you define a dedicated architecture for achievements.</p><p>The recommended architecture is to have an <code class="literal">AchievementsManager</code> class that loads all the achievements when the game starts and stores them in three lists:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All achievements</li><li class="listitem" style="list-style-type: disc">Locked achievements</li><li class="listitem" style="list-style-type: disc">Unlocked achievements</li></ul></div><p>Then, we have an <code class="literal">Achievement</code> base class with an abstract <code class="literal">check</code> method that we implement for each one of them:</p><div><pre class="programlisting">public boolean check (GameEngine gameEngine, GameEvent gameEvent) 
{
}</pre></div><p>This base class takes care of loading the achievement state from local storage (I recommend using <code class="literal">SharedPreferences</code> for this) and modify it as per the result of <code class="literal">check</code>.</p><p>The achievements check is done at <code class="literal">AchievementManager</code> level using a <code class="literal">checkLockedAchievements</code> method that iterates over the list of achievements that can be unlocked. This method should be called as a part of <code class="literal">onEventReceived</code> of <code class="literal">GameEngine</code>.</p><p>This architecture allows you <a class="indexterm" id="id000528"/>to check only the achievements that are yet to be unlocked and also all the achievements included in the game in a specific dedicated place.</p><p>In our case, since we are keeping the score inside the <code class="literal">ScoreGameObject</code>, we are going to add all achievements code there.</p><p>Note that making the <code class="literal">GameEngine</code> take care of the score and having it as a variable that other objects can read are also recommended design patterns, but it was simpler to do this as a part of <code class="literal">ScoreGameObject</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec00096"/>Unlocking achievements</h2></div></div></div><p>To handle <a class="indexterm" id="id000529"/>achievements, we need to have access to an object of the class <code class="literal">GoogleApiClient</code>. We can get a reference to it in the constructor of <code class="literal">ScoreGameObject</code>:</p><div><pre class="programlisting">private final GoogleApiClient mApiClient;

public ScoreGameObject(YassBaseFragment parent, View view, int viewResId) {
  […]
  mApiClient = parent.getYassActivity().getGameHelper().getApiClient();
}</pre></div><p>The parent <code class="literal">Fragment</code> has a reference to the <code class="literal">Activity</code>, which has a reference to the <code class="literal">GameHelper</code>, which has a reference to the <code class="literal">GoogleApiClient</code>.</p><p>Unlocking an achievement requires just a single line of code, but we also need to check whether the user is connected to Google Play services or not before trying to unlock an achievement. This is necessary because if the user has not signed it, an exception is thrown and the game crashes.</p><div><div><h3 class="title"><a id="note00096"/>Note</h3><p>Unlocking an achievement requires just a single line of code.</p></div></div><p>But this check is not <a class="indexterm" id="id000530"/>enough. In the edge case, when the user logs out manually from Google Play services (which can be done in the achievements screen), the connection will not be closed and there is no way to know whether he or she has logged out.</p><p>We are going to create a utility method to unlock the achievements that does all the checks and also wraps the unlock method into a <code class="literal">try/catch</code> block and make the API client disconnect if an exception is raised:</p><div><pre class="programlisting">private void unlockSafe(int resId) {
  if (mApiClient.isConnecting() || mApiClient.isConnected()) {
    try {
      Games.Achievements.unlock(mApiClient, getString(resId));
    } catch (Exception e) {
      mApiClient.disconnect();
    }
  }
}</pre></div><p>Even with all the checks, the code is still very simple.</p><p>Let's work on the particular achievements we have defined for the game. Even though they are very specific, the methodology to track game events and variables and then check for achievements to unlock is in itself generic, and serves as a real-life example of how to deal with achievements.</p><p>The achievements we have designed require us to count some game events and also the running time. For the last two achievements, we need to make a new <code class="literal">GameEvent</code> for the case when a bullet misses, which we have not created until now. The code in the <code class="literal">Bullet</code> object to trigger this new <code class="literal">GameEvent</code> is as follows:</p><div><pre class="programlisting">@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  mY += mSpeedFactor * elapsedMillis;
  if (mY &lt; -mHeight) {
    removeFromGameEngine(gameEngine);
    gameEngine.onGameEvent(GameEvent.BulletMissed);
  }
}</pre></div><p>Now, let's work inside <code class="literal">ScoreGameObject</code>. We are going to have a method that checks achievements each time an asteroid is hit. There are three achievements that can be unlocked when that event happens:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Big score</strong>, because hitting an asteroid gives us points</li><li class="listitem" style="list-style-type: disc"><strong>Target acquired</strong>, because it requires consecutive asteroid hits</li><li class="listitem" style="list-style-type: disc"><strong>Asteroid killer</strong>, because it counts the total number of asteroids that have been destroyed</li></ul></div><p>The code is like <a class="indexterm" id="id000531"/>this:</p><div><pre class="programlisting">private void checkAsteroidHitRelatedAchievements() {
  if (mPoints &gt; 100000) {
    // Unlock achievement
    unlockSafe(R.string.achievement_big_score);
  }
  if (mConsecutiveHits &gt;= 20) {
    unlockSafe(R.string.achievement_target_acquired);
  }
  // Increment achievement of asteroids hit
  if (mApiClient.isConnecting() || mApiClient.isConnected()) {
    try {
      Games.Achievements.increment(mApiClient, getString(R.string.achievement_asteroid_killer), 1);
    } catch (Exception e) {
      mApiClient.disconnect();
    }
  }
}</pre></div><p>We check the total points and the number of consecutive hits to unlock the corresponding achievements.</p><p>The "Asteroid killer" achievement is a bit of a different case, because it is an incremental achievement. These type of achievements do not have an <code class="literal">unlock</code> method, but rather an <code class="literal">increment</code> method. Each time we increment the value, progress on the achievement is updated. Once the progress is 100 percent, it is unlocked automatically.</p><div><div><h3 class="title"><a id="note00097"/>Note</h3><p>Incremental achievements are automatically unlocked, we just have to increment their value.</p></div></div><p>This makes incremental achievements much easier to use than tracking the progress locally. But we still need to do all the checks as we did for <code class="literal">unlockSafe</code>.</p><p>We are using a variable named <code class="literal">mConsecutiveHits</code>, which we have not initialized yet. This is done inside <code class="literal">onGameEvent</code>, which is the place where the other hidden achievement target lost is checked. Some initialization for the "Survivor" achievement is also done here:</p><div><pre class="programlisting">public void onGameEvent(GameEvent gameEvent) {
  if (gameEvent == GameEvent.AsteroidHit) {
    mPoints += POINTS_GAINED_PER_ASTEROID_HIT;
    mPointsHaveChanged = true;
    mConsecutiveMisses = 0;
    mConsecutiveHits++;
    checkAsteroidHitRelatedAchievements();
  }
  else if (gameEvent == GameEvent.BulletMissed) {
    mConsecutiveMisses++;
    mConsecutiveHits = 0;
    if (mConsecutiveMisses &gt;= 20) {
      unlockSafe(R.string.achievement_target_lost);
    }
  }
  else if (gameEvent == GameEvent.SpaceshipHit) {
    mTimeWithoutDie = 0;
  }
  […]
}</pre></div><p>Each time we hit an asteroid, we increment the number of consecutive asteroid hits and reset the number of consecutive misses. Similarly, each time we miss a bullet, we increment the number of consecutive misses and reset the number of consecutive hits.</p><p>As a side note, each <a class="indexterm" id="id000532"/>time the spaceship is destroyed we reset the time without dying, which is used for "Survivor", but this is not the only time when the time without dying should be updated. We have to reset it when the game starts, and modify it inside <code class="literal">onUpdate</code> by just adding the elapsed milliseconds that have passed:</p><div><pre class="programlisting">@Override
public void startGame(GameEngine gameEngine) {
  mTimeWithoutDie = 0;
  […]
}

@Override
public void onUpdate(long elapsedMillis, GameEngine gameEngine) {
  mTimeWithoutDie += elapsedMillis;
  if (mTimeWithoutDie &gt; 60000) {
    unlockSafe(R.string.achievement_survivor);
  }
}</pre></div><p>So, once the game has been running for 60,000 milliseconds since it started or since a spaceship was destroyed, we unlock the "Survivor" achievement.</p><p>With this, we have all the code we need to unlock the achievements we have created for the game. Let's finish this section with some comments on the system and the developer console:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a rule of thumb, you can edit most of the details of an achievement until you publish it to production.</li><li class="listitem" style="list-style-type: disc">Once your <a class="indexterm" id="id000533"/>achievement has been published, it cannot be deleted. You can only delete an achievement in its prepublished state. There is a button labeled Delete at the bottom of the achievement screen for this.</li><li class="listitem" style="list-style-type: disc">You can also reset the progress for achievements while they are in draft. This reset happens for all players at once. There is a button labeled <strong>Reset achievement progress</strong> at the bottom of the achievement screen for this.</li></ul></div><p>Also note that <code class="literal">GameBaseActivity</code> does a lot of logging. So, if your device is connected to your computer and you run a debug build, you may see that it lags sometimes. This does not happen in a release build for which the log is removed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00061"/>Leaderboards</h1></div></div></div><p>Since YASS has only <a class="indexterm" id="id000534"/>one game mode and one score in the game, it makes sense to have only one leaderboard on Google Play Game Services. Leaderboards are managed from their own tab inside the Game services area of the developer console.</p><p>Unlike achievements, it is not mandatory to have any leaderboard to be able to publish your game.</p><p>If your game has different levels of difficulty, you can have a leaderboard for each of them. This also applies if the game has several values that measure player progress, you can have a leaderboard for each of them.</p><div><img alt="Leaderboards" src="img/B04757_09_09.jpg"/><div><p>Managing leaderboards on Play Games console</p></div></div><p>Leaderboards can be created and managed in the <strong>Leaderboards</strong> tag. When we click on Add leaderboard, we are <a class="indexterm" id="id000535"/>presented with a form that has several fields to be filled. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: the display name of the leaderboard, which can be localized. We will simply call it <code class="literal">High Scores</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Score formatting</strong>: this can be <strong>Numeric</strong>, <strong>Currency</strong>, or <strong>Time</strong>. We will use <strong>Numeric</strong> for YASS.</li><li class="listitem" style="list-style-type: disc"><strong>Icon</strong>: a 512x512 px icon to identify the leaderboard.</li><li class="listitem" style="list-style-type: disc"><strong>Ordering</strong>: <strong>Larger is better</strong> / <strong>Smaller is better</strong>. We are going to use <strong>Larger is better</strong>, but other score types may be <strong>Smaller is better</strong> as in a racing game.</li><li class="listitem" style="list-style-type: disc"><strong>Enable tamper protection</strong>: this automatically filters out suspicious scores. You should keep this on.</li><li class="listitem" style="list-style-type: disc"><strong>Limits</strong>: if you want to limit the score range that is shown on the leaderboard, you can do it here. We are not going to use this</li><li class="listitem" style="list-style-type: disc"><strong>List order</strong>: the order of the leaderboards. Since we only have one, it is not really important for us.<div><img alt="Leaderboards" src="img/B04757_09_10.jpg"/><div><p>Setting up a leaderboard on the Play Games console</p></div></div></li></ul></div><p>Now that we have defined the leaderboard, it is time to use it in the game. As happens with achievements, we have a link where we can get all the resources for the game in XML. So, we proceed to get the ID of the leaderboard and add it to the strings defined in the <code class="literal">play_services.xml</code> file.</p><p>We have to submit the <a class="indexterm" id="id000536"/>scores at the end of the game (that is, a <code class="literal">GameOver</code> event), but also when the user exits a game via the pause button. To unify this, we will create a new <code class="literal">GameEvent</code> called <code class="literal">GameFinished</code> that is triggered after a <code class="literal">GameOver</code> event and after the user exits the game.</p><p>We will update the <code class="literal">stopGame</code> method of <code class="literal">GameEngine</code>, which is called in both cases to trigger the event:</p><div><pre class="programlisting">public void stopGame() {
  if (mUpdateThread != null) {
    synchronized (mLayers) {
      onGameEvent(GameEvent.GameFinished);
    }
    mUpdateThread.stopGame();
    mUpdateThread = null;
  }
  […]
}</pre></div><p>We have to set the <code class="literal">updateThread</code> to null after sending the event, to prevent this code being run twice. Otherwise, we could send each score more than once.</p><p>Similarly, as happens for achievements, submitting a score is very simple, just a single line of code. But we also need to check that the <code class="literal">GoogleApiClient</code> is connected and we still have the same <a class="indexterm" id="id000537"/>edge case when an Exception is thrown. So, we need to wrap it in a <code class="literal">try</code>/<code class="literal">catch</code> block.</p><p>To keep everything in the same place, we will put this code inside <code class="literal">ScoreGameObject</code>:</p><div><pre class="programlisting">@Override
public void onGameEvent(GameEvent gameEvent) {
  […]
  else if (gameEvent == GameEvent.GameFinished) {
    // Submit the score
    if (mApiClient.isConnecting() || mApiClient.isConnected()) {
      try {
        Games.Leaderboards.submitScore(mApiClient, getLeaderboardId(), mPoints);
      }
      catch (Exception e){
        mApiClient.disconnect();
      }
    }
  }
}

private String getLeaderboardId() {
  return mParent.getString(R.string.leaderboard_high_scores);
}</pre></div><p>This is really straightforward. GPGS is now receiving our scores and it takes care of the timestamp of the score to create daily, weekly, and all time leaderboards. It also uses your Google+ circles to show the social score of your friends. All this is done automatically for you.</p><p>The final missing piece is to let the player open the leaderboards and achievements UI from the main menu as well as trigger a sign in if they are signed out.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00062"/>Opening the Play Games UI</h1></div></div></div><p>To complete the <a class="indexterm" id="id000538"/>integration of achievements and leaderboards, we are going to add buttons to open the native UI provided by GPGS to our main menu.</p><p>For this, we are going to place two buttons in the bottom–left corner of the screen, opposite the music and sound buttons. We will also check whether we are connected or not; if not, we will show a single sign-in button.</p><p>For these buttons we will use the official images of GPGS, which are available for developers to use. Note that you must follow the brand guidelines while using the icons and they must be displayed as they are and not modified. This also provides a consistent look and feel across all the games that support Play Games.</p><p>Since we have seen a lot of layouts already, we are not going to include another one that is almost the same as something we already have.</p><div><img alt="Opening the Play Games UI" src="img/B04757_09_11.jpg"/><div><p>The main menu with the buttons to view achievements and leaderboards.</p></div></div><p>To handle these new buttons we will, as usual, set the <code class="literal">MainMenuFragment</code> as <code class="literal">OnClickListener</code> for the views. We do this in the same place as the other buttons, that is, inside <code class="literal">onViewCreated</code>:</p><div><pre class="programlisting">@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
  super.onViewCreated(view, savedInstanceState);
  [...]
  view.findViewById(R.id.btn_achievements).setOnClickListener(this);
  view.findViewById(R.id.btn_leaderboards).setOnClickListener(this);
  view.findViewById(R.id.btn_sign_in).setOnClickListener(this);
}</pre></div><p>As happened with achievements and leaderboards, the work is done using static methods that receive a <code class="literal">GoogleApiClient</code> object. We can get this object from the <code class="literal">GameHelper</code> that is a part of the <code class="literal">BaseGameActivity</code>, like this:</p><div><pre class="programlisting">GoogleApiClient apiClient = getYassActivity().getGameHelper().getApiClient();</pre></div><p>To open the native UI, we have to obtain an <code class="literal">Intent</code> and then start an <code class="literal">Activity</code> with it. It is important that you use <code class="literal">startActivityForResult</code>, since some data is passed back and forth.</p><p>To open the achievements UI, the <a class="indexterm" id="id000539"/>code is like this:</p><div><pre class="programlisting">Intent achievementsIntent = Games.Achievements.getAchievementsIntent(apiClient);
startActivityForResult(achievementsIntent, REQUEST_ACHIEVEMENTS);</pre></div><div><img alt="Opening the Play Games UI" src="img/B04757_09_12.jpg"/></div><p>This works out of the box. It automatically grays out the icons for the unlocked achievements, adds a counter and progress bar to the one that is in progress, and a padlock to the hidden ones.</p><p>Similarly, to open the leaderboards UI we obtain an intent from the <code class="literal">Games.Leaderboards</code> class instead:</p><div><pre class="programlisting">Intent leaderboardsIntent = Games.Leaderboards.getLeaderboardIntent(
  apiClient,
  getString(R.string.leaderboard_high_scores));
startActivityForResult(leaderboardsIntent, REQUEST_LEADERBOARDS);</pre></div><p>In this case, we are asking for a specific leaderboard, since we only have one. We could use <code class="literal">getLeaderboardsIntent</code> <a class="indexterm" id="id000540"/>instead, which will open the Play Games UI for the list of all the leaderboards.</p><div><div><h3 class="title"><a id="note00098"/>Note</h3><p>We can have an intent to open the list of leaderboards or a specific one.</p></div></div><p>What remains to be done is to replace the buttons for the login one when the user is not connected. For this, we will create a method that reads the state and shows and hides the views accordingly:</p><div><pre class="programlisting">private void updatePlayButtons() {
  GameHelper gameHelper = getYassActivity().getGameHelper();
  if (gameHelper.isConnecting() || gameHelper.isSignedIn()) {
    getView().findViewById(R.id.btn_achievements).setVisibility(View.VISIBLE);
    getView().findViewById(R.id.btn_leaderboards).setVisibility(View.VISIBLE);
    getView().findViewById(R.id.btn_sign_in).setVisibility(View.GONE);
  }
  else {
    getView().findViewById(R.id.btn_achievements).setVisibility(View.GONE);
    getView().findViewById(R.id.btn_leaderboards).setVisibility(View.GONE);
    getView().findViewById(R.id.btn_sign_in).setVisibility(View.VISIBLE);
  }
}</pre></div><p>This method decides whether to remove or make visible the views based on the state. We will call it inside the important state-changing methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onLayoutCompleted</code>: the first time we open the game to initialize the UI.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onSignInSucceeded</code>: when the user successfully signs in to GPGS.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onSignInFailed</code>: this can be triggered when we auto sign in and there is no connection. It is important to handle it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onActivityResult</code>: when we come back from the Play Games UI, in case the user has logged out.</li></ul></div><p>But nothing is as easy as it looks. In fact, when the user signs out and does not exit the game, <code class="literal">GoogleApiClient</code> keeps the connection open. Therefore the value of <code class="literal">isSignedIn</code> from <code class="literal">GameHelper</code> still returns true. This is the edge case we have been talking about all through the chapter.</p><p>As a result of this edge case, there is an inconsistency in the UI that shows the achievements and leaderboards buttons when it should show the login one.</p><div><div><h3 class="title"><a id="note00099"/>Note</h3><p>When the user logs out from Play Games, <code class="literal">GoogleApiClient</code> keeps the connection open. This can lead to confusion.</p></div></div><p>Unfortunately, this has been <a class="indexterm" id="id000541"/>marked as work as expected by Google. The reason is that the connection is still active and it is our responsibility to parse the result in the <code class="literal">onActivityResult</code> method to determine the new state. But this is not very convenient.</p><p>Since it is a rare case we will just go for the easiest solution, which is to wrap it in a <code class="literal">try/catch</code> block and make the user sign in if he or she taps on leaderboards or achievements while not logged in. This is the code we have to handle  the click on the achievements button, but the one for leaderboards is equivalent:</p><div><pre class="programlisting">else if (v.getId() == R.id.btn_achievements) {
  try {
    GoogleApiClient apiClient = getYassActivity().getGameHelper().getApiClient();
    Intent achievementsIntent = Games.Achievements.getAchievementsIntent(apiClient);
    startActivityForResult(achievementsIntent, REQUEST_ACHIEVEMENTS);
  }
  catch (Exception e) {
    GameHelper gameHelper = getYassActivity().getGameHelper();
    gameHelper.disconnect();
    gameHelper.beginUserInitiatedSignIn();
  }
}</pre></div><p>Basically, we have the old code to open the achievements activity, but we wrap it in a <code class="literal">try</code>/<code class="literal">catch</code> block. If an exception is raised, we disconnect the game helper and begin a new login using the <code class="literal">beginUserInitiatedSignIn</code> method.</p><p>It is very important to disconnect the <code class="literal">gameHelper</code> before we try to log in again. Otherwise, the login will not work.</p><div><div><h3 class="title"><a id="note000100"/>Note</h3><p>We must disconnect from GPGS before we can log in using the method from the <code class="literal">GameHelper</code>.</p></div></div><p>Finally, there is the case when the user clicks on the login button, which just triggers the login using the <code class="literal">beginUserInitiatedSignIn</code> method from the <code class="literal">GameHelper</code>:</p><div><pre class="programlisting">if (v.getId() == R.id.btn_sign_in) {
  getYassActivity().getGameHelper().beginUserInitiatedSignIn();
}</pre></div><p>Once you have published your game and the game services, achievements and leaderboards will not appear in the game description on Google Play straight away. It is required that "a fair amount of <a class="indexterm" id="id000542"/>users" have used them. You have done nothing wrong, you just have to wait.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00063"/>Other features of Google Play services</h1></div></div></div><p>Google Play Game <a class="indexterm" id="id000543"/>Services provides more features for game developers than achievements and leaderboards. None of them really fit the game we are building, but it is useful to know they exist just in case your game needs them. You can save yourself lots of time and effort by using them and not reinventing the wheel.</p><p>The other features of Google Play Games Services are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Events and quests</strong>: these allow you to monitor game usage and progression. Also, they add the possibility of creating time-limited events with rewards for the players.</li><li class="listitem" style="list-style-type: disc"><strong>Gifts</strong>: as simple as it sounds, you can send a gift to other players or request one to be sent to you. Yes, this is seen in the very mechanical Facebook games popularized a while ago.</li><li class="listitem" style="list-style-type: disc"><strong>Saved games</strong>: the standard concept of a saved game. If your game has progression or can unlock content based on user actions, you may want to use this feature. Since it is saved in the cloud, saved games can be accessed across multiple devices.</li><li class="listitem" style="list-style-type: disc"><strong>Turn-based and real-time multiplayer</strong>: Google Play Game Services provides an API to implement turn-based and real-time multiplayer features without you needing to write any server code.</li></ul></div><p>If your game is multiplayer and has an online economy, it may be worth making your own server and granting virtual currency only on the server to prevent cheating. Otherwise, it is fairly easy to crack the gifts/reward system and a single person can ruin the complete game economy.</p><p>However, if there is no online game economy, the benefits of gifts and quests may be more important than the fact that someone can hack them.</p><p>Let's take a look at <a class="indexterm" id="id000544"/>each of these features.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec00097"/>Events</h2></div></div></div><p>The event's APIs <a class="indexterm" id="id000545"/>provides us with a way to define and collect gameplay metrics and upload them to Google Play Game Services.</p><p>This is very similar to the <code class="literal">GameEvents</code> we are already using in our game. Events should be a subset of the <a class="indexterm" id="id000546"/>game events of our game. Many of the game events we have are used internally as a signal between objects or as a synchronization mechanism. These events are not really relevant outside the engine, but others could be. Those are the events we should send to GPGS.</p><p>To be able to send an event from the game to GPGS, we have to create it in the developer console first.</p><p>To create an event, we have to go to the <strong>Events</strong> tab in the developer console, click on <strong>Add new event</strong>, and fill in the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: a short name of the event. The name can be up to 100 characters. This value can be localized.</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: a longer description of the event. The description can be up to 500 characters. This value can also be localized.</li><li class="listitem" style="list-style-type: disc"><strong>Icon</strong>: the icon for the event of the standard 512x512 px size.</li><li class="listitem" style="list-style-type: disc"><strong>Visibility</strong>: as for achievements, this can be revealed or hidden.</li><li class="listitem" style="list-style-type: disc"><strong>Format</strong>: as for leaderboards, this can be <strong>Numeric</strong>, <strong>Currency</strong>, or <strong>Time</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Event type</strong>: this is used to mark events that create or spend premium currency. This can be <strong>Premium currency sink</strong>, <strong>Premium currency source</strong>, or <strong>None</strong>.</li></ul></div><p>While in the game, events work pretty much as incremental achievements. You can increment the event counter using the following line of code:</p><div><pre class="programlisting">Games.Events.increment(mGoogleApiClient, myEventId, 1);</pre></div><p>You can delete events that are in the draft state or that have been published as long as the event is not in use by a quest. You can also reset the player progress data for the testers of your events as you can do for achievements.</p><p>While the events can be used as an analytics system, their real usefulness appears when they are combined with quests.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec00098"/>Quests</h2></div></div></div><p>A quest is a <a class="indexterm" id="id000547"/>challenge that asks players to complete an event a number of times during a specific time frame to receive a reward.</p><p>Because a quest is linked to an event, to use quests you need to have created at least one event.</p><p>You can create a quest from the <a class="indexterm" id="id000548"/>quests tab in the developer console. A quest has the following fields to be filled:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: the short name of the quest. This can be up to 100 characters and can be localized.</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: a longer description of the quest. Your quest description should let players know what they need to do to complete the quest. The description can be up to 500 characters. The first 150 characters will be visible to players on cards such as those shown in the Google Play Games app.</li><li class="listitem" style="list-style-type: disc"><strong>Icon</strong>: a square icon that will be associated with the quest.</li><li class="listitem" style="list-style-type: disc"><strong>Banner</strong>: a rectangular image that will be used to promote the quest.</li><li class="listitem" style="list-style-type: disc"><strong>Completion Criteria</strong>: this is the configuration of the quest itself. It consists of an event and the number of times the event must occur.</li><li class="listitem" style="list-style-type: disc"><strong>Schedule</strong>: the start and end date and time for the quest. GPGS uses your local time zone, but stores the values as UTC. Players will see these values appear in their local time zone. You can mark a checkbox to notify users when the quest is about to end.</li><li class="listitem" style="list-style-type: disc"><strong>Reward Data</strong>: this is specific to each game. It can be a JSON object, specifying the reward. This is sent to the client when the quest is completed.</li></ul></div><p>Once configured in the developer console, you can do two things with the quests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Display the list of quests</li><li class="listitem" style="list-style-type: disc">Process a quest completion</li></ul></div><p>To get the list of quests, we start an activity with an intent that is provided to us via a static method as usual:</p><div><pre class="programlisting">Intent questsIntent = Games.Quests.getQuestsIntent(mGoogleApiClient,
   Quests.SELECT_ALL_QUESTS);
startActivityForResult(questsIntent, QUESTS_INTENT);</pre></div><p>To be notified when a quest is completed, all we have to do is register a listener:</p><div><pre class="programlisting">Games.Quests.registerQuestUpdateListener(mGoogleApiClient, this);</pre></div><p>Once we have set the listener, the <code class="literal">onQuestCompleted</code> method will be called once the quest is completed. After completing the processing of the reward, the game should call <code class="literal">claim</code> to inform Play Game services that the player has claimed the reward.</p><p>The following code <a class="indexterm" id="id000549"/>snippet shows how you might override the <code class="literal">onQuestCompleted</code> callback:</p><div><pre class="programlisting">@Override
public void onQuestCompleted(Quest quest) {
  // Claim the quest reward.
  Games.Quests.claim(mGoogleApiClient, quest.getQuestId(),
    quest.getCurrentMilestone().getMilestoneId());
  // Process the RewardData to provision a specific reward.
  String reward = new
    String(quest.getCurrentMilestone().getCompletionRewardData(),
    Charset.forName("UTF-8"));
}</pre></div><p>The rewards themselves are defined by the client. As we mentioned before, this will make the game quite easy to <a class="indexterm" id="id000550"/>crack and get rewards. But usually, avoiding the hassle of writing your own server is worth it.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec00099"/>Gifts</h2></div></div></div><p>The gifts feature of <a class="indexterm" id="id000551"/>GPGS allows us to send gifts to other players and to request them to send us one as well. This is intended to make the gameplay more collaborative and to improve the social aspect of the game.</p><p>As for other GPGS features, we have a built-in UI provided by the library that can be used. In this case, to send and request gifts for in-game items and resources to and from friends in their Google+ circles. The request system can make use of notifications.</p><p>There are two types of requests <a class="indexterm" id="id000552"/>that players can send using the game gifts feature in Google Play Game Services:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A wish request to ask for in-game items or some other form of assistance from their friends</li><li class="listitem" style="list-style-type: disc">A gift request to send in-game items or some other form of assistance to their friends</li></ul></div><p>A player can specify one or more target request recipients from the default request-sending UI. A gift or wish can be consumed (accepted) or dismissed by a recipient.</p><p>To see the gifts API in <a class="indexterm" id="id000553"/>detail, you can visit <a class="ulink" href="https://developers.google.com/games/services/android/giftRequests">https://developers.google.com/games/services/android/giftRequests</a>.</p><p>Again, as for quest <a class="indexterm" id="id000554"/>rewards, this is done entirely by the client, which makes the game <a class="indexterm" id="id000555"/>susceptible to piracy.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec000100"/>Saved games</h2></div></div></div><p>The saved games service <a class="indexterm" id="id000556"/>offers cloud game saving slots. Your game can retrieve the saved game data to allow returning players to continue a game at their last save point from any device.</p><p>This service makes it possible to synchronize a player's game data across multiple devices. For example, if you have a game that runs on Android, you can use the saved games service to allow a player to start a game on their Android phone and then continue playing the game on a tablet without losing any of their progress. This service can also be used to ensure that a player's game play continues from where it was left off even if their device is lost, destroyed, or traded in for a newer model or if the game was reinstalled</p><p>The saved games service does not know about the game internals, so it provides a field that is an unstructured binary blob where you can read and write the game data. A game can write an arbitrary number of saved games for a single player subjected to user quota, so there is no hard requirement to restrict players to a single save file.</p><div><div><h3 class="title"><a id="note000101"/>Note</h3><p>Saved games are done in an unstructured binary blob.</p></div></div><p>The API for saved games also receives some metadata that is used by Google Play Games to populate the UI and to present useful information in the Google Play Game app (for example, last updated timestamp).</p><p>Saved games has several entry <a class="indexterm" id="id000557"/>points and actions, including how to deal with conflicts in the saved games. To know more about these check out the official documentation at <a class="ulink" href="https://developers.google.com/games/services/android/savedgames">https://developers.google.com/games/services/android/savedgames</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec000101"/>Multiplayer games</h2></div></div></div><p>If you are going to <a class="indexterm" id="id000558"/>implement multiplayer, GPGS can save you a lot of work. You may or may not use it for the final product, but it will remove the need to think about the server-side until the game concept is validated.</p><p>You can use GPGS for turn-based and real-time multiplayer games. Although each one is completely different and uses a different API, there is always an initial step where the game is set up and the opponents are selected or invited.</p><p>In a turn-based multiplayer game, a single shared state is passed among the players and only the player that owns the turn has permission to modify it. Players take turns asynchronously according to an order of play determined by the game.</p><p>A turn is finished explicitly by the player using an API call. Then the game state is passed to the other players, together with the turn.</p><p>There are many cases: selecting opponents, creating a match, leaving a match, canceling, and so on. The <a class="indexterm" id="id000559"/>official documentation at <a class="ulink" href="https://developers.google.com/games/services/android/turnbasedMultiplayer">https://developers.google.com/games/services/android/turnbasedMultiplayer</a> is quite exhaustive and you should read through it if you plan to use this feature.</p><p>In a real-time <a class="indexterm" id="id000560"/>multiplayer there is no concept of turn. Instead, the server uses the concept of room: a virtual construct that enables network communication between multiple players in the same game session and lets players send data directly to one another, a common concept for game servers.</p><div><div><h3 class="title"><a id="note000102"/>Note</h3><p>Real-time multiplayer service is based on the concept of Room.</p></div></div><p>The API of real-time multiplayer allows us to easily:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manage network connections to create and maintain a real-time multiplayer room</li><li class="listitem" style="list-style-type: disc">Provide a player-selection user interface to invite players to join a room, look for random players for auto-matching, or a combination of both</li><li class="listitem" style="list-style-type: disc">Store participant and room-state information on the Play Game services' servers while the game is running</li><li class="listitem" style="list-style-type: disc">Send room invitations and updates to players</li></ul></div><p>To check the complete documentation <a class="indexterm" id="id000561"/>for real-time games, please visit the official web at <a class="ulink" href="https://developers.google.com/games/services/android/realtimeMultiplayer">https://developers.google.com/games/services/android/realtimeMultiplayer</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec00064"/>Summary</h1></div></div></div><p>We have added Google Play services to YASS, including setting up the game in the developer console and adding the required libraries to the project.</p><p>Then, we defined a set of achievements and added the code to unlock them. We have used normal, incremental, and hidden achievement types to showcase the different options available.</p><p>We have also configured a leaderboard and submitted the scores, both when the game is finished and when it is exited via the pause dialog.</p><p>Finally, we have added links to the native UI for leaderboards and achievements to the main menu.</p><p>We have also introduced the concepts of events, quests, and gifts and the features of saved games and multiplayer that Google Play Game services offers.</p><p>The game is ready to publish now. In the next chapter, we will see how to make it work on Android TV.</p></div>
<div><div><div><div><h1 class="title"><a id="ch30"/>Chapter 10. To the Big Screen</h1></div></div></div><p>We have a game that <a class="indexterm" id="id000562"/>runs properly on phones and tablets. So what about Android TV?</p><p>I believe Android TV has the potential to become a big gaming platform in the near future. Although other systems have tried to bring Android games to the big screen—namely OUYA, GameStick, and Amazon FireTV—there is a major difference: Android TV is not designed to be a box you plug into your TV but rather the Operating System in your SmartTV.</p><p>That makes a lot of difference because people will have it by default. I was skeptical about OUYA until I tried it. It was a great experience, but if I hadn't been an Android game developer I probably would not have tried it. Android TV can break that barrier.</p><p>In addition to that, adding support to Android TV is fairly simple and it may allow you to get more reach, so, why not do it anyway?</p><p>TVs are different from phones, they are bigger and they do not have a touch screen. They are also usually watched from a larger distance. Because of that Android TV has a different UI and some extra requirements for apps to run on it.</p><p>The main requirements when it comes to porting a game to Android TV are to support landscape orientation and be usable with a controller. We already do that. If your game does not support landscape or is not designed to work with a gamepad, then porting to Android TV will require a lot more work and may not be the best investment for your time; however, if you have landscape and controller support, go for it!</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec00065"/>Project configuration</h1></div></div></div><p>There are two <a class="indexterm" id="id000563"/>different approaches to adding Android TV to your project. They are conceptually different but the code you have to write is almost the same for both of them, although in different places. According to the characteristics of your project, you may prefer one or another. These options are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a separate APK for Android TV</li><li class="listitem" style="list-style-type: disc">Using the same APK for phones, tablets, and TVs</li></ul></div><p>The default option of Android Studio is to create a build variant for Android TV. It did that when we used the wizard to set up our project and we added TV support. That is why we have the <code class="literal">mobile</code> and <code class="literal">tv</code> directories. The main project is <code class="literal">mobile</code> and <code class="literal">tv</code> is configured to be a build variant or "flavor".</p><p>Flavors are a powerful way to build different APKs from the same code base, allowing us to modify parts, be it code or resources. It is particularly useful when you have to publish the same game in different markets. On the other hand, if you have a single APK, it has to be able to adapt to the different configurations on its own.</p><p>Each approach has advantages and disadvantages.</p><p>Some reasons why you <a class="indexterm" id="id000564"/>would want to have a separate APK for Android TV are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a lower target API for the mobile version (Android TV requires target SDK 21 – Lollipop)</li><li class="listitem" style="list-style-type: disc">Using higher-resolution assets for TV without including them into the mobile package</li><li class="listitem" style="list-style-type: disc">Having separated special features for mobile/TV</li></ul></div><p>On the other hand, the main advantages of having a single APK are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easier to publish (only one file to upload)</li><li class="listitem" style="list-style-type: disc">Easier to maintain</li></ul></div><p>Given that we will not have any special features built in for Android TV, we are going to use the single-APK approach. Note that, if you want to do a build variant, the modifications are almost the same, but done in the <code class="literal">tv</code> directory instead.</p><div><div><h3 class="title"><a id="note000103"/>Note</h3><p>Publishing on Android TV requires target SDK 21.</p></div></div><p>The official documentation suggests that we include the <code class="literal">Leanback</code> library, which requires <code class="literal">minSDK</code> version 17. Since we are not building an app, but a game, and the library is about UIs, we can ignore it and keep the <code class="literal">minSDK</code> to 15.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00066"/>Testing for Android TV</h1></div></div></div><p>There are several ways <a class="indexterm" id="id000565"/>to test the builds for Android TV. The obvious and simplest one is to use an emulator.</p><p>Emulators for Android TV—as for phones—are virtual machines that run exactly the same version of the operating system as the real device. Therefore they are very reliable but also quite slow.</p><p>Of course, ideally you should be able to test your game on a real device. At the time of writing, there are several smart TVs announced with Android TV, but the best devices to test are the ADT-1 (Developer Kit) and the Nexus Player.</p><p>ADT-1 however is in short supply and is hard to get. The Nexus Player on the other hand is a fairly cheap device.</p><p>However, unless you require to test gameplay, navigation can be easily tested with an emulator.</p><div><div><h3 class="title"><a id="note000104"/>Note</h3><p>Unless you require to test gameplay, an emulator should be enough to test the game.</p></div></div><p>Note that emulators do not include Google Play Services but a real device will have them.</p><p>I also noticed that the theme <a class="indexterm" id="id000566"/>on the ADT-1 is slightly different than the one on the emulator and the text on the Start button was of a different color. Nothing major, and also easy to fix.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00067"/>Declaring a TV Activity</h1></div></div></div><p>Android TV uses the <a class="indexterm" id="id000567"/>Leanback interface, which is designed for big screens controlled by a remote. This UI displays apps and games in a different way from phones. The launcher is also different. Because of this, apps and games need to declare an Activity with a particular intent filter so the Leanback launcher can find them and make them available to the user.</p><p>This intent filter will declare the app to be available for launch on a Leanback interface.</p><p>The easiest way to proceed is to create a new <code class="literal">Activity</code> that extends from our normal activity and then override some methods if necessary to adapt to the TV interface. For now, we will create <code class="literal">YassTvActivity</code> that just extends <code class="literal">YassActivity</code>:</p><div><pre class="programlisting">public class YassTvActivity extends YassActivity {
}</pre></div><p>We will then declare it on <code class="literal">AndroidManifest.xml</code> with the proper intent filter:</p><div><pre class="programlisting">&lt;activity
  android:name=".YassTvActivity"
  android:label="@string/app_name"
  &gt;
  &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LEANBACK_LAUNCHER" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div><p>As you can see, the intent filter is almost the same as the one for the normal launch activity except that the category has a different name (<code class="literal">LEANBACK_LAUNCHER</code> instead of <code class="literal">LAUNCHER</code>).</p><p>Note that on Android you cannot declare the same activity twice on the manifest, but you can declare multiple intent filters for the same activity. You can use the same activity for both mobile and TV, like this:</p><div><pre class="programlisting">&lt;activity
  android:screenOrientation="sensorLandscape"
  android:name=".YassActivity"
  android:hardwareAccelerated="false"
  android:label="@string/title_activity_main" &gt;
  &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
  &lt;/intent-filter&gt;
  &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LEANBACK_LAUNCHER" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div><p>We are going to use a <a class="indexterm" id="id000568"/>separate activity to allow minor tweaks in the code, but keep the possibility of having the same activity with two intent filters in mind, although I advise using it only if you are sure that you will not need to override anything.</p><p>There is no way to define qualifiers for TV, and that has been done purposefully by the Android team to enforce responsive layout design. The only way to know we are running on a TV is to programmatically check for the Leanback feature or to use a specific activity for TVs and override some methods on it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00068"/>Providing a home screen banner</h1></div></div></div><p>Android TV apps must <a class="indexterm" id="id000569"/>declare a banner in the <a class="indexterm" id="id000570"/>manifest. This is another requirement that does not exist for mobile apps.</p><p>The banner is used by the Leanback UI to navigate among apps and games. It has a different aspect ratio than the icon. In particular, the banner is an image of 320x180 px that we have to put under the <code class="literal">drawable-xhdpi</code> directory.</p><div><img alt="Providing a home screen banner" src="img/B04757_10_01.jpg"/><div><p>The banner is a 320x180 px image</p></div></div><p>This image is as important for TV as <a class="indexterm" id="id000571"/>the icon is for mobile, it is the entry point to your game on the TV. While we—as developers—can install and run apps on a TV without providing this, there is no easy entry point to launch the app from the Leanback UI without providing the banner.</p><p>To define which image is <a class="indexterm" id="id000572"/>to be used as the banner, we need to add it as one of the attributes of the <code class="literal">&lt;appication&gt;</code> tag in the <code class="literal">AndroidManifest.xml</code>.</p><div><pre class="programlisting">&lt;application
  […]
  android:banner="@drawable/banner_small" &gt;</pre></div><p>This attribute was introduced on Lollipop and it is one of the reasons why we need to compile with target SDK 21 to be able to publish for Android TV.</p><div><img alt="Providing a home screen banner" src="img/B04757_10_02.jpg"/><div><p>Our game in the Leanback UI of an emulator</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00069"/>Declaring it as a game</h1></div></div></div><p>As you can see in the previous screenshot, the Leanback UI separates apps from games, and our game is listed among <a class="indexterm" id="id000573"/>the apps. We are building a game and we want to be classified as such.</p><p>This is another property of the <code class="literal">&lt;application&gt;</code> tag that was also introduced in Lollipop for Android TV; we can declare the app to be a game.</p><div><pre class="programlisting">&lt;application
  […]
  android:isGame="true"&gt;</pre></div><p>This will show the banner in the <strong>Games</strong> category.</p><div><img alt="Declaring it as a game" src="img/B04757_10_03.jpg"/><div><p>YASS listed in the Games category on an ADT-1</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec000102"/>Declaring Leanback support</h2></div></div></div><p>To allow Google <a class="indexterm" id="id000574"/>Play to list our game when searching from an <a class="indexterm" id="id000575"/>Android TV, we need to specifically declare that we support the Leanback UI. To do that, we have to declare that we use the Leanback feature:</p><div><pre class="programlisting">&lt;uses-feature android:name="android.software.leanback"
  android:required="false" /&gt;</pre></div><p>Note that we declare that we use it but we mark it as not required. This is important because otherwise the game will not appear for devices that do not have the Leanback feature. If we were to have two separate APKs, we should mark this feature as required on the TV build variant only.</p><p>Declaring a <code class="literal">uses-feature</code> means that your app makes use of it. Marking it as not required means that it can do without it, but it will make use of it if present.</p><div><div><h3 class="title"><a id="note000105"/>Note</h3><p>Declaring a <code class="literal">uses-feature</code> means that your app makes use of it. Marking it as not required means that it can do without it.</p></div></div><p>If you are using separate APKs for mobile and TV, you should declare the <code class="literal">uses-feature</code> for Leanback only on the TV build variant and do nothing on the mobile one. By doing that, the TV APK will appear only on devices with Leanback UI and the mobile APK will appear only on devices without Leanback support.</p><p>The default state for the <a class="indexterm" id="id000576"/>Leanback feature is to not be <a class="indexterm" id="id000577"/>required.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec000103"/>Declaring touchscreen capability as not required</h2></div></div></div><p>Because of how the <a class="indexterm" id="id000578"/>
<code class="literal">uses-feature</code> system works, we need to fix the requested features to make our game available on Android TV. Essentially this means that we cannot ask for features that the TV does not have, otherwise the game will not appear as available for it.</p><p>This is not as simple as it looks since some features get automatically included without doing anything.</p><p>Because of the nature of Android, touchscreen capability is required by default but, if we don't mark it as not required, the game will not be listed on Google Play for Android TV, since the device does not have a touchscreen.</p><div><div><h3 class="title"><a id="note000106"/>Note</h3><p>The touchscreen feature is required by default on Android apps.</p></div></div><p>This is really easy to fix, we just need to declare touchscreen capability as not required on the <code class="literal">AndroidManifest.xml</code>.</p><div><pre class="programlisting">&lt;uses-feature android:name="android.hardware.touchscreen"
  android:required="false" /&gt;</pre></div><p>Note that this also means that the game should be completely usable without a touchscreen. For that we have a special section about handling menus with a controller later in this chapter.</p><p>There are other features that are not available on Android TV and you must make sure to mark them as not required (and handle cases when they are not available) if you use them. The features are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Touchscreen: <code class="literal">android.hardware.touchscreen</code></li><li class="listitem" style="list-style-type: disc">Touchscreen emulator: <code class="literal">android.hardware.faketouch</code></li><li class="listitem" style="list-style-type: disc">Telephony: <code class="literal">android.hardware.telephony</code></li><li class="listitem" style="list-style-type: disc">Camera: <code class="literal">android.hardware.camera</code></li><li class="listitem" style="list-style-type: disc">Bluetooth: <code class="literal">android.hardware.bluetooth</code></li><li class="listitem" style="list-style-type: disc">Near Field Communications (NFC): <code class="literal">android.hardware.nfc</code></li><li class="listitem" style="list-style-type: disc">GPS: <code class="literal">android.hardware.location.gps</code></li><li class="listitem" style="list-style-type: disc">Microphone: <code class="literal">android.hardware.microphone</code></li><li class="listitem" style="list-style-type: disc">Sensors: <code class="literal">android.hardware.sensor</code></li></ul></div><p>For games only, the touchscreen and sensor aspect may be worrying, but there are games that use location and/or the camera as an integral part of the game. This may be a deal-breaker when it comes to bringing the game to the TV.</p><div><div><h3 class="title"><a id="note000107"/>Note</h3><p>If your game relies on GPS or the Camera, it's probably not a good fit for a TV.</p></div></div><p>In addition to this, some <code class="literal">uses-permission</code> declarations imply a requirement for hardware features. The permissions that implicitly require features are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RECORD_AUDIO</code> requires the use of <code class="literal">android.hardware.microphone</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CAMERA</code> requires:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.camera</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.camera.autofocus</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ACCESS_COARSE_LOCATION</code> requires:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.location</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.location.network</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ACCESS_FINE_LOCATION</code> requires:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.location</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.hardware.location.gps</code></li></ul></div></li></ul></div><p>If you use any of these permissions, you should ensure to mark the appropriate feature as not required and act <a class="indexterm" id="id000579"/>accordingly when not present.</p><p>To detect if a feature is present or not to enable or disable some parts of the game on runtime, you can use the <code class="literal">hasSystemFeature</code> method of <code class="literal">PackageManager</code>. Like this:</p><div><pre class="programlisting">getPackageManager().hasSystemFeature("android.hardware.touchscreen")</pre></div><p>Note that <code class="literal">getPackageManager</code> is available at the <code class="literal">Context</code> level, so you can access it from the <code class="literal">Activity</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00070"/>Reviewing the manifest</h1></div></div></div><p>Once we have added the <a class="indexterm" id="id000580"/>activity for the TV to the Leanback launcher, made sure that the Leanback and touchscreen features are requested but not required, configured the banner, and marked it as a game, we are done modifying <code class="literal">AndroidManifest.xml</code>.</p><p>The updated version of the manifest is as follows:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
  package="com.plattysoft.yass" &gt;

  &lt;application
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:isGame="true"
    android:banner="@drawable/banner_small"
    android:theme="@style/AppTheme" &gt;

    &lt;uses-feature android:name="android.software.leanback"
      android:required="false" /&gt;

    &lt;uses-feature android:name="android.hardware.touchscreen"
      android:required="false" /&gt;

    &lt;meta-data android:name="com.google.android.gms.games.APP_ID"
      android:value="@string/app_id" /&gt;
    &lt;meta-data android:name="com.google.android.gms.version"
      android:value="@integer/google_play_services_version"/&gt;

    &lt;activity
      android:screenOrientation="sensorLandscape"
      android:name=".YassActivity"
      android:hardwareAccelerated="false"
      android:label="@string/title_activity_main" &gt;
      &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
      &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity
      android:name=".YassTvActivity"
      android:label="@string/app_name" &gt;
      &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LEANBACK_LAUNCHER" /&gt;
      &lt;/intent-filter&gt;
    &lt;/activity&gt;
  &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00071"/>Showing controller instructions</h1></div></div></div><p>One of the special <a class="indexterm" id="id000581"/>requirements for an app to be <a class="indexterm" id="id000582"/>approved for Android TV is to provide a dialog indicating how the controller is mapped. For this Google provides us with a template <a class="indexterm" id="id000583"/>that we can use and it is available online: (<a class="ulink" href="http://developer.android.com/training/tv/games/index.html">http://developer.android.com/training/tv/games/index.html</a>).</p><div><img alt="Showing controller instructions" src="img/B04757_10_04.jpg"/><div><p>Template for controller mapping</p></div></div><p>We already have a dialog that is displayed when a controller is connected, but we never updated it from being just an <code class="literal">AlertDialog</code>. It is time we made it a custom dialog.</p><p>The logic for phones was to show the dialog only the first time the main menu was loaded and a controller was connected. For Android TV, we want a different behavior: we want to show the dialog every time the game is opened.</p><p>To do this, we are going to overwrite the method <code class="literal">showControllerHelp</code> on <code class="literal">MainMenuFragment</code> to use a custom dialog with the template image modified to include the controls of our game.</p><p>As for other custom dialogs we have already made, we have to create a layout and a class. The layout is extremely simple, just an image:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  android:layout_gravity="center"
  android:background="@drawable/dialog_bg"
  android:layout_width="@dimen/dialog_width"
  android:layout_height="@dimen/dialog_height"&gt;

  &lt;ImageView
    android:id="@+id/controller_help_image"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerInParent="true"
    android:src="img/controller_help"/&gt;

&lt;/RelativeLayout&gt;</pre></div><p>And the class is also very simple thanks to <code class="literal">BaseCustomDialog</code>:</p><div><pre class="programlisting">public class ControllerHelpDialog extends BaseCustomDialog implements View.OnClickListener {
  public ControllerHelpDialog(YassActivity a) {
    super(a);
    setContentView(R.layout.dialog_controller_help);
    findViewById(R.id.controller_help_image).setOnClickListener(this);
  }

  @Override
  public void onClick(View v) {
    dismiss();
  }
}</pre></div><p>We are setting the layout and then handling the click on the image as a dismiss. When using a controller, the dialog <a class="indexterm" id="id000584"/>will only be dismissed when <a class="indexterm" id="id000585"/>using the keys <em>B</em> or back; we will take care of proper key handling on dialogs later in the chapter and make it also dismiss when clicking on the <em>A</em> button.</p><p>Finally, we need to do some changes on <code class="literal">MainMenuFragment</code> to show this newly created dialog and also to modify the logic of when to show it:</p><div><pre class="programlisting">private void displayGamepadHelp() {
  showDialog(new ControllerHelpDialog(getYassActivity()));
}

private boolean shouldDisplayGamepadHelp() {
  PackageManager pm = getYassActivity().getPackageManager();
  boolean isLeanback = pm.hasSystemFeature("android.software.leanback");
  if (isLeanback) {
    boolean shownAlready = YassActivity.sGamepadHelpShown;
    YassActivity.sGamepadHelpShown = true;
    return !shownAlready;
  }
  if (isGameControllerConnected()) {
    return PreferenceManager.getDefaultSharedPreferences(getActivity())
      .getBoolean(PREF_SHOULD_DISPLAY_GAMEPAD_HELP, true);
  }
  return false;
}</pre></div><p>In the method <code class="literal">shouldDisplayGamePadHelp</code> we will check if we use the Leanback feature to know if we are on a TV or not.</p><p>If the Leanback feature is not present, we use the same code as before: we display the dialog if a controller is connected and we have not displayed it before.</p><p>As mentioned before, we will <a class="indexterm" id="id000586"/>keep the logic we had for <a class="indexterm" id="id000587"/>phones, but for TVs we will always display the dialog.</p><p>In the case of an Android TV, we want to show it when the app is opened. Since <code class="literal">shouldDisplayGamepadHelp</code> is executed during the <code class="literal">onResume</code> method of the fragment, we will store the fact that it has been shown already in a static variable, so the dialog is not shown again when we come back to the fragment after a game over. Then we return true if the dialog has not been shown yet.</p><div><img alt="Showing controller instructions" src="img/B04757_10_05.jpg"/></div><p>If you plan to support other controllers or consoles such as the MOGA, OUYA, or Nvidia Shield, you should have a different <a class="indexterm" id="id000588"/>image for each of the <a class="indexterm" id="id000589"/>controllers and detect which one is connected by using the device descriptor. In the particular case of OUYA, since it is a different marketplace, you can just have another build variant with a special graphic.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec000104"/>Dealing with overscan</h2></div></div></div><p>Layouts for TV have some <a class="indexterm" id="id000590"/>special requirements due to the evolution of TV standards and the desire to always present a full screen picture to viewers. For this reason, TV devices may clip the outside edge of an app layout in order to ensure that <a class="indexterm" id="id000591"/>the entire display is filled. This behavior is generally referred to as <strong>overscan</strong>.</p><p>To avoid screen elements being clipped due to overscan, it is recommended to add a 10% margin on all sides of layouts. When talking about dips, this translates into a 48dp margin on the left and right edges and a 27dp margin on the top and bottom.</p><p>While we could just add that padding on the layout for all the devices, we will create special layouts for Android TV as a practical example of how to do it. As we mentioned before, there is no resource qualifier for TV; we have to rely on the Leanback feature being present or not.</p><p>We already have a special activity that is launched on the Leanback interface. We will also create special fragments for TV where the only difference will be the layout. To put the two pieces together, we will override the methods that create the fragments and replace them on the TV activity.</p><p>This means that we need to first extract the creation of the fragments to a method we can override. This is already the case for the <code class="literal">GameFragment</code>, which is created when we start a game, but not for <a class="indexterm" id="id000592"/>
<code class="literal">MainMenuFragment</code>. That fragment is only created during <code class="literal">onCreate</code> of the activity, so we will refactor the code by <a class="indexterm" id="id000593"/>extracting the creation of the <code class="literal">MainMenuFragment</code> to a new method.</p><div><pre class="programlisting">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_yass);
  if (savedInstanceState == null) {
    getFragmentManager().beginTransaction()
      .add(R.id.container, <strong>createMenuFragment()</strong>, TAG_FRAGMENT)
      .commit();
  }
  [...]
}

protected Fragment createMenuFragment() {
  return new MainMenuFragment();
}

public void startGame() {
  navigateToFragment(new GameFragment());
}</pre></div><p>To add the margins to the game itself, we will create a file <code class="literal">fragment_game_tv.xml</code> as the layout for the <code class="literal">GameTvFragment</code> with the following declaration:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout 
  android:layout_width="match_parent"
  android:layout_gravity="center"
  android:paddingTop="27dp"
  android:paddingLeft="48dp"
  android:paddingRight="48dp"
  android:paddingBottom="27dp"
  android:background="@color/background"
  android:layout_height="match_parent"&gt;

  &lt;include layout="@layout/fragment_game" /&gt;

&lt;/FrameLayout&gt;</pre></div><p>We just put a <code class="literal">FrameLayout</code> at the top level with the padding required to deal with overscan and then include the layout that is normally used for the game.</p><p>Note that we use padding and not margin because we want to make the background to be a child of the <code class="literal">FrameLayout</code> so it fills the rest of the layout.</p><p>On the code side, the class for <code class="literal">GameTvFragment</code> is also quite simple:</p><div><pre class="programlisting">public class GameTvFragment extends GameFragment {
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_game_tv, container, false);
  }
}</pre></div><p>We extend <code class="literal">GameFragment</code> <a class="indexterm" id="id000594"/>and override the method <code class="literal">onCreateView</code> to use the <a class="indexterm" id="id000595"/>alternative layout we just created. Since the normal layout is imported, all the views keep their ids and nothing else is necessary for the <code class="literal">GameTvFragment</code> to work.</p><div><img alt="Dealing with overscan" src="img/B04757_10_06.jpg"/><div><p>GameFragment with extra padding to deal with overscan on TVs</p></div></div><p>The case of the main menu is a bit more complicated because of the background image being an <code class="literal">ImageView</code> inside the layout. We have two possible solutions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Import the layout as before and set the visibility of the background image to <code class="literal">GONE</code></li><li class="listitem" style="list-style-type: disc">Extract all the common layout to a new file and import it on both the mobile and the TV layouts</li></ul></div><p>The last option is easier to read and maintain, so we will do it that way.</p><p>We'll move all the layout <a class="indexterm" id="id000596"/>information to a new file named <code class="literal">fragment_main_menu_common.xml</code>, which is essentially all the layout except the background image, which <a class="indexterm" id="id000597"/>will go on each of the other layouts.</p><p>Then we create two files for the different layouts; the one for mobiles looks like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout 
  android:layout_width="match_parent"
  android:layout_height="match_parent" &gt;
  &lt;ImageView
    android:id="@+id/main_menu_bg"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scaleType="centerCrop"
    android:src="img/seamless_space_0"/&gt;

  &lt;include layout="@layout/fragment_main_menu_common" /&gt;
&lt;/FrameLayout&gt;</pre></div><p>Simple enough—we have replaced the top level view with a <code class="literal">FrameLayout</code>, added the background, and included the common elements.</p><p>The layout for Android TV is essentially the same, but we add margins to the imported layout:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout 
  android:layout_width="match_parent"
  android:layout_gravity="center"
  android:layout_height="match_parent"&gt;
  &lt;ImageView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scaleType="centerCrop"
    android:src="img/seamless_space_0"/&gt;

  &lt;include layout="@layout/fragment_main_menu_common"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginTop="27dp"
    android:layout_marginLeft="48dp"
    android:layout_marginRight="48dp"
    android:layout_marginBottom="27dp"/&gt;
&lt;/FrameLayout&gt;</pre></div><p>Note that, to make the margins work with an <code class="literal">include</code> tag, you also need to set the <code class="literal">width</code> and the <code class="literal">height</code> but, thankfully, Android Studio gives us a warning on that.</p><p>Going into the code, we will implement a different way of doing the layout replacement on the TV fragment. We will extract the layout resource id to a method that can be overridden on the extended class. We will do it like this for the <code class="literal">MainMenuFragment</code>. This technique is especially useful when your fragment does some work during <code class="literal">onCreateView</code>.</p><p>The code on <code class="literal">MainMenuFragment</code> <a class="indexterm" id="id000598"/>will be slightly modified to extract the layout <a class="indexterm" id="id000599"/>resource to a method:</p><div><pre class="programlisting">@Override
public final View onCreateView(LayoutInflater inflater, ViewGroup container,
  Bundle savedInstanceState) {
  return inflater.inflate(getLayoutResId(), container, false);
}

protected int getLayoutResId() {
  return R.layout.fragment_main_menu;
}</pre></div><p>Since we are extracting the layout because we do not want to override <code class="literal">onCreateView</code>, we are also declaring it final.</p><p>Now the <code class="literal">MainMenuTvFragment</code> class is just like this:</p><div><pre class="programlisting">public class MainMenuTvFragment extends MainMenuFragment {
  @Override
  protected int getLayoutResId() {
    return R.layout.fragment_main_menu_tv;
  }
}</pre></div><div><img alt="Dealing with overscan" src="img/B04757_10_07.jpg"/><div><p>The main menu before and after applying margins for overscan</p></div></div><p>Finally, we have to override the specific methods that create the fragments in <code class="literal">YassTvActivity</code>. At last some code is added into that class:</p><div><pre class="programlisting">public class YassTvActivity extends YassActivity {

  public void startGame() {
    // Navigate the the game fragment, which makes the start automatically
    navigateToFragment( new GameTvFragment());
  }

  protected Fragment createMenuFragment() {
    return new MainMenuTvFragment();
  }
}</pre></div><p>Now that we have illustrated <a class="indexterm" id="id000600"/>how to solve the problem of overscan in a few different <a class="indexterm" id="id000601"/>ways, let's move on to the last aspect: navigating the game with a controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec000105"/>Controller-based navigation</h2></div></div></div><p>The <a class="indexterm" id="id000602"/>most complex <a class="indexterm" id="id000603"/>requirement for Android TV is that all the options of the game must be accessible using a controller. If you are planning to release on console, you should think about it in advance and not make overly complicated menus or dialogs.</p><div><div><h3 class="title"><a id="note000108"/>Note</h3><p>For Android TV, all the options in the game must be accessible using a gamepad.</p></div></div><p>This is where the use of the native Android UI comes in handy. The Android framework handles directional navigation between layout elements automatically, so in principle you do not need to make any extra effort. However, you should still test the navigation with a controller to see if there are any navigation problems.</p><p>Users can also navigate your app using the arrow keys on a keyboard (the behavior is the same as when navigating with a D-Pad or trackball). Android provides a best-guess as to which view should be given focus in a given direction based on the layout of the views on screen. Sometimes, however, Android might guess wrong.</p><p>If the system does not pass focus to the view we want when navigating, we can override it by specifying which view should receive focus with the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusUp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusDown</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusLeft</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusRight</code></li></ul></div><p>Generally <a class="indexterm" id="id000604"/>speaking, you should always have the <code class="literal">A</code> button provide the positive action and the <code class="literal">B</code> button provide the <a class="indexterm" id="id000605"/>back action. Some controllers (such as the one on the ADT-1) provide dedicated back and home buttons, which should also work as such. All this is already handled by Android for you.</p><div><div><h3 class="title"><a id="note000109"/>Note</h3><p>The A button should always be a positive action and the B button should act as cancel/back.</p></div></div><p>In our case, there are a few problems with YASS that we have to address to provide full navigation. These problems are interesting because they are also common pitfalls.</p><p>If we run the game now we can see that the only focusable control on the main menu is the start button. It is not possible to navigate to any other view. This is a non-obvious particularity of the Android framework: <code class="literal">ImageView</code> is not focusable by default.</p><div><div><h3 class="title"><a id="note000110"/>Note</h3><p>ImageViews are not focusable by default.</p></div></div><p>Luckily we have defined a style for the round buttons. We can set <code class="literal">focusable</code> to true on the style and it will apply to all round buttons in the application:</p><div><pre class="programlisting">&lt;style name="iconButton" &gt;
  &lt;item name="android:background"&gt;@drawable/icon_button_bg&lt;/item&gt;
  &lt;item name="android:layout_width"&gt;@dimen/btn_round_size&lt;/item&gt;
  &lt;item name="android:layout_height"&gt;@dimen/btn_round_size&lt;/item&gt;
  &lt;item name="android:padding"&gt;@dimen/round_button_padding&lt;/item&gt;
  <strong>&lt;item name="android:focusable"&gt;true&lt;/item&gt;</strong>
&lt;/style&gt;</pre></div><p>We could also use <code class="literal">ImageButton</code> instead of <code class="literal">ImageView</code>, which is focusable by default, but I think making the <code class="literal">ImageView</code> focusable is clearer.</p><p>Now we can navigate around the menu with the controller and we can see that the default navigation Android provides is good. The next step is to check the dialogs.</p><p>There are a couple <a class="indexterm" id="id000606"/>of side effects when we interact with dialogs. Since they are not the standard Android dialogs, focus <a class="indexterm" id="id000607"/>can be moved out of the dialog. Also the <code class="literal">GameFragment</code> uses a game input controller that is taking care of all the events. We need to do some fixes.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec000106"/>Dialogs and controllers</h2></div></div></div><p>We are going to <a class="indexterm" id="id000608"/>solve the problems one at a <a class="indexterm" id="id000609"/>time. The first one is that focus can go to views outside the dialog.</p><p>This can be easily replicated by opening the game and moving the focus over the buttons on the background while the controller help dialog is present. The same issue is present on the quit dialog. In both cases, we can start a game with the dialog on top, which is wrong.</p><p>For touch, we solved that with the background view that acts as a click screen getting all the clicks and not letting the event pass to the other views behind it. For the controller navigation, however, we need something else.</p><p>There are several ways to fix this. One is to override the navigation on the layout; another is to ignore <code class="literal">onClick</code> events on the fragment if a dialog is being shown. We are going for yet another approach: passing the key events to the dialogs and filtering them there.</p><p>This approach also solves the second problem: while in a game, the input controller collects and consumes the controller presses.</p><p>Since all the <code class="literal">KeyEvent</code> and <code class="literal">MotionEvent</code> handling is done at activity level, we are going to do a small refactoring and move the logic of showing a dialog from the fragment to the activity.</p><p>We will move the method <code class="literal">showDialog</code> and the variable <code class="literal">mCurrentDialog</code> from <code class="literal">YassBaseFragment</code> to <code class="literal">YassActivity</code>.</p><p>In the base fragment we just have to replace the code of the <code class="literal">showDialog</code> method with this:</p><div><pre class="programlisting">public void showDialog (BaseCustomDialog newDialog, boolean dismissOtherDialog) {
  getYassActivity().showDialog(newDialog, dismissOtherDialog);
}</pre></div><p>The next step is to refactor the <code class="literal">dispatchKeyEvent</code> and <code class="literal">dispatchGenericMotionEvent</code> methods of <code class="literal">YassActivity</code> by making the dialog have preference over the input controller.</p><p>The updated <a class="indexterm" id="id000610"/>version of <code class="literal">dispatchKeyEvent</code> is as follows:</p><div><pre class="programlisting">@Override
public boolean dispatchKeyEvent (KeyEvent event) {
  if (mCurrentDialog != null &amp;&amp; mCurrentDialog.isShowing()) {
    if (mCurrentDialog.dispatchKeyEvent(event)) {
      return true;
    }
  }
  else if (mGamepadControllerListener != null) {
    if (mGamepadControllerListener.dispatchKeyEvent(event)) {
      return true;
    }
  }
  return super.dispatchKeyEvent(event);
}</pre></div><p>If the current dialog is not null and it is showing, then we call a method on it also called <code class="literal">dispatchKeyEvent</code>. If the key event was consumed (the method returned true) we return true.</p><p>Similarly we proceed <a class="indexterm" id="id000611"/>with the gamepad controller listener if no dialog is being shown. We also return true if the event was consumed by the gamepad controller.</p><p>Finally, if the event was not consumed yet, we call the super method, which will take care of the event normally. This includes moving the focus around the views.</p><p>Similarly, we will modify <code class="literal">dispatchGenericMotionEvent</code>. Although we are not going to override any of those events on our dialogs, if you plan to customize navigation with the directional keys you also have to take care of the analog joysticks and you will need this method for that:</p><div><pre class="programlisting">@Override
public boolean dispatchGenericMotionEvent(MotionEvent event) {
  if (mCurrentDialog != null &amp;&amp; mCurrentDialog.isShowing()) {
    if (mCurrentDialog.dispatchGenericMotionEvent(event)) {
      return true;
    }
  }
  else if (mGamepadControllerListener != null) {
    if (mGamepadControllerListener.dispatchGenericMotionEvent(event)) {
      return true;
    }
  }
  return super.dispatchGenericMotionEvent(event);
}</pre></div><p>Finally, we have to <a class="indexterm" id="id000612"/>update the handling of the back key:</p><div><pre class="programlisting">@Override
public void onBackPressed() {
  if (mCurrentDialog != null &amp;&amp; mCurrentDialog.isShowing()) {
    mCurrentDialog.dismiss();
    return;
  }
  final YassBaseFragment fragment = (YassBaseFragment) getFragmentManager().findFragmentByTag(TAG_FRAGMENT);
  if (fragment == null || !fragment.onBackPressed()) {
    super.onBackPressed();
  }
}</pre></div><p>If we are showing a dialog, we just dismiss it. Otherwise we keep the code we had before: we ask the current fragment to handle the back key press and, if the event was not consumed, we pass it to the parent class.</p><p>Note that passing the <a class="indexterm" id="id000613"/>back key event to the current fragment is important. In our game a back press while in the <code class="literal">GameFragment</code> means that we want to pause the game.</p><p>To complete this, we have to make the dialogs handle the keys. The default implementation on <code class="literal">BaseCustomDialog</code> is to just return false, meaning that the event was not consumed:</p><div><pre class="programlisting">public boolean dispatchKeyEvent(KeyEvent event) {
  return false;
}

public boolean dispatchGenericMotionEvent(MotionEvent event) {
  return false;
}</pre></div><p>We are going to do a very simple handling where we will only process the OK click when one of the buttons on the dialog is selected, but you could also prevent the focus from going to views outside the dialog with a more elaborate handling.</p><p>For <code class="literal">ControllerHelpDialog</code>, we will just dismiss it whenever an <strong>OK</strong> is pressed, regardless of which view is in focus:</p><div><pre class="programlisting">public boolean dispatchKeyEvent(KeyEvent event) {
  if (event.getKeyCode() == KeyEvent.KEYCODE_BUTTON_A ||
      event.getKeyCode() == KeyEvent.KEYCODE_ENTER ||
      event.getKeyCode() == KeyEvent.KEYCODE_DPAD_CENTER) {
    dismiss();
    return true;
  }
  return false;
}</pre></div><p>Note that, from the <a class="indexterm" id="id000614"/>controller point of view, the <strong>A</strong> <a class="indexterm" id="id000615"/>button is the <strong>OK</strong> button, but certain controllers also have the D-Pad center button and sometimes the <em>Enter</em> key, so we accept any of those key events as an <strong>OK</strong>.</p><p>In the case of the Quit dialog, the code is slightly different:</p><div><pre class="programlisting">public boolean dispatchKeyEvent(KeyEvent event) {
  if (event.getKeyCode() == KeyEvent.KEYCODE_BUTTON_A ||
      event.getKeyCode() == KeyEvent.KEYCODE_ENTER ||
      event.getKeyCode() == KeyEvent.KEYCODE_DPAD_CENTER) {
    if (findViewById(R.id.btn_resume).isFocused() ||
        findViewById(R.id.btn_exit).isFocused()) {
      // Return false, so a proper click is sent
      return false;
    }
    return true;
  }
  return false;
}</pre></div><p>In this dialog, whenever we get an OK event, we check if one of our buttons is focused. If that is the case, we return false, meaning that we let the upper level process it. That will pass the event to the activity, when it will be processed and sent back as a click.</p><p>If none of our actions are focused, we return true, meaning that we are consuming the event and nothing else should be done with it.</p><p>In any other case, we return false (again, not consuming the event) to let the activity handle the key event normally.</p><p>Finally, in the case of the pause and game over dialogs that are shown in the <code class="literal">GameFragment</code>, we do not need to do anything because the only item that is focusable on that UI is the pause button.</p><p>What we will do is set the pause button to not focusable and then let the system handle the keys:</p><div><pre class="programlisting">&lt;ImageView
  style="@style/iconButton"
  <strong>android:focusable="false"</strong>
  android:layout_gravity="top|right"
  android:id="@+id/btn_play_pause"
  android:layout_marginTop="@dimen/menu_margin"
  android:layout_marginRight="@dimen/menu_margin"
  android:src="img/pause" /&gt;</pre></div><p>Note that, while <code class="literal">ImageView</code> is <a class="indexterm" id="id000616"/>not focusable by default, we <a class="indexterm" id="id000617"/>have set that property at the style level, and we can always overwrite the value of the style in the definition of the layout.</p><p>With all this changes all the UI of our game is usable with a gamepad and we are finally ready to publish on Android TV.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00072"/>Beyond this book</h1></div></div></div><p>We made it! We have built a game from scratch using the Android SDK. We have built a game engine that has a separate <code class="literal">UpdateThread</code> and <code class="literal">DrawThread</code>, we have sprites that can move around, we have handled touch and gamepad controllers, and added collision detection, sound, and even particles.</p><p>We have also used the components of the Android framework to build our menus and dialogs and made use of the animation tools to make it more dynamic.</p><p>YASS also has achievements and leaderboards using Google Play Game Services and now it is ready to be played on Android TV as well.</p><p>At this point, there are a few things that can be done to improve the game and that can be a good exercise to help you move forward, if you feel like it. Some ideas are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spawn multiple waves with increasing difficulty</li><li class="listitem" style="list-style-type: disc">Include bigger asteroids that break in smaller parts when hit</li><li class="listitem" style="list-style-type: disc">Add ship selection: provide several ships with different characteristics (speed, fire ratio, and so on)</li><li class="listitem" style="list-style-type: disc">Implement power-ups like shields or improved lasers</li></ul></div><p>While this book focuses on the development of a game, there are other aspects of making a game that have been overlooked but are also very important. The most relevant of them are game design and monetization.</p><div><div><h3 class="title"><a id="note000111"/>Note</h3><p>Game design and monetization are key aspects of making a game.</p></div></div><p><strong>Game design</strong> is a discipline-independent from platform and code and it requires high-level considerations about the game itself. Game design is about making a game that is fun and engages the user. There are many books that are dedicated solely to this concept and it is beyond the scope of this book.</p><p><strong>Monetization</strong> is also a big topic nowadays. If you plan to release a game just for fun you do not need to worry about it, but if you mean to make some money out of it, it is something to be evaluated.</p><p>The main options to monetize a game are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Premium</strong>: Make it a paid game</li><li class="listitem" style="list-style-type: disc"><strong>Ads</strong>: Monetize the game by showing ads to the user, either banners or interstitials</li><li class="listitem" style="list-style-type: disc"><strong>In-App Purchases</strong>: Offer the user the chance to purchase items inside the game</li></ul></div><p>The advantage of making a paid game is that it is much simpler to build and it will give you fewer headaches.</p><p>Some examples of premium games that have done well on mobile are Monument Valley, Threes, and The Room (1 and 2).</p><p>The advantage of a free game, either with ads or In-App Purchases, is that the install barrier is the lowest there is. If someone is interested in the game, installing it is free. Paying for a game requires a conscious decision and many people will opt out, regardless of the price.</p><p>If you are planning to go the Free2Play road, be ready to worry about retention and conversion of the players. You will get familiar with terms like DAU, MAU, ARPU, and ARPPU, to name a few.</p><p>Some examples of successful free games with different monetization schemes are Candy Crush Saga, Clash of Clans, and Angry Birds.</p><p>Most studies will tell you that people make more money with In-App Purchases than with paid apps. While that it is true, creating a Free2Play game that monetizes well requires time and effort to tune it right; so does designing compelling In-App Purchases.</p><p>In my experience, making a good monetization design for a Free2Play game takes about as much time as making the game itself. If you do not design it carefully, you can get really low conversion rates, which turns into little or no revenue.</p><p>As a rule of thumb, do not push a monetization model in a game that does not feel right and invest your efforts into making the game fun.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec00073"/>Summary</h1></div></div></div><p>We have our game ready for Android TV. We have updated the manifest to provide an activity to launch from the Leanback interface as well as a banner to show on the UI, and we have marked it as a game. We also reviewed the permissions to be sure that the game will be available on Google Play for Android TV, mainly marking touchscreen capability and Leanback as requested but not required.</p><p>From the code point of view, we added some extra padding to all the screens when running on the TV, to make sure the important content is never cut off because of overscan, and we tweaked the code on the dialogs to make them work nicely with controllers.</p><p>Finally we mentioned some pointers about how to improve the game further and talked briefly about game design and monetization.</p><p>It is time to start making your own game. Good luck and have fun!</p></div>
<div><div><div><div><h1 class="title"><a id="appA"/>Appendix A. API Levels for Android Versions</h1></div></div></div><p>The <a class="indexterm" id="id000618"/>following table shows the API levels of different Android platform versions, along with the version code:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Platform Version</p>
</th><th style="text-align: left" valign="bottom">
<p>API Level</p>
</th><th style="text-align: left" valign="bottom">
<p>VERSION_CODE</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Android 5.1</p>
</td><td style="text-align: left" valign="top">
<p>22</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">LOLLIPOP_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 5.0</p>
</td><td style="text-align: left" valign="top">
<p>21</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">LOLLIPOP</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.4W</p>
</td><td style="text-align: left" valign="top">
<p>20</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KITKAT_WATCH</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.4</p>
</td><td style="text-align: left" valign="top">
<p>19</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KITKAT</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.3</p>
</td><td style="text-align: left" valign="top">
<p>18</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">JELLY_BEAN_MR2</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.2, 4.2.2</p>
</td><td style="text-align: left" valign="top">
<p>17</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">JELLY_BEAN_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.1, 4.1.1</p>
</td><td style="text-align: left" valign="top">
<p>16</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">JELLY_BEAN</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.0.3, 4.0.4</p>
</td><td style="text-align: left" valign="top">
<p>15</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ICE_CREAM_SANDWICH_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 4.0, 4.0.1, 4.0.2</p>
</td><td style="text-align: left" valign="top">
<p>14</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ICE_CREAM_SANDWICH</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 3.2</p>
</td><td style="text-align: left" valign="top">
<p>13</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">HONEYCOMB_MR2</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 3.1.x</p>
</td><td style="text-align: left" valign="top">
<p>12</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">HONEYCOMB_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 3.0.x</p>
</td><td style="text-align: left" valign="top">
<p>11</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">HONEYCOMB</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.3.4</p>
<p>Android 2.3.3</p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GINGERBREAD_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.3.2</p>
<p>Android 2.3.1</p>
<p>Android 2.3</p>
</td><td style="text-align: left" valign="top">
<p>9</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GINGERBREAD</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.2.x</p>
</td><td style="text-align: left" valign="top">
<p>8</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FROYO</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.1.x</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ECLAIR_MR1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.0.1</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ECLAIR_0_1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 2.0</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ECLAIR</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 1.6</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DONUT</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 1.5</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CUPCAKE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 1.1</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BASE_1_1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android 1.0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">BASE</code></p>
</td></tr></tbody></table></div></div></body></html>