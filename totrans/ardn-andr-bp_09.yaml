- en: Chapter 9. Bluetooth Low Energy Mobile Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to use most of the concepts we have learned throughout
    the book to control a mobile robot via an Android app. The robot will have two
    motors that we can control, and also an ultrasonic sensor in the front so that
    it can detect obstacles. The robot will also have a BLE chip so that it can receive
    commands from the Android app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following basic commands that you will need to
    control the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: Go forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go backward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the connection status to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following will be the major takeaways from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a mobile robot based on the Arduino platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a BLE module to the Arduino robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Android application to control the robot remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware and software requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first see what we need for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The base of this project is of course the robot itself. For this project, we
    used a DFRobot miniQ two-wheeled robot chassis. It comes with a round robot chassis,
    two DC motors, two wheels, and some screws and bolts so that you can mount multiple
    Arduino boards on it. You can basically use any equivalent robot chassis that
    has two wheels coupled with DC motors and on which you can mount Arduino-compatible
    boards.
  prefs: []
  type: TYPE_NORMAL
- en: To control the robot, we are actually going to use three different Arduino boards.
    The "brain" of the robot will be a simple Arduino Uno board. On top of that, we
    will use a DFRobot motor shield to control the two DC motors of the robot. And
    on top of these two boards, we will put a prototyping shield so that we can connect
    different modules to the robot.
  prefs: []
  type: TYPE_NORMAL
- en: To control the robot remotely, we will again use BLE. To give BLE connectivity
    to the robot, we used an Adafruit nRF8001 breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: To give the robot the ability to detect what is in front of it, we added an
    URM37 ultrasonic sensor to the project. As we will see, this sensor is really
    easy to interface with Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will also need some jumper wires to make the different connections
    between the robot, the sensor, and the Bluetooth module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of all of the hardware you will need for this project,
    along with links to these parts on the web:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno board ([http://www.dfrobot.com/index.php?route=product/product&search=uno&description=true&product_id=838](http://www.dfrobot.com/index.php?route=product/product&search=uno&description=true&product_id=838))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arduino motor shield ([http://www.dfrobot.com/index.php?route=product/product&path=35_39&product_id=59](http://www.dfrobot.com/index.php?route=product/product&path=35_39&product_id=59))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arduino prototyping shield ([http://www.dfrobot.com/index.php?route=product/product&product_id=55](http://www.dfrobot.com/index.php?route=product/product&product_id=55))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An nRF8001 breakout board ([https://www.adafruit.com/products/1697](https://www.adafruit.com/products/1697))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ultrasonic range sensor ([http://www.dfrobot.com/index.php?route=product/product&search=ultrasonic&description=true&page=1&product_id=53](http://www.dfrobot.com/index.php?route=product/product&search=ultrasonic&description=true&page=1&product_id=53))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ultrasonic sensor mounting kit ([http://www.dfrobot.com/index.php?route=product/product&product_id=322](http://www.dfrobot.com/index.php?route=product/product&product_id=322))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DFRobot miniQ chassis ([http://www.dfrobot.com/index.php?route=product/product&search=miniq&description=true&product_id=367](http://www.dfrobot.com/index.php?route=product/product&search=miniq&description=true&product_id=367))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 7.4 V battery ([http://www.dfrobot.com/index.php?route=product/product&product_id=489](http://www.dfrobot.com/index.php?route=product/product&product_id=489))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires ([https://www.adafruit.com/products/1957](https://www.adafruit.com/products/1957))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the software side, you will of course need the Arduino IDE. You will also
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A library for the nRF8001 chip ([https://github.com/adafruit/Adafruit_nRF8001](https://github.com/adafruit/Adafruit_nRF8001))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aREST library to send commands to the robot ([https://github.com/marcoschwartz/aREST](https://github.com/marcoschwartz/aREST))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are first going to assemble the robot itself, and then see how to connect
    the Bluetooth module and the ultrasonic sensor. To give you an idea of what you
    should end up with, the following is a front-view image of the robot when fully
    assembled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the hardware](img/0389OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the back of the robot when fully assembled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the hardware](img/0389OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first step is to assemble the robot chassis. To do so, you can watch the
    DFRobot assembly guide at [https://www.youtube.com/watch?v=tKakeyL_8Fg](https://www.youtube.com/watch?v=tKakeyL_8Fg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to attach the different Arduino boards and shields to the robot.
    Use the spacers found in the robot chassis kit to mount the Arduino Uno board
    first. Then put the Arduino motor shield on top of that. At this point, use the
    screw header terminals to connect the two DC motors to the motor shield. This
    is how it should look at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the hardware](img/0389OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, mount the prototyping shield on top of the motor shield.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to connect the BLE module and the ultrasonic sensor to the
    Arduino prototyping shield. The following is a schematic diagram showing the connections
    between the Arduino Uno board (done via the prototyping shield in our case) and
    the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the hardware](img/0389OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are now going to connect the BLE module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the module on the prototyping shield.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the power supply of the module as follows: **GND** goes to the prototyping
    shield''s **GND** pin, and **VIN** goes to the prototyping shield''s +5V.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, you need to connect the different wires responsible for the SPI
    interface: **SCK** to Arduino pin **13**, **MISO** to Arduino pin **12**, and
    **MOSI** to Arduino pin **11**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then connect the **REQ** pin to Arduino pin **10**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the **RDY** pin to Arduino pin **2** and the **RST** pin to
    Arduino pin **9**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the URM37 module, connect the **VCC** pin of the module to Arduino +5V,
    **GND** to **GND**, and the **PWM** pin to the Arduino **A3** pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To review the pin order on the URM37 module, you can check the official DFRobot
    documentation at [http://www.dfrobot.com/wiki/index.php?title=URM37_V3.2_Ultrasonic_Sensor_(SKU:SEN0001)](http://www.dfrobot.com/wiki/index.php?title=URM37_V3.2_Ultrasonic_Sensor_(SKU:SEN0001)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a close-up image of the prototyping shield with the BLE module
    connected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Configuring the hardware](img/0389OS_09_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Finally, connect the 7.4 V battery to the Arduino Uno board power jack. The
    battery is simply placed below the Arduino Uno board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to write a sketch to test the different functionalities of
    the robot, first without using Bluetooth. As the sketch is quite long, we will
    look at the code piece by piece. Before you proceed, make sure that the battery
    is always plugged into the robot. Now perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch starts by including the aREST library that we will use to control
    the robot via serial commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we declare which pins the motors are connected to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also declare which pin the ultrasonic sensor is connected to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create an instance of the aREST library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To store the distance data measured by the ultrasonic sensor, we declare a
    distance variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup()` function of the sketch, we first initialize serial communications
    that we will use to communicate with the robot for this test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also expose the distance variable to the REST API, so we can access it easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To control the robot, we are going to declare a whole set of functions that
    will perform the basic operations: going forward, going backward, turning on itself
    (left or right), and stopping. We will see the details of these functions in a
    moment; for now, we just need to expose them to the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also give the robot an ID and a name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `loop()` function of the sketch, we first measure the distance from
    the sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then handle the requests using the aREST library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will look at the functions for controlling the motors. They are all
    based on a function to control a single motor, where we need to set the motor
    pins, the speed, and the direction of the motor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Based on this function, we can now define the different functions to move the
    robot, such as `forward`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also define a `backward` function, simply inverting the direction of both
    motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the robot turn left, we simply make the motors rotate in opposite directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have a function to stop the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is also a function to make the robot turn right, which is not detailed
    here. Note that all of the code used in this chapter can be found in the GitHub
    repository of the book at [https://github.com/marcoschwartz/arduino-android-blueprints](https://github.com/marcoschwartz/arduino-android-blueprints).
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to test the robot. Before you do anything, ensure that the
    battery is always plugged into the robot. This will ensure that the motors are
    not trying to get power from your computer USB port, which could damage it.
  prefs: []
  type: TYPE_NORMAL
- en: Also place some small support at the bottom of the robot so that the wheels
    don't touch the ground. This will ensure that you can test all the commands of
    the robot without the robot moving too far from your computer, as it is still
    attached via the USB cable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can upload the sketch to your Arduino Uno board. Open the serial monitor
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should make both the wheels of the robot turn in the same direction. You
    can also try the other commands to move the robot to make sure they all work properly.
    Then, test the ultrasonic distance sensor by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get back the distance (in centimeters) in front of the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Try changing the distance by putting your hand in front of the sensor and typing
    the command again.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Arduino sketch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have made sure that the robot is working properly, we can write
    the final sketch that will receive the commands via Bluetooth. As the sketch shares
    many similarities with the test sketch, we are only going to see what is added
    compared to the test sketch. We first need to include more libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define which pins the BLE module is connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to create an instance of the BLE module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setup()` function of the sketch, we initialize the BLE chip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loop()` function, we check the status of the BLE chip and store it
    in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we detect that a device is connected to the chip, we handle the incoming
    request with the aREST library, which will allow us to use the same commands as
    before to control the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can now upload the code to your Arduino board, again by making sure that
    the battery is connected to the Arduino Uno board via the power jack. You can
    now move on to the development of the Android application to control the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Android app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android application that we will be creating will give us the opportunity
    to control the robot via BLE from the physical Android device. This application
    will have five basic controls, that is, **Forward**, **Backward**, **Left**, **Right**,
    and **Stop**. In addition, it will also show the BLE connection status and there
    will be a **Refresh** button that will allow us to refresh the Bluetooth callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume that you will have switched on the `Auto-Import` function within
    your preferences. If not, activate it by going to the **Auto-Import** preferences
    and selecting all the available options. The **Auto-Import** preferences are available
    on Mac and Windows as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, navigate to **Android Studio** > **Preferences** > **Editor** > **Auto-Import**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, navigate to **File** > **Settings** > **Editor** > **Auto-Import**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all the necessary settings in place, we will start off by creating a new
    project where we will choose the following within the **New Project** setup walkthrough:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: `Mobile Robot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum SDK**: `18`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: `Blank Activity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activity Name**: `RobotControlAc``tivity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: `arduinoandroid.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out the Android user interface and setting permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to make this project work, we will need to first go over to the Android
    `Manifest` file, which is available at `app` > `src` > `main` > `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this Android application uses BLE to connect the Android physical device
    to the robot, we will need to add the following permissions to the Android `Manifest`
    file. These permissions will allow the application to connect to the paired Bluetooth
    devices that have been discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next step that we will take is to set up the very basic Android layout file
    so that we can implement the app's functions and allow the user to activate the
    voice recognition intent.
  prefs: []
  type: TYPE_NORMAL
- en: In our project, we will navigate to the main layout file which can be accessed
    from `app` > `src` > `res` > `layout` > `activity_robot_control.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of layout formats with the Android user interface design,
    and in this particular case, we will be using a horizontal linear layout with
    a vertical linear layout as a child. Keeping these concepts in mind, we will replace
    the current code with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should end up with something that looks like the following
    screenshot. This is based on the LG Nexus 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying out the Android user interface and setting permissions](img/0389OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Coding the app's internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we want to start connecting our freshly designed Android user
    interface to the main Android code, and we will start doing this by opening the
    `RobotControlActivity.java` file, which is available at `app` > `src` > `main`
    > `java` > `package name` > `RobotControlActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by declaring the user interface element variables together
    with the main variable, which we could use for logging, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will declare all the necessary variables for the `BluetoothCallback` variable,
    where we will primarily declare the UUIDs associated with our specific BLE module,
    followed by the Bluetooth adapter variables and characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then proceed to the `onCreate()` method and connect the different user
    interface elements to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, we would like to send specific BLE messages to our robot when
    the user taps on the buttons, and in this part, we will be adding `onClickListeners`
    to our buttons which we have connected earlier to send the messages that we need
    to interface with the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we need to declare a new method, which we will name `writeConnectionData`.
    Its main role is writing the status of the Bluetooth callback to the connection
    status text view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is all the necessary Bluetooth callback which needs to take
    place in order to establish a connection between the Android physical device and
    BLE module on the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android application''s life cycle gives us the ability to add methods that
    can be activated at different parts of this cycle. The following `onStart()` and
    `onStop()`methods, which are invoked on starting and exiting the application respectively,
    allow us to conserve the device''s energy and memory resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to allow the starting, stopping, and restarting of Bluetooth scans,
    we need to declare methods to do these particular actions, which is the purpose
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of the Bluetooth callback is to connect to the right
    BLE device, and the following code helps the user to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: UUID parsing, unlike in the previous chapters, has been moved to a `utility`
    class in order to refactor the code and make it more readable. In order to create
    a `utility` class, we first need to right-click on our package name and create
    a new package called `Bluetooth`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will right-click on the new package, select **New** > **Java
    Class**, and name the new class as `BluetoothUtils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the preceding two steps, we will replace the code within the class with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you could go ahead, build, and run the project on an Android
    physical device running Android 4.3 with Bluetooth switched on.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the user interface further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have managed to finalize our code and assure ourselves that the user
    interface includes all the basic functionalities required to control the robot,
    we can proceed to improving our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will improve the user interface with two main actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new app icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling the user interface buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new app icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will download the image asset. It's available within the GitHub repository
    and also as a public download at [http://bit.ly/mobileroboticon](http://bit.ly/mobileroboticon).
  prefs: []
  type: TYPE_NORMAL
- en: You should navigate to the project tree, followed by a right-click on **app**.
  prefs: []
  type: TYPE_NORMAL
- en: When you right-click on **app**, create a new image asset by going to **New**
    > **Image Asset**.
  prefs: []
  type: TYPE_NORMAL
- en: You will then be shown an **Asset Studio** pop-up window, which will allow you
    to choose your very own image file. For optimization purposes, we recommend that
    you go for a `.png` file with a resolution of 144 pixels by 144 pixels. Android
    Studio automatically does all the resizing and resource creation to adapt your
    graphic to different screens.
  prefs: []
  type: TYPE_NORMAL
- en: Once you choose the `ic_launcher` image file that we have provided you with,
    you will be shown a screen with the icon in different sizes. Click on **Next**
    where you will see the screen with the launcher icons in different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: This screen warns you that previous files will be overwritten and shows you
    the image launcher file in a number of different resolutions once again. Click
    on **Finish.** Then compile the app, launch it on your physical device, and you
    should see something pleasant in your app tray and in the app's action bar.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the user interface buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final steps that we will be taking about are to modify our buttons and add
    some color to the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps required while creating the new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Drawable` folder with a new XML drawable file known as `button.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then connect the drawable resource file to the main Android layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Drawable` folder by right-clicking on the `res` folder, which is
    available at `App` > `src` > `main` > `res`.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the `Drawable` folder within the `res` folder, we need to once
    again right-click on the new `drawable` folder and navigate to **New** > **Drawable
    Resource File**.
  prefs: []
  type: TYPE_NORMAL
- en: Name the file `buttonshape` and type `shape` as the root element, followed by
    clicking on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `button.xml` file, replace the current code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the buttons have not been modified yet, so we will go to the
    robot control activity layout file, which is available at `app` > `main` > `res`
    > `layout` > `activity_robot_control.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Within this file, we will also be connecting the changes within the `buttonshape.xml`
    file to the main layout file, and we will be adding `margin` to the buttons so
    that there is enough spacing between the buttons for a presentable layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the following code to all the button elements to give them the
    `buttonshape` styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will add the margins by adding the following code to the **Connect**,
    **Backward**, and **Forward** buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the left and right buttons, we will add the following code since they''re
    within a different kind of layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have a layout that looks like the following screenshot
    on Nexus 4, which is more attractive and presentable to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the user interface buttons](img/0389OS_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to go further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android application can be further enhanced with more refined controls that
    could quantify the exact angle by which you would like the robot to turn left
    or right. We can also extract data from the ultrasonic sensor and display it within
    the Android application to get data about the proximity to obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Android application will definitely benefit from the addition
    of a **Connection** dialog that shows the user all the available BLE devices,
    and the user can choose the BLE Chip connected to the robot. This will enhance
    user experience and, at the same time, provide a more stable connection with the
    robot, especially if you're working in an environment surrounded by other BLE
    transmitters.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the reader can also go ahead and do further modifications
    to the user interface and layout to make the app even more attractive and presentable.
    Our main recommendation is to follow the design guidelines available at [http://developer.android.com](http://developer.android.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we managed to create our very own mobile robot together with
    a companion Android application that we can use to control our robot.
  prefs: []
  type: TYPE_NORMAL
- en: We achieved this step by step by setting up an Arduino-enabled robot and coding
    the companion Android application. It uses the BLE software and hardware of an
    Android physical device running on Android 4.3 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we will consider a more direct form of user interaction,
    by measuring our pulse rate using Android, Arduino, and a specific sensor.
  prefs: []
  type: TYPE_NORMAL
