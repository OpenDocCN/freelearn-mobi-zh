<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Placing Applications in Domains</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <em>Android Is Weird</em>, we introduced the zygote and that all applications, APKs in Android speak, emanate from the zygote just like services emanate from the <code class="literal">init</code> process. As such, they need to be labeled, as we did in the previous chapter. Recall that labeling is the same as placing a process in a domain of that label. Applications need to be labeled as well.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>APK<a id="id286" class="indexterm"/> is the file extension and format for installable application packages on Android. It's analogous to the desktop package formats like RPM (Redhat based) or DEB (Debian based).</p></div></div><p>In this chapter, we will learn to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Properly label application private data directories and their runtime contexts</li><li class="listitem" style="list-style-type: disc">Further examine zygote and methods to secure it</li><li class="listitem" style="list-style-type: disc">Discover how a finished <code class="literal">mac_permssions.xml</code> file assigns <code class="literal">seinfo</code> value</li><li class="listitem" style="list-style-type: disc">Create a new custom domain</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec55"/>The case to secure the zygote</h1></div></div></div><p>Android <a id="id287" class="indexterm"/>applications with elevated permissions and capabilities are spawned from the zygote. An example of this is the system server, a large process comprised of native and non-native code hosting a variety of services. The system server houses the activity manager, package manager, GPS feeds and so on. The system server also runs <a id="id288" class="indexterm"/>with a highly sensitive UID of <code class="literal">system</code> (<code class="literal">1000</code>). Also, many OEMs package what are known as <strong>system apps</strong>, which are standalone applications running with the <code class="literal">system</code> UID.</p><p>The zygote also spawns applications that do not need elevated permissions. All third-party applications represent this. Third party applications run as their own UID, separate from sensitive UIDs, such as <code class="literal">system</code>. Additionally, applications get spawned into various UIDs such as <code class="literal">media</code>, <code class="literal">nfc</code>, and so on. OEMs tend to define additional UIDs.</p><p>It's important<a id="id289" class="indexterm"/> to note that to get into a special UID, like <code class="literal">system</code>, you must be signed with the proper key. Android has four major keys used to sign applications: <code class="literal">media</code>, <code class="literal">platform</code>, <code class="literal">shared</code>, and <code class="literal">testkey</code>. They are located in <code class="literal">build/target/product/security</code>, along with a <code class="literal">README</code>.</p><p>According to the <code class="literal">README</code>, the key usage is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testkey</code>: A <a id="id290" class="indexterm"/>generic key for packages that do not otherwise specify a key.</li><li class="listitem" style="list-style-type: disc"><code class="literal">platform</code>: A <a id="id291" class="indexterm"/>test key for packages that are part of the core platform.</li><li class="listitem" style="list-style-type: disc"><code class="literal">shared</code>: A <a id="id292" class="indexterm"/>test key for things that are shared in the home/contacts process.</li><li class="listitem" style="list-style-type: disc"><code class="literal">media</code>: A<a id="id293" class="indexterm"/> test key for packages that are part of the media/download system.</li></ul></div><p>In order to request <code class="literal">system</code> UID for your application, you must be signed with the <code class="literal">platform</code> key. Possession of the private key is required to execute in these more privileged environments.</p><p>As you can see, we have applications executing at a variety of permission levels, and trust levels. We cannot trust third party applications since they are created by unknown entities, and we can trust things signed with our private keys. However, before SELinux, application permissions were still bound by the same DAC permission limitations as those identified in <a class="link" href="ch01.html" title="Chapter 1. Linux Access Controls">Chapter 1</a>, <em>Linux Access Controls</em>. Because of these properties, it makes the zygote a prime target for attack, as well as fortification with SELinux.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Fortifying the zygote</h1></div></div></div><p>Now that<a id="id294" class="indexterm"/> we have identified a problem with zygote, the next step is understanding how to get applications into appropriate domains. We need either SELinux policy or code changes to place new processes into a domain. In <a class="link" href="ch09.html" title="Chapter 9. Adding Services to Domains">Chapter 9,</a> <em>Adding Services to Domains</em>, we covered dynamic domain transitions with init-based services and the end of the chapter mentions the importance of the <code class="literal">exec()</code> syscall in the "Limitations on App Labeling" section. This is the trigger on which dynamic domain transitions occur. If there is no <code class="literal">exec</code> in the path, we would have to rely on code changes. However, one also has to consider the signing key in this security model, and there is no way in pure SELinux policy language to express the key the process was signed with.</p><p>Rather than exploring the whole zygote, we can dissect the following patches that introduce application labeling into Android. Additionally, we can discover how the introduced design meets the requirements of respecting the signing key, working within the design <a id="id295" class="indexterm"/>of SELinux and the zygote.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec39"/>Plumbing the zygote socket</h2></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <em>Android Is Weird</em>, we learned that the zygote listens for requests to spawn a new application from a socket. The first patch to examine is <a class="ulink" href="https://android-review.googlesource.com/#/c/31066/">https://android-review.googlesource.com/#/c/31066/</a>. This patch modifies three files in the base frameworks<a id="id296" class="indexterm"/> of Android. The first file is <code class="literal">Process.java</code> in the method <code class="literal">startViaZygote()</code>. This method <a id="id297" class="indexterm"/>is the main entry point for other methods with respect to building string arguments and passing them to the zygote with <code class="literal">zygoteSendArgsAndGetResult()</code>. The patch introduces a new argument called <code class="literal">seinfo</code>. Later on, we will see how this gets used. It appears that this patch is plumbing this new <code class="literal">seinfo</code> argument over the socket. Note that this code is called external to the zygote process.</p><p>The next file to look at in this patch is <code class="literal">ZygoteConnection.java</code>. This code executes from within the context. The patch starts off by declaring a string member variable <code class="literal">peerContext</code> in the <code class="literal">ZygoteConnection</code> class. In the constructor, this <code class="literal">peerContext</code> member is set to the value obtained from a call to <code class="literal">SELinux.getPeerContext(mSocket.getFileDescriptor())</code>.</p><p>Since the <code class="literal">LocalSocket</code> <code class="literal">mSocket</code> is a Unix domain socket under the hood, you can obtain the connected client's credentials. In this case, the call to <code class="literal">getPeerContext()</code> gets the client's security context, or in more formal terms, the process label. After the initialization, further down in method <code class="literal">runOnce()</code>, we see it being used in calls to <code class="literal">applyUidSecurityPolicy</code> and other <code class="literal">apply*SecurityPolicy</code> routines. The protected method <code class="literal">runOnce()</code> is called to read one start command from the socket and arguments. Eventually, after the <code class="literal">apply*SecurityPolicy</code> checks, it calls <code class="literal">forkandSpecialize()</code>. Each security policy check has been modified to use SELinux on top of the existing DAC security controls. If we review <code class="literal">applyUidSecurityPolicy</code>, we see they make the call:</p><div><pre class="programlisting">boolean allowed = SELinux.checkSELinuxAccess(peerSecurityContext, peerSecurityContext, "zygote", "specifyids");</pre></div><p>This is an example of a userspace leveraging mandatory access controls in what is known as an object manager. Additionally, a security check has been added for the mysterious <code class="literal">seinfo</code> string in the <code class="literal">applyseInfoSecurityPolicy()</code> method. All the security checks here for SELinux specify the target class <code class="literal">zygote</code>. So if we look into <code class="literal">sepolicy access_vectors</code>, we see the added class <code class="literal">zygote</code>. This is a custom class for Android and defines all the vectors checked in the security checks.</p><p>The last file we'll consider from this patch is <code class="literal">ActivityManagerService.java</code>. The <code class="literal">ActivityManager</code> is responsible for starting applications and managing their lifecycles. It's a consumer of the <code class="literal">Process.start</code> API and needs to specify <code class="literal">seinfo</code>. This patch is simple, and for now, just sends <code class="literal">null</code>. Later, we will see the patch enabling its use.</p><p>The next patch, <a class="ulink" href="https://android-review.googlesource.com/#/c/31063/">https://android-review.googlesource.com/#/c/31063/</a>, executes within the context of the Android Dalvik VM and is coded in the VM zygote process space. The <code class="literal">forkAndSpecialize()</code> we saw in <code class="literal">ZygoteConnection</code> ends up in this native routine. It enters using <code class="literal">static pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)</code>. This routine is responsible for creating the new process that becomes the application.</p><p>It begins<a id="id298" class="indexterm"/> with housekeeping code moving from Java to <a id="id299" class="indexterm"/>C and sets up the <code class="literal">niceName</code> and <code class="literal">seinfo</code> values as C-style strings. Eventually, the code calls <code class="literal">fork()</code> and the child process starts doing things, like executing <code class="literal">setgid</code> and <code class="literal">setuid</code>. The <code class="literal">uid</code> and <code class="literal">gid</code> values are specified to the zygote connection with the <code class="literal">Process.start</code> method. We also see a new call to <code class="literal">setSELinuxContext()</code>. As an aside, the order of these events is important here. If you set the SELinux context of the new process too early, the process would need additional capabilities in the new context to do things like <code class="literal">setuid</code> and <code class="literal">setgid</code>. However, those permissions are best left to the <code class="literal">zygote</code> domain, so the application domain we entered can be as minimal as possible.</p><p>Continuing, <code class="literal">setSELinuxContext</code> eventually calls <code class="literal">selinux_android_setcontext()</code>. Note that the <code class="literal">HAVE_SELINUX</code> conditional compilation macros were removed after this commit, but prior to the 4.3 release. Also note that <code class="literal">selinux_android_setcontext()</code> is defined in <code class="literal">libselinux</code>, so our journey will take us there. Here we see the mysterious <code class="literal">seinfo</code> is still being passed along.</p><p>The next patch to evaluate is <a class="ulink" href="https://android-review.googlesource.com/#/c/39601/">https://android-review.googlesource.com/#/c/39601/</a>. This patch actually passes a more meaningful <code class="literal">seinfo</code> value from the Java layer. Rather than being set to <code class="literal">null</code>, this patch introduces some parsing logic from an XML file, and passes this along to the <code class="literal">Process.start</code> method.</p><p>This patch modifies two major components: <code class="literal">PackageManager</code> and <code class="literal">installd</code>. <code class="literal">PackageManager</code> runs inside the <code class="literal">system_server</code>, and performs application installation. It maintains the state of all installed packages in the system. The second component, a service known as <code class="literal">installd</code>, is a very privileged root service that creates all the applications' private directories on disk. Rather than giving system server, and therefore <code class="literal">PackageManager</code>, the capability to create these directories, only <code class="literal">installd</code> has these permissions. Using this approach, even the system server cannot read data in your private data directories unless you make it world readable.</p><p>This patch is larger than the others, so we are only going to inspect the parts directly relevant to our discussion. We'll start by looking at <code class="literal">PackageManagerService.java</code>. This class is the package manager, proper for Android. In the constructor for <code class="literal">PackageManagerService()</code>, we see the addition of <code class="literal">mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</code>.</p><p>Based on the naming, we can conjecture that this method is looking for some type of policy configuration file, and if found, returns true, setting the <code class="literal">mFoundPolicyFile</code> member variable. We also see some calls to <code class="literal">createDataDirs</code> and <code class="literal">mInstaller.*</code> calls. These we can ignore, since those calls are headed to <code class="literal">installd</code>.</p><p>The next major portion adds the following:</p><div><pre class="programlisting">if (mFoundPolicyFile) {
  SELinuxMMAC.assignSeinfoValue(pkg);
}</pre></div><p>It's important <a id="id300" class="indexterm"/>to note that this code was added into<a id="id301" class="indexterm"/> the <code class="literal">scanPackageLI()</code> method. This method is called every time a package needs to be scanned for installation. So at a high level, if some policy file is found during service startup, then a <code class="literal">seinfo</code> value is assigned to the package.</p><p>The next file to look at is <code class="literal">ApplicationInfo.java</code>, a container class for maintaining meta information about a package. As we can see, the <code class="literal">seinfo</code> value is specified here for storage purposes. Additionally, there is some code for serializing and deserializing the class via the Android specific <code class="literal">Parcel</code> implementation.</p><p>At this point, we should have a closer look at the <code class="literal">SELinuxMMAC.java</code> code to confirm our understanding of what's going on. The class starts by declaring two locations for policy files.</p><div><pre class="programlisting">// Locations of potential install policy files.
private static final File[] INSTALL_POLICY_FILE = {
  new File(Environment.getDataDirectory(), "system/mac_permissions.xml"),
  new File(Environment.getRootDirectory(), "etc/security/mac_permissions.xml"),
  null };</pre></div><p>According to this, policy files can exist in two locations- <code class="literal">/data/system/mac_permissions.xml</code> and <code class="literal">/system/etc/security/mac_permissions.xml</code>. Eventually, we see the call from <code class="literal">PackageManagerService</code> initialization to the method defined in the class <code class="literal">readInstallPolicy()</code>, which eventually reduces to a call of:</p><div><pre class="programlisting">private static boolean readInstallPolicy(File[] policyFiles) {
  FileReader policyFile = null;
  int i = 0;
  while (policyFile == null &amp;&amp; policyFiles != null &amp;&amp; policyFiles[i] != null) {
    try {
      policyFile = new FileReader(policyFiles[i]);
      break;
    } catch (FileNotFoundException e) {
      Slog.d(TAG,"Couldn't find install policy " + policyFiles[i].getPath());
    }
  i++;
  }
...</pre></div><p>With <code class="literal">policyFiles</code> set to <code class="literal">INSTALL_POLICY_FILE</code>, this code uses the array to find a file at the specified locations. It is priority based, with the <code class="literal">/data</code> location taking precedence over <code class="literal">/system</code>. The rest of the code in this method looks like parsing logic and fills up two<a id="id302" class="indexterm"/> hash tables that were defined in the class declaration:</p><div><pre class="programlisting">// Signature seinfo values read from policy.
private static final HashMap&lt;Signature, String&gt; sSigSeinfo =
new HashMap&lt;Signature, String&gt;();
// Package name seinfo values read from policy.
private static final HashMap&lt;String, String&gt; sPackageSeinfo =
new HashMap&lt;String, String&gt;();</pre></div><p>The <code class="literal">sSigSeinfo</code> maps <code class="literal">Signatures</code>, or signing keys, to <code class="literal">seinfo</code> strings. The other map, <code class="literal">sPackageSeinfo</code> maps a package name to a string.</p><p>At this <a id="id303" class="indexterm"/>point, we can read some formatted XML from the <code class="literal">mac_permissions.xml</code> file and create internal mappings from signing key to <code class="literal">seinfo</code> and package name to <code class="literal">seinfo</code>.</p><p>The other call from <code class="literal">PackageManagerService</code> into this class came from <code class="literal">void assignSeinfoValue(PackageParser.Package pkg)</code>.</p><p>Let's investigate what this method can do. It starts by checking if the application is system UID or a system installed app. In other words, it checks whether the application is a third-party application:</p><div><pre class="programlisting">if (((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) ||
((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {</pre></div><p>This code has subsequently been dropped by Google, and was initially a requirement for merge. We can, however, continue our evaluation. The code loops over all the signatures in the package, and checks against the hash table. If it is signed with something in that map, it uses the associated <code class="literal">seinfo</code> value. The other case is that it matches by package name. In either case, the package's <code class="literal">ApplictionInfo</code> class <code class="literal">seinfo</code> value is updated to reflect this and be used elsewhere by <code class="literal">installd</code> and zygote application spawn:</p><div><pre class="programlisting">// We just want one of the signatures to match.
for (Signature s : pkg.mSignatures) {
  if (s == null)
    continue;
  if (sSigSeinfo.containsKey(s)) {
    String seinfo = pkg.applicationInfo.seinfo = sSigSeinfo.get(s);
    if (DEBUG_POLICY_INSTALL)
      Slog.i(TAG, "package (" + pkg.packageName +
        ") labeled with seinfo=" + seinfo);
    return;
    }
  }
  // Check for seinfo labeled by package.
  if (sPackageSeinfo.containsKey(pkg.packageName)) {
    String seinfo = pkg.applicationInfo.seinfo = sPackageSeinfo.get(pkg.packageName);
    if (DEBUG_POLICY_INSTALL)
      Slog.i(TAG, "package (" + pkg.packageName +
        ") labeled with seinfo=" + seinfo);
      return;
    }
  }
}</pre></div><p>As an aside, what is merged into mainline AOSP and what is maintained in the NSA Bitbucket repositories is a bit different. The NSA has additional controls in these policy files<a id="id304" class="indexterm"/> that can cause an application installation to abort. Google<a id="id305" class="indexterm"/> and the NSA are "forked" over this issue, so to speak. In the NSA versions of <code class="literal">SELinuxMMAC.java</code>, you can specify that applications matching a specific signature or package name are allowed to have certain sets of Android-level permissions. For instance, you can block all applications from being installed that request <code class="literal">CAMERA</code> permissions or block applications signed with certain keys. This also highlights how important it can be to find patches within large code bases and quickly come up to speed on how projects evolve, which can often seem daunting.</p><p>The last file in this patch for us to consider is <code class="literal">ActivityManagerService.java</code>. This patch replaces the null with <code class="literal">app.info.seinfo</code>. After all that work and all that plumbing, we finally have the mystical <code class="literal">seinfo</code> value fully parsed, associated per application package, and sent along to the zygote for use in <code class="literal">selinux_android_setcontext()</code>.</p><p>Now it would benefit us to sit back and think about some of the properties we wanted to achieve in labeling applications. One of them is to somehow couple a security context with the application signing key, and this is precisely the main benefit of <code class="literal">seinfo</code>. This is a highly sensitive and trusted string associated value of a signing key. The actual contents of the string <a id="id306" class="indexterm"/>are arbitrary and dictated in <code class="literal">mac_permissions.xml</code>, which is the next stop on our adventure.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec40"/>The mac_permissions.xml file</h2></div></div></div><p>The <code class="literal">mac_permissions.xml</code> file<a id="id307" class="indexterm"/> has a very confusing<a id="id308" class="indexterm"/> name. Expanded, the name is MAC permissions. However, its major mainline functionality is to map a signing key to a <code class="literal">seinfo</code> string. Secondarily, it can also be used to configure a non-mainstream install-time permission-checking feature, known as install time MMAC. MMAC controls are part of the NSA's work to implement mandatory access controls in the middleware layer. MMAC stands for "Middleware Mandatory Access Controls". Google has not merged any of the MMAC features. However, since we used the NSA Bitbucket repositories, our code base contains these features.</p><p>The <code class="literal">mac_permissions.xml</code> is an XML file, and should adhere to the following rules, where italicized portions are only supported on NSA branches:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A signature is a hex encoded X.509 certificate and is required for each signer tag.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">&lt;signer signature="" &gt;</code> element may have multiple child elements:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">allow-permission</code>: It produces a set of maximal allowed permissions (whitelist)</li><li class="listitem" style="list-style-type: disc"><code class="literal">deny-permission</code>: It produces a blacklist of permissions to deny</li><li class="listitem" style="list-style-type: disc"><code class="literal">allow-all</code>: It is a wildcard tag that will allow every permission requested</li><li class="listitem" style="list-style-type: disc"><code class="literal">package</code>: It is a complex tag which defines allow, deny, and wildcard sub-elements for a specific package name protected by the signature</li></ul></div></li><li class="listitem" style="list-style-type: disc">Zero or more global <code class="literal">&lt;package name=""&gt;</code> tags are allowed. These tags allow a policy to be set outside any signature for specific package names.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">&lt;default&gt;</code> tag is allowed that can contain install policy for all apps not signed with a previously listed cert and not having a per package global policy.</li><li class="listitem" style="list-style-type: disc">Unknown tags at any level are skipped.</li><li class="listitem" style="list-style-type: disc">Zero or more signer tags are allowed.</li><li class="listitem" style="list-style-type: disc">Zero or more package tags are allowed per signer tag.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">&lt;package name=""&gt;</code> tag may not contain another <code class="literal">&lt;package name=""&gt;</code> tag. If found, it's skipped.</li><li class="listitem" style="list-style-type: disc">When multiple sub-elements appear for a tag, the following logic is used to ultimately determine the type of enforcement:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A blacklist is used if at least one deny-permission tag is found.</li><li class="listitem" style="list-style-type: disc">A whitelist is used, if not a blacklist, and at least one allow-permission tag is found.</li><li class="listitem" style="list-style-type: disc">A wildcard (accept all permissions) policy is used if not a blacklist and not a whitelist, and at least one allow-all tag is present.</li><li class="listitem" style="list-style-type: disc">If a <code class="literal">&lt;package name=""&gt;</code> sub-element is found, then that sub-element's policy is used according to the earlier logic and overrides any signature global policy type.</li><li class="listitem" style="list-style-type: disc">In order for a policy stanza to be enforced, at least one of the preceding situations must apply. Meaning, empty signer, default or package tags will not be accepted.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Each <code class="literal">signer/default/package</code> (global or attached to a signer) tag is allowed <a id="id309" class="indexterm"/>to contain one <code class="literal">&lt;seinfo value=""/&gt;</code> tag. This tag represents additional info that each app can use in setting an SELinux security context on the eventual process.</li><li class="listitem" style="list-style-type: disc">Strict<a id="id310" class="indexterm"/> enforcing of any XML stanza is not enforced in most cases. This mainly applies to duplicate tags, which are allowed. In the event that a tag already exists, the original tag is replaced.</li><li class="listitem" style="list-style-type: disc">There are also no checks on the validity of permission names. Although valid Android permissions are expected, nothing prevents unknowns.</li><li class="listitem" style="list-style-type: disc">Following are the enforcement decisions:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All signatures used to sign an app are checked for policy according to signer tags. However, only one of the signature policies has to pass.</li><li class="listitem" style="list-style-type: disc">In the event that none of the signature policies pass, or none even match, then a global package policy is sought. If found, this policy mediates the install.</li><li class="listitem" style="list-style-type: disc">The default tag is consulted last, if needed.</li><li class="listitem" style="list-style-type: disc">A local package policy always overrides any parent policy.</li><li class="listitem" style="list-style-type: disc">If none of the cases apply, then the app is denied.</li></ul></div></li></ul></div><p>The following examples ignore the Install MMAC support and focus on the mainline usage of <code class="literal">seinfo</code> mapping. The following is an example of stanza mapping all things signed with the platform key to <code class="literal">seinfo</code> value platform:</p><div><pre class="programlisting">&lt;!-- Platform dev key in AOSP --&gt;
&lt;signer signature="@PLATFORM" &gt;
  &lt;seinfo value="platform" /&gt;
&lt;/signer&gt;</pre></div><p>Here is an example mapping all things signed with the release key to the release domain with the exception of the browser. The browser gets assigned a <code class="literal">seinfo</code> value of <code class="literal">browser</code>, as follows:</p><div><pre class="programlisting">&lt;!-- release dev key in AOSP --&gt;
&lt;signer signature="@RELEASE" &gt;
  &lt;seinfo value="release" /&gt;
  &lt;package name="com.android.browser" &gt;
  &lt;seinfo value="browser" /&gt;
  &lt;/package&gt;
&lt;/signer&gt;
...</pre></div><p>Anything with an unknown key, gets mapped to the default tag:</p><div><pre class="programlisting">...
&lt;!-- All other keys --&gt;
&lt;default&gt;
  &lt;seinfo value="default" /&gt;
&lt;/default&gt;</pre></div><p>The<a id="id311" class="indexterm"/> signing tags are of interest, the <code class="literal">@PLATFORM</code> and <code class="literal">@RELEASE</code> are special processing strings used during build. Another mapping file maps<a id="id312" class="indexterm"/> these to actual key values. The file that is processed and placed onto the device has all key references replaced with hex encoded public keys rather than these placeholders. It also has all whitespace and comments stripped to reduce size. Let's take a look by pulling the built file from the device and formatting it.</p><div><pre class="programlisting">
<strong>$ adb pull /system/etc/security/mac_permissions.xml</strong>
<strong>$ xmllint --format mac_permissions.xml</strong>
</pre></div><p>Now, scroll to the top of the formatted output; you should see the following:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!-- AUTOGENERATED FILE DO NOT MODIFY --&gt;
&lt;policy&gt;
  &lt;signer signature="308204ae30820396a003020102020900d2cba57296ebebe2300d06092a864886f70d0101050500308196310b300906035504061302555331133...
dec513c8443956b7b0182bcf1f1d"&gt;
    &lt;allow-all/&gt;
    &lt;seinfo value="platform"/&gt;
  &lt;/signer&gt;</pre></div><p>Notice that <code class="literal">signature=@PLATFORM</code> is now a hex string. This hex string is a valid X509 certificate.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec41"/>keys.conf</h2></div></div></div><p>The <a id="id313" class="indexterm"/>actual magic doing the mapping from <code class="literal">signature=@PLATFORM</code> in <code class="literal">mac_permissions.xml</code> is <code class="literal">keys.conf</code>. This configuration file allows<a id="id314" class="indexterm"/> you to map a pem encoded x509 to an arbitrary string. The convention is to start them with <code class="literal">@</code>, but this is not enforced. The format of the file is based on the Python config parser and contains sections. The section names are the tags in the <code class="literal">mac_permissions.xml</code> file you wish to replace with key values. The platform example is:</p><div><pre class="programlisting">[@PLATFORM]
ALL : $DEFAULT_SYSTEM_DEV_CERTIFICATE/platform.x509.pem</pre></div><p>In Android, when you build, you can have three levels of builds: <code class="literal">engineering</code>, <code class="literal">userdebug</code>, or <code class="literal">user</code>. In the <code class="literal">keys.conf</code> file, you can associate a key to be used for all levels with the section attribute <code class="literal">ALL</code>, or you can assign different keys per level. This is helpful when building release or user builds with very special release keys. We see an example of this in the <code class="literal">@RELEASE</code> section:</p><div><pre class="programlisting">[@RELEASE]
ENG       : $DEFAULT_SYSTEM_DEV_CERTIFICATE/testkey.x509.pem
USER      : $DEFAULT_SYSTEM_DEV_CERTIFICATE/testkey.x509.pem
USERDEBUG : $DEFAULT_SYSTEM_DEV_CERTIFICATE/testkey.x509.pem</pre></div><p>The file also allows the use of environment variables through the traditional <code class="literal">$</code> special character. The default location for the pem files is <code class="literal">build/target/product/security</code>. However, you should <em>never</em> use these keys for a user release build. These keys are the AOSP test keys and are public! By doing so, anyone can use the system key to sign their app and gain system privilege. The <code class="literal">keys.conf</code> file is only used during the build and is not located on the system.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec42"/>seapp_contexts</h2></div></div></div><p>So far, we<a id="id315" class="indexterm"/> have looked at how a finished <code class="literal">mac_permssions.xml</code> file assigns the <code class="literal">seinfo</code> value. Now we should address how the labeling <a id="id316" class="indexterm"/>is actually configured and utilizes this value. The labeling of applications is managed in another configuration file, <code class="literal">seapp_contexts</code>. Like <code class="literal">mac_permissions.xml</code>, it is loaded to the device. However, the default location is <code class="literal">/seapp_contexts</code>. The format of <code class="literal">seapp_contexts</code> is the <code class="literal">key=value</code> pair mappings per line, adhering to the following rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Input selectors:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isSystemServer</code> (boolean)</li><li class="listitem" style="list-style-type: disc"><code class="literal">user</code> (string)</li><li class="listitem" style="list-style-type: disc"><code class="literal">seinfo</code> (string)</li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code> (string)</li><li class="listitem" style="list-style-type: disc"><code class="literal">sebool</code> (string)</li></ul></div></li><li class="listitem" style="list-style-type: disc">Input <a id="id317" class="indexterm"/>selector rules:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isSystemServer=true</code> can only be used once.</li><li class="listitem" style="list-style-type: disc">An<a id="id318" class="indexterm"/> unspecified <code class="literal">isSystemServer</code> defaults to false.</li><li class="listitem" style="list-style-type: disc">An unspecified string selector will match any value.</li><li class="listitem" style="list-style-type: disc">A user string selector that ends in <code class="literal">*</code> will perform a prefix match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">user=_app</code> will match any regular app UID.</li><li class="listitem" style="list-style-type: disc"><code class="literal">user=_isolated</code> will match any isolated service UID.</li><li class="listitem" style="list-style-type: disc">All specified input selectors in an entry must match (logical AND).</li><li class="listitem" style="list-style-type: disc">Matching is case-insensitive.</li><li class="listitem" style="list-style-type: disc">Precedence rules in order:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><code class="literal">isSystemServer=true</code> before <code class="literal">isSystemServer=false</code></li><li class="listitem" style="list-style-type: none">Specified <code class="literal">user=</code> string before unspecified <code class="literal">user=</code> string</li><li class="listitem" style="list-style-type: none">Fixed the <code class="literal">user=</code> string before the <code class="literal">user=</code> prefix (ending in <code class="literal">*</code>)</li><li class="listitem" style="list-style-type: none">Longer <code class="literal">user=</code> prefix before shorter <code class="literal">user=</code> prefix</li><li class="listitem" style="list-style-type: none">Specified <code class="literal">seinfo=</code> string before unspecified <code class="literal">seinfo=</code> string.</li><li class="listitem" style="list-style-type: none">Specified <code class="literal">name=</code> string before unspecified <code class="literal">name=</code> string.</li><li class="listitem" style="list-style-type: none">Specified <code class="literal">sebool=</code> string before unspecified <code class="literal">sebool=</code> string.</li></ul></div></li></ul></div></li><li class="listitem" style="list-style-type: disc">Outputs:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">domain</code> (string): It specifies the process domain for the application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code> (string): It specifies the disk label for the applications' private data directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">levelFrom</code> (string; one of <code class="literal">none</code>, <code class="literal">all</code>, <code class="literal">app</code>, or <code class="literal">user</code>): It gives the MLS specifier.</li><li class="listitem" style="list-style-type: disc"><code class="literal">level</code> (string): It shows the hardcoded MLS value.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Output rules:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Only entries that specify <code class="literal">domain=</code> will be used for app process labeling.</li><li class="listitem" style="list-style-type: disc">Only entries that specify <code class="literal">type=</code> will be used for app directory labeling.</li><li class="listitem" style="list-style-type: disc"><code class="literal">levelFrom=user</code> is only supported for <code class="literal">_app</code> or <code class="literal">_isolated</code> UIDs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">levelFrom=app</code> or <code class="literal">levelFrom=all</code> is only supported for <code class="literal">_app</code> UIDs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">level</code> may be used to specify a fixed level for any UID.</li></ul></div></li></ul></div><p>During<a id="id319" class="indexterm"/> application spawn, this file is used by the <code class="literal">selinux_android_setcontext()</code> and <code class="literal">selinux_android_setfilecon2()</code> functions to look<a id="id320" class="indexterm"/> up the proper application domain or filesystem context, respectively. The source for these can be found in <code class="literal">external/libselinux/src/android.c</code> and are recommended reads. For example, this entry places all applications with UID <code class="literal">bluetooth</code> in the <code class="literal">bluetooth</code> domain with a data directory label of <code class="literal">bluetooth_data_file</code>:</p><div><pre class="programlisting">user=bluetooth domain=bluetooth type=bluetooth_data_file</pre></div><p>This example places all third party or "default" applications into a process domain of <code class="literal">untrusted_app</code> and a data directory of <code class="literal">app_data_file</code>. It additionally uses MLS categories of <code class="literal">levelFrom=app</code> to help provide additional MLS-based separations.</p><div><pre class="programlisting">user=_app domain=untrusted_app type=app_data_file levelFrom=app</pre></div><p>Currently, this feature is experimental as this breaks some known application compatibility issues. At the time of this writing, this was a hot item of focus for both Google and NSA engineers. Since it is experimental, let's validate its functionality and then disable it.</p><p>We have not installed any third party applications yet, so we'll need to do so in order to experiment. FDroid is a useful place to find third party applications, so let's download something from there and install it. We can use the <code class="literal">0xbenchmark</code> application located at <a class="ulink" href="https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark">https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark</a> with an APK at <a class="ulink" href="https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk">https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk</a>, as follows:</p><div><pre class="programlisting">
<strong>$ wget https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk</strong>
<strong>$ adb install org.zeroxlab.zeroxbenchmark_9.apk </strong>
<strong>567 KB/s (1193455 bytes in 2.052s)</strong>
<strong>pkg: /data/local/tmp/org.zeroxlab.zeroxbenchmark_9.apk</strong>
<strong>Success</strong>
</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Check <code class="literal">logcat</code> for the install time <code class="literal">seinfo</code> value:</p><div><pre class="programlisting">
<strong>$ adb logcat | grep SELinux</strong>
<strong>I/SELinuxMMAC( 2557): package (org.zeroxlab.zeroxbenchmark) installed with seinfo=default</strong>
</pre></div></div></div><p>From your UDOO, launch the <code class="literal">0xbenchmark</code> APK. We should see it running with its label in <code class="literal">ps</code>:</p><div><pre class="programlisting">
<strong>$ adb shell ps -Z | grep untrusted</strong>
<strong>u:r:untrusted_app:s0:c40,c256 u0_a40 17890 2285 org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>Notice <a id="id321" class="indexterm"/>the level portion of the context string <code class="literal">s0:c40,c256</code>. These categories were created with the <code class="literal">level=app</code> setting from <code class="literal">seapp_contexts</code>.</p><p>To <a id="id322" class="indexterm"/>disable it, we could simply remove the key-value pair for level from the entry in <code class="literal">seapp_contexts</code>, or we could leverage the <code class="literal">sebool</code> conditional assignment. Let's use the Boolean approach. Modify the sepolicy <code class="literal">seapp_contexts</code> file so the existing <code class="literal">untrusted_app</code> entry is modified, and a new one is added. Change <code class="literal">user=_app domain=untrusted_app type=app_data_file</code> to <code class="literal">user=_app sebool=app_level domain=untrusted_app type=app_data_file levelFrom=app</code>.</p><p>Build that with <code class="literal">mmm external/sepolicy</code>, as follows:</p><div><pre class="programlisting">
<strong>Error:</strong>
<strong>out/host/linux-x86/bin/checkseapp -p out/target/product/udoo/obj/ETC/sepolicy_intermediates/sepolicy -o out/target/product/udoo/obj/ETC/seapp_contexts_intermediates/seapp_contexts out/target/product/udoo/obj/ETC/seapp_contexts_intermediates/seapp_contexts.tmp</strong>
<strong>Error: Could not find selinux boolean "app_level" on line: 42 in file: out/target/product/udoo/obj/ETC/seapp_contexts_intermediates/seapp_contexts</strong>
<strong>Error: Could not validate</strong>
</pre></div><p>Well, there was a build error complaining about not finding the <code class="literal">selinux</code> Boolean on line 42 of <code class="literal">seapp_contexts</code>. Let's attempt to correct the issue by declaring the Boolean. In <code class="literal">app.te</code>, add: <code class="literal">bool app_level false;</code>. Now push the newly built <code class="literal">seapp_contexts</code> and sepolicy file to the device and trigger a dynamic reload:</p><div><pre class="programlisting">
<strong>$ adb push $OUT/root/sepolicy /data/security/current/</strong>
<strong>$ adb push $OUT/root/seapp_contexts /data/security/current/</strong>
<strong>$ adb shell setprop selinux.reload_policy 1</strong>
</pre></div><p>We can verify that the Boolean exists by:</p><div><pre class="programlisting">
<strong>$ adb shell getsebool -a | grep app_level</strong>
<strong>app_level --&gt; off</strong>
</pre></div><p>Due to design limitations, we need to uninstall and reinstall the application:</p><div><pre class="programlisting">
<strong>$ adb uninstall org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>Re-install <a id="id323" class="indexterm"/>and check the context of the process <em>after</em> launching it:</p><div><pre class="programlisting">
<strong>$ adb shell ps -Z | grep untrusted</strong>
<strong>u:r:untrusted_app:s0:c40,c256 u0_a40 17890 2285 org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>Great! It <a id="id324" class="indexterm"/>failed. After some debugging, we discovered the source of the issue is that the path <code class="literal">/data/security</code> is not world searchable, causing a DAC permissions failure.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>We found this by printing off the result and error codes in <code class="literal">android.c</code> where we saw the <code class="literal">fopen</code> on <code class="literal">seapp_contexts_file[]</code> array (files in priority order) while checking the result of <code class="literal">fp = fopen(seapp_contexts_file[i++], "r")</code> in <code class="literal">selinux_android_seapp_context_reload()</code> and using <code class="literal">selinux_log()</code> to dump the data to <code class="literal">logcat</code>.</p></div></div><div><pre class="programlisting">
<strong>$ adb shell ls -la /data | grep security</strong>
<strong>drwx------ system system 1970-01-04 00:22 security</strong>
</pre></div><p>Remember the <code class="literal">set selinux</code> context occurs after the UID switch, so we need to make it searchable for others. We can fix the permissions on the UDOO <code class="literal">init.rc</code> script by changing <code class="literal">device/fsl/imx6/etc/init.rc</code>. Specifically, change the line <code class="literal">mkdir /data/security 0700 system system</code> to <code class="literal">mkdir /data/security 0711 system system</code>. Build and flash the <code class="literal">bootimage</code>, and try the context test again.</p><div><pre class="programlisting">
<strong>$ adb uninstall org.zeroxlab.zeroxbenchmark</strong>
<strong>$ adb install ~/org.zeroxlab.zeroxbenchmark_9.apk</strong>
<strong>&lt;launch apk&gt;</strong>
<strong>$ adb shell ps -Z | grep org.zeroxlab.zeroxbenchmark</strong>
<strong>u:r:untrusted_app:s0 u0_a40 3324 2285 org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>So far, we've demonstrated how to use the <code class="literal">sebool</code> option on <code class="literal">seapp_contexts</code> to disable the MLS categories. It's important to note that when changing categories or types on APKs, it is required to remove and install the APK, or you will orphan the process from its data directory because it won't have access permissions under most circumstances.</p><p>Next, let's take this APK, uninstall it, and assign it a unique domain by changing its <code class="literal">seinfo</code> string. Typically, you use this feature to take a set of applications signed with a common key and get them into a custom domain to do custom things. For example, if you're an OEM, you may need to allow custom permissions to third party applications that are not signed with an OEM controlled key. Start by uninstalling the APK:</p><div><pre class="programlisting">
<strong>$ adb uninstall org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>Create a new entry in <code class="literal">mac_permissions.xml</code> by adding:</p><div><pre class="programlisting">
<strong>&lt;signer signature="@BENCHMARK" &gt;</strong>
<strong>&lt;allow-all /&gt;</strong>
<strong>&lt;seinfo value="benchmark" /&gt;</strong>
<strong>&lt;/signer&gt;</strong>
</pre></div><p>Now <a id="id325" class="indexterm"/>we need to get a pem file for <code class="literal">keys.conf</code>. So unpackage<a id="id326" class="indexterm"/> the APK and extract the public certificate:</p><div><pre class="programlisting">
<strong>$ mkdir tmp</strong>
<strong>$ cd tmp</strong>
<strong>$ unzip ~/org.zeroxlab.zeroxbenchmark_9.apk</strong>
<strong>$ cd META-INF/</strong>
<strong>$ $ openssl pkcs7 -inform DER -in *.RSA -out CERT.pem -outform PEM  -print_certs</strong>
</pre></div><p>We'll have to strip any cruft from the generated <code class="literal">CERT.pem</code> file. If you open it up, you should see these lines at the top:</p><div><pre class="programlisting">subject=/C=UK/ST=ORG/L=ORG/O=fdroid.org/OU=FDroid/CN=FDroid
issuer=/C=UK/ST=ORG/L=ORG/O=fdroid.org/OU=FDroid/CN=FDroid
-----BEGIN CERTIFICATE-----
MIIDPDCCAiSgAwIBAgIEUVJuojANBgkqhkiG9w0BAQUFADBgMQswCQYDVQQGEwJV
SzEMMAoGA1UECBMDT1JHMQwwCgYDVQQHEwNPUkcxEzARBgNVBAoTCmZkcm9pZC5v
...</pre></div><p>They need to be removed, so remove <em>only</em> the subject and issuer lines. The file should start with <code class="literal">BEGIN CERTIFICATE</code> and end with <code class="literal">END CERTIFICATE</code> scissor lines.</p><p>Let's move this to a new folder in our workspace called <code class="literal">certs</code> and move the certificate into this folder with a better name:</p><div><pre class="programlisting">
<strong>$ mkdir UDOO_SOURCE_ROOT/certs</strong>
<strong>$ mv CERT.pem UDOO_SOURCE_ROOT/certs/benchmark.x509.pem</strong>
</pre></div><p>We can set up our <code class="literal">keys.conf</code> by adding:</p><div><pre class="programlisting">
<strong>[@BENCHMARK]</strong>
<strong>ALL : certs/benchmark.x509.pem</strong>
</pre></div><p>Don't forget to update <code class="literal">seapp_contexts</code> in order to use the new mapping:</p><div><pre class="programlisting">
<strong>user=_app seinfo=benchmark domain=benchmark_app type=benchmark_app_data_file</strong>
</pre></div><p>Now declare the new types to be used. The domain type should be declared in a file called <code class="literal">benchmark_app.te</code> in <code class="literal">sepolicy</code>:</p><div><pre class="programlisting">
<strong># Declare the new type</strong>
<strong>type benchmark_app, domain;</strong>
<strong># This macro adds it to the untrusted app domain set and gives it some allow rules</strong>
<strong># for basic functionality as well as object access to the type in argument 2.</strong>
<strong>untrustedapp_domain(benchmark_app, benchmark_app_data_file)</strong>
</pre></div><p>Also, add <a id="id327" class="indexterm"/>the <code class="literal">benchmark_app_data_file</code> in <code class="literal">file.te</code>:</p><div><pre class="programlisting">
<strong>type benchmark_app_data_file, file_type, data_file_type, app_public_data_type;</strong>
</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>You may not always want <em>all</em> of these attributes, especially if you're doing something security critical. Make sure you look at each attribute and macro and see its usage. You don't want to open up an unintended hole by having an overly permissive domain.</p></div></div><p>Rebuild<a id="id328" class="indexterm"/> the policy, push the required pieces, and trigger a reload.</p><div><pre class="programlisting">
<strong>$ mmm external/sepolicy/</strong>
<strong>$ adb push $OUT/system/etc/security/mac_permissions.xml /data/security/current/</strong>
<strong>$ adb push $OUT/root/sepolicy /data/security/current/</strong>
<strong>$ adb push $OUT/root/seapp_contexts /data/security/current/</strong>
<strong>$ adb shell setprop selinux.reload_policy 1</strong>
</pre></div><p>Start a shell and grep logcat to see the <code class="literal">seinfo</code> value the benchmark APK is installed as. Then install the APK:</p><div><pre class="programlisting">
<strong>$ adb install ~/org.zeroxlab.zeroxbenchmark_9.apk</strong>
<strong>$ adb logcat | grep -i SELinux</strong>
</pre></div><p>On the <code class="literal">logcat</code> output, you should see:</p><div><pre class="programlisting">
<strong>I/SELinuxMMAC( 2564): package (org.zeroxlab.zeroxbenchmark) installed with seinfo=default</strong>
</pre></div><p>It should have been <code class="literal">seinfo=benchmark</code>! What could have happened?</p><p>The problem is in <code class="literal">frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java</code>. It looks in <code class="literal">/data/security/mac_permissions.xml</code>; so we can just push <code class="literal">mac_permissions.xml</code>. This is another bug in the dynamic policy reload and has to do with historical changes in this loading procedure. The culprit is within the <code class="literal">frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java</code> file:</p><div><pre class="programlisting">private static final File[] INSTALL_POLICY_FILE = {
new File(Environment.getDataDirectory(), "security/mac_permissions.xml"),
new File(Environment.getRootDirectory(), "etc/security/mac_permissions.xml"),
null};</pre></div><p>To get around this, remount <code class="literal">system</code> and push it to the default location.</p><div><pre class="programlisting">
<strong>$ adb remount</strong>
<strong>$ adb push $OUT/system/etc/security/mac_permissions.xml /system/etc/security/</strong>
</pre></div><p>This does <em>not</em> require a <code class="literal">setprop selinux.reload_policy 1</code>. Uninstall and reinstall the benchmark APK, and check the logs:</p><div><pre class="programlisting">
<strong>I/SELinuxMMAC( 2564): package (org.zeroxlab.zeroxbenchmark) installed with seinfo=default</strong>
</pre></div><p>OK. It<a id="id329" class="indexterm"/> still didn't work. When we examined the code, the <code class="literal">mac_permissions.xml</code> file was loaded during package manager service start. This file won't get reloaded <a id="id330" class="indexterm"/>without a reboot, so let's uninstall the benchmark APK, and reboot the UDOO. After it's been booted and <code class="literal">adb</code> is enabled, trigger a dynamic reload, install the APK, and check <code class="literal">logcat</code>. It should have:</p><div><pre class="programlisting">
<strong>I/SELinuxMMAC( 2559): package (org.zeroxlab.zeroxbenchmark) installed with seinfo=benchmark</strong>
</pre></div><p>Now let's verify the process domain by launching the APK, checking <code class="literal">ps</code>, and verifying its application private directory:</p><div><pre class="programlisting">
<strong>&lt;launch apk&gt;</strong>
<strong>$ adb shell ps -Z | grep org.zeroxlab.zeroxbenchmark</strong>
<strong>u:r:benchmark_app:s0 u0_a45 3493 2285 org.zeroxlab.zeroxbenchmark</strong>
<strong>$ adb shell ls -Z /data/data | grep org.zeroxlab.zeroxbenchmark</strong>
<strong>drwxr-x--x u0_a45 u0_a45 u:object_r:benchmark_app_data_file:s0 org.zeroxlab.zeroxbenchmark</strong>
</pre></div><p>This time, all the types check out. We successfully created a new custom domain.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we investigated how to properly label application private data directories as well as their runtime contexts via the configuration files and SELinux policy. We also looked into the subsystems and code to make all of this work as well as some basic things that may go wrong along the way. In the next chapter, we will expand on how the policy and configuration files get built by peering into the SE for Android build system.</p></div></body></html>