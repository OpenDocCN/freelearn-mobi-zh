["```kt\n    Party:\n      type: object\n      properties:\n        householdName:\n          type: string\n        service:\n          type: string\n        agreedAt:\n          type: string\n          format: date-time\n    ServiceContract:\n      type: object\n      properties:\n        id:\n          type: integer\n          format: int32\n        partyA:\n          $ref: '#/components/schemas/Party'\n        partyB:\n          $ref: '#/components/schemas/Party'\n```", "```kt\n      parameters:\n        - in: path\n          name: id\n          required: true\n          schema:\n            type: integer\n        - in: header\n          name: household\n          required: true\n          schema:\n            type: string\n```", "```kt\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ServiceContract'\n        '400':\n          description: Failed request validation\n        '403':\n          description: Not authorized\n        '404':\n         description: Service contract not found\n```", "```kt\n      requestBody:\n        description: The service contract to be created or updated\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ServiceContract'\n        required: true\n```", "```kt\n      responses:\n        '200':\n          description: Service contract updated\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ServiceContract'\n        '201':\n          description: Service contract created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ServiceContract'\n        '400':\n          description: Failed request validation\n        '403':\n          description: Not authorized\n```", "```kt\n      responses:\n        '204':\n          description: Agreed service contract\n        '400':\n          description: Failed request validation\n        '403':\n          description: Not authorized\n        '404':\n          description: Service contract not found\n```", "```kt\ndata class ServiceContract(\n    val id: Int,\n    val partyA: Party,\n    val partyB: Party,\n)\ndata class Party(\n    val householdName: String,\n    val service: String,\n    val agreedAt: Instant? = null,\n)\n```", "```kt\nval contracts = ConcurrentHashMap<Int, ServiceContract>()\n```", "```kt\nval serviceContractLens = Body.auto<ServiceContract>().toLens()\nval householdHeader = Header.required(\"household\")\n```", "```kt\nval app: HttpHandler =\n    routes(\n...\n)\n```", "```kt\n\"/contracts/{id}\" bind GET to { request ->\n    val household = householdHeader(request)\n    val id = request.path(\"id\")?.toInt()\n    val contract = id?.let { contracts[it] }\n    if (contract == null) {\n        Response(NOT_FOUND).body(\"Service contract of ID $id not found\")\n    } else if (contract.partyA.householdName != household && contract.partyB.householdName != household) {\n        Response(FORBIDDEN).body(\"Household $household is not allowed to see the service contract of ID $id\")\n    } else {\n        Response(OK).with(serviceContractLens of contract)\n    }\n}\n```", "```kt\n\"/contracts/{id}\" bind PUT to { request ->\n    val household = householdHeader(request)\n    val lens = Body.auto<ServiceContract>().toLens()\n    val id = request.path(\"id\")?.toInt()\n    val contract = lens(request)°\n    if (id == null || id != contract.id) {\n        Response(BAD_REQUEST).body(\"Service contract ID in the payload and the URI path do not match\")\n    } else if (contract.partyA.householdName == contract.partyB.householdName) {\n        Response(BAD_REQUEST).body(\"Service contract must have two different household: $household\")\n    } else if (contract.partyA.householdName != household && contract.partyB.householdName != household) {\n        Response(FORBIDDEN).body(\"Household $household is not allowed to update the service contract of ID $id\")\n    } else {\n        val previous = contracts.put(contract.id, contract)\n        val status = if (previous == null) CREATED else OK\n        Response(status).with(serviceContractLens of contract)\n    }\n}\n```", "```kt\n\"/contracts/{id}/agreedAt\" bind PATCH to { request ->\n    val household = householdHeader(request)\n    val id = request.path(\"id\")?.toInt()\n    val contract = id?.let { contracts[id] }\n    if (contract == null) {\n        Response(NOT_FOUND).body(\"Service contract of ID $id not found\")\n    } else if (contract.partyA.householdName != household && contract.partyB.householdName != household) {\n        Response(FORBIDDEN).body(\"Household $household is not allowed to see the service contract of ID $id\")\n```", "```kt\n    } else {\n        val now = Instant.now()\n        val revisedContract =\n            if (contract.partyA.householdName == household) {\n                contract.copy(partyA = contract.partyA.copy(agreedAt = now))\n            } else {\n                contract.copy(partyB = contract.partyB.copy(agreedAt = now))\n            }\n        contracts[contract.id] = revisedContract\n        Response(NO_CONTENT).with(serviceContractLens of contract)\n    }\n}\n```", "```kt\nfun main() {\n    val printingApp: HttpHandler = PrintRequest().then(app)\n    val server = printingApp.asServer(Undertow(9000)).start()\n}\n```", "```kt\nval client: HttpHandler = OkHttp()\nval printingClient: HttpHandler = PrintResponse().then(client)\n```", "```kt\nval initialContractDraftedByHouseholdA =\n    ServiceContract(\n        id = 1,\n        partyA = Party(\"A\", \"Plumbing\"),\n        partyB = Party(\"B\", \"Cleaning\"),\n    )\nprintingClient(\n    Request(PUT, \"http://localhost:9000/contracts/1\").with(\n        householdHeader of \"A\",\n        Body.json().toLens() of\n            initialContractDraftedByHouseholdA.asJsonObject(),\n    ),\n)\n```", "```kt\nval contractReceivedByB =\n    serviceContractLens(\n        printingClient(\n            Request(GET, \"http://localhost:9000/contracts/1\").with(householdHeader of \"B\"),\n        ),\n    )\nval contractRevisedByB =\n    contractReceivedByB.copy(\n        partyB = contractReceivedByB.partyB.copy(service = \"Babysitting\"),\n    )\nprintingClient(\n    Request(PUT, \"http://localhost:9000/contracts/1\").with(\n        householdHeader of \"B\",\n        Body.json().toLens() of\n            contractRevisedByB.asJsonObject(),\n    ),\n)\n```", "```kt\nval contractReceivedByA =\n    serviceContractLens(\n        printingClient(\n            Request(GET, \"http://localhost:9000/contracts/1\").with(householdHeader of \"A\"),\n        ),\n    )\nprintingClient(Request(PATCH, \"http://localhost:9000/contracts/1/agreedAt\").with(householdHeader of \"A\"))\n```", "```kt\nval revisedContractReceivedByB =\n    serviceContractLens(\n        printingClient(\n            Request(GET, \"http://localhost:9000/contracts/1\").with(householdHeader of \"B\"),\n        ),\n    )\nif (revisedContractReceivedByB.partyA.agreedAt != null) {\n    printingClient(Request(PATCH, \"http://localhost:9000/contracts/1/agreedAt\").with(householdHeader of \"B\"))\n}\n```", "```kt\nval contractAgreedByBoth =\n    serviceContractLens(\n        printingClient(\n            Request(GET, \"http://localhost:9000/contracts/1\").with(householdHeader of \"A\"),\n        ),\n    )\n```", "```kt\ndata class ServiceContract(\n    val id: Int,\n    val partyA: Party,\n    val partyB: Party,\n)\ndata class Party(\n    val householdName: String,\n    val service: String,\n    val agreedAt: Instant? = null,\n)\n```", "```kt\nclass UdpNode<T>(\n    val address: SocketAddress,\n    val convertor: DtoConvertor<T>,\n    val transformer: (T) -> T?,\n) {\n    private val inbound: ByteBuffer = convertor.allocate()\n    private val outbound: ByteBuffer = convertor.allocate()\n    private var channel: DatagramChannel? = null\n```", "```kt\n    fun start() {\n        channel =\n            DatagramChannel.open()\n                .bind(address)\n     }\n```", "```kt\n    fun produce(\n        payload: T,\n        target: SocketAddress,\n    ): Int {\n        outbound.clear()\n        convertor.toBuffer(payload, outbound)\n        outbound.flip()\n        return channel!!.send(outbound, target)\n    }\n```", "```kt\n    fun consume(): Int {\n        return channel?.let { c ->\n            inbound.clear()\n            val address: SocketAddress = c.receive(inbound)\n            inbound.rewind()\n            val received = convertor.fromBuffer(inbound)\n            transformer(received)?.let { transformed ->\n                produce(transformed, address)\n            }\n        } ?: 0\n    }\n}\n```", "```kt\ninterface DtoConvertor<E> {\n    fun allocate(): ByteBuffer\n    fun toBuffer(dto: E, buffer: ByteBuffer)\n    fun fromBuffer(buffer: ByteBuffer): E\n}\n```", "```kt\nobject ServiceContractConvertor : DtoConvertor<ServiceContract> {\n    override fun allocate(): ByteBuffer {\n        return ByteBuffer.allocate(1024)\n    }\n```", "```kt\n    override fun toBuffer(dto: ServiceContract, buffer: ByteBuffer) { buffer.putInt(dto.id).putParty(dto.partyA).putParty(dto.partyB)\n    }\n    private fun ByteBuffer.putParty(dto: Party): ByteBuffer = putString(dto.householdName).putString(dto.service).putInstant(dto.agreedAt)\n    private fun ByteBuffer.putInstant(dto: Instant?): ByteBuffer =\n        if (dto == null) {\n            putChar(ABSENT)\n        } else {\n            putChar(PRESENT).putLong(dto.epochSecond)\n        }\n    private fun ByteBuffer.putString(dto: String): ByteBuffer = putInt(dto.length).put(dto.toByteArray())\n```", "```kt\n    override fun fromBuffer(buffer: ByteBuffer): ServiceContract = ServiceContract(buffer.getInt(), buffer.getParty(), buffer.getParty())\n    private fun ByteBuffer.getParty(): Party = Party(getString(), getString(), getInstant())\n    private fun ByteBuffer.getInstant(): Instant? =\n        if (getChar() == PRESENT) {\n            Instant.ofEpochSecond(getLong())\n        } else {\n            null\n        }\n    private fun ByteBuffer.getString(): String {\n        val bytes = ByteArray(getInt())\n        get(bytes)\n        return String(bytes)\n    }\n```", "```kt\nfun main() {\n    val node =\n        UdpNode(\n            InetSocketAddress(HOST_A, PORT_A),\n            ServiceContractConvertor,\n        ) { it.receivedByHouseholdA() }\n    node.start()\n```", "```kt\n    val contract =\n        ServiceContract(\n            id = 1,\n            partyA = Party(HOUSEHOLD_A, PLUMBING, null),\n            partyB = Party(HOUSEHOLD_B, CLEANING, null),\n        )\n    node.produce(contract, InetSocketAddress(HOST_B, PORT_B))\n    println(\"Submitted service contract: ${contract.id}\")\n    loopForever(1000) { node.consume() }\n}\nprivate fun ServiceContract.receivedByHouseholdA() =\n    if (bothPartiesHaveDifferentNames().not() ||\n        partyAgreed(HOUSEHOLD_A) ||\n        isHouseholdInvolved(HOUSEHOLD_A).not()\n    ) {\n        println(\"No response to service contract: $this\")\n        null\n    } else {\n        println(\"Agreed to service contract: $id\")\n        agree(HOUSEHOLD_A) { Instant.now() }\n    }\n```", "```kt\nfun main() {\n    val node =\n        UdpNode(\n            InetSocketAddress(HOST_B, PORT_B),\n            ServiceContractConvertor,\n        ) { it.receivedByHouseholdB() }\n    node.start()\n    loopForever(1000) { node.consume() }\n}\nfun ServiceContract.receivedByHouseholdB() =\n    if (bothPartiesHaveDifferentNames().not() ||\n        partyAgreed(HOUSEHOLD_B) ||\n        isHouseholdInvolved(HOUSEHOLD_B).not()\n    ) {\n        println(\"No response to service contract: ${this}\")\n        null\n    } else if (serviceReceivedBy(HOUSEHOLD_B) == CLEANING) {\n        println(\"Submitted revised service contract: $id\")\n        withReceivedService(HOUSEHOLD_B, BABYSITTING)\n    } else if (serviceReceivedBy(HOUSEHOLD_B) == BABYSITTING) {\n        println(\"Agreed to service contract: $id\")\n        agree(HOUSEHOLD_B) { Instant.now() }\n    } else {\n        println(\"No response to service contract: $id\")\n        null\n    }\n```", "```kt\nStarted on $localhost/127.0.0.1:7001\nSubmitted service contract: 1\nAgreed to the service contract: 1\nNo response to service contract: ServiceContract\n```", "```kt\nSubmitted to revised service contract: 1\nAgreed to service contract: 1\n```"]