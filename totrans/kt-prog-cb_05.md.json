["```kt\ninterface DemoInterface {\n\n    fun implementatedMethod() {\n        println(\"From demo interface\")\n    }\n}\n```", "```kt\nclass IntefaceImplementation: DemoInterface\n```", "```kt\nfun main(args: Array<String>) {\n    var interfaceImplementation= IntefaceImplementation()\n    interfaceImplementation.implementatedMethod()\n}\n```", "```kt\n From demo interface\n```", "```kt\nfun main(args: Array<String>) {\n    var interfaceImplementation= IntefaceImplementation()\n    interfaceImplementation.foo()\n    interfaceImplementation.bar()\n\n}\ninterface A {\n\n    fun foo() {\n        println(\"foo from A\")\n    }\n}\nclass IntefaceImplementation: A,B\n\ninterface B  {\n    fun bar() {\n        println(\"foo from B\")\n    }\n}\n```", "```kt\ninterface A {\n    fun foo() {\n        println(\"foo from A\")\n    }\n}\ninterface B  {\n    fun foo() {\n        println(\"foo from B\")\n    }\n}\n```", "```kt\nError:(24, 1) Kotlin: Class 'IntefaceImplementation' must override public open fun foo(): Unit defined in packageB.A because it inherits multiple interface methods of it\n```", "```kt\nclass IntefaceImplementation: A,B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    var interfaceImplementation= IntefaceImplementation()\n    interfaceImplementation.foo()\n}\n```", "```kt\nfoo from A\nfoo from B\n```", "```kt\nval a: Int\n    get() = 2\n```", "```kt\nclass InterfaceImplementation: A,B {\n    override val a: Int=25}\n```", "```kt\nfun main(args: Array<String>) {\n    var interfaceImplementation= InterfaceImplementation(object :A{\n    })\n    interfaceImplementation.someMethod()\n}\nclass InterfaceImplementation(var a:A){\n    fun someMethod(){\n        a.foo()\n    }\n}\ninterface A {\n    fun foo() {\n        println(\"foo from A\")\n    }\n}\n```", "```kt\nclass InterfaceImplementation(var a:A):A by a{\n    fun someMethod(){\n        foo()\n    }\n}\n```", "```kt\nbutton.setOnClickListener(object : View.OnClickListener {\n    fun onClick(View v) {\n       *// TODO: do some stuff...*\n\n    }\n\n    fun onLongClick(View v) {\n        *// we don't need it*\n    }\n\n    fun onTouch(View v, MotionEvent event) {\n        *// we don't need it\n*    } \n});\n```", "```kt\ninterface OnClickListener { \n    fun onClick( v:View )\n} public interface OnLongClickListener { \n    fun onLongClick( v: View)\n} interface OnTouchListener { \n    fun onTouch( v: View,  event: MotionEvent)\n```", "```kt\nfun main(args: Array<String>) {\n    Simple().callMethod()\n}\nclass Simple:A{\n    fun callMethod(){\n        bar()\n    }\n}\ninterface A{\n    fun bar(){\n        println(\"Printing from interface\")\n    }\n}\n```", "```kt\nopen class A\n```", "```kt\nclass B:A()\n```", "```kt\nopen class A(var str:String)\n```", "```kt\nclass B(var randomString:String): A(randomString)\n```", "```kt\nclass B: A{\n    constructor(randomString:String) : super(randomString)\n    constructor(randomString:String, randomInt:Int) : super(randomString)\n```", "```kt\nopen class A(var str:String){\n    open fun foo(){\n        println(\"foo from A\")\n    }\n}\nclass B(var string: String): A(string) {\n    override fun foo(){\n        println(\"foo from B\")\n    }\n}\n```", "```kt\nopen class A(var str:String){\n    final fun foo(){\n        println(\"foo from A\")\n    }\n}\n```", "```kt\nclass B(var string: String): C() {\n    override fun methodC() {\n        // Do something here\n    }\n}\nabstract class C{\n    abstract fun methodC()\n    fun impl(){}\n}\n```", "```kt\nGlide.with(context).load(image_url).into(imageView)\n```", "```kt\nprivate fun ImageView.loadImage(image_url: String) {\n\n}\n```", "```kt\nprivate fun ImageView.loadImage(image_url: String) {\n    Glide.with(context).load(image_url).into(this)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    var c= C()\n    c.foo()\n}\nclass C{\n    fun foo(){\n        println(\"from member\")\n    }\n}\nprivate fun C.foo() {\n    println(\"from extension\")\n}\n```", "```kt\n from member\n```", "```kt\nfun main(args: Array<String>) {\n    val intgen: GenCl<Int> = GenCl<Int>(10)\n    println(intgen.a)\n\n    // We are letting Kotlin compiler infer type\n    val strgen = GenCl(\"A string\")\n    println(strgen.a)\n}\n\nclass GenCl<T>(t: T) {\n    var a = t\n}\n```", "```kt\n10\nA string\n```", "```kt\nfun main(args: Array<String>) {\n    val intgen: GenCl<Int> = GenCl<Int>(10)\n    println(intgen.a)\n\n    val flgen = GenCl(1.0)\n    println(flgen.a)\n}\n\n// Restricting T to only be of type Number\nclass GenCl<T: Number>(t: T) {\n    var a = t\n}\n```", "```kt\nError:(8, 17) Type parameter bound for T in constructor GenCl<T : Number>(t: T)\n is not satisfied: inferred type String is not a subtype of Number\n```", "```kt\nfun main(args: Array<String>) {\n    fun <T> addTwo(a: List<T>) {\n        for(x in a) {\n            println(x)\n        }\n    }\n\n    addTwo(listOf(10,20,30,40))\n    addTwo(listOf(\"a\",\"b\",\"c\",\"d\",\"e\"))\n}\n```", "```kt\n10 \n20 \n30 \n40 \na \nb \nc \nd \ne\n```", "```kt\nfun main(args: Array<String>) {\n    println(doubleOf(4))\n\n    println(doubleOf(4.3))\n\n    println(doubleOf(4.323))\n}\n\nfun doubleOf(a: Int): Int {\n    return 2*a\n}\n\nfun doubleOf(a: Float): Float {\n    return 2*a\n}\n\nfun doubleOf(a: Double): Double {\n    return 2.00*a\n}\n```", "```kt\n8\n8.6\n8.646\n```", "```kt\nfun main(args: Array<String>) {\n    var a = Sup()\n    a.method1()\n    a.method2()\n\n    var b = Sum()\n    b.method1()\n    b.method2()\n}\n\nopen class Sup {\n    open fun method1() {\n        println(\"Printing method 1 from inside Sup\")\n    }\n\n    fun method2() {\n        println(\"Printing method 2 from inside Sup\")\n    }\n}\n\nclass Sum: Sup() {\n    override fun method1() {\n        println(\"Printing method 1 from inside Sum\")\n    }\n}\n```", "```kt\nPrinting method 1 from inside Sup\nPrinting method 2 from inside Sup\nPrinting method 1 from inside Sum\nPrinting method 2 from inside Sup\n```", "```kt\nclass ShowMessageToast(val message:String):ToastOperation()\n```", "```kt\nobject ShowErrorToast:ToastOperation()\n```", "```kt\nfun doToastOperation(toastOperation: ToastOperation){\n    when(toastOperation){\n        is ShowMessageToast ->Toast.makeText(this,toastOperation.message,Toast.LENGTH_LONG).show()\n        ShowErrorToast->Toast.makeText(this,\"Error.. Grr!\",Toast.LENGTH_LONG).show()\n    }\n}\n```", "```kt\nsealed class ToastOperation {\n}\nobject ShowErrorToast:ToastOperation()\nclass ShowMessageToast(val message:String):ToastOperation()\n```", "```kt\nsealed class ToastOperation {\n    object ShowErrorToast:ToastOperation()\n    class ShowMessageToast(val message:String):ToastOperation()\n}\n```"]