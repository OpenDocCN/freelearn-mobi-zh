<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Swift Debugging with Xcode" id="1R42S1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Swift Debugging with Xcode</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Validating the values – developing a tax income simulator app</li><li class="listitem">Debugging with Xcode and Swift – the best checker movement</li><li class="listitem">Debugging with LLDB</li><li class="listitem">Profiling an app</li><li class="listitem">Error handling in Swift 2.0</li><li class="listitem">Custom error handling in Swift 2.0</li><li class="listitem">Availability checking in Swift 2.0</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Swift Debugging with Xcode" id="1R42S1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec56" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">Let's face it, nobody writes a full program without any issues. Even the best programmer will see some situations that haven't been contemplated. Sometimes it's easy to find the bug, sometimes it is very hard, mainly you have a multithread app.</p><p class="calibre7">In this chapter, we are going to learn how to debug an app step by step, it will make it easier for you to find out where the issue is.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Validating the values &#x2013; developing a tax income simulator app"><div class="book" id="1S2JE2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec57" class="calibre1"/>Validating the values – developing a tax income simulator app</h1></div></div></div><p class="calibre7">When writing <a id="id298" class="calibre1"/>code and developing apps, we know that some variables of a function <a id="id299" class="calibre1"/>shouldn't contain certain values, but are you sure of that? How can we develop and check that everything has the right value?</p><p class="calibre7">In this recipe, we are going to learn how to check that the values are right during the development stage. To simulate this, let's create an app where we are sure that there will be people trying to cheat the values; in this case let's create an app to calculate tax income.</p></div>

<div class="book" title="Validating the values &#x2013; developing a tax income simulator app">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec172" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a project called <code class="email">Chapter 7 Tax Income</code> and make sure that you are in debug mode; to do it click on the <a id="id300" class="calibre1"/>project schema and select <span class="strong"><strong class="calibre8">Edit Scheme…</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00074.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Click on the <span class="strong"><strong class="calibre8">Run</strong></span> <a id="id301" class="calibre1"/>option located on the left-hand side, then make sure that the <span class="strong"><strong class="calibre8">Info</strong></span> tab is selected, and finally, make sure that the <span class="strong"><strong class="calibre8">Build</strong></span> option is on <span class="strong"><strong class="calibre8">Debug</strong></span>. We will have some explanations afterwards:</p><div class="mediaobject"><img src="../images/00075.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Once these steps have <a id="id302" class="calibre1"/>been checked we need to open the project <a id="id303" class="calibre1"/>settings and create a macro called <code class="email">DEBUG_MODE</code>, only on the debug configuration.</p><div class="mediaobject"><img src="../images/00076.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Validating the values &#x2013; developing a tax income simulator app">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec173" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, let's create a new file called <code class="email">Assertions.swift</code>. Here we are going to add some functions, all of them starting with <code class="email">assert_</code>:<div class="informalexample"><pre class="programlisting">// element must be one of the elements in the set
func assert_in&lt;T:Comparable&gt;(element: @autoclosure () -&gt; T, set: [T], message: @autoclosure () -&gt; String){
    #if DEBUG_MODE
        if set.count == 0 {
        println("warning: comparing with an empty set")
        }
        assert(set.filter({(currentElement) -&gt; Bool in
        return currentElement == element()
        }).count &gt; 0, message)
    #endif
}

// element must be greater or equal to the other value
func assert_ge&lt;T:Comparable&gt;(value:T, otherValue:T, message: @autoclosure () -&gt; String){
    #if DEBUG_MODE
        assert(value &gt;= otherValue , message)
    #endif
}

// element can't be nil
func assert_not_nil&lt;T&gt;(element:@autoclosure () -&gt; T?, message: @autoclosure () -&gt; String){
    if element() == nil {
        #if DEBUG_MODE
            assertionFailure(message)
        #endif
    }
}</pre></div></li><li class="listitem" value="2">Now we can create another file, which will contain a class that should be able to calculate the income tax. Create a new file called <code class="email">IncomeTaxCalculator.swift</code>; start with the following class header:<div class="informalexample"><pre class="programlisting">class IncomeTaxCalculator: CustomStringConvertable {</pre></div></li><li class="listitem" value="3">The next step is <a id="id304" class="calibre1"/>adding its attributes; as you can imagine, we <a id="id305" class="calibre1"/>have to store a few values for it:<div class="informalexample"><pre class="programlisting">    var title:String?
    var name:String?
    lazy var grossIncome:Double = 0.0
    lazy var netIncome:Double = 0.0
    lazy var children:Int = 0
    lazy var education:Double = 0.0</pre></div></li><li class="listitem" value="4">As you can see, all of them are initialized or are options; you don't need to create an initializer in this case, except if you are using one of the first versions of Swift:<div class="informalexample"><pre class="programlisting">init(){}</pre></div></li><li class="listitem" value="5">If you paid attention, this class must implement the <code class="email">Printable</code> protocol. So we need to add the description to this class:<div class="informalexample"><pre class="programlisting">    var description: String {
        assert_not_nil(self.title, "Title cant be nil")
        assert_not_nil(self.name, "Name cant be nil")
        assert_in(self.title!, ["Mr", "Dr", "Miss", "Mrs"], "Wrong title")
        return "\(self.title!) \(self.name!) - \(self.calculate())"
    } </pre></div></li><li class="listitem" value="6">To finish this <a id="id306" class="calibre1"/>class, we need a method that calculates the income <a id="id307" class="calibre1"/>tax based on the previous attributes. Of course, this is a fictional case; don't use this app to calculate your income tax:<div class="informalexample"><pre class="programlisting">    func calculate() -&gt; Double {
        assert_ge(self.grossIncome, 0.0, "Gross income can't be negative")
        assert_ge(self.netIncome, 0.0, "Net income can't be negative")
        assert_ge(self.grossIncome, self.netIncome, "Net income cant be negative")
        
        let totalAlreadyPaid = self.grossIncome - self.netIncome
        var percentage:Double
        if self.grossIncome &lt;= 9000.0 {
            percentage = 0.0
        } else if self.grossIncome &lt;= 18000.0 {
            percentage = 0.15
        } else {
            percentage = 0.40
        }
        
        let childrenBonus = Double(self.children) * 100.0
        
        // 10 percent of education up to 1000 per child
        var educationBonus:Double
        var educationLimit = Double(self.children) * 1000.0
        if 0.1 * self.education &lt; educationLimit {
            educationBonus = 0.1 * self.education
        }else {
            educationBonus = educationLimit
        }
        
        return self.grossIncome * percentage - childrenBonus - educationBonus - totalAlreadyPaid
    }
}</pre></div></li><li class="listitem" value="7">Once it is done, we have to create the graphical part of our app, so go to the storyboard and <a id="id308" class="calibre1"/>create a layout with six text fields, one button, and <a id="id309" class="calibre1"/>six labels; something similar to the following one:<div class="mediaobject"><img src="../images/00077.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">As you may <a id="id310" class="calibre1"/>imagine, we need to create some attributes to link with the text fields:<div class="informalexample"><pre class="programlisting">    @IBOutlet var titleTextField: UITextField!
    @IBOutlet var nameTextField: UITextField!
    @IBOutlet var lastYearIncomeTextField: UITextField!
    @IBOutlet var numberOfChildrenTextField: UITextField!
    @IBOutlet var LastYearNetIncome: UITextField!
    @IBOutlet var educationTextField: UITextField!</pre></div></li><li class="listitem" value="9">To complete our graphical part, we need to add an event for the button:<div class="informalexample"><pre class="programlisting">    @IBAction func calculateAction(sender: UIButton) {
        assert(countElements(self.nameTextField.text) &gt;= 5, "Your name looks too short")
        var error:NSError?
        let regex = NSRegularExpression(pattern: "^[0-9]+[.[0-9]+]?$", options: .CaseInsensitive, error: &amp;error)!
        if regex.matchesInString(self.lastYearIncomeTextField.text, options: nil, range: NSMakeRange(0, countElements(self.lastYearIncomeTextField.text))).count == 0{
            assertionFailure("Gross Income tax: wrong format")
        }
        let income = (self.lastYearIncomeTextField.text as NSString).doubleValue
        let incomeTaxCalculator:IncomeTaxCalculator = IncomeTaxCalculator()
        incomeTaxCalculator.title = self.titleTextField.text
        incomeTaxCalculator.name = self.nameTextField.text
        incomeTaxCalculator.grossIncome = (self.lastYearIncomeTextField.text as NSString).doubleValue
        incomeTaxCalculator.netIncome = (self.LastYearNetIncome.text as NSString).doubleValue
        incomeTaxCalculator.education = (self.educationTextField.text as NSString).doubleValue
        incomeTaxCalculator.children = self.numberOfChildrenTextField.text.toInt()!
        UIAlertView(title: "Income Tax", message: incomeTaxCalculator.description, delegate:nil, cancelButtonTitle:"Ok").show()
    }</pre></div></li><li class="listitem" value="10">The last <a id="id311" class="calibre1"/>step to do is testing our application and watching <a id="id312" class="calibre1"/>the assertions work. Press play and when the application appears, press calculate, without adding any information into the text fields. You should see your application stop running, and the Xcode should show you where:<div class="mediaobject"><img src="../images/00078.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">If you pay attention, the log console will open and show you what happened, printing the message that you have written:<div class="mediaobject"><img src="../images/00079.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="12">Let's <a id="id313" class="calibre1"/>complete this recipe, changing from <span class="strong"><strong class="calibre8">Debug</strong></span> to <span class="strong"><strong class="calibre8">Release</strong></span> <a id="id314" class="calibre1"/>configuration; press play again, and see that the first assert was ignored.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Validating the values &#x2013; developing a tax income simulator app">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec174" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Assertions are like functions that interrupt the application when they find an unexpected value. Of course, when a program is released, it needs to accept these values, which means that the developer shouldn't trust on the assertions' power forever, he must fix the value, or at least interrupt the process.</p><p class="calibre7">Swift comes with only two assertions functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">assert</code>: This function has two arguments. The first one is a Boolean element which, in case of being false, is going to stop your program and show the next argument (the message) for the developer.</li><li class="listitem"><code class="email">assertionFailure</code>: This function stops the program execution without checking any condition. This function is used when there is a way where the app shouldn't go through it. Imagine that you have a <code class="email">switch</code> statement, and theoretically your program shouldn't go to the default case because it isn't considered, in this case you need to add an assertion.</li></ul></div><p class="calibre7">Another nagging question is: What does <code class="email">autoclosure</code> mean? The reason is the following—<code class="email">assert</code>, <code class="email">assertionFailure</code>, and our assertions functions actually don't receive a value as an argument, the reason is laziness. It means that Swift isn't going to evaluate the values before entering into the function.</p><p class="calibre7">Swift converts your argument into a function and the argument will be evaluated inside when the assert function calls it. Why? The reason is that assertions shouldn't work if you are compiling with Release configuration instead of Debug. Bear in mind that assertions stop your program, which is something good when you are developing, but for a user it won't be a good sensation. That's the reason that sometimes we call the autoclosure function between <code class="email">#ifdef NDEBUG</code> and <code class="email">#endif</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre7">Before Xcode 6 beta 5, <code class="email">@autoclosure</code> used to be written as <code class="email">@auto_closure</code>. If you are going to search for something about this modifier on the Internet, try writing it both ways.</p></div><p class="calibre7">If assertions don't <a id="id315" class="calibre1"/>work on Release mode, why are they useful? The reason is that assertions are used for detecting development errors, you should track the source of the <a id="id316" class="calibre1"/>error and modify it to ensure that the source won't give you a wrong value.</p><p class="calibre7">The reason we created a different file for our own assertion functions is that you may have this file shared between projects; of course you can use the function <code class="email">assert</code> for everything, but I would recommend creating assertions functions that can save us from work, like the one we have to check if an element is inside of an array.</p></div></div>

<div class="book" title="Validating the values &#x2013; developing a tax income simulator app">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec175" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">In this recipe we learned about using the Swift assertions, which is the equivalent of the <code class="email">NSAssert</code> in Objective-C. If you prefer using the other assertion features from the Objective-C foundation, such as <code class="email">NSParameterAssert</code> and <code class="email">NSAssertionHandler</code>, you are still able to use them in Swift.</p><p class="calibre7">Assertions are very useful for finding paths that are receiving wrong values, however there are times when it is necessary to go step by step in the code. We will see how to do it with Xcode and Swift in the next recipe.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Debugging with Xcode and Swift &#x2013; the best checker movement"><div class="book" id="1T1402-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec58" class="calibre1"/>Debugging with Xcode and Swift – the best checker movement</h1></div></div></div><p class="calibre7">If you have <a id="id317" class="calibre1"/>some experience with programming, you <a id="id318" class="calibre1"/>know that sometimes we need to go step by step into the code, mainly when we have those kinds of issues where nobody knows how it happened.</p><p class="calibre7">In this recipe we are going to learn how to debug with Xcode and Swift. To do it, we are going to recycle our checkers board. In this case we are going to make the best move using the white pieces. We are also going to leave it prepared for a second version of this app where we could use kings.</p><p class="calibre7">We are not going to create the right algorithm in the beginning, the idea is to debug and find where the issue is, and then we are going to correct it afterwards.</p></div>

<div class="book" title="Debugging with Xcode and Swift &#x2013; the best checker movement">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec176" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Open your playground from the previous chapter where you have the checkers board. Leave it open because we are going to reuse this code. Once it is opened, create a new project called <a id="id319" class="calibre1"/>
<code class="email">Chapter 7 checkerboard</code>, and let's start coding.</p></div></div>

<div class="book" title="Debugging with Xcode and Swift &#x2013; the best checker movement">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec177" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new file called <code class="email">CheckersBoard.swift</code>, start by importing the <code class="email">UIKit</code> library if it is not imported yet:<div class="informalexample"><pre class="programlisting">import UIKit</pre></div></li><li class="listitem" value="2">After that you can <a id="id320" class="calibre1"/>paste the class code from playground. Then, copy the last part from playground (variable instantiation and setup) and paste it in the <code class="email">viewDidLoad</code> method on the view controller file:<div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        var board = CheckersBoard()
        board.board[2][5] = .WHITE
        board.board[2][3] = .BLACK
        board.board[4][3] = .WHITE
        board.board[2][1] = .BLACK
        board.board[0][5] = .WHITE
        board.board[1][0] = .BLACK
        board.board[7][6] = .WHITE
        board.board[5][6] = .BLACK
    }</pre></div></li><li class="listitem" value="3">Now let's create a breakpoint on the third time we assign a piece, by clicking on the gray area to the left of the code:<div class="mediaobject"><img src="../images/00080.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Press play, wait until the Xcode stops on your breakpoint and move your mouse pointer over the board variable. It can be any of them, like the first one, where <a id="id321" class="calibre1"/>the variable is being declared, or the other ones where we assign a piece.</li><li class="listitem" value="5">After a short interval <a id="id322" class="calibre1"/>you will see a small dialog with two icons on the right. The first icon, which is an <span class="strong"><strong class="calibre8">i</strong></span> with a circle around it, displays the content of the object with a text format similar to a JSON format:<div class="mediaobject"><img src="../images/00081.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><p class="calibre15">The other icon is very familiar to us, because it's the same icon we've seen on the playground, it's the quick look icon and we can also use it here. That way we retrieve a more visual way of watching the checkers board:</p><div class="mediaobject"><img src="../images/00082.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre7">Don't create the <a id="id323" class="calibre1"/>method <code class="email">debugQuickLookObject</code> for every single class you have, only for those classes that are <a id="id324" class="calibre1"/>hard to visualize and need to be debugged frequently.</p></div></li><li class="listitem" value="6">Now that we know how to visualize our object, we need to differentiate traditional pieces from kings. Our next goal is adding a Boolean to the <code class="email">BoardSpace</code> enumeration. Replace the previous enumeration with this one:<div class="informalexample"><pre class="programlisting">    enum BoardSpace {
        case FREE,
        WHITE(Bool),
        BLACK(Bool)
    }</pre></div></li><li class="listitem" value="7">Now we need to display something different, in this case we are going to add the letter <code class="email">K</code> over the piece. Replace the <code class="email">switch</code> statement inside the <code class="email">debugQuickLookObject</code> with this one:<div class="informalexample"><pre class="programlisting">                var isKing = false;

                switch board[row][col] {
                case .WHITE(let king):
                    isKing = king
                    UIColor.whiteColor().setFill()
                case .BLACK(let king):
                    isKing = king
                    UIColor.brownColor().setFill()
                default:
                    continue
                }</pre></div></li><li class="listitem" value="8">Right, now after filling the pieces we need to add a code in case the current piece is a king:<div class="informalexample"><pre class="programlisting">...
bezier.fill()
if isKing {
   ("K" as NSString).drawAtPoint(CGPointMake(offsetx + CGFloat( squareSize / 3 ) , offsety + CGFloat(squareSize / 5)), withAttributes: nil)
}</pre></div></li><li class="listitem" value="9">Now we need to <a id="id325" class="calibre1"/>change the way we assign the <a id="id326" class="calibre1"/>pieces with the following:<div class="informalexample"><pre class="programlisting">        let board = CheckersBoard()
        board.board[2][5] = .WHITE(false)
        board.board[2][3] = .BLACK(false)
        board.board[4][3] = .WHITE(true)
        board.board[2][1] = .BLACK(false)
        board.board[0][5] = .WHITE(false)
        board.board[1][0] = .BLACK(false)
        board.board[7][6] = .WHITE(false)
        board.board[5][6] = .BLACK(false)</pre></div></li><li class="listitem" value="10">Let's repeat the operation by pressing play and watching the board with quick look; now you can press the step over button, just press the <span class="strong"><em class="calibre9">F6</em></span> key.<div class="note" title="Note"><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre7">New Apple keyboards have an assigned function for the <span class="strong"><em class="calibre9">F6 </em></span>key, so you will probably have to press this key together with the <span class="strong"><em class="calibre9">fn</em></span> key.</p></div></li><li class="listitem" value="11">Now check the quick look and see that you have the letter <code class="email">K</code> over one of your pieces:<div class="mediaobject"><img src="../images/00083.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="12">Ok, now that we know how to visualize the board, we are going to see whether we can win a game with only one turn. To do it we will need to choose a piece and see every possibility we have. It means that we will need to clone our <a id="id327" class="calibre1"/>object frequently. Usually we would <a id="id328" class="calibre1"/>create a struct for it but in this case we are going to create a method for cloning our object. We will give explanations later; just add this code inside your <code class="email">CheckersBoard</code> class:<div class="informalexample"><pre class="programlisting">    func clone() -&gt; CheckersBoard {
        let board = CheckersBoard()
        for i in 0..&lt;8 {
            for j in 0..&lt;8 {
                switch self.board[i][j] {
                case .FREE:
                    continue
                default:
                    board.board[i][j] = self.board[i][j]
                }
            }
        }
        return board
    }</pre></div></li><li class="listitem" value="13">The next step to worry about is how to capture the opponent's piece, to do it we will need to test which directions are possible. Let's create an enumeration inside our <code class="email">CheckersBoard</code> class to help us:<div class="informalexample"><pre class="programlisting">    enum Direction {
        case NORTHWEST,
        NORTHEAST,
        SOUTHWEST,
        SOUTHEAST
    }</pre></div></li><li class="listitem" value="14">Now we need to create a method that is going to find us the best move; remember <a id="id329" class="calibre1"/>that we are using only the <a id="id330" class="calibre1"/>white pieces:<div class="informalexample"><pre class="programlisting">    func bestMovementWhite() -&gt; CheckersBoard?{
        var boardCandidate:CheckersBoard?
        for i in 0..&lt;8 {
            for j in 1..&lt;8 {
                var result: CheckersBoard?
                switch self.board[i][j]{
                    
                case .WHITE(let king):
                    if king {
                        result = bestMovementKingWhite(i, y: j)
                    }else {
                      result = bestMovementSinglePieceWhite(i, y: j)
                    }
                default:
                    continue
                }

                if let boardFound = result {
                    if let currentBoard = boardCandidate {
                        if currentBoard.countBlack() &gt; boardFound.countBlack() {
                            boardCandidate = boardFound
                        }
                    }else {
                        boardCandidate = boardFound
                    }
                }
            }
        }
        return boardCandidate
    }</pre></div></li><li class="listitem" value="15">As you can see, we have two private methods, one for the best movement of a normal piece, and another one for a king. Here we are going to develop the single piece function, the other method I'll leave as homework for you; otherwise it will be an extremely huge recipe:<div class="informalexample"><pre class="programlisting">    private func bestMovementSinglePieceWhite(x:Int, y:Int) -&gt; CheckersBoard {
        var clonedBoard = self.clone()
        if clonedBoard.capture(x, y: y, direction: .NORTHWEST) {
           return clonedBoard.bestMovementSinglePieceWhite(-1, y: -1)
        }
        
        if clonedBoard.capture(x, y: y, direction: .NORTHEAST) {
            return clonedBoard.bestMovementSinglePieceWhite(1, y: -1)
        }
        
        if clonedBoard.capture(x, y: y, direction: .SOUTHWEST) {
            return clonedBoard.bestMovementSinglePieceWhite(-1, y: 1)
        }
        
        if clonedBoard.capture(x, y: y, direction: .SOUTHEAST) {
            return clonedBoard.bestMovementSinglePieceWhite(1, y: 1)
        }
        return clonedBoard
    }
    
    private func bestMovementKingWhite(x:Int, y:Int) -&gt; CheckersBoard? {
        // TODO Homework
        return nil
    }</pre></div></li><li class="listitem" value="16">To complete <a id="id331" class="calibre1"/>this class, we need to add more <a id="id332" class="calibre1"/>methods, one that will count the number of black pieces, and another that is going to capture the opponent's piece:<div class="informalexample"><pre class="programlisting">    func countBlack() -&gt; Int{
        var total = 0
        for row in self.board {
            for element in row {
                switch element {
                case .BLACK:
                    total++
                default:
                    continue
                }
            }
        }
        return total
    }
    private func capture(x: Int, y:Int, direction: Direction) -&gt; Bool {
        var offset_x:Int
        var offset_y:Int
        switch(direction){
        case .NORTHWEST:
            offset_x = -1
            offset_y = -1
        case .NORTHEAST:
            offset_x = 1
            offset_y = -1
        case .SOUTHWEST:
            offset_x = -1
            offset_y = 1
        case .SOUTHEAST:
            offset_x = 1
            offset_y = 1
        }
        if x + 2*offset_x &gt;= 0 &amp;&amp; y + 2*offset_y &gt;= 0 &amp;&amp; x + 2*offset_x &lt; 8 &amp;&amp;  y + 2*offset_y &lt; 8 {
            // we are inside the board range
            switch (board[x + 2*offset_x][y+2*offset_y], board[x + offset_x][y+offset_y]) {
                case (.FREE, .BLACK):
                    board[x + offset_x][y+offset_y] = .FREE
                    board[x + 2 * offset_x ][ y + 2 * offset_y] = board[x][y]
                    board[x][y] = .FREE
                return true
                default:
                return false
            }
        }else {
            return false
        }
    }</pre></div><p class="calibre15">Ok, now imagine that it's Monday. We had to type this whole amount of code and someone (probably your boss) tells us that there is a setup that doesn't find the best solution. Reviewing every single line of this code can be <a id="id333" class="calibre1"/>very boring, and it can be hard to find where the problem is.</p></li><li class="listitem" value="17">Let's debug <a id="id334" class="calibre1"/>starting with the setup that is not working, so replace the setup code with this one:<div class="informalexample"><pre class="programlisting">        let board = CheckersBoard()
        board.board[0][1] = .WHITE(false)
        board.board[0][5] = .WHITE(false)
        board.board[2][7] = .WHITE(false)
        board.board[3][2] = .WHITE(false)
        board.board[2][1] = .BLACK(false)
        board.board[4][3] = .BLACK(false)
        board.board[4][5] = .BLACK(false)
        board.board[2][5] = .BLACK(false)
        board.board[2][3] = .BLACK(false)
        if let finalBoard = board.bestMovementWhite() {
            println(finalBoard.debugDescription)
        }else {
            println("no solution")
        }</pre></div><p class="calibre15">The first thing you might have noticed is the <code class="email">debugDescription</code>. This is something similar to <code class="email">debugQuickLookObject</code> but instead of returning different kinds of objects it only returns a text, we are going to complete this property later.</p><p class="calibre15">As you know, we have to debug the fourth white piece movement. To do it, go to the method called <code class="email">bestMovementWhite</code> and add a breakpoint on the line where we call the method <code class="email">bestMovementSinglePieceWhite</code>. Right-click on this breakpoint and you will see a menu like the following one:</p><div class="mediaobject"><img src="../images/00084.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="18">Choose <a id="id335" class="calibre1"/><span class="strong"><strong class="calibre8">Edit breakpoint...</strong></span>, as you know we don't <a id="id336" class="calibre1"/>want to check what happened with the first three pieces, so say that you want to ignore <span class="strong"><strong class="calibre8">3</strong></span> times before stopping:<div class="mediaobject"><img src="../images/00085.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="19">Sometimes we know that we have to stop after a certain number of times, try to use it instead of clicking play lots of times. Add another breakpoint in this same method at the end (<code class="email">return boardCandidate</code>) and edit it. Now we are going to add a condition to make it work and change the action to sound. Unfortunately most of the available sounds are too soft, I usually choose the glass one, but if you prefer you can choose another one. To finish this breakpoint, select the option <span class="strong"><strong class="calibre8">Automatically continue after evaluating actions</strong></span>:<div class="mediaobject"><img src="../images/00086.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="20">Now press play and wait until Xcode stops, press the step into button (the one with an <a id="id337" class="calibre1"/>arrow pointing down) or press <span class="strong"><em class="calibre9">F7</em></span>, you <a id="id338" class="calibre1"/>will get into the <code class="email">bestMovementSinglePieceWhite</code>. Now click on step over (or press <span class="strong"><em class="calibre9">F6</em></span>) three times, check the board with quick look, and have a look that we will return this board. Once this issue has been detected, we can replace our algorithm with this one:<div class="informalexample"><pre class="programlisting">    private func bestMovementSinglePieceWhite(x:Int, y:Int) -&gt; CheckersBoard {
        var clonedBoard = self.clone()
        var winner:CheckersBoard = self
        
        if clonedBoard.capture(x, y: y, direction: .NORTHWEST) {
            winner = clonedBoard.bestMovementSinglePieceWhite(x-2, y: y-2)
        }
        
        clonedBoard = self.clone()
        if clonedBoard.capture(x, y: y, direction: .NORTHEAST) {
            clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x+2, y: y-2)
            if winner.countBlack() &gt; clonedBoard.countBlack() {
                winner = clonedBoard
            }
        }
        
        clonedBoard = self.clone()
        if clonedBoard.capture(x, y: y, direction: .SOUTHWEST) {
            clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x-2, y: y+2)
            if winner.countBlack() &gt; clonedBoard.countBlack() {
                winner = clonedBoard
            }
        }
        
        clonedBoard = self.clone()
        if clonedBoard.capture(x, y: y, direction: .SOUTHEAST) {
            clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x+2, y: y+2)
            if winner.countBlack() &gt; clonedBoard.countBlack() {
                winner = clonedBoard
            }
        }
        return winner
    }</pre></div></li><li class="listitem" value="21">Now <a id="id339" class="calibre1"/>press play again but instead of pressing step <a id="id340" class="calibre1"/>into use step over, check the board with the quick look inspector, and see that you now have the right solution. So, problem solved, but don't celebrate too much, other issues are coming.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Debugging with Xcode and Swift &#x2013; the best checker movement">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec178" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Xcode allows us to debug step by step. Using the method that we used to debug on our playground (<code class="email">debugQuickLookObject</code>) can help us to visualize the current object state. In this case we could improve our method using the method <code class="email">drawAtPoint</code> of the NSString, right now there is no equivalent method on Swift strings.</p><p class="calibre7">Another detail that you could see is that we created our own method to clone the board instead of using a struct. The reason is that structs can't inherit and in this case we need to do it due to our quick look method.</p><p class="calibre7">Breakpoints have some special features when using Xcode. You can ignore them a few times, which is very useful when you know that the issue happens after some repetitions. Imagine if you have to press continue 50 times, and then you have to repeat it again and again until you find the solution. You and your mouse would end the day exhausted.</p><p class="calibre7">As you can see, you can also add an action to the breakpoint, such as adding a debugger command, playing a sound (that is very useful for knowing that something was done in the background, but you don't want to stop), or logging a message that helps us to analyze the program trajectory.</p><p class="calibre7">There are some commands for debugging that a developer must know, such as step over, which executes the whole line of code and stops on the next one, step into, which goes inside the current function, step out (<span class="strong"><em class="calibre9">F8</em></span>), which exits from the current function and stops on the same place where it was called, and continue (<span class="strong"><em class="calibre9">control</em></span> + <span class="strong"><em class="calibre9">command</em></span> + <span class="strong"><em class="calibre9">Y</em></span>), which continues executing the program until the next breakpoint.</p><p class="calibre7">Unfortunately there is no right or wrong procedure to find an issue, and sometimes you have to use your sixth sense <a id="id341" class="calibre1"/>to solve it. The only way is to collect as much information as you can and go step by step.</p></div></div>

<div class="book" title="Debugging with Xcode and Swift &#x2013; the best checker movement">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec179" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Actually Xcode <a id="id342" class="calibre1"/>isn't debugging by itself, the reality is that it uses another debugger to do this task; on the next recipe we are going to use the debugger from the command line.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Debugging with LLDB" id="1TVKI1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec59" class="calibre1"/>Debugging with LLDB</h1></div></div></div><p class="calibre7">Debugging with <a id="id343" class="calibre1"/>Xcode is fine, but sometimes we are limited and we have to use the debugger with a lower level. To do it, we have to know that actually, Xcode is not debugging anything, it uses another program called LLDB.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre7">Old versions of Xcode used to debug with GDB instead of LLDB, don't try to use them with Swift because there is no support for Swift on GDB.</p></div><p class="calibre7">It is highly recommended knowing the LLDB commands if you want to debug big programs, there are also some cases where you have to connect with another machine (a continuous integration, for example), where you have to do everything through an SSH shell.</p></div>

<div class="book" title="Debugging with LLDB" id="1TVKI1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec180" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Open the checkers board program and check whether you have any breakpoints and remove all of them.</p></div></div>

<div class="book" title="Debugging with LLDB" id="1TVKI1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec181" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Press play and when the program starts, press the pause button using the combination <span class="strong"><em class="calibre9">control</em></span> +<span class="strong"><em class="calibre9"> command</em></span> + <span class="strong"><em class="calibre9">U</em></span>. After that you will see the LLDB console:<div class="mediaobject"><img src="../images/00087.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Now click on the LLDB console and write <code class="email">break s -r bestMovement*</code>. You will see that the answer is <code class="email">Breakpoint 1: 4 locations</code>. Then let's list these <a id="id344" class="calibre1"/>breakpoints with a breakpoint list. Here you can see an ugly answer, but don't be scared, this is simpler than you think.</li><li class="listitem" value="3">You can also write <code class="email">thread info</code> to get some information about the current thread. Check that it specifies the language of each frame, with this information you can get a better idea about what happened with your code in case of crashing.</li><li class="listitem" value="4">List your threads with <code class="email">thread list,</code> switch to thread 2 with <code class="email">thread select 2</code>, and write <code class="email">thread info</code> again.</li><li class="listitem" value="5">Now write <code class="email">repl</code> and see that the prompt changes to <code class="email">1&gt;</code>. In this case, we are going to write a new function to test our REPL, so type the following code:<div class="informalexample"><pre class="programlisting">func num0(myArray:[Int]) -&gt; Int {
    return myArray.reduce(0, {
  if $1 == 0 {
    return $0 + 1
  }else {
    return $0
  }})
}</pre></div></li><li class="listitem" value="6">Once this function is done, let's test it:<div class="informalexample"><pre class="programlisting">num0([1,3,1,0,0,4,1])</pre></div></li></ol><div class="calibre13"/></div><p class="calibre7">As you can see, <code class="email">repl</code> can help you write functions in runtime, like we did with the playground.</p></div></div>

<div class="book" title="Debugging with LLDB" id="1TVKI1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec182" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">LLDB is the current Xcode debugger; you can set multiple breakpoints with regular expressions. Remember that what you do on LLDB isn't necessarily reflected on Xcode, the breakpoints we set are a good example.</p><p class="calibre7">Have a look that three of our breakpoints have the filename and a line number, like <code class="email">... at CheckersBoard.swift:158,  …</code> it means your breakpoint is on the file <code class="email">CheckersBoard.swift</code> at line 158.</p><p class="calibre7">We also used REPL, which is a Swift command line, here you can create functions and test some code. Of <a id="id345" class="calibre1"/>course you can also use playground, but sometimes it is faster using the current debugger.</p></div></div>

<div class="book" title="Debugging with LLDB" id="1TVKI1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec183" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Apple has some <a id="id346" class="calibre1"/>documentation about LLDB worth looking at. Check this URL: <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html">https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html</a>.</li><li class="listitem">What about features that users complain about but are hard to debug, such as memory, performance, or energy? For these kinds of problems you have to use another tool, we are going to learn about it in the next recipe.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Profiling an app"><div class="book" id="1UU542-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec60" class="calibre1"/>Profiling an app</h1></div></div></div><p class="calibre7">It's very common to hear <a id="id347" class="calibre1"/>about issues, but if an app doesn't have any important issue it doesn't mean that it is working fine. Imagine that you have a program that has a memory leak. Presumably you won't find any problem using it for 10 minutes, however, a user may find it after using it for a few days. Don't think that this case is impossible, remember that iOS apps don't terminate, so if you have a memory leak it will be kept until your app blows up.</p><p class="calibre7">Performance is another frequent topic, what if your app looks ok but it gets slower with the passage of time? We <a id="id348" class="calibre1"/>have to be aware of this problem. This kind of test is called <span class="strong"><strong class="calibre8">profiling</strong></span> and Xcode comes with a very good tool for realizing this operation, which is <a id="id349" class="calibre1"/>called <span class="strong"><strong class="calibre8">Instruments</strong></span>.</p><p class="calibre7">In this case we are going to profile our app to visualize the amount of energy wasted by our app and of course let's try to reduce it.</p></div>

<div class="book" title="Profiling an app">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec184" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe you will need a physical device, and to install your app on the device you will need to be enrolled on the Apple Developer Program. If you have both requirements the next thing you have to do is create a new project called <code class="email">Chapter 7 Energy</code>.</p></div></div>

<div class="book" title="Profiling an app">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec185" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Before we start <a id="id350" class="calibre1"/>coding, we will need to add a framework to the project. Click on the tab <span class="strong"><strong class="calibre8">Build Phases</strong></span> of your project and go to the section <span class="strong"><strong class="calibre8">Link Binaries with Libraries</strong></span> and press the plus sign:<div class="mediaobject"><img src="../images/00088.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Once Xcode opens a dialog window asking for the framework to add, choose <span class="strong"><strong class="calibre8">CoreLocation</strong></span> and <span class="strong"><strong class="calibre8">MapKit</strong></span>.</li><li class="listitem" value="3">Now go to the storyboard, place a label and a MapKit view, you might have a layout similar to this one:<div class="mediaobject"><img src="../images/00089.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Link the MapKit view and call it just map, and the <code class="email">UILabel</code> and call it just label:<div class="informalexample"><pre class="programlisting">    @IBOutlet var label: UILabel!
    @IBOutlet var map: MKMapView!</pre></div></li><li class="listitem" value="5">Continuing with the <a id="id351" class="calibre1"/>view controller, let's click at the beginning of the file to add the <code class="email">CoreLocation</code> and <code class="email">MapKit</code> imports:<div class="informalexample"><pre class="programlisting">import CoreLocation
import MapKit</pre></div></li><li class="listitem" value="6">After that you have to initialize the location manager object on the <code class="email">viewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }</pre></div><p class="calibre15">At this moment you may get an error because your view controller doesn't conform with the <code class="email">CLLocationManagerDelegate</code>, so let's go to the header of the view controller class and let's specify that it implements this protocol. Another error we have is the <code class="email">locationManager</code> variable, because it is not declared, therefore we have to create it as an attribute. And as we are declaring attributes, we are going to <a id="id352" class="calibre1"/>add the geocoder, which is going to be used later:</p><div class="informalexample"><pre class="programlisting">class ViewController: UIViewController, <span class="strong"><strong class="calibre8">CLLocationManagerDelegate</strong></span> {
    var locationManager = CLLocationManager()
    var geocoder = CLGeocoder()</pre></div></li><li class="listitem" value="7">Before we implement the method that receives the positioning, let's create another method to detect whether there was any authorization error:<div class="informalexample"><pre class="programlisting">    func locationManager(manager: CLLocationManager!,
        didChangeAuthorizationStatus status: CLAuthorizationStatus) {
            var locationStatus:String
            switch status {
            case CLAuthorizationStatus.Restricted:
                locationStatus = "Access: Restricted"
                break
            case CLAuthorizationStatus.Denied:
                locationStatus = "Access: Denied"
                break
            case CLAuthorizationStatus.NotDetermined:
                locationStatus = "Access: NotDetermined"
                break
            default:
                locationStatus = "Access: Allowed"
            }
            NSLog(locationStatus)
    }</pre></div></li><li class="listitem" value="8">Then, we can implement the method that will update our location:<div class="informalexample"><pre class="programlisting">    func locationManager(manager:CLLocationManager, didUpdateLocations locations:[AnyObject]) {
        if locations[0] is CLLocation {
          let location:CLLocation = locations[0] as CLLocation
          self.map.setRegion(MKCoordinateRegionMakeWithDistance(location.coordinate, 800,800), animated: true)
          
          geocoder.reverseGeocodeLocation(location, completionHandler: { (addresses, error) -&gt; Void in
                  let placeMarket:CLPlacemark = addresses[0] as CLPlacemark
                let curraddress:String = (placeMarket.addressDictionary["FormattedAddressLines"] as [String]) [0] as String
                    self.label.text = "You are at \(curraddress)"
            })
        }
    }</pre></div></li><li class="listitem" value="9">Before you test the <a id="id353" class="calibre1"/>app there is still another step to do. On your project, navigate to or click expand on the supporting files and then click on <span class="strong"><strong class="calibre8">info.plist</strong></span>. Add a row by right-clicking on the list and selecting <span class="strong"><strong class="calibre8">add row</strong></span>.</li><li class="listitem" value="10">On this new row, type <code class="email">NSLocationWhenInUseUsageDescription</code> as key, and on value Permission required, like the following screenshot:<div class="mediaobject"><img src="../images/00090.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">Select a device and install this app onto it, and test the application walking around your street (or walking around planet Earth if you want). Check that the label will change and also that the map will display your current position.</li><li class="listitem" value="12">Now go back to your computer and plug the device in again, now instead of pressing play you have to hold the play button until you see more options and then you have to select the profile option:<div class="mediaobject"><img src="../images/00091.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="13">The next thing that will happen is that instruments is going to open, probably a dialog will pop up asking for an administrator account. That's due to instruments needing <a id="id354" class="calibre1"/>to use some special permissions to access some low-level information:<div class="mediaobject"><img src="../images/00092.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="14">On the next dialog you will see different kinds of instruments, some of them are OS X specific, some are iOS specific, and others are for both. If you choose the <a id="id355" class="calibre1"/>wrong platform instrument the record button will be disabled. For this recipe choose energy diagnostics:<div class="mediaobject"><img src="../images/00093.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="15">Once the <span class="strong"><strong class="calibre8">Energy Diagnostics</strong></span> window is open you can press the record button, which is on the upper-left corner, and try to move around—yes, you need to keep the device connected to your computer so you have to move around with both elements together—and do some actions with your device, such as pressing the home button and turning off the screen. Now you may have a screen similar to this one:<div class="mediaobject"><img src="../images/00094.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="16">Now you can analyze who is spending more energy on your app. To get a better idea about <a id="id356" class="calibre1"/>it, go to your code and replace the constant <code class="email">kCLLocationAccuracyBest</code> with <code class="email">kCLLocationAccuracyThreeKilometers</code> and check whether you have saved some energy.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Profiling an app">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec186" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Instruments is a tool used for profiling your application. It gives you information about your app, which can't be retrieved by code, or at least can't be retrieved easily. You can check whether your app has memory leaks, whether it is losing performance, and as you can see, whether it is wasting much energy or not.</p><p class="calibre7">In this recipe we used the GPS because it is a sensor that requires some energy, and also you can check on the table on the bottom of your instrument that Internet requests were done, which is something that if you do very frequently, will also empty your battery fast.</p><p class="calibre7">Something you might be asking is: why did we have to change the <code class="email">info.plist</code>? Since iOS 8, some sensors require user permissions; the GPS is one of them, so you need to report the message <a id="id357" class="calibre1"/>that is going to be shown to the user.</p></div></div>

<div class="book" title="Profiling an app">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec187" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">It is recommended that you read about the way that instruments work, mainly those that you are going to <a id="id358" class="calibre1"/>use. Check the Apple documentation about instruments to get more details about it: <a class="calibre1" href="https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html">https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html</a>.</li><li class="listitem">If you have experience with Objective-C you might be asking how could you recycle your code using Swift, in the next chapter we are going to see some recipes for this.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Error handling in Swift 2.0" id="1VSLM1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec61" class="calibre1"/>Error handling in Swift 2.0</h1></div></div></div><p class="calibre7">With the introduction <a id="id359" class="calibre1"/>of Swift 2.0, Apple has provided an entirely new way to <a id="id360" class="calibre1"/>perform error handling, similar to other programming languages. Not only can you take advantage of this in your own classes, Apple has also updated all of its classes to use the new error handling methods.</p></div>

<div class="book" title="Error handling in Swift 2.0" id="1VSLM1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec188" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new single view project and name it <code class="email">Error Handling Chapter 7</code>. We will be using the boiler plate project setup for this recipe.</p></div></div>

<div class="book" title="Error handling in Swift 2.0" id="1VSLM1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec189" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open <code class="email">ViewController.swift</code> and add the following function:<div class="informalexample"><pre class="programlisting">func performAnErrorProneTask() {
        
        var error: NSError?
        var someString: String = "string"
        var someURL: NSURL = NSURL(string: "http://www.someurl.com")!

        let success = someString.writeToURL(someURL, atomically: true, encoding: NSUTF8StringEncoding, error: &amp;error)
        if !success {
            print("Error writing to URL: \(error!)")
        }
        
    }</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre7">Upon running this code, you should receive an error <code class="email">Extra argument 'Error' in call</code>. With Swift 2.0, you are no longer required to pass the memory address of an error object, therefore the error argument is no longer needed and has been removed from the Apple standard library.</p></div></li><li class="listitem" value="2">Update the <a id="id361" class="calibre1"/>code in the method call to the following:<div class="informalexample"><pre class="programlisting">let someString: String = "string"
        let someURL: NSURL = NSURL(string: "http://www.someurl.com")!
        
        do {
            let success = try someString.writeToURL(someURL, atomically: true, encoding: NSUTF8StringEncoding)
        }
        catch let error as NSError {
            print(error.localizedDescription)
        }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Error handling in Swift 2.0" id="1VSLM1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec190" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Similar to C++, Swift 2.0 now uses a do-try-catch method of error handling. Inside the do block we attempt to perform some task that can result in an error and prefix it with the try keyword. This lets Xcode know that this method can fail and to look for a catch block if a failure occurs.</p><p class="calibre7">You can tell what <a id="id362" class="calibre1"/>methods require this error handling by looking at the method declaration. All methods with error handling will include a throws keyword at the tail end of the declaration. We will learn in the next recipe how to define your own methods that incorporate error handling.</p><p class="calibre7">Additionally, the try keyword can be used with both ? and ! for additional functionality. Using try? for instance will result in the returned value wrapped in an optional. Rather than performing a do-while loop and catching the error to set a value to nil, you can simply substitute try? and the value will now function as an optional with standard nil handling. When using try!, you explicitly ignore the error handling. This is only used when you already know a value will not produce an error; for example, loading an image that was shipped with the application.</p></div></div>

<div class="book" title="Error handling in Swift 2.0" id="1VSLM1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec191" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">You will often require some code to run regardless of errors. Swift 2.0 adds a new feature that works great for just <a id="id363" class="calibre1"/>this scenario: the defer keyword. Any code <a id="id364" class="calibre1"/>provided inside of the defer block will automatically execute once it reaches the end of the containing scope. This feature works anywhere in code.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Custom error handling in Swift 2.0" id="20R681-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec62" class="calibre1"/>Custom error handling in Swift 2.0</h1></div></div></div><p class="calibre7">The new error <a id="id365" class="calibre1"/>handling in Swift 2.0 is not limited to the <a id="id366" class="calibre1"/>Apple standard library. You can include this new syntax in your own classes and methods. Doing so allows you to build applications that handle all errors appropriately, often resulting in a better user experience and with fewer crashes. Additionally, this new error handling can be leveraged for more complex debugging.</p></div>

<div class="book" title="Custom error handling in Swift 2.0" id="20R681-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec192" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new single view project and name it <code class="email">Custom Error Handling Chapter 7</code>. We will be using the boilerplate project setup for this recipe. If you followed the previous recipe in this chapter, you may continue using that project.</p></div></div>

<div class="book" title="Custom error handling in Swift 2.0" id="20R681-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec193" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Navigate to the <code class="email">ViewController.swift</code> file and add the following code to the bottom of the file:<div class="informalexample"><pre class="programlisting">enum CustomError: ErrorType {
    case Minimal
    case Bad
    case Explosion
}</pre></div></li><li class="listitem" value="2">Let's implement a custom method that uses the <code class="email">CustomError</code> enum we just created. Add the following code below our enum declaration:<div class="informalexample"><pre class="programlisting">func performTaskWithString(taskString: String) throws -&gt; String {
    // Do something that will result in a success or error.
    
    // If a minimal error occurs, throw a minimal error
    if (taskString.isEmpty) {
        throw CustomError.Minimal
    }
    
    // If a bad error occurs, throw a bad error
    if (taskString.containsString("Oops")) {
        throw CustomError.Bad
    }
    
    // If an explosixe error occurs, throw an explosion error
    if (taskString.containsString("ABORT ABORT ABORT")) {
        throw CustomError.Explosion
    }
    
    return "No errors!!"
}</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Custom error handling in Swift 2.0" id="20R681-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec194" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">We initially create a custom enum to store any required custom error types. These types can be explicit to your application or generic enough for a framework. Swift 2.0 uses the throws keyword placed before the return value of a method in order to identify methods with error handling.</p><p class="calibre7">In our custom method, we want to perform any task that can possibly fail, such as a URL request. Next, we validate the possible errors and call <code class="email">throw</code> with the error type. Everything after our <a id="id367" class="calibre1"/>checks will run as normal if no errors are <a id="id368" class="calibre1"/>thrown.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec63" class="calibre1"/>Availability checking in Swift 2.0</h1></div></div></div><p class="calibre7">Swift 2.0 <a id="id369" class="calibre1"/>introduces a new method for checking OS availability in your code. This is done in the form of <code class="email">@available</code> and allows us to check for OS support for both calling methods and creating our own. Using this new availability checking allows you to write backwards-compatible code without the worry of runtime errors. Xcode 7 has great integration with <code class="email">@available</code> for a better programmer experience without many warnings. Additionally, you can more clearly define tasks based on the OS version without the hassle of macros.</p></div>

<div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec195" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new single view project and name it <code class="email">Availability Chapter 7</code>. We will be using the boiler plate project setup for this recipe. If you followed the previous recipe in this chapter, you may continue using that project.</p></div></div>

<div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec196" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To test this <a id="id370" class="calibre1"/>functionality, we will be using an Apple standard library call for registering notifications. iOS 8 introduced a new method for this, so we want to target iOS 8 and up only.</li><li class="listitem" value="2">Navigate to the project settings and change the minimum deployment target to iOS 7.1 or below. Because the notification method is supported in 8.0 and above, we want to test with 7.1 as our target.</li><li class="listitem" value="3">Navigate to the projects <code class="email">AppDelegate.swift</code> file and add the following code to the <code class="email">didFinishLaunchingWithOptions</code> method:<div class="informalexample"><pre class="programlisting">if #available(iOS 8.0, *) {
     let types = UIUserNotificationType([UIUserNotificationType.Alert, UIUserNotificationType.Sound, UIUserNotificationType.Badge])
     let settings = UIUserNotificationSettings(forTypes: types, categories: nil)
     application.registerUserNotificationSettings(settings)
  }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec197" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">We use the new syntax <code class="email">#available</code>(version number) to specify the version we require to run this block of code. The <code class="email">*</code> simply indicates all versions above the stated version. Additionally, this syntax supports adding multiple platforms, such as OS X and watchOS.</p></div></div>

<div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec198" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Using the <code class="email">@available</code>(version number) syntax, you can specify individual functions and classes as only available in a specific version. Simply include this line directly above the function or class declaration.</p></div></div>

<div class="book" title="Availability checking in Swift 2.0" id="21PMQ1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="See also…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec199" class="calibre1"/>See also…</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Apple has supplied numerous <a id="id371" class="calibre1"/>attributes that can be used in conjunction with <code class="email">@available</code>. Visit this link to the Apple documentation to learn more about attributes: <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html</a></li></ul></div></div></div></body></html>