- en: Chapter 7. Creating Animations, Transformations, and Understanding Drag-and-drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating a View using the "animate" method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a View using 2D matrix and 3D matrix transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging an ImageView using touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling an ImageView using a Slider control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving our Funny Face image using the toImage() method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost any control or element in Titanium can have an animation or transform
    applied to it. This allows you to enhance your applications by adding a level
    of interactivity and "bling" that your apps would otherwise perhaps not have.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to create a small application that allows the
    user to choose a "funny face" image, which we are going to position over the top
    of a photograph of ourselves. We'll use transitions and animations in order to
    display the funny face pictures and allow the user to adjust the size of his/her
    photograph and its position so that it fits neatly within the funny-face cutout
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll combine both our "me" photograph and the funny face into one
    complete image using the Windows `toImage()` method, letting the user e-mail the
    resulting image to his/her friends!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this entire chapter can be found in the `Chapter 7/FunnyFaces`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a View using the "animate" method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any Window, View, or Component in Titanium can be animated using the `animate`
    method. This allows you to quickly and confidently create animated objects that
    can give your applications the "wow" factor. Additionally, you can use animations
    as a way of holding information or elements off screen until they are actually
    required. A good example of this would be if you had three different TableViews
    but only wanted one of those views visible at any one time. Using animations,
    you could slide those tables in and out of the screen space whenever it suited
    you, without the complication of creating additional Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipe, we will create the basic structure of our application
    by laying out a number of different components and then get down to animating
    four different ImageViews. These will each contain a different image to use as
    our "Funny Face" character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `FunnyFaces`
    as the name of the app, and fill in the rest of the details with your own information.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is, *com.packtpub.funnyfaces)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is copy all of the required images into an `images` folder
    under your project's `Resources` folder. Then, open the `app.js` file in your
    IDE and replace its contents with the following code. This code will form the
    basis of our FunnyFaces application layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run your application in the emulator for the first time, and you
    should end up with a screen that looks just similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3968EXP_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, back in the `app.js` file, we are going to animate the four ImageViews
    which will each provide an option for our funny face image. Inside the declaration
    of the `imageViewFace` object''s event handler, type in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the emulator from Titanium Studio and you should see the initial
    layout with our "Tap To Choose An Image" view visible. Tapping the choose ImageView
    should now animate our four funny face options onto the screen, as seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first block of code creates the basic layout for our application, which
    consists of a couple of ImageViews, a footer view holding our "save" button, and
    the Slider control, which we'll use later on to increase the zoom scale of our
    own photograph. Our second block of code is where it gets interesting. Here, we're
    doing a simple check that the user hasn't already selected an image using the
    `imageSelected` Boolean, before getting into our animated ImageViews, named `image1,
    image2, image3, and image4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept behind the animation of these four ImageViews is pretty simple.
    All we''re essentially doing is changing the properties of our control over a
    period of time, defined by us in milliseconds. Here, we are changing the `top`
    and `left` properties of all of our images over a period of half a second so that
    we get an effect of them sliding into place on our screen. You can further enhance
    these animations by adding more properties to animate, for example, if we wanted
    to change the opacity of image1 from 50 percent to 100 percent as it slides into
    place, we could change the code to look something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the curve property of `animate()` allows you to adjust the easing
    of your animated component. Here, we used all four animation-curve constants on
    each of our ImageViews. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_IN:` Accelerate the animation slowly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_OUT:` Decelerate the animation slowly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT:` Accelerate and decelerate the animation
    slowly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Titanium.UI.ANIMATION_CURVE_LINEAR:` Make the animation speed constant throughout
    the animation cycles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a View using 2D matrix and 3D matrix transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that each of our ImageViews in the previous recipe had
    a `click` event listener attached to them, calling an event handler named `setChosenImage`.
    This event handler is going to handle setting our chosen "funny face" image to
    the `imageViewFace` control. It will then animate all four "funny face" ImageView
    objects on our screen area using a number of different 2D and 3D matrix transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Replace the existing `setChosenImage` function, which currently stands empty,
    with the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, we are creating animations for each of the four ImageViews, but this
    time in a slightly different way. Instead of using the built-in `animate` method,
    we are creating a separate animation object for each ImageView, before calling
    the ImageView's `animate` method and passing this animation object to it. This
    method of creating animations allows you to have finer control over them, including
    the use of transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Transforms have a couple of shortcuts to help you perform some of the most common
    animation types quickly and easily. The `image1` and `image2` transforms, as shown
    in the previous code, use the `rotate` and `scale` methods respectively. Scale
    and rotate in this case are 2D matrix transforms, meaning they only transform
    the object in two-dimensional space along its X-axis and Y-axis. Each of these
    transformation types takes a single integer parameter; for scale, it is 0-100
    percent and for rotate, the number of it is 0-360 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using transforms for your animations is that you can easily
    chain them together to perform a more complex animation style. In the previous
    code, you can see that both a `scale` and a `rotate` transform are transforming
    the `image3` component. When you run the application in the emulator or on your
    device, you should notice that both of these transform animations are applied
    to the `image3` control!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `image4` control also has a transform animation applied to it,
    but this time we are using a 3D matrix transform instead of the 2D matrix transforms
    used for the other three ImageViews. These work the same way as regular 2D matrix
    transforms, except that you can also animate your control in 3D space, along the
    Z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note that animations have two event listeners: `start` and
    `complete`. These event handlers allow you to perform actions based on the beginning
    or ending of your animation''s life cycle. As an example, you could chain animations
    together by using the `complete` event to add a new animation or transform to
    an object after the previous animation has finished. In our previous example,
    we are using this `complete` event to remove our ImageView from the Window once
    its animation has finished.'
  prefs: []
  type: TYPE_NORMAL
- en: Dragging an ImageView using touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have allowed the user to select a funny face image from our four
    animated ImageView controls, we need to allow them to adjust the position of their
    own photo so it fits within the transparent hole that makes up the face portion
    of our funny face. We are going to do this using the touch events provided by
    the ImageView control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to perform this task is by capturing the X and Y touch points
    and moving the ImageView to that location. The code for this is simple. Just add
    the following code after your declaration of the `imageViewFace` control, but
    before you add this control to your window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run your app in the emulator, and after selecting a funny face image,
    attempt to touch-and-drag your photograph around the screen. You should notice
    that it works but it doesn''t seem quite right, does it? This is because we are
    moving the image based on the top corner position, instead of the center of the
    object. Let''s change our code to instead work on the center point of the `imageViewMe`
    control, by replacing the previous code with the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app in the emulator again and after selecting a funny face image,
    attempt to touch-and-drag your photograph around the screen. This time you should
    notice a much smoother, more natural feeling drag-and-drop effect! Try positioning
    your "me" photograph into the center of one of your funny faces, and you should
    be able to replicate the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we are using two separate touch events to transform the left and top positioning
    properties of our `imageViewMe` control. First, we need to find the center point.
    We do this in our `touchstart` event by the `center.x` and `center.y` properties
    of our ImageView control and then assign these to a couple of custom variables
    we have named "ox" and "oy". Doing this within the `touchstart` event ensures
    that these variables are immediately available to us when the `touchmove` event
    occurs. Then, within our `touchmove` event, instead of changing the top and left
    properties of `imageViewMe`, we pass its center property to our new x and y co-ordinates
    based on the touch events x and y properties, minus the center point we saved
    as our object's ox and oy variables. This ensures that the movement of the image
    is nice and smooth!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling an ImageView using a Slider control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created a code to select an animated funny face and we have the
    ability to move our image around using the drag-and-drop method. We need to be
    able to scale our —me— photograph using a Slider control and a new transformation.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipe, we will hook up the event listener of our Slider control
    and use another 2D matrix transformation, and this time change the scale of our
    `imageViewMe` control based on the user input.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Near the bottom of your current source code, you should have instantiated a
    Slider control named "`zoomSlider`". We are going to replace that code with a
    slightly updated version, and then capture the slider''s change event in order
    to scale our `imageViewMe` component based on the value selected. Replace your
    declaration of the `zoomSlider` component with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running your application in the emulator now, and after selecting a funny
    face image, you should be able to scale the "me" photograph using the Slider control.
    Try using it in conjunction with the touch-and-drag from the previous recipe to
    fit your face inside the funny picture hole, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are performing a very similar action to what we did in the second recipe
    of this chapter. Within the change event handler of our Slider control, we are
    applying a 2D matrix transform to the `imageViewMe` control, using the scale method.
    Our slider has been given a minimum value of 0 and a maximum of 100\. These values
    are the relative percentages that we are going to scale our image by. By using
    a very short duration (for example, 100 milliseconds) on our animation, we can
    make the movement of the slider almost instantaneously relate to the scale of
    the "me" photograph.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our "Funny Face" image using the toImage() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the very last part of this application, we want to combine the two images
    together (our "me" photograph and the funny face image we have chosen) and save
    them to the filesystem as one complete image. To do this, we will hook up the
    event listener of our save button control and use another common method found
    on almost all views and control types; `toImage`. Once we've combined our two
    images together and saved it off to the local filesystem, we'll then create a
    quick e-mail dialog and attach our funny face to it, allowing the user to send
    the complete image to his/her friends.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Underneath the instantiation of your `btnSave` object, add the following event
    listener and handler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, launch your application in the emulator or on your device, again going
    through all of the steps until you have chosen a funny face, and adjust the layout
    of your photograph accordingly. When done, hit the **save** button and you should
    see an e-mail dialog appear with your combined image visible as an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `toImage` method simply takes a combined screenshot of the element in question.
    In our case, we are performing the command on `win1`, our root `Window` object.
    To do this, we are simply hiding our footer control and then setting a short timeout.
    When elapsed, it uses `toImage` to take a combined screenshot of both our `imageViewMe`
    and `imageViewFace` controls, which we then save to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: There is another method that most controls have called `toBlob`, which works
    in a very similar manner to `toImage`. Depending on what you are trying to achieve,
    you can generally use either one of these methods. However, at times, you will
    find that the Titanium API will contain bugs and only one of them may work. In
    particular, the `toBlob` method works far better on Android devices than the `toImage`
    method does. However, as the Titanium platform grows more stable, you can expect
    better performance from both of these API calls. Additionally, you would use the
    `toBlob` method in order to store blob data in a local database using SQLite,
    though in general this approach is not normally used as it is very memory intensive.
    Saving blob objects to the filesystem is the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows our final combined image, which has been saved
    to the filesystem and attached to a new e-mail dialog ready to be shared among
    the user's friends and family!
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
