- en: Chapter 7. Creating Animations, Transformations, and Understanding Drag-and-drop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：创建动画、变换以及理解拖放
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Animating a View using the "animate" method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“animate”方法对视图进行动画处理
- en: Animating a View using 2D matrix and 3D matrix transforms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D矩阵和3D矩阵变换对视图进行动画处理
- en: Dragging an ImageView using touch events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触摸事件拖动`ImageView`
- en: Scaling an ImageView using a Slider control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滑动控件缩放`ImageView`
- en: Saving our Funny Face image using the toImage() method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`toImage()`方法保存我们的“Funny Face”图像
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Almost any control or element in Titanium can have an animation or transform
    applied to it. This allows you to enhance your applications by adding a level
    of interactivity and "bling" that your apps would otherwise perhaps not have.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎Titanium中的任何控件或元素都可以应用动画或变换。这允许你通过添加交互性和“bling”级别来增强你的应用程序，否则你的应用程序可能没有。
- en: In this chapter, we are going to create a small application that allows the
    user to choose a "funny face" image, which we are going to position over the top
    of a photograph of ourselves. We'll use transitions and animations in order to
    display the funny face pictures and allow the user to adjust the size of his/her
    photograph and its position so that it fits neatly within the funny-face cutout
    section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个小应用程序，允许用户选择一个“有趣的表情”图像，我们将将其放置在我们自己的照片的顶部。我们将使用过渡和动画来显示有趣的表情图片，并允许用户调整他/她的照片的大小和位置，以便它能够整齐地位于有趣的表情剪影部分内。
- en: Finally, we'll combine both our "me" photograph and the funny face into one
    complete image using the Windows `toImage()` method, letting the user e-mail the
    resulting image to his/her friends!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Windows的`toImage()`方法将我们的“我”的照片和有趣的表情合并成一张完整的图像，让用户可以将生成的图像通过电子邮件发送给他的朋友！
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this entire chapter can be found in the `Chapter 7/FunnyFaces`
    folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节的完整源代码可以在`Chapter 7/FunnyFaces`文件夹中找到。
- en: Animating a View using the "animate" method
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“animate”方法对视图进行动画处理
- en: Any Window, View, or Component in Titanium can be animated using the `animate`
    method. This allows you to quickly and confidently create animated objects that
    can give your applications the "wow" factor. Additionally, you can use animations
    as a way of holding information or elements off screen until they are actually
    required. A good example of this would be if you had three different TableViews
    but only wanted one of those views visible at any one time. Using animations,
    you could slide those tables in and out of the screen space whenever it suited
    you, without the complication of creating additional Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Titanium中的任何窗口、视图或组件都可以使用`animate`方法进行动画处理。这允许你快速自信地创建可以给你的应用程序带来“哇”效果的动画对象。此外，你可以使用动画作为在屏幕上保持信息或元素的方法，直到它们实际需要时。一个很好的例子是，如果你有三个不同的TableView，但只想在任何时候显示其中一个视图。使用动画，你可以根据需要将那些表格滑动到屏幕空间内或滑出屏幕空间，而无需创建额外的窗口。
- en: In the following recipe, we will create the basic structure of our application
    by laying out a number of different components and then get down to animating
    four different ImageViews. These will each contain a different image to use as
    our "Funny Face" character.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们将通过布局多个不同的组件来构建我们应用程序的基本结构，然后开始对四个不同的`ImageView`进行动画处理。每个`ImageView`将包含一个不同的图像，用作我们的“Funny
    Face”角色。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    1` folder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 7/Recipe 1`文件夹中找到。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `FunnyFaces`
    as the name of the app, and fill in the rest of the details with your own information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个菜谱，打开Titanium Studio并登录，如果你还没有登录的话。如果你需要注册新账户，你可以在应用程序内部免费注册。登录后，点击**新建项目**，创建新项目的详细信息窗口将出现。将应用程序名称输入为`FunnyFaces`，并使用你自己的信息填写其余的详细信息。
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is, *com.packtpub.funnyfaces)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意应用程序标识符，它以反向域名表示法（即，*com.packtpub.funnyfaces*）正常书写。在项目创建后，此标识符不容易更改，您在创建用于分发应用程序的配置文件时需要完全匹配它。
- en: The first thing to do is copy all of the required images into an `images` folder
    under your project's `Resources` folder. Then, open the `app.js` file in your
    IDE and replace its contents with the following code. This code will form the
    basis of our FunnyFaces application layout.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是将所有必需的图片复制到项目“资源”文件夹下的“images”文件夹中。然后，在您的IDE中打开“app.js”文件，并用以下代码替换其内容。这段代码将成为我们FunnyFaces应用程序布局的基础。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build and run your application in the emulator for the first time, and you
    should end up with a screen that looks just similar to the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在模拟器中构建和运行您的应用程序，您应该得到一个看起来与以下示例类似的屏幕：
- en: '![Getting ready](img/3968EXP_07_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/3968EXP_07_01.jpg)'
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now, back in the `app.js` file, we are going to animate the four ImageViews
    which will each provide an option for our funny face image. Inside the declaration
    of the `imageViewFace` object''s event handler, type in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到“app.js”文件中，我们将对四个ImageView进行动画处理，每个ImageView将提供一个搞笑面孔图片的选项。在`imageViewFace`对象的事件处理程序声明中，输入以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now launch the emulator from Titanium Studio and you should see the initial
    layout with our "Tap To Choose An Image" view visible. Tapping the choose ImageView
    should now animate our four funny face options onto the screen, as seen in the
    following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从Titanium Studio中启动模拟器，您应该看到带有“点击选择图片”视图的初始布局。点击选择ImageView现在应该将我们的四个搞笑面孔选项动画化到屏幕上，如以下截图所示：
- en: '![How to do it…](img/3968EXP_07_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3968EXP_07_02.jpg)'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first block of code creates the basic layout for our application, which
    consists of a couple of ImageViews, a footer view holding our "save" button, and
    the Slider control, which we'll use later on to increase the zoom scale of our
    own photograph. Our second block of code is where it gets interesting. Here, we're
    doing a simple check that the user hasn't already selected an image using the
    `imageSelected` Boolean, before getting into our animated ImageViews, named `image1,
    image2, image3, and image4`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码创建了应用程序的基本布局，包括几个ImageView、一个包含“保存”按钮的页脚视图以及我们将用于稍后增加我们自己的照片缩放比例的Slider控件。我们的第二段代码是其中最有趣的部分。在这里，我们通过检查用户是否已经使用`imageSelected`布尔值选择了图片，然后进入名为`image1、image2、image3和image4`的动画ImageView。
- en: 'The concept behind the animation of these four ImageViews is pretty simple.
    All we''re essentially doing is changing the properties of our control over a
    period of time, defined by us in milliseconds. Here, we are changing the `top`
    and `left` properties of all of our images over a period of half a second so that
    we get an effect of them sliding into place on our screen. You can further enhance
    these animations by adding more properties to animate, for example, if we wanted
    to change the opacity of image1 from 50 percent to 100 percent as it slides into
    place, we could change the code to look something similar to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个ImageView动画背后的概念相当简单。我们本质上只是在毫秒数内改变我们控制的属性，这些毫秒数是我们自己定义的。在这里，我们在半秒内改变所有图片的`top`和`left`属性，以便在屏幕上产生它们滑入位置的视觉效果。您可以通过添加更多要动画化的属性来进一步增强这些动画，例如，如果我们想在图片1滑入位置时将其不透明度从50%变为100%，我们可以将代码更改为类似以下的形式：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the curve property of `animate()` allows you to adjust the easing
    of your animated component. Here, we used all four animation-curve constants on
    each of our ImageViews. They are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`animate()`函数的曲线属性允许您调整动画组件的缓动效果。在这里，我们在每个ImageView上使用了所有四个动画曲线常量。它们是：
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_IN:` Accelerate the animation slowly'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Titanium.UI.ANIMATION_CURVE_EASE_IN:` 动画开始时缓慢加速'
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_OUT:` Decelerate the animation slowly'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Titanium.UI.ANIMATION_CURVE_EASE_OUT:` 动画结束时缓慢减速'
- en: '`Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT:` Accelerate and decelerate the animation
    slowly'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Titanium.UI.ANIMATION_CURVE_EASE_IN_OUT:` 动画开始和结束时都缓慢加速和减速'
- en: '`Titanium.UI.ANIMATION_CURVE_LINEAR:` Make the animation speed constant throughout
    the animation cycles'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Titanium.UI.ANIMATION_CURVE_LINEAR:` 使动画在整个动画周期中速度保持恒定'
- en: Animating a View using 2D matrix and 3D matrix transforms
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用2D矩阵和3D矩阵变换来动画化视图
- en: You may have noticed that each of our ImageViews in the previous recipe had
    a `click` event listener attached to them, calling an event handler named `setChosenImage`.
    This event handler is going to handle setting our chosen "funny face" image to
    the `imageViewFace` control. It will then animate all four "funny face" ImageView
    objects on our screen area using a number of different 2D and 3D matrix transforms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的菜谱中，我们为每个`ImageView`都附加了一个`click`事件监听器，调用名为`setChosenImage`的事件处理器。这个事件处理器将负责将我们的选择“搞笑面孔”图像设置到`imageViewFace`控件上。然后，它将使用多种2D和3D矩阵变换来动画化屏幕区域上的所有四个“搞笑面孔”`ImageView`对象。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    2` folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 7/Recipe 2`文件夹中找到。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Replace the existing `setChosenImage` function, which currently stands empty,
    with the following source code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下源代码替换现有的空`setChosenImage`函数：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Again, we are creating animations for each of the four ImageViews, but this
    time in a slightly different way. Instead of using the built-in `animate` method,
    we are creating a separate animation object for each ImageView, before calling
    the ImageView's `animate` method and passing this animation object to it. This
    method of creating animations allows you to have finer control over them, including
    the use of transforms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们正在为四个`ImageView`中的每一个创建动画，但这次的方式略有不同。我们不是使用内置的`animate`方法，而是在调用`ImageView`的`animate`方法并将此动画对象传递给它之前，为每个`ImageView`创建一个单独的动画对象。这种方法创建动画可以让你更精细地控制它们，包括使用变换。
- en: Transforms have a couple of shortcuts to help you perform some of the most common
    animation types quickly and easily. The `image1` and `image2` transforms, as shown
    in the previous code, use the `rotate` and `scale` methods respectively. Scale
    and rotate in this case are 2D matrix transforms, meaning they only transform
    the object in two-dimensional space along its X-axis and Y-axis. Each of these
    transformation types takes a single integer parameter; for scale, it is 0-100
    percent and for rotate, the number of it is 0-360 degrees.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 变换有一些快捷方式可以帮助你快速轻松地执行一些最常见的动画类型。如前代码所示，`image1`和`image2`变换分别使用`rotate`和`scale`方法。在这种情况下，缩放和旋转是2D矩阵变换，这意味着它们只在X轴和Y轴上的二维空间中变换对象。每种变换类型都接受一个单个整数参数；对于缩放，它是0-100%，对于旋转，数值是0-360度。
- en: Another advantage of using transforms for your animations is that you can easily
    chain them together to perform a more complex animation style. In the previous
    code, you can see that both a `scale` and a `rotate` transform are transforming
    the `image3` component. When you run the application in the emulator or on your
    device, you should notice that both of these transform animations are applied
    to the `image3` control!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变换进行动画的另一个优点是，你可以轻松地将它们链接起来以执行更复杂的动画风格。在之前的代码中，你可以看到`scale`和`rotate`变换都在变换`image3`组件。当你运行模拟器或设备上的应用程序时，你应该注意到这两个变换动画都应用于`image3`控件！
- en: Finally, the `image4` control also has a transform animation applied to it,
    but this time we are using a 3D matrix transform instead of the 2D matrix transforms
    used for the other three ImageViews. These work the same way as regular 2D matrix
    transforms, except that you can also animate your control in 3D space, along the
    Z-axis.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`image4`控件也应用了一个变换动画，但这次我们使用的是3D矩阵变换，而不是其他三个`ImageView`使用的2D矩阵变换。这些变换与常规的2D矩阵变换工作方式相同，除了你还可以在3D空间中，沿着Z轴动画化你的控件。
- en: 'It''s important to note that animations have two event listeners: `start` and
    `complete`. These event handlers allow you to perform actions based on the beginning
    or ending of your animation''s life cycle. As an example, you could chain animations
    together by using the `complete` event to add a new animation or transform to
    an object after the previous animation has finished. In our previous example,
    we are using this `complete` event to remove our ImageView from the Window once
    its animation has finished.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，动画有两个事件监听器：`start` 和 `complete`。这些事件处理器允许你根据动画生命周期的开始或结束执行操作。例如，你可以通过使用
    `complete` 事件在之前的动画完成后添加一个新的动画或变换到对象上，从而将动画链在一起。在我们的上一个例子中，我们就是使用这个 `complete`
    事件在动画完成后从窗口中移除我们的 ImageView。
- en: Dragging an ImageView using touch events
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触摸事件拖动 ImageView
- en: Now that we have allowed the user to select a funny face image from our four
    animated ImageView controls, we need to allow them to adjust the position of their
    own photo so it fits within the transparent hole that makes up the face portion
    of our funny face. We are going to do this using the touch events provided by
    the ImageView control.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经允许用户从我们的四个动画 ImageView 控件中选择一个有趣的表情图片，我们需要允许他们调整自己照片的位置，使其适合透明洞，这个洞构成了我们有趣表情的脸部部分。我们将使用
    ImageView 控件提供的触摸事件来完成这项工作。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    3` folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 7/Recipe 3` 文件夹中找到。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The simplest way to perform this task is by capturing the X and Y touch points
    and moving the ImageView to that location. The code for this is simple. Just add
    the following code after your declaration of the `imageViewFace` control, but
    before you add this control to your window:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此任务最简单的方法是捕获 X 和 Y 触摸点，并将 ImageView 移动到该位置。这段代码很简单。只需在你声明 `imageViewFace`
    控件之后，但在将其添加到窗口之前添加以下代码：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, run your app in the emulator, and after selecting a funny face image,
    attempt to touch-and-drag your photograph around the screen. You should notice
    that it works but it doesn''t seem quite right, does it? This is because we are
    moving the image based on the top corner position, instead of the center of the
    object. Let''s change our code to instead work on the center point of the `imageViewMe`
    control, by replacing the previous code with the following source code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模拟器中运行你的应用，并在选择一个有趣的表情图片后，尝试在屏幕上触摸并拖动你的照片。你应该会发现它工作得很好，但似乎并不完全正确，对吧？这是因为我们是根据对象的左上角位置移动图片，而不是以对象的中心为基准。让我们修改我们的代码，使其基于
    `imageViewMe` 控件的中心点，通过用以下源代码替换之前的代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run your app in the emulator again and after selecting a funny face image,
    attempt to touch-and-drag your photograph around the screen. This time you should
    notice a much smoother, more natural feeling drag-and-drop effect! Try positioning
    your "me" photograph into the center of one of your funny faces, and you should
    be able to replicate the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在模拟器中运行你的应用，并在选择一个有趣的表情图片后，尝试在屏幕上触摸并拖动你的照片。这次你应该会注意到一个更加平滑、更自然的拖放效果！尝试将你的“我”照片定位到其中一个有趣表情的中心，你应该能够复制以下截图：
- en: '![How to do it…](img/3968EXP_07_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/3968EXP_07_03.jpg)'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Here we are using two separate touch events to transform the left and top positioning
    properties of our `imageViewMe` control. First, we need to find the center point.
    We do this in our `touchstart` event by the `center.x` and `center.y` properties
    of our ImageView control and then assign these to a couple of custom variables
    we have named "ox" and "oy". Doing this within the `touchstart` event ensures
    that these variables are immediately available to us when the `touchmove` event
    occurs. Then, within our `touchmove` event, instead of changing the top and left
    properties of `imageViewMe`, we pass its center property to our new x and y co-ordinates
    based on the touch events x and y properties, minus the center point we saved
    as our object's ox and oy variables. This ensures that the movement of the image
    is nice and smooth!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个独立的触摸事件来变换我们的`imageViewMe`控件的左和上定位属性。首先，我们需要找到中心点。我们在`touchstart`事件中通过ImageView控件的`center.x`和`center.y`属性来完成这个操作，然后将这些属性分配给几个我们命名为“ox”和“oy”的自定义变量。在`touchstart`事件中这样做确保了当`touchmove`事件发生时，这些变量立即可用。然后，在我们的`touchmove`事件中，我们不是改变`imageViewMe`的顶部和左属性，而是根据触摸事件的x和y属性，减去我们保存为对象ox和oy变量的中心点，将图像的中心属性传递给新的x和y坐标。这确保了图像的移动既平滑又顺畅！
- en: Scaling an ImageView using a Slider control
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滑动条控件缩放ImageView
- en: We have now created a code to select an animated funny face and we have the
    ability to move our image around using the drag-and-drop method. We need to be
    able to scale our —me— photograph using a Slider control and a new transformation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个代码来选择一个动画搞笑脸，并且我们有能力使用拖放方法移动我们的图像。我们需要能够使用滑动条控件和一个新的变换来缩放我们的“我”照片。
- en: In the following recipe, we will hook up the event listener of our Slider control
    and use another 2D matrix transformation, and this time change the scale of our
    `imageViewMe` control based on the user input.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们将连接滑动条控件的监听器，并使用另一个2D矩阵变换，这次根据用户输入改变`imageViewMe`控件的缩放比例。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    4` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 7/Recipe 4`文件夹中找到。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Near the bottom of your current source code, you should have instantiated a
    Slider control named "`zoomSlider`". We are going to replace that code with a
    slightly updated version, and then capture the slider''s change event in order
    to scale our `imageViewMe` component based on the value selected. Replace your
    declaration of the `zoomSlider` component with the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在你当前的源代码底部附近，你应该已经实例化了一个名为"`zoomSlider`"的滑动条控件。我们将用稍微更新版本的代码替换它，然后捕获滑动条的更改事件，以便根据所选值缩放我们的`imageViewMe`组件。将你的`zoomSlider`组件声明替换为以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Try running your application in the emulator now, and after selecting a funny
    face image, you should be able to scale the "me" photograph using the Slider control.
    Try using it in conjunction with the touch-and-drag from the previous recipe to
    fit your face inside the funny picture hole, as seen in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在模拟器中运行你的应用程序，并在选择一个搞笑脸图像后，你应该能够使用滑动条控件来缩放“我”照片。尝试结合使用上一个菜谱中的触摸和拖动来将你的脸放入搞笑图片的洞中，如图所示：
- en: '![How to do it…](img/3968EXP_07_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/3968EXP_07_04.jpg)'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We are performing a very similar action to what we did in the second recipe
    of this chapter. Within the change event handler of our Slider control, we are
    applying a 2D matrix transform to the `imageViewMe` control, using the scale method.
    Our slider has been given a minimum value of 0 and a maximum of 100\. These values
    are the relative percentages that we are going to scale our image by. By using
    a very short duration (for example, 100 milliseconds) on our animation, we can
    make the movement of the slider almost instantaneously relate to the scale of
    the "me" photograph.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在执行与本章第二个菜谱中非常相似的操作。在我们的滑动条控件的改变事件处理程序中，我们正在应用一个2D矩阵变换到`imageViewMe`控件，使用缩放方法。我们的滑动条被赋予了最小值0和最大值100。这些值是我们将要缩放图像的相对百分比。通过在动画中使用非常短的时间（例如，100毫秒），我们可以使滑动条的移动几乎瞬间与“我”照片的缩放相关联。
- en: Saving our "Funny Face" image using the toImage() method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`toImage()`方法保存我们的“搞笑脸”图像
- en: For the very last part of this application, we want to combine the two images
    together (our "me" photograph and the funny face image we have chosen) and save
    them to the filesystem as one complete image. To do this, we will hook up the
    event listener of our save button control and use another common method found
    on almost all views and control types; `toImage`. Once we've combined our two
    images together and saved it off to the local filesystem, we'll then create a
    quick e-mail dialog and attach our funny face to it, allowing the user to send
    the complete image to his/her friends.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本应用程序的最后一部分，我们想要将两张图像（我们的“我”照片和选择的有趣表情）合并在一起，并将它们保存到文件系统中作为一个完整的图像。为此，我们将连接保存按钮控件的事件监听器，并使用在几乎所有视图和控制类型上都可以找到的另一个常用方法；`toImage`。一旦我们将两张图像合并并保存到本地文件系统中，我们将创建一个快速的电子邮件对话框，并将有趣的面部表情附加到它上，使用户能够将完整的图像发送给他的/她的朋友。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 7/Recipe
    5` folder.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 7/Recipe 5` 文件夹中找到。
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Underneath the instantiation of your `btnSave` object, add the following event
    listener and handler code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `btnSave` 对象实例化下面，添加以下事件监听器和处理程序代码：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, launch your application in the emulator or on your device, again going
    through all of the steps until you have chosen a funny face, and adjust the layout
    of your photograph accordingly. When done, hit the **save** button and you should
    see an e-mail dialog appear with your combined image visible as an attachment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模拟器或设备上再次启动您的应用程序，再次执行所有步骤，直到您选择了一个有趣的表情，并相应地调整您的照片布局。完成后，点击 **保存** 按钮，您应该会看到一个电子邮件对话框出现，您的综合图像作为附件可见。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `toImage` method simply takes a combined screenshot of the element in question.
    In our case, we are performing the command on `win1`, our root `Window` object.
    To do this, we are simply hiding our footer control and then setting a short timeout.
    When elapsed, it uses `toImage` to take a combined screenshot of both our `imageViewMe`
    and `imageViewFace` controls, which we then save to the filesystem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`toImage` 方法简单地获取了问题元素的综合截图。在我们的例子中，我们正在对 `win1` 执行命令，即我们的根 `Window` 对象。为此，我们只是隐藏了我们的页脚控件，然后设置了一个短暂的超时。当超时后，它使用
    `toImage` 来获取我们的 `imageViewMe` 和 `imageViewFace` 控件的综合截图，然后我们将它们保存到文件系统中。'
- en: There is another method that most controls have called `toBlob`, which works
    in a very similar manner to `toImage`. Depending on what you are trying to achieve,
    you can generally use either one of these methods. However, at times, you will
    find that the Titanium API will contain bugs and only one of them may work. In
    particular, the `toBlob` method works far better on Android devices than the `toImage`
    method does. However, as the Titanium platform grows more stable, you can expect
    better performance from both of these API calls. Additionally, you would use the
    `toBlob` method in order to store blob data in a local database using SQLite,
    though in general this approach is not normally used as it is very memory intensive.
    Saving blob objects to the filesystem is the recommended approach.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数控件还有一个名为 `toBlob` 的方法，其工作方式与 `toImage` 非常相似。根据您想要实现的目标，您通常可以使用这两种方法中的任何一种。然而，有时您会发现
    Titanium API 中存在错误，并且可能只有其中一种方法可以工作。特别是，`toBlob` 方法在 Android 设备上比 `toImage` 方法表现得更好。然而，随着
    Titanium 平台的日益稳定，您可以期待这两个 API 调用都能提供更好的性能。此外，您将使用 `toBlob` 方法来将 blob 数据存储在本地数据库中，使用
    SQLite，尽管通常不采用这种方法，因为它非常占用内存。将 blob 对象保存到文件系统是推荐的方法。
- en: The following screenshot shows our final combined image, which has been saved
    to the filesystem and attached to a new e-mail dialog ready to be shared among
    the user's friends and family!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的最终综合图像，它已被保存到文件系统中，并附加到一个新的电子邮件对话框中，准备与用户的亲朋好友分享！
- en: '![How it works…](img/3968EXP_07_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/3968EXP_07_05.jpg)'
