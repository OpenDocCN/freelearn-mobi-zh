- en: Chapter 4. Game Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have completed the first half of our game in the previous chapter.
    We started on developing the initial structure for the project by introducing
    the game objects to the screen. Currently, the paddle and ball movement is inactive,
    but everything displayed in the simulator is scaled accordingly to the original
    game design. The last phase of completing this tutorial is to add in all the actions
    that will occur in the game, including object movement and updating the score.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the paddle using touch events and accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection between all game objects in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing objects upon collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ball movement within screen boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win and lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home stretch! We can do it!
  prefs: []
  type: TYPE_NORMAL
- en: Moving in the up direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If making objects appear on screen is exciting to you, wait until you see them
    move! The main object of Breakout is to keep the ball above the paddle position
    to stay in play and have it collide with all the bricks to complete the level.
    What keeps the suspense flowing is the anticipation of the ball movement throughout
    the game screen. This wouldn't be possible without adding physical boundaries
    on the game objects to react to collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get even more physical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about how to integrate the physics engine into
    your code. We also started implementing physical bodies to the brick objects and
    now we'll need to do the same with other active game objects such as the paddle
    and the ball. Let's continue with this last half of the tutorial. We will continue
    using our `main.lua` file from the `Breakout` project folder.
  prefs: []
  type: TYPE_NORMAL
- en: physics.addBody()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Corona display objects can be turned into simulated physical objects using one
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: If no shape information is specified, the display object takes on the form of
    the actual rectangular boundary of the original image to create the physics body.
    For example, if a display object is 100 x 100 pixels, then that would be the actual
    size of the physics body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a shape is specified, then the body boundaries will follow the polygon provided
    by the shape. The shape coordinates must be defined in clockwise order, and the
    resulting shape must be convex-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a radius is specified, then the body boundaries will be circular and centered
    in the middle of the display object used to create the physics body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A body shape is a table of local (x,y) coordinates, relative to the center of
    the display object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circular shapes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Polygon shapes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circular bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Polygon bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object` (Object): A display object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bodyType` (String): Specifying the body type is optional. It uses a string
    parameter before the first body element. The possible types are`"static", "dynamic"`,
    and`"kinematic"`. The default type is`"dynamic"` if no value is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: static bodies don't move, and don't interact with each other; examples of static
    objects would include the ground or the walls of a pinball machine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: dynamic bodies are affected by gravity and collisions with the other body types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: kinematic objects are affected by forces but not by gravity, so you should generally
    set draggable objects to`"kinematic"`, at least for the duration of the drag event.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Density` (Number): Multiplied by the area of the body''s shape to determine
    mass. Based on a standard value of 1.0 for water. Lighter materials (such as wood)
    have a density below 1.0, and heavier materials (such as stone) have a density
    greater than 1.0\. Default value is `1.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Friction` (Number): May be any non-negative value; a value of 0 means no friction
    and 1.0 means fairly strong friction. The default value is `0.3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bounce` (Number): Determines the amount of an object''s velocity returned
    after a collision. The default value is `0.2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radius` (Number): Radius of the bounding circle in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shape` (Number): Shape value in the form of a table of the shape vertices,
    {x1,y1,x2,y2,...,xn,yn}. For example, `rectangleShape = { -6,-48, 6,-48, 6,48,
    -6,48 }`. The coordinates must be defined in clockwise order, and the resulting
    shape must be convex-only. (Physics assume the 0,0 point of an object, is the
    center of the object. A -x will be to the left of the object''s center and -y
    will be at the top of object''s center).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action—starting physics for the paddle and ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our display objects are rather stagnant. In order for gameplay to
    initiate, we have to activate physics for the paddle and ball in order for any
    kind of movement in the game to occur.
  prefs: []
  type: TYPE_NORMAL
- en: Above the `gameLevel1()` function, create a new function called `startGame()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the following lines to instantiate the physics of the paddle and ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an event listener that uses the background display object to remove the`"tap"`
    event for `startGame()`. Close the function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `addGameScreen()` function that we created in the previous chapter, we
    have to add the following line after the call to the `gameLevel1()` function.
    This starts the actual game when the background is touched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The paddle object has a`"static"` body type so it is not affected by any collision
    that occurs against it.
  prefs: []
  type: TYPE_NORMAL
- en: The ball object has a`"dynamic"` body type because we want it to be affected
    by the collisions on the screen due to directional changes by the wall borders,
    bricks and paddle.
  prefs: []
  type: TYPE_NORMAL
- en: The event listener on the background is removed from the `startGame()` function,
    that way it doesn't affect any of the other touch events that are applied in game.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting the paddle to move side to side is one of the key actions that needs
    to be accomplished. Part of the game design is to protect the ball from reaching
    the bottom of the screen. We will be separating paddle movement in the simulator
    and the accelerometer. The movement in the simulator enables us to test with touch
    events since accelerometer actions cannot be tested in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—dragging the paddle in the simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the paddle does not move at all. There are no coordinates set to
    translate on the screen, so let's create that.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the `addGameScreen()` function, create a new function called `dragPaddle(event)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll focus on moving the paddle side to side within the boundary of the
    game screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the preceding block of code to enable paddle movement in the simulator
    and then close the function. The reason for adding this block is because the simulator
    does not support accelerometer events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—dragging the paddle in the simulator](img/1888_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a function where the drag event only works in the simulator.
    For `if event.phase == "began"`, a touch has been made to the paddle. On `elseif
    event.phase == "moved"`, a touch has been moved on the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the paddle from moving past the wall boundaries, `paddle.x`
    does not go past`< 0` in the x-direction when it hits the coordinate. When the
    paddle slides to the right side of the screen, `paddle.x` does not go past`> display.contentWidth`
    in the x-direction.
  prefs: []
  type: TYPE_NORMAL
- en: There is no designated coordinate for the right side of the screen since the
    code is supposed to be universal for all screen sizes on iOS and Android devices.
    Both platforms have varying screen resolutions, so `display.contentWidth` takes
    them into account.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—moving the paddle with accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, accelerometer events cannot be tested in the simulator.
    They only work when a game build is uploaded to a device to see the results. The
    paddle movement will stay within the wall borders of the level across the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Below the `dragPaddle()` function, create a new function called `movePaddle(event)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the accelerometer movement using `yGravity`. It provides the acceleration
    due to gravity in the y-direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the wall borders for the level and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for landscape mode,
    `xGravity` and `yGravity` values are switched to compensate for the events to
    work properly.
  prefs: []
  type: TYPE_NORMAL
- en: We have applied the same code for the paddle from `function dragPaddle():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This still keeps the paddle from going past any wall border boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Ball collision with paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motion of the ball has to flow in a fluid manner every time it collides
    with the paddle. This means proper directional changes on all sides of the game
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—making the ball bounce against the paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will check which side of the paddle the ball has hit to choose the side where
    it will move next. It's important to have the motion to follow through any directional
    hits as it would in a realistic environment. Through every paddle collision, we
    want to make sure the ball goes in the *up* direction.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function called `bounce()` for the ball after the `movePaddle()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in a value of -3 for velocity in the y-direction. This will make the ball
    move in an upward motion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check when a collision is made with the `paddle` and `ball` and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the ball collides with the paddle, the motion follows through depending
    on what side of the paddle is touched by the ball. In the first part of the `if`
    statement, the ball travels toward 0 in the x-direction. The last part of the
    `if` statement shows the ball travelling toward the opposite side of the screen
    in the x-direction.
  prefs: []
  type: TYPE_NORMAL
- en: Removing objects from the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are limited resources on a device. As much as we wish they were as powerful
    as a desktop to hold so much memory, it's not at that point yet. This is why it
    is important to remove display objects from the display hierarchy when you no
    longer use them in your application. This helps the overall system performance
    by reducing memory consumption and eliminates unnecessary drawing.
  prefs: []
  type: TYPE_NORMAL
- en: When a display object is created, it is added by default to the root object
    of the display hierarchy. This object is a special kind of group object known
    as the **stage object**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep an object from rendering on screen, it needs to be removed
    from the scene. The object needs to be removed explicitly from its parent. This
    removes the object from the display hierarchy. This can be done in either of the
    two following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myImage.parent:remove( myImage )` -- remove `myImage` from hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '`myImage:removeSelf( )` -- same as above'
  prefs: []
  type: TYPE_NORMAL
- en: This does not free all the memory from the display object. To make sure that
    the display object is removed properly, we need to eliminate all variable references
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Variable references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though a display object has been removed from the hierarchy, there are
    situations in which the object continues to exist. To do this, we set the property
    to `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Brick by brick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bricks in the game are the main obstacles since they have to be cleared
    in order to move onto the next round. In this version of Breakout, the player
    must destroy all the bricks in one turn. Failure to do so results in starting
    over from the beginning of the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—removing the bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the ball collides with a brick, we will use the same technique applied
    to the paddle to determine the side the ball will follow. When a brick is hit,
    we'll need to figure out which brick has been touched and then remove it from
    both the stage and the bricks group. Each brick removal will increment 100 points
    to the score. The score will be taken from the score constant and added to the
    current score as text.
  prefs: []
  type: TYPE_NORMAL
- en: Below the `gameLevel2()` function, create a function called `removeBrick(event):`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check which side of the brick the ball hits using the `if` statement. When
    checking for an event, we''ll be referring the event to the object name,`"brick"`.
    This is the name we gave our `brick` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the following `if` statement to remove the brick from the scene when
    the ball collides with one. After a collision has been made, increase the `score`
    by 1\. Initiate the `scoreNum` to take the value of the `score` and multiply it
    by `scoreIncrease:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When all the bricks are destroyed from the level, create an `if` statement that
    pops up on the **Alert** screen for a win condition and set the `gameEvent` string
    to`"win"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—removing the bricks](img/1888_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, we gave the `brick` objects a name
    called`"brick"`.
  prefs: []
  type: TYPE_NORMAL
- en: When the ball hits the left side of any of the individual bricks, the ball travels
    towards the left. When the ball hits the right side of the bricks, it travels
    toward the right. The width of each object is taken as a whole to calculate the
    direction the ball travels.
  prefs: []
  type: TYPE_NORMAL
- en: When a brick is hit, the ball bounces upward (the y-direction). Upon every collision,
    the ball makes with a brick; the object is removed from the scene and destroyed
    from memory.
  prefs: []
  type: TYPE_NORMAL
- en: '`bricks.numChildren -1` subtracts the count from the total number of bricks
    it started out with originally. When a brick is removed, the score increments
    100 points each time. The `scoreNum` text object updates the score every time
    a brick is hit.'
  prefs: []
  type: TYPE_NORMAL
- en: When all bricks are gone, the **Alert** screen pops up with a notification that
    the player has won the level. We also set `gameEvent = "win"`, which will be used
    in another function that will transition the event to a new scene.
  prefs: []
  type: TYPE_NORMAL
- en: Directional changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the ball motion against the paddle, other factors are the collision
    states against the wall borders. When a collision occurs, the ball diverts its
    direction the opposite way. For every action, there is a reaction, just like real
    world physics.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—updating the ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ball needs to move in a continuous motion without gravity affecting it.
    We'll have to take into account the side walls and top and bottom walls. The velocity
    in the x and y direction have to reflect the other way when a collision happens
    on any of the boundaries. We need to set coordinates that the ball is only allowed
    to move through and an alert when it passes through an area below the paddle region.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function called `function updateBall()` below the `removeBrick(event)`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the ball movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the ball movement for the x-direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—updating the ball](img/1888_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add in the ball movement for the y-direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—updating the ball](img/1888_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Add in the ball movement when it collides with the bottom of the **Gameplay**
    screen. Create the lose **Alert** screen and a game event for`"lose"`. Close the
    function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—updating the ball](img/1888_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everywhere the ball travels, proper direction change is needed when it hits
    the wall. Any time the ball hits the side walls, we use `vx = -vx`. When the ball
    hits the top boundary, `vy = -vy` is used. The only time the ball doesn't reflect
    the opposite direction is when it hits the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The **Alert** screen displays the lose condition, which emphasizes to the player
    to **Play Again**. `gameEvent = "lose"` will be used in another `if` statement
    to reset the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a win or lose condition occurs, the game needs a way to transition to the
    next level or repeat the current one. The main game objects have to be reset to
    their starting position and the bricks redrawn. Pretty much the same idea when
    you start a game during first play.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—resetting and changing levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to create functions that set up the first and second level in the
    game. If a level needs to be replayed, only the current level the user lost in
    can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `changeLevel1()`. This will be placed below the
    `updateBall()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clear the `bricks` group when the player loses the round and reset them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `alertDisplayGroup:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reset the `ball` and `paddle` position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Redraw the `bricks` for the current level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add an event listener to the `background` object for `startGame()`. Close the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next create a new function called `changeLevel2()`. Apply all the same code
    used for `changeLevel1()`, but make sure the `bricks` are redrawn for `gameLevel2()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a level needs to be reset or changed, the display objects have to be wiped
    from the board. In this case, we removed the `bricks` group using `bricks:removeSelf()`.
  prefs: []
  type: TYPE_NORMAL
- en: When any **Alert** screen pops up, whether win or lose, the entire `alertDisplayGroup`
    is removed during the reset as well. The `ball` and `paddle` are set back to their
    start game position.
  prefs: []
  type: TYPE_NORMAL
- en: '`gameLevel1()` is called to redraw the bricks for level 1\. The function holds
    the initial setup for the `brick` display objects and `bricks` group.'
  prefs: []
  type: TYPE_NORMAL
- en: The `background` object is used again to call the `startGame()` function with
    an event listener. When level 2 needs to be set up, the same procedure is used
    like in function `changeLevel1()`, but called `changeLevel2()` and `gameLevel2()`
    is used to redraw the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—add more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, the game only has two levels. What can be done to extend this game
    is add more levels. They can be created using the same logic made for `gameLevel1()`
    and `gameLevel2()` by adjusting the numbers used to create rows and columns for
    the bricks. You'll have to create a new function that resets the level. We can
    use the same method done on `changeLevel1()` and `changeLevel2()` to re-create
    a level and reset it.
  prefs: []
  type: TYPE_NORMAL
- en: You win some, you lose some
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is more exhilarating than the anticipation of winning. That is until
    you make that one small mistake and it causes you to start over. Don't worry,
    it's not the end of the world, you can always try again and learn from your errors
    on beating the level.
  prefs: []
  type: TYPE_NORMAL
- en: Game events that occur within the program such as a win or lose condition has
    been made will alert the player of their progress. The game has to have some way
    of guiding the player to what action they need to make to replay the level or
    move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—making win and lose conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any game alerts to even appear during gameplay, we need to create some `if`
    statements for every possible scenario available in each level. When this occurs,
    the score needs to be reset back to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Below the `alertScreen()` function, create a new function called `restart():`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an `if` statement for a`"win"` game event when the first level has been
    completed and transitions to **Level 2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tostring()` converts any argument to a string. In the preceding example, the
    `currentLevel` value changes from 1 to 2 when a`"win"` game event occurs. The
    value will convert to a string format that the `levelNum` text object can display
    on screen for **Level 2**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add an `elseif` statement for a`"win"` game event when the second level has
    been completed and notifies the player that the game has been completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add another `elseif` statement for`"lose"` game event on the first level. Reset
    the score to zero and replay level 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add another `elseif` statement for a`"lose"` game event on the second level.
    Reset the score to zero and replay level 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly add another `elseif` statement for a `gameEvent = "completed"`. Close
    the function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to backtrack and add an event listener to the `alertScreen()` function
    using the `alertBox` object. We're going to add it to the bottom of the function.
    This will activate `function restart()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `restart()` function checks all `gameEvent` and `currentLevel` variables
    happening during gameplay. When a game event checks for the string`"win"`, it
    also goes down the list of statements to see what comes out true. For example,
    if the player wins and is currently on level 1, then the player moves on to level
    2.
  prefs: []
  type: TYPE_NORMAL
- en: During a case that the player loses, `gameEvent == "lose"` becomes true and
    the code checks what level the player lost in. For any level the player loses
    in, the score reverts back to 0 and the current level the player was on is set
    up again.
  prefs: []
  type: TYPE_NORMAL
- en: Activating event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event listeners in this game basically turn the movements of the objects
    on and off. We have already coded the functions that carry out the actions of
    our game objects to run the level. Now it's time to activate them using certain
    type of events. As you've noticed from the previous chapter, we can add event
    listeners to display objects or have them run globally.
  prefs: []
  type: TYPE_NORMAL
- en: Collision events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collision events within the physics engine occur through Corona''s event listener
    model. There are three new event types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"collision":` This event includes phases for`"began"` and`"ended"`, which
    signify the moments of initial contact and broken contact. These phases exist
    for both normal two-body collisions and body-sensor collisions. If you do not
    implement a`"collision"` listener, this event will not fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"preCollision":` An event type that fires right before the objects start to
    interact. Depending on your game logic, you may wish to detect this event and
    conditionally override the collision. It may also result in multiply reports per
    contact and affect the application performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"postCollision":` An event type that fires right after the objects have interacted.
    This is the only event in which the collision force is reported. If you do not
    implement a`"postCollision"` listener, this event will not fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Collisions are reported between pairs of objects and can be detected either
    globally, using a runtime listener, or locally within an object, using a table
    listener.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Global collision listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When detected as a runtime event, each collision event includes `event.object1`,
    which contains the table ID of the Corona display object involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Local collision listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When detected with a table listener within an object, each collision event includes
    `event.other`, which contains the table ID of the other display object involved
    in the collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Time for action—adding game listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many of the functions we have created for our game objects we need to activate
    the event listeners so that they will run the code and disable them when gameplay
    has stopped.
  prefs: []
  type: TYPE_NORMAL
- en: The last function we need to create in order to complete this game is called
    `gameListeners()`, which will also have a parameter called `event`. This should
    be added right after the `gameLevel2()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the following event listeners that will start several events in the
    application using an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we'll add in an `elseif` statement for the event listeners that will remove
    the events and then close the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order for `function gameListeners()` to work properly, we need to instantiate
    it in the `startGame()` function using the`"add"` string in the parameter. Place
    it before the end of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `alertScreen()` function, add the`"remove"` string in the parameter and
    place it at the start of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the code has been written! Go ahead and run the game in the simulator. The
    application is also device ready. Make a simple icon image that fits the required
    dimensions for the device you're developing on. Compile a build and run it on
    your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two sets of `if` statements for the `event` parameter,`"add"` and`"remove"`.
  prefs: []
  type: TYPE_NORMAL
- en: All the event listeners in this function play an important role in making the
    game run.`"accelerometer"` and`"enterframe"` are used as runtime events since
    they have no specific target.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `paddle` and `ball` have`"collision"` events that will carry out their
    purpose in any object contact made.
  prefs: []
  type: TYPE_NORMAL
- en: The`"touch"` event allows the user to touch and drag the paddle so it can move
    back and forth in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Notice `event == "remove"` removes all event listeners that were active in the
    game. When the game starts, `gameListeners("add")` is activated. When a win or
    lose condition is achieved, `gameListeners("remove")` is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—let's turn everything upside down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we decided to flip the game upside down? In other words, place the paddle
    near the top of the screen, the ball below the paddle, and the group of bricks
    closer to the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things you''ll have to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The top wall is now an area you have to keep the ball from entering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The y-direction the ball travels when it collides with the bricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ball has to reflect off the bottom wall when it collides with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are a couple things to consider before switching values
    from negative to positive and vice versa. Be sure to verify your logic and that
    it makes sense when creating this new variation.
  prefs: []
  type: TYPE_NORMAL
- en: The results are in!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's reiterate block by block to make sure that we have everything added into
    our game. You can also refer to the `Breakout Final` folder in the [Chapter 4](ch04.html
    "Chapter 4. Game Controls") folder to see the final code. We made sure that we
    introduced our variables used in the game. We also initialized the `main()` function
    that starts the gameplay. A **Main Menu** screen was implemented with the game
    title and a **Play** button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Next we transitioned the `menuScreenGroup` away from the stage to load the main
    playing field. The main display objects of the game, such as the paddle, ball,
    and bricks were added. The score and the level number were displayed as the UI
    elements and updated throughout gameplay. Paddle movement in both the simulator
    and accelerometer were added as well as the collision detection with the paddle
    and the ball.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The physical properties of the paddle and ball were added to the start of the
    game. The brick layouts for each of the two levels were created. We have added
    event listeners to all our game objects from the point when they need to be activated
    during the game and removed when gameplay is over.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Every time the ball collides with a brick, the brick is removed from the scene.
    The directional changes are updated to the ball for every wall, paddle, or brick
    collision made. Every time a win or lose condition occurred, all game objects
    are reset to begin at the start of the current or new level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When a condition occurs, an **Alert** screen pops out, notifying the player
    what has happened. The display objects that initiate the alerts are created into
    a function. Lastly, the win and lose arguments are created to determine if the
    current level has to be replayed, goes to the next level, or if the game has been
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Beware of case-sensitive variables and functions in case you run into errors.
    Also be sure to check if you're missing any punctuation required in your code.
    These can be easily overlooked. Refer to your **Terminal** window in the simulator
    for any error references.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz—working with game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do you properly remove a display object from the stage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `remove()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'b. `object: remove()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `object:removeSelf(); object = nil`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the correct way to make the following display object into a physical
    object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: a. `physics.addBody( circle, { density=2.0, friction=0.5, bounce=0.2, radius
    = 25 } )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `physics.addBody( circle, "dynamic", { density=2.0, friction=0.5, bounce=0.2,
    radius = 15 } )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. a and b
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What best represents what`"began"` means in the following function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: a. A finger moved on the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. A finger was lifted from the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. The system cancelled tracking the start touch
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. A finger touched the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have completed making your very first game! You should
    be very proud of yourself. Now you have experienced how simple it is to make an
    application with Corona. It can take merely a few hundred lines of code to make
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Added movement to the paddle with touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced the accelerometer features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented collision event listeners for all game objects affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed objects from memory when they weren't needed on the game screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented movement of the ball as a physical object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated a scoreboard for every brick collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to handle win and lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The past two chapters weren't so bad now were they? We're getting familiar with
    the workflow as we continue programming in Lua. It will definitely get easier
    to understand as long as you keep working with different game frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: What the next chapter holds will be another game that will surely catch your
    attention. We'll be creating animated sprite sheets for our display objects. How's
    that for eye candy?
  prefs: []
  type: TYPE_NORMAL
