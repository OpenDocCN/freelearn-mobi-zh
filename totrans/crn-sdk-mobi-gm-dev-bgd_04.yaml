- en: Chapter 4. Game Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 游戏控制
- en: So far we have completed the first half of our game in the previous chapter.
    We started on developing the initial structure for the project by introducing
    the game objects to the screen. Currently, the paddle and ball movement is inactive,
    but everything displayed in the simulator is scaled accordingly to the original
    game design. The last phase of completing this tutorial is to add in all the actions
    that will occur in the game, including object movement and updating the score.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，我们在上一章中完成了游戏的一半。我们通过将游戏对象引入屏幕来开始开发项目的初始结构。目前，拍子和球的移动是无效的，但模拟器中显示的所有内容都相应地缩放到了原始游戏设计。完成本教程的最后阶段是添加游戏中将发生的所有动作，包括对象移动和更新分数。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Moving the paddle using touch events and accelerometer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触摸事件和加速度计移动拍子
- en: Collision detection between all game objects in the scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中所有游戏对象的碰撞检测
- en: Removing objects upon collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测后移除对象
- en: Ball movement within screen boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球在屏幕边界内的移动
- en: Calculating the score
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算分数
- en: Win and lose conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利和失败条件
- en: Home stretch! We can do it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后冲刺！我们可以做到！
- en: Moving in the up direction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上移动方向
- en: If making objects appear on screen is exciting to you, wait until you see them
    move! The main object of Breakout is to keep the ball above the paddle position
    to stay in play and have it collide with all the bricks to complete the level.
    What keeps the suspense flowing is the anticipation of the ball movement throughout
    the game screen. This wouldn't be possible without adding physical boundaries
    on the game objects to react to collision detection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果让物体出现在屏幕上让你兴奋，那么等你看到它们移动！Breakout游戏的主要目标是保持球在拍子位置上方，以保持游戏状态，并使其与所有砖块碰撞以完成关卡。保持悬念流动的是对整个游戏屏幕中球移动的期待。如果没有在游戏对象上添加物理边界以进行碰撞检测，这是不可能的。
- en: Let's get even more physical
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们更加物理化
- en: In the last chapter, we talked about how to integrate the physics engine into
    your code. We also started implementing physical bodies to the brick objects and
    now we'll need to do the same with other active game objects such as the paddle
    and the ball. Let's continue with this last half of the tutorial. We will continue
    using our `main.lua` file from the `Breakout` project folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何将物理引擎集成到代码中。我们还开始将物理体实现到砖块对象中，现在我们需要将相同的操作应用于其他活动游戏对象，如拍子和球。让我们继续本教程的最后部分。我们将继续使用`Breakout`项目文件夹中的`main.lua`文件。
- en: physics.addBody()
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: physics.addBody()
- en: Corona display objects can be turned into simulated physical objects using one
    line of code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一行代码，Corona显示对象可以被转换成模拟物理对象。
- en: If no shape information is specified, the display object takes on the form of
    the actual rectangular boundary of the original image to create the physics body.
    For example, if a display object is 100 x 100 pixels, then that would be the actual
    size of the physics body.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定形状信息，显示对象将采用原始图像的实际矩形边界来创建物理体。例如，如果显示对象是100 x 100像素，那么这将物理体的实际大小。
- en: If a shape is specified, then the body boundaries will follow the polygon provided
    by the shape. The shape coordinates must be defined in clockwise order, and the
    resulting shape must be convex-only.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了形状，则物体边界将遵循形状提供的多边形。形状坐标必须按顺时针顺序定义，并且生成的形状必须是凸形状。
- en: If a radius is specified, then the body boundaries will be circular and centered
    in the middle of the display object used to create the physics body.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了半径，则物体边界将是圆形的，并且位于创建物理体的显示对象中间。
- en: A body shape is a table of local (x,y) coordinates, relative to the center of
    the display object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 物体形状是一个相对于显示对象中心的局部（x,y）坐标表。
- en: 'Syntax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: 'Circular shapes:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形形状：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Polygon shapes:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形形状：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Circular bodies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形物体：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Polygon bodies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形物体：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`Object` (Object): A display object.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object` (对象): 一个显示对象。'
- en: '`bodyType` (String): Specifying the body type is optional. It uses a string
    parameter before the first body element. The possible types are`"static", "dynamic"`,
    and`"kinematic"`. The default type is`"dynamic"` if no value is specified.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyType` (字符串): 指定身体类型是可选的。它使用一个字符串参数在第一个身体元素之前。可能的类型是`"static", "dynamic"`和`"kinematic"`。如果没有指定值，默认类型是`"dynamic"`。'
- en: static bodies don't move, and don't interact with each other; examples of static
    objects would include the ground or the walls of a pinball machine.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态身体不会移动，也不会相互交互；静态对象的例子包括地面或弹球机的墙壁。
- en: dynamic bodies are affected by gravity and collisions with the other body types.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态身体受到重力和其他身体类型碰撞的影响。
- en: kinematic objects are affected by forces but not by gravity, so you should generally
    set draggable objects to`"kinematic"`, at least for the duration of the drag event.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动力学对象受到力的作用，但不受到重力的影响，因此你应该通常将可拖动对象设置为`"kinematic"`，至少在拖动事件期间。
- en: '`Density` (Number): Multiplied by the area of the body''s shape to determine
    mass. Based on a standard value of 1.0 for water. Lighter materials (such as wood)
    have a density below 1.0, and heavier materials (such as stone) have a density
    greater than 1.0\. Default value is `1.0`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Density`（数值）：乘以身体形状的面积以确定质量。基于水的标准值1.0。较轻的材料（如木材）的密度小于1.0，而较重的材料（如石头）的密度大于1.0。默认值为`1.0`。'
- en: '`Friction` (Number): May be any non-negative value; a value of 0 means no friction
    and 1.0 means fairly strong friction. The default value is `0.3`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Friction`（数值）：可以是任何非负值；0表示没有摩擦，1.0表示相当强的摩擦。默认值为`0.3`。'
- en: '`Bounce` (Number): Determines the amount of an object''s velocity returned
    after a collision. The default value is `0.2`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bounce`（数值）：确定物体在碰撞后返回的速度量。默认值为`0.2`。'
- en: '`Radius` (Number): Radius of the bounding circle in pixels.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radius`（数值）：边界圆的像素半径。'
- en: '`Shape` (Number): Shape value in the form of a table of the shape vertices,
    {x1,y1,x2,y2,...,xn,yn}. For example, `rectangleShape = { -6,-48, 6,-48, 6,48,
    -6,48 }`. The coordinates must be defined in clockwise order, and the resulting
    shape must be convex-only. (Physics assume the 0,0 point of an object, is the
    center of the object. A -x will be to the left of the object''s center and -y
    will be at the top of object''s center).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape`（数值）：形状值以形状顶点的表格形式表示，{x1,y1,x2,y2,...,xn,yn}。例如，`rectangleShape = {
    -6,-48, 6,-48, 6,48, -6,48 }`。坐标必须按顺时针顺序定义，并且生成的形状必须是凸形状。（物理假设对象的0,0点为对象的中心。负x位于对象中心的左侧，负y位于对象中心的顶部）。'
- en: Time for action—starting physics for the paddle and ball
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始物理操作——启动挡板和球的物理属性
- en: Right now, our display objects are rather stagnant. In order for gameplay to
    initiate, we have to activate physics for the paddle and ball in order for any
    kind of movement in the game to occur.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的显示对象相当静止。为了开始游戏，我们必须激活挡板和球体的物理属性，以便在游戏中发生任何类型的移动。
- en: Above the `gameLevel1()` function, create a new function called `startGame()`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameLevel1()`函数上方创建一个名为`startGame()`的新函数。
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add in the following lines to instantiate the physics of the paddle and ball:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以实例化挡板和球的物理属性：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create an event listener that uses the background display object to remove the`"tap"`
    event for `startGame()`. Close the function with `end`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个事件监听器，使用背景显示对象来移除`startGame()`的`"tap"`事件。使用`end`结束函数。
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `addGameScreen()` function that we created in the previous chapter, we
    have to add the following line after the call to the `gameLevel1()` function.
    This starts the actual game when the background is touched.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中我们创建的`addGameScreen()`函数中，必须在调用`gameLevel1()`函数之后添加以下行。这样，当背景被触摸时，实际上开始游戏。
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What just happened?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The paddle object has a`"static"` body type so it is not affected by any collision
    that occurs against it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 挡板对象具有`"static"`类型的身体，因此它不会受到任何对其发生的碰撞的影响。
- en: The ball object has a`"dynamic"` body type because we want it to be affected
    by the collisions on the screen due to directional changes by the wall borders,
    bricks and paddle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 球对象具有`"dynamic"`类型的身体，因为我们希望它能够受到由于墙壁边缘、砖块和挡板方向变化而产生的屏幕碰撞的影响。
- en: The event listener on the background is removed from the `startGame()` function,
    that way it doesn't affect any of the other touch events that are applied in game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startGame()`函数中移除背景上的事件监听器，这样它就不会影响游戏中应用的任何其他触摸事件。
- en: Paddle movement
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挡板移动
- en: Getting the paddle to move side to side is one of the key actions that needs
    to be accomplished. Part of the game design is to protect the ball from reaching
    the bottom of the screen. We will be separating paddle movement in the simulator
    and the accelerometer. The movement in the simulator enables us to test with touch
    events since accelerometer actions cannot be tested in the simulator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让桨在两侧移动是必须完成的关键动作之一。游戏设计的一部分是保护球不达到屏幕底部。我们将在模拟器和加速度计中分离桨的移动。模拟器中的移动使我们能够通过触摸事件进行测试，因为加速度计动作无法在模拟器中测试。
- en: Time for action—dragging the paddle in the simulator
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——在模拟器中拖动桨
- en: Right now, the paddle does not move at all. There are no coordinates set to
    translate on the screen, so let's create that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，桨没有任何移动。屏幕上没有设置用于转换的坐标，所以让我们创建它。
- en: Underneath the `addGameScreen()` function, create a new function called `dragPaddle(event)`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addGameScreen()`函数下方，创建一个名为`dragPaddle(event)`的新函数。
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we'll focus on moving the paddle side to side within the boundary of the
    game screen.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于在游戏屏幕的边界内移动桨的左右移动。
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add in the preceding block of code to enable paddle movement in the simulator
    and then close the function. The reason for adding this block is because the simulator
    does not support accelerometer events.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码块中添加代码以启用模拟器中的桨移动，然后关闭函数。添加此代码块的原因是模拟器不支持加速度计事件。
- en: '![Time for action—dragging the paddle in the simulator](img/1888_04_01.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——在模拟器中拖动桨](img/1888_04_01.jpg)'
- en: What just happened?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created a function where the drag event only works in the simulator.
    For `if event.phase == "began"`, a touch has been made to the paddle. On `elseif
    event.phase == "moved"`, a touch has been moved on the paddle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数，其中拖动事件仅在模拟器中起作用。对于`if event.phase == "began"`，已经触摸到桨上。在`elseif event.phase
    == "moved"`时，触摸已经在桨上移动。
- en: In order to keep the paddle from moving past the wall boundaries, `paddle.x`
    does not go past`< 0` in the x-direction when it hits the coordinate. When the
    paddle slides to the right side of the screen, `paddle.x` does not go past`> display.contentWidth`
    in the x-direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止桨越过墙壁边界，当桨击中坐标时，`paddle.x`在x方向上不会越过`< 0`。当桨滑到屏幕的右侧时，`paddle.x`在x方向上不会越过`>
    display.contentWidth`。
- en: There is no designated coordinate for the right side of the screen since the
    code is supposed to be universal for all screen sizes on iOS and Android devices.
    Both platforms have varying screen resolutions, so `display.contentWidth` takes
    them into account.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕右侧没有指定的坐标，因为代码应该是适用于iOS和Android设备上所有屏幕尺寸的通用代码。这两个平台具有不同的屏幕分辨率，因此`display.contentWidth`考虑了它们。
- en: Time for action—moving the paddle with accelerometer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用加速度计移动桨
- en: As mentioned earlier, accelerometer events cannot be tested in the simulator.
    They only work when a game build is uploaded to a device to see the results. The
    paddle movement will stay within the wall borders of the level across the x-axis.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，加速度计事件无法在模拟器中测试。它们只有在将游戏构建上传到设备上才能看到结果时才起作用。桨的移动将在水平轴上的关卡墙壁边界内。
- en: Below the `dragPaddle()` function, create a new function called `movePaddle(event)`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dragPaddle()`函数下方，创建一个名为`movePaddle(event)`的新函数。
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add in the accelerometer movement using `yGravity`. It provides the acceleration
    due to gravity in the y-direction.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`yGravity`添加加速度计运动。它提供了y方向上的重力加速度。
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add in the wall borders for the level and close the function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加关卡墙壁边界并关闭函数：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What just happened?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使加速度计运动与设备一起工作，我们必须使用`yGravity`。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for landscape mode,
    `xGravity` and `yGravity` values are switched to compensate for the events to
    work properly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`xGravity`和`yGravity`时，加速度计事件基于纵向比例。当为横向模式指定显示对象时，`xGravity`和`yGravity`值会切换以补偿事件以正确工作。
- en: We have applied the same code for the paddle from `function dragPaddle():`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为桨应用了与`function dragPaddle():`相同的代码。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This still keeps the paddle from going past any wall border boundaries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然使桨不会越过任何墙壁边界。
- en: Ball collision with paddle
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球与桨的碰撞
- en: The motion of the ball has to flow in a fluid manner every time it collides
    with the paddle. This means proper directional changes on all sides of the game
    field.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每次球与挡板碰撞时，球的运动必须流畅。这意味着在游戏场地的所有方向上都要进行适当的方向改变。
- en: Time for action—making the ball bounce against the paddle
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使球反弹到挡板上
- en: We will check which side of the paddle the ball has hit to choose the side where
    it will move next. It's important to have the motion to follow through any directional
    hits as it would in a realistic environment. Through every paddle collision, we
    want to make sure the ball goes in the *up* direction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查球击中挡板的哪一侧，以选择球下一次移动的方向。在现实环境中，确保运动轨迹跟随任何方向的击打是很重要的。在每次挡板碰撞中，我们都要确保球向上移动。
- en: Create a new function called `bounce()` for the ball after the `movePaddle()`
    function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`movePaddle()`函数之后为球创建一个名为`bounce()`的新函数。
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add in a value of -3 for velocity in the y-direction. This will make the ball
    move in an upward motion:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在y方向的速度中添加一个-3的值。这将使球向上移动：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check when a collision is made with the `paddle` and `ball` and close the function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查与`paddle`和`ball`的碰撞，并关闭函数：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What just happened?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When the ball collides with the paddle, the motion follows through depending
    on what side of the paddle is touched by the ball. In the first part of the `if`
    statement, the ball travels toward 0 in the x-direction. The last part of the
    `if` statement shows the ball travelling toward the opposite side of the screen
    in the x-direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当球与挡板碰撞时，其运动轨迹会根据球触碰到挡板的哪一侧而有所不同。在`if`语句的第一部分，球在x方向上向0移动。`if`语句的最后部分显示球在x方向上向屏幕的对面移动。
- en: Removing objects from the scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从场景中移除对象
- en: There are limited resources on a device. As much as we wish they were as powerful
    as a desktop to hold so much memory, it's not at that point yet. This is why it
    is important to remove display objects from the display hierarchy when you no
    longer use them in your application. This helps the overall system performance
    by reducing memory consumption and eliminates unnecessary drawing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的资源有限。尽管我们希望它们像桌面一样强大，能够存储大量内存，但它们还没有达到那个水平。这就是为什么在应用程序中不再使用显示对象时，从显示层次结构中移除显示对象很重要。这通过减少内存消耗并消除不必要的绘制来帮助提高整体系统性能。
- en: When a display object is created, it is added by default to the root object
    of the display hierarchy. This object is a special kind of group object known
    as the **stage object**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建显示对象时，它默认被添加到显示层次结构的根对象中。这个对象是一种特殊类型的组对象，称为**舞台对象**。
- en: 'In order to keep an object from rendering on screen, it needs to be removed
    from the scene. The object needs to be removed explicitly from its parent. This
    removes the object from the display hierarchy. This can be done in either of the
    two following ways:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止一个对象在屏幕上渲染，需要将其从场景中移除。对象需要从其父对象中显式移除。这将对象从显示层次结构中移除。这可以通过以下两种方式中的任何一种来完成：
- en: '`myImage.parent:remove( myImage )` -- remove `myImage` from hierarchy'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`myImage.parent:remove( myImage )` -- 从层次结构中移除`myImage`'
- en: or
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '`myImage:removeSelf( )` -- same as above'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`myImage:removeSelf( )` -- 与上面相同'
- en: This does not free all the memory from the display object. To make sure that
    the display object is removed properly, we need to eliminate all variable references
    to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有从显示对象中释放所有内存。为了确保显示对象被正确移除，我们需要消除所有对该对象的变量引用。
- en: Variable references
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量引用
- en: Even though a display object has been removed from the hierarchy, there are
    situations in which the object continues to exist. To do this, we set the property
    to `nil`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使显示对象已经从层次结构中移除，也存在一些情况下对象仍然存在。为了做到这一点，我们将属性设置为`nil`。
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Brick by brick
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一块接一块
- en: The bricks in the game are the main obstacles since they have to be cleared
    in order to move onto the next round. In this version of Breakout, the player
    must destroy all the bricks in one turn. Failure to do so results in starting
    over from the beginning of the current level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的砖块是主要的障碍，因为必须清除它们才能进入下一轮。在这个版本的Breakout中，玩家必须在一轮内摧毁所有砖块。未能做到这一点将导致从当前级别的开始重新开始。
- en: Time for action—removing the bricks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——移除砖块
- en: When the ball collides with a brick, we will use the same technique applied
    to the paddle to determine the side the ball will follow. When a brick is hit,
    we'll need to figure out which brick has been touched and then remove it from
    both the stage and the bricks group. Each brick removal will increment 100 points
    to the score. The score will be taken from the score constant and added to the
    current score as text.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当球与砖块碰撞时，我们将使用应用于桨的相同技术来确定球将跟随的侧面。当砖块被击中时，我们需要找出哪个砖块被触摸，然后从舞台和砖块组中移除它。每次移除砖块都会将100分加到得分上。得分将从得分常量中取出并添加到当前得分作为文本。
- en: Below the `gameLevel2()` function, create a function called `removeBrick(event):`
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameLevel2()`函数下方创建一个名为`removeBrick(event):`的函数。
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check which side of the brick the ball hits using the `if` statement. When
    checking for an event, we''ll be referring the event to the object name,`"brick"`.
    This is the name we gave our `brick` display object:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if`语句检查球击中砖块的哪一侧。在检查事件时，我们将事件引用到对象名称`"brick"`。这是我们给我们的`brick`显示对象起的名字：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add in the following `if` statement to remove the brick from the scene when
    the ball collides with one. After a collision has been made, increase the `score`
    by 1\. Initiate the `scoreNum` to take the value of the `score` and multiply it
    by `scoreIncrease:`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`if`语句，当球与一个砖块碰撞时从场景中移除砖块。在碰撞发生后，将`score`增加1。启动`scoreNum`以获取`score`的值并乘以`scoreIncrease:`。
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When all the bricks are destroyed from the level, create an `if` statement that
    pops up on the **Alert** screen for a win condition and set the `gameEvent` string
    to`"win"`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有砖块从关卡中销毁后，创建一个在**Alert**屏幕上弹出的`if`语句，以显示胜利条件，并将`gameEvent`字符串设置为`"win"`。
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Close the function with `end`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`end`关闭函数。
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Time for action—removing the bricks](img/1888_04_02.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——移除砖块](img/1888_04_02.jpg)'
- en: What just happened?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: If you remember from the previous chapter, we gave the `brick` objects a name
    called`"brick"`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章，我们给`brick`对象起了一个叫`"brick"`的名字。
- en: When the ball hits the left side of any of the individual bricks, the ball travels
    towards the left. When the ball hits the right side of the bricks, it travels
    toward the right. The width of each object is taken as a whole to calculate the
    direction the ball travels.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当球击中任何单个砖块的左侧时，球会向左移动。当球击中砖块的右侧时，它会向右移动。每个物体的宽度作为一个整体来计算球移动的方向。
- en: When a brick is hit, the ball bounces upward (the y-direction). Upon every collision,
    the ball makes with a brick; the object is removed from the scene and destroyed
    from memory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当砖块被击中时，球会向上弹起（y方向）。在每次碰撞后，球与砖块接触；物体从场景中移除并从记忆中销毁。
- en: '`bricks.numChildren -1` subtracts the count from the total number of bricks
    it started out with originally. When a brick is removed, the score increments
    100 points each time. The `scoreNum` text object updates the score every time
    a brick is hit.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bricks.numChildren -1`从最初的总砖块数中减去计数。当移除砖块时，每次得分增加100分。`scoreNum`文本对象在每次击中砖块时更新得分。'
- en: When all bricks are gone, the **Alert** screen pops up with a notification that
    the player has won the level. We also set `gameEvent = "win"`, which will be used
    in another function that will transition the event to a new scene.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有砖块消失后，**Alert**屏幕会弹出通知玩家已赢得关卡。我们还设置了`gameEvent = "win"`，这将在另一个函数中使用，以将事件过渡到新场景。
- en: Directional changes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向变化
- en: Aside from the ball motion against the paddle, other factors are the collision
    states against the wall borders. When a collision occurs, the ball diverts its
    direction the opposite way. For every action, there is a reaction, just like real
    world physics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了球与桨的运动之外，其他因素还包括与墙边界的碰撞状态。当发生碰撞时，球会改变方向。每个动作都有一个反应，就像现实世界的物理一样。
- en: Time for action—updating the ball
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——更新球
- en: The ball needs to move in a continuous motion without gravity affecting it.
    We'll have to take into account the side walls and top and bottom walls. The velocity
    in the x and y direction have to reflect the other way when a collision happens
    on any of the boundaries. We need to set coordinates that the ball is only allowed
    to move through and an alert when it passes through an area below the paddle region.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 球需要在没有重力影响的情况下连续移动。我们必须考虑侧墙、顶部和底部墙壁。当任何边界发生碰撞时，x和y方向的速度必须反映相反的方向。我们需要设置坐标，球只能通过这些坐标移动，并且当它通过桨区域下方的区域时发出警报。
- en: Create a new function called `function updateBall()` below the `removeBrick(event)`
    function.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`removeBrick(event)`函数下方创建一个名为`updateBall()`的新函数。
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add in the ball movement:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加球体运动：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add in the ball movement for the x-direction:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加x方向的球体运动：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Time for action—updating the ball](img/1888_04_03.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——更新球体](img/1888_04_03.jpg)'
- en: 'Add in the ball movement for the y-direction:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加y方向的球体运动：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Time for action—updating the ball](img/1888_04_04.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——更新球体](img/1888_04_04.jpg)'
- en: Add in the ball movement when it collides with the bottom of the **Gameplay**
    screen. Create the lose **Alert** screen and a game event for`"lose"`. Close the
    function with `end`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**游戏界面**底部碰撞时添加球体运动。创建一个失去**警报**屏幕和一个名为`"lose"`的游戏事件。使用`end`关闭函数。
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Time for action—updating the ball](img/1888_04_05.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——更新球体](img/1888_04_05.jpg)'
- en: What just happened?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Everywhere the ball travels, proper direction change is needed when it hits
    the wall. Any time the ball hits the side walls, we use `vx = -vx`. When the ball
    hits the top boundary, `vy = -vy` is used. The only time the ball doesn't reflect
    the opposite direction is when it hits the bottom of the screen.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当球体在任何地方移动时，当它击中墙壁时需要改变正确的方向。任何时间球体击中侧墙时，我们使用`vx = -vx`。当球体击中顶部边界时，使用`vy = -vy`。球体不反射相反方向的情况只有当它击中屏幕底部时。
- en: The **Alert** screen displays the lose condition, which emphasizes to the player
    to **Play Again**. `gameEvent = "lose"` will be used in another `if` statement
    to reset the current level.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**警报**屏幕显示失败条件，强调玩家**再次游戏**。在另一个`if`语句中使用`gameEvent = "lose"`来重置当前级别。'
- en: Transitioning levels
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别过渡
- en: When a win or lose condition occurs, the game needs a way to transition to the
    next level or repeat the current one. The main game objects have to be reset to
    their starting position and the bricks redrawn. Pretty much the same idea when
    you start a game during first play.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现胜利或失败条件时，游戏需要一种方式来过渡到下一级或重复当前级别。主要游戏对象必须重置到起始位置，并重新绘制砖块。当你第一次开始游戏时，基本上有相同的概念。
- en: Time for action—resetting and changing levels
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——重置和更改级别
- en: We'll need to create functions that set up the first and second level in the
    game. If a level needs to be replayed, only the current level the user lost in
    can be accessed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建设置游戏第一级和第二级的函数。如果需要重玩游戏级别，只能访问用户失去的当前级别。
- en: 'Create a new function called `changeLevel1()`. This will be placed below the
    `updateBall()` function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`changeLevel1()`的新函数。这将放置在`updateBall()`函数下方：
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Clear the `bricks` group when the player loses the round and reset them:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家输掉回合时清除`砖块`组并重置它们：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remove the `alertDisplayGroup:`
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`alertDisplayGroup`：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Reset the `ball` and `paddle` position:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置`球体`和`挡板`位置：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Redraw the `bricks` for the current level:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新绘制当前级别的`砖块`：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Add an event listener to the `background` object for `startGame()`. Close the
    function.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`背景`对象添加一个事件监听器以调用`startGame()`。关闭函数。
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next create a new function called `changeLevel2()`. Apply all the same code
    used for `changeLevel1()`, but make sure the `bricks` are redrawn for `gameLevel2()`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建一个名为`changeLevel2()`的新函数。应用与`changeLevel1()`相同的所有代码，但确保为`gameLevel2()`重新绘制`砖块`。
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What just happened?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When a level needs to be reset or changed, the display objects have to be wiped
    from the board. In this case, we removed the `bricks` group using `bricks:removeSelf()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要重置或更改级别时，必须从板上擦除显示对象。在这种情况下，我们使用`bricks:removeSelf()`移除了`砖块`组。
- en: When any **Alert** screen pops up, whether win or lose, the entire `alertDisplayGroup`
    is removed during the reset as well. The `ball` and `paddle` are set back to their
    start game position.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何**警报**屏幕弹出时，无论是胜利还是失败，在重置过程中也会移除整个`alertDisplayGroup`。`球体`和`挡板`被设置回起始游戏位置。
- en: '`gameLevel1()` is called to redraw the bricks for level 1\. The function holds
    the initial setup for the `brick` display objects and `bricks` group.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`gameLevel1()`重新绘制第一级的砖块。该函数包含`砖块`显示对象和`砖块`组的初始设置。
- en: The `background` object is used again to call the `startGame()` function with
    an event listener. When level 2 needs to be set up, the same procedure is used
    like in function `changeLevel1()`, but called `changeLevel2()` and `gameLevel2()`
    is used to redraw the bricks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`背景`对象调用`startGame()`函数，并添加事件监听器。当需要设置第二级时，使用与`changeLevel1()`函数中相同的程序，但调用`changeLevel2()`，并使用`gameLevel2()`重新绘制砖块。
- en: Have a go hero—add more levels
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试——添加更多级别
- en: Right now, the game only has two levels. What can be done to extend this game
    is add more levels. They can be created using the same logic made for `gameLevel1()`
    and `gameLevel2()` by adjusting the numbers used to create rows and columns for
    the bricks. You'll have to create a new function that resets the level. We can
    use the same method done on `changeLevel1()` and `changeLevel2()` to re-create
    a level and reset it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏只有两个级别。要扩展这个游戏，可以添加更多级别。它们可以使用为`gameLevel1()`和`gameLevel2()`创建的逻辑创建，通过调整用于创建砖块行和列的数字。你必须创建一个新的函数来重置级别。我们可以使用在`changeLevel1()`和`changeLevel2()`上执行的方法来重新创建级别并重置它。
- en: You win some, you lose some
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有赢有输
- en: Nothing is more exhilarating than the anticipation of winning. That is until
    you make that one small mistake and it causes you to start over. Don't worry,
    it's not the end of the world, you can always try again and learn from your errors
    on beating the level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比赢得胜利的期待更令人兴奋的了。直到你犯了一个小小的错误，导致你不得不从头开始。别担心，这并不是世界末日，你总是可以再次尝试并从击败级别的错误中学习。
- en: Game events that occur within the program such as a win or lose condition has
    been made will alert the player of their progress. The game has to have some way
    of guiding the player to what action they need to make to replay the level or
    move on to the next one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中发生的游戏事件，如胜利或失败条件，会通知玩家他们的进度。游戏必须有一种方法来指导玩家进行哪些操作以重新播放级别或进入下一个级别。
- en: Time for action—making win and lose conditions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建胜利和失败条件
- en: For any game alerts to even appear during gameplay, we need to create some `if`
    statements for every possible scenario available in each level. When this occurs,
    the score needs to be reset back to zero.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏在游戏中出现任何警报，我们需要为每个级别中可能出现的每个场景创建一些`if`语句。当这种情况发生时，分数需要重置为零。
- en: Below the `alertScreen()` function, create a new function called `restart():`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`alertScreen()`函数下方，创建一个新的函数，称为`restart():`
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create an `if` statement for a`"win"` game event when the first level has been
    completed and transitions to **Level 2**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`if`语句以处理第一级完成时的`"win"`游戏事件，并过渡到**第2级**。
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`tostring()` converts any argument to a string. In the preceding example, the
    `currentLevel` value changes from 1 to 2 when a`"win"` game event occurs. The
    value will convert to a string format that the `levelNum` text object can display
    on screen for **Level 2**.'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tostring()`函数可以将任何参数转换为字符串。在上面的例子中，当发生`"win"`游戏事件时，`currentLevel`的值从1变为2。该值将转换为字符串格式，`levelNum`文本对象可以在屏幕上显示**第2级**。'
- en: Add an `elseif` statement for a`"win"` game event when the second level has
    been completed and notifies the player that the game has been completed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第二级完成时，添加一个`elseif`语句以处理`"win"`游戏事件，并通知玩家游戏已完成。
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add another `elseif` statement for`"lose"` game event on the first level. Reset
    the score to zero and replay level 1.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一级添加另一个`elseif`语句以处理`"lose"`游戏事件。将分数重置为零并重新播放第1级。
- en: '[PRE38]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add another `elseif` statement for a`"lose"` game event on the second level.
    Reset the score to zero and replay level 2.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二级添加另一个`elseif`语句以处理`"lose"`游戏事件。将分数重置为零并重新播放第2级。
- en: '[PRE39]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Lastly add another `elseif` statement for a `gameEvent = "completed"`. Close
    the function with `end`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加另一个`elseif`语句以处理`gameEvent = "completed"`。使用`end`关闭函数。
- en: '[PRE40]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we need to backtrack and add an event listener to the `alertScreen()` function
    using the `alertBox` object. We're going to add it to the bottom of the function.
    This will activate `function restart()`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要回溯并使用`alertBox`对象为`alertScreen()`函数添加一个事件监听器。我们将将其添加到函数的底部。这将激活`restart()`函数。
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What just happened?
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `restart()` function checks all `gameEvent` and `currentLevel` variables
    happening during gameplay. When a game event checks for the string`"win"`, it
    also goes down the list of statements to see what comes out true. For example,
    if the player wins and is currently on level 1, then the player moves on to level
    2.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart()`函数检查游戏过程中发生的所有`gameEvent`和`currentLevel`变量。当游戏事件检查字符串`"win"`时，它也会查看语句列表，以查看哪些为真。例如，如果玩家在第一级获胜，则玩家将进入第二级。'
- en: During a case that the player loses, `gameEvent == "lose"` becomes true and
    the code checks what level the player lost in. For any level the player loses
    in, the score reverts back to 0 and the current level the player was on is set
    up again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家失败时，`gameEvent == "lose"`变为真，代码检查玩家在哪个级别失败。对于玩家失败的任何级别，分数将重置为0，并将玩家当前所在的级别重新设置。
- en: Activating event listeners
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活事件监听器
- en: The event listeners in this game basically turn the movements of the objects
    on and off. We have already coded the functions that carry out the actions of
    our game objects to run the level. Now it's time to activate them using certain
    type of events. As you've noticed from the previous chapter, we can add event
    listeners to display objects or have them run globally.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，事件监听器基本上是开启和关闭对象的移动。我们已经编写了执行游戏对象动作的函数来运行关卡。现在，是时候使用某种类型的事件来激活它们了。正如您在前一章中注意到的，我们可以向显示对象添加事件监听器或使它们全局运行。
- en: Collision events
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞事件
- en: 'Collision events within the physics engine occur through Corona''s event listener
    model. There are three new event types:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎中的碰撞事件是通过Corona的事件监听器模型发生的。有三个新的事件类型：
- en: '`"collision":` This event includes phases for`"began"` and`"ended"`, which
    signify the moments of initial contact and broken contact. These phases exist
    for both normal two-body collisions and body-sensor collisions. If you do not
    implement a`"collision"` listener, this event will not fire.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"collision"`：此事件包括`"began"`和`"ended"`阶段，分别表示初始接触和接触断裂的时刻。这些阶段存在于正常两体碰撞和身体-传感器碰撞中。如果您没有实现`"collision"`监听器，则此事件不会触发。'
- en: '`"preCollision":` An event type that fires right before the objects start to
    interact. Depending on your game logic, you may wish to detect this event and
    conditionally override the collision. It may also result in multiply reports per
    contact and affect the application performance.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"preCollision"`：在对象开始交互之前触发的事件类型。根据您的游戏逻辑，您可能希望检测此事件并条件性地覆盖碰撞。它还可能导致每次接触时多次报告，并影响应用程序性能。'
- en: '`"postCollision":` An event type that fires right after the objects have interacted.
    This is the only event in which the collision force is reported. If you do not
    implement a`"postCollision"` listener, this event will not fire.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"postCollision"`：在对象交互之后触发的事件类型。这是唯一报告碰撞力的事件。如果您没有实现`"postCollision"`监听器，则此事件不会触发。'
- en: Note
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Collisions are reported between pairs of objects and can be detected either
    globally, using a runtime listener, or locally within an object, using a table
    listener.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 碰撞是在对象对之间报告的，并且可以通过运行时监听器全局检测，或者使用表监听器在对象内部本地检测。
- en: Global collision listeners
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局碰撞监听器
- en: When detected as a runtime event, each collision event includes `event.object1`,
    which contains the table ID of the Corona display object involved.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到运行时事件时，每个碰撞事件都包含`event.object1`，其中包含参与碰撞的Corona显示对象的表ID。
- en: 'For example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Local collision listeners
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地碰撞监听器
- en: When detected with a table listener within an object, each collision event includes
    `event.other`, which contains the table ID of the other display object involved
    in the collision.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当在对象内部使用表监听器检测时，每个碰撞事件都包含`event.other`，其中包含参与碰撞的另一个显示对象的表ID。
- en: 'For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Time for action—adding game listeners
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加游戏监听器
- en: For many of the functions we have created for our game objects we need to activate
    the event listeners so that they will run the code and disable them when gameplay
    has stopped.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们为游戏对象创建的许多函数，我们需要激活事件监听器，以便它们可以运行代码，并在游戏停止时禁用它们。
- en: The last function we need to create in order to complete this game is called
    `gameListeners()`, which will also have a parameter called `event`. This should
    be added right after the `gameLevel2()` function.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个游戏，我们需要创建的最后一个函数是`gameListeners()`，它也将有一个名为`event`的参数。这应该紧接在`gameLevel2()`函数之后。
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add in the following event listeners that will start several events in the
    application using an `if` statement:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if`语句添加以下事件监听器，以在应用程序中启动几个事件：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next we'll add in an `elseif` statement for the event listeners that will remove
    the events and then close the function.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为事件监听器添加一个`elseif`语句，用于删除事件并关闭函数。
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In order for `function gameListeners()` to work properly, we need to instantiate
    it in the `startGame()` function using the`"add"` string in the parameter. Place
    it before the end of the function.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`function gameListeners()`正常工作，我们需要在`startGame()`函数中使用参数中的`"add"`字符串来实例化它。将其放置在函数末尾之前。
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `alertScreen()` function, add the`"remove"` string in the parameter and
    place it at the start of the function.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`alertScreen()`函数中，将参数中的`"remove"`字符串添加到函数的开始处。
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All the code has been written! Go ahead and run the game in the simulator. The
    application is also device ready. Make a simple icon image that fits the required
    dimensions for the device you're developing on. Compile a build and run it on
    your device.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有代码都已编写！现在请在模拟器中运行游戏。应用程序也已准备好适配设备。制作一个适合你正在开发的设备所需尺寸的简单图标图像。编译构建并在你的设备上运行它。
- en: What just happened?
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: There are two sets of `if` statements for the `event` parameter,`"add"` and`"remove"`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`event`参数有两个`if`语句集，`"add"`和`"remove"`。
- en: All the event listeners in this function play an important role in making the
    game run.`"accelerometer"` and`"enterframe"` are used as runtime events since
    they have no specific target.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中的所有事件监听器在使游戏运行方面都发挥着重要作用。`"accelerometer"`和`"enterframe"`作为运行时事件使用，因为它们没有特定的目标。
- en: Both the `paddle` and `ball` have`"collision"` events that will carry out their
    purpose in any object contact made.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`paddle`和`ball`都有`"collision"`事件，它们将在任何对象接触时执行其功能。'
- en: The`"touch"` event allows the user to touch and drag the paddle so it can move
    back and forth in the simulator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`"touch"`事件允许用户触摸并拖动挡板，使其可以在模拟器中来回移动。'
- en: Notice `event == "remove"` removes all event listeners that were active in the
    game. When the game starts, `gameListeners("add")` is activated. When a win or
    lose condition is achieved, `gameListeners("remove")` is activated.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`event == "remove"`会移除游戏中所有活跃的事件监听器。当游戏开始时，`gameListeners("add")`被激活。当达到胜利或失败条件时，`gameListeners("remove")`被激活。
- en: Have a go hero—let's turn everything upside down
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来吧，英雄——让我们把一切都颠倒过来。
- en: What if we decided to flip the game upside down? In other words, place the paddle
    near the top of the screen, the ball below the paddle, and the group of bricks
    closer to the bottom of the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将游戏上下颠倒呢？换句话说，将挡板放置在屏幕顶部附近，球在挡板下方，砖块组靠近屏幕底部。
- en: 'Things you''ll have to consider:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的事情：
- en: The top wall is now an area you have to keep the ball from entering
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在顶部墙壁是你必须阻止球进入的区域。
- en: The y-direction the ball travels when it collides with the bricks
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球与砖块碰撞时移动的y方向。
- en: The ball has to reflect off the bottom wall when it collides with it
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球与底部墙壁碰撞时，它必须从底部墙壁反弹。
- en: As you can see, there are a couple things to consider before switching values
    from negative to positive and vice versa. Be sure to verify your logic and that
    it makes sense when creating this new variation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在从负值切换到正值以及反之亦然之前，有几件事情需要考虑。确保验证你的逻辑，并确保在创建这个新变体时它是有意义的。
- en: The results are in!
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果出来了！
- en: Let's reiterate block by block to make sure that we have everything added into
    our game. You can also refer to the `Breakout Final` folder in the [Chapter 4](ch04.html
    "Chapter 4. Game Controls") folder to see the final code. We made sure that we
    introduced our variables used in the game. We also initialized the `main()` function
    that starts the gameplay. A **Main Menu** screen was implemented with the game
    title and a **Play** button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐块重申，以确保我们已经将所有内容添加到我们的游戏中。你也可以参考[第4章](ch04.html "第4章。游戏控制")文件夹中的`Breakout
    Final`文件夹，查看最终代码。我们确保介绍了游戏中使用的变量。我们还初始化了`main()`函数，该函数启动游戏。实现了**主菜单**屏幕，包含游戏标题和**开始游戏**按钮。
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next we transitioned the `menuScreenGroup` away from the stage to load the main
    playing field. The main display objects of the game, such as the paddle, ball,
    and bricks were added. The score and the level number were displayed as the UI
    elements and updated throughout gameplay. Paddle movement in both the simulator
    and accelerometer were added as well as the collision detection with the paddle
    and the ball.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`menuScreenGroup`从舞台移除以加载主游戏区域。游戏的主要显示对象，如挡板、球和砖块被添加。分数和关卡数字作为UI元素显示，并在整个游戏过程中更新。同时添加了模拟器和加速度计中的挡板移动以及挡板和球的碰撞检测。
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The physical properties of the paddle and ball were added to the start of the
    game. The brick layouts for each of the two levels were created. We have added
    event listeners to all our game objects from the point when they need to be activated
    during the game and removed when gameplay is over.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 挡板和球的物理属性被添加到游戏开始时。为两个关卡各自创建了砖块布局。我们从游戏对象需要激活时开始添加事件监听器，并在游戏结束后移除。
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Every time the ball collides with a brick, the brick is removed from the scene.
    The directional changes are updated to the ball for every wall, paddle, or brick
    collision made. Every time a win or lose condition occurred, all game objects
    are reset to begin at the start of the current or new level.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当球与砖块碰撞时，砖块就会从场景中移除。对于每个墙壁、挡板或砖块的碰撞，都会更新球的方向变化。每次发生胜负条件时，所有游戏对象都会重置，以开始当前或新关卡。
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When a condition occurs, an **Alert** screen pops out, notifying the player
    what has happened. The display objects that initiate the alerts are created into
    a function. Lastly, the win and lose arguments are created to determine if the
    current level has to be replayed, goes to the next level, or if the game has been
    completed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生条件时，一个**警报**屏幕弹出，通知玩家发生了什么。创建触发警报的显示对象为一个函数。最后，创建胜负参数以确定当前关卡是否需要重玩、进入下一关卡，或者游戏是否已经完成。
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Beware of case-sensitive variables and functions in case you run into errors.
    Also be sure to check if you're missing any punctuation required in your code.
    These can be easily overlooked. Refer to your **Terminal** window in the simulator
    for any error references.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量和函数的大小写敏感，以防遇到错误。同时，确保检查代码中是否缺少任何必要的标点符号。这些很容易被忽略。请参考模拟器中的**终端**窗口以获取任何错误参考。
- en: Pop quiz—working with game controls
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验——与游戏控制操作
- en: How do you properly remove a display object from the stage?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何正确地从舞台中移除显示对象？
- en: a. `remove()`
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. `remove()`
- en: 'b. `object: remove()`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. `object:remove()`
- en: c. `object:removeSelf(); object = nil`
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. `object:removeSelf(); object = nil`
- en: d. None of the above
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: What is the correct way to make the following display object into a physical
    object?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的方式是将以下显示对象转换为物理对象是什么？
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: a. `physics.addBody( circle, { density=2.0, friction=0.5, bounce=0.2, radius
    = 25 } )`
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. `physics.addBody( circle, { density=2.0, friction=0.5, bounce=0.2, radius
    = 25 } )`
- en: b. `physics.addBody( circle, "dynamic", { density=2.0, friction=0.5, bounce=0.2,
    radius = 15 } )`
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. `physics.addBody( circle, "dynamic", { density=2.0, friction=0.5, bounce=0.2,
    radius = 15 } )`
- en: c. a and b
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. a 和 b
- en: d. None of the above
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上都不是
- en: What best represents what`"began"` means in the following function?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数中，“began”一词的最佳代表是什么？
- en: '[PRE55]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: a. A finger moved on the screen
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 手指在屏幕上移动
- en: b. A finger was lifted from the screen
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 手指从屏幕上抬起
- en: c. The system cancelled tracking the start touch
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 系统取消了跟踪起始触摸
- en: d. A finger touched the screen
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 手指触摸了屏幕
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You have completed making your very first game! You should
    be very proud of yourself. Now you have experienced how simple it is to make an
    application with Corona. It can take merely a few hundred lines of code to make
    an application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了你的第一个游戏！你应该为自己感到非常自豪。现在你已经体验到了使用Corona制作应用程序的简单性。制作一个应用程序可能只需要几百行代码。
- en: 'In this chapter, we covered the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下内容：
- en: Added movement to the paddle with touch events
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过触摸事件为挡板添加了移动
- en: Introduced the accelerometer features
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍了加速度计功能
- en: Implemented collision event listeners for all game objects affected
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有受影响的游戏对象实现了碰撞事件监听器
- en: Removed objects from memory when they weren't needed on the game screen
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当游戏屏幕上不再需要时，从内存中移除对象
- en: Implemented movement of the ball as a physical object
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了将球作为物理对象的移动
- en: Updated a scoreboard for every brick collision
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新了每次砖块碰撞的得分板
- en: Learned how to handle win and lose conditions
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了如何处理胜负条件
- en: The past two chapters weren't so bad now were they? We're getting familiar with
    the workflow as we continue programming in Lua. It will definitely get easier
    to understand as long as you keep working with different game frameworks.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 过去的两章现在看起来并不那么糟糕了，不是吗？随着我们在Lua中继续编程，我们正在熟悉工作流程。只要你继续使用不同的游戏框架，理解起来一定会更容易。
- en: What the next chapter holds will be another game that will surely catch your
    attention. We'll be creating animated sprite sheets for our display objects. How's
    that for eye candy?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将包含另一个肯定会吸引你注意力的游戏。我们将为显示对象创建动画精灵表。这难道不是视觉盛宴吗？
