- en: Chapter 4\. Moving to Real-World Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to set up the necessary environment
    configurations and how to build your first vanilla system, targeting the emulator.
    In this chapter, we will have a quick overview of the fundamental tools of every
    expert Android user and we will complete our first system for a real device—configure,
    build, flash, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging tools are some of the tools that no developer can live without. With
    embedded systems such as Android systems they are even more important. Android
    provides lots of debugging tools to facilitate complex or boring tasks. The two
    most important tools are definitely `adb` and `fastboot`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ADB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ADB stands for Android Debug Bridge and it''s a toolkit made of two crucial
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Adb server running on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adb client running on the PC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, `adb` is considered a command-line tool, but you can find a few graphical
    frontends online if you prefer to use it in a more graphical way. Android Studio,
    the official IDE by Google for Android development, uses `adb` to communicate
    with every device and provide cool tools such as `Android Device Monitor`. Using
    the graphical interface, we can analyze logs coming from the device or even take
    a screenshot for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the **Android Device Monitor** can be used
    to retrieve huge amounts of information from devices and apps running on the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_48.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: During our journey, we will use `adb` mostly on the command line, due to the
    embedded nature of our work. As we know, the emulator behaves like a hardware
    device, so we can easily use `adb` to communicate with it. Let's see a couple
    of useful commands to interact with our running emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a handy list of all the available commands. That''s easily
    achievable with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to detect the connected devices. On our trusty Terminal, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/epub_36702041_49.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous command will scan for every attached device and will list them.
    The previous screenshot shows that our emulator is attached and ready to communicate.
    In a multidevice scenario, we could have some issue when properly detecting our
    devices. Adb gives us a further option, `-l`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_50.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `–l` option, `adb` will show more details about the devices, and this
    will help us to identify them properly, as shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have detected the device, we can communicate with it in a few ways.
    One of the most common way is connecting it to the device''s internal shell. Every
    Android device comes with a system shell: it''s a common tool for embedded or
    remote systems. To connect the the internal shell, we simply need to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have more then one device, we will need to specify which device we want
    to connect to, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are connected to the internal shell, we can treat the system like a
    common `*nix` system. We can run an `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the next screenshot, we obtain the directory listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_51.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We suggest you explore the filesystem and play around. You will find that you
    can do almost whatever you want, from manipulating files to manipulating applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing files to devices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adb gives us dozens of useful commands to manage our devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `adb push` command is certainly one of the most useful. It allows us to
    copy files from our computer to our Android device. The next screenshot shows
    how to upload a single file to our device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_52.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have created a new file, `pippo.txt`, containing a single line, `hello pippo`,
    then we uploaded this file to our connected device, into the `/sdcard/` folder.
    As you can see, the first argument is the filename and the second one is the destination
    we want to copy the file to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows `pippo.txt` successfully uploaded to the device''s
    `/sdcard/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_53.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pulling files from devices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During development, we could need to retrieve a file from the device. To achieve
    this, `adb` gives us the opposite of `push`, which is `pull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is able to retrieve a file from a connected device and
    copy it to our computer. The syntax is fairly similar to `push`, simply with an
    inverse outcome. The next screenshot shows how to `pull` our `pippo.txt` from
    the device and copy it to the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_54.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have deleted our original file from the current folder, pulled the one on
    the device to the current folder, using `.` as the destination, and checked that
    the copied `pippo.txt` file contains the expected line, `hello pippo`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android APK files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we know, any Android application is contained in an APK file. Usually, users
    don''t see this file, because they install all their apps using the Google Play
    Store. As advanced users, we often deal with unreleased applications, for debugging
    and testing. These apps aren''t available on Google Play Store yet, so `adb` gives
    us the opportunity to manually install them with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows how the APK file has been successfully installed
    on our device number ZX1B226467:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_55.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Logcat
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every complex system such as Android needs a logging system. Android provides
    logging capabilities via `logcat` to help users with development and monitoring.
    Using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instruct `adb` to connect to the Android logging system, select the
    default buffer, and start printing every single system logging message, in real-time,
    to our terminal. Android provides other two logging buffers for advanced use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`radio`: This contains all the relevant logging messages related to the radio
    communication system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`: This contains messages related to the system events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can select a buffer different from the default using the `–b` option. For
    instance, if we want all the logs related to events, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Adb `logcat` comes with a few interesting output modes. We can select them
    using the `–v` option and the mode name:'
  prefs: []
  type: TYPE_NORMAL
- en: brief
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: printable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: raw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: threadtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: usec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next screenshot shows `logcat` output when we choose the `color` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_56.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, `logcat` will use a different color for every different logging
    level. We can even filter according to the logging level itself, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are only displaying error messages. The next screenshot shows
    every available filtering argument we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_57.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a complete list of all the possible options available with `logcat`, you
    can access the `logcat` command help using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the full list of all the available options with
    their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_58.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fastboot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fastboot is the tool that Android gives us to manipulate the device Flash Memory
    and its partitions, using a computer and an USB connection. Fastboot does not
    communicate with the Android system. It communicates with a specific firmware
    able to interact in a minimal system environment: `bootloader mode`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bootloader mode, the system initializes only the minimal amount of hardware
    and software to accomplish the most critical operations of all:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flash`: This option is used to deploy a new binary system image from the host
    computer to the device partitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase`: This option is used to delete a specific partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reboot`: This option is used to reboot the device in one of the available
    booting modes: recovery, bootloader, or standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This option is used to format a specific partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next screenshot shows the output of the following command, the full list
    of all the available options of `fastboot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can easily imagine, `fastboot` will be a big player in the future, when
    we will start building and testing our custom Android system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_59.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing our hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to obtain the source code, how the
    build system works, and how to build our first custom Android system for the emulator.
    The only things we know about real hardware are that Android is primarily used
    on smartphones and tablets and that we can certify our hardware according to the
    Android **Compatibility Definition Document (CDD)**, with all its constraints
    and rules. The truth is that Android CDD aims to provide guidelines to bring to
    the market devices that are compliant with Google Mobile Services requirements.
    This is crucial information because it gives us the freedom to choose different
    hardware if our goal is not to develop a smartphone or a tablet for the main consumer
    market.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two years, the amount of devices not being a smartphone or a tablet,
    but being able to run Android has increased enormously. There is a whole new ecosystem
    of te so-called development boards that can run Android or Ubuntu Linux, for instance.
    Most of these boards are not CDD compliant—they don't have apps such as Google
    Play Store, YouTube, Google Maps, and so on, but they still run Android and they
    can still be tested against Android CTS. This is a great opportunity for manufactures
    or advanced users who want to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is now possible because the actual hardware requirements to boot
    Android are getting very minimal nowadays. Keep in mind that Android is based
    on the Linux Kernel and the system itself has a few similarities if we strip away
    the Google apps ecosystem. Nowadays, most of the boards that are equipped with
    enough hardware to run Linux have a good chance of running Android as well.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware architectures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most popular hardware architecture we find in the Android market is definitely
    the ARM family, with its ARMv7 and ARMv8-A. Over time, the x86 and MIPS platforms
    received official support and they have gained market shares in recent months.
    As a further note, Android 5 Lollipop introduced support for 64-bit architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a fashion that reminds us of minimal requirements just for playing games,
    even Android as its own. For instance, Android 5.1 requires at least 512 MB RAM
    if it is going to be installed on a device with a standard display density device.
    Otherwise, you will need at least 1.8GB RAM if you are planning to port it to
    a device with a high density display.
  prefs: []
  type: TYPE_NORMAL
- en: The previous versions are less demanding when it comes to RAM. Android 4.4 KitKat,
    for instance, requires only 512 MB RAM. Unfortunately, KitKat comes with other
    constraints—there is no support for 64-bit architectures and a OpenGL ES 2.0 GPU
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of other hardware components, such as cameras, GPS sensors, accelerometers,
    gyroscopes, touchscreens, and so on, are very common, but they are absolutely
    optional—if your device does not need a camera, you can just save money. You can
    tailor your system, starting from a very minimal system, up to what is specifically
    needed for your use cases.
  prefs: []
  type: TYPE_NORMAL
- en: System on Chip – SoC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The coming of advanced embedded systems, such as smartphones and tablets, created
    a huge demand for new embedded chips—more and more small and powerful. When you
    think about a computer, you think about CPUs, motherboards, video cards, and lots
    of external devices. In the embedded world, you think about SoC.
  prefs: []
  type: TYPE_NORMAL
- en: 'SoC stands for System on Chip and it goes beyond the simple concept of a CPU.
    Most of the current SoC solutions embed a multicore CPU, RAM controller, ROMs,
    EEPROMs or Flash memories, USB support, Ethernet support, USART, SPI, and even
    a power management system. Everything is contained in one single chip, as shown
    in the next screenshot of an example SoC architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_60.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can imagine, the immediate advantage of this approach is the small size
    of the system. We can now have powerful, more and more feature complete and complex
    systems, with smaller and smaller power consumption in a smaller and smaller package,
    to satisfy every need that the market has.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest players here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Samsung
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualcomm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huawei
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediatek
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texas Instrument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseband processor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are planning to develop a smartphone or a radio-enabled device, you are
    going to deal with some kind of **baseband processor (BP)**. A baseband processor
    is a separated component; most of the time it is outside the SoC that is in charge
    of everything related to radio communications.
  prefs: []
  type: TYPE_NORMAL
- en: The BP is a critical component and it's kept separate for security reasons.
    Governments have strict policies about radio component certifications and basically,
    every Government requires that these components are equipped with read-only firmwares.
    Due to its nature, a BP is usually equipped with a specific real-time operating
    system and communicates with the external world via an AT commands-based serial
    bus.
  prefs: []
  type: TYPE_NORMAL
- en: Our hardware choice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this book in mainly to teach how to create a custom system for an
    existing device and how to approach the creation of a working Android system for
    a device that can be turned into an Android device with a fair amount of will
    and effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use two popular devices in this journey:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Nexus 6 by Motorola
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDOO by Aidilab and SECO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motorola Nexus 6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the second chapter, we learned about Google devices—smartphones, tablets,
    and so on. In this chapter, we will work with their latest smartphone currently
    available—the Nexus 6.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_61.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nexus 6, codename Shamu, is currently the top device available by Google. Its
    technical specifics are impressive:'
  prefs: []
  type: TYPE_NORMAL
- en: Qualcomm® Snapdragon™ 805 with quad-core 2.7 GHz CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display QHD AMOLED, 5.96" 2,560 x 1,440 (493 ppi), 16:9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Back camera: 13 MP, Led flash, f/2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Front camera: 2 MP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPU: Adreno 420'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wireless: 802.11ac 2x2 (MIMO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bluetooth: 4.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM: 3 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: 32 GB or 64 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sensors: GPS, gyroscope, accelerometer, light sensor, barometer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Networking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GSM: 850/900/1,800/1,900 MHz'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Band WCDMA: 1/2/4/5/6/8/9/19'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Band LTE: 1/3/5/7/8/9/19/20/28/41'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CA DL: B3-B5, B3-B8'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Battery: 3,220 mAh, wireless charging systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the internal structure—SoCs, battery, display
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_62.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Nexus 6 is obviously a fully CDD and CTS-compliant platform. It's shipped with
    the full Google Apps package and will be our reference as a certified device.
  prefs: []
  type: TYPE_NORMAL
- en: UDOO Quad
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Completely different compare to the Nexus 6, UDOO is not a smartphone or a Google
    certified device—there are no Google Apps here. It's a so-called Single Board
    Computer—a development and experimentation board that can be equipped with Android
    or Ubuntu Linux. UDOO will be our reference board to prove that we can create
    a working Android system out of hardware that's pretty different from a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at its technical specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: Freescale ARM i.MX6 Cortex A9 Quad core 1GHz CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPU Vivante GC 2000 + Vivante GC 355 + Vivante GC 320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atmel SAM3X8E ARM Cortex-M3 CPU (same as Arduino Due)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '76 fully available GPIO: 62 digital + 14 digital/analog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM: DDR3 1GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethernet up to 1,000Mbit/s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On board micro SD card as primary storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HDMI port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LVDS port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SATA interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTC module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSI camera connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 USB ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x 3.5" ports for mic and speakers![](img/epub_36702041_63.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are no sensors—there is no fancy light sensor or gyroscope,
    no accelerometer, and no GPS. There is no Baseband Processor either—we can't make
    phone calls, but we have more than enough to run Android on it!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have surely spotted the Atmel microprocessor. Basically, UDOO comes with
    an embedded Arduino microprocessor that can be used to push your experimentations
    even further—go for it!
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Android for a real-world device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you know everything you need to know about the build system and how
    to retrieve the source code. Retrieving the proper source code for Google official
    devices is no big deal, but life isn't always so easy. Working with many different
    devices, you will certainly come across a manufacturer who is not willing to give
    the source code away. They are not legally forced to release it. This is an unfortunate
    scenario that, hopefully, will be considered bad marketing and will disappear
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, instead, we are going to play with two devices that offer great
    support and that will magnificently serve the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Nexus 6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first device we are going to explore is the official Google Nexus 6 by
    Motorola. We have already had an overview of the device. If you want to push it
    even further, you can refer to the official Motorola Nexus 6 web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.motorola.in/consumers/View-all-Mobile-Phones/Nexus-6-by-Motorola/nexus-6-in.html](http://www.motorola.in/consumers/View-all-Mobile-Phones/Nexus-6-by-Motorola/nexus-6-in.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second chapter, we learned how to retrieve the source code for Google
    official devices. The only thing we need to know now is the specific tag to refer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The moment we have the source code, we can set up the environment with the
    setup script and run the `lunch` command to specifically target our Nexus 6\.
    The next screenshot shows how we are choosing device number 16, Nexus 6— codename
    Shamu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_64.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For security and copyright reasons, the source base we acquired does not contain
    everything we need to build the system. Real-world devices, unlike the emulator,
    come with proprietary software components that must be downloaded separately.
    For instance, our Nexus 6 has proprietary software by three of its component manufacturers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcom**: NFC, Bluetooth, and Wi-Fi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motorola**: Media, audio, thermal, touchscreen, and sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qualcomm**: GPS, audio, camera, gesture, Graphics, DRM, video, and sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The software components are distributed as binary files and can be downloaded
    at [https://developers.google.com/android/nexus/drivers](https://developers.google.com/android/nexus/drivers),
    by looking for Nexus 6, build codename LMY48M. Download the three files and extract
    them into your `WORKING_DIRECTORY`. The next screenshot shows the content of your
    download folder, with the three downloaded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_65.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every one of the downloaded packages contains a script, once you extract the
    content. The moment you run this script, it will show you a license you need to
    accept in order to continue. The next screenshot shows you the process for the
    `extract-broadcom-shamu.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/epub_36702041_66.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These three scripts are the final configuration step before launching the actual
    build process. After we have accepted all the three licenses, we can run our trusted
    `make` command and, patiently, wait for the build process to complete.
  prefs: []
  type: TYPE_NORMAL
- en: When the build process is over, the `out/target/product/shamu/` folder will
    contain your first Android build for the Google Nexus 6.
  prefs: []
  type: TYPE_NORMAL
- en: UDOO Quad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UDOO is one of the most popular development boards on the market. The hardware
    is top notch, the user community is great, it's well documented and it's the perfect
    workbench for an infinite number of experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'UDOO is not a Google device, so there is no chance we could use the source
    code we already have to create out custom Android system. We must stick to the
    source code that UDOO manufacturers provide the advanced users with. You can download
    the source code from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://download.udoo.org/files/Sources/UDOO_Android_4.4.2_Source_v1.0.tar.gz](http://download.udoo.org/files/Sources/UDOO_Android_4.4.2_Source_v1.0.tar.gz)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the file, you can extract it using your terminal and
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you have already figured out, the last available version of the UDOO Android
    source base is KitKat. When our adventure is over, you could try to port Lollipop
    to this platform as a new challenging Android project.
  prefs: []
  type: TYPE_NORMAL
- en: The extracted files and folders look exactly like the official Android folder
    structure we saw for the Nexus 6\. The only real difference is that UDOO provides
    us with the source code for almost every component—you will find the bootloader
    source code and even the Linux kernel source code. Both bootloader and kernel
    will be compiled during the building process, unlike the Nexus 6 scenario, where
    we got them as precompiled files. The Android system, bootloader, and kernel will
    be combined to create the final image set we will need to deploy to our UDOO.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before launching the `envsetup` script, we need to configure the environment
    to be able to build the bootloader. We will learn a lot about the bootloader in
    the next sections. For now, you just need to open up your Terminal and run these
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last configuration step, we need to set up the build system to properly
    generate the system image for our UDOO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Bootloader
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Everything is in place. We can now compile the bootloader. Open a Terminal
    and navigate to the `bootloader` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This folder contains the executable to perform the bootloader compilation.
    Run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will show a configuration dialog, like the one in the
    next screenshot. You will select the hardware configuration you are targeting—CPU,
    RAM, and so on. When everything is properly configured, the compilation process
    will be performed and it will generate the bootloader binary images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_67.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: System
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we have the bootloader images, we can go back to the source code root
    folder and launch the main system image build process, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This could take a while, so be patient. As usual, when the compilation is over,
    you will find all the binary images you will need in the `out/` folder, ready
    to be installed to our hardware and bring it to live.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Linux kernel will be compiled automatically during the Android system building
    process. If you want, you can also build the kernel by yourself, using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The process will generate a brand new `boot.img` in the `out/` folder. You can
    find the specific kernel file in `kernel_imx/arch/arm/boot`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sections guided you to your first system images, ready to be flashed
    to your hardware. These images will be deployed to the device memory. The Nexus
    6 has an internal Nand memory. The UDOO has a pretty standard SD card. The first
    step of the deployment is switching the device into the bootloader mode.
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader mode is a particular state of the device that allows us to transfer
    and deploy a system image to the device itself, using the `fastboot` utility.
    Every device running Android has this mode, but not every device will let us access
    it. Some devices come with a locked bootloader, for security reasons or simply
    because of a short-sighted manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we will be able to access the bootloader on our devices: Google
    is a generous manufacturer and every Nexus device comes with an unlocked or unlockable
    bootloader; UDOO, as a development board, is designed to be developer friendly,
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Nexus devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Nexus device will let us to access bootloader mode, but every device
    will do it in its own way. According to the model, we will need a specific sequence
    of steps to boot the device in bootloader mode. The following table shows how
    to do it for every Nexus device. Be sure to turn off your device and unplug the
    USB cable, pick the model from the table, and press the right buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_68.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our Nexus 6, we need to press *Volume Down* then also press *Power* and
    keep both pressed. The smartphone will boot and you will land on a screen like
    the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_69.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we are in `Bootloader Mode`!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will notice is the quite explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Device is LOCKED*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, Nexus devices come with an unlockable bootloader. We just need
    to connect the device to our computer with a standard USB cable, open a terminal
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You will see a notice message that will warn you that unlocking the bootloader
    will erase everything on your device. Yes, it will. That's unfortunate, but, from
    a security and system point of view, it's necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the right moment to think about a data backup. You can still abort the
    process, restart your smartphone, save your data and try again. We will wait for
    you!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are brave enough and you just don''t need all those pictures of little
    kitties on your phone anymore, just select `YES` and the bootloader will unlock
    smoothly. If for any reason you''d like the bootloader to lock again, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The moment we unlocked the bootloader, we gained full control of the Nand memory—we
    can erase partitions or flash the system images we have created. Unfortunately,
    Google does not release the source code of the bootloader, so we wouldn't know
    how they implement the whole fastboot protocol. Luckily for us, we are going to
    figure it out thanks to UDOO. The UDOO manufacturer provides us with the full
    source base, even the one for the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: UDOO family boards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UDOO comes as an open book. We can access every partition on its memory, with
    basically zero effort. There is no such thing as a "button ninja combination"
    to switch to bootloader mode. We can use a serial connection to analyze the whole
    boot process, stop it, and interact with it using the control console:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the serial interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the boot sequence
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the uboot console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run fastboot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the `fastboot server` ready to go. With the server in place, we
    will be able to connect to fastboot from our computer, using the `fastboot client`
    we already know.
  prefs: []
  type: TYPE_NORMAL
- en: This process could seem a bit harder than the one from Nexus. That's true. The
    fact is that UDOO does not ship with a default secret bootloader like the Nexus
    or any other mainstream smartphone on the market does. UDOO is mainly a development
    board and, as with lots of such devices, gives you the freedom and power to choose
    the bootloader you prefer. However, in an effort to be more developer friendly,
    UDOO can perfectly work with the most popular open source bootloader solution—`uboot`.
  prefs: []
  type: TYPE_NORMAL
- en: The `uboot` solution is fully compliant with the standard requirements for a
    bootloader to properly launch an operating system—hardware initialization, memory
    test, and so on. It also implements the fastboot protocol and the extraction of
    the kernel contained in the `boot.img`, generated by the build system. These last
    two features make it fully compatible with Android.
  prefs: []
  type: TYPE_NORMAL
- en: Flashing Android images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we are. Every piece of the puzzle is in place—you can finally move forward
    to installing your brand new custom Android version onto your device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As a reminder, we built the so-called stock version of the Android system:
    you won''t find any of the Google apps in here—no YouTube, no Google Play Store.'
  prefs: []
  type: TYPE_NORMAL
- en: Nexus 6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the build process is complete, you will find all the system images you
    need in the **out/target/product/shamu** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system.img`: This is, well, the system image. It contains the whole operating
    system—Android Framework, system native libraries, and the system utility app,
    such as Calc or Clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recovery.img`: This image contains what we are going to place in the *Recovery*
    partition. It contains a kernel and the recovery software itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.img`: This image contains the Linux Kernel and a small RamDisk. This
    image will be placed in the boot partition and will contain all the files needed
    to initialize the system: `init.rc`, for instance, and every other component needed
    to start the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every partition can be flashed using a specific partition image and an appropriate
    command. Switch your Nexus into bootloader mode, plug the USB cable, and let''s
    flash a few partitions. Launch your Terminal, navigate to `out/target/product/shamu`,
    and execute these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The last command will reboot your device and your brand new custom Android version
    will come to life! This first version of the system will definitely look bare
    without Google Play Store. With no possibility of installing applications, there
    is very little we can do with a device, indeed. No sad faces, please! In the next
    chapters, we will learn how to acquire and install the Google apps we need and
    how to customize our system.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, in this first run, we used the Linux Kernel provided by Google—we
    didn't compile it from sources. In the next chapters, we will learn how to do
    it and take full control.
  prefs: []
  type: TYPE_NORMAL
- en: UDOO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, UDOO is slightly different. We have a few possible paths to achieve
    our goal, but first things first—partitions. The first step is to prepare the
    SD card with the proper partitions set. Unlike the Nexus and its pre-partitioned
    Nand memory, ready to be flashed, with UDOO we have full control of the system,
    even of the memory partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Freedom and power come with responsibility—we need to create the proper partitions
    before being able to install the system. Being developer friendly, the UDOO development
    team provides a handy script to speed up the job. The root folder of your UDOO
    working directory contains a `make_sd.sh` file. Insert the UDOO SD card in your
    computer and detect the disk number:'
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, using `df –f`, you should look for something like `/dev/mmcblkX`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On OS X, using `diskutil list` you should look for something like `/dev/rdisksX`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A super easy trick is to insert the SD card and note down all the disk numbers.
    Extract the SD card and figure out the one that is now missing! Once you have
    detected the disk number, you can run the script like this by specifying the proper
    disk name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The script will automatically erase the SD card, create the partition structure,
    and copy all the files the build system generated and deployed in `out/`. This
    could take a while, depending on the speed of your SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw, developing for a Google device is pretty straightforward: we download
    the source code and start configuring the system to achieve our built images.
    We end up with a stock version of the system we can later decide to customize
    as we like. Developing or porting Android to a new hardware is a totally different
    matter: it is quite different and requires a bit of effort and commitment.'
  prefs: []
  type: TYPE_NORMAL
- en: When you decide to set out for a journey like this, the first crucial step is
    choosing the proper hardware platform. The market offers a large collection of
    vendors and every vendor offers his own particular solutions—different SoC, different
    on-board sensors, cheap low-end boards, or hyper-fast expensive boards. There
    is no place in this book for discussion about choosing an expensive board or not.
    We focus on the developer and their world and, as a professional, 99% of the time
    they will find themselves working with a so-called reference board*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'A **reference board** is a particular kind of development board that every
    vendor offers to its potential clients. Usually, a reference board ships with
    everything possible on-board—tons of sensors, tons of external devices, tons of
    connectors, and possible purposes. The final goal is to provide developers with
    a board that can truly show off the full potential of the SoC and the whole hardware
    solution. Everything is tailored to make developers'' life easy: the Linux Kernel
    source code is provided, the hardware components specifications are provided,
    and the documentation is provided.'
  prefs: []
  type: TYPE_NORMAL
- en: The UDOO board we played with in the chapter can be considered close to a reference
    board. It does not have every possible sensor, but it's easily expandable with
    external sensors and we know how to communicate with those sensors because the
    platform is open and easy to debug. An easy way to debug our software and hardware
    is crucial to make our developing time effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'UDOO comes with a handy micro-USB connection that is also a Serial-to-USB converter.
    Using this connection, we can interact with the board at one of the lowest level
    monitors and manipulate the boot sequence. To properly connect to the board console,
    we need to install a specific software on our computer: a modem control and terminal
    emulator named `minicom`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install it on Ubuntu using `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install it on OS X using `brew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have `minicom`, we can connect the turned-off UDOO to the USB port
    and run the following command on our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ttyUSB0` is the system device that the operating system associated to the
    UDOO connection. It could be different on your system, that is `ttyUSB1`, `ttyUSB2`,
    according to the hardware configuration, other connected USB devices, and so on.
    A bit of trial and error could be necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now plug the power cable in and turn on the board. If the connection
    is properly configured, you will see the boot sequence as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_70.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can monitor the boot sequence and interact with the system in a few interesting
    ways. The one we are interested in now is stopping the boot sequence and switching
    to bootloader mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the boot sequence, you will see a message suggesting how to stop the
    boot sequence itself and access `uboot`. Once you are in, run `fastboot` as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_71.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now flash the system images we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the serial connection still on, when the system reboots, we can enjoy
    all the system messages that the boot sequence provides: system initialization
    and Linux kernel loading, until we reach Android loading and finish to Android
    system console prompt. This is the beauty and the power of having deep access
    to and knowledge about your system and your hardware. The following screenshot
    shows a part of the boot sequence in the precise moment of kernel deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_72.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you have built and installed your first Android system for
    a real-world device. You now know a lot more about Google Nexus 6 and UDOO board.
    You have learned how to use ADB and Fastboot. You have learned how to interact
    with a development board using a serial connection and tools such as minicom,
    monitoring, and manipulating the boot sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig into the Linux kernel building and customization.
  prefs: []
  type: TYPE_NORMAL
