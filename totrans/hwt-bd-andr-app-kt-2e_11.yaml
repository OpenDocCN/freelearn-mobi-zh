- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Architecture Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the key components of the Android Jetpack
    libraries and what benefits they bring to the standard Android framework. You
    will also learn how to structure your code and give different responsibilities
    to your classes with the help of Jetpack components. Finally, you’ll improve the
    test coverage of your code.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create applications that handle
    the lifecycles of activities and fragments with ease. You’ll also know more about
    how to persist data on an Android device using Room and how to use ViewModels
    to separate your logic from your Views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, you learned how to write unit tests. The question
    is: what can you unit-test? Can you unit-test activities and fragments? It is
    hard to unit-test activities and fragments on your machine because of the way
    they are built. Testing would be easier if you could move the code away from activities
    and fragments.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider the situation where you are building an application that supports
    different orientations, such as landscape and portrait, and supports multiple
    languages. What tends to happen in these scenarios by default is that when the
    user rotates the screen, the activities and fragments are recreated for the new
    display orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that happens while your application is in the middle of processing
    data. You have to keep track of the data you are processing, keep track of what
    the user was doing to interact with your screens, and avoid causing a context
    leak.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A **context leak** occurs when your destroyed activity cannot be garbage-collected
    because it is referenced in a component with a longer lifecycle – such as a thread
    that is currently processing your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/89BCi](https://packt.link/89BCi)
  prefs: []
  type: TYPE_NORMAL
- en: Android components background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many situations, you have to use `onSaveInstanceState` to save the current
    state of your activity/fragment, and then in `onCreate` or `onRestoreInstanceState`,
    you need to restore the state of your activity/fragment. This adds extra complexity
    to your code and makes it repetitive, especially if the processing code is part
    of your activity or fragment.
  prefs: []
  type: TYPE_NORMAL
- en: These scenarios are where `ViewModel` and `LiveData` come in. `ViewModels` are
    components built with the express goal of holding data in case of lifecycle changes.
    They also separate the logic from the Views, which makes them very easy to unit-test.
    `LiveData` is a component used to hold data and notify observers when changes
    occur while taking their lifecycle into account.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, the fragment only deals with the Views, `ViewModel` does the
    heavy lifting, and `LiveData` deals with delivering the results to the fragment,
    but only when the fragment is there and ready.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever used WhatsApp or a similar messaging app and you’ve turned off
    the internet, you’ll have noticed that you are still able to use the application.
    The reason for this is that the messages are stored locally on your device. This
    is achieved with a database file called `SQLite` in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Framework already allows you to use this feature for your application.
    However, this requires a lot of boilerplate code to read and write data. Every
    time you want to interact with the local storage, you must write a SQL query.
    When you read the SQLite data, you must convert it into a Java/Kotlin object.
  prefs: []
  type: TYPE_NORMAL
- en: All of this requires a lot of code, time, and unit testing. What if someone
    else were to handle the SQLite connection, and all you had to do was focus on
    the code part? This is where **Room** comes in. This is a library that is a wrapper
    over SQLite. All you need to do is define how your data should be saved and let
    the library take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you want your activity to know when there is an internet connection
    and when the internet drops. You can use something called `BroadcastReceiver`
    for this. A slight problem with this is that every time you register `BroadcastReceiver`
    in an activity, you must unregister it when the activity is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `Lifecycle` to observe the state of your activity, thereby allowing
    your receiver to be registered in the desired state and unregistered in the complementary
    one (for example, `RESUMED-PAUSED`, `STARTED-STOPPED`, or `CREATED-DESTROYED`).
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`, `LiveData`, and `Room` are all part of the Android architecture
    components, which are part of the Android Jetpack libraries. The architecture
    components are designed to help developers structure their code, write testable
    components, and help reduce boilerplate code.'
  prefs: []
  type: TYPE_NORMAL
- en: Other architecture components include `Databinding` (which binds views with
    models or `ViewModels`, allowing the data to be directly set in the Views), `WorkManager`
    (which allows developers to handle background work with ease), `Navigation` (which
    allows developers to create visual navigation graphs and specify relationships
    between activities and fragments), and `Paging` (which allows developers to load
    paginated data, which helps in situations where infinite scrolling is required).
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ViewModel` component is responsible for holding and processing data required
    by the **user interface** (**UI**). It has the benefit of surviving configuration
    changes that destroy and recreate fragments and activities, which allows it to
    retain the data that can then be used to re-populate the UI.
  prefs: []
  type: TYPE_NORMAL
- en: It will eventually be destroyed when the activity or fragment is destroyed without
    being recreated or when the application process is terminated. This allows `ViewModel`
    to serve its responsibility and to have garbage collected when it is no longer
    necessary. The only method `ViewModel` has is the `onCleared()` method, which
    is called when `ViewModel` terminates. You can overwrite this method to terminate
    ongoing tasks and deallocate resources that will no longer be required.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating data processing from the activities into `ViewModel` helps create
    better and faster unit tests. Testing an activity requires an Android test to
    be executed on a device. Activities also have states, which means that your test
    should get the activity into the proper state for the assertions to work. `ViewModel`
    can be unit-tested locally on your development machine and can be stateless, meaning
    that your data processing logic can be tested individually.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important features of `ViewModel` is that it allows communication
    between fragments. To communicate between fragments without `ViewModel`, you must
    make your fragment communicate with the activity, which will then call the fragment
    you wish to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this with `ViewModel`, you can just attach it to the parent activity
    and use the same `ViewModel` in the fragment you wish to communicate with. This
    will reduce the boilerplate code that was required previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see that `ViewModel` can be created at any
    point in an activity’s lifecycle (in practice, they are normally initialized in
    `onCreate` for Activities and `onCreateView` or `onViewCreated` for Fragments
    because these represent the points where the views are created and ready to be
    updated), and that once created, it will live as long as the activity does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle](img/B19411_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see how the lifecycle of `Activity` compares
    to that of `ViewModel`. The red lines indicate what happens when the `Activity`
    is recreated, starting from the `onPause` method, ending in `onDestroy,` and then
    going from `onCreate` to `onResume` in a new instance of `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how `ViewModel` connects to a fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle](img/B19411_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see how the lifecycle of `Fragment` compares
    to that of `ViewModel`. The red lines indicate what happens when `Fragment` is
    recreated, starting from the `onPause` method, ending in `onDetach`, and then
    going from `onAttach` to `onResume` in a new instance of `Fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what a ViewModel is and the benefits it provides
    with regard to testing and performing logic, which survives the recreation of
    the activity and fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.01 – shared ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been tasked with building an app with one screen split vertically into
    two when in portrait mode and horizontally when in landscape mode. The first half
    contains some text, and below it is a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second half contains only text. When the screen is opened, the text in
    both halves displays **Total: 0**. When the button is clicked, the text will change
    to **Total: 1**. When clicked again, the text will change to **Total: 2**, and
    so on. When the device is rotated, the last total will be displayed in the new
    orientation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this task, we will define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An activity that will hold two fragments – one layout for portrait and another
    for landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One fragment with one layout containing `TextView` and a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One fragment with one layout containing `TextView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One `ViewModel` that will be shared between the two fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin by setting up our configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and add an empty activity called `SplitActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s add the `ViewModel` library to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following strings to `values/strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and define `SplitFragmentOne`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `fragment_split_one.xml` file to the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create and define `SplitFragmentTwo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `fragment_split_two.xml` file to the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `SplitActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `activity_split.xml` file in the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/HPy9p](https://packt.link/HPy9p).
  prefs: []
  type: TYPE_NORMAL
- en: Replace `{package.path}` with the name of the package in which your Fragments
    are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a `layout-land` folder in the `res` folder. Then, in the
    `layout-land` folder, we’ll create an `activity_split.xml` file with the following
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/1zRQa](https://packt.link/1zRQa).
  prefs: []
  type: TYPE_NORMAL
- en: Replace `{package.path}` with the name of the package in which your Fragments
    are located. Notice the same `android:id` attribute in both the `activity_split.xml`
    files. This allows the operating system to correctly save and restore the fragment’s
    state during rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main/java` folder in the root package, create a `TotalsViewModel` that
    looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we extended from the `ViewModel` class, which is part of the lifecycle
    library. In the `ViewModel` class, we defined one method that increases the total
    value and returns the updated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `updateText` and `prepareViewModel` methods to the `SplitFragment1`
    fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `prepareViewModel()` function, let’s start adding our `ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is how the `ViewModel` instance is accessed. `ViewModelProvider(this)`
    will bind `TotalsViewModel` to the lifecycle of the fragment. `.get(TotalsViewModel::class.java)`
    will retrieve the `TotalsViewModel` instance that we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: If the fragment is being created for the first time, it will produce a new instance,
    while if the fragment is recreated after a rotation, it will provide the previously
    created instance. We pass the class as an argument because a fragment or activity
    can have multiple ViewModels, and the class serves as an identifier for the type
    of `ViewModel` we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set the last known value on the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second line will help during device rotation. It will set the last total
    that was computed. If we remove this line and rebuild, then we will see `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the View when the `fragment_split_one_button` button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last few lines indicate that when a click is performed on the button, we
    tell `ViewModel` to recompute the total and set the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the same `ViewModel` we used previously to our `SplitFragmentTwo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the app now, we’ll see that nothing has changed. The first fragment
    works as before, but the second fragment doesn’t get any updates. This is because
    even though we defined one `ViewModel`, we have two instances of that `ViewModel`
    for each of our fragments.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to limit the number of instances to one per fragment. We can achieve
    this by attaching our `ViewModel` to the `SplitActivity` lifecycle using a method
    called `requireActiviy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our fragments. In both fragments, we need to find and change the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewModels to communicate between fragments will only work when the fragments
    are placed in the same activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.3 – Output of \uFEFFExercise 11.01](img/B19411_11_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Output of Exercise 11.01
  prefs: []
  type: TYPE_NORMAL
- en: When the button is clicked, the total updates are on the top half of the screen
    but not on the bottom half. If we rotate the screen, the last value `ViewModel`
    had will be set on the second screen as well. This means that our application
    doesn’t react properly to the changes in `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we will need a publisher-subscriber approach to monitor changes
    that occur in our data. In the next section, we will look at some common data
    streams that ViewModels can use to notify when the data is changed.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we implemented a ViewModel, which was responsible for incrementing
    an integer value that will be displayed on the screen. In the section that follows,
    we will connect data streams to react to changes when the number is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: Data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to data observability, we have multiple approaches for implementation,
    whether manually built mechanisms, components from the Java language, third-party
    components, or finally to solutions developed particularly for Android. When it
    comes to Android, some of the most common solutions are `LiveData`, Flows from
    the Coroutines components, and RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: The first one we will look at is `LiveData`, as it is part of the Android Architecture
    Components, which means that it is tailored specially to Android. We will then
    look at how we can use other types of data streams, which we will cover in more
    depth in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: LiveData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LiveData` is a lifecycle-aware component that permits updates to your UI,
    but only if the UI is in an active state (for example, if the activity or fragment
    is in one of the `STARTED` or `RESUMED` states). To monitor changes on `LiveData`,
    you need an observer combined with a `LifecycleOwner`. When the activity is set
    to an active state, the observers will be notified when changes occur.'
  prefs: []
  type: TYPE_NORMAL
- en: If the activity is recreated, then the observer will be destroyed, and a new
    one will be reattached. Once this happens, the last value of `LiveData` will be
    emitted to allow us to restore the state. Activities and fragments are `LifecycleOwners`,
    but fragments have a separate `LifecycleOwner` for the View states. Fragments
    have this particular `LifecycleOwner` due to their behavior in the `BackStack`
    fragment.
  prefs: []
  type: TYPE_NORMAL
- en: When fragments are replaced within the back stack, they are not fully destroyed;
    only their Views are. Some of the common callbacks that developers use to trigger
    processing logic are `onViewCreated()`, `onActivityResumed()`, and `onCreateView()`.
    If we were to register observers for `LiveData` in these methods, we might end
    up with scenarios where multiple observers will be created every time our fragment
    pops back onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'When updating a `LiveData` model, we are presented with two options: `setValue()`
    and `postValue()`. `setValue()` will deliver the result immediately and is meant
    to be called only on the UI thread. On the other hand, `postValue()` can be called
    on any thread. When `postValue()` is called, `LiveData` will schedule an update
    of the value on the UI thread and update the value when the UI thread becomes
    free.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LiveData` class, these methods are protected, which means that there
    are subclasses that allow us to change the data. `MutableLiveData` makes the methods
    public, which gives us a simple solution for observing data in most cases. `MediatorLiveData`
    is a specialized implementation of `LiveData` that allows us to merge multiple
    `LiveData` objects into one (this is useful in situations where our data is kept
    in different repositories and we want to show a combined result).
  prefs: []
  type: TYPE_NORMAL
- en: '`TransformLiveData` is another specialized implementation that allows us to
    convert one object into another (this helps us in situations where we grab data
    from one repository and we want to request data from another repository that depends
    on the previous data, as well as in situations where we want to apply extra logic
    to a result from a repository).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Custom LiveData` allows us to create our own `LiveData` implementations (usually
    when we periodically receive updates, such as the odds in a sports betting app,
    stock market updates, and Facebook and Twitter feeds).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to use `LiveData` in `ViewModel`. Holding `LiveData`
    in a fragment or activity will cause losses in data when configuration changes
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how `LiveData` is connected to the lifecycle of
    `LifecycleOwner`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.4 – The relationship between LiveData and lifecycle observers with\
    \ LifecycleOwner\uFEFF](img/B19411_11_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The relationship between LiveData and lifecycle observers with
    LifecycleOwner
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can register multiple observers for `LiveData`, and each observer can be
    registered for a different `LifecycleOwner`. In this situation, `LiveData` will
    become inactive, but only when all the observers are inactive.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how the `LiveData` component works and the benefits
    it provides for observing data from activities and fragments with regard to their
    lifecycles. In the following section, we will look at an exercise that uses `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.02 – observing with LiveData
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modify *Exercise 11.01 – shared ViewModel* so that when the button is clicked,
    both fragments will be updated with the total number of clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LiveData` library to the `app/build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TotalsViewModel` should be modified so that it supports `LiveData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we created `MutableLiveData`, a subclass of `LiveData` that allows us
    to change the value of the data. When `ViewModel` is created, we set the default
    value of `0`, and then when we increase the total, we post the previous value
    plus `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we have duplicated representations for the total is that we wanted
    to keep the mutable component private to the class while exposing the non-mutable
    total to be observed by other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to modify our fragments so that they adjust to the new `ViewModel`.
    For `SplitFragmentOne`, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `SplitFragmentTwo`, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we look at the following line: `totalsViewModel.getTotal().observe(view`
    **LifecycleOwner, { updateText(it)})**, the `LifecycleOwner` parameter for the
    `observe` method is called `viewLifecycleOwner`. This is inherited from the `fragment`
    class, and it helps when we observe data while the View that the fragment manages
    is being rendered. In our example, swapping `viewLifecycleOwner` with `this` would
    not have caused an impact.'
  prefs: []
  type: TYPE_NORMAL
- en: But if our fragment had been part of a back stack feature, then there would
    have been the risk of creating multiple observers, which would have led to being
    notified multiple times for the same dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write a test for our new `ViewModel`. We will name it `TotalsViewModelTest`
    and place it in the `test` package, not `androidTest`. This is because we want
    this test to execute on our workstation, not the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding test, before testing begins, we assert that the initial value
    of `LiveData` is set to `0`. Then, we write a small test in which we increase
    the total five times, and we assert that the final value is `5`. Let’s run the
    test and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A message similar to the preceding one will appear. This is because of how
    `LiveData` is implemented. Internally, it uses Handlers and Loopers, part of the
    Android framework, thus preventing us from executing the test. Luckily, there
    is a way around this. We will need the following configuration in our Gradle file
    for our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This adds a testing library to our testing code, not our application code.
    Now, let’s add the following line to our code above the instantiation of the `ViewModel`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added a `TestRule` that says every time `LiveData` has its value changed,
    it will make the change instantly and will avoid using the Android Framework components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every test we write in this class will be impacted by this rule, thus giving
    us the freedom to play with the `LiveData` class for each new test method. If
    we run the test again, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this mean that our new rule didn’t work? Not exactly. If you look in your
    `TotalsViewModels` class, you’ll see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means that because we created the `ViewModel` class outside of the rule’s
    scope, the rule will not apply. We can do two things to avoid this scenario: we
    can change our code to handle a null value that will be sent when we first subscribe
    to the `LiveData` class, or we can adjust our test so that we put the `ViewModel`
    class in the scope of the rule. Let’s go with the second approach and change how
    we create our `ViewModel` class in the test. It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run the test again and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'See whether you can spot where the error in the test is, fix it, and then rerun
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.5 – Output of \uFEFFExercise 11.02](img/B19411_11_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Output of Exercise 11.02
  prefs: []
  type: TYPE_NORMAL
- en: 'The same output in landscape mode will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.6 – Output of \uFEFFExercise 11.02 in landscape mode](img/B19411_11_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Output of Exercise 11.02 in landscape mode
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the preceding example, we can see how using a combination of
    the `LiveData` and `ViewModel` approaches helped us solve our problem while considering
    the particularities of the Android operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel`: This helped us hold the data across device orientation changes,
    and it solved the issue of communicating between fragments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveData`: This helped us retrieve the most up-to-date information that we’ve
    processed while considering the fragment’s lifecycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of the two helped us efficiently delegate our processing logic,
    allowing us to unit test this processing logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional data streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One type of data stream that has gained popularity recently is the usage of
    Coroutines and Flows, mainly for their approach to asynchronous operations in
    Android. An example of Flows emitting data in a `ViewModel` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have the two total declarations for public and
    private usage. Instead of `LiveData`, we use `StateFlow`, which will emit the
    current value and all subsequent new values when we subscribe to it. Because it
    emits the last value, we must always set an initial value when we initialize it.
    If we want to subscribe to changes in the total value, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will subscribe to `StateFlow` every time `viewLifecycleOwner`
    enters the `CREATED` stage. This will connect `StateFlow` with the lifecycle of
    `Fragment` to prevent any possible leaks. We will explore the mechanics of Flows
    and Coroutines in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a data stream is the RxJava library, which represents another
    mechanism for emitting data. The library is best used for performing asynchronous
    work and transformations, and because it’s based on Java and not the Android operating
    system, it lacks any lifecycle awareness. For example, using RxJava in combination
    with ViewModels would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using `BehaviorSubject` to replace `StateFlow`. `BehaviorSubject`
    has the same properties as state flow. It will keep the latest value and emit
    it when a component subscribes and all the new values after the subscription.
    Subscribing to the object looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using Disposable to hold the subscription in `onViewCreated`. In
    `onDestroyView`, we are disposing of the subscription to prevent any context leaks.
    This is an alternative to using lifecycle-aware components such as `LiveData`
    and `StateFlow`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at other types of streams of data that might be present
    in Android applications such as Kotlin Flows and RxJava, and analyzed their particularities.
    In the section that follows, we will look at how we can persist data using the
    Room library.
  prefs: []
  type: TYPE_NORMAL
- en: Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Room persistence library acts as a wrapper between your application code
    and the SQLite storage. You can think of SQLite as a database that runs without
    its own server and saves all the application data in an internal file that’s only
    accessible to your application (if the device is not rooted).
  prefs: []
  type: TYPE_NORMAL
- en: 'Room sits between the application code and the SQLite Android Framework, and
    handles the necessary **create**, **read**, **update**, and **delete** (**CRUD**)
    operations while exposing an abstraction that your application can use to define
    the data and how you want the data to be handled. This abstraction comes in the
    form of the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities**: You can specify how you want your data to be stored and the relationships
    between your data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access object** (**DAO**): The operations that can be done on your data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: You can specify the configurations that your database should
    have (the name of the database and migration scenarios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The relationship between your application and the Room components](img/B19411_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The relationship between your application and the Room components
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see how the Room components interact with each
    other. It’s easier to visualize this with an example. Let’s assume you want to
    make a messaging app and store each message in your local storage. In this case,
    `Entity` would be a `Message` object, which will have an ID and will contain the
    contents of the message, the sender, the time, status, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access messages from the local storage, you will need `MessageDao`,
    which will contain methods such as `insertMessage()`, `getMessagesFromUser()`,
    `deleteMessage()`, and `updateMessage()`. In addition, since it’s a messaging
    application, you will need a `Contact` entity to hold information about the senders
    and receivers of a message.
  prefs: []
  type: TYPE_NORMAL
- en: The `Contact` entity will contain information such as a name, last time online,
    phone number, email, and so on. In order to access the contact information, you
    will need a `ContactDao` interface, which will contain `createUser()`, `updateUser()`,
    `deleteUser()`, and `getAllUsers()`. Both entities will create a matching table
    in SQLite, which contains the fields we defined inside the entity classes as columns.
    In order to achieve this, we’ll have to create `MessagingDatabase` in which we
    will reference both entities.
  prefs: []
  type: TYPE_NORMAL
- en: In a world without Room or similar DAO libraries, we would need to use the Android
    Framework’s SQLite components. This typically involves code when setting up our
    database, such as a query to create a table and applying similar queries for every
    table we would have. Every time we queried a table for data, we would need to
    convert the resulting object into a Java or Kotlin one.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Room does not allow any operations on the UI thread to enforce the
    Android standards related to input-output operations. To make asynchronous calls
    to access data, Room is compatible with a number of libraries and frameworks,
    such as Kotlin coroutines, RxJava, and `LiveData`, on top of its default definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have an overview of how Room works and its main components. We
    will now look over each of these components and how we can use them for data persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Entities serve two purposes: to define the structure of tables and to hold
    the data from a table row. Let’s use our scenario of the messaging app and define
    two entities: one for the user and one for the message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` entity will contain information about who sent the messages, while
    the `Message` entity will contain information about the contents of a message,
    the time it was sent, and a reference to the sender of the message. The following
    code snippet provides an example of how entities are defined with Room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, entities are just *data classes* with annotations, which will
    tell Room how the tables should be built in SQLite. The annotations we used are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` annotation defines the table. By default, the table name will
    be the name of the class. We can change the name of the table through the `tableName`
    method in the `Entity` annotation. This is useful in situations where we want
    our code obfuscated but wish to keep the consistency of the SQLite structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ColumnInfo` defines configurations for a certain column. The most common
    one is the name of the column. We can also specify a default value, the SQLite
    type of the field, and whether the field should be indexed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PrimaryKey` indicates what in our entity will make it unique. Every entity
    should have at least one primary key. If your primary key is an integer or a long,
    then we can add the `autogenerate` field. This means that every entity that gets
    inserted into the `Primary Key` field is automatically generated by SQLite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, this is done by incrementing the previous ID. If you wish to define
    multiple fields as primary keys, then you can adjust the `@Entity` annotation
    to accommodate this, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let’s assume that our messaging application wants to send locations. Locations
    have a latitude, longitude, and name. We can add them to the `Message` class,
    but that would increase the complexity of the class. What we can do is create
    another entity and reference the ID in our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this approach is that we would then query the `Location` entity
    every time we queried the `Message` entity. Room has a third approach through
    the `@Embedded` annotation. Now, let’s look at the updated `Message` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code adds three columns (`lat`, `long`, and `location_name`) to the messages
    table. This allows us to avoid having objects with a large number of fields while
    keeping the consistency of our tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our entities, we’ll see that they exist independently. The `Message`
    entity has a `userId` field, but nothing is preventing us from adding messages
    from invalid users. This may lead to situations where we collect data without
    any purpose. If we want to delete a particular user, along with their messages,
    we must do so manually. Room provides us with a way to define this relationship
    using a `ForeignKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added the `foreignKeys` field and created a new
    `ForeignKey` to the `User` entity, while for the parent column, we defined the
    `user_id` field in the `User` class, and for the child column, the `user` field
    in the `Message` class.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we add a message to the table, there needs to be a `User` entry in
    the `users` table. If we try to delete a user and any messages from that user
    still exist, then, by default, this will not work because of the dependencies.
    However, we can tell Room to do a cascade delete, which will erase the user and
    the associated messages.
  prefs: []
  type: TYPE_NORMAL
- en: DAO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If entities specify how we define and hold our data, then DAOs specify what
    to do with that data. A DAO class is a place where we define our CRUD operations.
    Ideally, each entity should have a corresponding DAO, but there are situations
    where crossovers occur (usually, this happens when we have to deal with JOINs
    between two tables).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our previous example, let’s build some corresponding DAOs for
    our entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our messages, we have defined the following functions: insert
    one or more messages, update one or more messages, delete one or more messages,
    and retrieve all the messages from a certain user that are older than a particular
    time. For our users, we can insert one user, update one user, delete one user,
    and retrieve all the users.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our `Insert` methods, you’ll see we have defined that in the
    case of a conflict (when we try to insert something with an ID that already exists),
    it will replace the existing entry. The `Update` field has a similar configuration,
    but in our case, we have chosen the default. This means that nothing will happen
    if the update cannot occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Query` annotation stands out from all the others. This is where we use
    SQLite code to define how our read operations work. `SELECT *` means we want to
    read all the data for every row in the table, which will populate all our entities’
    fields. The `WHERE` clause indicates a restriction that we want to apply to our
    query. We can also define a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to filter messages from multiple users. We can define a new
    class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to extract information from certain columns at a time, not
    the entire row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that you want to add the user information of the sender to every
    message. Here, we’ll need to use a similar approach to the one we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the new data class, we can define this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We now have the user information for every message we want to display. This
    will come in handy in scenarios such as group chats, where we should display the
    name of the sender of every message.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have learned about so far is a bunch of DAOs and entities. Now, it’s
    time to put them together. First, let’s define our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the `@Database` annotation, we specify what entities go in our database and
    our version. Then, for every DAO, we define an abstract method in `RoomDatabase`.
    This allows the build system to build a subclass of our class in which it provides
    the implementations for these methods. The build system will also create the tables
    related to our entities.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDatabase` method in the companion object illustrates how we create an
    instance of the `ChatDatabase` class. Ideally, there should be one instance of
    the database for our application due to the complexity involved in building a
    new database object. However, this can be better achieved through a dependency
    injection framework.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume you’ve released your chat application. Your database is currently
    version one, but your users are complaining that the message status feature is
    missing. You decide to add this feature in the next release. This involves changing
    the database structure, which can impact databases that have already built their
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Room offers something called a migration. In the migration, we can
    define how our database changed between versions 1 and 2\. So, let’s look at our
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we added the status flag to the `Message` entity. Now, let’s look at
    `ChatDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In our database, we’ve increased the version to `2` and added a migration between
    versions `1` and `2`. Here, we added the `status` column to the table. We’ll add
    this migration when we build the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve released the new code, when the updated app is opened and the code
    to build the database is executed, it will compare the version of the stored data
    with the one specified in our class and notice a difference. Then, it will execute
    the specified migrations until it reaches the latest version. This allows us to
    maintain an application for years without impacting the user’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our `Message` class, you may have noticed that we defined the
    time as `Long`. In Java and Kotlin, we have the `Date` object, which may be more
    useful than the timestamp of the message. Luckily, Room has a solution for this
    in the form of `TypeConverter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows what data types we can use in our code and the SQLite
    equivalent. Complex data types need to be brought down to these levels using TypeConverters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite
    data types](img/B19411_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite
    data types
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ve modified the `lastOnline` field so that it’s of the `Date` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve defined a couple of methods that convert a `Date` object into `Long`
    and vice versa. The `@TypeConverter` annotation helps Room identify where the
    conversion takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll add our converter to Room using the `@``TypeConverters` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at some third-party frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Room works well with third-party frameworks such as `LiveData`, RxJava, and
    coroutines. This solves two issues: multi-threading and observing data changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveData` will make the `@Query` annotated methods in your DAOs reactive,
    which means that if new data is added, `LiveData` will notify the observers of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin coroutines complement `LiveData` by making the `@Insert`, `@Delete`,
    and `@Update` methods asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`@Query` methods reactive through components such as `Publisher`, `Observable`,
    or `Flowable` and making the rest of the methods asynchronous through `Completable`,
    `Single`, or `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**Executors and threads** come with the Java framework and can be a useful
    solution for solving threading issues with Room if none of the aforementioned
    third-party integrations are part of your project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your DAO classes will not suffer from any modifications; however, you will
    need the components that access your DAOs to adjust and use either an executor
    or a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of accessing the DAO is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will create a new thread and start it every time we want
    to retrieve the list of users. There are two major issues with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation is an expensive operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is hard to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to the first is to use `ThreadPools` and `Executors`. The Java
    framework offers a robust set of options when it comes to `ThreadPools`. A thread
    pool is a component responsible for thread creation and destruction and allows
    the developer to specify the number of threads in the pool. Multiple threads in
    a thread pool will ensure multiple tasks can be executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an executor that will use a pool of one
    thread. When we want to access the list of users, we move the query inside the
    executor, and when the data is loaded, our callback lambda will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.03 – making a little room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been hired by a news agency to build a news application. The application
    will display a list of articles written by journalists. An article can be written
    by one or more journalists, and each journalist can write one or more articles.
    The data information for each article includes the article’s title, content, and
    date.
  prefs: []
  type: TYPE_NORMAL
- en: The journalist’s information includes their first name, last name, and job title.
    You will need to build a Room database that holds this information so it can be
    tested. Before we start, let’s look at the relationship between the entities.
    In the chat application example, we defined the rule that one user can send one
    or multiple messages.
  prefs: []
  type: TYPE_NORMAL
- en: This relationship is known as a one-to-many relationship. That relationship
    is implemented as a reference between one entity to another (the user was defined
    in the message table in order to be connected to the sender).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have a many-to-many relationship. To implement a many-to-many
    relationship, we need to create an entity that holds references that will link
    the other two entities. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Project with No Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by adding the annotation processing plugin to `app/build.gradle`.
    This will read the annotations used by Room and generate the code necessary for
    interacting with the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add the Room libraries in `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line defines the library version, the second line brings in the Room
    library for Java and Kotlin, and the last line is for the Kotlin annotation processor.
    This allows the build system to generate boilerplate code from the Room annotations.
    After these changes to your Gradle files, you should get a prompt to sync your
    project, which you should click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define our entities in the `main/java` folder and the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the entity that connects the journalist to the article and the
    appropriate constraints in the `main/java` folder and the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we defined our connecting entity. As you can see, we
    haven’t defined an ID for uniqueness, but both the article and the journalist
    will be unique when used together. We also defined foreign keys for each of the
    other entities referred to by our entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ArticleDao` DAO in the `main/java` folder and the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the `JournalistDao` data access object in the `main/java` folder
    and the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `JoinedArticleJournalistDao` DAO in the `main/java` folder and the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s analyze our code a little bit. For the articles and journalists, we can
    add, insert, delete, and update queries. For articles, we can extract all of the
    articles but also extract articles from a certain author.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the option to extract all the journalists that wrote an article.
    This is done through a JOIN with our intermediary entity. For that entity, we
    define the options to insert (which will link an article to a journalist) and
    delete (which will remove that link).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s define our `Database` class in the `main/java` folder and the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We avoided defining the `getInstance` method here because we won’t be calling
    the database anywhere. But if we don’t do that, how will we know whether it works?
    The answer to this is that we’ll test it. This won’t be a test that will run on
    your machine but one that will run on the device. This means that we will create
    it in the `androidTest` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by setting up the test data. Here, we will add some articles and
    journalists to the database then test retrieving, updating, and deleting the entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/6H8X2](https://packt.link/6H8X2).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have defined a few examples of how to test a Room database. What’s
    interesting is how we build the database. Our database is an in-memory database.
    This means that all the data will be kept as long as the test is run and discarded
    afterward.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to start with a clean slate for each new state and avoids the
    consequences of each of our testing sessions affecting each other. In our test,
    we’ve set up 5 articles and 10 journalists. The first article was written by the
    top two journalists, while the second article was written by the first journalist.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the articles have no authors. By doing this, we can test our update
    and delete methods. For the delete method, we can test our foreign key relationship
    as well. In the test, we can see that if we delete article `1`, it will delete
    the relationship between the article and the journalists that wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: When testing your database, you should add the scenarios that your app will
    use. Feel free to add other testing scenarios and improve the preceding tests
    in your own database. Note that if you are using the `androidTest` folder, then
    this will be an instrumented test, meaning that you will need an emulator or a
    device to test.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 11.01 – a shopping notes app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want to keep track of your shopping items, so you decide to build an app
    to save the items you wish to buy during your next trip to the store. The requirements
    for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI will be split into two: top/bottom in portrait mode and left/right in
    landscape mode. The UI will look similar to what is shown in the following screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first half will display the number of notes, a text field, and a button.
    Every time the button is pressed, a note will be added with the text placed in
    the text field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second half will display the list of notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each half, you will have a View model that will hold the relevant data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should define a repository that will be used on top of the Room database
    to access your data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should also define a Room database that will hold your notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The note entity will have the following attributes: `id` and `text`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Example of a possible output for activity 11.01](img/B19411_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Example of a possible output for activity 11.01
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with Room integration by creating the `Entity`, `Dao`, and `Database`
    methods. For `Dao`, the `@Query` annotated methods can directly return a `LiveData`
    object so that the observers can be directly notified if the data changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a template of our repository in the form of an interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the repository. The repository will have one reference to the `Dao`
    object we defined previously. The code for inserting the data must be moved to
    a separate thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `NotesApplication` class to provide one instance of the repository
    that will be used across the application. Make sure to update the `<application>`
    tag in the `AndroidManifest.xml` file to add your new application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unit-test the repository and define `ViewModels`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `NoteListViewModel` and the associated test. This will have a reference
    to the repository and return the list of notes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `CountNotesViewModel` and the associated test. `CountViewModel` will
    have a reference to the repository and return the total number of notes as `LiveData`.
    It will also be responsible for inserting new notes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `CountNotesFragment` and the associated `fragment_count_notes.xml` layout.
    In the layout, define a `TextView`, which will display the total number, an `EditText`
    for the name of the new notes, and a button, which will insert the note that was
    introduced in `EditText`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an adapter for the list of notes called `NoteListAdapter` and an associated
    layout file for the rows called `view_note_item.xml`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the associated layout file, called `fragment_note_list.xml`, which will
    contain `RecyclerView`. The layout will be used by `NoteListFragment`, which will
    connect `NoteListAdapter` to `RecyclerView`. It will also observe the data from
    `NoteListViewModel` and update the adapter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `NotesActivity` with an associated layout for landscape mode and portrait
    mode.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have all the necessary data in `strings.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/ZhnDx](https://packt.link/ZhnDx).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the building blocks required to build a maintainable
    application. We also looked into one of the most common issues that developers
    come across when using the Android Framework, which is maintaining the states
    of objects during lifecycle changes.
  prefs: []
  type: TYPE_NORMAL
- en: We started by analyzing `ViewModels` and how they solve the issue of holding
    data during orientation changes. We added `LiveData` to `ViewModels` to show how
    the two complement each other and looked at how we can use other data streams
    with `ViewModels` and compare those with `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to Room to show how we can persist data with minimal effort
    and without much SQLite boilerplate code. We also explored one-to-many and many-to-many
    relationships, as well as how to migrate data and break down complex objects into
    primitives for storage.
  prefs: []
  type: TYPE_NORMAL
- en: The activity we completed in this chapter serves as an example of what direction
    Android apps are heading in. However, this was not a complete example due to the
    numerous frameworks and libraries that you will discover, which give developers
    the flexibility to go in different directions.
  prefs: []
  type: TYPE_NORMAL
- en: The information you’ve learned in this chapter will serve you well for the next
    one, which will expand on the concept of repositories. This will allow you to
    save data that’s been obtained from a server into a Room database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of persisting data will also be expanded as you will explore other
    ways to persist data, such as through `SharedPreferences`, `DataStore`, and files.
    Our focus will be on certain types of files: media files obtained from the camera
    of the device.'
  prefs: []
  type: TYPE_NORMAL
