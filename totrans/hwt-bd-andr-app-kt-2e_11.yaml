- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Android Architecture Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 架构组件
- en: In this chapter, you will learn about the key components of the Android Jetpack
    libraries and what benefits they bring to the standard Android framework. You
    will also learn how to structure your code and give different responsibilities
    to your classes with the help of Jetpack components. Finally, you’ll improve the
    test coverage of your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Android Jetpack 库的关键组件以及它们为标准 Android 框架带来的好处。你还将学习如何借助 Jetpack 组件来组织你的代码，并为你的类分配不同的职责。最后，你将提高你代码的测试覆盖率。
- en: By the end of this chapter, you’ll be able to create applications that handle
    the lifecycles of activities and fragments with ease. You’ll also know more about
    how to persist data on an Android device using Room and how to use ViewModels
    to separate your logic from your Views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够轻松地创建处理活动和片段生命周期的应用程序。你还将了解更多关于如何在 Android 设备上使用 Room 持久化数据以及如何使用
    ViewModels 将你的逻辑与视图分离。
- en: 'In the previous chapters, you learned how to write unit tests. The question
    is: what can you unit-test? Can you unit-test activities and fragments? It is
    hard to unit-test activities and fragments on your machine because of the way
    they are built. Testing would be easier if you could move the code away from activities
    and fragments.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何编写单元测试。问题是：你可以对什么进行单元测试？你能否对活动和片段进行单元测试？由于它们构建的方式，在你的机器上对活动和片段进行单元测试是困难的。如果你能将代码从活动和片段中移除，测试将会更容易。
- en: Also, consider the situation where you are building an application that supports
    different orientations, such as landscape and portrait, and supports multiple
    languages. What tends to happen in these scenarios by default is that when the
    user rotates the screen, the activities and fragments are recreated for the new
    display orientation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑一下你正在构建一个支持不同方向（如横屏和竖屏）和多种语言的应用程序的情况。在这些场景中，默认情况下，当用户旋转屏幕时，活动和片段会为新的显示方向重新创建。
- en: Now, imagine that happens while your application is in the middle of processing
    data. You have to keep track of the data you are processing, keep track of what
    the user was doing to interact with your screens, and avoid causing a context
    leak.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设这种情况发生在你的应用程序正在处理数据的过程中。你必须跟踪你正在处理的数据，跟踪用户如何与你的屏幕进行交互，并避免造成上下文泄露。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A **context leak** occurs when your destroyed activity cannot be garbage-collected
    because it is referenced in a component with a longer lifecycle – such as a thread
    that is currently processing your data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的已销毁活动因为被具有更长生命周期的组件（例如当前正在处理你的数据的线程）引用而无法被垃圾回收时，就会发生**上下文泄露**。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: ViewModel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModel
- en: Data streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流
- en: Room
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Room
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/89BCi](https://packt.link/89BCi)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在 GitHub 上找到，链接为 [https://packt.link/89BCi](https://packt.link/89BCi)
- en: Android components background
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 组件背景
- en: In many situations, you have to use `onSaveInstanceState` to save the current
    state of your activity/fragment, and then in `onCreate` or `onRestoreInstanceState`,
    you need to restore the state of your activity/fragment. This adds extra complexity
    to your code and makes it repetitive, especially if the processing code is part
    of your activity or fragment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你必须使用 `onSaveInstanceState` 来保存你的活动/片段的当前状态，然后在 `onCreate` 或 `onRestoreInstanceState`
    中恢复你的活动/片段的状态。这增加了你代码的复杂性，并使其变得重复，尤其是如果处理代码是活动或片段的一部分。
- en: These scenarios are where `ViewModel` and `LiveData` come in. `ViewModels` are
    components built with the express goal of holding data in case of lifecycle changes.
    They also separate the logic from the Views, which makes them very easy to unit-test.
    `LiveData` is a component used to hold data and notify observers when changes
    occur while taking their lifecycle into account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景正是 `ViewModel` 和 `LiveData` 发挥作用的地方。`ViewModels` 是为了在生命周期变化时持有数据而构建的组件。它们还从视图中分离逻辑，这使得它们非常容易进行单元测试。`LiveData`
    是一个用于持有数据并在变化发生时考虑到其生命周期的组件。
- en: In simpler terms, the fragment only deals with the Views, `ViewModel` does the
    heavy lifting, and `LiveData` deals with delivering the results to the fragment,
    but only when the fragment is there and ready.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的话来说，片段只处理视图，`ViewModel` 执行繁重的工作，而 `LiveData` 负责将结果传递给片段，但仅当片段存在且准备就绪时。
- en: If you’ve ever used WhatsApp or a similar messaging app and you’ve turned off
    the internet, you’ll have noticed that you are still able to use the application.
    The reason for this is that the messages are stored locally on your device. This
    is achieved with a database file called `SQLite` in most cases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 WhatsApp 或类似的即时通讯应用，并且你已经关闭了互联网，你会注意到你仍然可以使用该应用。这是因为消息通常存储在你的设备上的本地数据库文件
    `SQLite` 中。
- en: The Android Framework already allows you to use this feature for your application.
    However, this requires a lot of boilerplate code to read and write data. Every
    time you want to interact with the local storage, you must write a SQL query.
    When you read the SQLite data, you must convert it into a Java/Kotlin object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android 框架已经允许你为你的应用程序使用这个功能。然而，这需要大量的样板代码来读取和写入数据。每次你想与本地存储交互时，你必须编写一个 SQL
    查询。当你读取 SQLite 数据时，你必须将其转换为 Java/Kotlin 对象。
- en: All of this requires a lot of code, time, and unit testing. What if someone
    else were to handle the SQLite connection, and all you had to do was focus on
    the code part? This is where **Room** comes in. This is a library that is a wrapper
    over SQLite. All you need to do is define how your data should be saved and let
    the library take care of the rest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都需要大量的代码、时间和单元测试。如果有人处理 SQLite 连接，而你只需专注于代码部分会怎样？这就是 **Room** 发挥作用的地方。这是一个在
    SQLite 上包装的库。你所需要做的就是定义你的数据应该如何保存，然后让库处理其余部分。
- en: Let’s say you want your activity to know when there is an internet connection
    and when the internet drops. You can use something called `BroadcastReceiver`
    for this. A slight problem with this is that every time you register `BroadcastReceiver`
    in an activity, you must unregister it when the activity is destroyed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要你的活动知道何时有互联网连接，何时互联网断开。你可以使用 `BroadcastReceiver` 来实现这一点。这个问题的一个小问题是，每次你在活动中注册
    `BroadcastReceiver` 时，你必须在其被销毁时注销它。
- en: You can use `Lifecycle` to observe the state of your activity, thereby allowing
    your receiver to be registered in the desired state and unregistered in the complementary
    one (for example, `RESUMED-PAUSED`, `STARTED-STOPPED`, or `CREATED-DESTROYED`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Lifecycle` 来观察你活动的状态，从而允许你的接收器在所需状态下注册，并在互补状态下注销（例如，`RESUMED-PAUSED`、`STARTED-STOPPED`
    或 `CREATED-DESTROYED`）。
- en: '`ViewModels`, `LiveData`, and `Room` are all part of the Android architecture
    components, which are part of the Android Jetpack libraries. The architecture
    components are designed to help developers structure their code, write testable
    components, and help reduce boilerplate code.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModels`、`LiveData` 和 `Room` 都是 Android 架构组件的一部分，它们是 Android Jetpack 库的一部分。架构组件旨在帮助开发者构建代码结构，编写可测试的组件，并帮助减少样板代码。'
- en: Other architecture components include `Databinding` (which binds views with
    models or `ViewModels`, allowing the data to be directly set in the Views), `WorkManager`
    (which allows developers to handle background work with ease), `Navigation` (which
    allows developers to create visual navigation graphs and specify relationships
    between activities and fragments), and `Paging` (which allows developers to load
    paginated data, which helps in situations where infinite scrolling is required).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他架构组件包括 `Databinding`（它将视图与模型或 `ViewModels` 绑定，允许直接在视图中设置数据），`WorkManager`（它允许开发者轻松处理后台工作），`Navigation`（它允许开发者创建视觉导航图并指定活动与片段之间的关系），以及
    `Paging`（它允许开发者加载分页数据，这在需要无限滚动的情况下很有帮助）。
- en: ViewModel
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewModel
- en: The `ViewModel` component is responsible for holding and processing data required
    by the **user interface** (**UI**). It has the benefit of surviving configuration
    changes that destroy and recreate fragments and activities, which allows it to
    retain the data that can then be used to re-populate the UI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 组件负责保存和处理用户界面（**UI**）所需的数据。它有一个好处，即它能够在片段和活动被销毁和重新创建的配置更改中存活下来，这使得它能够保留数据，然后可以用来重新填充
    UI。'
- en: It will eventually be destroyed when the activity or fragment is destroyed without
    being recreated or when the application process is terminated. This allows `ViewModel`
    to serve its responsibility and to have garbage collected when it is no longer
    necessary. The only method `ViewModel` has is the `onCleared()` method, which
    is called when `ViewModel` terminates. You can overwrite this method to terminate
    ongoing tasks and deallocate resources that will no longer be required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动或片段被销毁而没有被重新创建，或者当应用程序进程被终止时，它最终会被销毁。这允许`ViewModel`履行其职责，并在不再需要时进行垃圾回收。`ViewModel`唯一的方法是`onCleared()`方法，当`ViewModel`终止时会被调用。你可以重写这个方法来终止正在进行的任务和释放不再需要的资源。
- en: Migrating data processing from the activities into `ViewModel` helps create
    better and faster unit tests. Testing an activity requires an Android test to
    be executed on a device. Activities also have states, which means that your test
    should get the activity into the proper state for the assertions to work. `ViewModel`
    can be unit-tested locally on your development machine and can be stateless, meaning
    that your data processing logic can be tested individually.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据处理从活动迁移到`ViewModel`有助于创建更好、更快的单元测试。测试活动需要在一个设备上执行Android测试。活动也有状态，这意味着你的测试应该将活动置于适当的状态，以便断言能够工作。`ViewModel`可以在你的开发机器上本地进行单元测试，并且可以是无状态的，这意味着你可以单独测试数据处理逻辑。
- en: One of the most important features of `ViewModel` is that it allows communication
    between fragments. To communicate between fragments without `ViewModel`, you must
    make your fragment communicate with the activity, which will then call the fragment
    you wish to communicate with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`最重要的特性之一是它允许片段之间的通信。要在没有`ViewModel`的情况下在片段之间进行通信，你必须让你的片段与活动通信，然后活动会调用你想要通信的片段。'
- en: To achieve this with `ViewModel`, you can just attach it to the parent activity
    and use the same `ViewModel` in the fragment you wish to communicate with. This
    will reduce the boilerplate code that was required previously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ViewModel`实现这一点，你只需将其附加到父活动，并在你想要通信的片段中使用相同的`ViewModel`。这将减少之前所需的样板代码。
- en: 'In the following diagram, you can see that `ViewModel` can be created at any
    point in an activity’s lifecycle (in practice, they are normally initialized in
    `onCreate` for Activities and `onCreateView` or `onViewCreated` for Fragments
    because these represent the points where the views are created and ready to be
    updated), and that once created, it will live as long as the activity does:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到`ViewModel`可以在活动生命周期的任何时刻被创建（在实践中，它们通常在`onCreate`中初始化，对于活动而言，以及`onCreateView`或`onViewCreated`对于片段而言，因为这些代表了视图被创建并准备好更新的点），一旦创建，它将和活动一样长时间存在：
- en: '![Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle](img/B19411_11_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 活动生命周期与ViewModel生命周期的比较](img/B19411_11_01.jpg)'
- en: Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 活动生命周期与ViewModel生命周期的比较
- en: In the preceding diagram, we can see how the lifecycle of `Activity` compares
    to that of `ViewModel`. The red lines indicate what happens when the `Activity`
    is recreated, starting from the `onPause` method, ending in `onDestroy,` and then
    going from `onCreate` to `onResume` in a new instance of `Activity`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到`Activity`的生命周期与`ViewModel`的生命周期是如何比较的。红色线条表示当`Activity`被重新创建时发生的情况，从`onPause`方法开始，以`onDestroy`结束，然后在新实例的`Activity`中从`onCreate`到`onResume`。
- en: 'The following diagram shows how `ViewModel` connects to a fragment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了`ViewModel`如何连接到一个片段：
- en: '![Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle](img/B19411_11_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – Fragment生命周期与ViewModel生命周期的比较](img/B19411_11_02.jpg)'
- en: Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – Fragment生命周期与ViewModel生命周期的比较
- en: In the preceding diagram, we can see how the lifecycle of `Fragment` compares
    to that of `ViewModel`. The red lines indicate what happens when `Fragment` is
    recreated, starting from the `onPause` method, ending in `onDetach`, and then
    going from `onAttach` to `onResume` in a new instance of `Fragment`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到`Fragment`的生命周期与`ViewModel`的生命周期是如何比较的。红色线条表示当`Fragment`被重新创建时发生的情况，从`onPause`方法开始，以`onDetach`结束，然后在新实例的`Fragment`中从`onAttach`到`onResume`。
- en: In this section, we learned what a ViewModel is and the benefits it provides
    with regard to testing and performing logic, which survives the recreation of
    the activity and fragment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了什么是 ViewModel 以及它提供的与测试和执行逻辑相关的优势，这些逻辑可以在活动或片段重建后继续存在。
- en: Exercise 11.01 – shared ViewModel
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01 – 共享 ViewModel
- en: You have been tasked with building an app with one screen split vertically into
    two when in portrait mode and horizontally when in landscape mode. The first half
    contains some text, and below it is a button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你被分配了一个任务，要构建一个应用，当在纵向模式时屏幕垂直分割成两部分，在横向模式时水平分割。第一部分包含一些文本，下面是一个按钮。
- en: 'The second half contains only text. When the screen is opened, the text in
    both halves displays **Total: 0**. When the button is clicked, the text will change
    to **Total: 1**. When clicked again, the text will change to **Total: 2**, and
    so on. When the device is rotated, the last total will be displayed in the new
    orientation.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '第二部分只包含文本。当屏幕打开时，两部分的文本都显示 **Total: 0**。当点击按钮时，文本将变为 **Total: 1**。再次点击，文本将变为
    **Total: 2**，依此类推。当设备旋转时，将显示最后总和的新方向。'
- en: 'To solve this task, we will define the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个任务，我们将定义以下内容：
- en: An activity that will hold two fragments – one layout for portrait and another
    for landscape
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将包含两个片段的活动 - 一个用于纵向，另一个用于横向：
- en: One fragment with one layout containing `TextView` and a button
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `TextView` 和按钮的一个布局的片段：
- en: One fragment with one layout containing `TextView`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `TextView` 的一个布局的片段：
- en: One `ViewModel` that will be shared between the two fragments
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将在两个片段之间共享的 `ViewModel`：
- en: 'Let’s begin by setting up our configurations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置我们的配置：
- en: Create a new project in Android Studio and add an empty activity called `SplitActivity`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并添加一个名为 `SplitActivity` 的空活动。
- en: 'Let’s add the `ViewModel` library to `app/build.gradle`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们将 `ViewModel` 库添加到 `app/build.gradle`:'
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following strings to `values/strings.xml`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字符串添加到 `values/strings.xml`：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create and define `SplitFragmentOne`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建并定义 `SplitFragmentOne`:'
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `fragment_split_one.xml` file to the `res/layout` folder:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `fragment_split_one.xml` 文件添加到 `res/layout` 文件夹：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s create and define `SplitFragmentTwo`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建并定义 `SplitFragmentTwo`：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the `fragment_split_two.xml` file to the `res/layout` folder:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `fragment_split_two.xml` 文件添加到 `res/layout` 文件夹：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define `SplitActivity`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '定义 `SplitActivity`:'
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `activity_split.xml` file in the `res/layout` folder:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout` 文件夹中创建 `activity_split.xml` 文件：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete code for this step can be found at [https://packt.link/HPy9p](https://packt.link/HPy9p).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在 [https://packt.link/HPy9p](https://packt.link/HPy9p) 找到。
- en: Replace `{package.path}` with the name of the package in which your Fragments
    are located.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `{package.path}` 替换为你片段所在的包名。
- en: 'Next, let’s create a `layout-land` folder in the `res` folder. Then, in the
    `layout-land` folder, we’ll create an `activity_split.xml` file with the following
    layout:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `res` 文件夹中创建一个 `layout-land` 文件夹。然后，在 `layout-land` 文件夹中，我们将创建一个具有以下布局的
    `activity_split.xml` 文件：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete code for this step can be found at [https://packt.link/1zRQa](https://packt.link/1zRQa).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在 [https://packt.link/1zRQa](https://packt.link/1zRQa) 找到。
- en: Replace `{package.path}` with the name of the package in which your Fragments
    are located. Notice the same `android:id` attribute in both the `activity_split.xml`
    files. This allows the operating system to correctly save and restore the fragment’s
    state during rotation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `{package.path}` 替换为你片段所在的包名。注意两个 `activity_split.xml` 文件中的相同 `android:id`
    属性。这允许操作系统在旋转期间正确保存和恢复片段的状态。
- en: 'In the `main/java` folder in the root package, create a `TotalsViewModel` that
    looks like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在根包的 `main/java` 文件夹中，创建一个类似于以下的 `TotalsViewModel`:'
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we extended from the `ViewModel` class, which is part of the lifecycle
    library. In the `ViewModel` class, we defined one method that increases the total
    value and returns the updated value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们扩展了 `ViewModel` 类，它是生命周期库的一部分。在 `ViewModel` 类中，我们定义了一个方法，该方法增加总值并返回更新后的值。
- en: 'Now, add the `updateText` and `prepareViewModel` methods to the `SplitFragment1`
    fragment:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `updateText` 和 `prepareViewModel` 方法添加到 `SplitFragment1` 片段中：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `prepareViewModel()` function, let’s start adding our `ViewModel`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `prepareViewModel()` 函数中，让我们开始添加我们的 `ViewModel`:'
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is how the `ViewModel` instance is accessed. `ViewModelProvider(this)`
    will bind `TotalsViewModel` to the lifecycle of the fragment. `.get(TotalsViewModel::class.java)`
    will retrieve the `TotalsViewModel` instance that we defined previously.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何访问 `ViewModel` 实例的方式。`ViewModelProvider(this)` 将 `TotalsViewModel` 绑定到片段的生命周期。`.get(TotalsViewModel::class.java)`
    将检索我们之前定义的 `TotalsViewModel` 实例。
- en: If the fragment is being created for the first time, it will produce a new instance,
    while if the fragment is recreated after a rotation, it will provide the previously
    created instance. We pass the class as an argument because a fragment or activity
    can have multiple ViewModels, and the class serves as an identifier for the type
    of `ViewModel` we want.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果片段是第一次被创建，它将产生一个新的实例，而如果片段在旋转后重新创建，它将提供之前创建的实例。我们传递类作为参数，因为片段或活动可以有多个 `ViewModel`，而这个类作为我们想要
    `ViewModel` 类型的标识符。
- en: 'Now, set the last known value on the view:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在视图中设置最后已知值：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second line will help during device rotation. It will set the last total
    that was computed. If we remove this line and rebuild, then we will see `1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将在设备旋转时有所帮助。它将设置最后计算的总数。如果我们删除这一行并重新构建，那么我们将看到 `1`。
- en: 'Update the View when the `fragment_split_one_button` button is clicked:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击 `fragment_split_one_button` 按钮时更新视图：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last few lines indicate that when a click is performed on the button, we
    tell `ViewModel` to recompute the total and set the new value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行表明，当按钮被点击时，我们告诉 `ViewModel` 重新计算总数并设置新值。
- en: 'Add the same `ViewModel` we used previously to our `SplitFragmentTwo`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们之前使用的相同 `ViewModel` 添加到 `SplitFragmentTwo`：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we run the app now, we’ll see that nothing has changed. The first fragment
    works as before, but the second fragment doesn’t get any updates. This is because
    even though we defined one `ViewModel`, we have two instances of that `ViewModel`
    for each of our fragments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们将看到没有任何变化。第一个片段仍然按预期工作，但第二个片段没有收到任何更新。这是因为尽管我们定义了一个 `ViewModel`，但我们为每个片段都有两个该
    `ViewModel` 的实例。
- en: We will need to limit the number of instances to one per fragment. We can achieve
    this by attaching our `ViewModel` to the `SplitActivity` lifecycle using a method
    called `requireActiviy`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将实例数量限制为每个片段一个。我们可以通过使用名为 `requireActivity` 的方法将我们的 `ViewModel` 附着到 `SplitActivity`
    生命周期来实现这一点。
- en: 'Let’s modify our fragments. In both fragments, we need to find and change the
    following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的片段。在两个片段中，我们需要找到并更改以下代码：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will change it to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它改为以下内容：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using ViewModels to communicate between fragments will only work when the fragments
    are placed in the same activity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ViewModel` 在片段之间进行通信仅在片段放置在同一个活动时才会工作。
- en: 'If we run the application, we should see the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们应该看到以下内容：
- en: "![Figure 11.3 – Output of \uFEFFExercise 11.01](img/B19411_11_03.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 练习 11.01 的输出](img/B19411_11_03.jpg)'
- en: Figure 11.3 – Output of Exercise 11.01
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 练习 11.01 的输出
- en: When the button is clicked, the total updates are on the top half of the screen
    but not on the bottom half. If we rotate the screen, the last value `ViewModel`
    had will be set on the second screen as well. This means that our application
    doesn’t react properly to the changes in `ViewModel`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，总更新显示在屏幕的上半部分，但不在下半部分。如果我们旋转屏幕，`ViewModel` 最后的值也会设置在第二个屏幕上。这意味着我们的应用程序没有正确地响应
    `ViewModel` 的变化。
- en: This means that we will need a publisher-subscriber approach to monitor changes
    that occur in our data. In the next section, we will look at some common data
    streams that ViewModels can use to notify when the data is changed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一个发布者-订阅者方法来监控我们数据中发生的变化。在下一节中，我们将查看一些 `ViewModel` 可以用来通知数据变化的常见数据流。
- en: In this exercise, we implemented a ViewModel, which was responsible for incrementing
    an integer value that will be displayed on the screen. In the section that follows,
    we will connect data streams to react to changes when the number is incremented.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们实现了一个 `ViewModel`，它负责增加一个将在屏幕上显示的整数值。在接下来的部分，我们将连接数据流以在数值增加时做出反应。
- en: Data streams
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: When it comes to data observability, we have multiple approaches for implementation,
    whether manually built mechanisms, components from the Java language, third-party
    components, or finally to solutions developed particularly for Android. When it
    comes to Android, some of the most common solutions are `LiveData`, Flows from
    the Coroutines components, and RxJava.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据可观察性方面，我们有多种实现方法，无论是手动构建的机制、Java 语言的组件、第三方组件，还是最终为 Android 开发的特定解决方案。在 Android
    方面，一些最常用的解决方案是 `LiveData`、协程组件中的 Flows 以及 RxJava。
- en: The first one we will look at is `LiveData`, as it is part of the Android Architecture
    Components, which means that it is tailored specially to Android. We will then
    look at how we can use other types of data streams, which we will cover in more
    depth in future chapters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨的是 `LiveData`，因为它属于 Android 架构组件的一部分，这意味着它是专门针对 Android 定制的。然后我们将探讨如何使用其他类型的数据流，这些内容将在未来的章节中更深入地介绍。
- en: LiveData
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LiveData
- en: '`LiveData` is a lifecycle-aware component that permits updates to your UI,
    but only if the UI is in an active state (for example, if the activity or fragment
    is in one of the `STARTED` or `RESUMED` states). To monitor changes on `LiveData`,
    you need an observer combined with a `LifecycleOwner`. When the activity is set
    to an active state, the observers will be notified when changes occur.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData` 是一个生命周期感知组件，允许更新您的 UI，但仅当 UI 处于活动状态时（例如，如果活动或片段处于 `STARTED` 或 `RESUMED`
    状态之一）。要监控 `LiveData` 的变化，您需要一个与 `LifecycleOwner` 结合的观察者。当活动设置为活动状态时，当发生变化时，观察者将被通知。'
- en: If the activity is recreated, then the observer will be destroyed, and a new
    one will be reattached. Once this happens, the last value of `LiveData` will be
    emitted to allow us to restore the state. Activities and fragments are `LifecycleOwners`,
    but fragments have a separate `LifecycleOwner` for the View states. Fragments
    have this particular `LifecycleOwner` due to their behavior in the `BackStack`
    fragment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果活动被重新创建，那么观察者将被销毁，并将重新附加一个新的观察者。一旦发生这种情况，`LiveData` 的最后一个值将被发出，以便我们可以恢复状态。活动和片段是
    `LifecycleOwner`，但片段有一个单独的 `LifecycleOwner` 用于视图状态。片段由于在 `BackStack` 中的行为而具有这个特定的
    `LifecycleOwner`。
- en: When fragments are replaced within the back stack, they are not fully destroyed;
    only their Views are. Some of the common callbacks that developers use to trigger
    processing logic are `onViewCreated()`, `onActivityResumed()`, and `onCreateView()`.
    If we were to register observers for `LiveData` in these methods, we might end
    up with scenarios where multiple observers will be created every time our fragment
    pops back onto the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当在回退栈中替换片段时，它们不会被完全销毁；只有它们的视图会被销毁。开发者常用的触发处理逻辑的一些常见回调包括 `onViewCreated()`、`onActivityResumed()`
    和 `onCreateView()`。如果我们在这类方法中注册 `LiveData` 的观察者，我们可能会遇到每次我们的片段返回屏幕时都会创建多个观察者的情况。
- en: 'When updating a `LiveData` model, we are presented with two options: `setValue()`
    and `postValue()`. `setValue()` will deliver the result immediately and is meant
    to be called only on the UI thread. On the other hand, `postValue()` can be called
    on any thread. When `postValue()` is called, `LiveData` will schedule an update
    of the value on the UI thread and update the value when the UI thread becomes
    free.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新 `LiveData` 模型时，我们面临两种选择：`setValue()` 和 `postValue()`。`setValue()` 会立即传递结果，并且只应在
    UI 线程上调用。另一方面，`postValue()` 可以在任何线程上调用。当调用 `postValue()` 时，`LiveData` 将在 UI 线程空闲时安排更新值。
- en: In the `LiveData` class, these methods are protected, which means that there
    are subclasses that allow us to change the data. `MutableLiveData` makes the methods
    public, which gives us a simple solution for observing data in most cases. `MediatorLiveData`
    is a specialized implementation of `LiveData` that allows us to merge multiple
    `LiveData` objects into one (this is useful in situations where our data is kept
    in different repositories and we want to show a combined result).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LiveData` 类中，这些方法是受保护的，这意味着存在允许我们更改数据的子类。`MutableLiveData` 使这些方法公开，这为我们提供了在大多数情况下观察数据的一个简单解决方案。`MediatorLiveData`
    是 `LiveData` 的一个特殊实现，它允许我们将多个 `LiveData` 对象合并为一个（这在我们的数据保存在不同的存储库中，我们希望显示一个组合结果的情况下非常有用）。
- en: '`TransformLiveData` is another specialized implementation that allows us to
    convert one object into another (this helps us in situations where we grab data
    from one repository and we want to request data from another repository that depends
    on the previous data, as well as in situations where we want to apply extra logic
    to a result from a repository).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`Custom LiveData` allows us to create our own `LiveData` implementations (usually
    when we periodically receive updates, such as the odds in a sports betting app,
    stock market updates, and Facebook and Twitter feeds).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to use `LiveData` in `ViewModel`. Holding `LiveData`
    in a fragment or activity will cause losses in data when configuration changes
    occur.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how `LiveData` is connected to the lifecycle of
    `LifecycleOwner`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.4 – The relationship between LiveData and lifecycle observers with\
    \ LifecycleOwner\uFEFF](img/B19411_11_04.jpg)"
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The relationship between LiveData and lifecycle observers with
    LifecycleOwner
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We can register multiple observers for `LiveData`, and each observer can be
    registered for a different `LifecycleOwner`. In this situation, `LiveData` will
    become inactive, but only when all the observers are inactive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how the `LiveData` component works and the benefits
    it provides for observing data from activities and fragments with regard to their
    lifecycles. In the following section, we will look at an exercise that uses `LiveData`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.02 – observing with LiveData
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modify *Exercise 11.01 – shared ViewModel* so that when the button is clicked,
    both fragments will be updated with the total number of clicks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LiveData` library to the `app/build.gradle` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`TotalsViewModel` should be modified so that it supports `LiveData`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we created `MutableLiveData`, a subclass of `LiveData` that allows us
    to change the value of the data. When `ViewModel` is created, we set the default
    value of `0`, and then when we increase the total, we post the previous value
    plus `1`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The reason we have duplicated representations for the total is that we wanted
    to keep the mutable component private to the class while exposing the non-mutable
    total to be observed by other objects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to modify our fragments so that they adjust to the new `ViewModel`.
    For `SplitFragmentOne`, we do the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For `SplitFragmentTwo`, we do the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we look at the following line: `totalsViewModel.getTotal().observe(view`
    **LifecycleOwner, { updateText(it)})**, the `LifecycleOwner` parameter for the
    `observe` method is called `viewLifecycleOwner`. This is inherited from the `fragment`
    class, and it helps when we observe data while the View that the fragment manages
    is being rendered. In our example, swapping `viewLifecycleOwner` with `this` would
    not have caused an impact.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: But if our fragment had been part of a back stack feature, then there would
    have been the risk of creating multiple observers, which would have led to being
    notified multiple times for the same dataset.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们的片段是回退栈功能的一部分，那么就有创建多个观察者的风险，这会导致对于相同的数据集被多次通知。
- en: 'Now, let’s write a test for our new `ViewModel`. We will name it `TotalsViewModelTest`
    and place it in the `test` package, not `androidTest`. This is because we want
    this test to execute on our workstation, not the device:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的新`ViewModel`编写一个测试。我们将命名为`TotalsViewModelTest`并将其放置在`test`包中，而不是`androidTest`。这是因为我们希望这个测试在我们的工作站上执行，而不是在设备上：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding test, before testing begins, we assert that the initial value
    of `LiveData` is set to `0`. Then, we write a small test in which we increase
    the total five times, and we assert that the final value is `5`. Let’s run the
    test and see what happens:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的测试中，在测试开始之前，我们断言`LiveData`的初始值被设置为`0`。然后，我们编写一个小测试，其中我们将总数增加五次，并断言最终值为`5`。让我们运行测试并看看会发生什么：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A message similar to the preceding one will appear. This is because of how
    `LiveData` is implemented. Internally, it uses Handlers and Loopers, part of the
    Android framework, thus preventing us from executing the test. Luckily, there
    is a way around this. We will need the following configuration in our Gradle file
    for our test:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会显示与前面类似的消息。这是因为`LiveData`的实现方式。内部，它使用Handlers和Loopers，这是Android框架的一部分，从而阻止我们执行测试。幸运的是，有一个解决办法。我们需要在我们的测试的Gradle文件中添加以下配置：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This adds a testing library to our testing code, not our application code.
    Now, let’s add the following line to our code above the instantiation of the `ViewModel`
    class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向我们的测试代码中添加一个测试库，而不是应用代码。现在，让我们在我们的代码中`ViewModel`类的实例化之上添加以下行：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have added a `TestRule` that says every time `LiveData` has its value changed,
    it will make the change instantly and will avoid using the Android Framework components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`TestRule`，它表示每次`LiveData`的值发生变化时，它将立即进行更改，并避免使用Android框架组件。
- en: 'Every test we write in this class will be impacted by this rule, thus giving
    us the freedom to play with the `LiveData` class for each new test method. If
    we run the test again, we will see the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中我们编写的每个测试都将受到这个规则的影响，从而给我们提供了在每种新的测试方法中玩转`LiveData`类的自由。如果我们再次运行测试，我们会看到以下内容：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Does this mean that our new rule didn’t work? Not exactly. If you look in your
    `TotalsViewModels` class, you’ll see this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是否意味着我们的新规则不起作用？并不完全是这样。如果你查看你的`TotalsViewModels`类，你会看到以下内容：
- en: '[PRE26]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means that because we created the `ViewModel` class outside of the rule’s
    scope, the rule will not apply. We can do two things to avoid this scenario: we
    can change our code to handle a null value that will be sent when we first subscribe
    to the `LiveData` class, or we can adjust our test so that we put the `ViewModel`
    class in the scope of the rule. Let’s go with the second approach and change how
    we create our `ViewModel` class in the test. It should look something like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着由于我们在规则的作用域之外创建了`ViewModel`类，因此规则不会适用。我们可以做两件事来避免这种情况：我们可以更改我们的代码以处理我们首次订阅`LiveData`类时发送的空值，或者我们可以调整我们的测试，以便将`ViewModel`类放在规则的作用域内。让我们选择第二种方法，并更改我们在测试中创建`ViewModel`类的方式。它应该看起来像这样：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s run the test again and see what happens:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行测试并看看会发生什么：
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'See whether you can spot where the error in the test is, fix it, and then rerun
    it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能找到测试中的错误，修复它，然后重新运行：
- en: "![Figure 11.5 – Output of \uFEFFExercise 11.02](img/B19411_11_05.jpg)"
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – Exercise 11.02的输出](img/B19411_11_05.jpg)'
- en: Figure 11.5 – Output of Exercise 11.02
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – Exercise 11.02的输出
- en: 'The same output in landscape mode will look as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 横屏模式下的相同输出将如下所示：
- en: "![Figure 11.6 – Output of \uFEFFExercise 11.02 in landscape mode](img/B19411_11_06.jpg)"
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 横屏模式下Exercise 11.02的输出](img/B19411_11_06.jpg)'
- en: Figure 11.6 – Output of Exercise 11.02 in landscape mode
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 横屏模式下Exercise 11.02的输出
- en: 'By looking at the preceding example, we can see how using a combination of
    the `LiveData` and `ViewModel` approaches helped us solve our problem while considering
    the particularities of the Android operating system:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的示例，我们可以看到使用`LiveData`和`ViewModel`方法的组合是如何帮助我们解决我们的问题，同时考虑到Android操作系统的特定性：
- en: '`ViewModel`: This helped us hold the data across device orientation changes,
    and it solved the issue of communicating between fragments'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`：这帮助我们跨设备方向变化保持数据，并解决了片段间通信的问题'
- en: '`LiveData`: This helped us retrieve the most up-to-date information that we’ve
    processed while considering the fragment’s lifecycle'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData`：这有助于我们在考虑片段的生命周期时检索我们处理的最最新信息。'
- en: The combination of the two helped us efficiently delegate our processing logic,
    allowing us to unit test this processing logic
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种方法的结合使我们能够有效地委托我们的处理逻辑，从而允许我们对这种处理逻辑进行单元测试。
- en: Additional data streams
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据流
- en: 'One type of data stream that has gained popularity recently is the usage of
    Coroutines and Flows, mainly for their approach to asynchronous operations in
    Android. An example of Flows emitting data in a `ViewModel` would be as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最近流行起来的一种数据流类型是协程和流的用法，主要因为它们在 Android 中的异步操作方法。以下是一个在 `ViewModel` 中发出数据的流的示例：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding snippet, we have the two total declarations for public and
    private usage. Instead of `LiveData`, we use `StateFlow`, which will emit the
    current value and all subsequent new values when we subscribe to it. Because it
    emits the last value, we must always set an initial value when we initialize it.
    If we want to subscribe to changes in the total value, we can use the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有公共和私有使用的两个总声明。我们不是使用 `LiveData`，而是使用 `StateFlow`，它将在我们订阅时发出当前值和所有后续的新值。因为它会发出最后一个值，所以我们必须在初始化时始终设置一个初始值。如果我们想订阅总值的更改，我们可以使用以下方法：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding snippet will subscribe to `StateFlow` every time `viewLifecycleOwner`
    enters the `CREATED` stage. This will connect `StateFlow` with the lifecycle of
    `Fragment` to prevent any possible leaks. We will explore the mechanics of Flows
    and Coroutines in future chapters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，每次 `viewLifecycleOwner` 进入 `CREATED` 阶段时，都会订阅 `StateFlow`。这将 `StateFlow`
    与 `Fragment` 的生命周期连接起来，以防止任何可能的泄漏。我们将在未来的章节中探讨流和协程的机制。
- en: 'Another example of a data stream is the RxJava library, which represents another
    mechanism for emitting data. The library is best used for performing asynchronous
    work and transformations, and because it’s based on Java and not the Android operating
    system, it lacks any lifecycle awareness. For example, using RxJava in combination
    with ViewModels would look like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个数据流的例子是 RxJava 库，它代表了另一种发出数据的方式。该库最适合执行异步工作和转换，因为它基于 Java 而不是 Android 操作系统，所以它缺乏任何生命周期感知。例如，将
    RxJava 与 ViewModels 结合使用看起来如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we are using `BehaviorSubject` to replace `StateFlow`. `BehaviorSubject`
    has the same properties as state flow. It will keep the latest value and emit
    it when a component subscribes and all the new values after the subscription.
    Subscribing to the object looks like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `BehaviorSubject` 来替换 `StateFlow`。`BehaviorSubject` 与状态流具有相同的属性。它将保留最新的值，并在组件订阅时以及订阅后的所有新值时发出。订阅对象看起来如下所示：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are using Disposable to hold the subscription in `onViewCreated`. In
    `onDestroyView`, we are disposing of the subscription to prevent any context leaks.
    This is an alternative to using lifecycle-aware components such as `LiveData`
    and `StateFlow`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `onViewCreated` 中使用 Disposable 来保持订阅。在 `onDestroyView` 中，我们销毁订阅以防止任何上下文泄漏。这是使用如
    `LiveData` 和 `StateFlow` 这样的生命周期感知组件的替代方案。
- en: In this section, we looked at other types of streams of data that might be present
    in Android applications such as Kotlin Flows and RxJava, and analyzed their particularities.
    In the section that follows, we will look at how we can persist data using the
    Room library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Android 应用程序中可能存在的其他类型的数据流，如 Kotlin 流和 RxJava，并分析了它们的特性。在下一节中，我们将探讨如何使用
    Room 库持久化数据。
- en: Room
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Room
- en: The Room persistence library acts as a wrapper between your application code
    and the SQLite storage. You can think of SQLite as a database that runs without
    its own server and saves all the application data in an internal file that’s only
    accessible to your application (if the device is not rooted).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 房间持久化库在您的应用程序代码和 SQLite 存储之间充当包装器。您可以将 SQLite 视为一个无需自己的服务器即可运行的数据库，并将所有应用程序数据保存到仅对应用程序可访问的内部文件中（如果设备未越狱）。
- en: 'Room sits between the application code and the SQLite Android Framework, and
    handles the necessary **create**, **read**, **update**, and **delete** (**CRUD**)
    operations while exposing an abstraction that your application can use to define
    the data and how you want the data to be handled. This abstraction comes in the
    form of the following objects:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Room位于应用程序代码和SQLite Android框架之间，处理必要的**创建**、**读取**、**更新**和**删除**（**CRUD**）操作，同时提供了一个抽象，应用程序可以使用它来定义数据和如何处理数据。这种抽象以以下对象的形式出现：
- en: '**Entities**: You can specify how you want your data to be stored and the relationships
    between your data'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体（Entities）**：你可以指定你想要如何存储数据以及数据之间的关系'
- en: '**Data access object** (**DAO**): The operations that can be done on your data'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问对象（Data access object，DAO）**：可以在你的数据上执行的操作'
- en: '**Database**: You can specify the configurations that your database should
    have (the name of the database and migration scenarios)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：你可以指定数据库应具有的配置（数据库的名称和迁移场景）'
- en: 'These can be seen in the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在以下图中看到：
- en: '![Figure 11.7 – The relationship between your application and the Room components](img/B19411_11_07.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 应用程序与Room组件之间的关系](img/B19411_11_07.jpg)'
- en: Figure 11.7 – The relationship between your application and the Room components
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 应用程序与Room组件之间的关系
- en: In the preceding diagram, we can see how the Room components interact with each
    other. It’s easier to visualize this with an example. Let’s assume you want to
    make a messaging app and store each message in your local storage. In this case,
    `Entity` would be a `Message` object, which will have an ID and will contain the
    contents of the message, the sender, the time, status, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到Room组件之间的交互方式。通过一个例子来可视化这一点会更简单。假设你想制作一个消息应用，并将每条消息存储在本地存储中。在这种情况下，`Entity`将是一个`Message`对象，它将有一个ID，并包含消息的内容、发送者、时间、状态等。
- en: In order to access messages from the local storage, you will need `MessageDao`,
    which will contain methods such as `insertMessage()`, `getMessagesFromUser()`,
    `deleteMessage()`, and `updateMessage()`. In addition, since it’s a messaging
    application, you will need a `Contact` entity to hold information about the senders
    and receivers of a message.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从本地存储中访问消息，你需要`MessageDao`，它将包含`insertMessage()`、`getMessagesFromUser()`、`deleteMessage()`和`updateMessage()`等方法。此外，由于这是一个消息应用，你还需要一个`Contact`实体来存储消息的发送者和接收者的信息。
- en: The `Contact` entity will contain information such as a name, last time online,
    phone number, email, and so on. In order to access the contact information, you
    will need a `ContactDao` interface, which will contain `createUser()`, `updateUser()`,
    `deleteUser()`, and `getAllUsers()`. Both entities will create a matching table
    in SQLite, which contains the fields we defined inside the entity classes as columns.
    In order to achieve this, we’ll have to create `MessagingDatabase` in which we
    will reference both entities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact`实体将包含诸如姓名、最后在线时间、电话号码、电子邮件等信息。为了访问联系信息，你需要一个`ContactDao`接口，它将包含`createUser()`、`updateUser()`、`deleteUser()`和`getAllUsers()`。这两个实体将在SQLite中创建一个匹配的表，该表包含我们在实体类内部定义的字段作为列。为了实现这一点，我们需要创建`MessagingDatabase`，在其中我们将引用这两个实体。'
- en: In a world without Room or similar DAO libraries, we would need to use the Android
    Framework’s SQLite components. This typically involves code when setting up our
    database, such as a query to create a table and applying similar queries for every
    table we would have. Every time we queried a table for data, we would need to
    convert the resulting object into a Java or Kotlin one.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有Room或类似DAO库的世界中，我们需要使用Android框架的SQLite组件。这通常涉及到在设置数据库时编写代码，例如创建表的查询，以及为每个我们将拥有的表应用类似的查询。每次我们查询表以获取数据时，我们都需要将结果对象转换为Java或Kotlin对象。
- en: By default, Room does not allow any operations on the UI thread to enforce the
    Android standards related to input-output operations. To make asynchronous calls
    to access data, Room is compatible with a number of libraries and frameworks,
    such as Kotlin coroutines, RxJava, and `LiveData`, on top of its default definitions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Room不允许在UI线程上进行任何操作，以强制执行与输入输出操作相关的Android标准。为了异步调用以访问数据，Room与许多库和框架兼容，例如Kotlin协程、RxJava和`LiveData`，在其默认定义之上。
- en: We should now have an overview of how Room works and its main components. We
    will now look over each of these components and how we can use them for data persistence.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该对 Room 的工作原理及其主要组件有一个概述。接下来，我们将逐一查看这些组件以及我们如何使用它们进行数据持久化。
- en: Entities
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体
- en: 'Entities serve two purposes: to define the structure of tables and to hold
    the data from a table row. Let’s use our scenario of the messaging app and define
    two entities: one for the user and one for the message.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实体有两个用途：定义表的结构并存储表行中的数据。让我们以我们的消息应用场景为例，定义两个实体：一个用于用户，一个用于消息。
- en: 'The `User` entity will contain information about who sent the messages, while
    the `Message` entity will contain information about the contents of a message,
    the time it was sent, and a reference to the sender of the message. The following
    code snippet provides an example of how entities are defined with Room:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 实体将包含有关谁发送了消息的信息，而 `Message` 实体将包含有关消息内容、发送时间和消息发送者的引用。以下代码片段提供了一个使用
    Room 定义实体的示例：'
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, entities are just *data classes* with annotations, which will
    tell Room how the tables should be built in SQLite. The annotations we used are
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实体只是带有注解的数据类，这些注解将告诉 Room 如何在 SQLite 中构建表。我们使用的注解如下：
- en: The `@Entity` annotation defines the table. By default, the table name will
    be the name of the class. We can change the name of the table through the `tableName`
    method in the `Entity` annotation. This is useful in situations where we want
    our code obfuscated but wish to keep the consistency of the SQLite structure.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity` 注解定义了表。默认情况下，表名将是类的名称。我们可以通过 `Entity` 注解中的 `tableName` 方法来更改表名。这在我们需要使代码混淆但希望保持
    SQLite 结构一致性的情况下非常有用。'
- en: '`@ColumnInfo` defines configurations for a certain column. The most common
    one is the name of the column. We can also specify a default value, the SQLite
    type of the field, and whether the field should be indexed.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ColumnInfo` 定义了特定列的配置。最常见的是列名。我们还可以指定默认值、字段的 SQLite 类型以及字段是否应该被索引。'
- en: '`@PrimaryKey` indicates what in our entity will make it unique. Every entity
    should have at least one primary key. If your primary key is an integer or a long,
    then we can add the `autogenerate` field. This means that every entity that gets
    inserted into the `Primary Key` field is automatically generated by SQLite.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PrimaryKey` 指示我们的实体中哪部分将使其唯一。每个实体至少应该有一个主键。如果你的主键是整数或长整型，那么我们可以添加 `autogenerate`
    字段。这意味着每个插入到 `Primary Key` 字段的实体都将由 SQLite 自动生成。'
- en: 'Usually, this is done by incrementing the previous ID. If you wish to define
    multiple fields as primary keys, then you can adjust the `@Entity` annotation
    to accommodate this, such as the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过递增前一个 ID 来实现的。如果你希望将多个字段定义为主键，那么你可以调整 `@Entity` 注解以适应这种情况，如下所示：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s assume that our messaging application wants to send locations. Locations
    have a latitude, longitude, and name. We can add them to the `Message` class,
    but that would increase the complexity of the class. What we can do is create
    another entity and reference the ID in our class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的消息应用想要发送位置。位置有纬度、经度和名称。我们可以将它们添加到 `Message` 类中，但这会增加类的复杂性。我们可以做的是创建另一个实体并在我们的类中引用其
    ID。
- en: 'The problem with this approach is that we would then query the `Location` entity
    every time we queried the `Message` entity. Room has a third approach through
    the `@Embedded` annotation. Now, let’s look at the updated `Message` entity:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，每次我们查询 `Message` 实体时，都会查询 `Location` 实体。Room 通过 `@Embedded` 注解提供了第三种方法。现在，让我们看看更新后的
    `Message` 实体：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code adds three columns (`lat`, `long`, and `location_name`) to the messages
    table. This allows us to avoid having objects with a large number of fields while
    keeping the consistency of our tables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码向消息表添加了三个列（`lat`、`long` 和 `location_name`）。这使我们能够在保持表的一致性的同时避免拥有大量字段的对象。
- en: 'If we look at our entities, we’ll see that they exist independently. The `Message`
    entity has a `userId` field, but nothing is preventing us from adding messages
    from invalid users. This may lead to situations where we collect data without
    any purpose. If we want to delete a particular user, along with their messages,
    we must do so manually. Room provides us with a way to define this relationship
    using a `ForeignKey`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的实体，我们会看到它们是独立存在的。`Message` 实体有一个 `userId` 字段，但没有任何东西阻止我们添加来自无效用户的消息。这可能导致我们收集没有目的的数据。如果我们想删除特定的用户及其消息，我们必须手动进行。Room
    提供了一种使用 `ForeignKey` 定义这种关系的方法：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we added the `foreignKeys` field and created a new
    `ForeignKey` to the `User` entity, while for the parent column, we defined the
    `user_id` field in the `User` class, and for the child column, the `user` field
    in the `Message` class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了 `foreignKeys` 字段，并为 `User` 实体创建了一个新的 `ForeignKey`，而对于父列，我们在 `User`
    类中定义了 `user_id` 字段，对于子列，在 `Message` 类中定义了 `user` 字段。
- en: Every time we add a message to the table, there needs to be a `User` entry in
    the `users` table. If we try to delete a user and any messages from that user
    still exist, then, by default, this will not work because of the dependencies.
    However, we can tell Room to do a cascade delete, which will erase the user and
    the associated messages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们向表中添加消息时，`users` 表中都需要有一个 `User` 条目。如果我们尝试删除一个用户，并且该用户的消息仍然存在，那么，默认情况下，这不会工作，因为存在依赖关系。然而，我们可以告诉
    Room 执行级联删除，这将删除用户及其相关的消息。
- en: DAO
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAO
- en: If entities specify how we define and hold our data, then DAOs specify what
    to do with that data. A DAO class is a place where we define our CRUD operations.
    Ideally, each entity should have a corresponding DAO, but there are situations
    where crossovers occur (usually, this happens when we have to deal with JOINs
    between two tables).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体指定了如何定义和保存我们的数据，那么 DAO 指定了如何处理这些数据。DAO 类是一个定义我们的 CRUD 操作的地方。理想情况下，每个实体都应该有一个相应的
    DAO，但在某些情况下会发生交叉（通常，这发生在我们必须处理两个表之间的 JOIN 时）。
- en: 'Continuing with our previous example, let’s build some corresponding DAOs for
    our entity:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前的例子，让我们为我们的实体构建一些相应的 DAO：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the case of our messages, we have defined the following functions: insert
    one or more messages, update one or more messages, delete one or more messages,
    and retrieve all the messages from a certain user that are older than a particular
    time. For our users, we can insert one user, update one user, delete one user,
    and retrieve all the users.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的消息的情况下，我们定义了以下函数：插入一个或多个消息，更新一个或多个消息，删除一个或多个消息，以及检索特定时间之前某个用户的全部消息。对于我们的用户，我们可以插入一个用户，更新一个用户，删除一个用户，以及检索所有用户。
- en: If you look at our `Insert` methods, you’ll see we have defined that in the
    case of a conflict (when we try to insert something with an ID that already exists),
    it will replace the existing entry. The `Update` field has a similar configuration,
    but in our case, we have chosen the default. This means that nothing will happen
    if the update cannot occur.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们的 `Insert` 方法，你会看到我们定义了在冲突的情况下（当我们尝试插入一个已经存在的ID时），它将替换现有的条目。`Update`
    字段有类似的配置，但在我们的情况下，我们选择了默认设置。这意味着如果更新无法发生，则不会发生任何操作。
- en: 'The `@Query` annotation stands out from all the others. This is where we use
    SQLite code to define how our read operations work. `SELECT *` means we want to
    read all the data for every row in the table, which will populate all our entities’
    fields. The `WHERE` clause indicates a restriction that we want to apply to our
    query. We can also define a method like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query` 注解与其他所有注解不同。这是我们使用 SQLite 代码来定义我们的读取操作如何工作的地方。`SELECT *` 表示我们想要读取表中每一行的所有数据，这将填充我们所有实体的字段。`WHERE`
    子句表示我们想要应用查询的限制。我们也可以定义一个类似的方法：'
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This allows us to filter messages from multiple users. We can define a new
    class like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们过滤来自多个用户的消息。我们可以定义一个新的类如下：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can define the following query:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义以下查询：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will allow us to extract information from certain columns at a time, not
    the entire row.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们一次提取某些列的信息，而不是整行。
- en: 'Now, let’s say that you want to add the user information of the sender to every
    message. Here, we’ll need to use a similar approach to the one we used previously:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要将发送者的用户信息添加到每条消息中。在这里，我们需要使用之前使用过的类似方法：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By using the new data class, we can define this query:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用新的数据类，我们可以定义以下查询：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now have the user information for every message we want to display. This
    will come in handy in scenarios such as group chats, where we should display the
    name of the sender of every message.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们想要显示的每条消息的用户信息。这在诸如群聊等场景中很有用，在这些场景中，我们应该显示每条消息的发送者姓名。
- en: Setting up the database
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'What we have learned about so far is a bunch of DAOs and entities. Now, it’s
    time to put them together. First, let’s define our database:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止学到的关于DAO和实体的一堆知识。现在，是时候将它们组合在一起了。首先，让我们定义我们的数据库：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `@Database` annotation, we specify what entities go in our database and
    our version. Then, for every DAO, we define an abstract method in `RoomDatabase`.
    This allows the build system to build a subclass of our class in which it provides
    the implementations for these methods. The build system will also create the tables
    related to our entities.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Database`注解中，我们指定了数据库中包含哪些实体以及我们的版本。然后，对于每个DAO，我们在`RoomDatabase`中定义一个抽象方法。这允许构建系统构建我们类的子类，并为这些方法提供实现。构建系统还将创建与我们的实体相关的表。
- en: The `getDatabase` method in the companion object illustrates how we create an
    instance of the `ChatDatabase` class. Ideally, there should be one instance of
    the database for our application due to the complexity involved in building a
    new database object. However, this can be better achieved through a dependency
    injection framework.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象中的`getDatabase`方法说明了我们如何创建`ChatDatabase`类的实例。理想情况下，由于构建新数据库对象涉及到的复杂性，我们的应用程序应该只有一个数据库实例。然而，这可以通过依赖注入框架更好地实现。
- en: Let’s assume you’ve released your chat application. Your database is currently
    version one, but your users are complaining that the message status feature is
    missing. You decide to add this feature in the next release. This involves changing
    the database structure, which can impact databases that have already built their
    structures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经发布了你的聊天应用程序。你的数据库目前是版本一，但你的用户抱怨消息状态功能缺失。你决定在下一个版本中添加这个功能。这涉及到更改数据库结构，这可能会影响已经构建了结构的数据库。
- en: 'Luckily, Room offers something called a migration. In the migration, we can
    define how our database changed between versions 1 and 2\. So, let’s look at our
    example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Room提供了一个名为迁移的功能。在迁移中，我们可以定义数据库在版本1和2之间的变化。所以，让我们看看我们的例子：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we added the status flag to the `Message` entity. Now, let’s look at
    `ChatDatabase`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`Message`实体添加了状态标志。现在，让我们看看`ChatDatabase`：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In our database, we’ve increased the version to `2` and added a migration between
    versions `1` and `2`. Here, we added the `status` column to the table. We’ll add
    this migration when we build the database.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库中，我们已经将版本提升到`2`，并在版本`1`和`2`之间添加了迁移。在这里，我们向表中添加了`status`列。当我们构建数据库时，我们将添加这个迁移。
- en: Once we’ve released the new code, when the updated app is opened and the code
    to build the database is executed, it will compare the version of the stored data
    with the one specified in our class and notice a difference. Then, it will execute
    the specified migrations until it reaches the latest version. This allows us to
    maintain an application for years without impacting the user’s experience.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发布了新代码，当更新后的应用程序打开并执行构建数据库的代码时，它将比较存储数据的版本与我们类中指定的版本，并发现差异。然后，它将执行指定的迁移，直到达到最新版本。这使我们能够在多年内维护应用程序，而不会影响用户体验。
- en: If you look at our `Message` class, you may have noticed that we defined the
    time as `Long`. In Java and Kotlin, we have the `Date` object, which may be more
    useful than the timestamp of the message. Luckily, Room has a solution for this
    in the form of `TypeConverter`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看我们的`Message`类，你可能已经注意到我们定义了时间戳为`Long`。在Java和Kotlin中，我们有`Date`对象，这可能比消息的时间戳更有用。幸运的是，Room提供了一个名为`TypeConverter`的解决方案。
- en: 'The following table shows what data types we can use in our code and the SQLite
    equivalent. Complex data types need to be brought down to these levels using TypeConverters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们在代码中可以使用的数据类型以及SQLite的等效类型。复杂的数据类型需要通过TypeConverters降级到这些级别：
- en: '![Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite
    data types](img/B19411_11_08.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – Kotlin/Java数据类型与SQLite数据类型之间的关系](img/B19411_11_08.jpg)'
- en: Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite
    data types
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – Kotlin/Java数据类型与SQLite数据类型之间的关系
- en: 'Here, we’ve modified the `lastOnline` field so that it’s of the `Date` type:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了`lastOnline`字段，使其成为`Date`类型：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we’ve defined a couple of methods that convert a `Date` object into `Long`
    and vice versa. The `@TypeConverter` annotation helps Room identify where the
    conversion takes place:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些方法，可以将 `Date` 对象转换为 `Long`，反之亦然。`@TypeConverter` 注解帮助 Room 识别转换发生的位置：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we’ll add our converter to Room using the `@``TypeConverters` annotation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `@TypeConverters` 注解将我们的转换器添加到 Room 中：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the next section, we will look at some third-party frameworks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些第三方框架。
- en: Third-party frameworks
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方框架
- en: 'Room works well with third-party frameworks such as `LiveData`, RxJava, and
    coroutines. This solves two issues: multi-threading and observing data changes.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 房间（Room）与第三方框架如 `LiveData`、RxJava 和协程（coroutines）配合良好。这解决了两个问题：多线程和观察数据变化。
- en: '`LiveData` will make the `@Query` annotated methods in your DAOs reactive,
    which means that if new data is added, `LiveData` will notify the observers of
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData` 将使你的 DAO 中的 `@Query` 注解的方法实现响应式，这意味着如果添加了新数据，`LiveData` 将通知观察者：'
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Kotlin coroutines complement `LiveData` by making the `@Insert`, `@Delete`,
    and `@Update` methods asynchronous:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 协程通过使 `@Insert`、`@Delete` 和 `@Update` 方法异步来补充 `LiveData`：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`@Query` methods reactive through components such as `Publisher`, `Observable`,
    or `Flowable` and making the rest of the methods asynchronous through `Completable`,
    `Single`, or `Maybe`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query` 方法通过 `Publisher`、`Observable` 或 `Flowable` 等组件实现响应式，并通过 `Completable`、`Single`
    或 `Maybe` 使其他方法异步：'
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Executors and threads** come with the Java framework and can be a useful
    solution for solving threading issues with Room if none of the aforementioned
    third-party integrations are part of your project.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行器和线程**是 Java 框架的一部分，如果上述第三方集成都不是你的项目的一部分，它们可以是一个有用的解决方案来解决 Room 的线程问题。'
- en: 'Your DAO classes will not suffer from any modifications; however, you will
    need the components that access your DAOs to adjust and use either an executor
    or a thread:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 DAO 类不会受到任何修改；然而，你需要访问你的 DAO 的组件进行调整和使用执行器或线程：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'An example of accessing the DAO is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 DAO 的一个示例如下：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding example will create a new thread and start it every time we want
    to retrieve the list of users. There are two major issues with this code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将在每次我们想要检索用户列表时创建一个新的线程并启动它。这段代码有两个主要问题：
- en: Thread creation is an expensive operation
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建是一个昂贵的操作
- en: The code is hard to test
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码难以测试
- en: The solution to the first is to use `ThreadPools` and `Executors`. The Java
    framework offers a robust set of options when it comes to `ThreadPools`. A thread
    pool is a component responsible for thread creation and destruction and allows
    the developer to specify the number of threads in the pool. Multiple threads in
    a thread pool will ensure multiple tasks can be executed concurrently.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的解决方案是使用 `ThreadPools` 和 `Executors`。Java 框架在提供 `ThreadPools` 方面提供了一套强大的选项。线程池是一个负责线程创建和销毁的组件，允许开发者指定池中的线程数。线程池中的多个线程将确保多个任务可以并发执行。
- en: 'We can rewrite the preceding code as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码重写如下：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding example, we defined an executor that will use a pool of one
    thread. When we want to access the list of users, we move the query inside the
    executor, and when the data is loaded, our callback lambda will be invoked.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个将使用一个线程池的执行器。当我们想要访问用户列表时，我们将查询移动到执行器内部，当数据加载完成后，我们的回调 lambda
    将被调用。
- en: Exercise 11.03 – making a little room
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03 – 留出一些空间
- en: You have been hired by a news agency to build a news application. The application
    will display a list of articles written by journalists. An article can be written
    by one or more journalists, and each journalist can write one or more articles.
    The data information for each article includes the article’s title, content, and
    date.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你被一家新闻机构雇佣来构建一个新闻应用程序。该应用程序将显示由记者撰写的文章列表。一篇文章可以由一位或多位记者撰写，每位记者可以撰写一篇或多篇文章。每篇文章的数据信息包括文章的标题、内容和日期。
- en: The journalist’s information includes their first name, last name, and job title.
    You will need to build a Room database that holds this information so it can be
    tested. Before we start, let’s look at the relationship between the entities.
    In the chat application example, we defined the rule that one user can send one
    or multiple messages.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 记者的信息包括他们的名字、姓氏和职位。你需要构建一个包含这些信息的 Room 数据库，以便进行测试。在我们开始之前，让我们看看实体之间的关系。在聊天应用程序的示例中，我们定义了一个规则：一个用户可以发送一条或多条消息。
- en: This relationship is known as a one-to-many relationship. That relationship
    is implemented as a reference between one entity to another (the user was defined
    in the message table in order to be connected to the sender).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系被称为一对多关系。该关系通过一个实体到另一个实体（用户在消息表中定义，以便与发送者连接）的引用来实现。
- en: 'In this case, we have a many-to-many relationship. To implement a many-to-many
    relationship, we need to create an entity that holds references that will link
    the other two entities. Let’s get started:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个多对多关系。为了实现多对多关系，我们需要创建一个包含引用的实体，这些引用将链接其他两个实体。让我们开始吧：
- en: Create a new Android Project with No Activity.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个不带活动的新的Android项目。
- en: 'Let’s start by adding the annotation processing plugin to `app/build.gradle`.
    This will read the annotations used by Room and generate the code necessary for
    interacting with the database:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先向`app/build.gradle`添加注解处理插件。这将读取Room使用的注解并生成与数据库交互所需的代码：
- en: '[PRE55]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, let’s add the Room libraries in `app/build.gradle`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`app/build.gradle`中添加Room库：
- en: '[PRE56]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first line defines the library version, the second line brings in the Room
    library for Java and Kotlin, and the last line is for the Kotlin annotation processor.
    This allows the build system to generate boilerplate code from the Room annotations.
    After these changes to your Gradle files, you should get a prompt to sync your
    project, which you should click.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了库版本，第二行引入了Java和Kotlin的Room库，最后一行是用于Kotlin注解处理器的。这允许构建系统从Room注解生成样板代码。在修改了你的Gradle文件之后，你应该会收到一个提示来同步你的项目，你应该点击它。
- en: 'Let’s define our entities in the `main/java` folder and the root package:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`main/java`文件夹和根包中定义我们的实体：
- en: '[PRE57]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, define the entity that connects the journalist to the article and the
    appropriate constraints in the `main/java` folder and the root package:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main/java`文件夹和根包中定义连接记者和文章的实体以及适当的约束：
- en: '[PRE58]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding code, we defined our connecting entity. As you can see, we
    haven’t defined an ID for uniqueness, but both the article and the journalist
    will be unique when used together. We also defined foreign keys for each of the
    other entities referred to by our entity.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了我们的连接实体。正如你所见，我们没有为唯一性定义ID，但文章和记者将一起使用时将是唯一的。我们还为我们的实体引用的每个其他实体定义了外键。
- en: 'Create the `ArticleDao` DAO in the `main/java` folder and the root package:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main/java`文件夹和根包中创建`ArticleDao` DAO：
- en: '[PRE59]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, create the `JournalistDao` data access object in the `main/java` folder
    and the root package:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main/java`文件夹和根包中创建`JournalistDao`数据访问对象：
- en: '[PRE60]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create the `JoinedArticleJournalistDao` DAO in the `main/java` folder and the
    root package:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main/java`文件夹和根包中创建`JoinedArticleJournalistDao` DAO：
- en: '[PRE61]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let’s analyze our code a little bit. For the articles and journalists, we can
    add, insert, delete, and update queries. For articles, we can extract all of the
    articles but also extract articles from a certain author.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分析一下我们的代码。对于文章和记者，我们可以添加、插入、删除和更新查询。对于文章，我们可以提取所有文章，也可以从特定作者那里提取文章。
- en: We also have the option to extract all the journalists that wrote an article.
    This is done through a JOIN with our intermediary entity. For that entity, we
    define the options to insert (which will link an article to a journalist) and
    delete (which will remove that link).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有提取所有撰写文章的记者的选项。这是通过与我们中间实体的JOIN来完成的。对于该实体，我们定义了插入（这将链接一篇文章到一个记者）和删除（这将移除该链接）的选项。
- en: 'Finally, let’s define our `Database` class in the `main/java` folder and the
    root package:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在`main/java`文件夹和根包中定义我们的`Database`类：
- en: '[PRE62]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We avoided defining the `getInstance` method here because we won’t be calling
    the database anywhere. But if we don’t do that, how will we know whether it works?
    The answer to this is that we’ll test it. This won’t be a test that will run on
    your machine but one that will run on the device. This means that we will create
    it in the `androidTest` folder.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里避免了定义`getInstance`方法，因为我们不会在任何地方调用数据库。但如果我们不这样做，我们怎么知道它是否工作呢？答案是，我们将对其进行测试。这不是将在你的机器上运行的测试，而是一个将在设备上运行的测试。这意味着我们将在`androidTest`文件夹中创建它。
- en: 'Let’s start by setting up the test data. Here, we will add some articles and
    journalists to the database then test retrieving, updating, and deleting the entries:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先设置测试数据。在这里，我们将向数据库添加一些文章和记者，然后测试检索、更新和删除条目：
- en: '[PRE63]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The complete code for this step can be found at [https://packt.link/6H8X2](https://packt.link/6H8X2).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/6H8X2](https://packt.link/6H8X2) 找到。
- en: Here, we have defined a few examples of how to test a Room database. What’s
    interesting is how we build the database. Our database is an in-memory database.
    This means that all the data will be kept as long as the test is run and discarded
    afterward.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些如何测试 Room 数据库的示例。有趣的是我们如何构建数据库。我们的数据库是一个内存数据库。这意味着所有数据都会在测试运行期间保留，并在之后丢弃。
- en: This allows us to start with a clean slate for each new state and avoids the
    consequences of each of our testing sessions affecting each other. In our test,
    we’ve set up 5 articles and 10 journalists. The first article was written by the
    top two journalists, while the second article was written by the first journalist.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们为每个新状态从零开始，避免了每个测试会话的后果相互影响。在我们的测试中，我们设置了 5 篇文章和 10 名记者。第一篇文章是由前两名记者撰写的，而第二篇文章是由第一名记者撰写的。
- en: The rest of the articles have no authors. By doing this, we can test our update
    and delete methods. For the delete method, we can test our foreign key relationship
    as well. In the test, we can see that if we delete article `1`, it will delete
    the relationship between the article and the journalists that wrote it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的文章没有作者。通过这样做，我们可以测试我们的更新和删除方法。对于删除方法，我们还可以测试我们的外键关系。在测试中，我们可以看到如果我们删除文章 `1`，它将删除文章与撰写它的记者之间的关系。
- en: When testing your database, you should add the scenarios that your app will
    use. Feel free to add other testing scenarios and improve the preceding tests
    in your own database. Note that if you are using the `androidTest` folder, then
    this will be an instrumented test, meaning that you will need an emulator or a
    device to test.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试你的数据库时，你应该添加你的应用程序将使用的场景。请随意添加其他测试场景并改进你自己的数据库中的先前测试。请注意，如果你正在使用 `androidTest`
    文件夹，那么这将是一个仪器化测试，这意味着你需要一个模拟器或设备来测试。
- en: Activity 11.01 – a shopping notes app
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01 – 购物笔记应用
- en: 'You want to keep track of your shopping items, so you decide to build an app
    to save the items you wish to buy during your next trip to the store. The requirements
    for this are as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你想跟踪你的购物项目，因此你决定构建一个应用程序来保存你下次去商店时希望购买的项目。这些要求如下：
- en: 'The UI will be split into two: top/bottom in portrait mode and left/right in
    landscape mode. The UI will look similar to what is shown in the following screenshot.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 将分为两部分：纵向模式下的顶部/底部和横向模式下的左侧/右侧。UI 的外观将与以下截图所示类似。
- en: The first half will display the number of notes, a text field, and a button.
    Every time the button is pressed, a note will be added with the text placed in
    the text field.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分将显示笔记数量、文本字段和按钮。每次按下按钮时，都会在文本字段中添加一个笔记。
- en: The second half will display the list of notes.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分将显示笔记列表。
- en: For each half, you will have a View model that will hold the relevant data.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一半，你将有一个视图模型来保存相关数据。
- en: You should define a repository that will be used on top of the Room database
    to access your data.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该定义一个存储库，该存储库将用于在 Room 数据库之上访问你的数据。
- en: You should also define a Room database that will hold your notes.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还应该定义一个 Room 数据库来保存你的笔记。
- en: 'The note entity will have the following attributes: `id` and `text`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记实体将具有以下属性：`id` 和 `text`：
- en: '![Figure 11.9 – Example of a possible output for activity 11.01](img/B19411_11_09.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 活动 11.01 的可能输出示例](img/B19411_11_09.jpg)'
- en: Figure 11.9 – Example of a possible output for activity 11.01
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 活动 11.01 的可能输出示例
- en: 'Perform the following steps to complete this activity:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Start with Room integration by creating the `Entity`, `Dao`, and `Database`
    methods. For `Dao`, the `@Query` annotated methods can directly return a `LiveData`
    object so that the observers can be directly notified if the data changes.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建 `Entity`、`Dao` 和 `Database` 方法开始 Room 集成。对于 `Dao`，使用 `@Query` 注解的方法可以直接返回
    `LiveData` 对象，这样观察者就可以在数据更改时直接收到通知。
- en: Define a template of our repository in the form of an interface.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以接口的形式定义我们存储库的模板。
- en: Implement the repository. The repository will have one reference to the `Dao`
    object we defined previously. The code for inserting the data must be moved to
    a separate thread.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现存储库。存储库将包含一个对我们之前定义的 `Dao` 对象的引用。插入数据的代码必须移动到单独的线程中。
- en: Create the `NotesApplication` class to provide one instance of the repository
    that will be used across the application. Make sure to update the `<application>`
    tag in the `AndroidManifest.xml` file to add your new application class.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `NotesApplication` 类以提供将在整个应用程序中使用的仓库的一个实例。确保更新 `AndroidManifest.xml` 文件中的
    `<application>` 标签以添加你的新应用程序类。
- en: 'Unit-test the repository and define `ViewModels`, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试仓库并定义 `ViewModels`，如下所示：
- en: Define `NoteListViewModel` and the associated test. This will have a reference
    to the repository and return the list of notes.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `NoteListViewModel` 和相关的测试。这将有一个对仓库的引用并返回笔记列表。
- en: Define `CountNotesViewModel` and the associated test. `CountViewModel` will
    have a reference to the repository and return the total number of notes as `LiveData`.
    It will also be responsible for inserting new notes.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `CountNotesViewModel` 和相关的测试。`CountViewModel` 将有一个对仓库的引用并返回笔记的总数作为 `LiveData`。它还将负责插入新的笔记。
- en: Define `CountNotesFragment` and the associated `fragment_count_notes.xml` layout.
    In the layout, define a `TextView`, which will display the total number, an `EditText`
    for the name of the new notes, and a button, which will insert the note that was
    introduced in `EditText`.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `CountNotesFragment` 和相关的 `fragment_count_notes.xml` 布局。在布局中，定义一个 `TextView`，用于显示总数，一个用于新笔记名称的
    `EditText`，以及一个按钮，该按钮将插入在 `EditText` 中引入的笔记。
- en: Define an adapter for the list of notes called `NoteListAdapter` and an associated
    layout file for the rows called `view_note_item.xml`.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `NoteListAdapter` 的笔记列表适配器以及相关的布局文件 `view_note_item.xml`。
- en: Define the associated layout file, called `fragment_note_list.xml`, which will
    contain `RecyclerView`. The layout will be used by `NoteListFragment`, which will
    connect `NoteListAdapter` to `RecyclerView`. It will also observe the data from
    `NoteListViewModel` and update the adapter.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义相关的布局文件，称为 `fragment_note_list.xml`，其中将包含 `RecyclerView`。该布局将由 `NoteListFragment`
    使用，它将连接 `NoteListAdapter` 到 `RecyclerView`。它还将观察来自 `NoteListViewModel` 的数据并更新适配器。
- en: Define `NotesActivity` with an associated layout for landscape mode and portrait
    mode.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有相关布局的 `NotesActivity`，包括横屏模式和竖屏模式。
- en: Make sure you have all the necessary data in `strings.xml`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经在 `strings.xml` 中有了所有必要的数据。
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/ZhnDx](https://packt.link/ZhnDx).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 [https://packt.link/ZhnDx](https://packt.link/ZhnDx) 找到。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the building blocks required to build a maintainable
    application. We also looked into one of the most common issues that developers
    come across when using the Android Framework, which is maintaining the states
    of objects during lifecycle changes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了构建可维护应用程序所需的基本组件。我们还探讨了开发者在使用 Android 框架时遇到的最常见问题之一，即在生命周期变化期间维护对象的状态。
- en: We started by analyzing `ViewModels` and how they solve the issue of holding
    data during orientation changes. We added `LiveData` to `ViewModels` to show how
    the two complement each other and looked at how we can use other data streams
    with `ViewModels` and compare those with `LiveData`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先分析了 `ViewModels` 以及它们如何解决在方向变化时保持数据的问题。我们向 `ViewModels` 添加了 `LiveData` 来展示这两个是如何相互补充的，并探讨了如何使用其他数据流与
    `ViewModels` 一起使用，并将这些与 `LiveData` 进行比较。
- en: We then moved on to Room to show how we can persist data with minimal effort
    and without much SQLite boilerplate code. We also explored one-to-many and many-to-many
    relationships, as well as how to migrate data and break down complex objects into
    primitives for storage.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着转向 Room，展示如何以最小的努力和几乎没有 SQLite 模板代码的情况下持久化数据。我们还探讨了一对一和多对多关系，以及如何迁移数据和将复杂对象分解为原始数据以进行存储。
- en: The activity we completed in this chapter serves as an example of what direction
    Android apps are heading in. However, this was not a complete example due to the
    numerous frameworks and libraries that you will discover, which give developers
    the flexibility to go in different directions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们完成的活动是 Android 应用发展方向的一个示例。然而，这并不是一个完整的示例，因为你会发现许多框架和库，这些框架和库为开发者提供了灵活性，可以走向不同的方向。
- en: The information you’ve learned in this chapter will serve you well for the next
    one, which will expand on the concept of repositories. This will allow you to
    save data that’s been obtained from a server into a Room database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你学到的信息将有助于下一章，下一章将扩展仓库的概念。这将允许你将来自服务器的数据保存到 Room 数据库中。
- en: 'The concept of persisting data will also be expanded as you will explore other
    ways to persist data, such as through `SharedPreferences`, `DataStore`, and files.
    Our focus will be on certain types of files: media files obtained from the camera
    of the device.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你探索其他持久化数据的方式，例如通过`SharedPreferences`、`DataStore`和文件，持久化数据的概念也将得到扩展。我们的重点将放在某些类型的文件上：从设备相机获取的媒体文件。
