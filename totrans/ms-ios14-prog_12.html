<html><head></head><body>
		<div><h1 id="_idParaDest-199"><em class="italic"><a id="_idTextAnchor422"/>Chapter 12</em>: Improving Apps with Location Services</h1>
			<p>All iOS devices come with a huge variety of chips and sensors that can be used to enhance the user experience. Augmented reality applications make heavy use of sensors such as the gyroscope, accelerometer, and camera. These sensors are great if you want to grab a picture or want to know how a device is moving. Other apps require different data, such as the user's GPS location at a given time. In this chapter, you will learn how to use the <strong class="bold">Core Location</strong> framework to do just that.</p>
			<p><strong class="bold">Core Location</strong> is a framework that allows developers to gain access to a user's current location, but it also allows developers to track whether a user has entered or exited a specific area, or even to monitor a user's location over time. A proper implementation of Core Location can be the core of many great features in your app, but a lousy implementation could drain a user's battery in no time.</p>
			<p>In this chapter, you will learn about the following location-related topics: </p>
			<ul>
				<li>Requesting a user's location</li>
				<li>Subscribing to location changes</li>
				<li>Setting up geofences</li>
			</ul>
			<p>By the end of the chapter, you should be able to make educated decisions about how and when you implement Core Location in your apps.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor423"/>Technical requirements</h1>
			<p>The code bundle for this chapter includes a starter project called <strong class="bold">LocationServices</strong>. You can find it in the code bundle repository:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%2012%20-%20Location%20Services</a></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor424"/>Requesting a user's location</h1>
			<p>As <a id="_idIndexMarker576"/>you can imagine, giving an application access to your exact location is quite a big deal. In the wrong hands, this data could allow people with malicious intentions to know exactly where you are at any given time and abuse this knowledge in many different ways. For this reason, it's essential that you only request a user's location if you absolutely have to. Simply using it for a small feature, or to make sure a user is in some arbitrary location before they sign up for a service, might not always be a goo<a id="_idTextAnchor425"/>d enough reason to ask for a user's location.</p>
			<p>Let's see now the different ways to ask the user for permission to access their location data in iOS.<a id="_idTextAnchor426"/></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor427"/>Asking for permission to access location data</h2>
			<p>When<a id="_idIndexMarker577"/> you do need access to a user's location, you have to ask permission first. Similar to how you have to add a reason for needing the camera or a user's contacts to the <code>Info.plist</code> file, you must also provide a reason for requesting location data. In the case of location data, there are two keys you can add to the <code>Info.plist</code>:</p>
			<ul>
				<li>Privacy-Location <code>NSLocationWhenInUseUsageDescription</code>)</li>
				<li>Privacy-Location <code>NSLocationAlwaysAndWhenInUseUsageDescription</code>)</li>
			</ul>
			<p>When your app asks for permission to use a user's location data, they have the option to only allow your app access to their location when the app is in use, or they can choose to allow your app to access their location all the time, even when the app is in the background. You can also configure the type of access that you want to ask yourself. If you only need the user's location when they are using the app, make sure to configure your permission request properly so the user isn't asked to provide their location to your app when it's in the background.</p>
			<p>After adding the required keys to the <code>Info.plist</code> file in the <strong class="bold">LocationServices</strong> app, you will need to write some code to ask the user for permission to use their location. Before doing this, let's quickly examine the sample project's structure and content so you are aware of what information can be found where<a id="_idTextAnchor428"/>.</p>
			<p>First, open the <code>Main.storyboard</code> file in the project. You will find a tab bar controller with two view controllers in it. Throughout this chapter, you will implement the features to populate these view controllers with appropriate data. Next, look at the <code>AppDelegate</code> implementation. The implementation here follows the <code>GeofenceViewController</code> is the one you will work on first, to make the user's current location appear on the screen.</p>
			<p>You will<a id="_idIndexMarker578"/> notice that a lot of code has already been implemented in this view controller. Examine the existing code for a bit and you'll find that all the code makes calls to empty methods in <code>LocationHelper.swift</code>. Most of your focus in this chapter will be on implementing the Core Location code required to work with a user's location data, so the UI work has already been set up. As you add code to <code>LocationHelper</code>, you'll find that the user interface for <code>LocationServices</code> comes to life bit by bit.</p>
			<p>Now that you have a better understanding of how the LocationServices app was set up, let's see what steps are involved in asking the user for permission to use their location. Since this app will eventually track location changes in the background, you should ask the user for access to their location even when the app is in the background. To do this, add the following <code>viewDidAppear(_:)</code> code to <code>GeofenceViewController</code>:</p>
			<pre>locationHelper.askPermission { [weak self] status in if status == .authorizedAlways {
  self?.showCurrentLocation()
  } else {
    // handle the case where you don't always have access
  }
}</pre>
			<p>This is the first view controller the user will see, so asking the user for their location as soon as this view appears is a good idea. If it's not obvious that you will be prompting the user for their location, it's often a good idea to inform the user about why you are going to ask them for location permissions before actually showing the location access dialog. To actually make the permission dialog appear, you will need to add some code to <code>LocationHelper.swif<a id="_idTextAnchor429"/>t</code>.</p>
			<p>All location service-related requests are performed through an instance of <code>CLLocationManager</code>. The location manager is responsible for obtaining the user's GPS location, asking for permission to access the user's location, and more. When the location manager receives updates about the user's location, authorization status, or other events, it will notify its delegate. A location manager delegate should conform to the <code>CLLocationManagerDelegate</code> protocol. Note that the <code>LocationHelper</code> already conforms to <code>CLLocationManagerDelegate</code>, and that an instance of <code>CLLocationManager</code> is already created on this object. All that's left to do is assign the helper as the delegate for the location manager. Add the following line at the end of the <code>init()</code> method in <code>LocationHelper</code> to set it as the location manager delegate:</p>
			<pre>locationManager.delegate = self</pre>
			<p>Next, add the <a id="_idIndexMarker579"/>following implementation for the <code>askPermission(_:)</code> method:</p>
			<pre>func askPermission(_ completion: @escaping (CLAuthorizationStatus) -&gt; Void) {
  let authorizationStatus = 
    CLLocationManager.authorizationStatus()
  if authorizationStatus != .notDetermined {
    completion(authorizationStatus)
  } else {
    askPermissionCallback = completion
    locationManager.requestAlwaysAuthorization()
  }
}</pre>
			<p>This implementation checks whether a current authorization status exists. If it does, the completion <code>callback</code> is called with the current status. If the current status has not been determined yet, the location manager is asked to request authorization to access the user location using the <code>requestAlwaysAuthorization()</code> method. This will prompt the user for their location permissions. The reason you need to have permanent access to a user's location in this app is to ensure you can implement geofencing later in this chapter. Add the following method to the <code>CLLocationManagerDelegate</code> to retrieve the user's <a id="_idIndexMarker580"/>response to the authorization pr<a id="_idTextAnchor430"/>ompt:</p>
			<pre>func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
  askPermissionCallback?(status)
  askPermissionCallback = nil
}</pre>
			<p>The preceding code immediately passes the user's response to the stored completion callback that was passed to <code>askPermission(_:)</code>. After calling the callback, it is set to nil to avoid accidentally calling it again. At this point, you have done all the work required to request access to a user's location. Let's see how you can retrieve a u<a id="_idTextAnchor431"/>ser's current location next, so you can make use of it in your a<a id="_idTextAnchor432"/>pps.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor433"/>Obtaining a user's location</h2>
			<p>Once your app has<a id="_idIndexMarker581"/> access to location data, you can use the location manager to begin observing a user's location, the direction in which a user is heading, and more. For now, you will focus on obtaining the user's current location. <code>GeofenceViewController</code> already contains a method, called <code>showCurrentLocation()</code>, that is responsible for asking the location helper for a current location. If you examine this method closely, you'll find that it also asks the location helper for a location name by calling <code>getLocationName(for:_:)</code> and passing the obtained location to this method. The <code>showCurrentLocation()</code> method also uses the obtained location to focus a map view on the user's location by calling <code>setRegion(_:animated:)</code> on the map view.</p>
			<p>Since the view controller is already fully prepared to handle location updates, all you need to do is add the proper implementations for <code>getLatestLocation(_:)</code> and <code>getLocationName(for:_:)</code>. Begin by adding the following implementation for <code>getLatestLocation(_:)</code>:</p>
			<pre>func getLatestLocation(_ completion: @escaping (CLLocation) -&gt; Void) {
  if let location = trackedLocations.last {
    completion(location)
  } else if CLLocationManager.locationServicesEnabled() {
    latestLocationObtainedCallback = completion
    locationManager.startUpdatingLocation()
  }
}</pre>
			<p>The preceding method first checks whether a location has already been obtained. If it has, then the latest obtained location is returned. If there is no existing location, the code checks whether location services are enabled. It's always good practice to check whether the location service you are about to use is actually available. If location services are available, the <code>completion</code> callback is stored in the helper, and the location manager is told to start monitoring the user's location by calling <code>startUpdatingLocati<a id="_idTextAnchor434"/>on()</code>.</p>
			<p>Calling <code>startUpdateLocation()</code> will make the location observer continuously monitor the user's <a id="_idIndexMarker582"/>GPS location, and will send any relevant updates to its delegate by calling <code>locationManager(_:didUpdateLocations:)</code>. This method will always receive one or more new locations that the manager has obtained, where the latest location will be the last item in the list of obtained locations. Add the following implementation for this method to the <code>CLLocationManagerDelegate</code> extension of <code>LocationHelper</code>:</p>
			<pre>func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  latestLocationObtainedCallback?(locations.last!)
  latestLocationObtainedCallback = nil
  locationManager.stopUpdatingLocation()
  trackedLocations += locations
}</pre>
			<p>The implementation for <code>locationManager(_:didUpdateLocations:)</code> is fairly straightforward: the latest location is passed to the callback, and the callback is removed to prevent subsequent location updates from triggering the callback unexpectedly. Also, the <a id="_idIndexMarker583"/>location manager is told to stop monitoring the user's location by calling <code>stopUpdatingLocation()</code>. Lastly, the obtained locations are stored for later use.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It's always good practice to make the location manager stop monitoring location updates if you won't be needing updates any time soon. Monitoring location updates has a pretty significant impact on battery life, so you shouldn't spend more time tracking a user's location than needed.</p>
			<p>Now that you can retrieve the user's location, the last step is to also retrieve the location name by implementing <code>getLocationName(for:_:_)</code> in the location helper. Add the following implementation for this method to the location helper:</p>
			<pre>func getLocationName(for location: CLLocation, _ completion: @escaping (String) -&gt; Void) {
  let geocoder = CLGeocoder()
  geocoder.reverseGeocodeLocation(location) { placemarks,
    error in
  guard error == nil else {
    completion("An error ocurred: 
    \(error?.localizedDescription ?? "Unknown error")")
    return
  }
  completion(placemarks?.first?.name ?? "Unkown location")
  }
}</pre>
			<p>The preceding code uses <code>CLGeocoder</code> to find a placemark that corresponds with the user's current location. Note that this feature uses an internet connection, so the name lookup will only work if the user has an internet connection. Regular GPS-related features do not require internet access, so your app can monitor and track a user's location even if they don't have an active internet connection.</p>
			<p>Try running your app now—you<a id="_idIndexMarker584"/> should be able to see the user's current location on the map, and the location name, latitude, and longitude should be displayed on the screen as well. Now that you know how to obtain a user's location, let's se<a id="_idTextAnchor435"/>e how you can efficiently subscribe your app to follow changes in a user's location in order to track their p<a id="_idTextAnchor436"/>osition.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor437"/>Subscribing to location changes</h1>
			<p>One way of <a id="_idIndexMarker585"/>subscribing to changes in a user's location has already been covered in the previous section of this chapter. When you call <code>startUpdatingLocation()</code> on a location manager, it will automatically subscribe to the user's location. This method of tracking a user's location is excellent if you need very detailed reporting on a user's location, but usually, you don't need this level of detail. More importantly, using this kind of location tracking for an extended period will drain the user's battery.</p>
			<p>Luckily, there are better ways to monitor location changes. One way is to subscribe to locations that the user visits by calling <code>startMonitoringVisits()</code>. This method is used if you aren't interested in the user's detailed movement but only want to know whether the user spent an extended period in a particular area. This type of tracking of a user's location is perfect if you need a low-power way to track very rough location changes. This kind of tracking even works well if your app is running in the background, because your app will automatically be woken up or launched if a visit event occurs.</p>
			<p>If your app is relaunched due to a location-related event, then <code>UIApplication.LaunchOptionsKey.location</code> will be present in the application's launch options dictionary. When it is, you are expected to create an instance of a location manager and assign it a delegate to receive the relevant locatio<a id="_idTextAnchor438"/>n update.</p>
			<p>If the visit monitoring is a bit too inaccurate for your purposes but you don't need continuous location tracking, you can use <code>LocationServices</code> sample app to see exactly how they work.</p>
			<p>If you look at <code>SignificantChangesViewController</code>, you'll note that the view controller is fully set up to begin monitoring significant location changes. The <code>monitorSignificantChanges(_:)</code> method, defined in the location helper, takes a callback that's called every time a significant location change occurs. Every time new location data is retrieved, the table view is reloaded to display the latest available data. Since significant location changes can wake the app up with a special key in the app's launch options, let's update <code>AppDelegate</code> so it can handle this scenario. Add the following code <code>application(_:didFinishLaunchingWithOptions:)</code> right before the <code>return</code> statement:</p>
			<pre>if launchOptions?[UIApplication.LaunchOptionsKey.location] != nil
  { locationHelper.monitorSignificantChanges { _ in
    // continue monitoring
  }
}</pre>
			<p>Since <code>AppDelegate</code> already has a reference to the location helper, all it needs to do is re-enable significant location changes monitoring. This small change to <code>AppDelegate</code> is quite powerful because it allows your app to respond to changes in the user's location even when the app is not running. Let's implement the appropriate code in the location helper next.</p>
			<p>Add the following implementation for <code>monitorSignificantLocationChanges(_:)</code> to <code>LocationHelper</code>:</p>
			<pre>func monitorSignificantChanges(_ locationHandler: @escaping (CLLocation) -&gt; Void) {
  guard CLLocationManager. 
    significantLocationChangeMonitoringAvailable() else { return }
  significantChangeReceivedCallback = locationHandler
  locationManager.startMonitoringSignificantLocationChanges()
  isTrackingSignificantLocationChanges = true
}</pre>
			<p>This method is <a id="_idIndexMarker587"/>very similar to the location helper methods you have seen before. When a significant location change is detected, the location manager calls <code>locationManager(_:didUpdateLocations:)</code> on its delegate. Since this method is already implemented, you should update the implementation as follows:</p>
			<pre>func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  latestLocationObtainedCallback?(locations.last!)
  latestLocationObtainedCallback = nil
  if isTrackingSignificantLocationChanges == false {
    locationManager.stopUpdatingLocation()
  }
  significantChangeReceivedCallback?(locations.last!)
  trackedLocations += locations
}</pre>
			<p>Note that the location manager is only told to stop updating the user's location when significant location change tracking is not active. When you call <code>stopUpdatingLocation()</code>, the location manager will cease to deliver any location updates to this delegate method. Also, note that <code>significantChangeReceivedCallback</code> is not removed after being calling. The reason for this is that the caller of <code>monitorSignificantChanges(_:)</code> is interested in continuous location updates, so any time this method is called, the <code>SignificantChangesViewController</code> view controller that initiated significant location change tracking should always be called.</p>
			<p>One last thing you need to do so that your app receives significant location changes while it's not in the foreground is to set the <code>allowsBackgroundLocationUpdates</code> property to <code>true</code>. Add the following line of code to the location helper's <code>init()</code>:</p>
			<pre>locationManager.allowsBackgroundLocationUpdates = true</pre>
			<p>In addition to <a id="_idIndexMarker588"/>subscribing to significant location changes or visits, you can also respond to the user entering or leaving a certain area wit<a id="_idTextAnchor439"/><a id="_idTextAnchor440"/><a id="_idTextAnchor441"/>h geofences.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor442"/>Setting up geofences</h1>
			<p>Sometimes, your app <a id="_idIndexMarker589"/>doesn't really need to know the details of the user's whereabouts. Sometimes, you're only interested in tracking whether the user has exited or left a certain area, in order to show certain content in your app or to unlock some kind of special feature. Core Location has great support for monitoring geofences. A <code>CLRegion</code> subclasses. Core Location provides two different region types that you can use:</p>
			<ul>
				<li><code>CLCircularRegion</code></li>
				<li><code>CLBeaconRegion</code></li>
			</ul>
			<p>A <code>CLCircularRegion</code> type is used to set up a geofence, as described before. A <code>CLBeaconRegion</code> type is used with physical BLE iBeacons, and essentially provides geofencing in a very small radius, for instance, just a couple of meters. In this section, you will learn how to set up a <code>CLCircularRegion</code> type that is set up around a user's first detected location. Setting up geofencing, or region monitoring, with both types of regions is very similar so all principles for monitoring a circular region also applies to beacon regions.</p>
			<p>If you look at the <code>GeofenceViewController</code>, you'll notice that it has a button labeled <code>@IBAction</code> for this button does quite a lot of the work already, but one key <a id="_idIndexMarker590"/>element is missing—it doesn't inform the location manager about the region that should be monitored. Add the following code to the end of <code>setGeofence()</code> in <code>GeofenceViewController</code>:</p>
			<pre>let region = CLCircularRegion(center: location.coordinate, radius: 30, identifier: "current-location-geofence") locationHelper.setGeofence(at: region, exitHandler, enterHandler)</pre>
			<p>The preceding code uses the location that was obtained from the user before and uses it to create a circular region with a radius of 30 meters. The identifier that is passed to the region should be an identifier that uniquely defines the region. If you reuse an identifier, Core Location will stop monitoring the old region with that identifier and will monitor the new region instead. For the LocationServices app this is perfect, but if you want your app to observe multiple regions, you must make sure every region has its own uniq<a id="_idTextAnchor443"/>ue identifier.</p>
			<p>Next, add the following implementation for <code>setGeofence(at:_:_:)</code> to the <code>LocationHelper</code>:</p>
			<pre>func setGeofence(at region: CLRegion, _ exitHandler: @escaping () -&gt; Void, _ enterHandler: @escaping () -&gt; Void) {
  guard CLLocationManager.isMonitoringAvailable(for: 
  CLCircularRegion.self) else { return }
  geofenceExitCallback = exitHandler
  geofenceEnterCallback = enterHandler
  locationManager.startMonitoring(for: region)
}</pre>
			<p>The preceding method is again very similar to the other location helper methods. Let's move right on to implementing the <code>CLocationManagerDelegate</code> methods that the location manager will call:</p>
			<pre>func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
  geofenceEnterCallback?()
}
func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
  geofenceExitCa<a id="_idTextAnchor444"/>llback?()
}</pre>
			<p>The<a id="_idIndexMarker591"/> preceding two methods are part of the <code>CLocationManagerDelegate</code> protocol and are called when a user enters or exits a certain area. Since there's no extra work to be done by the helper, the corresponding callbacks are immediately called so the <code>GeofenceViewController</code> can update its interface accordingly.</p>
			<p>Try opening the app and tapping the <strong class="bold">Set Geofence</strong> button. An orange circle should now appear on the map to visualize the geofence you have set up. If you exit or enter the region, the status label should update accordingly to show whether you have just entered or left the geofence. Note that it might take up to five minutes for iOS to properly register, monitor, and report updates about your geofence. Note that your user should have an active internet connection for region monitoring to <a id="_idTextAnchor445"/>work optimally.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor446"/>Summary</h1>
			<p>In this chapter, you have learned several techniques to obtain and respond to a user's location. You have implemented a <code>LocationHelper</code> class that provided a simple interface for view controllers to use the location manager that is contained in the helper. You learned about the best practices in the area of asking the user for access to their location data, and you have learned that asking for a user's location is a pretty privacy-sensitive question that shouldn't be asked without a good reason.</p>
			<p>You learned that there are different ways, each with different levels of detail, that you can use to track a user's location. You saw that you can subscribe to continuous changes, which has a bad impact on battery life. You also learned about subscribing to visits and significant location changes. In addition to learning about tracking a user's location, you also learned about monitoring whether a user has entered or exited a certain area by implementing geofencing. When you implement Core Location in your own apps, always make sure to keep the user's privacy in mind. If you don't really need the location data, then don't request access to it. And if you do, make sure to handle your user's location data with great care.</p>
			<p>In the next chapter, you will learn about the Combine framework and how you can use it to enhance your apps.</p>
		</div>
	</body></html>