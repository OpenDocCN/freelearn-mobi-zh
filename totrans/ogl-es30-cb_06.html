<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Shaders</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing the wobble and ripple effect</li><li class="listitem" style="list-style-type: disc">Procedural texture shading with object coordinates</li><li class="listitem" style="list-style-type: disc">Creating the circular pattern and making them revolve</li><li class="listitem" style="list-style-type: disc">Generating the brick pattern</li><li class="listitem" style="list-style-type: disc">Generating the polka dot pattern</li><li class="listitem" style="list-style-type: disc">Discarding fragments</li><li class="listitem" style="list-style-type: disc">Procedural texture shading with texture coordinates</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Introduction</h1></div></div></div><p>This chapter will give you an in-depth understanding of the shaders programming technique. It discusses various techniques that can be implemented by using the vertex and fragment shaders, revealing their capabilities. We will begin this chapter by understanding the role of shaders in the OpenGL ES 3.0 programmable pipeline. You will also learn how the vertex shader and fragment shaders process information on GPU Multicores.</p><p>You will learn how to deform the geometry shape by using the vertex shader; this will produce a wobble effect on 3D mesh models. With a little modification, we will use the same deforming concept to implement the pond water ripple effect. Further, we will understand the difference between the procedural and image texturing. With the help of model coordinates, we will implement our first simple procedural texturing recipe.</p><p>Drawing a circle-shaped geometry by using vertices may be too expensive to render because it requires too many vertices to form smoother edges; the circle shader recipe demonstrates an efficient way of rendering a circle that uses procedural texturing. The brick shader recipe demonstrates how to render a pattern of bricks on the surface of an object. Using the knowledge from the circle pattern, we will program how to render polka dots on 3D mesh objects. We will extend the same recipe to show an interesting feature of the GL shading language that allows us to produce holes in the 3D geometries by using discarded fragments. Finally, you will learn how to use texture coordinates to program procedural textures. With this knowledge, we will create a grid or cage like geometry on a 3D cube mesh object.</p><p>Shader role and responsibilities: The following figure illustrates the role of vertex and fragment shaders on two overlapped models to produce the final image on the screen; the expected output is marked as label 1. The graphics engine is provided with a rectangle-shaped model (four vertices) and a triangle-shaped model (three vertices). These models are first sent to the vertex shader. The vertex and fragment shader program has syntax, such as C programming language; the program's entry point always starts from the <code class="literal">main()</code> function.</p><p>The vertex shader is compiled and executed at runtime; it's invoked once for every vertex in the geometry, as shown in the following figure with labels <strong>2</strong> and <strong>3</strong>. Shader programs are executed on the multiprocessors GPUs, which allows manipulation of several vertices at the same time. The vertex shader is always executed first before the fragment shader.</p><p>There are mainly two goals of a vertex shader:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculating the transformation of the vertex coordinates</li><li class="listitem" style="list-style-type: disc">Calculating any per-vertex calculations required by the fragment shader<div><img src="img/5527OT_06_01.jpg" alt="Introduction"/></div></li></ul></div><p>A fragment shader is always executed after the vertex shader. Unlike vertex shaders, the fragment shader also contains a <code class="literal">main()</code> function as its entry point. The fragment shader is also compiled and executed at runtime for every single fragment; label <strong>4</strong> and label <strong>5</strong> shows the execution of the fragment shader on each fragment.</p><p>The image with label <strong>6</strong> shows the generated fragments after the rasterization process; the pixel is shown in the red box. Each fragment may or may not correspond to a single pixel in the primitive. A pixel in the framebuffer can be composed of one or more than one fragment, as shown in the following figure; using the fragment shader, these generated fragments can be controlled programmatically to assign color, texture, and other attribute information; each fragment has position, depth, and color associated with it.</p><p>The main goal of the fragment shader is to compute the color information for each fragment or discard the fragment according to the programing decision.</p><p>A fragment has the ability to perform the following tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Color interpolation or computation of every fragment</li><li class="listitem" style="list-style-type: disc">Texture coordinates computation</li><li class="listitem" style="list-style-type: disc">Texture assignment to every pixel</li><li class="listitem" style="list-style-type: disc">Normal interpolation for each pixel</li><li class="listitem" style="list-style-type: disc">Calculation of light information for every pixel</li><li class="listitem" style="list-style-type: disc">Animation effects computation</li></ul></div><p>The shaders concurrent execution model: The modern graphics engine architecture is capable of rendering high performance state-of-the-art graphics. Thanks to modern graphic processors that allow fast and parallel processing of large datasets at an incredible speed, this capability requires computation of a large dataset in a fraction of micro seconds. <strong>Graphics </strong><a id="id425" class="indexterm"/>
<strong>Processor Units</strong> (<strong>GPUs</strong>) are special dedicated processors made to fulfill these requirements; these processors are multicore where parallel processing can be achieved.</p><p>One of the major requirements of modern graphics is that it needs efficient floating-point calculations and fast polygon transformation operations. The GPU is optimized exclusively for these types of requirements; they provide a bunch of capabilities. Among these, it includes the fast trigonometric function, which is considered to be expensive on the CPU architecture. The number of processor cores in GPU can go from a few hundreds to thousands in number.</p><p>The following figure shows the concurrent execution on the GPUs for the vertex and fragment shader:</p><div><img src="img/5527OT_06_03.jpg" alt="Introduction"/></div><p>Each core of the GPU is capable of running an instance of the vertex or fragment shader; each core processes the vertices first and then the fragments, as shown in the preceding figure.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Implementing the wobble and ripple effect</h1></div></div></div><p>This is a first <a id="id426" class="indexterm"/>simple yet effective vertex shader technique that <a id="id427" class="indexterm"/>produces a wobbling effect on the object's geometry. This shader produces animation effects on the geometric shape like a sine wave; this effect is implemented within the vertex shader. This recipe also demonstrates another animation technique that produces a water pond ripple effect.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec159"/>Getting ready</h2></div></div></div><p>For this recipe, we will reuse the existing Phong shading recipe from the previous chapter. Rename the shader files with a name of your choice; for this recipe, we will rename these to <code class="literal">WobbleVertex.glsl</code> and <code class="literal">WobbleFragment.glsl</code>. The wobble and ripple shader are both vertex shader-based recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec160"/>How to do it...</h2></div></div></div><p>This section will provide the changes required to implement the vertex shader in order to produce the wobble effect. Modify the <code class="literal">WobbleVertex.glsl</code> as per the following code; there is no change required for the fragment shader:</p><div><pre class="programlisting">#version 300 es

// Define amplitude for Wobble Shader
#define AMPLITUDE           1.2

// Geometries vertex and normal information
layout(location = 0) in vec4  VertexPosition;
layout(location = 1) in vec3  Normal;

// Model View Project and Normal matrix
uniform mat4 ModelViewProjectionMatrix, ModelViewMatrix;
uniform mat3 NormalMatrix;

uniform float Time; // Timer

// Output variable for fragment shader
out vec3    nNormal, eyeCoord;

void main(){
    nNormal   = normalize ( NormalMatrix * Normal );
    eyeCoord  = vec3 ( ModelViewMatrix * VertexPosition );
    vec4 VertexCoord = VertexPosition;
    VertexCoord.y += sin(VertexCoord.x+Time)*AMPLITUDE;
    gl_Position = ModelViewProjectionMatrix * VertexCoord;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec161"/>How it works...</h2></div></div></div><p>A sine wave has a mathematical property of producing a smooth repetitive oscillation. The following figure shows the sine wave; the amplitude of sine wave defines the height or depth of the wave <a id="id428" class="indexterm"/>trough or crest, respectively. The wobble vertex shader <a id="id429" class="indexterm"/>displaces the Y component of each object vertex V (V<sub>x</sub>, V<sub>y</sub>, and V<sub>z</sub>) to produce the wobbling effect; the displacement is done using the sine function whose value always range between -1.0 and 1.0.</p><div><img src="img/5527OT_06_04.jpg" alt="How it works..."/></div><p>The uniform <code class="literal">Time</code> attribute variable is used for clock ticks. When these clock ticks are fed to the GLSL <code class="literal">sin()</code> function, it generates values ranging from -1.0 to 1.0. Each vertex's Y component (V<sub>y</sub>) is added to this sine value (<em>VertexCoord.y += sin(Time)</em>) to produce a hopping effect animation. Try this equation, it will make the object hop:</p><div><img src="img/5527OT_06_29.jpg" alt="How it works..."/></div><p>Further, in order to produce the wobble animation, take the X (V<sub>x</sub>) or Z (V<sub>z</sub>) component of each vertex into consideration to produce a wave like oscillation animation using (<em>VertexCoord.y += sin(VertexCoord.x + Time)</em>). Multiplying the Y (V<sub>y</sub>) component of the resultant with <code class="literal">AMPLITUDE</code> will affect the height of the wobbling wave animation:</p><div><img src="img/5527OT_06_26.jpg" alt="How it works..."/></div><p>With the new Y (V<sub>y</sub>) component of each vertex, the clip coordinates of the vertex are calculated by multiplying it with the <code class="literal">ModelViewProjection</code> matrix.</p><div><img src="img/5527OT_06_05.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec162"/>There's more...</h2></div></div></div><p>The wobble shader recipe <a id="id430" class="indexterm"/>also exhibits a pond water ripple animation, as <a id="id431" class="indexterm"/>shown in the preceding image in this section. Mathematically, the sine wave as a function of time is defined as follows:</p><div><img src="img/5527OT_06_27.jpg" alt="There's more..."/></div><p>Where <em>t</em> is the time, <em>A</em> is the amplitude of the wave, and <em>f</em> is the frequency. Using this formula, the ripple effect can be programmed as follows. The change in phase (<em>φ</em>) is assumed to be <em>t</em> here:</p><div><img src="img/5527OT_06_28.jpg" alt="There's more..."/></div><p>Modify the existing vertex shader according to the instructions given in the following code snippet, highlighted in bold:</p><div><pre class="programlisting">
<strong>#define RIPPLE_AMPLITUDE 0.05</strong>
<strong>#define FREQUENCY 5.0</strong>
<strong>#define PI 3.14285714286</strong>
void main(){
    nNormal   = normalize ( NormalMatrix * Normal );
    eyeCoord  = vec3 ( ModelViewMatrix * VertexPosition );
    vec4    VertexCoord = VertexPosition;
    float distance = length(VertexCoord);
<strong>    VertexCoord.y = sin( 2.0 * PI * distance * FREQUENCY + Time)</strong>
<strong>    * RIPPLE_AMPLITUDE;</strong>
    gl_Position = ModelViewProjectionMatrix * VertexCoord;
}</pre></div><p>The distance variable is used to calculate distances of each variable from its origin; this distance is calculated using the OpenGL ES shading language <code class="literal">length()</code> API. Finally, the clipped coordinates are calculated by taking product between the <code class="literal">VertexCoord</code> and <code class="literal">ModelViewProjection</code> matrix.</p><div><img src="img/5527OT_06_06.jpg" alt="There's more..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec163"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <a id="id432" class="indexterm"/><em>Phong shading – the per-fragment shading technique</em><a id="id433" class="indexterm"/> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Procedural texture shading with object coordinates</h1></div></div></div><p>In this <a id="id434" class="indexterm"/>recipe, you will learn how to <a id="id435" class="indexterm"/>produce a texture pattern on the surface of the 3D geometry with the help of procedural textures. Basically, texturing on a 2D/3D mesh object can be divided into two categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Procedural texturing</strong>: A procedure texture is an image or a texture produced mathematically using an algorithm; such algorithms use various attributes of a 2D/3D object to create an image; this type of texturing is highly controllable. Procedural texturing is used to create patterns, such as clouds, marble, wood, blending, noise, musgrave, voronoi, and so on.</li><li class="listitem" style="list-style-type: disc"><strong>Image texturing</strong>: In this type of texture, a static image is wrapped on the object; this image could be distorted on affine scaling transformation because this is a raster type of image. You will learn more about image texturing in the next chapter called textures.</li></ul></div><p>In this chapter, we will produce a number of procedural textures, with the help of object and texture <a id="id436" class="indexterm"/>coordinates. The current recipe <a id="id437" class="indexterm"/>makes use of object coordinates to demonstrate how it can be used to control fragment colors on a 3D model.</p><p>An object coordinate is a coordinate system in which the original shape of the object is defined. For example, the square in the following image is a 2 x 2 unit along the <em>x-z</em> plane; the origin is located in the middle of the square. The <em>x</em> axis and <em>z</em> axis divides the square into four quadrants around the origin. This recipe uses this logic to logically divide the mesh's 3D space into four quadrants, with each quadrant colored with a different color:</p><div><img src="img/5527OT_06_07.jpg" alt="Procedural texture shading with object coordinates"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec164"/>How to do it...</h2></div></div></div><p>Perform the following steps to implement this simple recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">SimpleVertexShader.glsl</code> and add it to the following code snippet:<div><pre class="programlisting">#version 300 es
// Vertex information
layout(location = 0) in vec4  VertexPosition;
layout(location = 1) in vec3  Normal;

// Model View Project and Normal matrix
uniform mat4 ModelViewProjectionMatrix, ModelViewMatrix;
uniform mat3    NormalMatrix;

// output variable to fragment shader
out vec3 nNormal, eyeCoord, ObjectCoord;

void main() {
    nNormal     = normalize ( NormalMatrix * Normal );
    eyeCoord    = vec3 (ModelViewMatrix * VertexPosition);
    ObjectCoord = VertexPosition.xyz;
    gl_Position = ModelViewProjectionMatrix * VertexPosition;
}</pre></div></li><li class="listitem">Modify <a id="id438" class="indexterm"/>the <code class="literal">SimpleFragmentShader.glsl</code> as follows:<div><pre class="programlisting">// Reuse the Light and Material properties. . 
in vec3 eyeCoord;    // Vertex eye coordinate
in vec3 ObjectCoord; // Vertex object coordinate 
layout(location = 0) out vec4 outColor;

vec3 PhongShading(){ 
  . . . . . .   // Reuse Phong shading code.
}

void main() {
    if (objectCoord.x  &gt; 0.0 &amp;&amp; objectCoord.z  &gt; 0.0)
        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);
    else if (objectCoord.x  &gt; 0.0  &amp;&amp; objectCoord.z  &lt; 0.0)
        FinalColor = vec4(0.0, 01.0, 0.0, 1.0);
    else if (objectCoord.x  &lt; 0.0  &amp;&amp; objectCoord.z  &gt; 0.0)
        FinalColor = vec4(0.0, 01.0, 1.0, 1.0);
    else if (objectCoord.x  &lt; 0.0  &amp;&amp; objectCoord.z  &lt; 0.0)
        FinalColor = vec4(1.0, 0.0, 1.0, 1.0);
    
    FinalColor = FinalColor  * vec4(PhongShading(), 1.0);
}</pre></div><div><img src="img/5527OT_06_08.jpg" alt="How to do it..."/></div></li></ol></div><p>The preceding figure <a id="id439" class="indexterm"/>shows the result of our simple procedural shader The models are divided into four quadrants along the <em>x-z</em> plane , with each quadrant shown in a different color. Use the single tap on the screen in order to switch between these models.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec165"/>How it works...</h2></div></div></div><p>The shader job <a id="id440" class="indexterm"/>starts from the vertex shader where object coordinates are received by the vertex program as a vertex attribute in the <code class="literal">VertexPosition</code> variable; this variable contains the vertex position in the local 3D space in which the object was defined. This value is stored in the <code class="literal">ObjectCoord</code> and passed on to the fragment shader. In the fragment shader, the object coordinate value is checked with the origin in order to test the quadrant to which it belongs to in the <em>x-z</em> plane. Depending on the quadrant outcome, a color is assigned to the fragment. The following image shows the division of 3D space into four quadrants using object coordinates:</p><div><img src="img/5527OT_06_09.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec166"/>There's more...</h2></div></div></div><p>The shader program does not provide any print statements that can be used for debugging purposes; one of the easiest solutions to debug coordinate values in the shader is to assign colors to fragments. If you are interested to deal with a coordinate range of a model in the 3D space, you can assign various colors using conditional statements. For example, if the previous fragment shader is replaced with the following code, it will render strips with various colors <a id="id441" class="indexterm"/>depending on <a id="id442" class="indexterm"/>the coordinate range:</p><div><pre class="programlisting">// Reuse the Light and Material properties. . 
in vec3 eyeCoord;    // Vertex eye coordinate
in vec3 ObjectCoord; // Vertex object coordinate 
layout(location = 0) out vec4 outColor;

vec3 PhongShading(){ 
  . . . . . .// Reuse Phong shading code.
}

void main() {
    //Debuging Shader with Model coordinates
    if (objectCoord.x  &gt; 0.9 )
        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);
    else if (objectCoord.x  &gt; 0.8 )
        FinalColor = vec4(1.0, 1.0, 0.0, 1.0);
    else if (objectCoord.x  &gt; 0.7 )
        FinalColor = vec4(1.0, 0.0, 1.0, 1.0);
    else if (objectCoord.x  &gt; 0.6 )
        FinalColor = vec4(0.60, 0.50, 0.40, 1.0);
    else if (objectCoord.x  &gt; 0.5 )
        FinalColor = vec4(0.30, 0.80, 0.90, 1.0);
    else
        FinalColor = vec4(1.0, 1.0, 1.0, 1.0);

    if (objectCoord.z  &gt; 0.9 )
        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);
    else if (objectCoord.z  &gt; 0.8 )
        FinalColor = vec4(1.0, 1.0, 0.0, 1.0);
    else if (objectCoord.z  &gt; 0.7 )
        FinalColor = vec4(1.0, 0.0, 1.0, 1.0);
    else if (objectCoord.z  &gt; 0.6 )
        FinalColor = vec4(0.60, 0.50, 0.40, 1.0);
    else if (objectCoord.z  &gt; 0.5 )
        FinalColor = vec4(0.30, 0.80, 0.90, 1.0);
    
    FinalColor = FinalColor  * vec4(PhongShading(), 1.0);
}</pre></div><div><img src="img/5527OT_06_10.jpg" alt="There's more..."/></div><p>Each unique <a id="id443" class="indexterm"/>color specifies a range of <a id="id444" class="indexterm"/>object coordinates along <em>x</em> or <em>z</em> axes. The following image shows that each color represents a band of 0.1 logical units from 0.5 to 1.0 units along the <em>x-z</em> plane:</p><div><img src="img/5527OT_06_11.jpg" alt="There's more..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec167"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Applying texture with UV mapping</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <em>Textures and Mapping Techniques</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Creating the circular pattern and making them revolve</h1></div></div></div><p>This procedural <a id="id445" class="indexterm"/>texture recipe will make use of fragment coordinates to demonstrate a circular pattern using <code class="literal">gl_FragCoord</code>. The <code class="literal">gl_FragCoord</code> is a keyword available in the fragment shader that is responsible to store the window position of the current fragment in <em>x</em> and <em>y </em>coordinates; the <em>z</em> coordinate stores the depth of the fragment in the range <code class="literal">[0, 1]</code>.</p><p>These coordinates are always relative to the OpenGL ES surface window; the <code class="literal">gl_FragCoords</code> is a result of a fixed functionality in which primitive are interpolated after the vertex processing stage to generate fragments. By default, the <code class="literal">gl_FragCoord</code> assumes the lower-left corner of the OpenGL ES rendering surface window as the origin. The following image shows the origin in the OpenGL ES surface window with different dimensions:</p><div><img src="img/5527OT_06_12.jpg" alt="Creating the circular pattern and making them revolve"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec168"/>How to do it...</h2></div></div></div><p>The light shading technique for this recipe will remain similar to the previous recipe; for more information, refer to the <em>Phong shading – the per-fragment shading technique</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em>. Create the <code class="literal">CircleVertexShader.glsl</code> vertex shader and reuse the code from previous recipe; for the <code class="literal">CircleFragmentShader.glsl</code> fragment shader, make the following changes:</p><div><pre class="programlisting">#version 300 es
// Reuse the variables . . . no change
vec3 PhongShading(){
   // Reuse Phong shading code.
   . . . . . .
   return ambient + diffuse + sIntensity * specular;
}

// Model and Dot color
uniform vec3 ModelColor, DotColor;

// Output color for fragment
layout(location = 0) out vec4 FinalColor;

// Size of the logical square
uniform float Side;

// Dot size 25% of Square size
float DotSize   = Side * 0.25;
vec2 Square     = vec2(Side, Side);

void main() {
    vec2 position = mod(gl_FragCoord.xy, Square) - Square*0.5;
    float length = length(position);
    float inside = step(length,DotSize);
    
    FinalColor = vec4(mix(ModelColor, DotColor, inside), 1.0);
    FinalColor = FinalColor * vec4(GouraudShading(), 1.0);
}</pre></div><p>The following <a id="id446" class="indexterm"/>image shows the output of this recipe:</p><div><img src="img/5527OT_06_13.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec169"/>How it works...</h2></div></div></div><p>For each fragment's window position received from <code class="literal">gl_Fragcoord</code>, it's manipulated by shifting the bottom-left coordinate to the center of the imaginary square region; this square region is used to inscribe a circle in it. The following code is responsible for displacing each <a id="id447" class="indexterm"/>coordinate relative to the center of the logical square, as shown in the following image:</p><div><pre class="programlisting">vec2 position = mod(gl_FragCoord.xy, Square) - Square*0.5;</pre></div><div><img src="img/5527OT_06_14.jpg" alt="How it works..."/></div><p>As the <code class="literal">position</code> is relative to the center of the imaginary square, we can calculate the distance of each coordinate from the center using the standard length formula in vector graphics. This length is used to render the fragment with the color of the circle, which is specified using the <code class="literal">DotColor</code>; if the length is smaller than the <code class="literal">DotSize</code>, then the body color is rendered using the <code class="literal">ModelColor</code>.</p><p>Mathematically, a circle is the locus of a point, which is always equidistant from a given point; as the origin is moved to the center, we can inscribe a circle within the square, as shown in the following figure. The coordinates falling under the circle can be rendered with <code class="literal">DotColor</code> to produce a circle pattern on the model. In order to check whether the length is greater or lesser than <code class="literal">DotSize</code>, we have used the <code class="literal">step()</code> GLSL API:</p><div><pre class="programlisting">   inside  = step(length,DotSize);</pre></div><div><img src="img/5527OT_06_15.jpg" alt="How it works..."/></div><p><strong>Syntax</strong>:</p><div><pre class="programlisting">float step(float edge, float x);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">edge</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the location of the edge of the step function</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">x</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the value to be used to generate the step function</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Return value</code></p>
</td><td style="text-align: left" valign="top">
<p>This step function returns 0.0 if x is smaller than edge; otherwise, it returns 1.0</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec170"/>There's more...</h2></div></div></div><p>The current <a id="id448" class="indexterm"/>implementation of the circle pattern is very static; it does not show any movement on the patterns of the circle. In this section, we will apply a general form of the 2D rotation matrix to perform a single rotation in the Euclidean space; the general form of the rotation matrix is:</p><div><img src="img/5527OT_06_30.jpg" alt="There's more..."/></div><p>Modify the existing fragment shader recipe to see the circular patterns rotation in action; the highlighted code is responsible for calculating the rotation matrix according to the 2D equation:</p><div><pre class="programlisting">uniform float   RadianAngle;
void main() {
    float cos  = cos(RadianAngle); // Calculate Cos of Theta
    float sin  = sin(RadianAngle); // Calculate Sin of Theta
    
    mat2 rotation  = mat2(cos, sin, -sin, cos);
    vec2 position  = mod( rotation * gl_FragCoord.xy, Square) 
    - Square*0.5;
    float length  = length(position);
    float inside  = step(length,DotSize);
    
    FinalColor = vec4(mix(ModelColor, DotColor, inside), 1.0);
    FinalColor = FinalColor * vec4(PhongShading(), 1.0);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec171"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Generating </em><a id="id449" class="indexterm"/><em>the polka dot pattern</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Generating the brick pattern</h1></div></div></div><p>The brick shader <a id="id450" class="indexterm"/>generates a pattern the bricks on the given surface of the 3D mesh object; this is another very good example of procedural texturing. The brick pattern is made up of two components (a brick and the mortar); these are represented using two different colors, as shown in the following figure. These colors are defined using <code class="literal">BrickColor</code> and <code class="literal">MortarColor</code> as the global variables in the vertex shader.</p><p>The rectangular size of the brick consists of brick and mortal materials; the total dimension of the rectangular region is 0.40 x 0.10 square units, out of which 90 percent of the horizontal dimension (0.40) is reserved for the dimension of the bricks along the <em>x</em> axis; the remaining 10 percent is used for the mortar along the same axis. Similarly, the brick vertical dimension is 85 percent along the <em>y</em> axis and the remaining 15 percent is used by the mortar's vertical dimension:</p><div><img src="img/5527OT_06_17.jpg" alt="Generating the brick pattern"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How to do it...</h2></div></div></div><p>Perform the following steps to implement the brick shader:</p><div><ol class="orderedlist arabic"><li class="listitem">Create <a id="id451" class="indexterm"/><code class="literal">BrickVertex.glsl</code> and reuse the code of the vertex shader from the previous recipe.</li><li class="listitem">Create <code class="literal">BrickFragment.glsl</code> and modify the following code:<div><pre class="programlisting">// Brick uniform parameters
uniform vec3  BrickColor, MortarColor;
uniform vec2  RectangularSize, BrickPercent;

// Object coordinates of the mesh
in vec3    ObjectCoord;

vec3 PhongShading(){ //Reuse code for Phong shading
   . . . . . .
   return ambient + diffuse + specular;
}

vec3  color;
vec2  position, useBrick;

void main() {
    position = ObjectCoord.xy / RectangularSize;
    
   // Displace rows alternately after 0.5 decimals
    if (fract(position.y * 0.5) &gt; 0.5){
        position.x += 0.5;
    }
    
    position = fract(position);
    useBrick = step(position, BrickPercent);
    color    = mix(MortarColor, BrickColor, 
                      useBrick.x * useBrick.y);
    FinalColor  = vec4(color * PhongShading(), 1.0);
}</pre></div></li><li class="listitem">Use the main <a id="id452" class="indexterm"/>program and specify the color for <code class="literal">BrickColor</code> and <code class="literal">MortarColor</code> uniform variables:<div><pre class="programlisting">    BrickColor = ProgramGetUniformLocation(program,"BrickColor");
    MortarColor= ProgramGetUniformLocation(program, "MortarColor");

    if (BrickColor &gt;= 0)
       {glUniform3f(BrickColor, 1.0, 0.3, 0.2 );}
    if (MortarColor &gt;= 0)
       {glUniform3f(MortarColor, 0.85, 0.86, 0.84);}</pre></div></li><li class="listitem">Similarly, specify the total rectangular size and brick percentage:<div><pre class="programlisting">    RectangularSize= ProgramGetUniformLocation(program,"RectangularSize");
    BrickPercent = ProgramGetUniformLocation(program,"BrickPercent");
    if (RectangularSize &gt;= 0)
       {glUniform2f(RectangularSize, 0.40, 0.10 );}
    if (BrickPercent &gt;= 0)
       {glUniform2f(BrickPercent, 0.90, 0.85 );}</pre></div><div><img src="img/5527OT_06_18.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec173"/>How it works...</h2></div></div></div><p>Each incoming object coordinate <code class="literal">ObjectCoord</code> in the fragment shader is divided by the <code class="literal">BrickSize</code>; the outcome position contains rows and columns of the brick to which <code class="literal">ObjectCoord</code> belongs. For each alternative row, the position of the brick is advanced by 0.5 units in the horizontal direction using the following code snippet in the program:</p><div><pre class="programlisting">    if (fract(position.y * 0.5) &gt; 0.5)
    {
        position.x += 0.5;
    }</pre></div><p>The <code class="literal">fract</code> GLSL API calculates the fractional part of the position and stores it in the <code class="literal">position</code> variable; as it's a fractional value, it must be in a range between 0.0 and 1.0; we must use this new value to compare it with <code class="literal">BrickPercent</code> using the GLSL step function. The step function takes two arguments, a threshold and a parameter against which the threshold needs <a id="id453" class="indexterm"/>to be compared; if the parameter value is less than the threshold value, the function return <code class="literal">0</code>; otherwise, it will return <code class="literal">1</code>:</p><div><pre class="programlisting">position = fract(position);
useBrick = step(position, BrickPercent);
color    = mix(MortarColor,BrickColor,useBrick.x * useBrick.y);</pre></div><p>The mix function mixes two colors using a weight parameter; this weight parameter in the current recipe is provided as a product between <code class="literal">useBrick.x</code> and <code class="literal">useBrick.y</code>. The resultant color is multiplied with <code class="literal">PhongShading()</code>, which produces the final light shading on the brick shader.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec174"/>There's more...</h2></div></div></div><p>The mix function that is used in the brick shader is responsible for performing linear interpolation between two given values based on the weight value.</p><p><strong>Syntax</strong>:</p><div><pre class="programlisting">genType mix(genType x, genType y, genType a);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">x</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the start of the range in which to interpolate</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">y</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the end of the range in which to interpolate</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">a</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the value to use to interpolate between x and y</p>
</td></tr></tbody></table></div><p>Mathematically, the <em>mix(x, y, and a)</em> function calculates the linear interpolation between <em>x</em> and <em>y,</em> using <code class="literal">a</code> as weight. The resultant value is computed as <em>x * (1 − a) + y * a</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec175"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Gouraud shading – the per-fragment shading technique</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Generating the polka dot pattern</h1></div></div></div><p>This recipe is <a id="id454" class="indexterm"/>another procedural texture, which is an extension of our circle pattern shader. In that recipe, we looked at the logic behind producing a 2D circle pattern on a planar surface; this planar surface was created using fragment coordinates. In this recipe, we will create a polka dot pattern on the surface of the 3D mesh object; the main difference here is that instead of producing a logical circle in the square, we will use an inscribed logical sphere within the logical cube of dimensions <strong>Side</strong> x <strong>Side</strong> x <strong>Side</strong> units:</p><div><img src="img/5527OT_06_19.jpg" alt="Generating the polka dot pattern"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec176"/>Getting ready</h2></div></div></div><p>In this recipe, we have reused the lighting technique using the <em>Implementing two-side shading</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em>. The generic vertex attributes for vertex positions, normals, and texture coordinates are laid out with 0, 1, and 2 indexes, respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec177"/>How to do it...</h2></div></div></div><p>Perform the following steps to implement the polka dot recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Create <code class="literal">PolkaDotsVertex.glsl</code> and reuse the code of the vertex shader from the previous recipe.</li><li class="listitem">Create <a id="id455" class="indexterm"/><code class="literal">PolkaDotsFragment.glsl</code>; edit the following fragment shader file:<div><pre class="programlisting">#version 300 es
precision mediump float;
layout(location = 0) out vec4 outColor;

in vec3  ObjectCoord;

// Size of the logical cube
uniform float Side;
uniform float DotSize;
vec3 Cube       = vec3(Side, Side, Side);
vec3 RenderColor= vec3(0.0, 0.0, 0.0);

// Front and Back face Model(mesh)/polka dot color
uniform vec3 ModelColor, DotColor, BackSideModelColor, BackSideDotColor;

void main() {

    float insideSphere, length;
    vec3 position = mod(ObjectCoord, Cube) – Cube*0.5;
    // Note: length() can also be used here
    length = sqrt( (position.x*position.x) +
    (position.y*position.y) + (position.z*position.z) );
    insideSphere = step(length,DotSize);
   
    // Determine color based on front/back shading
 if (gl_FrontFacing){){           
   RenderColor=vec3(mix(ModelColor,DotColor,insideSphere));
       outColor = vec4(RenderColor , 1.0);
    }
    else{
       RenderColor==vec3(mix(BackSideModelColor,BackSideDotColor, insideSphere));
        outColor = vec4(RenderColor, 1.0);
    }
}</pre></div><p>The following image shows the output of the polka shader on various 3D mesh models; among these, the hollow cylinder shows the two-sided shading technique, where the inside and outside faces are rendered with different color polka dots from inside and outside:</p><div><img src="img/5527OT_06_20.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec178"/>How it works...</h2></div></div></div><p>The polka dot shader uses object coordinates to produce polka dot on the surface of the mesh model; these <a id="id456" class="indexterm"/>object coordinates are shared by the vertex shader in the form of the <code class="literal">ObjectCoord</code> input vertex attribute variable. A modulus operation is performed on  <code class="literal">ObjectCoord</code> using the <code class="literal">Cube</code> variable, which is a <code class="literal">vec3</code> of <code class="literal">Side</code>. This results in a logical cube, which is further subtracted by the half cube dimension in order to bring the origin at the center of the logical cube:</p><div><pre class="programlisting">    vec3 position = mod(ObjectCoord, Cube) - Cube/0.5;</pre></div><p>Calculating the distance of the translated <code class="literal">ObjectCoord</code> with respect to this center will provide the length of the position vector from the translated origin:</p><div><pre class="programlisting">length = sqrt( (position.x*position.x) +
 (position.y*position.y)+(position.z*position.z));</pre></div><p>Finally, the length is compared with the <code class="literal">DotSize</code> using the GLSL step function in order to check whether it's inside the imaginary sphere of the <code class="literal">DotSize</code> radius or not:</p><div><pre class="programlisting">    insideSphere = step(length,DotSize);</pre></div><p>Depending on the outcome of the <code class="literal">insideSphere</code>, the color value is assigned to the body and polka dots; the colors used for the front face are different from the color used for back faces in order to exhibit the two-side shading.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec179"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Implementing two-side shading</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em></li><li class="listitem" style="list-style-type: disc"><em>Procedural texture shading with object coordinates</em></li><li class="listitem" style="list-style-type: disc"><em>Creating the circular pattern and making them revolve</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Discarding fragments</h1></div></div></div><p>The OpenGL ES <a id="id457" class="indexterm"/>shading language provides an important feature of discarding fragments using the <code class="literal">discard</code> keyword; this keyword is used only in the fragment shader to prevent updating the framebuffer. In other words, using this keyword throws away the current fragment and stops execution of the fragment shader. This feature of the OpenGL ES shading language is a simple yet effective feature, which opens up possibilities of producing cross-sectional views of 3D geometries, holes, or perforated surfaces.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec180"/>Getting ready</h2></div></div></div><p>This recipe reuses the last recipe; this requires a few changes in the fragment shader to demonstrate discarded fragment capabilities.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec181"/>How to do it...</h2></div></div></div><p>Rename the polka shader vertex and the fragment shader file as <code class="literal">DiscardFragVertex.glsl</code> and <code class="literal">DiscardFragFragment.glsl</code>. Open the fragment shader file and add the highlighted code:</p><div><pre class="programlisting">#version 300 es
<strong>// Many lines skipped . . . </strong>
layout(location = 0) out vec4 FinalColor;
vec3 GouraudShading( bool frontSide )
{
<strong>   // Reuse two sides shade recipe PhongShading code here</strong>
   return ambient + diffuse + specular;
}

in vec3  ObjectCoord;
uniform float Side, DotSize;
vec3 Square     = vec3(Side, Side, Side);
vec3 RenderColor;

<strong>// Front and Back face polka dot color</strong>
uniform vec3 ModelColor, DotColor, BackSideModelColor, BackSideDotColor;

<strong>// Variable for toggling the use of discard keyword</strong>
<strong>uniform int toggleDiscardBehaviour;</strong>

void main() {

    float insideCircle, length;
    vec3 position = mod(ObjectCoord, Square) - Square/2.0;

   length = sqrt( (position.x*position.x) +
          (position.y*position.y)+(position.z*position.z));
    insideCircle      = step(length,DotSize);
    
<strong>    // The toggleDiscardBehaviour change the behavior</strong>
<strong>    // automatically after fixed interval time.</strong>
<strong>    // The timer is controlled from the OpenGL ES program.</strong>
<strong>    if(toggleDiscardBehaviour == 0){</strong>
<strong>            if (insideCircle != 0.0)</strong>
<strong>               discard;</strong>
<strong>    }</strong>
<strong>    else{</strong>
<strong>             if (insideCircle == 0.0)</strong>
<strong>               discard;</strong>
<strong>    }</strong>
<strong>   </strong>
<strong>    // Determine final color based on front and back shading</strong>
    if (gl_FrontFacing){
     RenderColor = vec3(mix( ModelColor, DotColor, insideCircle));
     FinalColor = vec4(RenderColor * PhongShading(true), 1.0);
    }
    else{
     RenderColor=vec3(mix(BackSideModelColor, 
     BackSideDotColor, insideCircle));
     FinalColor=vec4(RenderColor * PhongShading(false), 1.0);
    }
}</pre></div><div><img src="img/5527OT_06_21.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec182"/>How it works...</h2></div></div></div><p>The preceding output shows the application of the discard keyword in the polka fragment shader program. In this <a id="id458" class="indexterm"/>recipe, fragments are judged on the basis of the <code class="literal">insideCircle</code> variable. This variable checks whether the fragment is falling inside the circle or outside the circle. If it's falling inside the circle, then the fragment is thrown away; this results in a perforated look, as shown in the previous image.</p><p>In the vice versa condition, fragments residing outside of the circle are discarded, as shown in previous images. In general, it's not advisable to use the <code class="literal">discard</code> keyword extensively because it increases the overhead on the graphics pipeline to perform additional operations. According to Imagination Technologies, for PowerVR architecture, it advises limited use of the <code class="literal">discard</code> keyword in programming practices. Although this is very much dependent on the application itself, it's advisable to profile your application to see whether the <code class="literal">discard</code> produces a significant loss in its performance.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec183"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Generating the polka dot pattern</em></li><li class="listitem" style="list-style-type: disc"><em>Procedural texture shading with texture coordinates</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Procedural texture shading with texture coordinates</h1></div></div></div><p>Texture <a id="id459" class="indexterm"/>coordinates control the wrapping <a id="id460" class="indexterm"/>of texture on the surface of a model; these are 2D coordinates used to map texture on the 3D surface of the geometry. Texture coordinates are mapped to a different coordinate system called <strong>UV</strong> Mapping. Letters <strong>U</strong> and <strong>V</strong> denote the axis of the texture along the <em>x</em> and <em>y</em> axis, respectively:</p><div><img src="img/5527OT_06_22.jpg" alt="Procedural texture shading with texture coordinates"/></div><p>The preceding extreme left image shows an icon that needs to be mapped to a blue-colored square of some arbitrary dimension. An image (irrespective of its dimensions) is always treated in the UV mapping between a range of 0 to 1 along the U and V axis, respectively. Therefore, the bottom-left image is always <strong>(0, 0)</strong> and the top-left image is <strong>(1, 1)</strong>; there is no need to assign these values in the OpenGL ES program. By default, it's understood by the graphics pipeline.</p><p>What needs to be mentioned is the texture coordinates of the 2D/3D model; for example; in the previous image, the blue color square is assigned with four UV coordinates, which shows how the image is going to be completely mapped to the surface of the square:</p><div><img src="img/5527OT_06_23.jpg" alt="Procedural texture shading with texture coordinates"/></div><p>In the preceding image, the blue-colored square is assigned with new texture coordinates with bottom-left and top-right at (0, 0) and (0.5, 1), respectively; the resultant mapped image is shown in the right-hand side corner, where we can clearly see that new texture coordinates are pasted on half of the image along the <em>U</em> axis.</p><p>Texture coordinates are compulsory for image-based texturing; however, they are not must for procedural <a id="id461" class="indexterm"/>texturing. Texture <a id="id462" class="indexterm"/>coordinates in procedural texturing have their own importance and their applications are endless. This recipe will demonstrate one of the applications of texture coordinates, where a grid like procedural texture is produced on the surface of a 3D cube mesh model. For more information on UV Mapping and its related application, refer to the next chapter.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec184"/>Getting ready</h2></div></div></div><p>For this recipe, the mesh model must contain texture coordinates information. For more information on how to create Wavefront object models with texture coordinates, refer to <a class="link" href="ch08.html" title="Chapter 8. Font Rendering">Chapter 8</a>, <em>Working with Meshes</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec185"/>How to do it...</h2></div></div></div><p>In order to implement this recipe, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">GridVertex.glsl</code> vertex shader program and add the following code:<div><pre class="programlisting">#version 300 es
// Vertex layout information
layout(location = 0) in vec4  VertexPosition;
layout(location = 1) in vec3  Normal;
layout(location = 2) in vec2  TexCoords;


// Model View Projection Normal matrix
uniform mat4    ModelViewProjectionMatrix, ModelViewMatrix;
uniform mat3    NormalMatrix;

out vec3    nNormal, eyeCoord;
out vec2    TextureCoord;

void main()
{
    nNormal      = normalize ( NormalMatrix * Normal );
    eyeCoord     = vec3 ( ModelViewMatrix * VertexPosition );
    TextureCoord = TexCoords;
    
    gl_Position = ModelViewProjectionMatrix * VertexPosition;
}</pre></div></li><li class="listitem">For the programming grid shader, we need to make changes in the fragment shader. Create <a id="id463" class="indexterm"/>a new fragment <a id="id464" class="indexterm"/>shader file called <code class="literal">GridFragment.glsl</code> and use the following code:<div><pre class="programlisting">vec3 PhongShading( bool frontSide ){
   // Reuse the Phong shading code.
   return ambient + diffuse + specular;
}

in vec2    TextureCoord;
layout(location = 0) out vec4 FinalColor;

   // Scale factor of the texture coord &amp; Grid strip width
   uniform float texCoordMultiplyFactor, stripWidth;  

void main() {
   // multiplicationFactor scales number of stripes
   vec2 t = TextureCoord * texCoordMultiplyFactor;

   // The stripWidth is used to define the line width
   if (fract(t.s) &lt; stripWidth  || fract(t.t) &lt; stripWidth ){
   // Front Face coloring
      if (gl_FrontFacing){ 
         FinalColor = vec4(PhongShading(true), 1.0);
      }
      // Back Face coloring
      else{ 
          FinalColor = vec4(GouraudShading(false), 1.0);
      }
   }
      // Throw the fragment
      else{ 
      discard;
   }
}</pre></div><div><img src="img/5527OT_06_24.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec186"/>How it works...</h2></div></div></div><p>The vertex shader receives texture coordinates from the OpenGL ES program in the <code class="literal">TexCoord</code> vertex attribute; this attribute is defined with index <strong>2</strong> as the layout location. Texture coordinates <a id="id465" class="indexterm"/>are passed on to the <a id="id466" class="indexterm"/>fragment shader as an out variable using <code class="literal">TextureCoord</code>. In this recipe, we have used a cube made of six square faces; each of these faces has texture coordinates defined in the UV mapping. Each of these UV mapping coordinates is multiplied by a multiplier factor variable called <code class="literal">texCoordMultiplyFactor</code>, which produces surface mapping coordinates called <strong>ST</strong> coordinates. Note that ST coordinates are logical coordinates, which are used to create surface mapping calculations; in many places, both are used interchangeably:</p><div><pre class="programlisting">vec2 t = TextureCoord * texCoordMultiplyFactor;</pre></div><div><img src="img/5527OT_06_25.jpg" alt="How it works..."/></div><p>The practical significance of <code class="literal">texCoordMultiplyFactor</code> is to define the number of strips along horizontal and vertical dimensions. The width of the strip is controlled by the <code class="literal">stripWidth</code> variable. As coordinates are converted to ST mapping, we can now assume that there are 10 strips along the horizontal and vertical axis and each strip is <strong>1</strong> unit wide. The stripWidth is compared against ST coordinate fractional values using the GLSL <code class="literal">frac()</code> API; this <a id="id467" class="indexterm"/>API returns the fractional <a id="id468" class="indexterm"/>value of the decimal number. If the fractional values are greater than the <code class="literal">stripWidth</code>, then they are discarded; otherwise, depending on the front and back facing of the fragment, they are assigned with colors:</p><div><pre class="programlisting">   if (fract(t.s) &lt; stripWidth  || fract(t.t) &lt; stripWidth ){
   //Front Face coloring  
   if (gl_FrontFacing) 
   { outColor = vec4( GouraudShadingGouraud(true), 1.0); }
   //Back Face coloring 
   else{ 
   { outColor = vec4( GouraudShadingGouraud(false), 1.0); }
   }
   // Throw the fragment 
   else{ 
   discard;
   }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec187"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Implementing two-side shading</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <em>Light and Materials</em></li><li class="listitem" style="list-style-type: disc"><em>Discarding fragments</em></li><li class="listitem" style="list-style-type: disc">Refer to the <em>Applying texture with UV mapping</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <em>Textures and Mapping Techniques</em></li></ul></div></div></div></body></html>