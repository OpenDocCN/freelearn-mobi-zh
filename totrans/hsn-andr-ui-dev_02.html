<html><head></head><body>
        

                            
                    <h1 class="header-title">Designing Form Screens</h1>
                
            
            
                
<p class="mce-root">Form screens are an essential part of user interface design in many ways because their history is a lesson in how not to do things. Most applications need to capture input from their users at some point, and you need input widgets for that, but you should always consider the minimum amount of information you need to ask the user for, rather than try to get all the information you may need in the future. This approach will keep the user focused on the task they are trying to carry out. Presenting them with a wall of input fields is overwhelming to most users and breaks their focus, which in turn can lead to them abandoning what they were trying to do with your application.</p>
<p class="mce-root">This chapter is focused on form screens, and will walk you through a bit of their history before diving into a method for actually designing form screens. This approach can and should be reused whenever you need to design a screen for an app. It's always important to take a step back from your code work and consider how things will look and fit together for the user; it's often the difference between a successful app and failure.</p>
<p class="mce-root">In this chapter, we'll develop a practical form screen using Android Studio and the layout editor. Starting from an empty template in a new project, you'll learn the following:</p>
<ul>
<li>How to break up and then arrange a form layout to be most effective for your users</li>
<li>How to use resources to keep your user interface consistent</li>
<li>How to style widgets to help the user understand what the widget should be used for</li>
<li>How to build drawable resources that respond to state changes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring form screens</h1>
                
            
            
                
<p class="mce-root">While not the most glamorous component of an application's user experience, form screens are a long-time staple of software. A form screen can be defined as any screen where the user is expected to explicitly enter or change data, as opposed to viewing or navigating it. Good examples of form screens are login screens, edit profile screens, or the add contact screen from a phonebook app. Over the years, the idea of what constitutes a good form screen has changed, with some people going as far as to shun them completely. However, you can't capture the user's data out of thin air.</p>
<p class="mce-root">The Android standard toolkit provides an excellent and diverse collection of widgets and layout structures to facilitate building excellent forms, and in Material Design applications, form screens can often double as a <em>view</em> screen (what will usually be a read-only version of the form screen) thanks to the placement of labels. A good way to understand this principle is to consider the evolution of textboxes. As soon as you have a blank space to be filled by your user, you need to tell the user what to put there, and when we started labeling textboxes, we simply copied how we did this on paper forms--by putting a label to the one side of the textbox:</p>
<div><img src="img/eb41dffa-4a42-4750-9e74-d38408ce5176.png"/></div>
<p class="mce-root">The issue with this is that the label always takes up quite a bit of space, and takes up even more if you need to include some validation rules for the user (such as date inputs--DD/MM/YYYY). This is where we started adding hints to the input boxes. The label will explain what to add in the Date of Birth textbox, and a hint within the textbox will tell the user how to input valid data:</p>
<div><img src="img/9ecff562-332e-4c1f-96a7-d9d3f4ff9797.png"/></div>
<p class="mce-root">From this pattern, many mobile applications began to drop the label completely and instead used the hint/placeholder to contain the data on the theory that from the context of the form, the user will be able to infer what data was in each of the textboxes. However, this means that the user has to do a bit of extra thinking in order to make sense of the screen when they see it for the first time. This extra delay can quickly turn to frustration, and reduces how usable your application is. For this reason, Material Design text inputs turn their hints into small labels that move above the textbox when the user focuses on the textbox, making it easier for them to keep track of what information they are entering:</p>
<div><img height="87" width="373" src="img/95a44133-8920-4198-9ac4-87937a650d97.png"/></div>
<p class="mce-root">This also reduces the amount of work that needs to be done on form screens as a developer, because you typically won't need to separate the <em>view</em> and <em>edit</em> screens of your application, since the form will always have all of its labeling available. However, it's important to avoid overcrowding your screens with input widgets. Nobody likes to have to fill in lots of data, even if most of it is optional. Instead, always consider the minimum amount of data you need from your user at each point in your application. It's also important to consider how you will ask the user for their data.</p>
<p class="mce-root">We'll start our first form screen as an information capturing screen. We'll be building an imaginary app to track someone's travel expenses, allowing them to capture, tag, and store each of their expenses to be filtered and reviewed later. The first thing we need is a screen where the user can capture an expense and any additional information that goes with it.</p>
<p class="mce-root">As best as possible, you should make input fields optional, but you can always encourage people to give more data by telling them how complete something is. This is a common technique when dealing with a user profile--"Your profile is 50% complete", helps encourage the user to provide more data to raise that number. This is a simple form of gamification, but it's also very effective.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing a layout</h1>
                
            
            
                
<p class="mce-root">Good user interface design is rooted in some simple rules, and there are processes you can follow to design a great user interface. For example, imagine that you're building an app to capture travel expenses so that they can be claimed easily at a later time. The foremost thing we'll build over here is the screen that captures the details of a single claim. This is a perfect example of a modern form screen design.</p>
<p>When designing a layout, it's a good idea to use a mockup tool such as Balsamiq (<a href="https://balsamiq.com/" target="_blank">https://balsamiq.com/</a>), or even paper and pencil to think about the layout of the screen. Physical index cards make excellent thinking spaces as they have similar proportions to a phone or tablet. Using paper, especially, helps you think about the arrangement of the screen instead of being distracted by the exact colors, fonts, and spacing that should be dealt with in a common set of theming rules.</p>
<p class="mce-root">To start designing the screen, we need to consider what data we'll need from the user and how we might be able to fill some of it out for them. We also need to try and stick to the platform design language so that the application doesn't feel out of place to the user. It's also important when designing form screens to ensure that the entire input form will fit onto the device's display. Scrolling an input screen requires your user to remember what is not on the screen, and causes frustration and anxiety. Whenever you design a form screen, ensure that all the inputs will fit onto one display. If they don't all immediately fit onto the display together, first consider whether you can remove some of them. After removing any that aren't absolutely required, consider grouping some on a single line, ensuring that you put no more than two inputs per line. More than two input fields on a single line implies that you can probably turn them into a single input.</p>
<p class="mce-root">So, to get started, consider what information a user will want to capture for a travel expense:</p>
<ul>
<li>How much the expense was</li>
<li>Some photos of the invoice, or maybe of the item purchased</li>
<li>The date that they captured the expense on</li>
<li>What sort of expense they're capturing such as food, transport, accommodation, and more</li>
<li>A short description to help them remember what the expense was</li>
</ul>
<p class="mce-root">Great, that seems like a good starting point, but they're not in a great order and they're not grouped at all. We need to consider what is most important, and what groups logically fit together well on-screen. For starters, let's focus on developing a portrait layout for a phone, since that will be our most common use case. So, the next thing to do is group the input components in a way that will feel logical and familiar to a user. When looking at an overview of claims, the things we'll want to list are as follows:</p>
<ul>
<li>The date of the expense:
<ul>
<li>The date that they captured the expense on</li>
</ul>
</li>
<li>The amount the claim is for:
<ul>
<li>How much the expense was</li>
<li>Some photos of the invoice, or maybe of the item purchased</li>
</ul>
</li>
<li>The description of the claim:
<ul>
<li>What sort of expense they're capturing such as food, transport, accommodation, and more</li>
<li>A short description to help them remember what the expense was</li>
</ul>
</li>
</ul>
<p class="mce-root">So, we'll group these three fields together, and put them at the top of the screen. This particular grouping will feel common to anyone who has used any budget or expense tracking software:</p>
<div><img height="94" width="328" src="img/c4ed0cd5-76ce-46f6-b639-2972e08b2ccb.jpg"/></div>
<p class="mce-root">The Date is a special field, because we can easily populate it with the current date. It's most likely when the user enters this screen that they are capturing an expense for the same day. We still need to capture a category and attachments for the expense. Attachments will need a large amount of space so that the user can preview them without having to open each one to know what it is, so we'll put them at the bottom of the screen and have them take any space left over. That just leaves the category. The expense categories are best represented using icons, but we need some space for text so that the user knows what each icon means. We can do this in one of several ways:</p>
<ol>
<li style="font-weight: 400">Place a tiny label above or below each icon:
<ul>
<li style="font-weight: 400">Pros: All the labels are always on the screen</li>
<li style="font-weight: 400">Cons: The labels can be hard to read on smaller screens, and the icons take up more screen space:</li>
</ul>
</li>
</ol>
<div><img height="52" width="247" src="img/8d94c91b-2f0d-4ec2-b066-3dfeba6297e1.jpg"/></div>
<ol start="2">
<li style="font-weight: 400">Create a vertical list of icons and put a nice large label to the right of each:
<ul>
<li style="font-weight: 400">Pros: The labels are easy to read, and always associated with their icons</li>
<li style="font-weight: 400">Cons: This will take up lots of the vertical space that is best used to display attachment previews:</li>
</ul>
</li>
</ol>
<div><img height="98" width="265" src="img/e517b489-32be-4772-99ef-1ef8a78a5ebd.jpg"/></div>
<ol start="3">
<li style="font-weight: 400">Show only the icons, and display the label when the user holds their finger over the icon (long presses):
<ul>
<li style="font-weight: 400">Pros: The text takes up no screen space</li>
<li style="font-weight: 400">Cons: This sort of behavior is not intuitive to users, and requires that the user selects the category to know what its label is:</li>
</ul>
</li>
</ol>
<div><img height="102" width="187" src="img/cf46ea5b-a70f-468b-843b-17b09980ffc6.jpg"/></div>
<ol start="4">
<li style="font-weight: 400">Show the list of icons and the text of the selected category below them:
<ul>
<li style="font-weight: 400">Pros: The text label can be large and easy to read, and takes up less screen space because only one label is shown at a time</li>
<li style="font-weight: 400">Cons: The user must select the category to know what its label is:</li>
</ul>
</li>
</ol>
<div><img height="82" width="209" src="img/2c7ec26d-e032-4100-aeac-1081746871b6.jpg"/></div>
<p class="mce-root">In order to keep the label in a nice, easily readable size, while also drawing extra attention to which category is currently selected, this example will show you how to create option four, where the currently selected category name is shown below a horizontal list of the category icons. We'll also highlight the selected icon to help keep a connection between the two user interface elements.</p>
<p class="mce-root">The one remaining thing that the user needs to be able to do is attach files to the expense claim before saving it. There should be a nice, large area at the bottom of this layout that will make a perfect area to preview a single attachment, and if the user has more than one attachment, they can swipe left and right to switch between their previews. However, how can they attach them in the first place? This is where a floating action button is an ideal solution. You'll see floating action buttons everywhere in Android applications. They are usually near the bottom-right of the screen, where a right-handed person will have their thumb if they hold the phone one-handed, and out of the way of most Western content, which will be to the left of the screen (normally):</p>
<div><img height="104" width="198" src="img/3639b7e8-e1db-47ae-b77e-d3f8d6d9a22f.png"/></div>
<div><p>Floating action buttons are normally the most common <em>creative</em> (as opposed to navigation or destructive) actions on the screen; for example, creating a new email in the Gmail or Inbox app, attaching a file, and so on.</p>
</div>
<p class="mce-root">So now, we have the screen broken down into three logical areas, outside of the normal decorations:</p>
<ul>
<li style="font-weight: 400">Claim details</li>
<li style="font-weight: 400">Categorization</li>
<li style="font-weight: 400">Attachment</li>
</ul>
<p class="mce-root">Putting them together into a single screen layout concept gives you a wireframe, looking something like this:</p>
<div><img height="452" width="306" src="img/8ded7bee-080c-4948-8697-efde533a8904.jpg"/></div>
<p class="mce-root">This exercise of wireframing your screens before you start developing them is an extremely valuable phase, because it gives you time and space to think about each of the choices you could be making, rather than just grabbing the first available widgets in the toolbox and putting them onto the screen. Now that you have a wireframe, you're ready to get started with building the user interface for the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a form layout</h1>
                
            
            
                
<p class="mce-root">Once you have a good wireframe to work from, you'll want to start developing the user interface screen. For this, we'll use Android Studio and its wonderful layout editor.</p>
<p class="mce-root">Since this is a brand new project, you'll need to open Android Studio and use File | New | New Project to get it started. Then, follow these steps:</p>
<ol>
<li style="font-weight: 400">Name the project <kbd>Claim</kbd>, and leave any non-Java support turned off.</li>
<li style="font-weight: 400">Target Android 4.1 on Phone &amp; Tablet only.</li>
<li style="font-weight: 400">In the Activity Gallery, choose the Basic Activity:</li>
</ol>
<div><img src="img/d0e29400-99c6-4672-af9b-07e1fa947b2c.png"/></div>
<ol start="4">
<li>Name the new Activity <kbd>CaptureClaimActivity</kbd>, and then change the title to <kbd>Capture Claim</kbd>. Leave the other parameters at their default values:</li>
</ol>
<div><img src="img/41766382-ac9d-4d3f-b977-6246b36c08eb.png"/></div>
<ol start="5">
<li style="font-weight: 400">Finish the New Project wizard, and wait for the project to be generated.</li>
<li style="font-weight: 400">When the project has been generated and synchronized, Android Studio will open the <kbd>content_capture_claim.xml</kbd> file in its layout editor.</li>
</ol>
<ol start="7">
<li style="font-weight: 400">By default, Android Studio assumes that you will be using a <kbd>ConstraintLayout</kbd> as the root of your layout. This is an incredibly powerful and flexible tool, but also not well suited as the root element of this user interface. You'll need to switch over to the Text view at the bottom of the screen in order to change to something more suitable:</li>
</ol>
<div><img src="img/2abfbd02-580d-491d-8a80-72cd70a30a66.png"/></div>
<ol start="8">
<li>The file will currently have something like the following XML in place:</li>
</ol>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;<strong>android.support.constraint.ConstraintLayout</strong> <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    app:layout_behavior="@string/appbar_scrolling_view_behavior"<br/>    tools:context="com.packtpub.claim.CaptureClaimActivity"<br/>    tools:showIn="@layout/activity_capture_claim"&gt;<br/><br/>    &lt;TextView<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Hello World!"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintLeft_toLeftOf="parent"<br/>        app:layout_constraintRight_toRightOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<ol start="9">
<li>Change the <kbd>ConstraintLayout</kbd> to a simple <kbd>LinearLayout</kbd>. <kbd>LinearLayout</kbd> is one of the simplest layouts available on Android. It renders each of its children in a straight line, either horizontal or vertical, depending on its orientation attribute. Replace the whole of the <kbd>content_capture_claim.xml</kbd> file with the following content:</li>
</ol>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:orientation="vertical"<br/>    app:layout_behavior="@string/appbar_scrolling_view_behavior"<br/>    tools:context="com.packtpub.claim.CaptureClaimActivity"<br/>    tools:showIn="@layout/activity_capture_claim"&gt;<br/> <br/>&lt;/LinearLayout&gt;</pre>
<p>Choosing the right layout to use is about more than just keeping your code simple; less flexible layouts are much faster at runtime and lead to a much smoother user experience. Try to stick to simpler layouts where possible, but also avoid nesting layouts too deep (one inside the other), as this also leads to performance problems.</p>
<ol start="10">
<li>Change back to the Design view in the layout editor, and you'll notice that the Component Tree to the left of the design view now has a LinearLayout (vertical) as its only component.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the description box</h1>
                
            
            
                
<p class="mce-root">Now that the base layout is set up, it's time to start adding the widgets to the user interface and make it useful. In this next stage, you'll be using several Material Design widgets that help produce great user interfaces, such as <strong>CardView</strong> and the <strong>TextInputLayout</strong> widget. Before Material Design, text input boxes were just plain <kbd>EditText</kbd> widgets, which while still available, are now generally discouraged in favor of a <kbd>TextInputLayout</kbd>. The <kbd>TextInputLayout</kbd> is a specialized layout that contains a single <kbd>EditText</kbd> widget for the user to enter text data. The <kbd>TextInputLayout</kbd> then also provides the floating hint/label effect and animations, transitioning the <kbd>EditText</kbd> widgets hint to a label space just above the input area. This means that even when the user has filled in the text, the hint for the <kbd>EditText</kbd> is still visible above their input:</p>
<div><img height="60" width="254" src="img/2fcc694c-5e37-49f1-a91f-3f3da355b179.png"/></div>
<p>You'll be wrapping this first group of widgets in a <kbd>CardView</kbd>, which will serve as a visual grouping for the user. Follow these steps to add the description input box:</p>
<ol>
<li>Open the AppCompat section of the Widget Palette. This contains widgets that come from special APIs that are parts of the extended Android platform. They're not included on the platform by default, and instead, are included in each application they are used in, a bit like static linking a library.</li>
<li>Drag and drop a <kbd>CardView</kbd> into your user interface design; you can drop it anywhere on the design canvas. This will serve as the grouping for the description, amount, and date input boxes. Ensure that in the Component Tree, the <kbd>CardView</kbd> appears as a child of the LinearLayout (vertical):</li>
</ol>
<div><img height="257" width="213" src="img/52c6a273-04a3-481d-88f9-caa6497d07d8.png"/></div>
<ol start="3">
<li>A <kbd>CardView</kbd> stacks its widgets on top of each other in layers (back to front). This is not what's needed in this case, so you'll need to open the Layouts section of the <kbd>Palette</kbd> and drag a <kbd>ConstraintLayout</kbd> into the <kbd>CardView</kbd> on your design. Ensure that in the Component Tree, the <kbd>ConstraintLayout</kbd> appears as a child of the <kbd>CardView</kbd>.</li>
<li>Select the new <kbd>ConstraintLayout</kbd> in the Component Tree.</li>
</ol>
<ol start="5">
<li>In the Attributes panel, select the View all attributes button:</li>
</ol>
<div><img height="71" width="382" src="img/bfface80-8164-44d4-b76c-01a96da322a5.png"/></div>
<ol start="6">
<li>Open the section titled Layout_Margin.</li>
<li>Click on the resource editor button for the all line, as shown in the screenshot:</li>
</ol>
<div><img src="img/cdca666b-c4b2-4e10-8272-08d482a05a38.png"/></div>
<ol start="8">
<li>In the resource editor, select the Add new resource button in the top-left, and choose New dimen value (dimen is short for dimension. A dimension resource can be used to specify sizes in non-pixel units, which are then converted according to the actual display system on the user's device).</li>
<li>Name the resource <kbd>grid_spacer1</kbd>, and give it a value of <kbd>8dp</kbd>:</li>
</ol>
<div><img src="img/48dd69c2-c5fa-4abf-89b5-0f4c24b99967.png"/></div>
<p>Material Design interfaces on Android use a spacing grid in an increment of <strong>8dp</strong>, which is <em>8 density-independent pixels</em>. This is a special unit of measurement that varies the actual number of pixels used based on the density of the screen. These are also the most common unit of on-screen measurement in Android. A <strong>1dp</strong> measurement will be 1 physical pixel on a 160dpi screen, and scaled to 2 pixels on a 320dpi screen. This means that by measuring your layout in terms of density-independent pixels rather than physical pixels, your user interface will translate better over the range of screen densities it might encounter on various devices.</p>
<ol start="10">
<li>Click OK to create the dimension resource and go back to the layout editor.</li>
<li>Now, you'll need to start building up the input boxes for the user to fill in. The first of these will be the description box. Open the Design section of the Palette, and drag a <kbd>TextInputLayout</kbd> into the Component Tree as a child of the ConstraintLayout:</li>
</ol>
<div><img src="img/b697692b-30c6-43d2-bf30-173147dcb97e.png"/></div>
<ol start="12">
<li>In the Attributes panel, click on the View fewer attributes button (it's the same one as View all attributes).</li>
<li>At the top of the Attributes panel, set the ID of the <kbd>TextInputLayout</kbd> to <kbd>description_layout</kbd>.</li>
<li>Use the Constraint editor (just below the ID attribute) to create connections to the left, and above the <kbd>TextInputLayout</kbd> by clicking on the blue circles with the + signs in them. Then, change the constrained margins to zero on both the new constraints, as shown:</li>
</ol>
<div><img src="img/b42003e1-9ca1-4c2d-9e13-e891710b0c8e.png"/></div>
<ol start="15">
<li>Your <kbd>TextInputLayout</kbd>, now named <kbd>description_layout</kbd>, should have snapped to the top-left corner of the layout editor:</li>
</ol>
<div><img src="img/5f7fcde9-2cba-4c1c-bca4-d08e938a1c01.png"/></div>
<ol start="16">
<li>Change the <kbd>layout_width</kbd> attribute to <kbd>match_constraint</kbd>, and the <kbd>layout_height</kbd> parameter to <kbd>wrap_content</kbd>. The <kbd>TextInputLayout</kbd> will shrink to the minimum space it can occupy in the top-left corner.</li>
<li style="font-weight: 400">Now, using the Component Tree, select the <kbd>TextInputEditText</kbd> inside the <kbd>description_layout</kbd> <kbd>TextInputLayout</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID to <kbd>description</kbd>, since this is the field you actually want to capture the contents of.</li>
<li style="font-weight: 400">Change the inputType to textCapWords; this will instruct software keyboards to place a capital letter at the beginning of each word:</li>
</ol>
<div><img src="img/06e8a6a1-ef8b-4b40-a6a1-ebbe4288c98e.png"/></div>
<ol start="20">
<li>The hint/label for the description box is currently hint, and it's hardcoded into the layout. We want to change it to <kbd>Description</kbd>, and make it localizable (so that it's easy to translate the app into new languages). Use the edit button to open the string resource editor, and choose Add new resource | New string value:</li>
</ol>
<div><img src="img/765fcd4e-1d1b-472d-8544-6a6d60f16391.png"/></div>
<ol start="21">
<li>Fill in the Resource name as <kbd>label_description</kbd>. You'll notice that this follows another prefix rule, which helps when dealing with large numbers of string resources in your source code.</li>
<li>Fill in the Resource value as <kbd>Description</kbd>, and leave the remaining fields unchanged:</li>
</ol>
<div><img src="img/5edd0859-c462-446b-a250-4bbc10ec4700.png"/></div>
<ol start="23">
<li>Click on OK to create the new string resource and go back to the layout editor.</li>
</ol>
<p>In this section, you created a grouping component (the <kbd>CardView</kbd>) that will serve to visually group the description amount and date fields for the user, and you have populated it with its first component--the description box. You have also created a dimension resource that can be reused throughout your application to represent a single grid spacing unit, allowing you to adjust the size of the grid for the entire application. A consistent grid spacing in the application helps define a consistent look and feel for the application, and keeping this value as a resource provides you with a single place where you can change it if required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the amount and date inputs</h1>
                
            
            
                
<p>In this next section, we'll finish building the description box by adding the <kbd>amount</kbd> and <kbd>date</kbd> fields. This will involve using some more complex constraints on the widgets you will be adding, as they will need to be positioned relative to each other. Follow these steps to finish the description box:</p>
<ol>
<li>Drag another <kbd>TextInputLayout</kbd> into your design and place it somewhere below the Description field. This new box has no constraints as of yet.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID to <kbd>amount_layout</kbd>.</li>
<li>In the Attributes panel, open the resource editor for <kbd>layout_width</kbd> as you did to create the <kbd>grid_spacer1</kbd> resource earlier.</li>
<li>Create a new resource named <kbd>input_size_amount</kbd>, and set its value as <kbd>100sp</kbd>.</li>
</ol>
<p>Much like dp, <strong>sp</strong> (<strong>scale-independent pixels</strong>) is a relative pixel size, but unlike density-independent pixels, scale-independent pixels are scaled according to the user's font preferences. Normally, these are used to specify font sizes, but they can also be useful when specifying fixed sizes for text input widgets.</p>
<ol start="5">
<li>Now, drag the right constraint handle to the right of the layout, and then drag the top constraint handle to the top of the layout, as shown:</li>
</ol>
<div><img src="img/0b522956-ecb0-4123-8174-77323826b485.png"/></div>
<ol start="6">
<li>Now, zero the margins using the constraint editor in the Attributes panel:</li>
</ol>
<div><img src="img/a1d2c65f-8773-4ac8-a755-603688b52eaa.png"/></div>
<ol start="7">
<li>Now, use the Component Tree to select the <kbd>description_layout</kbd> <kbd>TextInputLayout</kbd> widget.</li>
</ol>
<p>When selecting widgets directly in the design view, the editor will pick the deepest child of the Component Tree that you clicked on. This means that if you click on the Description field directly, you will select the <kbd>TextInputEditText</kbd> box, instead of the <kbd>TextInputLayout</kbd>. So, when dealing with the <kbd>ConstraintLayout</kbd> in particular, it's often better to select widgets in the Component Tree to ensure that you pick the right one.</p>
<ol start="8">
<li>In the layout view, drag the right constraint handle of the description <kbd>TextInputLayout</kbd> to meet up with the left constraint handle of the new <kbd>amount_layout</kbd> and <kbd>TextInputLayout</kbd>:</li>
</ol>
<div><img src="img/fc7e0496-e9d3-41b1-98a3-73816950e775.png"/></div>
<ol start="9">
<li style="font-weight: 400">Click on the new <kbd>TextInputEditText</kbd> widget in the Component Tree panel.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID to <kbd>amount</kbd>.</li>
<li style="font-weight: 400">Use the attribute editor to change the inputType to number.</li>
<li style="font-weight: 400">For the hint attribute, open the resource editor to create a new string resource.</li>
<li style="font-weight: 400">Name the resource as <kbd>label_amount</kbd>, and give it a value <kbd>Amount</kbd>:</li>
</ol>
<div><img src="img/91d98fbc-f87e-4a66-b4d8-cd2f6645cb12.png"/></div>
<ol start="14">
<li style="font-weight: 400">Now, we'll add a label for the <kbd>Date</kbd> input field; in the Palette panel, open the Text section and drag a new <kbd>TextView</kbd> into the layout editor.</li>
<li style="font-weight: 400">Using the constraint editor in the Attributes panel, add a constraint to the left and right, and then zero their margins.</li>
</ol>
<ol start="16">
<li style="font-weight: 400">Change the <kbd>layout_width</kbd> to <kbd>match_constraint</kbd> so that the label takes up all the available width:</li>
</ol>
<div><img src="img/29d933d6-422e-4d63-837b-c8b00d2958b2.png"/></div>
<p>The <kbd>match_contstraint</kbd> value available to the children of a <kbd>ConstraintLayout</kbd> is a special marker attribute that will cause the widget to fill the space made available by its constraints. This is similar to how the <kbd>match_parent</kbd> value will cause a widget to take up all the space made available by its parent.</p>
<ol start="17">
<li>Now, drag a new constraint from the top of the new <kbd>TextView</kbd> to the bottom of the Description <kbd>TextInputLayout</kbd>:</li>
</ol>
<div><img src="img/5fefec3a-0b4f-4d6c-b76e-119fbd898924.png"/></div>
<ol start="18">
<li style="font-weight: 400">Use the resource editor to create a new string resource for the text attribute.</li>
</ol>
<ol start="19">
<li style="font-weight: 400">Name the new resource <kbd>label_date</kbd>, and make its value <kbd>Date</kbd>:</li>
</ol>
<div><img height="94" width="202" src="img/47baea99-953b-4f38-9088-d945825a3ec9.png"/></div>
<ol start="20">
<li style="font-weight: 400">Still in the Attributes panel, change the textAppearance attribute to <kbd>AppCompat.Caption</kbd>. This is the same textAppearance style used by <kbd>TextInputLayout</kbd> for the hovering label when the cursor is focused on its <kbd>EditText</kbd>.</li>
<li style="font-weight: 400">Now, use the resource selector on the textColor attribute to choose the colorAccent color resource. This is the highlight color that is generated by Android Studio for you, and is also used by <kbd>TextInputLayout</kbd>. Your <kbd>TextView</kbd> should now look like the focused label for a <kbd>TextInputLayout</kbd>, which is exactly what you want, because the next widget should look like an <kbd>EditText</kbd>, but isn't.</li>
<li style="font-weight: 400">From the Palette panel, drag another <kbd>TextView</kbd> into the design layout.</li>
<li style="font-weight: 400">Use the Attributes panel to change its ID to <kbd>date</kbd>.</li>
<li style="font-weight: 400">Create left and right constraints, and set them to zero.</li>
<li style="font-weight: 400">Change the <kbd>layout_width</kbd> to <kbd>match_constraint</kbd> so that the <kbd>date</kbd> <kbd>TextView</kbd> takes up all the horizontal space:</li>
</ol>
<div><img height="242" width="184" src="img/41f53141-e338-4ee3-80ae-7f9e6cccf0e7.png"/></div>
<ol start="26">
<li>Drag the constraint handle from the top of the <kbd>date</kbd> <kbd>TextView</kbd> to the bottom of its <kbd>TextView</kbd> label:</li>
</ol>
<div><img height="159" width="294" src="img/6bd09ad8-9b72-4aeb-8ad5-3d5a1c1f9190.png"/></div>
<ol start="27">
<li style="font-weight: 400">At the top of the Attributes panel, use the View all attributes toggle button to view all the available attributes.</li>
<li style="font-weight: 400">Using the Attributes search box, find the style attribute:</li>
</ol>
<div><img height="99" width="236" src="img/495ef0a5-3527-4d67-81d2-e69da59b75d4.png"/></div>
<ol start="29">
<li style="font-weight: 400">Open the resource selector for the style attribute.</li>
<li style="font-weight: 400">Using the search box, find the <kbd>AppCompat.EditText</kbd> style:</li>
</ol>
<div><img height="192" width="346" src="img/b346e2f1-42eb-49b8-92e1-3d3267d1d4f1.png"/></div>
<ol start="31">
<li style="font-weight: 400">Clear the search box, and toggle back to the View fewer attributes panel.</li>
<li style="font-weight: 400">Clear the text attribute by deleting its content (this <kbd>TextView</kbd> should be empty in the layout file).</li>
<li style="font-weight: 400">In the Component Tree, select the <kbd>CardView</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, change its <kbd>layout_height</kbd> to <kbd>wrap_content</kbd>. The <kbd>CardView</kbd> will roll upward, taking up just enough space to contain the widgets that now make up the description, amount, and date inputs.</li>
</ol>
<p>Unlike the description and amount input boxes, the date is actually made up of two labels that are styled so that together, they look like a focused <kbd>TextInputLayout</kbd> widget. This is important because the user will populate the date using a calendar dialog, rather than typing the date using a keyboard. A calendar dialog is more user-friendly, and less error-prone than manual date entry. Also, like this, the component looks familiar to the user, giving them a suggestion of how it should be used. This sort of styling capability is very important and useful in Android, and it's worth learning how standard components are composed together and styled so that you can build these sort of emulations.</p>
<p>Your completed Description, Amount, and Date, so the capture box should look like this in the Android Studio layout editor:</p>
<div><img height="210" width="346" src="img/85409db6-d79f-4935-9875-b89dc5cc2422.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the category chooser</h1>
                
            
            
                
<p>The category chooser is where the user will select how to file their expense claims. There'll be a fairly small number of these, and they will be represented by icons in the user interface. Fortunately for Android developers, Material specifies a huge range of standard icons, and Android Studio has features to import them as bitmap or vector graphics files. When deciding whether to use bitmap images or SVGs, it's important to consider the trade-off between these two formats, specifically in relation to Android. Especially so since in Android, multiple copies of a bitmap are often provided for different screen sizes and densities, leading to much higher-quality scaling (as most will only ever be scaled down slightly). Here's a quick table to compare them:</p>
<table>
<tbody>
<tr>
<td><strong>Bitmaps</strong></td>
<td><strong>Vector Graphics</strong></td>
</tr>
<tr>
<td>
<p>Are supported on all platforms natively</p>
</td>
<td>
<p>May require a support library to work</p>
</td>
</tr>
<tr>
<td>
<p>Can be handled by the GPU and rendered with full acceleration</p>
</td>
<td>
<p>Must be rendered into a bitmap before they can be rendered onto the screen, which takes time</p>
</td>
</tr>
<tr>
<td>
<p>Take up more space in your app's APK, especially as you may need to provide different copies for different screen sizes and densities</p>
</td>
<td>
<p>Are stored as binary XML files, and take up very little space in the APK</p>
</td>
</tr>
<tr>
<td>
<p>Suffer massive loss of quality when scaled up, and loss of detail when scaled down</p>
</td>
<td>
<p>Can be rendered at virtually any size with no perceptible loss of quality or detail</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">For the category chooser widget, you'll be importing vector graphics icons and using them as radio buttons. Let's get things started:</p>
<ol>
<li style="font-weight: 400">In the files view to the extreme left of Android Studio, right-click on the res directory and select New, Vector Asset to open the vector import tool:</li>
</ol>
<div><img height="182" width="351" src="img/631d4086-a4f6-453f-9ad4-5e74811d1ffc.png"/></div>
<ol start="2">
<li style="font-weight: 400">Where it says Icon, click on the button with the Android robot.</li>
<li style="font-weight: 400">Use the search box at the top-left of the dialog to find the "hotel" icon, and select it.</li>
<li style="font-weight: 400">Click on OK to return to the import tool.</li>
<li style="font-weight: 400">The import tool will have changed the proposed name to <kbd>ic_hotel_black_24dp</kbd>; change this to <kbd>ic_accommodation_black</kbd>:</li>
</ol>
<div><img height="169" width="319" src="img/3f4c1482-edc2-4fe5-90c3-696e59780450.png"/></div>
<ol start="6">
<li style="font-weight: 400">In the Size boxes, select the Override checkbox and change the size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
</ol>
<ol start="7">
<li style="font-weight: 400">Click on Next and then on Finish to complete the import.</li>
<li style="font-weight: 400">Repeat this process, and find the room service icon. Name this one <kbd>ic_food_black</kbd>, and don't forget to change its size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
<li style="font-weight: 400">Repeat this for the airport shuttle icon. This is <kbd>ic_transport_black</kbd>, and again, change its size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
<li style="font-weight: 400">Repeat and find the local movies icon; name this <kbd>ic_entertainment_black</kbd> and remember to change its size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
<li style="font-weight: 400">Find the "business center" icon and name it <kbd>ic_business_black</kbd>; again, change its size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
<li style="font-weight: 400">Finally, find the all inclusive icon, name it <kbd>ic_other_black</kbd>, and override its size to <kbd>32</kbd> dp X <kbd>32</kbd> dp.</li>
</ol>
<p class="mce-root">Now you have a collection of black icons that will serve as the basis for your category selector.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making icons change with state</h1>
                
            
            
                
<p>In Android, images have state; they can change how they look according to the widget that is using them. In fact, this is how a button works; it has a background image that changes state depending on whether it's pressed, released, enabled, disabled, focused, and so on. For us to show the user which of these categories they have actually selected, we need to provide them with a visual indication on the icon. This involves some editing:</p>
<ol start="1">
<li style="font-weight: 400">Start by making a copy of the <kbd>ic_accommodation_black.xml</kbd> file that was generated, and name this one <kbd>ic_accommodation_white.xml</kbd>. Use copy, and then paste the file into the same directory to have Android Studio bring up a Copy dialog.</li>
</ol>
<p>Vector graphics in Android are XML files representing the various shapes and colors that make up the graphic. A vector graphic doesn't contain the pixel data like a bitmap image (such as a <kbd>.png</kbd> or <kbd>.jpeg</kbd>), but contains instructions for how to render the image. This means that by adjusting the coordinates contained within the instructions, the image can be made larger or smaller with little or no loss of quality.</p>
<ol start="2">
<li style="font-weight: 400"><strong>Beware</strong>, because by default, Android Studio might have selected the drawable-xhdpi directory as the target for the paste operation. If it has, you'll need to change this to <kbd>drawable</kbd>:</li>
</ol>
<div><img src="img/f800a39c-18a1-4356-a9e3-4ffb49e6f7fa.png"/></div>
<ol start="3">
<li>The editor will open with the new copy of the icon, which will still be black. The code for the file will look something like this:</li>
</ol>
<pre style="padding-left: 60px">&lt;vector<br/>  android:height="32dp"<br/>  android:viewportHeight="24.0"<br/>  android:viewportWidth="24.0"<br/>  android:width="32dp"<br/>  &gt;<br/><br/>    &lt;path android:fillColor="#FF000000" android:pathData="..."/&gt;<br/>&lt;/vector&gt;</pre>
<ol start="4">
<li>Change the <kbd>android:fillColor</kbd> attribute from <kbd>#FF000000</kbd> to <kbd>#FFFFFFFF</kbd> to change the icon from black to white.</li>
</ol>
<p>Colors in Android resources are specified using the standard Hexadecimal color notation. This is the same notation used on the web in CSS and HTML files. Each pair of two characters represents one part of the color component with values from 0 to 255 (inclusive). The components are always Alpha, Red, Green, and Blue, in that order. Alpha represents how transparent or opaque the color is, zero (00) being completely invisible, while 255 (FF) is completely opaque.</p>
<ol start="5">
<li style="font-weight: 400">Now, repeat this operation for all the other icons you imported, ensuring that each one is copied to the drawable directory, and change its name from <kbd>_black</kbd> to <kbd>_white</kbd>.</li>
<li style="font-weight: 400">You now have a black and white version of each icon; black is perfect to place against the white background of a <kbd>CardView</kbd>, while white is perfect to place against the accent color of your application, and shows how the icon has been selected by the user. For this, we need even more drawable resources. Right-click on the drawable directory and choose New| Drawable resource file.</li>
</ol>
<ol start="6">
<li style="font-weight: 400">Name this new file <kbd>ic_category_accommodation</kbd> and click on OK.</li>
<li style="font-weight: 400">Android Studio will now open the new file, which will be an empty selector file:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;selector<br/>    &gt;<br/>&lt;/selector&gt;</pre>
<p>A selector element corresponds to a <kbd>StateListDrawable</kbd> object from the <kbd>android.graphics.drawable</kbd> package. This class attempts to match its own state flags against a list of possible visual states (other <kbd>drawable</kbd> objects). The first item that matches is displayed, which means that it's important to consider the order you declare the states in.</p>
<ol start="9">
<li>First, tell the selector that it will always be the same size by setting its <kbd>constantSize</kbd> attribute, and then tell it that it should quickly animate between its state changes. This short animation gives the user an indication of these changes when choosing a category:</li>
</ol>
<pre style="padding-left: 60px">&lt;selector<br/>    <br/>    android:constantSize="true"<br/>    android:exitFadeDuration="@android:integer/config_shortAnimTime"<br/>    android:enterFadeDuration="@android:integer/config_shortAnimTime"&gt;</pre>
<ol start="10">
<li>First, you'll need to create a state for when the category is selected; you'll use two layers: one will be a simple circle background filled with the accent color, and over that you'll have the white version of the accommodation icon:</li>
</ol>
<pre style="padding-left: 60px">&lt;item android:state_checked="true"&gt;<br/>  &lt;layer-list&gt;<br/>    &lt;item&gt;<br/>      &lt;shape android:shape="oval"&gt;<br/>        &lt;solid android:color="@color/colorAccent"/&gt;<br/>      &lt;/shape&gt;<br/>    &lt;/item&gt;<br/>    &lt;item<br/>        android:width="28dp"<br/>        android:height="28dp"<br/>        android:gravity="center"<br/>        android:drawable="@drawable/ic_accommodation_white"/&gt;<br/>  &lt;/layer-list&gt;<br/>&lt;/item&gt;</pre>
<ol start="11">
<li>Then, create another <kbd>item</kbd> that is the default state--the black-filled accommodation icon:</li>
</ol>
<pre style="padding-left: 60px">&lt;item android:drawable="@drawable/ic_accommodation_black"/&gt;</pre>
<ol start="12">
<li>Repeat this process for each icon you imported so that each one has a stateful, drawable icon that you can use in the layout file.</li>
</ol>
<p>This process is often repeated, and there may even be more drawable resources involved for more varied state lists. Drawable elements are not always nested, as you did with the preceding <kbd>state_checked</kbd> item; they are often written into external drawable resources and then imported. This allows them to be reused without requiring the resource to be state-aware.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the category picker layout</h1>
                
            
            
                
<p>Now, it's time to go back to the layout editor and start creating the category selector box with these icons:</p>
<ol>
<li style="font-weight: 400">Reopen the <kbd>content_capture_claim.xml</kbd> layout file from the <kbd>res/layout</kbd> directory.</li>
<li style="font-weight: 400">In the Palette panel, open the AppCompat section and drag another <kbd>CardView</kbd> into the layout editor. Drop it below the <kbd>CardView</kbd> for the description, amount, and date input fields.</li>
<li style="font-weight: 400">In the Attributes panel, use the View all attributes toggle button and search box to find the layout margin.</li>
<li style="font-weight: 400">Open the Layout_Margins attribute group.</li>
<li style="font-weight: 400">Then, open the resource selector for the top attribute.</li>
</ol>
<ol start="6">
<li style="font-weight: 400">Select the <kbd>grid_spacer1</kbd> dimension resource you created earlier, and click on OK to close the resource selector:</li>
</ol>
<div><img height="201" width="287" src="img/fb994880-a20d-4800-8d29-987d2f3e5ebf.png"/></div>
<ol start="7">
<li style="font-weight: 400">Then, in the Palette, open the Layouts section and drag a LinearLayout (vertical) into the new <kbd>CardView</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, use the resource selector to change the all margin attribute to <kbd>grid_spacer1</kbd> to create some padding from the edges of the <kbd>CardView</kbd>.</li>
<li style="font-weight: 400">Clear the Attributes panel search box.</li>
<li style="font-weight: 400">Open the Containers section of the Palette, and drag a <kbd>RadioGroup</kbd> into the new <kbd>LinearLayout</kbd> in the layout editor. A <kbd>RadioGroup</kbd> is a specialized <kbd>LinearLayout</kbd> that handles the toggling of its child <kbd>RadioButton</kbd> widgets, which you'll use to allow the user to select a category.</li>
<li style="font-weight: 400">In the Attributes panel, change the id attribute to <kbd>categories</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, use the search box to find the orientation attribute and change it to <kbd>horizontal</kbd>.</li>
<li style="font-weight: 400">Clear the Attributes panel search box, and toggle it back to View fewer attributes.</li>
<li style="font-weight: 400">Open the Widgets section of the Palette and drag a <kbd>RadioButton</kbd> into the new <kbd>RadioGroup</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID to <kbd>accommodation</kbd>.</li>
<li style="font-weight: 400">Clear the layout_weight attribute.</li>
</ol>
<ol start="17">
<li style="font-weight: 400">Use the resource editor for the button attribute to select the <kbd>ic_category_accommodation</kbd> you created earlier:</li>
</ol>
<div><img height="91" width="262" src="img/15e865bd-2b6f-40c0-8568-3bb3d6e2e4b0.png"/></div>
<ol start="18">
<li style="font-weight: 400">Clear the text attribute, since these radio buttons won't have any labels.</li>
<li style="font-weight: 400">You'll then use the contentDescription attribute to store the human readable name of the category. Open the resource editor, create a new string resource named <kbd>description_accommodation</kbd>, and give it a value of <kbd>Accommodation</kbd>.</li>
</ol>
<p>The <kbd>contentDescription</kbd> attribute is part of the accessibility system, and it's used by screen readers and similar aids to describe a component that might not have a text label. In this case, it's a perfect place for us to grab the human-readable description of a category. It's not an on-screen space, and it also serves users with accessibility enabled.</p>
<ol start="20">
<li style="font-weight: 400">Toggle the Attributes panel to view all the attributes, and then find the layout margins.</li>
<li style="font-weight: 400">Use the resource selector to change the end margin attribute to <kbd>grid_spacer1</kbd>.</li>
<li style="font-weight: 400">Repeat the process of adding and populating radio buttons for the categories, giving each of them a suitable name in their ID and contentDescription attributes. Leave the “other” category until last so that it appears to the right of all the others.</li>
<li style="font-weight: 400">In the Component Tree panel, select the RadioGroup.</li>
<li style="font-weight: 400">In the Attributes panel, change its layout_height to <kbd>wrap_content</kbd>.</li>
<li style="font-weight: 400">From the Palette, open the Text section and drag a <kbd>TextView</kbd> into place below the <kbd>RadioGroup</kbd>.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID to <kbd>selected_category</kbd>.</li>
<li style="font-weight: 400">Clear the text attribute.</li>
<li style="font-weight: 400">Use the drop-down on the textAppearance attribute to select <kbd>AppCompat.Medium</kbd>.</li>
<li style="font-weight: 400">In the Component Tree, select the <kbd>CardView</kbd> containing the category selection components.</li>
<li style="font-weight: 400">Now in the Attributes panel, change the layout_height to <kbd>wrap_content</kbd>.</li>
</ol>
<p>The <kbd>CardView</kbd> will wrap upward, packing in the radio buttons and the label that you will use to display the currently selected category name. The <kbd>CardView</kbd>, again, serves to visually group the categories, and helps the user understand how they use this area of the screen:</p>
<div><img height="78" width="338" src="img/1f41b0d7-414d-429c-a551-8cae187805df.png"/></div>
<p>The use of standard styles and theming, again, helps the user to quickly grasp how things work; even though the categories are just a row of icons, they are underscored by the selected category name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the attachment preview</h1>
                
            
            
                
<p>After completing the category selector box, roughly half the available layout space should be left empty underneath. This is where the user will be able to preview the attachments they have added to the claim. We want the user to be able to swipe through these attachments left and right, and the easiest way to allow this is a <kbd>ViewPager</kbd>. A <kbd>ViewPager</kbd> is a special type of Android widget that links to an <kbd>Adapter</kbd> (other examples are <kbd>ListView</kbd>, <kbd>Spinner</kbd>, and <kbd>RecylerView</kbd>). An <kbd>Adapter</kbd> object turns data (such as rows from a database cursor, or objects from a <kbd>java.util.List</kbd>) into widgets that can be displayed on the screen.</p>
<p>Follow these steps to add it to the layout:</p>
<ol>
<li style="font-weight: 400">The <kbd>ViewPager</kbd> class is not available from the Palette panel, so at the bottom of the layout editor, change from Design mode to Text mode, so that you can edit the layout XML directly.</li>
<li style="font-weight: 400">Go to the bottom of the file and find the space between where the last <kbd>CardView</kbd> element is closed and where the <kbd>LinearLayout</kbd> is closed.</li>
<li style="font-weight: 400">Insert a <kbd>ViewPager</kbd> element into that space:</li>
</ol>
<pre style="padding-left: 60px">   &lt;/android.support.v7.widget.CardView&gt;<br/><br/><strong>   &lt;android.support.v4.view.ViewPager</strong><br/><strong>      android:id="@+id/attachments"</strong><br/><strong>      android:clipChildren="false"</strong><br/><strong>      android:clipToPadding="false"</strong><br/><strong>      android:paddingBottom="@dimen/grid_spacer1"</strong><br/><strong>      android:layout_weight="1"</strong><br/><strong>      android:layout_width="wrap_content"</strong><br/><strong>      android:layout_height="0dp"</strong><br/><strong>      android:layout_marginTop="@dimen/grid_</strong><strong>spacer1"/&gt;</strong><br/>&lt;/LinearLayout&gt;</pre>
<ol start="4">
<li>Change back to the Design view, and you'll note that a new box has been added to the layout and blueprints where the empty space was.</li>
</ol>
<p>The <kbd>clipChildren</kbd> and <kbd>clipToPadding</kbd> attributes in the preceding code change how the <kbd>ViewPager</kbd> and its children treat the space around them when rendering. The <kbd>CardView</kbd> class draws its shadows outside of its boundaries, and by default, these are clipped by the graphics system. Turning the clipping off allows the shadows and borders to be rendered completely.</p>
<p>A <kbd>ViewPager</kbd> doesn't look like anything on its own; its children are the only things that make it appear visually. So, until the user has added an attachment to a claim, nothing will appear in this space. This is not a problem, since the empty area provides a space for the software keyboard to appear when they enter the description and amount.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Try it yourself</h1>
                
            
            
                
<p>Using the knowledge you have gained in this chapter, import the attachment icon as a vector graphic, change its fill color to white, and set it as the icon of the floating action button that appears at the bottom-right of your layout. Once you have the icon right, try increasing the size of the floating action button to make it more thumb-friendly for your users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<ol>
<li>When designing a form screen, what is the first thing you should consider?
<ul>
<li style="font-weight: 400">The colors and icons you want to use</li>
<li style="font-weight: 400">The data you need from your user</li>
<li style="font-weight: 400">The standard guidelines for Android</li>
</ul>
</li>
</ol>
<ol start="2">
<li>What is the standard spacing increment in Material design?
<ul>
<li>8 Pixels</li>
<li>8 Density Independent Pixels</li>
<li>8 Device Pixels</li>
</ul>
</li>
<li>The <kbd>ConstraintLayout</kbd>, <kbd>ViewPager</kbd>, and <kbd>CardView</kbd> are part of the support APIs. What does this mean?
<ul>
<li style="font-weight: 400">Their bytecode must be included with your application if you use them</li>
<li style="font-weight: 400">They are also used as part of the Android Studio code base</li>
<li style="font-weight: 400">They can only contain other widgets from the support APIs</li>
</ul>
</li>
<li>When building a new layout, your root widget should always be which of these?
<ul>
<li style="font-weight: 400">A <kbd>ConstraintLayout</kbd></li>
<li style="font-weight: 400">A <kbd>LinearLayout</kbd></li>
<li style="font-weight: 400">The simplest widget that makes sense for your layout</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at how to design and then build a form screen in detail. These screens are an important part of applications, because they are where you users give you their details and as such they need to be especially intuitive and quick to use. Nobody likes to spend a lot of time filling in forms, and even less if they are using a mobile device. It's always good to remember that people normally use apps for relatively short periods of time; "what was that email?", is a more common action than "let me draft a letter to someone." This viewpoint helps when it comes to designing the user interfaces and overall experience you will build for your users.</p>
<p>It's always a good idea to sketch out your screen somewhere visually, and if you do, use software for it: ensure that it's something that lets you focus on layout and content rather than having to worry about colors, templates, or layout systems; always design first and then figure out how you'll build it. Pay attention to apps you enjoy using and that you find useful, look at how they do things--imitation is the sincerest form of flattery. Don't copy people too closely, but draw inspiration from good ideas; your users will thank you for it as well, because you'll be presenting them with something familiar, and hopefully more innovative at the same time.</p>
<p>Try to keep all text, colors, and dimensions as resources, and use generic names for these resources wherever possible. It's not uncommon to have an <em>ok</em> and <em>cancel</em> resource defined right under the application's name, because they are commonly used throughout applications. Keeping these values in the resource system allows for changes to be made far more easily, and keeps the application look and experience consistent for your users.</p>
<p>In the next chapter, we'll look at events, the Android event model, and how to best deal with events from your user interfaces in a way that provides the best user experience, while also being the more flexible to program with.</p>


            

            
        
    </body></html>