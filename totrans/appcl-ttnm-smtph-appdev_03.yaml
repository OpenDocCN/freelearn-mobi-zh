- en: Chapter 3. Integrating Google Maps and GPS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：集成谷歌地图和GPS
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Adding a MapView to your application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你的应用程序添加MapView
- en: Getting your current position with Geolocation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地理位置获取你的当前位置
- en: Converting addresses to latitude and longitude positions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地址转换为经纬度位置
- en: Adding annotations to your MapView
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你的MapView添加注释
- en: Customizing annotations and capturing MapView events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义注释并捕获MapView事件
- en: Monitoring your heading using the device compass
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备罗盘监控你的航向
- en: Drawing routes on your MapView
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的MapView上绘制路线
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Applications that utilize maps and location-based technology are second only
    to games and entertainment in sheer numbers of users and downloads on the iTunes
    store. This popularity with consumers is no surprise considering the multitude
    of uses we have found for them so far. From apps that help us navigate in the
    car and on foot, to being able to find a coffee shop or restaurant close by, the
    uses of this technology are truly only just being explored.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 利用地图和基于位置技术的应用程序在用户数量和iTunes商店的下载量上仅次于游戏和娱乐。考虑到我们迄今为止发现的多种用途，这种消费者的流行度并不令人惊讶。从帮助我们开车和步行导航的应用程序，到能够找到附近的咖啡馆或餐厅，这项技术的用途实际上才刚刚被探索。
- en: Titanium exposes the building blocks of this technology for us through the tight
    integration of Google Maps and GPS-based services for both the iPhone and the
    Android platform. Built-in geo-location, reverse geo-location and point-to-point
    routing are accessible all through Titanium's native API set. With these tools
    at your disposal, you can build anything from a store location finder to augmented
    reality applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Titanium通过将谷歌地图和基于GPS的服务紧密集成到iPhone和Android平台中，为我们提供了这个技术的构建块。内置的地理位置、反向地理位置和点对点路由都可以通过Titanium的本地API集访问。有了这些工具，你可以构建从商店位置查找器到增强现实应用程序的任何东西。
- en: Throughout the course of this chapter, we will introduce all of these core mapping
    concepts and use them to put together an exercise tracker app which will access
    our location at certain points and provide us feedback on how far we have traveled.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将介绍所有这些核心地图概念，并使用它们来构建一个锻炼追踪器应用程序，该应用程序将在特定点访问我们的位置，并就我们走了多远提供反馈。
- en: Pre-requisites
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前置条件
- en: You should already be familiar with Titanium basics, including creating UI objects
    and using Titanium Studio. Additionally, it would be useful to have a basic understanding
    of how latitude and longitude positioning works, which is the standardized method
    of calculating the position of a person or object anywhere on Earth.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉Titanium的基本知识，包括创建UI对象和使用Titanium Studio。此外，了解纬度和经度定位的工作原理会有所帮助，这是计算地球上任何地方的人或物体位置的标准方法。
- en: Adding a MapView to your application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的应用程序添加MapView
- en: Maps have become ubiquitous throughout all levels of technology. We now have
    real-time maps available everywhere from our computers, to our cars, the Web,
    and of course mobile devices. Google Maps is the most common platform implementation
    and the one both Android and the iPhone platforms utilize. In our first recipe
    for this chapter, we'll be implementing a MapView, and providing it with regional
    co-ordinates in the form of longitude and latitude values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 地图已经无处不在，渗透到技术的各个层面。现在，从我们的电脑到汽车、网络，当然还有移动设备，我们都可以获取实时地图。谷歌地图是最常见的平台实现，也是Android和iPhone平台所使用的平台。在本章的第一个示例中，我们将实现一个MapView，并为其提供以经纬度值形式存在的区域坐标。
- en: If you are intending to follow the entire chapter and build the **Exercise Tracker**
    app, then pay careful attention to the first *Getting ready* section for this
    recipe, as it will guide you through setting up the project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算跟随整个章节并构建**锻炼追踪器**应用程序，那么请仔细注意本食谱的第一个*准备就绪*部分，因为它将指导你设置项目。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `Exercise
    Tracker` as the name of the app, and fill in the rest of the details with your
    own information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个食谱，打开Titanium Studio并登录，如果您还没有这样做。如果您需要注册新账户，您可以直接在应用程序内免费注册。登录后，点击**新建项目**，创建新项目的详细信息窗口将出现。将应用程序名称输入为`Exercise
    Tracker`，并填写其他详细信息。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is *com.packtpub.exercisetracker)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意应用程序标识符，它通常以反向域名表示法书写（即 *com.packtpub.exercisetracker*）。在项目创建后，此标识符不易更改，并且您在创建用于分发应用的配置文件时需要**精确**匹配它。
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    1` folder, while complete source code for this entire chapter can be found in
    the `/Chapter 3/Exercise Tracker` folder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 3/Recipe 1`文件夹中找到，而本章的完整源代码可以在`/Chapter 3/Exercise Tracker`文件夹中找到。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Our project has now been created using Titanium Studio. Let''s get down to
    business! Open up the `app.js` file in your editor and remove all existing code.
    After you have done that, type in the following and then hit save:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已使用Titanium Studio创建了项目。让我们开始吧！在您的编辑器中打开`app.js`文件，并删除所有现有代码。完成后，输入以下内容并保存：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Try running the emulator now for either Android or iPhone. You should see a
    map appear in the bottom two-thirds of the screen, and after a few seconds it
    should center on London, England, as shown in the following screenshot. You may
    also receive a request at this point from the emulator asking if it can use your
    location. If this appears on your screen, simply select *yes*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行Android或iPhone的模拟器。您应该在屏幕底部三分之二的位置看到一个地图出现，几秒钟后它应该中心对准英国伦敦，如下面的截图所示。此时，模拟器可能会请求您是否可以使用您的位置。如果出现在您的屏幕上，只需选择*是*。
- en: '![How to do it...](img/3968EXP_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_03_01.jpg)'
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Most of this code should be pretty familiar to you by now. We have created
    a `Window` object and added another object of type MapView to that window, before
    opening it via the `win1.open()` method. The MapView itself has a number of new
    properties that are relevant and significant only to it. These include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码中的大部分应该都很熟悉。我们创建了一个`Window`对象，并在该窗口中添加了一个类型为MapView的对象，然后通过`win1.open()`方法打开它。MapView本身有许多只与其相关且重要的新属性。这些包括：
- en: '`region:` The region property accepts an array of parameters, which contain
    the latitude and longitude points that we wish to center the map on, as well as
    latitude and longitude delta values. The delta values indicate the zoom level
    of the map according to its centered location.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`region:` 区域属性接受一个参数数组，其中包含我们希望地图中心化的纬度和经度点，以及纬度和经度增量值。增量值表示地图根据其中心位置缩放级别。'
- en: '`userLocation:` This Boolean value will turn on or off the blue *dot* indicator
    (an arrow on Android devices), which indicates where you are in relation to the
    MapView. It''s important to note that this will probably not function in the emulator
    due to its inability to properly ascertain your current position.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userLocation:` 这个布尔值将开启或关闭表示位置的蓝色*点*指示器（在Android设备上是一个箭头），它表示您相对于MapView的位置。请注意，由于模拟器无法正确确定您的当前位置，这可能在模拟器中无法正常工作。'
- en: '`animate:` This Boolean value will turn zooming and movement animation on or
    off in the MapView. Useful in the event of targeting older devices with low processing
    power and/or low bandwidth.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animate:` 这个布尔值将开启或关闭MapView中的缩放和移动动画。在针对处理能力较低和/或带宽较低的旧设备时很有用。'
- en: '`regionFit:` A Boolean that indicates whether the selected region fits the
    view dimensions given.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regionFit:` 一个布尔值，表示所选区域是否适合给定的视图尺寸。'
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: After adding the Map view to your application, let's look at how we can make
    changes to the MapView's style.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在将地图视图添加到您的应用程序后，让我们看看我们如何可以更改MapView的样式。
- en: Changing your MapView's style
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改MapView的样式
- en: 'There are actually a number of different MapView types you can add to your
    application, all accessible via the `TITANIUM.MAP` enumerator. The full set of
    map types available are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将多种MapView类型添加到你的应用程序中，所有这些类型都可以通过`TITANIUM.MAP`枚举器访问。可用的完整地图类型如下：
- en: '`TITANIUM.MAP.STANDARD_TYPE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TITANIUM.MAP.STANDARD_TYPE`'
- en: '`TITANIUM.MAP.SATELLITE_TYPE`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TITANIUM.MAP.SATELLITE_TYPE`'
- en: '`TITANIUM.MAP.HYBRID_TYPE`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TITANIUM.MAP.HYBRID_TYPE`'
- en: Getting your current position using GeoLocation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GeoLocation获取您的当前位置
- en: Our map may be working, but it is currently hardcoded to appear above London,
    England, and not all of us merry chaps work for Her Majesty. One of the great
    things about mapping technology is that we can determine our location from anywhere
    in the world via GPS satellites and, when GPS fails, mobile tower signals. This
    allows us to put maps into context, and let's you issue data to your user that
    is targeted to their environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地图可能正在工作，但它目前是硬编码为出现在英国伦敦上方，并不是我们所有人都在为女王陛下工作。地图技术的伟大之处在于，我们可以通过GPS卫星从世界任何地方确定我们的位置，当GPS失效时，通过移动塔信号。这使我们能够将地图置于上下文中，并允许我们向用户发布针对其环境的数据。
- en: In order to get our current location, we need to use the `Titanium.Geolocation`
    namespace, which contains a method called `getCurrentPosition`. The next recipe
    will explain how to use this namespace to adjust the bounds of our MapView to
    our current location.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们的当前位置，我们需要使用`Titanium.Geolocation`命名空间，它包含一个名为`getCurrentPosition`的方法。下一个菜谱将解释如何使用此命名空间来调整MapView的边界以适应我们的当前位置。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    2` folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 3/Recipe 2`文件夹中找到。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add in the following code after you have added your MapView component to the
    window:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将MapView组件添加到窗口之后，添加以下代码：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run your app in the emulator now and you should have a screen appear that looks
    similar to the following screenshot. Note that if you run the code in the emulator,
    the map will zoom to your current location but will not show the blue dot indicating
    your current location. You will need to run the application on a device in order
    to see the full results of this recipe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模拟器中运行你的应用程序，你应该会看到一个类似于以下截图的屏幕出现。注意，如果你在模拟器中运行代码，地图将缩放到你的当前位置，但不会显示表示当前位置的蓝色点。你需要在一个设备上运行应用程序才能看到本菜谱的完整结果。
- en: '![How to do it...](img/3968EXP_03_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/3968EXP_03_02.jpg)'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Getting our current position is simply a matter of calling the `getCurrentPosition`
    method of the `Titanium.Geolocation` namespace, and capturing the properties returned
    when this event fires. All of the information we need is then accessible via the
    `coords` property of the event object `(e)`. In the source code mentioned in the
    previous example, we have set a number of these properties to variables, some
    of which we will use in our Exercise Tracker application later on. Finally, we
    have taken the latitude and longitude properties from the `coords` object and
    reset the MapView's `region` according to these new values. The distance filter
    property being set determines how accurate you want your GPS location/position
    to be. In our case, we have set it to 10 meters, which is accurate enough for
    our purposes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 获取我们的当前位置只需调用`Titanium.Geolocation`命名空间中的`getCurrentPosition`方法，并在该事件触发时捕获返回的属性。所有我们需要的信息都可以通过事件对象的`coords`属性`(e)`访问。在前面示例中提到的源代码中，我们已经将这些属性设置到变量中，其中一些我们将在后面的练习追踪器应用程序中使用。最后，我们从`coords`对象中获取纬度和经度属性，并根据这些新值重置MapView的`region`。设置的距离过滤器属性决定了你希望你的GPS位置/位置的精确度。在我们的例子中，我们将其设置为10米，这对于我们的目的来说已经足够精确了。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An important note for iPhone applications…
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于iPhone应用程序的重要注意事项…
- en: The second line in our block of code is a new requirement from Apple. It states
    that you must define exactly why you are requesting a user's location. This is
    there for your user's privacy and safety, so don't forget to add this line whenever
    you are using Geolocation, or Apple will probably reject your app from the iTunes
    store!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码块的第二行是苹果提出的新要求。它指出，你必须确切地说明你请求用户位置的原因。这是为了你的用户隐私和安全，所以每次你使用Geolocation时，别忘了添加这一行，否则苹果可能会拒绝你的应用程序进入iTunes商店！
- en: Converting addresses to latitude and longitude positions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将地址转换为经纬度位置
- en: 'Getting our location is all well and good when it''s done for us, but humans
    don''t think of places in terms of latitude and longitude values, we use good
    old addresses to define points on a map. To convert addresses to latitude and
    longitude decimal values, we can again use the `Titanium.Geolocation` namespace,
    and specifically a method in it called `forwardGeocoder`. Titanium has built-in
    methods for geo-coding, which utilize and essentially ''''black box'''' the services
    provided by the Google Maps API. The Google Geocoding API processes the converting
    addresses (such as "1600 Amphitheatre Parkway, Mountain View, CA") into geographic
    coordinates (for example, latitude: 37.423021 and longitude: 122.083739), which
    you can use to place markers or position the map. The Google Geocoding API provides
    a direct way to access a geocoder via an HTTP request.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们完成定位时，这当然很好，但人类不会用经纬度值来思考地点，我们使用传统的地址来定义地图上的点。要将地址转换为经纬度十进制值，我们再次可以使用
    `Titanium.Geolocation` 命名空间，特别是其中的 `forwardGeocoder` 方法。Titanium 内置了地理编码方法，这些方法利用并本质上“黑盒”了
    Google 地图 API 提供的服务。Google 地理编码 API 将地址（例如，“1600 Amphitheatre Parkway, Mountain
    View, CA”）转换为地理坐标（例如，纬度：37.423021 和经度：122.083739），您可以使用这些坐标来放置标记或定位地图。Google 地理编码
    API 提供了一种通过 HTTP 请求直接访问地理编码器的方式。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    3` folder.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在 `/Chapter 3/Recipe 3` 文件夹中找到。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, we need to create some input fields so that the user can provide us
    with a starting and an ending address. Let''s create a new View and add it to
    the top of our window above the `MapView`. We''ll also need to add a button to
    fire off the `forwardGeocoder` conversion. The background gradient image for the
    View is available within the `images` folder of the source code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一些输入字段，以便用户可以为我们提供起始地址和结束地址。让我们创建一个新的 View 并将其添加到窗口的顶部，位于 `MapView`
    之上。我们还需要添加一个按钮来触发 `forwardGeocoder` 转换。View 的背景渐变图像可以在源代码的 `images` 文件夹中找到：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, as we have some input fields, let''s use the search button to capture
    those addresses and convert them into location values that we can use to define
    the region of our `MapView`. Put the next block of code into your button''s `click`
    event handler:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们有一些输入字段，让我们使用搜索按钮来捕获这些地址并将它们转换为我们可以用来定义 `MapView` 区域的位置值。将以下代码块放入按钮的
    `click` 事件处理程序中：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your app in the emulator and provide a start and an end address, and then
    hit **search**. After a few seconds you should get the geolocation values of those
    addresses outputted to the console, and your MapView should re-orientate itself
    to the region surrounding your starting address. The following screenshot shows
    the start and end addresses converted to latitude and longitude coordinates being
    outputted to the Titanium Studio console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行您的应用程序，并提供起始地址和结束地址，然后点击 **搜索**。几秒钟后，您应该会在控制台输出这些地址的地理定位值，并且您的 MapView
    应该会重新定位到起始地址所在的区域。以下截图显示了起始和结束地址转换为纬度和经度坐标，并输出到 Titanium Studio 控制台：
- en: '![How to do it...](img/3968EXP_03_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3968EXP_03_03.jpg)'
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first section of code in this recipe is simple. Create a couple of TextFields
    for the start and end address and capture the click event of a Button component,
    wherein we pass those address values to our `Titanium.Geolocation.forwardGeocoder`
    method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的第一段代码很简单。创建几个用于起始地址和结束地址的 TextFields，并捕获 Button 组件的点击事件，我们将这些地址值传递给我们的
    `Titanium.Geolocation.forwardGeocoder` 方法。
- en: The forward geolocation task is actually performed against Google's servers.
    Titanium has wrapped this into one simple method for you to call, which saves
    you having to do the legwork of creating your own HTTP request against Google's
    server and then manually parsing the response.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前向地理定位任务实际上是在 Google 服务器上执行的。Titanium 为您封装了一个简单的方法，以便您可以直接调用，这样您就无需亲自创建针对 Google
    服务器的 HTTP 请求，然后手动解析响应。
- en: 'You can try it out manually if you wish by reading the instructions at Google''s
    own website: [http://code.google.com/apis/maps/documentation/geocoding/index.html](http://code.google.com/apis/maps/documentation/geocoding/index.html).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以手动尝试，通过阅读 Google 自己网站上的说明：[http://code.google.com/apis/maps/documentation/geocoding/index.html](http://code.google.com/apis/maps/documentation/geocoding/index.html)。
- en: Adding annotations to your MapView
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的 MapView 添加注释
- en: The ability to find locations on a map is extremely useful, but what the user
    needs is some kind of visual representation of that location on the screen. This
    is where annotations come in. In the next recipe, we will create annotation pins
    for both the start and end addresses, using the latitude and longitude values
    created by our `forwardGeocoder`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上查找位置的能力非常有用，但用户需要的是屏幕上该位置的某种视觉表示。这就是标注的作用所在。在下一个食谱中，我们将使用`forwardGeocoder`创建的纬度和经度值，为起始地址和结束地址创建标注图钉。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    4` folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可在`/Chapter 3/Recipe 4`文件夹中找到。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Within your search button function and the `forwardGeocoder` method we called
    in the previous recipe, add the following code to create an annotation for the
    start location:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的搜索按钮函数和之前食谱中调用的`forwardGeocoder`方法中，添加以下代码以创建起始位置的标注：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have added this code into the `forwardGeocoder` method for the start
    location, do exactly the same for your end location, except give the end location
    a`'myid'` property value of `2`. We will use these custom ID values later on when
    capturing events from our annotations; they will allow us to determine which annotation
    pin was tapped. Also, for your second annotation, give it a `pinColor` property
    of `Titanium.Map.ANNOTATION_RED`, as this well help distinguish the two pins on
    the map.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将此代码添加到`forwardGeocoder`方法中的起始位置，请对结束位置执行完全相同的操作，除了给结束位置一个`'myid'`属性值为`2`。稍后，当我们从标注捕获事件时，我们将使用这些自定义ID值；它们将使我们能够确定哪个标注图钉被点击。此外，为你的第二个标注提供一个`pinColor`属性为`Titanium.Map.ANNOTATION_RED`，这将有助于在地图上区分两个图钉。
- en: 'Load your application in the emulator and give it a start and an end location,
    then press **search**—you should end up with a couple of pins on your MapView,
    as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中加载你的应用程序，并指定起始位置和结束位置，然后按**搜索**——你应该在你的MapView上看到几个图钉，如下面的截图所示：
- en: '![How to do it...](img/3968EXP_03_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_03_04.jpg)'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Within your search button function and the `forwardGeocoder` method we called
    in the previous recipe, is the instantiation of a new object of type `annotation`,
    using `Titanium.Map.createAnnotation()`. This object represents a pin icon that
    is dropped onto the map to identify a specific location, and has a number of interesting
    properties. Apart from the standard longitude and latitude values, it can also
    accept a title and a secondary title, with the title being displayed more prominently
    at the top of the annotation and the secondary one below it. You should also give
    your annotations an `id` property (we have used `id` in this example), so that
    it is easier to identify them when you are adding events to your `MapView`. This
    is explained further in the next recipe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的搜索按钮函数和之前食谱中调用的`forwardGeocoder`方法中，是使用`Titanium.Map.createAnnotation()`创建一个新对象，该对象代表一个图钉图标，它被放置在地图上以标识特定位置，并且具有许多有趣的属性。除了标准的经纬度值外，它还可以接受标题和副标题，标题在标注顶部显示得更为突出，副标题位于其下方。你还应该给你的标注提供一个`id`属性（我们在这个例子中使用了`id`），这样在向`MapView`添加事件时更容易识别它们。这将在下一个食谱中进一步解释。
- en: Customizing annotations and capturing MapView events
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义标注和捕获MapView事件
- en: Annotations can also be customized to give the user a better indication of what
    your location symbolizes. For example, if you were mapping restaurants in a particular
    area, you may provide each annotation with an icon that symbolized the type of
    restaurant it was—be it a pizza slice for Italian, a pint for pub food or a hamburger
    for a fast food chain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标注也可以自定义，以便用户更好地了解你的位置符号代表什么。例如，如果你正在绘制特定区域的餐厅，你可以为每个标注提供一个图标，以表示其代表的餐厅类型——无论是意大利披萨切片、酒吧食物的品脱还是快餐连锁店的汉堡。
- en: In this recipe, we will add a left image to both the start and end location
    annotations, using an "S" (for "Start") and an "E" (for "End") icon respectively,
    to help the user identify them. We will also add a *start* button to the first
    pin, and a *stop* button to the second, which we will use to control our exercise
    timer later on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将为起始位置和结束位置标注添加左侧图像，分别使用代表“起始”的“S”图标和代表“结束”的“E”图标，以帮助用户识别它们。我们还将为第一个图钉添加一个*开始*按钮，为第二个图钉添加一个*停止*按钮，我们将使用这些按钮来控制后续的练习计时器。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    5` folder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可在`/Chapter 3/Recipe 5`文件夹中找到。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: After your annotation is declared, but before it is added to your `mapView`
    object, type in the following code to create a custom `leftView` and custom `rightButton`.
    You should do the same for both the start location pin and the end location pin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明注释之后，但在将其添加到`mapView`对象之前，输入以下代码以创建自定义的`leftView`和自定义`rightButton`。你应该对起始位置针和结束位置针都做同样的事情。
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s create the event listener for the `mapView` object. This function
    will execute when a user taps on any annotation in the map. You should place this
    code near the bottom of your JavaScript, just before the `mapView` is added to
    our window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`mapView`对象创建事件监听器。当用户在地图上点击任何注释时，此函数将执行。你应该将此代码放置在JavaScript的底部附近，就在`mapView`被添加到我们的窗口之前：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, all we are doing at the beginning is pointing some new properties
    at each annotation. Our `leftView` is being populated by an `imageView`, using
    the image icons for "S" and "E" respectively. The annotation also accepts a simple
    URL string for the `rightButton` property, and it is here that we are providing
    the "start" and "stop" button image locations (both are to be found in the `images`
    folder of the source code).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的开始，我们只是在每个注释上指向一些新的属性。我们的`leftView`通过使用“S”和“E”的图像图标被填充。注释还接受一个简单的URL字符串作为`rightButton`属性，正是在这里我们提供了“开始”和“停止”按钮的图像位置（两者都可以在源代码的`images`文件夹中找到）。
- en: The event listener for the `mapView` works slightly differently as compared
    to other event listeners. You need to capture an annotation click from the `mapView`
    parent object and then work out which annotation was tapped by means of a custom
    ID. In this case, we have used the `id` property to determine which annotation
    was the start location and which was the end location. The start location is set
    to `id 1`, while the end location is simply set to `id 2`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他事件监听器相比，`mapView`的事件监听器工作方式略有不同。你需要从`mapView`的父对象捕获注释点击，然后通过自定义ID来确定哪个注释被点击。在这种情况下，我们使用了`id`属性来确定哪个注释是起始位置，哪个是结束位置。起始位置被设置为`id
    1`，而结束位置简单地设置为`id 2`。
- en: Additionally, you may wish to perform different actions based on whether the
    right or left button on the annotation pin was tapped. We can determine this by
    using the event property's `(e) clicksource`. A comparison to a string of either
    `leftButton` or `rightButton` will let you know which was tapped and you can program
    functions into your app accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能希望根据注释的右键或左键是否被点击执行不同的操作。我们可以通过使用事件属性的`(e) clicksource`来确定这一点。将字符串与`leftButton`或`rightButton`进行比较，可以让你知道哪个被点击了，并且你可以根据应用程序相应地编写函数。
- en: '![How it works...](img/3968EXP_03_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3968EXP_03_05.jpg)'
- en: Drawing routes on your MapView
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的`MapView`上绘制路线
- en: In order to track our movements and draw a route on the map, we need to create
    an array of points, each with its own latitude and longitude value. The MapView
    will take in this array of points as a property called route, and draw a series
    of lines to provide a visual representation of the route to the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪我们的移动并在地图上绘制路线，我们需要创建一个包含各个点的数组，每个点都有其自己的纬度和经度值。`MapView`将接受这个点的数组作为名为`route`的属性，并绘制一系列线条，为用户提供路线的视觉表示。
- en: In this recipe, we will create a timer that records our location every minute,
    and adds it to the points array. When each new point is recorded, we will access
    the Google Directions API to determine the distance and add that to our overall
    tally of how far we have traveled.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个计时器，每分钟记录我们的位置，并将其添加到点数组中。当每个新点被记录时，我们将访问Google Directions API来确定距离，并将其添加到我们旅行的总距离中。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe will not work on Android devices, as there is currently
    no support for Android routing in Titanium. However, it will work as described
    here for the iPhone and iPod Touch. There is an unsupported method of routing
    in Android, which you can read about at [http://bit.ly/pUq2v2](http://bit.ly/pUq2v2).
    You will need to use an actual iPhone or iPod Touch device to test this recipe,
    as the emulator will not be able to get your current location.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个食谱在Android设备上可能无法工作，因为Titanium目前不支持Android路由。然而，它将如描述的那样在iPhone和iPod Touch上工作。Android中有一个不受支持的路由方法，你可以在[http://bit.ly/pUq2v2](http://bit.ly/pUq2v2)上阅读有关内容。你需要使用实际的iPhone或iPod
    Touch设备来测试这个食谱，因为模拟器无法获取你的当前位置。
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    6` folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 3/Recipe 6`文件夹中找到。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Within your `mapView` click event, after the console logging to determine which
    button was tapped and which annotation, type in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`mapView`点击事件中，在控制台日志确定哪个按钮被轻触以及哪个注释之后，输入以下代码：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are some variables we need to create now that need to be globally accessible
    to this JavaScript file. Add the following code to the very top of your `app.js`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一些需要全局访问的变量。将以下代码添加到`app.js`文件的顶部：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to create the function for obtaining the user''s new current
    location and determining how far the new location is from our previous location.
    Create this new function above the click event for the `mapView` component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个函数来获取用户的新当前位置，并确定新位置与之前位置的距离。在`mapView`组件的点击事件上方创建这个新函数：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a number of things happening in this recipe, so let's break them down
    logically into their separate parts. First, we are obtaining the user's current
    location again on the start button's `click` event, and adding that as the first
    point in our `points` array. In order for our `mapView` component to use the array
    of point locations, we need to create a route object. This route object contains
    the array of points, plus the visual information such as the route's line, color,
    and thickness.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中发生了很多事情，所以让我们逻辑地将其分解成各自的独立部分。首先，我们在启动按钮的`click`事件中再次获取用户的当前位置，并将其作为`points`数组中的第一个点。为了使`mapView`组件能够使用点位置数组，我们需要创建一个路线对象。这个路线对象包含点数组，以及路线的线条、颜色和粗细等视觉信息。
- en: From there, we are creating a timer using `setInterval().` This timer will only
    start when both the `timerStarted` variable is set to false, and when we can determine
    that the button tapped was indeed the right "start" button on one of our annotations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们使用`setInterval()`创建一个计时器。这个计时器只有在`timerStarted`变量设置为false，并且我们可以确定按钮轻触确实是我们的注释中的一个“开始”按钮时才会启动。
- en: Our timer is set to execute every 60 seconds, or as required by the code, 60,000
    milliseconds. This means that every minute the function called `recordCurrentLocation()`
    will be executed. This function does the processing for determining our current
    location, and adds the new location to our "points" array. It then performs an
    HTTP request call to the Google APIs, which performs a distance calculation between
    our newest point, and the point location that we were at previously. This new
    distance is added to our total distance variable, called `distanceTraveled`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间计时器设置为每60秒执行一次，或者按照代码要求，60,000毫秒。这意味着每分钟都会执行一次名为`recordCurrentLocation()`的函数。这个函数负责处理确定我们当前位置，并将新位置添加到我们的“points”数组中。然后，它会对Google
    API执行HTTP请求调用，计算我们最新点和之前所在位置之间的距离。这个新的距离会被添加到名为`distanceTraveled`的总距离变量中。
- en: Finally, whenever the user taps the *stop* button on the end annotation, the
    timer is stopped and the user is presented with an `alertDialog` showing the total
    value for how far they have traveled in meters. The following screenshot shows
    the route being drawn from our start to end location, and then the alert with
    the distance traveled when the *stop* button is tapped.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户在结束注释上的*停止*按钮上轻触时，计时器停止，并显示一个`alertDialog`，显示用户已经走过的总距离（以米为单位）。以下截图显示了从起点到终点位置的路线绘制，以及当轻触*停止*按钮时的距离警报。
- en: '![How it works...](img/3968EXP_03_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3968EXP_03_06.jpg)'
- en: Monitoring your heading using the device compass
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备罗盘监控航向
- en: In this recipe, our final recipe for our chapter on Maps and GPS, we will be
    using the inbuilt device compass to determine your heading. We'll present that
    heading using an image of an arrow to represent the direction visually.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们章节关于地图和GPS的最终菜谱，我们将使用内置的设备罗盘来确定你的航向。我们将使用箭头的图像来表示方向，直观地展示这个航向。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe will not work on older iPhone devices, such as the iPhone
    3G, which lack the compass. You will need to use an actual device to test this
    recipe, as the emulator will not be able to get your current heading either.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个菜谱在较旧的iPhone设备上可能无法工作，例如iPhone 3G，因为它缺少罗盘。你需要使用实际设备来测试这个菜谱，因为模拟器无法获取你的当前航向。
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    7` folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 3/Recipe 7`文件夹中找到。
- en: Complete source code for the Exercise Tracker application built in this chapter
    can be found in the `/Chapter 3/Exercise Tracker` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章构建的练习跟踪应用程序的完整源代码可以在`/Chapter 3/Exercise Tracker`文件夹中找到。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add the following code to your `app.js` file, just before you perform a `win1.open()`
    method call at the end of the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的末尾执行`win1.open()`方法调用之前，将以下代码添加到你的`app.js`文件中：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We are first creating an `imageView` and setting its image property to our
    arrow image. Initially, this will face towards the top of the screen, and will
    indicate north. This `imageView` is then added to our `Window` object. The heading
    source code for this recipe is performing two similar tasks: one gets our *initial*
    heading and the second fires on set intervals to get our *current* heading. When
    the heading is obtained for either the current position or the new position, we
    use the `magneticHeading` property to determine the angle (direction) in which
    we are facing, and use a simple transformation to rotate the arrow in that direction.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`imageView`，并将其图像属性设置为我们的箭头图像。最初，它将面向屏幕顶部，指示北方。然后，我们将这个`imageView`添加到我们的`Window`对象中。这个菜谱的标题源代码执行了两个类似任务：一个获取我们的*初始*航向，另一个在设定的时间间隔内触发以获取我们的*当前*航向。当获取到当前位置或新位置的航向时，我们使用`magneticHeading`属性来确定我们面向的角度（方向），并使用简单的变换将箭头旋转到那个方向。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't worry if you don't understand what a 2D matrix is, or how the transformation
    is performing the rotation of our image! We will be covering transformations,
    rotations, and animations in [Chapter 7](ch07.html "Chapter 7. Creating Animations,
    Transformations, and Understanding Drag-and-drop"),
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解什么是二维矩阵，或者变换是如何执行我们图像的旋转，请不要担心！我们将在[第7章](ch07.html "第7章。创建动画、变换以及理解拖放")中介绍变换、旋转和动画。
