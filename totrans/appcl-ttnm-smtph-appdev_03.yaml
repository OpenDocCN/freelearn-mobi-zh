- en: Chapter 3. Integrating Google Maps and GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a MapView to your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting your current position with Geolocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting addresses to latitude and longitude positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding annotations to your MapView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing annotations and capturing MapView events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring your heading using the device compass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing routes on your MapView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that utilize maps and location-based technology are second only
    to games and entertainment in sheer numbers of users and downloads on the iTunes
    store. This popularity with consumers is no surprise considering the multitude
    of uses we have found for them so far. From apps that help us navigate in the
    car and on foot, to being able to find a coffee shop or restaurant close by, the
    uses of this technology are truly only just being explored.
  prefs: []
  type: TYPE_NORMAL
- en: Titanium exposes the building blocks of this technology for us through the tight
    integration of Google Maps and GPS-based services for both the iPhone and the
    Android platform. Built-in geo-location, reverse geo-location and point-to-point
    routing are accessible all through Titanium's native API set. With these tools
    at your disposal, you can build anything from a store location finder to augmented
    reality applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the course of this chapter, we will introduce all of these core mapping
    concepts and use them to put together an exercise tracker app which will access
    our location at certain points and provide us feedback on how far we have traveled.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-requisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should already be familiar with Titanium basics, including creating UI objects
    and using Titanium Studio. Additionally, it would be useful to have a basic understanding
    of how latitude and longitude positioning works, which is the standardized method
    of calculating the position of a person or object anywhere on Earth.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a MapView to your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps have become ubiquitous throughout all levels of technology. We now have
    real-time maps available everywhere from our computers, to our cars, the Web,
    and of course mobile devices. Google Maps is the most common platform implementation
    and the one both Android and the iPhone platforms utilize. In our first recipe
    for this chapter, we'll be implementing a MapView, and providing it with regional
    co-ordinates in the form of longitude and latitude values.
  prefs: []
  type: TYPE_NORMAL
- en: If you are intending to follow the entire chapter and build the **Exercise Tracker**
    app, then pay careful attention to the first *Getting ready* section for this
    recipe, as it will guide you through setting up the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `Exercise
    Tracker` as the name of the app, and fill in the rest of the details with your
    own information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is *com.packtpub.exercisetracker)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    1` folder, while complete source code for this entire chapter can be found in
    the `/Chapter 3/Exercise Tracker` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our project has now been created using Titanium Studio. Let''s get down to
    business! Open up the `app.js` file in your editor and remove all existing code.
    After you have done that, type in the following and then hit save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Try running the emulator now for either Android or iPhone. You should see a
    map appear in the bottom two-thirds of the screen, and after a few seconds it
    should center on London, England, as shown in the following screenshot. You may
    also receive a request at this point from the emulator asking if it can use your
    location. If this appears on your screen, simply select *yes*.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of this code should be pretty familiar to you by now. We have created
    a `Window` object and added another object of type MapView to that window, before
    opening it via the `win1.open()` method. The MapView itself has a number of new
    properties that are relevant and significant only to it. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`region:` The region property accepts an array of parameters, which contain
    the latitude and longitude points that we wish to center the map on, as well as
    latitude and longitude delta values. The delta values indicate the zoom level
    of the map according to its centered location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userLocation:` This Boolean value will turn on or off the blue *dot* indicator
    (an arrow on Android devices), which indicates where you are in relation to the
    MapView. It''s important to note that this will probably not function in the emulator
    due to its inability to properly ascertain your current position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`animate:` This Boolean value will turn zooming and movement animation on or
    off in the MapView. Useful in the event of targeting older devices with low processing
    power and/or low bandwidth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regionFit:` A Boolean that indicates whether the selected region fits the
    view dimensions given.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After adding the Map view to your application, let's look at how we can make
    changes to the MapView's style.
  prefs: []
  type: TYPE_NORMAL
- en: Changing your MapView's style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are actually a number of different MapView types you can add to your
    application, all accessible via the `TITANIUM.MAP` enumerator. The full set of
    map types available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TITANIUM.MAP.STANDARD_TYPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TITANIUM.MAP.SATELLITE_TYPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TITANIUM.MAP.HYBRID_TYPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting your current position using GeoLocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our map may be working, but it is currently hardcoded to appear above London,
    England, and not all of us merry chaps work for Her Majesty. One of the great
    things about mapping technology is that we can determine our location from anywhere
    in the world via GPS satellites and, when GPS fails, mobile tower signals. This
    allows us to put maps into context, and let's you issue data to your user that
    is targeted to their environment.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get our current location, we need to use the `Titanium.Geolocation`
    namespace, which contains a method called `getCurrentPosition`. The next recipe
    will explain how to use this namespace to adjust the bounds of our MapView to
    our current location.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add in the following code after you have added your MapView component to the
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run your app in the emulator now and you should have a screen appear that looks
    similar to the following screenshot. Note that if you run the code in the emulator,
    the map will zoom to your current location but will not show the blue dot indicating
    your current location. You will need to run the application on a device in order
    to see the full results of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting our current position is simply a matter of calling the `getCurrentPosition`
    method of the `Titanium.Geolocation` namespace, and capturing the properties returned
    when this event fires. All of the information we need is then accessible via the
    `coords` property of the event object `(e)`. In the source code mentioned in the
    previous example, we have set a number of these properties to variables, some
    of which we will use in our Exercise Tracker application later on. Finally, we
    have taken the latitude and longitude properties from the `coords` object and
    reset the MapView's `region` according to these new values. The distance filter
    property being set determines how accurate you want your GPS location/position
    to be. In our case, we have set it to 10 meters, which is accurate enough for
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important note for iPhone applications…
  prefs: []
  type: TYPE_NORMAL
- en: The second line in our block of code is a new requirement from Apple. It states
    that you must define exactly why you are requesting a user's location. This is
    there for your user's privacy and safety, so don't forget to add this line whenever
    you are using Geolocation, or Apple will probably reject your app from the iTunes
    store!
  prefs: []
  type: TYPE_NORMAL
- en: Converting addresses to latitude and longitude positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting our location is all well and good when it''s done for us, but humans
    don''t think of places in terms of latitude and longitude values, we use good
    old addresses to define points on a map. To convert addresses to latitude and
    longitude decimal values, we can again use the `Titanium.Geolocation` namespace,
    and specifically a method in it called `forwardGeocoder`. Titanium has built-in
    methods for geo-coding, which utilize and essentially ''''black box'''' the services
    provided by the Google Maps API. The Google Geocoding API processes the converting
    addresses (such as "1600 Amphitheatre Parkway, Mountain View, CA") into geographic
    coordinates (for example, latitude: 37.423021 and longitude: 122.083739), which
    you can use to place markers or position the map. The Google Geocoding API provides
    a direct way to access a geocoder via an HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to create some input fields so that the user can provide us
    with a starting and an ending address. Let''s create a new View and add it to
    the top of our window above the `MapView`. We''ll also need to add a button to
    fire off the `forwardGeocoder` conversion. The background gradient image for the
    View is available within the `images` folder of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we have some input fields, let''s use the search button to capture
    those addresses and convert them into location values that we can use to define
    the region of our `MapView`. Put the next block of code into your button''s `click`
    event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app in the emulator and provide a start and an end address, and then
    hit **search**. After a few seconds you should get the geolocation values of those
    addresses outputted to the console, and your MapView should re-orientate itself
    to the region surrounding your starting address. The following screenshot shows
    the start and end addresses converted to latitude and longitude coordinates being
    outputted to the Titanium Studio console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first section of code in this recipe is simple. Create a couple of TextFields
    for the start and end address and capture the click event of a Button component,
    wherein we pass those address values to our `Titanium.Geolocation.forwardGeocoder`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The forward geolocation task is actually performed against Google's servers.
    Titanium has wrapped this into one simple method for you to call, which saves
    you having to do the legwork of creating your own HTTP request against Google's
    server and then manually parsing the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try it out manually if you wish by reading the instructions at Google''s
    own website: [http://code.google.com/apis/maps/documentation/geocoding/index.html](http://code.google.com/apis/maps/documentation/geocoding/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding annotations to your MapView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to find locations on a map is extremely useful, but what the user
    needs is some kind of visual representation of that location on the screen. This
    is where annotations come in. In the next recipe, we will create annotation pins
    for both the start and end addresses, using the latitude and longitude values
    created by our `forwardGeocoder`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within your search button function and the `forwardGeocoder` method we called
    in the previous recipe, add the following code to create an annotation for the
    start location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added this code into the `forwardGeocoder` method for the start
    location, do exactly the same for your end location, except give the end location
    a`'myid'` property value of `2`. We will use these custom ID values later on when
    capturing events from our annotations; they will allow us to determine which annotation
    pin was tapped. Also, for your second annotation, give it a `pinColor` property
    of `Titanium.Map.ANNOTATION_RED`, as this well help distinguish the two pins on
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load your application in the emulator and give it a start and an end location,
    then press **search**—you should end up with a couple of pins on your MapView,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within your search button function and the `forwardGeocoder` method we called
    in the previous recipe, is the instantiation of a new object of type `annotation`,
    using `Titanium.Map.createAnnotation()`. This object represents a pin icon that
    is dropped onto the map to identify a specific location, and has a number of interesting
    properties. Apart from the standard longitude and latitude values, it can also
    accept a title and a secondary title, with the title being displayed more prominently
    at the top of the annotation and the secondary one below it. You should also give
    your annotations an `id` property (we have used `id` in this example), so that
    it is easier to identify them when you are adding events to your `MapView`. This
    is explained further in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing annotations and capturing MapView events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations can also be customized to give the user a better indication of what
    your location symbolizes. For example, if you were mapping restaurants in a particular
    area, you may provide each annotation with an icon that symbolized the type of
    restaurant it was—be it a pizza slice for Italian, a pint for pub food or a hamburger
    for a fast food chain.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will add a left image to both the start and end location
    annotations, using an "S" (for "Start") and an "E" (for "End") icon respectively,
    to help the user identify them. We will also add a *start* button to the first
    pin, and a *stop* button to the second, which we will use to control our exercise
    timer later on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After your annotation is declared, but before it is added to your `mapView`
    object, type in the following code to create a custom `leftView` and custom `rightButton`.
    You should do the same for both the start location pin and the end location pin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the event listener for the `mapView` object. This function
    will execute when a user taps on any annotation in the map. You should place this
    code near the bottom of your JavaScript, just before the `mapView` is added to
    our window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, all we are doing at the beginning is pointing some new properties
    at each annotation. Our `leftView` is being populated by an `imageView`, using
    the image icons for "S" and "E" respectively. The annotation also accepts a simple
    URL string for the `rightButton` property, and it is here that we are providing
    the "start" and "stop" button image locations (both are to be found in the `images`
    folder of the source code).
  prefs: []
  type: TYPE_NORMAL
- en: The event listener for the `mapView` works slightly differently as compared
    to other event listeners. You need to capture an annotation click from the `mapView`
    parent object and then work out which annotation was tapped by means of a custom
    ID. In this case, we have used the `id` property to determine which annotation
    was the start location and which was the end location. The start location is set
    to `id 1`, while the end location is simply set to `id 2`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you may wish to perform different actions based on whether the
    right or left button on the annotation pin was tapped. We can determine this by
    using the event property's `(e) clicksource`. A comparison to a string of either
    `leftButton` or `rightButton` will let you know which was tapped and you can program
    functions into your app accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3968EXP_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing routes on your MapView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to track our movements and draw a route on the map, we need to create
    an array of points, each with its own latitude and longitude value. The MapView
    will take in this array of points as a property called route, and draw a series
    of lines to provide a visual representation of the route to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a timer that records our location every minute,
    and adds it to the points array. When each new point is recorded, we will access
    the Google Directions API to determine the distance and add that to our overall
    tally of how far we have traveled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe will not work on Android devices, as there is currently
    no support for Android routing in Titanium. However, it will work as described
    here for the iPhone and iPod Touch. There is an unsupported method of routing
    in Android, which you can read about at [http://bit.ly/pUq2v2](http://bit.ly/pUq2v2).
    You will need to use an actual iPhone or iPod Touch device to test this recipe,
    as the emulator will not be able to get your current location.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    6` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within your `mapView` click event, after the console logging to determine which
    button was tapped and which annotation, type in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some variables we need to create now that need to be globally accessible
    to this JavaScript file. Add the following code to the very top of your `app.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the function for obtaining the user''s new current
    location and determining how far the new location is from our previous location.
    Create this new function above the click event for the `mapView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of things happening in this recipe, so let's break them down
    logically into their separate parts. First, we are obtaining the user's current
    location again on the start button's `click` event, and adding that as the first
    point in our `points` array. In order for our `mapView` component to use the array
    of point locations, we need to create a route object. This route object contains
    the array of points, plus the visual information such as the route's line, color,
    and thickness.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we are creating a timer using `setInterval().` This timer will only
    start when both the `timerStarted` variable is set to false, and when we can determine
    that the button tapped was indeed the right "start" button on one of our annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Our timer is set to execute every 60 seconds, or as required by the code, 60,000
    milliseconds. This means that every minute the function called `recordCurrentLocation()`
    will be executed. This function does the processing for determining our current
    location, and adds the new location to our "points" array. It then performs an
    HTTP request call to the Google APIs, which performs a distance calculation between
    our newest point, and the point location that we were at previously. This new
    distance is added to our total distance variable, called `distanceTraveled`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, whenever the user taps the *stop* button on the end annotation, the
    timer is stopped and the user is presented with an `alertDialog` showing the total
    value for how far they have traveled in meters. The following screenshot shows
    the route being drawn from our start to end location, and then the alert with
    the distance traveled when the *stop* button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3968EXP_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring your heading using the device compass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, our final recipe for our chapter on Maps and GPS, we will be
    using the inbuilt device compass to determine your heading. We'll present that
    heading using an image of an arrow to represent the direction visually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this recipe will not work on older iPhone devices, such as the iPhone
    3G, which lack the compass. You will need to use an actual device to test this
    recipe, as the emulator will not be able to get your current heading either.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 3/Recipe
    7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for the Exercise Tracker application built in this chapter
    can be found in the `/Chapter 3/Exercise Tracker` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to your `app.js` file, just before you perform a `win1.open()`
    method call at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are first creating an `imageView` and setting its image property to our
    arrow image. Initially, this will face towards the top of the screen, and will
    indicate north. This `imageView` is then added to our `Window` object. The heading
    source code for this recipe is performing two similar tasks: one gets our *initial*
    heading and the second fires on set intervals to get our *current* heading. When
    the heading is obtained for either the current position or the new position, we
    use the `magneticHeading` property to determine the angle (direction) in which
    we are facing, and use a simple transformation to rotate the arrow in that direction.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry if you don't understand what a 2D matrix is, or how the transformation
    is performing the rotation of our image! We will be covering transformations,
    rotations, and animations in [Chapter 7](ch07.html "Chapter 7. Creating Animations,
    Transformations, and Understanding Drag-and-drop"),
  prefs: []
  type: TYPE_NORMAL
