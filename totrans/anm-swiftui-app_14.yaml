- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Creating a Color Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个颜色游戏
- en: In the last chapter, we built a game where the user had to find words by using
    the letters of a larger word. In this project, we will continue the “finding”
    theme and build another game, where the user must find colors within a broader
    color.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个游戏，用户必须使用更大单词的字母来找到单词。在本项目中，我们将继续“寻找”主题，并构建另一个游戏，其中用户必须在更广泛的颜色中找到颜色。
- en: The goal of this project will be to generate a random RGB color and then have
    the user manipulate separate sliders for each of the individual RGB values in
    order to completely match that random color. For example, there will be one slider
    for red, one slider for green, and one slider for blue, with each slider containing
    a range from 0 to 255 (the range of each RGB value). Then, the user will have
    to adjust those sliders to see whether they can find the exact RGB random color.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标将是生成一个随机的RGB颜色，然后让用户操作每个单独RGB值的独立滑块，以完全匹配那个随机颜色。例如，将有一个用于红色的滑块，一个用于绿色的滑块，一个用于蓝色的滑块，每个滑块包含从0到255的范围（每个RGB值的范围）。然后，用户将必须调整这些滑块，看看他们是否能找到确切的RGB随机颜色。
- en: We will also add three difficulty levels to the game, from easy to extreme.
    And if the user is skilled enough to work out the individual RGB values in the
    given color, we will display a shower of confetti over the user interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为游戏添加三个难度级别，从简单到极端。如果用户足够熟练，能够计算出给定颜色中的单个RGB值，我们将在用户界面上方显示一场纸屑雨。
- en: In building this game, you will learn about adding pre-built animations to a
    project using Swift packages, which includes the aforementioned confetti animation
    for when the user gets a high score. We will also add a spring animation to SwiftUI
    sliders and make them visible when needed, and invisible when not.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个游戏的过程中，您将学习如何使用Swift包将预构建的动画添加到项目中，包括当用户获得高分时的上述纸屑动画。我们还将为SwiftUI滑块添加弹簧动画，并在需要时使其可见，不需要时使其不可见。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Understanding colors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解颜色
- en: Creating the `Title` View
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“Title”视图
- en: Creating the target and guess circles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建目标和猜测圆圈
- en: Creating the `Picker` View
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“Picker”视图
- en: Creating the target and guess rectangles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建目标和猜测矩形
- en: Making the color sliders
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建颜色滑块
- en: Keeping track of the user’s score with a button
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按钮跟踪用户的得分
- en: Showing the user’s score in an `Alert` View
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“Alert”视图中显示用户的得分
- en: Resetting the game
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置游戏
- en: Adding a background
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加背景
- en: Adding confetti using Swift packages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swift包添加纸屑
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As always, you can find the code and download the completed project from the
    `Chapter 14` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，您可以从GitHub上的“第14章”文件夹中找到代码并下载完成的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).
- en: Understanding colors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解颜色
- en: Before we begin, let’s just have a quick look at colors. There are two color
    models that you may be familiar with, primary colors and RGB colors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们先快速了解一下颜色。您可能熟悉两种颜色模型，即原色和RGB颜色。
- en: Primary colors are the basic colors from which all other colors can be derived.
    In traditional color theory, the primary colors are red, blue, and yellow. Primary
    colors are used in many different fields, such as art, printing, and graphic design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 原色是从中可以派生出所有其他颜色的基本颜色。在传统色彩理论中，原色是红色、蓝色和黄色。原色在许多不同的领域中使用，例如艺术、印刷和图形设计。
- en: RGB (which is short for Red, Green, and Blue) colors make up a color model in
    which the colors are combined to create different intensities of red, green, and
    blue light that can be displayed on electronic displays and devices, such as computers,
    TVs, phones, and tablets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: RGB（代表红色、绿色和蓝色）颜色构成一个颜色模型，其中颜色被组合以创建不同强度的红、绿和蓝色光，这些光可以在电子显示屏和设备上显示，例如计算机、电视、手机和平板电脑。
- en: RGB colors are represented by their red, green, and blue components, each of
    which has a value between 0 and 255\. The value 0 represents the absence of that
    color, while 255 represents the maximum intensity of that color. By varying the
    values of the RGB components, a wide range of colors can be created. For example,
    (255, 0, 0) represents pure red, (0, 255, 0) represents pure green, and (0, 0,
    255) represents pure blue. Combinations of these colors can create many different
    colors and hues of colors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RGB颜色由它们的红色、绿色和蓝色分量表示，每个分量都有一个介于0到255之间的值。值0表示该颜色的缺失，而255表示该颜色的最大强度。通过改变RGB分量的值，可以创建广泛的颜色。例如，(255,
    0, 0)表示纯红色，(0, 255, 0)表示纯绿色，(0, 0, 255)表示纯蓝色。这些颜色的组合可以创建许多不同的颜色和色调。
- en: We will be adding three sliders, which will represent each RGB color, and the
    user has to manipulate those sliders to find a target color by combining different
    amounts of those RGB colors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加三个滑块，它们将代表每个RGB颜色，用户必须操作这些滑块，通过组合不同数量的这些RGB颜色来找到目标颜色。
- en: Let’s jump right in and get this game off the ground. We’ll start by adding
    a title to the user interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始并让这个游戏起飞。我们将首先向用户界面添加一个标题。
- en: Creating the Title view
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标题视图
- en: Let’s get started by creating a new Xcode project – I’m calling it `VStack`
    to organize the views vertically.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的Xcode项目开始——我将其命名为`VStack`以垂直组织视图。
- en: 'The first objective here will be to give the UI a title; it’s not a lot of
    code, but we’ll still put it in its own file anyway. So, create a new SwiftUI
    View file, and call it `TitleView`, then add the following code to the `body`
    property:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的第一个目标将是给UI添加一个标题；代码不多，但我们仍然将其放在自己的文件中。因此，创建一个新的SwiftUI视图文件，并将其命名为`TitleView`，然后在`body`属性中添加以下代码：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside the `HStack`, there are three `Text` views, each with different colors
    – `"Find"` with the red color, `"The"` with green, and `"Color"` with blue – all
    colored using the `foregroundColor` modifier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HStack`内部有三个`Text`视图，每个视图都有不同的颜色——“Find”用红色， “The”用绿色，“Color”用蓝色——所有这些颜色都是使用`foregroundColor`修饰符着色的。
- en: 'After the `HStack`, three additional modifiers are applied to the view. The
    first is `.foregroundColor(.blue)`, which sets the text color of all the `Text`
    views to blue. The next is `.fontWeight(.black)`, which sets the font weight of
    all the `Text` views to bold. And lastly, `.font(Font.system(size: 35, design:
    .serif))` sets the font and size of all the `Text` views to `35` points with a
    Serif design font.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在`HStack`之后，对视图应用了三个额外的修饰符。第一个是`.foregroundColor(.blue)`，它将所有`Text`视图的文本颜色设置为蓝色。接下来是`.fontWeight(.black)`，它将所有`Text`视图的字体重量设置为粗体。最后，`.font(Font.system(size:
    35, design: .serif))`将所有`Text`视图的字体和大小设置为35点，采用Serif设计字体。'
- en: 'Next, we’ll go back into `ContentView` and display the title by adding the
    following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到`ContentView`并添加以下代码来显示标题：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I also added some `padding` so the `Title` view won’t be too close to the notch
    at the top of the iPhone when we finish adding all the views.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了一些`padding`，这样在添加完所有视图后，`Title`视图就不会太靠近iPhone顶部的缺口。
- en: 'And now, we can see the colorful title that starts off the UI:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到启动UI的彩色标题：
- en: '![Figure 14.1: Game title ](img/B18674_14_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1：游戏标题](img/B18674_14_01.jpg)'
- en: 'Figure 14.1: Game title'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：游戏标题
- en: With that, we can move on to the next part of the UI, the target and guess circles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以继续到UI的下一部分，即目标和猜测圆圈。
- en: Creating the target and guess circles
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标和猜测圆圈
- en: 'The next task is to create two colored circles:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是创建两个彩色圆圈：
- en: One circle will be the target circle, which will show a randomly generated color;
    because it is an RGB color, the user will need to combine three RGB values to
    find this target color.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个圆圈将是目标圆圈，它将显示一个随机生成的颜色；因为它是一个RGB颜色，用户需要组合三个RGB值来找到这个目标颜色。
- en: The other circle will be their “guess” circle – kind of like a sketchpad, where
    the user can see their current progress as they manipulate the sliders.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个圆圈将是他们的“猜测”圆圈——有点像草图板，用户可以在操作滑块时看到他们的当前进度。
- en: These two circles will be created in their own SwiftUI file, so let’s make them
    now. Press *Command + N*, select `TargetAndGuessCircleView`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个圆圈将创建在它们自己的SwiftUI文件中，所以现在让我们创建它们。按*Command + N*，选择`TargetAndGuessCircleView`。
- en: 'We want to use this file inside of `ContentView` – in order to do so, we will
    need some `Binding` variables inside the struct:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在`ContentView`中使用这个文件——为了做到这一点，我们将在结构体内部需要一些`Binding`变量：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are seven variables needed for this file – three variables for the target
    circle, three variables for the guess circle, and one integer (which we will use
    for a `Picker` view) will allow the user to select a difficulty level.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件需要七个变量 – 三个用于目标圆，三个用于猜测圆，还有一个整数（我们将用于 `Picker` 视图）将允许用户选择难度级别。
- en: 'After adding those `Binding` properties, we notice we have an error in the
    `previews` struct. Remember that when we add these variables to a file, the `previews`
    struct always has to be updated with some dummy data in order for it to work again.
    So, modify the `previews` struct so it looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了那些 `Binding` 属性后，我们注意到 `previews` 结构体中有一个错误。记住，当我们向文件添加这些变量时，`previews` 结构体必须使用一些占位符数据更新，以便它再次工作。因此，修改
    `previews` 结构体，使其看起来像这样：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, let’s go back into the `body` property. We want to add a `ZStack`
    so that we can overlay the target circle over the guess circle. We can create
    these two circles with the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们回到 `body` 属性。我们想要添加一个 `ZStack`，以便我们可以将目标圆叠加在猜测圆上。我们可以使用以下代码创建这两个圆：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside the `ZStack`, we start off with the guess circle; this will be the bigger
    circle, with the `frame` height set to `200`. Here, we’re using an `if else` statement
    and checking the `selectedPickerIndex` variable to see what difficulty level the
    user has chosen. If they’ve chosen `0`; in that case, we will supply the green
    and blue RGB target colors to the user, so they only have to work out the red
    RGB target value. If they’ve selected `1`; in that case, we only supply the user
    with the blue RGB value, and they have to work out the red and green values themselves.
    Finally, if the user selected the `2`; in that case, we don’t supply the user
    with any RGB target values and they have to work out the individual target color
    value themselves.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ZStack` 中，我们首先处理猜测圆；这将是一个较大的圆，`frame` 高度设置为 `200`。在这里，我们使用了一个 `if else` 语句并检查
    `selectedPickerIndex` 变量以查看用户选择了哪个难度级别。如果他们选择了 `0`，那么我们将提供绿色和蓝色的 RGB 目标颜色给用户，这样他们只需要计算出红色的
    RGB 目标值。如果他们选择了 `1`，那么我们只向用户提供蓝色的 RGB 值，他们必须自己计算出红色和绿色的值。最后，如果用户选择了 `2`，那么我们不向用户提供任何
    RGB 目标值，他们必须自己计算出单独的目标颜色值。
- en: Next, we create the target circle – this will be the randomly generated colored
    circle that the user has to try and match by manipulating the sliders. Notice
    that we’re creating this circle much smaller, only `80` points, and because we
    are in a `ZStack`, this circle will be on top of the guess circle. The reason
    for this overlaying of circles is that as the user is trying to work out the colors,
    their guess circle will change in color and they can better visualize how close
    they are to the target color.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建目标圆 – 这将是用户需要通过操作滑块来尝试匹配的随机生成颜色的圆。请注意，我们创建的这个圆很小，只有 `80` 点，而且因为我们处于
    `ZStack` 中，这个圆将在猜测圆的上方。这种圆叠加的原因是，当用户试图确定颜色时，他们的猜测圆会改变颜色，他们可以更好地可视化他们离目标颜色有多接近。
- en: Lastly, at the end of the `ZStack`, we’re using the `onAppear` modifier. This
    modifier will run an action every time the `ZStack` gets redrawn; if the `ZStack`
    gets redrawn, it means the user chose to play a new game (using a button that
    we will create later) and the sliders will go back to **0**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `ZStack` 的末尾，我们使用了 `onAppear` 修饰符。这个修饰符会在 `ZStack` 重新绘制时运行一个动作；如果 `ZStack`
    重新绘制，这意味着用户选择了玩新游戏（使用我们稍后创建的按钮），滑块将回到 **0**。
- en: 'That finishes up the `TargetAndGuessCircleView` file. Let’s go back into `ContentView`
    and add the `State` variables that we need in order to display `TargetAndGuessCircleView`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 `TargetAndGuessCircleView` 文件。让我们回到 `ContentView` 并添加我们需要显示 `TargetAndGuessCircleView`
    的 `State` 变量：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are seven `State` properties, one for each of the `Binding` properties
    we made in the previous file. The variables are each set to a random double value
    between `0` and `1` using the `Double.random(in: 0..<1)` method. The function
    will generate a new random number every time it’s called, meaning that every time
    the user starts a new game, a new random value will be used to pick an RGB value.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '该文件中有七个 `State` 属性，每个属性对应我们在上一个文件中创建的 `Binding` 属性之一。变量分别使用 `Double.random(in:
    0..<1)` 方法设置为介于 `0` 和 `1` 之间的随机双精度值。函数每次被调用时都会生成一个新的随机数，这意味着每次用户开始新游戏时，都会使用一个新的随机值来选择
    RGB 值。'
- en: 'Continuing from here, we notice that there’s an error in the `Previews` struct
    of `ContentView`. This is a familiar error – it is Xcode telling us that we declared
    a property in the `ContentView` struct, yet we are not including it here in the
    `Previews` struct. Let’s fix that by inputting some data into the `Previews` struct,
    like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里继续，我们注意到`ContentView`的`Previews`结构体中有一个错误。这是一个熟悉的错误 - 这是Xcode告诉我们我们在`ContentView`结构体中声明了一个属性，但我们没有在`Previews`结构体中包含它。让我们通过在`Previews`结构体中输入一些数据来修复这个问题，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That will fix the error in `ContentView`, but we also need to update the Swift
    file that contains the main startup code for the project. That file will be named
    the same as what you named your app – I named this project `Find the Color`, so
    in the Project Navigator to the left of Xcode, there will be a file with a Swift
    extension, called `Find_The_ColorApp.swift`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以修复`ContentView`中的错误，但我们也需要更新包含项目主要启动代码的Swift文件。该文件将使用与您为应用程序命名的相同名称 - 我将此项目命名为`Find
    the Color`，因此在Xcode左侧的项目导航器中，将有一个扩展名为Swift的文件，称为`Find_The_ColorApp.swift`。
- en: 'Click on that Swift file, and update the code to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击那个Swift文件，并将代码更新为以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now go back into `ContentView`, call the `TargetAndGuessCircleView`
    file, and pass in the appropriate `State` variables. Add the following code directly
    underneath the title code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回到`ContentView`，调用`TargetAndGuessCircleView`文件，并传入适当的`State`变量。在标题代码下方直接添加以下代码：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is how the UI should look now:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是UI现在的样子：
- en: '![Figure 14.2: Target and guess circles ](img/B18674_14_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2：目标和猜测圆圈](img/B18674_14_02.jpg)'
- en: 'Figure 14.2: Target and guess circles'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：目标和猜测圆圈
- en: Let’s continue by adding the `Picker` view to allow the user to select the difficulty
    for the game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加`Picker`视图，以便用户可以选择游戏的难度。
- en: Creating the Picker view
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选择器视图
- en: To create the `Picker` view, let’s make a new SwiftUI View file called `PickerView`
    for this purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Picker`视图，让我们为此目的创建一个新的SwiftUI View文件，命名为`PickerView`。
- en: 'Inside this file, we need to add a `Binding` property so that we can use it
    inside `ContentView`, as well as add an array of titles for the picker:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们需要添加一个`Binding`属性，以便我们可以在`ContentView`中使用它，以及为选择器添加一个标题数组：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code here has a `Binding` variable to hold the value of `selectedPickerIndex`;
    that way, we can keep track of which button on the picker the user has selected.
    Then, we have a `State` array of titles that we will use on the individual picker
    buttons, along with an appropriate emoji signifying the difficulty level.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码有一个`Binding`变量来保存`selectedPickerIndex`的值；这样，我们可以跟踪用户选择了选择器上的哪个按钮。然后，我们有一个包含标题的`State`数组，我们将使用它来为单个选择器按钮添加适当的表情符号，以表示难度级别。
- en: 'Next, as we’ve done before, update the `Previews` struct with some dummy data,
    to satisfy Xcode:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，就像我们之前做的那样，使用一些虚拟数据更新`Previews`结构体，以满足Xcode的要求：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the previews up and running, we can now create and style the `Picker`
    control. Move into the `body` property and add this code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 预览功能运行正常后，我们现在可以创建和设置`Picker`控件。进入`body`属性并添加以下代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is what we are doing here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里所做的事情。
- en: 'The code adds a `Picker` component and a `Text` component. The `VStack` is
    used to arrange the `Picker` and `Text` components vertically. `Picker` is used
    to display a list of options, with the options being the elements in the `levels`
    array; it takes two arguments: `Numbers` and `selection: $selectedPickerIndex`,
    where `Numbers` is the label for the picker and `$selectedPickerIndex` is a state
    variable that keeps track of the currently selected option.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '代码添加了一个`Picker`组件和一个`Text`组件。`VStack`用于垂直排列`Picker`和`Text`组件。`Picker`用于显示选项列表，选项是`levels`数组中的元素；它接受两个参数：`Numbers`和`selection:
    $selectedPickerIndex`，其中`Numbers`是选择器的标签，`$selectedPickerIndex`是一个状态变量，用于跟踪当前选定的选项。'
- en: The `ForEach` loop is used to iterate through the `levels` array, creating a
    new `Text` component for each element in the array. Each `Text` component is configured
    to display the corresponding element from the `levels` array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach`循环用于遍历`levels`数组，为数组中的每个元素创建一个新的`Text`组件。每个`Text`组件被配置为显示来自`levels`数组的相应元素。'
- en: The `pickerStyle` method is used to change the appearance of the picker to a
    segmented picker style. We have used the `background`, `cornerRadius`, `padding`,
    and `shadow` modifiers before, and these apply various visual styles to the picker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickerStyle`方法用于将选择器的外观更改为分段选择器样式。我们之前已经使用了`background`、`cornerRadius`、`padding`和`shadow`修饰符，并将各种视觉样式应用到选择器上。'
- en: 'The `Text` component is used to display the difficulty level in the UI under
    the `Picker` component. It takes the `"Difficulty Level: " + "(levels[selectedPickerIndex])"`
    string and makes it bold, then applies some padding and animation to it. The animation
    is added so that instead of the difficulty level string appearing and disappearing
    instantly, it will ease in and out with a `0.2`-second duration, for a smoother
    transition in the UI.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`文本`组件用于在`选择器`组件下方显示UI中的难度级别。它将字符串`"难度级别: " + "(levels[selectedPickerIndex])"`设置为粗体，然后对其应用一些填充和动画。动画被添加，以便难度级别字符串不会立即出现和消失，而是以`0.2`秒的持续时间平滑地进入和退出，以实现更平滑的UI过渡。'
- en: Now, we have a `Picker` component that can be used to select the difficulty
    level of the game, and a `Text` string to display that level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个`选择器`组件，可以用来选择游戏的难度级别，以及一个`文本`字符串来显示该级别。
- en: 'The result is shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Figure 14.3: The segmented picker ](img/B18674_14_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3：分段选择器](img/B18674_14_03.jpg)'
- en: 'Figure 14.3: The segmented picker'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：分段选择器
- en: 'With the `Picker` control done, move back into `ContentView` and call `PickerView`directly
    under the target and guess circle code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成选择器控制后，回到`ContentView`并直接在目标和猜测圆圈代码下方调用`PickerView`：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That code will add the `PickerView` file into the UI under the target and guess
    circles. The result is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`PickerView`文件添加到目标和猜测圆圈下方的UI中。结果如下所示：
- en: '![Figure 14.4: The picker in the UI ](img/B18674_14_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4：UI中的选择器](img/B18674_14_04.jpg)'
- en: 'Figure 14.4: The picker in the UI'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：UI中的选择器
- en: Now, if you click on the picker, you will see that the guess circle changes
    color; it won’t change to more than three shades of colors, as the picker displays
    a random color from each RGB value while the preview is running. If you stop the
    preview and restart it, another set of three random colors will be displayed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击选择器，你会看到猜测圆圈的颜色会改变；它不会改变到超过三种色调的颜色，因为选择器在预览运行时显示每个RGB值的一个随机颜色。如果你停止预览并重新启动它，将显示另一组三种随机颜色。
- en: Shortly, we will implement sliders to change the guess circle colors, and change
    the target circle color when the user starts a new game. Before that, let’s continue
    with the next part of the UI, making target and guess rectangles. I’ll explain
    what they are for next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将实现滑块来改变猜测圆圈的颜色，并在用户开始新游戏时改变目标圆圈的颜色。在那之前，让我们继续下一部分的UI，制作目标和猜测矩形。我将在下面解释它们的作用。
- en: Creating the target and guess rectangles
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标和猜测矩形
- en: So far, we have given the user a guess circle so they can see how close they
    are coming to the target color. Let’s do something similar to that and give them
    another visual cue – let’s create a guess rectangle and a target rectangle, and
    put them directly under the `Picker` control. We can also add an RGB value indicator,
    so they can see the actual values of each slider as they change, which can be
    helpful when they’re trying to figure out how much of the slider they need to
    move and in which direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们给用户提供了一个猜测圆圈，这样他们可以看到他们离目标颜色有多近。让我们做类似的事情，给他们另一个视觉提示——让我们创建一个猜测矩形和一个目标矩形，并将它们直接放在`选择器`控制之下。我们还可以添加一个RGB值指示器，这样他们可以看到每个滑块的实际值，当他们在尝试确定需要移动滑块的多少以及哪个方向时，这可能很有帮助。
- en: 'Start by creating a new file to make these rectangles, called `TargetAndGuessRectView`.
    This file will contain very similar code to the `TargetAndGuessCircleView` file,
    which means adding the needed `Binding` properties:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新文件来制作这些矩形，命名为`TargetAndGuessRectView`。这个文件将包含与`TargetAndGuessCircleView`文件非常相似的代码，这意味着添加所需的`绑定`属性：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should be familiar with these `Binding` variables, as we’ve created them
    before in the `TargetAndGuessCircleView` file. Actually, you can refactor all
    the code and combine the two guess and target files into one file if you’d like,
    or create a data model and make the properties available to all the files... I’ll
    leave that as a challenge for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉这些`绑定`变量，因为我们之前在`TargetAndGuessCircleView`文件中创建过它们。实际上，如果你想的话，可以重构所有代码并将两个猜测和目标文件合并到一个文件中，或者创建一个数据模型并使属性对所有文件可用...我将把这个留给你作为一个挑战。
- en: 'Moving on, we need a combination of VStacks and HStacks to position the `Rectangle`
    and `Text` views. Add this code to the body of the file (I’ll explain it all next):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要结合使用`VStacks`和`HStacks`来定位`矩形`和`文本`视图。将此代码添加到文件的主体中（我将在下面解释它）：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here’s a breakdown of what the code is doing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对代码所做事情的分解。
- en: The first `VStack` contains a rectangle with the color determined by the values
    of `redTarget`, `greenTarget`, and `blueTarget`. It also has a corner radius of
    `5` and padding on the leading edge, with a height of `40`. Below the rectangle,
    there is a `Text` view displaying the `"Target Color to Match"` string in bold
    font.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `VStack` 包含一个矩形，其颜色由 `redTarget`、`greenTarget` 和 `blueTarget` 的值决定。它还拥有
    `5` 的圆角半径和前导边缘的填充，高度为 `40`。在矩形下方，有一个 `Text` 视图，以粗体字体显示 `"Target Color to Match"`
    字符串。
- en: The second `VStack` contains a rectangle with the color determined by the values
    of `redGuess`, `greenGuess`, and `blueGuess`, and is modified by the `rectModifier`
    struct (more on the `rectModifier` struct in a moment). The color of the rectangle
    is determined by `selectedPickerIndex`, which is an integer value. If `selectedPickerIndex`
    is `0`, the color is determined by `redGuess`, `greenTarget`, and `blueTarget`.
    If `selectedPickerIndex` is `1`, the color is determined by `redGuess`, `greenGuess`,
    and `blueTarget`. If `selectedPickerIndex` is `2`, the color is determined by
    `redGuess`, and `greenGuess`, `blueGuess`. Below the rectangle, there is an `HStack`
    containing an image and text displaying the values of `redGuess`, `greenGuess`,
    and `blueGuess`, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `VStack` 包含一个矩形，其颜色由 `redGuess`、`greenGuess` 和 `blueGuess` 的值决定，并且通过 `rectModifier`
    结构体（稍后将对 `rectModifier` 结构体进行详细介绍）进行修改。矩形的颜色由 `selectedPickerIndex` 决定，它是一个整数值。如果
    `selectedPickerIndex` 为 `0`，颜色由 `redGuess`、`greenTarget` 和 `blueTarget` 决定。如果
    `selectedPickerIndex` 为 `1`，颜色由 `redGuess`、`greenGuess` 和 `blueTarget` 决定。如果 `selectedPickerIndex`
    为 `2`，颜色由 `redGuess`、`greenGuess` 和 `blueGuess` 决定。在矩形下方，有一个包含图像和文本的 `HStack`，分别显示
    `redGuess`、`greenGuess` 和 `blueGuess` 的值。
- en: Now the target and guess rectangles are in place, as well as the three `Text`
    views that will display the RGB values as the user works the slider, let’s continue
    and look at that last bit of code, the `rectModifer` struct.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标和猜测矩形已经就位，以及三个将显示 RGB 值的 `Text` 视图，随着用户操作滑块，让我们继续查看最后一部分代码，即 `rectModifer`
    结构体。
- en: 'The `rectModifier` struct is a `ViewModifier` that modifies the `Rectangle`
    view. It is a struct that conforms to the `ViewModifier` protocol and defines
    a single method, `body(content: Content) -> some View`, which takes a single argument
    content of the `Content` type and returns a modified version of that content wrapped
    in a `view`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`rectModifier` 结构体是一个 `ViewModifier`，它修改 `Rectangle` 视图。它是一个符合 `ViewModifier`
    协议的结构体，并定义了一个单一的方法，`body(content: Content) -> some View`，该方法接受一个 `Content` 类型的单个参数
    `content`，并返回一个包裹在 `view` 中的修改后的内容版本。'
- en: In this specific case, the struct is modifying the appearance of a `rectangle`
    view. The modifications are made by chaining together a series of view modifiers
    on the `content` parameter in the `body` method, such as setting the corner radius
    to `5`, adding `padding` to the trailing edge, and setting the height of the rectangle
    to `40`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，结构体正在修改 `rectangle` 视图的外观。通过在 `body` 方法中对 `content` 参数进行一系列视图修饰符的链式操作来完成修改，例如将圆角半径设置为
    `5`，添加尾随边缘的填充，并将矩形的宽度设置为 `40`。
- en: When `rectModifier()` is called, it is passed the `rectangle` view as the `content`
    parameter, and it applies the modifications defined in the struct to that `rectangle`
    view, returning the modified version of that view. In other words, `rectModifier()`
    is a simple way to package a set of modifiers that can be applied to any view,
    and it provides a way to reuse the same set of modifiers on multiple views, saving
    on coding time and readability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `rectModifier()` 时，它将 `rectangle` 视图作为 `content` 参数传递，并将结构体中定义的修改应用于该 `rectangle`
    视图，返回修改后的视图版本。换句话说，`rectModifier()` 是一种简单的方式来封装可以应用于任何视图的一组修饰符，并且它提供了一种在多个视图中重用同一组修饰符的方法，从而节省了编码时间和可读性。
- en: 'Here is the result of what we just coded:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们所编写的代码的结果：
- en: '![Figure 14.5: Target and guess rectangles ](img/B18674_14_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5：目标和猜测矩形](img/B18674_14_05.jpg)'
- en: 'Figure 14.5: Target and guess rectangles'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：目标和猜测矩形
- en: The sliders will now display the RGB values for the user.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块现在将显示用户的 RGB 值。
- en: 'Now, it’s time to go back into the `ContentView` and make a call to this file
    directly underneath the `Picker` code so that we can display these two rectangles
    and text in the main UI:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回到 `ContentView` 中，在 `Picker` 代码直接下方调用此文件了，这样我们就可以在主 UI 中显示这两个矩形和文本：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, this is familiar code – we are simply calling `TargetAndGuessRectView`
    and passing in the appropriate `State` variables. Here is the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是熟悉的代码——我们只是调用 `TargetAndGuessRectView` 并传递适当的 `State` 变量。以下是结果：
- en: '![Figure 14.6: Target and Guess Rectangles in the UI ](img/B18674_14_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6：UI中的目标和猜测矩形](img/B18674_14_06.jpg)'
- en: 'Figure 14.6: Target and Guess Rectangles in the UI'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：UI中的目标和猜测矩形
- en: We just need the sliders, and a button to check the score, so let’s do that
    now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要滑块和一个检查得分的按钮，所以现在就做吧。
- en: Making the color sliders
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作颜色滑块
- en: To start creating the sliders, make a new SwiftUI View file and call it `SliderView`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建滑块，创建一个新的SwiftUI视图文件，并将其命名为`SliderView`。
- en: 'As the sliders are only used to manipulate the guess circle, we won’t need
    any `Target` variables in this file. Instead, we just need three `Guess` variables,
    as well as a variable to track the value of the picker control, which you can
    add like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于滑块仅用于操作猜测圆圈，我们在这个文件中不需要任何`Target`变量。相反，我们只需要三个`Guess`变量，以及一个用于跟踪选择器控件值的变量，你可以这样添加：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, we need to update the `Previews` struct, because it’s giving us this
    error: `Binding` variables in its `SliderView` struct initializer. Let’s give
    it what it wants, by updating `Previews` with the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要更新`Previews`结构体，因为它在`SliderView`结构体的初始化器中给出了这个错误：`Binding`变量。让我们给它想要的，通过以下代码更新`Previews`：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the previews operational again, let’s continue by making a separate struct
    for the creation of the slider itself. Add `CreateSlider` outside and underneath
    the `SliderView` struct:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预览功能恢复正常后，让我们继续创建一个用于创建滑块的单独的结构体。在`SliderView`结构体外部和下方添加`CreateSlider`：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code defines a new SwiftUI struct called `CreateSlider` that takes in
    two parameters: a `Binding` variable called `value` of the `Double` type, and
    a variable called `color` of the `Color` type.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的SwiftUI结构体`CreateSlider`，它接受两个参数：一个名为`value`的`Double`类型的`Binding`变量，以及一个名为`color`的`Color`类型的变量。
- en: Here is what each line of code does.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每行代码的作用。
- en: 'As we’ve seen before, `@Binding var value: Double` is a property wrapper that
    creates a two-way binding between the struct’s `value` variable and another variable.
    This allows the struct to read and write the value of the variable that it is
    bound to.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们之前所见，`@Binding var value: Double`是一个属性包装器，它创建了一个结构体`value`变量和另一个变量之间的双向绑定。这允许结构体读取和写入它所绑定的变量的值。'
- en: '`var color: Color` creates a variable called `color` that is of the `Color`
    type.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`var color: Color`创建了一个名为`color`的变量，其类型为`Color`。'
- en: '`Text("0")` creates a `Text` view with a value of `0`, and gets the following
    modifiers placed on it: `.bold()` makes the text bold, and `foregroundColor(color)`
    sets the color of the text to the `color` variable passed to the struct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text("0")`创建了一个值为`0`的`Text`视图，并对其应用了以下修改器：`.bold()`使文本加粗，`foregroundColor(color)`将文本的颜色设置为传递给结构体的`color`变量。'
- en: 'Then we add the slider, `Slider(value: $value, in: 0.0...1.0)`. This creates
    a `Slider` view that reads and writes its value to the `value` property. The `in`
    parameter sets the range of the slider to go from `0.0` to `1.0`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们添加滑块，`Slider(value: $value, in: 0.0...1.0)`。这创建了一个`Slider`视图，它读取并写入其值到`value`属性。`in`参数设置了滑块的取值范围为`0.0`到`1.0`。'
- en: 'Then, we add another `Text` view, add the text `255`, and put some padding
    on it using `.padding(.init(top: 10, leading: 10, bottom: 10, trailing: 10))`.
    This is a `View` modifier that adds a padding of `10` points to the top, leading,
    bottom, and trailing edge of the view.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们再添加另一个`Text`视图，添加文本`255`，并使用`.padding(.init(top: 10, leading: 10, bottom:
    10, trailing: 10))`给它添加一些填充。这是一个`View`修改器，它给视图的顶部、前导、底部和尾部边缘添加了`10`点的填充。'
- en: 'With the slider created, we will need to call this `CreateSlider` struct several
    times inside the `SliderView` struct and add some styling to it as well. So, back
    up into the `SliderView` struct, add the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块创建后，我们将在`SliderView`结构体内部多次调用`CreateSlider`结构体，并对其添加一些样式。所以，回到`SliderView`结构体，添加以下代码：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s break this code down. It starts off by defining a SwiftUI view called
    `SliderView` that uses a `VStack` to lay out three sliders for adjusting the values
    of the `redGuess`, `greenGuess`, and `blueGuess` properties. The struct has a
    `VStack` used to organize three sliders vertically.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码。它首先定义了一个名为`SliderView`的SwiftUI视图，该视图使用`VStack`来布局三个滑块，用于调整`redGuess`、`greenGuess`和`blueGuess`属性的值。这个结构体使用`VStack`来垂直组织三个滑块。
- en: Those three sliders are added by calls to the `CreateSlider` view. The `CreateSlider`
    view uses the `background` modifier and a capsule shape in order to outline the
    slider with a red color.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个滑块是通过调用`CreateSlider`视图添加的。`CreateSlider`视图使用`background`修改器和胶囊形状来用红色勾勒出滑块。
- en: Next up is a `switch` statement – since we are using one for the first time,
    let me explain what it is and the difference between using a `switch` statement
    and an `if` `else` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`switch`语句——由于我们第一次使用它，让我解释一下它是什么，以及使用`switch`语句和使用`if else`语句之间的区别。
- en: So, an `if else` statement is used to evaluate a Boolean expression and execute
    a block of code if the expression is `true`, and another block of code if the
    expression is `false`. It can be used for any type of condition or comparison.
    A `switch` statement, on the other hand, is used to match a value or expression
    against multiple possible cases and execute a block of code for the matching case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`if else`语句用于评估布尔表达式，如果表达式为`true`，则执行一个代码块，如果表达式为`false`，则执行另一个代码块。它可以用于任何类型的条件或比较。另一方面，`switch`语句用于将值或表达式与多个可能的案例进行匹配，并为匹配的案例执行一个代码块。
- en: A `switch` statement is typically used for matching against multiple possible
    values for a single variable or expression and is often used for situations where
    multiple conditions need to be checked in a more concise and readable way. For
    example, when you have multiple conditions with multiple `if else` statements,
    you can use a `switch` statement over `if else`. It makes the code more readable
    and easier to maintain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句通常用于匹配单个变量或表达式的多个可能值，并且常用于需要以更简洁和可读的方式检查多个条件的情况。例如，当你有多个条件，并且使用多个`if
    else`语句时，你可以使用`switch`语句而不是`if else`。这使得代码更易于阅读和维护。'
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In general, `if else` statements are good for complex conditions, while `switch`
    statements are good for simple conditions. In Swift, you can use either, depending
    on what you are trying to accomplish.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`if else`语句适用于复杂条件，而`switch`语句适用于简单条件。在Swift中，你可以根据要达成的目标选择使用其中之一。
- en: So, going back to our code, the `switch` statement checks the `selectedPickerIndex`
    value to see whether it is equal to `1`; if so, it means the user selected the
    `selectedPickerIndex` value is equal to `2`, it will create both the green and
    blue sliders, because the user has selected the `selectedPickerIndex` is not `1`
    or `2`, it will return an empty view.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们的代码，`switch`语句检查`selectedPickerIndex`的值，看它是否等于`1`；如果是，这意味着用户选择了`selectedPickerIndex`的值等于`2`，它将创建绿色和蓝色滑块，因为用户选择的`selectedPickerIndex`不是`1`或`2`，它将返回一个空视图。
- en: Next, the `CreateSlider` struct is used to create the sliders, and it takes
    two arguments, `value` and `color`. It displays the minimum and maximum values
    of the slider and it uses the `color` argument to change the color of the `"0"`
    text view and the `"255"` text view.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`CreateSlider`结构体创建滑块，它接受两个参数，`value`和`color`。它显示滑块的最小和最大值，并使用`color`参数改变`"0"`文本视图和`"255"`文本视图的颜色。
- en: '`SliderView` uses the `CreateSlider` struct to create the sliders for RGB colors.
    The `selectedPickerIndex` binding is used to decide which sliders to show, based
    on the user’s selection.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`SliderView`使用`CreateSlider`结构体创建RGB颜色的滑块。`selectedPickerIndex`绑定用于根据用户的选取决定显示哪些滑块。'
- en: '`SliderView` is now complete, so let’s use it inside `ContentView`. Add the
    following code just after the `Picker` code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`SliderView`现在已经完成，所以让我们在`ContentView`中使用它。在`Picker`代码之后添加以下代码：'
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code calls the `SliderView` struct and fills in the `Binding` variables,
    then adds a spring animation to the sliders as they appear and disappear in the
    UI. The `interactiveSpring` animation is a type of animation that simulates the
    behavior of a spring, and takes three parameters:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用`SliderView`结构体并填充`Binding`变量，然后在UI中滑块出现和消失时添加弹簧动画。`interactiveSpring`动画是一种模拟弹簧行为的动画，它接受三个参数：
- en: '`response`: This value controls the stiffness of the spring. A lower value
    will result in a softer spring, and a higher value will result in a stiffer spring.
    A value of `0.4` will provide a moderate stiffness.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`：此值控制弹簧的刚度。较低的值将导致弹簧较软，而较高的值将导致弹簧较硬。`0.4`的值将提供适中的刚度。'
- en: '`dampingFraction`: This value controls the damping of the spring, which is
    a measure of how quickly the spring’s oscillations will die out. A lower value
    will result in a spring with less damping, and a higher value will result in a
    spring with more damping. A value of `0.5` means that the spring’s oscillations
    will die out relatively quickly.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dampingFraction`：这个值控制弹簧的阻尼，这是衡量弹簧振荡衰减速度的一个指标。较低的值将导致阻尼较小的弹簧，而较高的值将导致阻尼较大的弹簧。`0.5`的值意味着弹簧的振荡会相对较快地衰减。'
- en: '`blendDuration`: This value controls the duration of the animation’s blending.
    A lower value will result in a shorter blend duration, and a higher value will
    result in a longer blend duration. A value of `0.5` seconds is a moderate blend
    duration.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendDuration`：这个值控制动画混合的持续时间。较低的值将导致较短的混合持续时间，而较高的值将导致较长的混合持续时间。`0.5`秒的值是一个适中的混合持续时间。'
- en: 'As well as the `interactiveSpring` animation, we’re using the `scaleEffect`
    modifier and passing in a value of `1`. What this does is help smooth out the
    animation as each slider appears and disappears. Go ahead and try it out. If you
    click on the picker control to choose a difficulty level, each slider will appear
    and disappear on the screen with a springy animation to it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`interactiveSpring`动画之外，我们还使用了`scaleEffect`修饰符，并传入了一个值为`1`的值。这样做有助于平滑动画，因为每个滑块出现和消失时。试试看。如果你点击选择器控件来选择难度级别，每个滑块都会在屏幕上以弹簧动画的方式出现和消失：
- en: '![Figure 14.7: The sliders ](img/B18674_14_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7：滑块](img/B18674_14_07.jpg)'
- en: 'Figure 14.7: The sliders'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：滑块
- en: As you move the sliders, the guess circle color will update smoothly, and the
    RGB values will change in the RGB text string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动滑块时，猜测圆的颜色将平滑更新，RGB值将在RGB文本字符串中改变。
- en: The last UI component to add is a button that will let the user check their
    score as they play.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的最后UI组件是一个按钮，允许用户在游戏过程中检查他们的分数。
- en: Keeping track of the user’s score with a button
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮跟踪用户的分数
- en: To make this a game, the user needs a way to check their progress and see a
    number that reflects how close they are to a perfect score/color match.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个成为游戏，用户需要一种方式来检查他们的进度并看到一个数字，反映他们离完美分数/颜色匹配有多近。
- en: 'Let’s add a button right after the `SliderView` struct’s `Spacer()` in `ContentView`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ContentView`中的`SliderView`结构的`Spacer()`之后添加一个按钮：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code creates a `Button` view, which we have named `Check Score`. The button
    gets styled with a black foreground, yellow background, padding, a corner radius,
    and finally, a black shadow to make the button stand out a bit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`Check Score`的`Button`视图。按钮使用黑色前景、黄色背景、填充、圆角半径，最后是一个黑色阴影，使按钮略显突出。
- en: The body of the button is currently empty right now, but what we want to do
    is to put some code in there that will trigger an alert and show the user their
    current score, so that they know how close they are to the target value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的主体目前是空的，但我们的目的是在那里放入一些代码，这将触发一个警报并显示用户的当前分数，这样他们就知道自己离目标值有多近。
- en: 'To do this, we need to create a function that calculates a score. So, at the
    bottom of the `ContentView` struct, add this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要创建一个计算分数的函数。因此，在`ContentView`结构的底部，添加以下代码：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code defines a function named `calculateScore` that returns an `Int` value.
    This function is used to calculate a score based on the difference between the
    `guess` values of `red`, `green`, and `blue`, and the `target` values of `red`,
    `green`, and `blue`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`calculateScore`的函数，它返回一个`Int`值。这个函数用于根据`red`、`green`和`blue`的`guess`值与`red`、`green`和`blue`的`target`值之间的差异来计算分数。
- en: Here’s how it works. The function first calculates the difference between the
    `guess` values and the `target` values for `red`, `green`, and `blue`. Next, it
    calculates `easyDifference` by getting the square root of the `redDiff` variable.
    Next, it calculates `hardDifference` by adding the square of the `greenDiff` variable
    to `easyDifference`. Then, it calculates `extremeDifference` by adding the square
    root of `blueDiff` to `hardDifference`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理。函数首先计算`guess`值和`target`值之间的差异，针对`red`、`green`和`blue`。接下来，它通过获取`redDiff`变量的平方根来计算`easyDifference`。然后，它通过将`greenDiff`变量的平方加到`easyDifference`上来计算`hardDifference`。最后，它通过将`blueDiff`变量的平方根加到`hardDifference`上来计算`extremeDifference`。
- en: 'After that, it uses a `switch` statement to determine which level of difficulty
    is currently selected, and assigns the `calculatedDifference` variable a value
    based on that:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它使用`switch`语句来确定当前选中的难度级别，并根据该值分配`calculatedDifference`变量的值：
- en: If `selectedPickerIndex` is `0`, then `calculatedDifference` is the square root
    of `easyDifference`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`selectedPickerIndex`是`0`，则`calculatedDifference`是`easyDifference`的平方根
- en: If `selectedPickerIndex` is `1`, then `calculatedDifference` is the square root
    of `hardDifference`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`selectedPickerIndex`是`1`，则`calculatedDifference`是`hardDifference`的平方根
- en: If `selectedPickerIndex` is `2`, then `calculatedDifference` is the square root
    of `extremeDifference`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`selectedPickerIndex`是`2`，则`calculatedDifference`是`extremeDifference`的平方根
- en: If `selectedPickerIndex` is any other value, then `calculatedDifference` is
    set to `0.0`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`selectedPickerIndex`是任何其他值，则`calculatedDifference`设置为`0.0`
- en: Finally, it returns an `integer` value that is calculated by taking `(1.0 -
    calculatedDifference) * 100 + 0.5`, which is the final score.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它返回一个通过计算`(1.0 - calculatedDifference) * 100 + 0.5`得到的`integer`值，这是最终分数。
- en: This function is used to calculate a score based on how close the `guess` values
    are to the `target` values. The smaller the difference between the values, the
    higher the score will be. If the `guess` value is equal to the `target` value,
    the user gets a perfect score of 100.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于根据`guess`值与`target`值的接近程度计算一个分数。值之间的差异越小，分数越高。如果`guess`值等于`target`值，用户将获得完美的100分。
- en: Now, the `calculateScore` function is complete; let’s use it to show the user
    their score in an `Alert` view.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`calculateScore`函数已完成；让我们使用它来在`Alert`视图中显示用户的得分。
- en: Showing the user’s score in an Alert view
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在警告视图中显示用户的得分
- en: 'To create an `Alert` view, we first need a state variable to keep track of
    the alert and trigger it when the `state` value changes. At the top of the file,
    underneath the other variables we created, add the following `State` variable:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Alert`视图，我们首先需要一个状态变量来跟踪警告并在`state`值变化时触发它。在文件顶部，在其他变量下方添加以下`State`变量：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to add the `Alert` modifier after the `Button` code’s closing
    brace:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Button`代码的闭合括号后添加`Alert`修饰符：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code creates a title, a message, and two buttons – a primary button and
    a secondary button.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个标题、一条消息和两个按钮——一个主要按钮和一个次要按钮。
- en: The title will be the message to the user, and the message will be the user’s
    score. We’re doing that by calling the `calculatedScore` function inside a `Text`
    view using string interpolation; remember, the `calculateScore` function returns
    an integer, and that value will be shown to the user as their current score.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 标题将是用户的消息，消息将是用户的得分。我们通过在`Text`视图中调用`calculatedScore`函数并使用字符串插值来实现这一点；记住，`calculateScore`函数返回一个整数，该值将显示为用户的当前得分。
- en: Then, the primary button will prompt the user to start a new game, while the
    secondary button will prompt the user to continue playing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主要按钮将提示用户开始新游戏，而次要按钮将提示用户继续玩游戏。
- en: 'To trigger the alert, we need to toggle the `showAlert` variable to `true`
    inside the `Button` body, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发警告，我们需要在`Button`的主体内部将`showAlert`变量切换到`true`，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can try the game out. Slide the sliders and try to get as close to
    the target circle color as you can, then press the **Check Score** button to see
    your score:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试玩游戏。滑动滑块，尽量接近目标圆圈的颜色，然后按下**检查得分**按钮查看您的得分：
- en: '![ Figure 14.8: Alert view showing the user’s score ](img/B18674_14_08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8：显示用户得分的警告视图](img/B18674_14_08.jpg)'
- en: 'Figure 14.8: Alert view showing the user’s score'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：显示用户得分的警告视图
- en: From this screen, if the user presses **Continue Playing?**, the game will continue
    from where it left off. However, if they press **New Game?**, nothing will happen
    – that’s because we haven’t added any logic to start a new game yet. Let’s do
    that next.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕，如果用户按下**继续玩游戏？**，游戏将从上次离开的地方继续。然而，如果他们按下**新游戏？**，则不会发生任何事情——那是因为我们还没有添加任何逻辑来开始新游戏。让我们接下来做这件事。
- en: Resetting the game
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置游戏
- en: We want to give the user the opportunity to start a new game, and we can do
    that by adding a `reset` function to the file. This function will reset the sliders
    to **0** and generate another random target color for the middle target circle.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望给用户一个开始新游戏的机会，我们可以通过向文件中添加一个`reset`函数来实现这一点。此函数将滑块重置为**0**并为中间的目标圆圈生成另一个随机目标颜色。
- en: 'Add the following function underneath the `calculateScore` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculateScore`函数下方添加以下函数：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function creates new random colors and stores them in the `Target` variables.
    It also resets the `Guess` variables back to `0`, which will move all the sliders
    back to their starting points on the left.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建新的随机颜色并将它们存储在 `Target` 变量中。它还将 `Guess` 变量重置回 `0`，这将使所有滑块回到左侧的起始点。
- en: 'Let’s call the `reset` function inside the `Alert` modifier’s secondary button,
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Alert` 修饰符的次要按钮中调用 `reset` 函数，如下所示：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, when we press the secondary button, **New Game?**, a new game starts with
    a new target color, and the sliders are set back to their starting position:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们按下次要按钮时，**新游戏？**，一个新的游戏开始，带有新的目标颜色，滑块被设置回起始位置：
- en: '![Figure 14.9: Starting a new game ](img/B18674_14_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9：开始新游戏](img/B18674_14_09.jpg)'
- en: 'Figure 14.9: Starting a new game'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：开始新游戏
- en: The sliders are set back to zero, and a new random target color is generated
    and shown.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块被设置回零，并生成并显示一个新的随机目标颜色。
- en: Let’s finish this project by adding two more things – a background, and a confetti
    animation that will appear when the user gets a perfect score of 100.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加两个更多的事物来完成这个项目——一个背景，以及当用户得到 100 分完美分数时出现的纸屑动画。
- en: Adding a background
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加背景
- en: 'First, the background. You can find the resource for this project in the `Chapter
    14` folder on GitHub (it’s the only asset in the folder); just drag and drop the
    `background` image file into the Asset Catalog. After you’ve done that, add the
    following code in `ContentView`, after the closing brace of the main `VStack`,
    like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是背景。您可以在 GitHub 的 `第 14 章` 文件夹中找到此项目的资源（文件夹中唯一的资产）；只需将 `background` 图像文件拖放到资产目录中。完成此操作后，在
    `ContentView` 中，在主 `VStack` 的闭合括号之后添加以下代码：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we are using the `background` modifier, passing the name of the image,
    resizing it, and setting `edgesIgnoringSafeArea` to stretch it out throughout
    the whole screen. It’s a subtle background, but it has a nice pattern to it that
    I think works as a backdrop for the colorful UI:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `background` 修饰符，传递图像名称，调整大小，并将 `edgesIgnoringSafeArea` 设置为拉伸整个屏幕。这是一个微妙的背景，但它有一个漂亮的图案，我认为它适合作为彩色
    UI 的背景：
- en: '![Figure 14.10: Background added ](img/B18674_14_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10：添加背景](img/B18674_14_10.jpg)'
- en: 'Figure 14.10: Background added'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：背景已添加
- en: Now, let’s look at Swift packages, and how to make some confetti.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Swift 包，以及如何制作一些纸屑。
- en: Adding confetti using Swift packages
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swift 包添加纸屑
- en: A Swift package is pre-built software that we can use in any of our projects,
    in which all the coding work has been done for us; all we have to do is configure
    it in our project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 包是预先构建的软件，我们可以在我们的任何项目中使用它，其中所有编码工作都为我们完成；我们只需在我们的项目中配置它。
- en: 'To add a Swift package, in Xcode, go to the **File** menu and select **Add
    Packages…**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 Swift 包，在 Xcode 中，转到 **文件** 菜单并选择 **添加包…**：
- en: '![Figure 14.11: Add Packages… ](img/B18674_14_11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11：添加包…](img/B18674_14_11.jpg)'
- en: 'Figure 14.11: Add Packages…'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：添加包…
- en: 'In the **All Sources** window, enter [https://github.com/simibac/ConfettiSwiftUI.git](https://github.com/simibac/ConfettiSwiftUI.git)
    in the search box:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **所有源** 窗口中，在搜索框中输入 [https://github.com/simibac/ConfettiSwiftUI.git](https://github.com/simibac/ConfettiSwiftUI.git)：
- en: '![Figure 14.12: Adding the URL ](img/B18674_14_12.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12：添加 URL](img/B18674_14_12.jpg)'
- en: 'Figure 14.12: Adding the URL'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：添加 URL
- en: When the **Add Package** button is clicked, Xcode will add the Confetti package
    to the project. The Confetti package contains all the code needed to create all
    kinds of confetti, dispersed in different ways.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**添加包**按钮时，Xcode 将 Confetti 包添加到项目中。Confetti 包包含创建所有种类纸屑所需的所有代码，以不同的方式分散。
- en: 'Now, we need to import the Confetti framework into the `ContentView` file at
    the top:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 Confetti 框架导入到 `ContentView` 文件的最顶部：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need a variable that can trigger the confetti (placed after the other
    project variables):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个可以触发纸屑的变量（放置在其他项目变量之后）：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can call the `confettiCannon` initializer in `ContentView` just after
    the target and guess rectangle code, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `ContentView` 中调用 `confettiCannon` 初始化器，就在目标和猜测矩形代码之后，如下所示：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code calls the `confettiCannon` initializer, using the `counter` variable
    to trigger the animation. The number of pieces of confetti being created will
    be 100, and the `colors` array lets you add the colors that you want the confetti
    to be. `rainHeight` will set how high the confetti goes upward, and the radius
    will set how wide the confetti spreads.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码调用 `confettiCannon` 初始化器，使用 `counter` 变量来触发动画。创建的彩带数量将是 100，`colors` 数组允许您添加您想要彩带具有的颜色。`rainHeight`
    将设置彩带上升的高度，而半径将设置彩带扩散的宽度。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'I filled out the variables for our example; however, you can play around with
    these values and configure them the way you like. There are many parameters that
    the creator, Simon Bachmann, has built into the `confettiCannon` initializer,
    so it’s very customizable. For a full list, follow this link: [https://github.com/simibac/ConfettiSwiftUI#parameters](https://github.com/simibac/ConfettiSwiftUI#parameters).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为我们的示例填写了变量；然而，您可以玩弄这些值并按您喜欢的配置它们。创建者 Simon Bachmann 在 `confettiCannon` 初始化器中构建了许多参数，因此它非常可定制。要获取完整列表，请点击此链接：[https://github.com/simibac/ConfettiSwiftUI#parameters](https://github.com/simibac/ConfettiSwiftUI#parameters)。
- en: 'Finally, we want to trigger the confetti in the `Button` body only when the
    user scores a perfect 100\. So, add the following code into the `Button` body,
    right after the `showAlert` variable is set to `true`, and then we can test out
    the animation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在用户得到满分 100 分时，只在 `Button` 主体中触发彩带。因此，在将 `showAlert` 变量设置为 `true` 后，将以下代码添加到
    `Button` 主体中，然后我们可以测试动画：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is just a simple `if` statement that checks whether the `calculateScore`
    function returns `100`. If so, we add `1` to the `counter` variable, which will
    trigger the animation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的 `if` 语句，用于检查 `calculateScore` 函数是否返回 `100`。如果是这样，我们将 `1` 添加到 `counter`
    变量中，这将触发动画。
- en: And if you’re wondering how adding a value of `1` triggers the confetti cannon,
    well, that’s how the Confetti package is configured –when a value of `1` is added
    to its `counter` variable, it triggers the confetti.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道如何通过添加 `1` 的值来触发彩带发射器，那么，这正是 Confetti 包的配置方式——当向其 `counter` 变量添加 `1` 的值时，它会触发彩带。
- en: 'Okay, now when the user gets a score of 100, the confetti cannon will shoot
    the confetti from the middle of the screen upward, and the confetti will slowly
    rain down the entire interface, all the way past the bottom of the screen:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在当用户得到 100 分时，彩带发射器将从屏幕中央向上发射彩带，彩带将慢慢在整个界面上空飘落，直到屏幕底部：
- en: '![Figure 14.13: Confetti animation ](img/B18674_14_13.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13：彩带动画](img/B18674_14_13.jpg)'
- en: 'Figure 14.13: Confetti animation'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：彩带动画
- en: And that’s the color-matching game finished.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，颜色匹配游戏就完成了。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this project, we learned about RGB colors, `switch` statements, implementing
    a `Picker` view, adding a `Slider` view, and creating a `reset` function, as well
    as using Swift packages to import pre-built code into our project.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们学习了关于 RGB 颜色、`switch` 语句、实现 `Picker` 视图、添加 `Slider` 视图、创建 `reset` 函数，以及使用
    Swift 包将预构建代码导入到我们的项目中。
- en: Play around with the code, and think of ways that you can take the game further.
    For example, maybe you want to play a sound effect when a perfect score is reached,
    such as a “pop” sound, or maybe you want to display the score on a label in the
    UI rather than having to click a button to check it. There are many different
    things that you can do to add more fun to the project.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄一下代码，想想您如何将游戏进一步发展。例如，也许您想在得到满分时播放声音效果，比如“砰”的一声，或者也许您想在 UI 中的标签上显示分数，而不是必须点击按钮来检查它。您可以为项目添加更多乐趣的许多不同的事情。
- en: The next chapter will look at some advanced animations we can create by integrating
    the SpriteKit framework into our SwiftUI projects. SpriteKit gives us a particle
    system that creates all kinds of very realistic effects and animations that you
    can use in your projects.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨一些通过将 SpriteKit 框架集成到我们的 SwiftUI 项目中可以创建的高级动画。SpriteKit 为我们提供了一个粒子系统，可以创建各种非常逼真的效果和动画，您可以在项目中使用。
