- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Color Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built a game where the user had to find words by using
    the letters of a larger word. In this project, we will continue the “finding”
    theme and build another game, where the user must find colors within a broader
    color.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this project will be to generate a random RGB color and then have
    the user manipulate separate sliders for each of the individual RGB values in
    order to completely match that random color. For example, there will be one slider
    for red, one slider for green, and one slider for blue, with each slider containing
    a range from 0 to 255 (the range of each RGB value). Then, the user will have
    to adjust those sliders to see whether they can find the exact RGB random color.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add three difficulty levels to the game, from easy to extreme.
    And if the user is skilled enough to work out the individual RGB values in the
    given color, we will display a shower of confetti over the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In building this game, you will learn about adding pre-built animations to a
    project using Swift packages, which includes the aforementioned confetti animation
    for when the user gets a high score. We will also add a spring animation to SwiftUI
    sliders and make them visible when needed, and invisible when not.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Title` View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the target and guess circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Picker` View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the target and guess rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the color sliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the user’s score with a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the user’s score in an `Alert` View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding confetti using Swift packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, you can find the code and download the completed project from the
    `Chapter 14` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, let’s just have a quick look at colors. There are two color
    models that you may be familiar with, primary colors and RGB colors.
  prefs: []
  type: TYPE_NORMAL
- en: Primary colors are the basic colors from which all other colors can be derived.
    In traditional color theory, the primary colors are red, blue, and yellow. Primary
    colors are used in many different fields, such as art, printing, and graphic design.
  prefs: []
  type: TYPE_NORMAL
- en: RGB (which is short for Red, Green, and Blue) colors make up a color model in
    which the colors are combined to create different intensities of red, green, and
    blue light that can be displayed on electronic displays and devices, such as computers,
    TVs, phones, and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: RGB colors are represented by their red, green, and blue components, each of
    which has a value between 0 and 255\. The value 0 represents the absence of that
    color, while 255 represents the maximum intensity of that color. By varying the
    values of the RGB components, a wide range of colors can be created. For example,
    (255, 0, 0) represents pure red, (0, 255, 0) represents pure green, and (0, 0,
    255) represents pure blue. Combinations of these colors can create many different
    colors and hues of colors.
  prefs: []
  type: TYPE_NORMAL
- en: We will be adding three sliders, which will represent each RGB color, and the
    user has to manipulate those sliders to find a target color by combining different
    amounts of those RGB colors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump right in and get this game off the ground. We’ll start by adding
    a title to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Title view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s get started by creating a new Xcode project – I’m calling it `VStack`
    to organize the views vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first objective here will be to give the UI a title; it’s not a lot of
    code, but we’ll still put it in its own file anyway. So, create a new SwiftUI
    View file, and call it `TitleView`, then add the following code to the `body`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `HStack`, there are three `Text` views, each with different colors
    – `"Find"` with the red color, `"The"` with green, and `"Color"` with blue – all
    colored using the `foregroundColor` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `HStack`, three additional modifiers are applied to the view. The
    first is `.foregroundColor(.blue)`, which sets the text color of all the `Text`
    views to blue. The next is `.fontWeight(.black)`, which sets the font weight of
    all the `Text` views to bold. And lastly, `.font(Font.system(size: 35, design:
    .serif))` sets the font and size of all the `Text` views to `35` points with a
    Serif design font.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll go back into `ContentView` and display the title by adding the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I also added some `padding` so the `Title` view won’t be too close to the notch
    at the top of the iPhone when we finish adding all the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we can see the colorful title that starts off the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: Game title ](img/B18674_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Game title'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can move on to the next part of the UI, the target and guess circles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the target and guess circles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next task is to create two colored circles:'
  prefs: []
  type: TYPE_NORMAL
- en: One circle will be the target circle, which will show a randomly generated color;
    because it is an RGB color, the user will need to combine three RGB values to
    find this target color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other circle will be their “guess” circle – kind of like a sketchpad, where
    the user can see their current progress as they manipulate the sliders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two circles will be created in their own SwiftUI file, so let’s make them
    now. Press *Command + N*, select `TargetAndGuessCircleView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use this file inside of `ContentView` – in order to do so, we will
    need some `Binding` variables inside the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are seven variables needed for this file – three variables for the target
    circle, three variables for the guess circle, and one integer (which we will use
    for a `Picker` view) will allow the user to select a difficulty level.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding those `Binding` properties, we notice we have an error in the
    `previews` struct. Remember that when we add these variables to a file, the `previews`
    struct always has to be updated with some dummy data in order for it to work again.
    So, modify the `previews` struct so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let’s go back into the `body` property. We want to add a `ZStack`
    so that we can overlay the target circle over the guess circle. We can create
    these two circles with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `ZStack`, we start off with the guess circle; this will be the bigger
    circle, with the `frame` height set to `200`. Here, we’re using an `if else` statement
    and checking the `selectedPickerIndex` variable to see what difficulty level the
    user has chosen. If they’ve chosen `0`; in that case, we will supply the green
    and blue RGB target colors to the user, so they only have to work out the red
    RGB target value. If they’ve selected `1`; in that case, we only supply the user
    with the blue RGB value, and they have to work out the red and green values themselves.
    Finally, if the user selected the `2`; in that case, we don’t supply the user
    with any RGB target values and they have to work out the individual target color
    value themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the target circle – this will be the randomly generated colored
    circle that the user has to try and match by manipulating the sliders. Notice
    that we’re creating this circle much smaller, only `80` points, and because we
    are in a `ZStack`, this circle will be on top of the guess circle. The reason
    for this overlaying of circles is that as the user is trying to work out the colors,
    their guess circle will change in color and they can better visualize how close
    they are to the target color.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, at the end of the `ZStack`, we’re using the `onAppear` modifier. This
    modifier will run an action every time the `ZStack` gets redrawn; if the `ZStack`
    gets redrawn, it means the user chose to play a new game (using a button that
    we will create later) and the sliders will go back to **0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That finishes up the `TargetAndGuessCircleView` file. Let’s go back into `ContentView`
    and add the `State` variables that we need in order to display `TargetAndGuessCircleView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are seven `State` properties, one for each of the `Binding` properties
    we made in the previous file. The variables are each set to a random double value
    between `0` and `1` using the `Double.random(in: 0..<1)` method. The function
    will generate a new random number every time it’s called, meaning that every time
    the user starts a new game, a new random value will be used to pick an RGB value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from here, we notice that there’s an error in the `Previews` struct
    of `ContentView`. This is a familiar error – it is Xcode telling us that we declared
    a property in the `ContentView` struct, yet we are not including it here in the
    `Previews` struct. Let’s fix that by inputting some data into the `Previews` struct,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That will fix the error in `ContentView`, but we also need to update the Swift
    file that contains the main startup code for the project. That file will be named
    the same as what you named your app – I named this project `Find the Color`, so
    in the Project Navigator to the left of Xcode, there will be a file with a Swift
    extension, called `Find_The_ColorApp.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on that Swift file, and update the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now go back into `ContentView`, call the `TargetAndGuessCircleView`
    file, and pass in the appropriate `State` variables. Add the following code directly
    underneath the title code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the UI should look now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: Target and guess circles ](img/B18674_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Target and guess circles'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by adding the `Picker` view to allow the user to select the difficulty
    for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Picker view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the `Picker` view, let’s make a new SwiftUI View file called `PickerView`
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this file, we need to add a `Binding` property so that we can use it
    inside `ContentView`, as well as add an array of titles for the picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code here has a `Binding` variable to hold the value of `selectedPickerIndex`;
    that way, we can keep track of which button on the picker the user has selected.
    Then, we have a `State` array of titles that we will use on the individual picker
    buttons, along with an appropriate emoji signifying the difficulty level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, as we’ve done before, update the `Previews` struct with some dummy data,
    to satisfy Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previews up and running, we can now create and style the `Picker`
    control. Move into the `body` property and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is what we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code adds a `Picker` component and a `Text` component. The `VStack` is
    used to arrange the `Picker` and `Text` components vertically. `Picker` is used
    to display a list of options, with the options being the elements in the `levels`
    array; it takes two arguments: `Numbers` and `selection: $selectedPickerIndex`,
    where `Numbers` is the label for the picker and `$selectedPickerIndex` is a state
    variable that keeps track of the currently selected option.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ForEach` loop is used to iterate through the `levels` array, creating a
    new `Text` component for each element in the array. Each `Text` component is configured
    to display the corresponding element from the `levels` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickerStyle` method is used to change the appearance of the picker to a
    segmented picker style. We have used the `background`, `cornerRadius`, `padding`,
    and `shadow` modifiers before, and these apply various visual styles to the picker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` component is used to display the difficulty level in the UI under
    the `Picker` component. It takes the `"Difficulty Level: " + "(levels[selectedPickerIndex])"`
    string and makes it bold, then applies some padding and animation to it. The animation
    is added so that instead of the difficulty level string appearing and disappearing
    instantly, it will ease in and out with a `0.2`-second duration, for a smoother
    transition in the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a `Picker` component that can be used to select the difficulty
    level of the game, and a `Text` string to display that level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: The segmented picker ](img/B18674_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The segmented picker'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Picker` control done, move back into `ContentView` and call `PickerView`directly
    under the target and guess circle code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That code will add the `PickerView` file into the UI under the target and guess
    circles. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: The picker in the UI ](img/B18674_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: The picker in the UI'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you click on the picker, you will see that the guess circle changes
    color; it won’t change to more than three shades of colors, as the picker displays
    a random color from each RGB value while the preview is running. If you stop the
    preview and restart it, another set of three random colors will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Shortly, we will implement sliders to change the guess circle colors, and change
    the target circle color when the user starts a new game. Before that, let’s continue
    with the next part of the UI, making target and guess rectangles. I’ll explain
    what they are for next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the target and guess rectangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have given the user a guess circle so they can see how close they
    are coming to the target color. Let’s do something similar to that and give them
    another visual cue – let’s create a guess rectangle and a target rectangle, and
    put them directly under the `Picker` control. We can also add an RGB value indicator,
    so they can see the actual values of each slider as they change, which can be
    helpful when they’re trying to figure out how much of the slider they need to
    move and in which direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file to make these rectangles, called `TargetAndGuessRectView`.
    This file will contain very similar code to the `TargetAndGuessCircleView` file,
    which means adding the needed `Binding` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with these `Binding` variables, as we’ve created them
    before in the `TargetAndGuessCircleView` file. Actually, you can refactor all
    the code and combine the two guess and target files into one file if you’d like,
    or create a data model and make the properties available to all the files... I’ll
    leave that as a challenge for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we need a combination of VStacks and HStacks to position the `Rectangle`
    and `Text` views. Add this code to the body of the file (I’ll explain it all next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a breakdown of what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: The first `VStack` contains a rectangle with the color determined by the values
    of `redTarget`, `greenTarget`, and `blueTarget`. It also has a corner radius of
    `5` and padding on the leading edge, with a height of `40`. Below the rectangle,
    there is a `Text` view displaying the `"Target Color to Match"` string in bold
    font.
  prefs: []
  type: TYPE_NORMAL
- en: The second `VStack` contains a rectangle with the color determined by the values
    of `redGuess`, `greenGuess`, and `blueGuess`, and is modified by the `rectModifier`
    struct (more on the `rectModifier` struct in a moment). The color of the rectangle
    is determined by `selectedPickerIndex`, which is an integer value. If `selectedPickerIndex`
    is `0`, the color is determined by `redGuess`, `greenTarget`, and `blueTarget`.
    If `selectedPickerIndex` is `1`, the color is determined by `redGuess`, `greenGuess`,
    and `blueTarget`. If `selectedPickerIndex` is `2`, the color is determined by
    `redGuess`, and `greenGuess`, `blueGuess`. Below the rectangle, there is an `HStack`
    containing an image and text displaying the values of `redGuess`, `greenGuess`,
    and `blueGuess`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now the target and guess rectangles are in place, as well as the three `Text`
    views that will display the RGB values as the user works the slider, let’s continue
    and look at that last bit of code, the `rectModifer` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rectModifier` struct is a `ViewModifier` that modifies the `Rectangle`
    view. It is a struct that conforms to the `ViewModifier` protocol and defines
    a single method, `body(content: Content) -> some View`, which takes a single argument
    content of the `Content` type and returns a modified version of that content wrapped
    in a `view`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this specific case, the struct is modifying the appearance of a `rectangle`
    view. The modifications are made by chaining together a series of view modifiers
    on the `content` parameter in the `body` method, such as setting the corner radius
    to `5`, adding `padding` to the trailing edge, and setting the height of the rectangle
    to `40`.
  prefs: []
  type: TYPE_NORMAL
- en: When `rectModifier()` is called, it is passed the `rectangle` view as the `content`
    parameter, and it applies the modifications defined in the struct to that `rectangle`
    view, returning the modified version of that view. In other words, `rectModifier()`
    is a simple way to package a set of modifiers that can be applied to any view,
    and it provides a way to reuse the same set of modifiers on multiple views, saving
    on coding time and readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of what we just coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: Target and guess rectangles ](img/B18674_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Target and guess rectangles'
  prefs: []
  type: TYPE_NORMAL
- en: The sliders will now display the RGB values for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to go back into the `ContentView` and make a call to this file
    directly underneath the `Picker` code so that we can display these two rectangles
    and text in the main UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is familiar code – we are simply calling `TargetAndGuessRectView`
    and passing in the appropriate `State` variables. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: Target and Guess Rectangles in the UI ](img/B18674_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Target and Guess Rectangles in the UI'
  prefs: []
  type: TYPE_NORMAL
- en: We just need the sliders, and a button to check the score, so let’s do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Making the color sliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start creating the sliders, make a new SwiftUI View file and call it `SliderView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the sliders are only used to manipulate the guess circle, we won’t need
    any `Target` variables in this file. Instead, we just need three `Guess` variables,
    as well as a variable to track the value of the picker control, which you can
    add like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we need to update the `Previews` struct, because it’s giving us this
    error: `Binding` variables in its `SliderView` struct initializer. Let’s give
    it what it wants, by updating `Previews` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previews operational again, let’s continue by making a separate struct
    for the creation of the slider itself. Add `CreateSlider` outside and underneath
    the `SliderView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines a new SwiftUI struct called `CreateSlider` that takes in
    two parameters: a `Binding` variable called `value` of the `Double` type, and
    a variable called `color` of the `Color` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is what each line of code does.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen before, `@Binding var value: Double` is a property wrapper that
    creates a two-way binding between the struct’s `value` variable and another variable.
    This allows the struct to read and write the value of the variable that it is
    bound to.'
  prefs: []
  type: TYPE_NORMAL
- en: '`var color: Color` creates a variable called `color` that is of the `Color`
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text("0")` creates a `Text` view with a value of `0`, and gets the following
    modifiers placed on it: `.bold()` makes the text bold, and `foregroundColor(color)`
    sets the color of the text to the `color` variable passed to the struct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add the slider, `Slider(value: $value, in: 0.0...1.0)`. This creates
    a `Slider` view that reads and writes its value to the `value` property. The `in`
    parameter sets the range of the slider to go from `0.0` to `1.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add another `Text` view, add the text `255`, and put some padding
    on it using `.padding(.init(top: 10, leading: 10, bottom: 10, trailing: 10))`.
    This is a `View` modifier that adds a padding of `10` points to the top, leading,
    bottom, and trailing edge of the view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the slider created, we will need to call this `CreateSlider` struct several
    times inside the `SliderView` struct and add some styling to it as well. So, back
    up into the `SliderView` struct, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this code down. It starts off by defining a SwiftUI view called
    `SliderView` that uses a `VStack` to lay out three sliders for adjusting the values
    of the `redGuess`, `greenGuess`, and `blueGuess` properties. The struct has a
    `VStack` used to organize three sliders vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Those three sliders are added by calls to the `CreateSlider` view. The `CreateSlider`
    view uses the `background` modifier and a capsule shape in order to outline the
    slider with a red color.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is a `switch` statement – since we are using one for the first time,
    let me explain what it is and the difference between using a `switch` statement
    and an `if` `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: So, an `if else` statement is used to evaluate a Boolean expression and execute
    a block of code if the expression is `true`, and another block of code if the
    expression is `false`. It can be used for any type of condition or comparison.
    A `switch` statement, on the other hand, is used to match a value or expression
    against multiple possible cases and execute a block of code for the matching case.
  prefs: []
  type: TYPE_NORMAL
- en: A `switch` statement is typically used for matching against multiple possible
    values for a single variable or expression and is often used for situations where
    multiple conditions need to be checked in a more concise and readable way. For
    example, when you have multiple conditions with multiple `if else` statements,
    you can use a `switch` statement over `if else`. It makes the code more readable
    and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, `if else` statements are good for complex conditions, while `switch`
    statements are good for simple conditions. In Swift, you can use either, depending
    on what you are trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: So, going back to our code, the `switch` statement checks the `selectedPickerIndex`
    value to see whether it is equal to `1`; if so, it means the user selected the
    `selectedPickerIndex` value is equal to `2`, it will create both the green and
    blue sliders, because the user has selected the `selectedPickerIndex` is not `1`
    or `2`, it will return an empty view.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `CreateSlider` struct is used to create the sliders, and it takes
    two arguments, `value` and `color`. It displays the minimum and maximum values
    of the slider and it uses the `color` argument to change the color of the `"0"`
    text view and the `"255"` text view.
  prefs: []
  type: TYPE_NORMAL
- en: '`SliderView` uses the `CreateSlider` struct to create the sliders for RGB colors.
    The `selectedPickerIndex` binding is used to decide which sliders to show, based
    on the user’s selection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SliderView` is now complete, so let’s use it inside `ContentView`. Add the
    following code just after the `Picker` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code calls the `SliderView` struct and fills in the `Binding` variables,
    then adds a spring animation to the sliders as they appear and disappear in the
    UI. The `interactiveSpring` animation is a type of animation that simulates the
    behavior of a spring, and takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`response`: This value controls the stiffness of the spring. A lower value
    will result in a softer spring, and a higher value will result in a stiffer spring.
    A value of `0.4` will provide a moderate stiffness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dampingFraction`: This value controls the damping of the spring, which is
    a measure of how quickly the spring’s oscillations will die out. A lower value
    will result in a spring with less damping, and a higher value will result in a
    spring with more damping. A value of `0.5` means that the spring’s oscillations
    will die out relatively quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blendDuration`: This value controls the duration of the animation’s blending.
    A lower value will result in a shorter blend duration, and a higher value will
    result in a longer blend duration. A value of `0.5` seconds is a moderate blend
    duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as the `interactiveSpring` animation, we’re using the `scaleEffect`
    modifier and passing in a value of `1`. What this does is help smooth out the
    animation as each slider appears and disappears. Go ahead and try it out. If you
    click on the picker control to choose a difficulty level, each slider will appear
    and disappear on the screen with a springy animation to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: The sliders ](img/B18674_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: The sliders'
  prefs: []
  type: TYPE_NORMAL
- en: As you move the sliders, the guess circle color will update smoothly, and the
    RGB values will change in the RGB text string.
  prefs: []
  type: TYPE_NORMAL
- en: The last UI component to add is a button that will let the user check their
    score as they play.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the user’s score with a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make this a game, the user needs a way to check their progress and see a
    number that reflects how close they are to a perfect score/color match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a button right after the `SliderView` struct’s `Spacer()` in `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a `Button` view, which we have named `Check Score`. The button
    gets styled with a black foreground, yellow background, padding, a corner radius,
    and finally, a black shadow to make the button stand out a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the button is currently empty right now, but what we want to do
    is to put some code in there that will trigger an alert and show the user their
    current score, so that they know how close they are to the target value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to create a function that calculates a score. So, at the
    bottom of the `ContentView` struct, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a function named `calculateScore` that returns an `Int` value.
    This function is used to calculate a score based on the difference between the
    `guess` values of `red`, `green`, and `blue`, and the `target` values of `red`,
    `green`, and `blue`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how it works. The function first calculates the difference between the
    `guess` values and the `target` values for `red`, `green`, and `blue`. Next, it
    calculates `easyDifference` by getting the square root of the `redDiff` variable.
    Next, it calculates `hardDifference` by adding the square of the `greenDiff` variable
    to `easyDifference`. Then, it calculates `extremeDifference` by adding the square
    root of `blueDiff` to `hardDifference`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, it uses a `switch` statement to determine which level of difficulty
    is currently selected, and assigns the `calculatedDifference` variable a value
    based on that:'
  prefs: []
  type: TYPE_NORMAL
- en: If `selectedPickerIndex` is `0`, then `calculatedDifference` is the square root
    of `easyDifference`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `selectedPickerIndex` is `1`, then `calculatedDifference` is the square root
    of `hardDifference`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `selectedPickerIndex` is `2`, then `calculatedDifference` is the square root
    of `extremeDifference`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `selectedPickerIndex` is any other value, then `calculatedDifference` is
    set to `0.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it returns an `integer` value that is calculated by taking `(1.0 -
    calculatedDifference) * 100 + 0.5`, which is the final score.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used to calculate a score based on how close the `guess` values
    are to the `target` values. The smaller the difference between the values, the
    higher the score will be. If the `guess` value is equal to the `target` value,
    the user gets a perfect score of 100.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `calculateScore` function is complete; let’s use it to show the user
    their score in an `Alert` view.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the user’s score in an Alert view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an `Alert` view, we first need a state variable to keep track of
    the alert and trigger it when the `state` value changes. At the top of the file,
    underneath the other variables we created, add the following `State` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the `Alert` modifier after the `Button` code’s closing
    brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a title, a message, and two buttons – a primary button and
    a secondary button.
  prefs: []
  type: TYPE_NORMAL
- en: The title will be the message to the user, and the message will be the user’s
    score. We’re doing that by calling the `calculatedScore` function inside a `Text`
    view using string interpolation; remember, the `calculateScore` function returns
    an integer, and that value will be shown to the user as their current score.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the primary button will prompt the user to start a new game, while the
    secondary button will prompt the user to continue playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger the alert, we need to toggle the `showAlert` variable to `true`
    inside the `Button` body, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try the game out. Slide the sliders and try to get as close to
    the target circle color as you can, then press the **Check Score** button to see
    your score:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 14.8: Alert view showing the user’s score ](img/B18674_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Alert view showing the user’s score'
  prefs: []
  type: TYPE_NORMAL
- en: From this screen, if the user presses **Continue Playing?**, the game will continue
    from where it left off. However, if they press **New Game?**, nothing will happen
    – that’s because we haven’t added any logic to start a new game yet. Let’s do
    that next.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to give the user the opportunity to start a new game, and we can do
    that by adding a `reset` function to the file. This function will reset the sliders
    to **0** and generate another random target color for the middle target circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function underneath the `calculateScore` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function creates new random colors and stores them in the `Target` variables.
    It also resets the `Guess` variables back to `0`, which will move all the sliders
    back to their starting points on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call the `reset` function inside the `Alert` modifier’s secondary button,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we press the secondary button, **New Game?**, a new game starts with
    a new target color, and the sliders are set back to their starting position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: Starting a new game ](img/B18674_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Starting a new game'
  prefs: []
  type: TYPE_NORMAL
- en: The sliders are set back to zero, and a new random target color is generated
    and shown.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this project by adding two more things – a background, and a confetti
    animation that will appear when the user gets a perfect score of 100.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, the background. You can find the resource for this project in the `Chapter
    14` folder on GitHub (it’s the only asset in the folder); just drag and drop the
    `background` image file into the Asset Catalog. After you’ve done that, add the
    following code in `ContentView`, after the closing brace of the main `VStack`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `background` modifier, passing the name of the image,
    resizing it, and setting `edgesIgnoringSafeArea` to stretch it out throughout
    the whole screen. It’s a subtle background, but it has a nice pattern to it that
    I think works as a backdrop for the colorful UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: Background added ](img/B18674_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Background added'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at Swift packages, and how to make some confetti.
  prefs: []
  type: TYPE_NORMAL
- en: Adding confetti using Swift packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Swift package is pre-built software that we can use in any of our projects,
    in which all the coding work has been done for us; all we have to do is configure
    it in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Swift package, in Xcode, go to the **File** menu and select **Add
    Packages…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: Add Packages… ](img/B18674_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Add Packages…'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **All Sources** window, enter [https://github.com/simibac/ConfettiSwiftUI.git](https://github.com/simibac/ConfettiSwiftUI.git)
    in the search box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: Adding the URL ](img/B18674_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: Adding the URL'
  prefs: []
  type: TYPE_NORMAL
- en: When the **Add Package** button is clicked, Xcode will add the Confetti package
    to the project. The Confetti package contains all the code needed to create all
    kinds of confetti, dispersed in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import the Confetti framework into the `ContentView` file at
    the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a variable that can trigger the confetti (placed after the other
    project variables):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the `confettiCannon` initializer in `ContentView` just after
    the target and guess rectangle code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code calls the `confettiCannon` initializer, using the `counter` variable
    to trigger the animation. The number of pieces of confetti being created will
    be 100, and the `colors` array lets you add the colors that you want the confetti
    to be. `rainHeight` will set how high the confetti goes upward, and the radius
    will set how wide the confetti spreads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'I filled out the variables for our example; however, you can play around with
    these values and configure them the way you like. There are many parameters that
    the creator, Simon Bachmann, has built into the `confettiCannon` initializer,
    so it’s very customizable. For a full list, follow this link: [https://github.com/simibac/ConfettiSwiftUI#parameters](https://github.com/simibac/ConfettiSwiftUI#parameters).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to trigger the confetti in the `Button` body only when the
    user scores a perfect 100\. So, add the following code into the `Button` body,
    right after the `showAlert` variable is set to `true`, and then we can test out
    the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple `if` statement that checks whether the `calculateScore`
    function returns `100`. If so, we add `1` to the `counter` variable, which will
    trigger the animation.
  prefs: []
  type: TYPE_NORMAL
- en: And if you’re wondering how adding a value of `1` triggers the confetti cannon,
    well, that’s how the Confetti package is configured –when a value of `1` is added
    to its `counter` variable, it triggers the confetti.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now when the user gets a score of 100, the confetti cannon will shoot
    the confetti from the middle of the screen upward, and the confetti will slowly
    rain down the entire interface, all the way past the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: Confetti animation ](img/B18674_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Confetti animation'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s the color-matching game finished.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we learned about RGB colors, `switch` statements, implementing
    a `Picker` view, adding a `Slider` view, and creating a `reset` function, as well
    as using Swift packages to import pre-built code into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Play around with the code, and think of ways that you can take the game further.
    For example, maybe you want to play a sound effect when a perfect score is reached,
    such as a “pop” sound, or maybe you want to display the score on a label in the
    UI rather than having to click a button to check it. There are many different
    things that you can do to add more fun to the project.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at some advanced animations we can create by integrating
    the SpriteKit framework into our SwiftUI projects. SpriteKit gives us a particle
    system that creates all kinds of very realistic effects and animations that you
    can use in your projects.
  prefs: []
  type: TYPE_NORMAL
