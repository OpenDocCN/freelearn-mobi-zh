<html><head></head><body>
		<div id="_idContainer086">
			<h1 id="_idParaDest-143"><em class="italic"><a id="_idTextAnchor193"/>Chapter 8</em>: Adding Core Data to Your App</h1>
			<p><strong class="bold">Core Data</strong> is Apple's data <a id="_idIndexMarker342"/>persistence framework. You can use this framework whenever your application needs to store data. Simple data can often be stored in <strong class="source-inline">UserDefaults</strong>, but when you're handling data that is more complex, has relationships, or needs some form of efficient searching, Core Data is much better suited to your needs.</p>
			<p>You don't need to build a very complex app or have vast amounts of data to make Core Data worth your while. Regardless of your app's size, even if it's tiny with only a couple of records, or if you're holding onto thousands of records, Core Data has your back.</p>
			<p>In this chapter, you'll learn how to add Core Data to an existing app. The app you will build keeps track of a list of favorite movies for all members of a family. The main interface is a table view that shows a list of family members. If you tap on a family member's name, you'll see their favorite movies. Adding family members can be done through the overview screen and adding movies can be done through the detail screen.<a id="_idTextAnchor194"/><a id="_idTextAnchor195"/></p>
			<p>In<a id="_idTextAnchor196"/><a id="_idTextAnchor197"/> this chapter,<a id="_idTextAnchor198"/><a id="_idTextAnchor199"/> the following topics are covered:</p>
			<ul>
				<li>Understanding the Core Data stack </li>
				<li>Adding Core Data to an existing application </li>
				<li>Creating a Core Data model</li>
				<li>Persisting data and reacting to data changes</li>
				<li>Understanding the use of multiple instances of <strong class="source-inline">NSManagedObjectContext</strong></li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor200"/>Technical requirements</h1>
			<p>You won't build the screens in this app from scratch. The code bundle for this chapter includes a starter project called <strong class="source-inline">MustC</strong>. The starter project contains all of the screens, so you don't have to set up the user interface before you get around to implementing Core Data.</p>
			<p>Download the sample code from the following GitHub link:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor201"/>Understanding the Core Data stack</h1>
			<p>Before you dive right into <a id="_idIndexMarker343"/>the project and add Core Data to it, let's take a look at how Core Data works, what it is, and what it isn't. In order to make efficient use of Core Data, you must know what you're working with.</p>
			<p>When you work with Core Data, you're utilizing a stack of layers that starts with managed objects and ends with a data store. This data store is often a SQLite database, but there are different storage options you can use with Core Data, depending on your application's needs. Let's take a quick look at the layers involved with Core Data and discuss their roles in an application briefly:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_8.01_B14717.jpg" alt="Figure 8.1 – A Core Data stack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A Core Data stack</p>
			<p>At the top right of this diagram is the <strong class="source-inline">NSManagedObject</strong> class. When you use Core Data, this is the class you'll interact with most often since it's the base class for all the Core Data models that your app contains. For instance, in the app that you will build in this chapter, the family member and movie models are subclasses of <strong class="source-inline">NSManagedObject</strong>.</p>
			<p>Each managed object belongs to an instance of <strong class="source-inline">NSManagedObjectContext</strong>. The managed object context is responsible for communicating with the <strong class="bold">persistent store coordinator</strong>. Often, you'll only need a single managed object context and a single persistent store coordinator. However, it is possible to use multiple persistent store coordinators and multiple managed object contexts. It's even possible to have multiple managed object contexts for the same persistent store coordinator.<a id="_idTextAnchor202"/></p>
			<p>A setup with multiple managed object contexts can be particularly useful if you're performing costly operations on your managed objects; for example, if you're importing or synchronizing large amounts of data. Usually, you will stick to using a single managed object context and a single persistent store coordinator because most apps don't need more than one.</p>
			<p>The persistent store coordinator is responsible for communicating with the <strong class="bold">persistent store</strong>. In most scenarios, the persistent store uses SQLite as its underlying storage database. However, you<a id="_idIndexMarker344"/> can also use other types of storage, such as an in-memory database. An in-memory database is especially useful if you're writing unit tests or if your app does not need long-term storage. </p>
			<p>If you've worked with MySQL, SQLite, or any other relational database, it is tempting to think of Core Data as a layer on top of a relational database. Although this isn't entirely false since Core Data can use SQLite as its underlying storage, Core Data does not work the same as using SQLite directly; it's an abstraction on top of it.</p>
			<p>One example of a difference between SQLite and Core Data is the concept of primary keys. Core Data doesn't allow you to specify your own primary keys. Also, when you define relationships, you don't use foreign keys. Instead, you simply define the relationship and Core Data will figure out how to store this relationship in the underlying database. You will learn more about this later. It's important to know that you should not directly translate your SQL experiences to Core Data. If you do, you will run into issues, simply because Core Data is not SQL. It just so happens that SQLite is one of the ways that data can be stored, but the similarities end right there.</p>
			<p>To recap, all Core Data apps have a <strong class="bold">persistent store</strong>. This store is backed by an in-memory database or a<a id="_idIndexMarker345"/> SQLite database. A <strong class="bold">persistent store coordinator</strong> is responsible for communicating with the <strong class="bold">persistent store</strong>. The object communicating with the <strong class="bold">persistent store coordinator</strong> is the <strong class="bold">managed object context</strong>. An application can have multiple <strong class="bold">managed object context</strong> instances talking to the same <strong class="bold">persistent store coordinator</strong>. The objects that a <strong class="bold">managed object context</strong> retrieves from the <strong class="bold">persistent store coordinator</strong> are <strong class="bold">managed objects</strong>.</p>
			<p>Now that you have an overview of the Core Data stack and where all the parts involved with its usage belong, let's <a id="_idIndexMarker346"/>add the Core Data stack to the <strong class="bold">MustC</strong> applicati<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/><a id="_idTextAnchor205"/>on.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor206"/>Adding Core Data to an existing application</h1>
			<p>When you create a new<a id="_idIndexMarker347"/> project in Xcode, Xcode asks whether you want to add Core Data to your application. If you check this checkbox, Xcode will automatically generate some boilerplate code that sets up the Core Data stack. For practicing purposes, <strong class="source-inline">MustC</strong> was set up without Core Data, so you'll have to add this to the project yourself.</p>
			<p>Start by opening <strong class="source-inline">AppDelegate.swift</strong> and add the following <strong class="source-inline">import</strong> statement:</p>
			<p class="source-code">import CoreData</p>
			<p>Next, add the following <strong class="source-inline">lazy</strong> variable to the implementation of <strong class="source-inline">AppDelegate</strong>:</p>
			<p class="source-code">private lazy var persistentContainer: NSPersistentContainer = {</p>
			<p class="source-code">  let container = NSPersistentContainer(name: "MustC")</p>
			<p class="source-code">  container.loadPersistentStores(completionHandler: { (storeDescription, error) in</p>
			<p class="source-code">    if let error = error {</p>
			<p class="source-code">      fatalError("Unresolved error (error), (error.userInfo)")</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  return container</p>
			<p class="source-code">}()</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you declare a variable as lazy, it won't be initialized until it is accessed. This is particularly useful for variables that are expensive to initialize, rely on other objects, or are not always accessed. The fact that the variable is initialized just in time comes with a performance penalty since the variable needs to be set up the first time you access it. In some instances, this is fine, but in other cases, it might negatively impact the user experience. When used correctly, lazy variables can offer significant benefits.</p>
			<p>The preceding code snippet creates an instance of <strong class="source-inline">NSPersistentContainer</strong>. The persistent container is a container for the persistent store coordinator, persistent store, and managed object context. This single object manages different parts of the Core Data stack, and it ensures that everything is set up and managed correct<a id="_idTextAnchor207"/>ly. </p>
			<p>If you let Xcode generate the Core Data code for your app, it adds a similar property to create <strong class="source-inline">NSPersistentContainer</strong>. Xcode also adds a method called <strong class="source-inline">saveContext()</strong> to <strong class="source-inline">AppDelegate</strong>. This method is used in <strong class="source-inline">applicationWillTerminate(_:)</strong> to perform a last-minute save of any changes and updates when the application is about to terminate. Since you're setting up Core Data manually, this behavior<a id="_idIndexMarker348"/> isn't added by Xcode, so it must be added by you manually.</p>
			<p>Instead of placing the <strong class="source-inline">saveContext()</strong> method in <strong class="source-inline">AppDelegate</strong>, you will add this method as an extension to <strong class="source-inline">NSPersistentContainer</strong>. This makes it easier for other parts of your code to use this method, without having to rely on <strong class="source-inline">AppDelegate</strong>.</p>
			<p>Next, create a new folder in the Project Navigator and name it <strong class="source-inline">Extensions</strong>. Also, create a new Swift file and name it <strong class="source-inline">NSPersistentContainer.swift</strong>. Add the following implementation to this file:</p>
			<p class="source-code">import CoreData</p>
			<p class="source-code">extension NSPersistentContainer {</p>
			<p class="source-code">  func saveContextIfNeeded() {</p>
			<p class="source-code">    if viewContext.hasChanges {</p>
			<p class="source-code">      do {</p>
			<p class="source-code">        try viewContext.save()</p>
			<p class="source-code">      } catch {</p>
			<p class="source-code">        let nserror = error as NSError</p>
			<p class="source-code">        fatalError("Unresolved error \(nserror), \(nserror.userInfo)")</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This code adds a new method to <strong class="source-inline">NSPersistentContainer</strong> instances by extending it. This is convenient because it decouples the save method from <strong class="source-inline">AppDelegate</strong> entirely. This is much nicer<a id="_idIndexMarker349"/> than the default save mechanism provided for Core Data apps by Xcode. </p>
			<p>Add the following implementation of <strong class="source-inline">applicationWillTerminate(_:)</strong> to <strong class="source-inline">AppDelegate</strong> to save the context right before the app terminates:</p>
			<p class="source-code">func applicationWillTerminate(_ application: UIApplication) {</p>
			<p class="source-code">    persistentContainer.saveContextIfNeed<a id="_idTextAnchor208"/>ed()</p>
			<p class="source-code">}</p>
			<p>Now, whenever the application terminates, the persistent store will check whether there are any changes to the managed object context that the <strong class="source-inline">viewContext</strong> property points to. If there are any changes, an attempt to save them is made. If this attempt fails, the app will crash with <strong class="source-inline">fatalError</strong>. When creating your own app, you might want to handle this scenario a bit more gracefully. It could very well be that failing to save data before the app terminates might not be a reason that crashes your app. You can modify the error-handling implementation of <strong class="source-inline">saveContextIfNeeded()</strong> if you think a different behavior is more appropriate for your app. You can, for example, upload the error to your analytics or reporting tool to analyze it later, or avoid <strong class="source-inline">fatalError</strong> and just log the error without crashing the app.</p>
			<p>Now that you have the Core Data stack set up, you need a way to provide this stack to the view controllers in the app. A common technique to achieve this is called <strong class="bold">dependency injection</strong>. In this <a id="_idIndexMarker350"/>case, dependency injection means that <strong class="source-inline">AppDelegate</strong> will pass the persistent container to <strong class="source-inline">FamilyMemberViewController</strong>, which is the first view controller in the app. It then becomes the job of <strong class="source-inline">FamilyMemberViewController</strong> to pass the persistent container to the next view controller that depends on it, and so forth.</p>
			<p>In order to inject the persistent container, you need to add a property to <strong class="source-inline">FamilyMembersViewController</strong> that holds the persistent container. Don't forget to add <strong class="source-inline">import CoreData</strong> at the top of the file and add the following code:</p>
			<p class="source-code">var persistentContainer: NSPersistentContainer!</p>
			<p>Now, in <strong class="source-inline">AppDelegate</strong>, modify <a id="_idIndexMarker351"/>the <strong class="source-inline">application(_:didFinishLaunchingWith Options:)</strong> method, as follows:</p>
			<p class="source-code">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {</p>
			<p class="source-code">  <strong class="bold">if let navVC = window?.rootViewController as? UINavigationController,</strong></p>
			<p class="source-code"><strong class="bold">     let initialVC = navVC.viewControllers[0] as? FamilyMembersViewController {</strong></p>
			<p class="source-code"><strong class="bold">      initialVC.persistentContainer = persistentContainer</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code">  retur<a id="_idTextAnchor209"/>n true</p>
			<p class="source-code">}</p>
			<p>This code is using dependency injection to inject <strong class="source-inline">persistentContainer</strong> into <strong class="source-inline">FamilyMemberViewController</strong>. But you can still make one major improvement: you know that there might be more view controllers that depend on a persistent container, so you will need a <strong class="source-inline">persistentContainer</strong> property in each of them. This will cause a lot of repeated code. We can improve our code if we define a protocol that we can reuse in order to reduce the duplicated code in each <strong class="source-inline">UIViewController</strong> instance that needs <strong class="source-inline">persistentContainer</strong>. As an exercise, attempt to improve the code by adding a protocol called <strong class="source-inline">PersistentContainerRequiring</strong>. This protocol should add a requirement for an implicitly unwrapped <strong class="source-inline">persistentContainer</strong> property. Make sure that <strong class="source-inline">FamilyMembersViewController</strong> conforms to this protocol, and fix the implementation of <strong class="source-inline">application(_:didFinishLaunchingWithOptions:)</strong> as well so that it uses your new protocol.</p>
			<p>You have just put down the foundation that is required to use Core Data in your app. Before you can use Core<a id="_idIndexMarker352"/> Data and store data in it, you must define wha<a id="_idTextAnchor210"/>t data you would like to save by creating your data model. Let's go over how to do t<a id="_idTextAnchor211"/>his next.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor212"/>Creating a Core Data model</h1>
			<p>So far, you have<a id="_idIndexMarker353"/> worked on the persistence layer of your app. The next step is to create your models so that you can actually store and retrieve data from your Core Data database. All models in an application that uses Core Data are represented by <strong class="source-inline">NSManagedObject</strong> subclasses. When you retrieve data from your database, <strong class="source-inline">NSManagedObjectContext</strong> is responsible for creating instances of your managed objects and populating them with the relevant fetched data.</p>
			<p>The <strong class="bold">MustC</strong> application<a id="_idIndexMarker354"/> requires two models: a family-member model and a movie model. When you define models, you can also define relationships. For the models in <strong class="bold">MustC</strong>, you should define a relationship that links multiple movies to a single fam<a id="_idTextAnchor213"/><a id="_idTextAnchor214"/><a id="_idTextAnchor215"/>ily member.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor216"/>Creating the models</h2>
			<p>In order for Core Data to<a id="_idIndexMarker355"/> understand which models your application uses, you must define them in Xcode's model editor. Let's create a new model file so that you can add your own models to the <strong class="bold">MustC</strong> application. Create a new file, and from the file template selection screen, pick <strong class="bold">Data Model</strong>. First, you will set up the basic models, and then see how you can define a relationship between family members and their favorite movies:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_8.02_B14717.jpg" alt="Figure 8.2 – Creating a new Core Data model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Creating a new Core Data model</p>
			<p>Name your model file <strong class="source-inline">MustC</strong>. Your project now<a id="_idIndexMarker356"/> contains a file called <strong class="source-inline">MustC.xcdatamodeld</strong>. Open this file to go to the model editor. In the bottom-left corner of the editor, you'll find a button labeled <strong class="bold">Add Entity</strong>. Click this button to add a new entity, and name it <strong class="source-inline">FamilyMember</strong>.</p>
			<p>When you select an entity by clicking it, you can see all of its attributes, relationships, and fetched properties. Let's add a <strong class="source-inline">name</strong> property to the family member. Click on the plus (<strong class="bold">+</strong>) icon at the bottom of the empty attributes list and add a new attribute called <strong class="source-inline">name</strong>. Make sure that you select <strong class="bold">String</strong> as the type for this attribute:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_8.03_B14717.jpg" alt="Figure 8.3 – Adding an attribute to a Core Data entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Adding an attribute to a Core <a id="_idTextAnchor217"/>Data entity</p>
			<p>Click on this new property to select it. In the sidebar on the right, select the fourth tab to open the Data Model inspector. This is where you can see more detailed information on this attribute. For instance, you can configure a property to be indexed for faster lookups. You can also choose whether you want the attribute to be optional. For now, you shouldn't care too much about indexing since you're not performing lookups by family members' names, and, even if you were, a family doesn't tend to have hundreds or thousands of members. By default, the <strong class="bold">Optional</strong> checkbox is checked. Make sure that you uncheck this box because you don't want to store family members without a name.</p>
			<p>Some other options you have for attributes are adding validation, adding a default value, and enabling indexing in Spotlight. For now, leave all those options at their default <a id="_idIndexMarker357"/>settings:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_8.04_B14717.jpg" alt="Figure 8.4 – Attribute properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Attribute properties</p>
			<p>In addition to a <strong class="source-inline">FamilyMember</strong> entity, <strong class="bold">MustC</strong> also needs a <strong class="source-inline">Movie</strong> entity. Create this entity using the same steps as before and give it a single property: <strong class="source-inline">title</strong>. This property should be a string and it shouldn't be optional. Once you've added this property, you can set up a relationship between family members and their favor<a id="_idTextAnchor218"/><a id="_idTextAnchor219"/><a id="_idTextAnchor220"/>ite movies.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor221"/>Defining relationships</h2>
			<p>A relationship in Core <a id="_idIndexMarker358"/>Data adds a reference as a property onto an entity. In this case, you want to define a relationship between <strong class="source-inline">FamilyMember</strong> and <strong class="source-inline">Movie</strong>. The best way to describe this relationship is a one-to-many relationship. This means that every movie will have only one family member associated with it and every family member can have multiple favorite movies.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Configuring your data model with a one-to-many relationship from <strong class="source-inline">Movie</strong> to <strong class="source-inline">FamilyMember</strong> is not the most efficient way to define this relationship. A many-to-many relationship is likely a better fit because that would allow multiple family members to add the same movie instance as their favorite. A one-to-many relationship is used in this example to keep the setup simple and make it easy to follow along with the example.</p>
			<p>Select the <strong class="bold">FamilyMember</strong> entity and click on the plus icon at the bottom of the <strong class="bold">Relationships</strong> list. Name the relationship <strong class="bold">movies</strong> and select <strong class="source-inline">Movie</strong> as the destination. Don't select an <strong class="bold">Inverse</strong> relationship yet because the other end of this relationship is not defined yet. The <strong class="bold">Inverse</strong> relationship will tell the model that <strong class="source-inline">Movie</strong> has a property that points back to <strong class="source-inline">FamilyMember</strong>. Make sure that you select <strong class="bold">To Many</strong> as the relationship type in the Data Model inspector panel for the <strong class="source-inline">movies</strong> property. </p>
			<p>Also, select <strong class="bold">Cascade</strong> as the value for <strong class="bold">Delete Rule</strong>:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_8.05_B14717.jpg" alt="Figure 8.5 – Relationship properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Relationship properties</p>
			<p><strong class="bold">Delete Rule</strong> is a very important property to be set correctly. Not paying attention to this property could result in a lot of orphaned, and even corrupted, data in your database. For instance, setting this property to <strong class="bold">nullify</strong> simply sets the inverse of the relationship to <strong class="source-inline">nil</strong>. This is the correct behavior when deleting a movie because deleting a movie shouldn't delete the entire family member who added this movie as their favorite. It should simply be removed from the list of<a id="_idTextAnchor222"/> favorites.</p>
			<p>However, if a family member is deleted and the relationship is <strong class="source-inline">nullified</strong>, you would end up with a bunch of movies that don't have a family member associated with them. In this application, these movies are worthless; they won't be used anymore because every movie only belongs to a single family member. For this app, it's desirable that when a family member gets deleted, Core Data also deletes their favorite movies. This is precisely what the <strong class="bold">Cascade</strong> option does; it cascades the deletion over to the relationship's <a id="_idIndexMarker359"/>inverse.</p>
			<p>After setting <strong class="bold">Delete Rule</strong> to <strong class="bold">Cascade</strong>, select the <strong class="bold">Movie</strong> entity and define a relationship called <strong class="source-inline">familyMember</strong>. The destination should be <strong class="source-inline">FamilyMember</strong> and the inverse for this relationship is <strong class="source-inline">favoriteMovies</strong>. After adding this relationship, the inverse will be automatically set on the <strong class="source-inline">FamilyMember</strong> entity:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_8.06_B14717.jpg" alt="Figure 8.6 – Movie relationship with FamilyMember&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Movie relationship with FamilyMember</p>
			<p>Now that we have learned how to create and establish relationships between entities in our model, let's start using the entities to store data <a id="_idTextAnchor223"/><a id="_idTextAnchor224"/>in our app.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor225"/>Using your entities</h2>
			<p>As mentioned before, every <a id="_idIndexMarker360"/>model or entity in your Core Data database is represented by <strong class="source-inline">NSManagedObject</strong>. There are a couple of ways to create or generate <strong class="source-inline">NSManagedObject</strong> subclasses. In the simplest of setups, an <strong class="source-inline">NSManagedObject</strong> subclass contains just the properties for a certain managed object and nothing else. If this is the case, you can let Xcode generate your model classes for you.</p>
			<p>This is actually what Xcode does by default. If you build your project now and add the following code to <strong class="source-inline">viewDidLoad()</strong> in <strong class="source-inline">FamilyMembersViewController</strong>, your project should compi<a id="_idTextAnchor226"/>le just fine:</p>
			<p class="source-code">let fam = FamilyMember(entity: FamilyMember.entity(), insertInto: persistentContainer.viewContext)</p>
			<p>This works automatically; you don't have to write any code for your models yourself. Don't worry about what the preceding code does just yet; we'll get into that very soon. The point is that you see that a <strong class="source-inline">FamilyMember</strong> class exists in your project even though you didn't have to create one yourself.</p>
			<p>If the default behavior doesn't suit the approach you want in your app – for instance, if you want to prevent your code from modifying your models by defining your variables as <strong class="source-inline">private(set)</strong> – you may want to create a custom subclass instead of making Xcode generate the classes <a id="_idIndexMarker361"/>for you. A custom <strong class="source-inline">NSManagedObject</strong> subclass for <strong class="source-inline">FamilyMember</strong> could look like this:</p>
			<p class="source-code">class FamilyMember: NSManagedObject {</p>
			<p class="source-code">  @NSManaged private(set) var name: String</p>
			<p class="source-code">  @NSManaged private(set) var favoriteMovies: [Movie]?</p>
			<p class="source-code">}</p>
			<p>This custom <strong class="source-inline">FamilyMember</strong> subclass makes sure that any external code can't modify the instances by making the setters on <strong class="source-inline">FamilyMember</strong> private. Depending on your application, it might be a good idea to implement this since it will ensure that your models can't accidentally change.</p>
			<p>One final option you have is to let Xcode generate the properties for <strong class="source-inline">NSManagedObject</strong> as an extension on a class you define. This is particularly useful if you have some custom stored properties that you'd like to define on your model or if you have a customized <strong class="source-inline">NSManagedObject</strong> subclass that you can use as the base for all of your models.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">All code that Xcode generates for your Core Data models is added to the <strong class="source-inline">Build</strong> folder in Xcode's Derived Data. You shouldn't modify it or access it directly. These files will be automatically regenerated by Xcode whenever you perform a build, so any functionality you add inside the generated files will be overwritten.</p>
			<p>For the <strong class="bold">MustC</strong> app, it's okay if Xcode generates the model definition classes since there are no custom properties that you need to add. In the model editor, select each entity and make sure that the <strong class="bold">Codegen</strong> field is set to <strong class="bold">Class Definition</strong>; you can find this field in the Data Model in<a id="_idTextAnchor227"/><a id="_idTextAnchor228"/>spector panel.</p>
			<p>At this point, you are all set up to store your first piece of data in the Core Data database:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_8.07_B14717.jpg" alt="Figure 8.7 – The Codegen attribute for entities&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – The Codegen attribute for entities</p>
			<p>In the next section, we<a id="_idIndexMarker362"/> are going to persist data with the model and relationship that we <a id="_idTextAnchor229"/>just created.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor230"/>Persisting data and reacting to data changes</h1>
			<p>The first step to implement data persistence for your app is to make sure that you can store data in the database. You have defined the models that you want to store in your database, so the next step is to actually store your models. Once you have implemented a rough version of your data persistence, you will refine the code to make it more reusable. The final step will be to read data from<a id="_idTextAnchor231"/> Core Data and dynamically respond to changes in <a id="_idTextAnchor232"/> the database.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor233"/>Understanding data persistence</h2>
			<p>Whenever you want <a id="_idIndexMarker363"/>to <a id="_idIndexMarker364"/>persist a model with Core Data, you must insert a new <strong class="source-inline">NSManagedObject</strong> into <strong class="source-inline">NSManagedObjectContext</strong>. Doing this does not immediately persist the model. It merely stages the object for persistence in the current <strong class="source-inline">NSManagedObjectContext</strong>. If you don't properly manage your managed objects and contexts, this is a potential source of bugs. For example, not persisting your managed objects results in the loss of your data once you refresh the context. Even though this might sound obvious, it could lead to several hours of frustration if you aren't aware of this and have bugs in managing your managed object context.</p>
			<p>If you want to save managed objects correctly, you must tell the managed object context to persist its changes to the persistent store coordinator. The persistent store coordinator will take care of persisting the data in the underlying SQLite database.</p>
			<p>Extra care is required when you use multiple managed object contexts. If you insert an object in one managed object context and persist it, you will manually need to synchronize the changes into the other managed object contexts. Also, managed objects are not thread-safe. This means that you must make sure that you create, access, and store a managed object on a single thread at all times. The managed object context has a helper method called <strong class="source-inline">perform(_:)</strong> to help you with this.</p>
			<p>Inserting new objects, updating them, or adding relationships between objects should always be done using the <strong class="source-inline">perform(_:)</strong> method. The reason is that the helper method makes sure that all the code in the closure you want to perform is executed on the same thread that the managed object<a id="_idTextAnchor234"/> context is on.</p>
			<p>Now that you're aware <a id="_idIndexMarker365"/>of how data persistence works in Core Data, it's time to <a id="_idIndexMarker366"/>start implementing the code to store family members and their favorite movies. You will implement the family member persistence first. Then, you'll expand t<a id="_idTextAnchor235"/>he app so that you can safely add movies t<a id="_idTextAnchor236"/>o family members.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor237"/>Persisting your models</h2>
			<p>The first model you will <a id="_idIndexMarker367"/>persist is the family member model. The app is already set up with a form that asks for a family member name and a delegate protocol that informs <strong class="source-inline">FamilyMembersViewController</strong> whenever the user wants to store a new family member.</p>
			<p>Note that none of the input data is validated; usually, you'd want to add some checks that make sure that the user is not trying to insert an empty family member name, for instance. For now, we'll skip that because this type of validation isn't Core Data-specific.</p>
			<p>The code to persist new family members should be added to the <strong class="source-inline">saveFamilyMember(withName:)</strong> method. Add the following implementation to <strong class="source-inline">FamilyMembersViewController</strong>; we'll go over it line by line after adding the code:</p>
			<p class="source-code">func saveFamilyMember(withName name: String) {</p>
			<p class="source-code">  // 1</p>
			<p class="source-code">  let moc = persistentContainer.viewContext</p>
			<p class="source-code">  // 2</p>
			<p class="source-code">  moc.perform {</p>
			<p class="source-code">  // 3</p>
			<p class="source-code">    let familyMember = FamilyMember(context: moc)</p>
			<p class="source-code">    familyMember.name = name</p>
			<p class="source-code">  // 4</p>
			<p class="source-code">    do {</p>
			<p class="source-code">      try moc.save()</p>
			<p class="source-code">    } catch {</p>
			<p class="source-code">      moc.roll<a id="_idTextAnchor238"/>back()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The first comment in this<a id="_idIndexMarker368"/> code marks where the managed object context is extracted from <strong class="source-inline">persistentContainer</strong>. All <strong class="source-inline">NSPersistentContainer</strong> objects have a <strong class="source-inline">viewContext</strong> property. This property is used to obtain a managed object context that exists on the main thread.</p>
			<p>The second comment marks the call to <strong class="source-inline">perform(_:)</strong>. This ensures that the new <strong class="source-inline">FamilyMember</strong> instance is created and stored on the correct thread. </p>
			<p>The third comment marks where we create a <strong class="source-inline">familyMember</strong> instance inside our managed object context (<strong class="source-inline">moc</strong>) and we update its name. When you create an instance of a managed object, you must provide the managed object context where the instance will be temporarily stored.</p>
			<p>Lastly, saving the managed object context can fail, so you must wrap the <strong class="source-inline">to save()</strong> call in a <strong class="source-inline">do {} catch {}</strong> block, so it correctly handles potential errors. If the managed object context can't be saved, all unsaved changes are rolled back.</p>
			<p>This code is all you need to persist family members. Before you implement the required code to read existing family members and respond to the insertion of new family members, let's set up <strong class="source-inline">MoviesViewController</strong> so that it can store movies for a family member.</p>
			<p>The code to store movies for a family member is very similar to the code you wrote previously. Before you implement the following snippets, make sure that in the <strong class="source-inline">MoviesViewController</strong> file, you add <strong class="source-inline">import CoreData</strong>. Also, add a <strong class="source-inline">persistentContainer</strong> property to <strong class="source-inline">MoviesViewController</strong>, as follows:</p>
			<p class="source-code">var persistentContainer: NSPersistentContainer!</p>
			<p>In order to connect a <a id="_idIndexMarker369"/>new movie to a family member, you also need a variable to hold the family member in <strong class="source-inline">MoviesViewController</strong>. Add the following declaration to <strong class="source-inline">MoviesViewController</strong>:</p>
			<p class="source-code">var familyMember: FamilyMember?</p>
			<p>After doing this, add the following implementation for <strong class="source-inline">saveMovie(withName:)</strong>:</p>
			<p class="source-code">func saveMovie(withName name: String) {</p>
			<p class="source-code">  guard let familyMember = self.familyMember else { return }</p>
			<p class="source-code">  let moc = persistentContainer.viewContext</p>
			<p class="source-code">  moc.perform {</p>
			<p class="source-code">    let movie = Movie(context: moc)</p>
			<p class="source-code">    movie.title = name</p>
			<p class="source-code">    // 1</p>
			<p class="source-code">    let newFavorites: Set&lt;AnyHashable&gt; = familyMember.movies?.adding(movie) ?? [movie]</p>
			<p class="source-code">    // 2</p>
			<p class="source-code">    familyMember.movies = NSSet(set: newFavorites)</p>
			<p class="source-code">    do {</p>
			<p class="source-code">      try moc.save()</p>
			<p class="source-code">    } catch {</p>
			<p class="source-code">      moc.rollback()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The most important differences between adding the movie and the family member are highlighted with <a id="_idIndexMarker370"/>comments. Note that the <strong class="source-inline">movies</strong> property on a family member is <strong class="source-inline">NSSet</strong>. This is an immutable object, so you need to create a copy and add the movie to that copy. If no copy could be made because there is no set created yet, you can create a new set with the new movie in it. Next, this new, updated set is converted back to an <strong class="source-inline">NSSet</strong> instance so that it can be the new value for movies.</p>
			<p>As you can see, both save methods share about half of the implementation. You can make some clever use of extensions and generics in Swift<a id="_idTextAnchor239"/> to avoid writing this duplicated code. Let's refactor the app a bit.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Notice how we have used <strong class="source-inline">viewContext</strong> for persisting data (in both the <strong class="source-inline">saveFamilyMember</strong> and <strong class="source-inline">saveMovie</strong> methods). For this example, it will work perfectly fine, because we are not doing any heavy tasks. But <strong class="source-inline">viewContext</strong> is associated with the main queue of the application, so it is not good practice to do any work with it that can block the UI (such as persisting a large amount of data). In the last section of this chapter, we will refactor this code by creating a private context that works in a background thread. We will persist data in the background and read changes from <strong class="source-inline">viewContext</strong> in the<a id="_idIndexMarker371"/> main thread. By using two different contexts, one in the background and one in the main thread, we will follow best practices and ensure we don't block the UI <a id="_idTextAnchor240"/>while persisting data.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor241"/>Refactoring the persistence code</h2>
			<p>Many iOS developers<a id="_idIndexMarker372"/> dislike the amount of boilerplate code that is involved with using Core Data. Simply persisting an object requires you to repeat several lines of code, which can become quite a pain to write and maintain over time. The approach to refactoring the persistence code presented in the following examples is heavily inspired by the approach taken in the <em class="italic">Core Data</em> book written by <em class="italic">Florian Kugler</em> and <em class="italic">Daniel Eggert</em>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you're interested in learning more about Core Data outside of what this book covers, and if you'd like to see more clever ways to reduce the amount of boilerplate code, you should pick up <em class="italic">Core Data</em> by <em class="italic">Kugler</em> and <em class="italic">Eggert</em>..</p>
			<p>After creating the code blocks to save <strong class="source-inline">familyMember</strong> and <strong class="source-inline">familyMember.movies</strong> instances into Core Data, use the following pattern: </p>
			<p class="source-code">moc.perform {</p>
			<p class="source-code">  // create managed object </p>
			<p class="source-code">  do {</p>
			<p class="source-code">    try moc.save()</p>
			<p class="source-code">  } catch {</p>
			<p class="source-code">    moc.rollback()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now, it would be great if you could write the following code to persist data instead, reducing the duplicated code every time you save an object:</p>
			<p class="source-code">moc.persist {</p>
			<p class="source-code">  // create managed object</p>
			<p class="source-code">}</p>
			<p>This can be achieved by writing an extension for <strong class="source-inline">NSManagedObjectContext</strong>. Add a file called <strong class="source-inline">NSManagedObjectContext</strong> to the extensions folder, and add the following<a id="_idIndexMarker373"/> implementation:</p>
			<p class="source-code">extension NSManagedObjectContext {</p>
			<p class="source-code">  func persist(block: @escaping () -&gt; Void) {</p>
			<p class="source-code">    perform {</p>
			<p class="source-code">      </p>
			<p class="source-code">      block()</p>
			<p class="source-code">      do {</p>
			<p class="source-code">        try self.save()</p>
			<p class="source-code">      } catch {</p>
			<p class="source-code">        self.rollback()</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding code allows you to reduce the amount of boilerplate code, which is something that you should always try to achieve. Reducing boilerplate code greatly improves your code's readability and maintainability. Update both the family overview and the movie list view controllers to make us<a id="_idTextAnchor242"/>e of this new persistence method.</p>
			<p>After optimizing our code to save entities in Core Data with the preceding trick, now let's see how to read <a id="_idIndexMarker374"/>data, making use of <strong class="source-inline">NSFetchRequest</strong>, which allows us to query data in a <a id="_idTextAnchor243"/>simple and effective way.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor244"/>Reading data with a simple fetch request</h2>
			<p>The simplest way to<a id="_idIndexMarker375"/> fetch data from your database is to use a fetch request. The managed object context forwards fetch requests to the persistent store coordinator. The persistent store coordinator will then forward the request to the persistent store, which will then convert the request into a SQLite query. Once the results are fetched, they are passed back up this chain and converted into <a id="_idTextAnchor245"/><strong class="source-inline">NSManagedObject</strong> instances.</p>
			<p>By default, these objects are called faults. When an object is a fault, it means that the actual properties and values for the object are not fetched yet, but they will be fetched once you access them. This is an example of a good implementation of lazy variables because fetching the values is a pretty fast operation, and fetching everything upfront would greatly increase your app's memory footprint because all values would have to be loaded into the app's memory right away.</p>
			<p>Let's take a look at an example of a simple fetch request that retrieves all <strong class="source-inline">FamilyMember</strong> instances that were saved to the database:</p>
			<p class="source-code">let request: NSFetchRequest&lt;FamilyMember&gt; = FamilyMember.fetchRequest()</p>
			<p class="source-code">let moc = persistentContainer.viewContext </p>
			<p class="source-code">guard let results = try? moc.fetch(request) else { return }</p>
			<p>As you can see, it's not particularly hard to fetch all of your family members. Every <strong class="source-inline">NSManagedObject</strong> instance has a class method that configures a basic fetch request that can be used to retrieve data. If you have large amounts of data, you probably don't want to fetch all of the persisted objects at once. You can configure your fetch request to fetch data in batches by setting the <strong class="source-inline">fetchBatchSize</strong> property. It's recommended that you use this property whenever you want to use fetched data in a table view or collection view. You should set the <strong class="source-inline">fetchBatchSize</strong> property to a value that is just a bit higher than the number of cells you expect to display at a time. This makes sure that Core Data fetches plenty of items to display while avoiding loading everything at once.</p>
			<p>Now that you know how to fetch data, let's display some data in the family members table view. Add a new variable called <strong class="source-inline">familyMembers</strong> to <strong class="source-inline">FamilyMembersViewController</strong>. Give this property an initial value of <strong class="source-inline">[FamilyMember]()</strong> so that you start off with an empty array of family members. Also, add the example fetch request you saw earlier to <strong class="source-inline">viewDidLoad()</strong>. Next, assign the result of the fetch request to <strong class="source-inline">familyMembers</strong>, as follows:</p>
			<p class="source-code">familyMembers = results</p>
			<p>Finally, update the table view delegate methods so that <strong class="source-inline">tableView(_:numberOfRowsInSection:)</strong> returns <a id="_idIndexMarker376"/>the number of items in the <strong class="source-inline">familyMembers</strong> array:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</p>
			<p class="source-code">  return familyMembers.count</p>
			<p class="source-code">}</p>
			<p>Also, update the <strong class="source-inline">tableView(_:cellForRowAtIndexPath:)</strong> method by adding the following two highlighted lines before returning the cell:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p>
			<p class="source-code">  guard let cell = tableView.dequeueReusableCell(withIdentifier: "FamilyMemberCell")</p>
			<p class="source-code">    else { fatalError("Wrong cell identifier requested") }</p>
			<p class="source-code">  <strong class="bold">let familyMember = familyMembers[indexPath.row]</strong></p>
			<p class="source-code"><strong class="bold">  cell.textLabel?.text = familyMember.name</strong></p>
			<p class="source-code">  return cell</p>
			<p class="source-code">}</p>
			<p>If you build and run your app now, you should see the family members you already saved. New family members won't show up right away. However, when you quit the app and run it again, new members will show up.</p>
			<p>You could manually reload the table view right after you insert a new family member so that it's always up to date, but this isn't the best approach. You will see a better way to react to the insertion of new data soon. Let's finish the family member detail view first so that it shows a family member's favorite movies. Add the following code to the end of the <strong class="source-inline">prepare(for:sender:)</strong> method in the <strong class="source-inline">FamilyMembersViewController</strong> view controller:</p>
			<p class="source-code">if let moviesVC = segue.destination as? MoviesViewController {</p>
			<p class="source-code">  moviesVC.persistentContainer = persistentContainer</p>
			<p class="source-code">  moviesVC.familyMember = familyMembers[selectedIndex.row]</p>
			<p class="source-code">}</p>
			<p>The method<a id="_idIndexMarker377"/> should look like this:</p>
			<p class="source-code">override func prepare(for segue: UIStoryboardSegue, sender: Any?) {</p>
			<p class="source-code">  if let navVC = segue.destination as? UINavigationController,</p>
			<p class="source-code">    let addFamilyMemberVC = navVC.viewControllers[0] as? AddFamilyMemberViewController {</p>
			<p class="source-code">    addFamilyMemberVC.delegate = self</p>
			<p class="source-code">  }</p>
			<p class="source-code">  guard let selectedIndex = tableView.indexPathForSelectedRow</p>
			<p class="source-code">    else { return }</p>
			<p class="source-code">  <strong class="bold">if let moviesVC = segue.destination as? MoviesViewController {</strong></p>
			<p class="source-code"><strong class="bold">    moviesVC.persistentContainer = persistentContainer</strong></p>
			<p class="source-code"><strong class="bold">    moviesVC.familyMember = familyMembers[selectedIndex.row]</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code">  </p>
			<p class="source-code">  tableView.deselectRow(at: selectedIndex, animated: true)</p>
			<p class="source-code">}</p>
			<p>The preceding lines of code pass the selected family member and the persistent container to <strong class="source-inline">MoviesViewController</strong> so that it can display and store the current family member's favorite movies.</p>
			<p>All you need to <a id="_idIndexMarker378"/>do to show the correct movies for a family member is to use the family member's favorite movies in the <strong class="source-inline">MovieViewController</strong> table view dat<a id="_idTextAnchor246"/>a source methods, as follows:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt;Int {</p>
			<p class="source-code">  return familyMember?.movies?.count ?? 0</p>
			<p class="source-code">}</p>
			<p class="source-code">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p>
			<p class="source-code">  guard let cell = tableView.dequeueReusableCell(withIdentifier: "MovieCell"), let movies = familyMember?.movies</p>
			<p class="source-code">    else { fatalError("Wrong cell identifier requested or missing family member") }</p>
			<p class="source-code">  let moviesArray = Array(movies as! Set&lt;Movie&gt;)</p>
			<p class="source-code">  let movie = moviesArray[indexPath.row]</p>
			<p class="source-code">  cell.textLabel?.text = movie.title</p>
			<p class="source-code">  return cell</p>
			<p class="source-code">}</p>
			<p>You don't need to use a fetch request here because you can simply traverse the <strong class="source-inline">movies</strong> relationship on the family member to get their favorite movies. This isn't just convenient for you as a developer, it's also good for your app's performance. Every time you use a fetch request, you force a query to the database. If you traverse a relationship, Core Data will attempt to fetch the object from memory instead of asking the database.</p>
			<p>Again, adding new data won't immediately trigger the table view to update its contents. We'll get to that after we take a look at how to filter data. If you want to check whether your code works, build <a id="_idIndexMarker379"/>and rerun the app<a id="_idTextAnchor247"/> so that all the latest data is fetched from the database. Now that we know how to query from Core Data, let's perform smarter queries by filtering the retrieved data, with the <a id="_idTextAnchor248"/>help of the <strong class="source-inline">NSPredicate</strong> class.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor249"/>Filtering data with predicates</h2>
			<p>A typical operation <a id="_idIndexMarker380"/>you'll want to perform on your<a id="_idIndexMarker381"/> database is filtering. In Core Data, you use predicates to do this. A <strong class="bold">predicate</strong> describes a set of rules that any object that gets fetched has to match.</p>
			<p>When you model your data in the model editor, it's wise to think about the types of filtering you need to do. For instance, you may be building a birthday calendar where you'll often sort or filter by date. If this is the case, you should make sure that you have a Core Data index for this property. You can enable indexing with the checkbox you saw earlier in the model editor. If you ask Core Data to index a property, it will significantly improve performance when filtering and selecting data in large datasets.</p>
			<p>Writing predicates can be confusing, especially if you try to think of them as the <strong class="source-inline">WHERE</strong> clause from SQL. Predicates are very similar, but they're not quite the same. A simple predicate looks as follows:</p>
			<p class="source-code">NSPredicate(format: "name CONTAINS[n] %@", "Gu")</p>
			<p>A predicate has a format; this format always starts with a key. This key represents the property you want to match with. In this example, it would be the name of a family member. Then, you specify the condition – for instance, <strong class="source-inline">==, &gt;, &lt;, or CONTAINS[n]</strong>.</p>
			<p>There are more conditions available, but the ones listed are some examples of conditions you'll commonly use. Finally, you will specify a placeholder that is substituted with the true value. This placeholder is <strong class="source-inline">%@</strong> in the preceding example. If you have written any Objective-C before you picked up this book, the <strong class="source-inline">%@</strong> placeholder might look familiar to you because it's used as a plac<a id="_idTextAnchor250"/>eholder in format strings there.</p>
			<p>The example predicate is very simple and bare; it could be the template for a search feature you're building. Usually, a simple search doesn't have to be much more complicated than this as long as there's an index added to the properties you search for.</p>
			<p>If you have multiple predicates you want to match on, you can combine them using <strong class="source-inline">NSCompoundPredicate</strong>. This<a id="_idIndexMarker382"/> class combines different predicates <a id="_idIndexMarker383"/>using either an <strong class="source-inline">and</strong>, <strong class="source-inline">or</strong>, or <strong class="source-inline">not</strong> clause. A typical use case for this approach is when you build a complex filter in your app where the predicate is hard to express in a single statement.</p>
			<p>To use a predicate in a fetch request, you assign it to the <strong class="source-inline">predicate</strong> property of a fetch request. Every fetch request has a <strong class="source-inline">predicate</strong> property that you can set. It can handle both a single predicate and a compound predicate. If you set this property before executing the fetch request, the predicate is applied to the request, and you will receive a filtered dataset instead of the full dataset.</p>
			<p>Predicates are powerful, and they have many options available.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you're interested in an in-depth overview of predicates and all of the ways in which you can make use of format strings, I recommend that you read <em class="italic">Apple's Predicate Programming Guide</em> at <a href="http://apple.co/2fF3qHc">http://apple.co/2fF3qHc</a>. It provides a well-documented overview of predicates and their applications.</p>
			<p>Next up, you will learn how to respond to changes <a id="_idTextAnchor251"/>in the managed object context – for instance, when <a id="_idIndexMarker384"/>you<a id="_idTextAnchor252"/> add new family members and <a id="_idIndexMarker385"/>movies.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor253"/>Reacting to database changes</h2>
			<p>In its current <a id="_idIndexMarker386"/>state, the <strong class="bold">MustC</strong> app doesn't update its list when a new managed object is persisted. One possible solution for this is to manually reload the table right after a new family member is inserted. Although this might work well for some time, it's not the best solution to this problem. If the app grows, you might add functionality that imports new family members from the network. Manually refreshing the table view would be problematic because the networking logic should not be aware of the table view. Luckily, there is a better solution to react to changes in your data.</p>
			<p>One way to respond to database changes is by using <strong class="source-inline">NSFetchedResultsController</strong>. This class is perfect for listening to the insertion of new family members. You will implement this approach in <strong class="source-inline">FamilyMembersViewController</strong>. A second way to respond to updates is through notifications. You will implement t<a id="_idTextAnchor254"/><a id="_idTextAnchor255"/><a id="_idTextAnchor256"/>his approach in <strong class="source-inline">MoviesViewController</strong>.</p>
			<h3>Implementing NSFetchedResultsController</h3>
			<p><strong class="source-inline">NSFetchedResultsController</strong> is a helper class that specializes in fetching data and managing this<a id="_idIndexMarker387"/> data. It <a id="_idIndexMarker388"/>listens to changes in its managed object context and notifies a delegate whenever the data it has fetched changes. This is incredibly helpful because it allows you to respond to specific changes in the dataset rather than reloading the table view entirely.</p>
			<p>Being a delegate for the fetched results controller involves the following important methods:</p>
			<ul>
				<li><strong class="source-inline">controllerWillChangeContent(_:)</strong> is called right before the controller passes updates to the delegate. If you're using a table view with a fetched-results controller, this is the perfect method to begin updating the table view.</li>
				<li><strong class="source-inline">controller(_:didChange:at:for:newIndexPath:)</strong> and <strong class="source-inline">controller(_:didChange:atSectionIndex:for:)</strong> are called to inform the delegate about updates to the fetched items and sections, respectively. This is where you should handle updates in the fetched data. For instance, you could insert new rows in a table view if new items were inserted in the dataset.</li>
				<li><strong class="source-inline">controllerDidChangeContent(_:)</strong> is called. This is the point where you should let the table view know that you've finished processing the updates so that all the updates can be applied to the table view's interface.</li>
			</ul>
			<p>For <strong class="source-inline">MustC</strong>, it doesn't make sense to implement all four methods because the table view that shows family members only has a single section. This means <strong class="source-inline">controller(_:didChange:atSectionIndex:for:)</strong> does not have to be implemented.</p>
			<p>To use a<a id="_idIndexMarker389"/> fetched-results<a id="_idIndexMarker390"/> controller to fetch the stored family members, you need to create an instance of <strong class="source-inline">NSFetchedResultsController</strong> and assign <strong class="source-inline">FamilyMembersViewController</strong> as its delegate so that it can respond to changes in the underlying data. You can then implement the delegate methods so that you can respond to changes in the fetched-results dataset. Remove the <strong class="source-inline">familyMembers</strong> array from the variable declarations in <strong class="source-inline">FamilyMembersViewController</strong> and add the following <strong class="source-inline">fetchedResultsController</strong> property:</p>
			<p class="source-code">var fetchedResultsController: NSFetchedResultsController&lt;FamilyMember&gt;?</p>
			<p>The <strong class="source-inline">viewDidLoad</strong> method should be adjusted as follows:</p>
			<p class="source-code">override func viewDidLoad() {</p>
			<p class="source-code">  super.viewDidLoad()</p>
			<p class="source-code">  let moc = persistentContainer.viewContext</p>
			<p class="source-code">  let request = NSFetchRequest&lt;FamilyMember&gt;(entityName: "FamilyMember")</p>
			<p class="source-code">  request.sortDescriptors = [NSSortDescriptor(key: "name", ascending: true)]</p>
			<p class="source-code">  fetchedResultsController = NSFetchedResultsController(fetchRequest: request, managedObjectContext: moc, sectionNameKeyPath: nil, cacheName: nil)</p>
			<p class="source-code">  fetchedResultsController?.delegate = self</p>
			<p class="source-code">  do {</p>
			<p class="source-code">    try fetchedResultsController?.performFetch()</p>
			<p class="source-code">  } catch {</p>
			<p class="source-code">    print("fetch request failed")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This implementation<a id="_idIndexMarker391"/> initializes <strong class="source-inline">NSFetchedResultsController</strong>, assigns its delegate, and tells it to <a id="_idIndexMarker392"/>execute the fetch request. Note that the <strong class="source-inline">sortDescriptors</strong> property of the fetch request is set to an array that contains <strong class="source-inline">NSSortDescriptor</strong>. A fetched-request controller requires this property to be set, and for the list of family members, it makes sense to order family members by name.</p>
			<p>Now that you have a fetched-results controller, you should implement the delegate methods on <strong class="source-inline">FamilyMembersViewController</strong> and make it conform to <strong class="source-inline">NSFetchedResultsControllerDelegate</strong>. Add the following extension to <strong class="source-inline">FamilyMembersViewController.swift</strong>:</p>
			<p class="source-code">extension FamilyMembersViewController: NSFetchedResultsControllerDelegate {</p>
			<p class="source-code">  func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {</p>
			<p class="source-code">    tableView.beginUpdates()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {</p>
			<p class="source-code">    tableView.endUpdates()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The implementation of this extension is fairly straightforward. The table view gets notified when the fetched-result controller is about to process changes to its data and when the fetched-results controller is done processing changes. The bulk of the work needs to be done in <strong class="source-inline">controller(_:didChange:at:for:newIndexPath)</strong>. This method is called when an update has been processed by the fetched-result controller. In <strong class="source-inline">MustC</strong>, the goal is to update a table view, but you could also update a collection view or store all of the updates in a list and do something else with them.</p>
			<p>Let's take a look <a id="_idIndexMarker393"/>at how <a id="_idIndexMarker394"/>you can process changes to fetched data in the following method. Add it to the extension on <strong class="source-inline">FamilyMembersViewController.swift</strong>:</p>
			<p class="source-code">func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {</p>
			<p class="source-code">  switch type {</p>
			<p class="source-code">  case .insert:</p>
			<p class="source-code">    guard let insertIndex = newIndexPath else { return }</p>
			<p class="source-code">    tableView.insertRows(at: [insertIndex], with: .automatic)</p>
			<p class="source-code">  case .delete:</p>
			<p class="source-code">    guard let deleteIndex = indexPath else { return }</p>
			<p class="source-code">    tableView.deleteRows(at: [deleteIndex], with: .automatic)</p>
			<p class="source-code">  case .move:</p>
			<p class="source-code">    guard let fromIndex = indexPath, let toIndex = newIndexPath else { return }</p>
			<p class="source-code">    tableView.moveRow(at: fromIndex, to: toIndex)</p>
			<p class="source-code">  case .update:</p>
			<p class="source-code">    guard let updateIndex = indexPath else { return }</p>
			<p class="source-code">    tableView.reloadRows(at: [updateIndex], with: .automatic)</p>
			<p class="source-code">  @unknown de<a id="_idTextAnchor257"/>fault:</p>
			<p class="source-code">    fatalError("Unhandled case")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This method<a id="_idIndexMarker395"/> contains <a id="_idIndexMarker396"/>quite a lot of code, but it's actually not that complex. The preceding method receives a type parameter. This parameter is an instance of <strong class="source-inline">NSFetchedResultsChangeType</strong>, which contains information about the kind of update that was received. The following are the four types of updates that can occur:</p>
			<ul>
				<li>Insert </li>
				<li>Delete </li>
				<li>Move </li>
				<li>Update</li>
			</ul>
			<p>Each of these change types corresponds to a database action. If an object was inserted, you will receive an insert change type. The proper way to handle these updates for <strong class="source-inline">MustC</strong> is to simply pass them on to the table view. Once all the updates are received, the table view will apply all of these updates at once.</p>
			<p>If you had implemented <strong class="source-inline">controller(_:didChange:atSectionIndex:for:)</strong> as well, it would also have received a <strong class="source-inline">change</strong> type; however, the sections only deal with the following two types of changes:</p>
			<ul>
				<li>Insert</li>
				<li>Delete</li>
			</ul>
			<p>Sections don't update or move, so if you implement this method, you don't have to account for all cases because you won't encounter any, other than the two listed types of changes.</p>
			<p>If you take a close look at the implementation for <strong class="source-inline">controller(_:didChange:at:for:newIndexPath)</strong>, you'll notice that it receives two index paths. One is named <strong class="source-inline">indexPath</strong>, and the other is named <strong class="source-inline">newIndexPath</strong>. They're both optional, so you will need to make sure that you safely unwrap them if you use them. For new objects, only the <strong class="source-inline">newIndexPath</strong> property will be present. For delete and update, the <strong class="source-inline">indexPath</strong> property will be set. When an object is moved from one place in the dataset to another, both <strong class="source-inline">newIndexPath</strong> and <strong class="source-inline">indexPath</strong> will have a value.</p>
			<p>The last thing you <a id="_idIndexMarker397"/>need to <a id="_idIndexMarker398"/>do is update the code in <strong class="source-inline">FamilyMembersViewController</strong> so that it uses the fetched results controller instead of the <strong class="source-inline">familyMembers</strong> array that it used earlier. First, update the <strong class="source-inline">prepare(for:sender:)</strong> method, as follows:</p>
			<p class="source-code">if let moviesVC = segue.destination as? MoviesViewController, let familyMember = fetchedResultsController?.object(at:</p>
			<p class="source-code">   selectedIndex) {</p>
			<p class="source-code">  moviesVC.persistentContainer = persistentContainer</p>
			<p class="source-code">  moviesVC.familyMember = familyMember</p>
			<p class="source-code">}</p>
			<p>This makes sure that a valid family member is passed to the <strong class="source-inline">movies</strong> view controller. Update the table view data source methods, as shown in the following code. A fetched-results controller can retrieve objects based on an index path. This makes it a great fit to use in combination with table views and collection views:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</p>
			<p class="source-code">  return fetchedResultsController?.fetchedObjects?.count ?? 0</p>
			<p class="source-code">}</p>
			<p class="source-code">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p>
			<p class="source-code">  guard let cell = tableView.dequeueReusableCell(withIdentifier: "FamilyMemberCell"), let familyMember = fetchedResultsController?.object(at: indexPath) else { fatalError("Wrong cell identifier requested") }</p>
			<p class="source-code">  cell.textLabel?.text = familyMember.name</p>
			<p class="source-code">  return cell</p>
			<p class="source-code">}</p>
			<p>If you run your app now, the <a id="_idIndexMarker399"/>interface updates automatically when you add a new<a id="_idIndexMarker400"/> family member to the database. However, the list of favorite movies doesn't update yet. That page does not use a fetched-results controller, so it must listen to changes to the dataset directly.</p>
			<p>The reason <strong class="source-inline">MoviesViewController</strong> doesn't use a fetched-results controller for the movie list is that fetched-result controllers will always need to drop down all the way to your persistent store (SQLite in this app). As mentioned before, querying the database has a significant memory overhead compared to traversing the relationship between family members and their movies; it's much faster to read the <strong class="source-inline">movies</strong> property than fetching them from the database.</p>
			<p>Whenever a managed object context changes, a notification is posted to the default <strong class="source-inline">NotificationCenter</strong>. <strong class="source-inline">NotificationCenter</strong> is used to send events inside of an app so that other parts of the code can react to those events.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">It can be very tempting to use notifications instead of delegates, especially if you're coming from a background that makes heavy use of events, such as JavaScript. Don't do this; delegation is better suited to most cases, and it will make your code much more maintainable. Only use notifications if you don't care who's listening to your notifications or if setting up a delegate relationship between objects would mean you'd create very complex relationships between unrelated objects just to set up the delegation.</p>
			<p>Let's subscribe <strong class="source-inline">MoviesViewController</strong> to changes in the managed object context so that it can respond to data changes if needed. Before you implement this, add the following method, which<a id="_idIndexMarker401"/> should be <a id="_idIndexMarker402"/>called when changes in the managed object context occur:</p>
			<p class="source-code">extension MoviesViewController {</p>
			<p class="source-code">  @objc func managedObjectContextDidChange(notification: NSNotification) {</p>
			<p class="source-code">    guard let userInfo = notification.userInfo, let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;FamilyMember&gt;, let familyMember = self.familyMember else { return }</p>
			<p class="source-code">    if updatedObjects.contains(familyMember) {</p>
			<p class="source-code">      tableView.reloadData()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This method reads the notification's <strong class="source-inline">userInfo</strong> dictionary to access the information that's relevant to the current list. You're interested in changes to the current <strong class="source-inline">familyMember</strong> object because when this object changes, you can be pretty sure that a new movie was just inserted. The <strong class="source-inline">userInfo</strong> dictionary contains keys for the inserted, deleted, and updated objects. In this case, you should look for the updated objects because users can't delete or insert new family members in this view. If the family member was updated, the table view is reloaded so that it shows the new data.</p>
			<p>The following code subscribes <strong class="source-inline">MoviesViewController</strong> to changes in the persistent container's managed object context:</p>
			<p class="source-code">override func viewDidLoad() {</p>
			<p class="source-code">  super.viewDidLoad()</p>
			<p class="source-code">  NotificationCenter.default.addObserver(self, selector: #selector(self.managedObjectContextDidChange(notification:)), name: .NSManagedObjectContextObjectsDidChange, object: nil)</p>
			<p class="source-code">}</p>
			<p>When the view loads, the current <strong class="source-inline">MoviesViewController</strong> instance is added as an observer to the <strong class="source-inline">.NSManagedObjectContextObjectsDidChange</strong> notification. Go ahead and build your app;<a id="_idTextAnchor258"/> you should now see the user interfa<a id="_idTextAnchor259"/>ce update whenever you add new data to your database.</p>
			<p>In this section, we learned<a id="_idIndexMarker403"/> how to respond to database changes using two <a id="_idIndexMarker404"/>different methods: <strong class="source-inline">NSFetchedResultsController</strong> and notifications. In the next section, we are going to learn how to manage multiple instances of <strong class="source-inline">NSManagedObjectContext</strong> in order to improve the user interface response when dealing with heavy tasks.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor260"/>Understanding the use of multiple instances of NSManagedObjectContext</h1>
			<p>It has been mentioned <a id="_idIndexMarker405"/>several times in this chapter that you can use multiple managed object contexts. In many cases, you will only need a single managed object context. Using a single managed object context means that all of the code related to the managed object context is executed on the main thread. If you're performing small operations, that's fine. However, imagine importing large amounts of data. An operation such as that could take a while. Executing code that runs for a while on the main thread will cause the user interface to become unresponsive. This is not good, because the user will think your app has crashed. So, how do you work around this? The answer is using multiple managed object contexts.</p>
			<p>In the past, using several managed object contexts was not easy to manage; you had to create instances of <strong class="source-inline">NSManagedObjectContext</strong> using the correct queues yourself. Luckily, <strong class="source-inline">NSPersistentContainer</strong> helps to make complex setups a lot more manageable. If you want to import data on a background task, you can obtain a managed object context by calling <strong class="source-inline">newBackgroundContext()</strong> on the persistent container. Alternatively, you can call <strong class="source-inline">performBackgroundTask</strong> on the persistent container and pass it a closure with the processing you want to do in the background.</p>
			<p>One important thing to understand about Core Data, background tasks, and multithreading is that you must always use a managed object context on the same thread it was created on. Consider the following example:</p>
			<p class="source-code">let backgroundQueue = DispatchQueue(label: "backgroundQueue")</p>
			<p class="source-code">let backgroundContext = persistentContainer.newBackgroundContext()</p>
			<p class="source-code">backgroundQueue.async {</p>
			<p class="source-code">  let results = try? backgroundContext.fetch(someRequest)</p>
			<p class="source-code">  for result in results {</p>
			<p class="source-code">    // use result</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The behavior of this<a id="_idIndexMarker406"/> code can cause you a couple of headaches. The background context was created in a different queue than the one it's used it in. It's always best to make sure to use a managed object context in the same queue it was created in by using the <strong class="source-inline">perform(_:)</strong> method of <strong class="source-inline">NSManagedObject</strong>. More importantly, you must also make sure to use the managed objects you retrieve on the same queue that the managed object context belongs to.</p>
			<p>Often, you'll find that it's best to fetch data on the main queue using the <strong class="source-inline">viewContext</strong> persistent containers. Storing data can be delegated to background contexts if needed. If you do this, you must make sure that the background context is a child context of the main context. When this relationship is defined between the two contexts, your main context will automatically receive updates when the background context is persisted. This is quite convenient because it removes a lot of manual maintenance, which keeps your contexts in sync. Luckily, the persistent container takes care of this for you.</p>
			<p>When you find that your app requires a setup with multiple managed object contexts, it's essential to keep the rules mentioned in this section in mind. Bugs related to using managed objects or managed object contexts in the wrong places are often tedious to debug and hard to discover. When implemented carefully, complex setups with multiple managed object contexts can increase your application's performance and flexibility. </p>
			<p>In our project <strong class="bold">MustC</strong>, the <strong class="source-inline">saveFamily(…)</strong> method inside the <strong class="source-inline">FamilyMembersViewController</strong> file was using the <strong class="source-inline">viewContext</strong> to persist data. Let's refactor<a id="_idIndexMarker407"/> this code to use different managed object contexts and improve the performance of the app. </p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor261"/>Refactoring the persisting code</h2>
			<p>In the <strong class="bold">MustC</strong> project, we <a id="_idIndexMarker408"/>have been persisting data using <strong class="source-inline">viewContext</strong> (you can see this in the <strong class="source-inline">FamilyMembersViewController</strong> file, inside the <strong class="source-inline">saveFamily</strong> method). Remember that we said before that <strong class="source-inline">viewContext</strong> is associated with the main queue of the application. Therefore, we can block the UI if we do any heavy work with it (usually, persisting data can incur heavy work!). So, it is a good idea to use <strong class="source-inline">viewContext</strong> just to read changes in Core Data and use a different managed object context (in a background queue) to persist them. In this way, we will not block the UI while we persist large amounts of data. Let's do this refactor.</p>
			<p>In the code bundle of the chapter, open the project named <strong class="source-inline">MustC_refactor_start</strong>. Open the <strong class="source-inline">FamilyMembersViewController</strong> file and replace <strong class="source-inline">saveFamilyMember(…)</strong> with the following implementation:</p>
			<p class="source-code">func saveFamilyMember(withName name: String) {</p>
			<p class="source-code">  // 1</p>
			<p class="source-code">  persistentContainer.performBackgroundTask({ (moc) in</p>
			<p class="source-code">    // 2</p>
			<p class="source-code">    let familyMember = FamilyMember(context: moc)</p>
			<p class="source-code">    familyMember.name = name</p>
			<p class="source-code">    // 3</p>
			<p class="source-code">    do {</p>
			<p class="source-code">      try moc.save()</p>
			<p class="source-code">    } catch {</p>
			<p class="source-code">      moc.rollback()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">}</p>
			<p>Let's go through the comments (notice that we have the old method by the name of <strong class="source-inline">saveFamilyMemberOld</strong> for reference; you can compare both to see the differences):</p>
			<ol>
				<li>First, we make use of the <strong class="source-inline">performBackgroundTask</strong> persistent container method. Each time this method is invoked, the persistent container creates a new <strong class="source-inline">NSManagedObjectContext</strong> with <strong class="source-inline">concurrencyType</strong> set to <strong class="source-inline">.privateQueueConcurrencyType</strong>. The persistent container then executes the passed-in block against that newly created context on the context's <a id="_idIndexMarker409"/>private queue. We can use this new <strong class="source-inline">moc</strong> object to persist data in a background queue, without the risk of blocking the user interface. Note how in our previous method (<strong class="source-inline">saveFamilyMemberOld</strong>), we were using the <strong class="source-inline">viewContext</strong> managed object context, which can block the user interface if the data to persist is large.</li>
				<li>Second, we create a <strong class="source-inline">familyMember</strong> instance inside our managed object context (<strong class="source-inline">moc</strong>) and we update its name. When you create an instance of a managed object, you must provide the managed object context where the instance will be temporarily stored.</li>
				<li>Last, in the third comment, we save. Saving the managed object context can fail, so you must wrap the <strong class="source-inline">save()</strong> call in a <strong class="source-inline">do {} catch {}</strong> block so that it correctly handles potential errors. If the managed object context can't be saved, all unsaved changes are rolled back.</li>
			</ol>
			<p>Now, let's run the app and add a family member. Oops! Nothing. You will see that when you add the member, the table that displays the existing members doesn't update. However, if you stop and relaunch the app, the new member is there. So, what is happening? Looks like we are saving the data, but the user interface doesn't know about it (until we relaunch and it is reloaded). Why is that? We are persisting the data with a private managed object context, and <strong class="source-inline">viewContext</strong> doesn't know about it. Let's fix this.</p>
			<p>In the <strong class="source-inline">viewDidLoad</strong> method, add this line, just after <strong class="source-inline">let moc = persistentContainer.viewContext</strong>:</p>
			<p class="source-code">moc.automaticallyMergesChangesFromParent = true</p>
			<p>Setting <strong class="source-inline">automaticallyMergesChangesFromParent</strong> to <strong class="source-inline">true</strong> basically makes <strong class="source-inline">viewContext</strong> aware<a id="_idIndexMarker410"/> of any changes that other contexts are performing in the persisting store. If you execute the app now and add a family member, you will see how the table reflects the changes immediately. </p>
			<p>Now, as practice, you can do the same in the <strong class="source-inline">MoviesViewController</strong> file, modifying the <strong class="source-inline">saveMovie</strong> method and setting the <strong class="source-inline">automaticallyMergesChangesFromParent</strong> property of <strong class="source-inline">viewContext</strong> to <strong class="source-inline">true</strong>. Give it a try!</p>
			<p>In this section, we have learned how to use multiple managed object contexts to improve the performance of your <a id="_idTextAnchor262"/>Core Data code. Let's wrap up the chapter now with a summary.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor263"/>Summary</h1>
			<p>This chapter showed you how to implement a relatively simple Core Data database that stores family members and their favorite movies. You used the Core Data model editor in Xcode to configure the models you wanted to store and define the relationship between these models. Once the models were set up, you implemented code that created instances of your models so that they could be stored in the database and retrieved later.</p>
			<p>Next, you retrieved the data from the database and saw that your table views don't automatically update when the underlying data changes. You used an <strong class="source-inline">NSFetchedResult</strong> controller to fetch family members and listen to changes on the list of family members. You saw that this setup is very powerful because you can respond to changes in your data quite easily.</p>
			<p>Finally, you improved the Core Data code by using different managed object contexts, using the background object context to persist data, and the main queue object context to react to the changes and refresh the user interface.</p>
			<p>In the next chapter, you will learn how to enrich the data your users a<a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>dd to the database by fetching and storing data from the web.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor266"/>Further reading</h1>
			<ul>
				<li>The <em class="italic">Core Data</em> book, by Florian Kugler and Daniel Eggert</li>
				<li>Apple's Predicate Programming Guide: <a href="http://apple.co/2fF3qHc">http://apple.co/2fF3qHc</a></li>
			</ul>
		</div>
	</body></html>