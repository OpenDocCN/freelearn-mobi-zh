<html><head></head><body>
  <div id="_idContainer073">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-209" class="chapterTitle">Generics</h1>
    <p class="normal">My first experience with generics was back in 2004, when they were first introduced in the Java programming language. I can still remember picking up my copy of <em class="italic">The Java Programming Language, Fourth Edition</em>, which covered Java 5, and reading about Java's implementation of generics. Since then, I have used generics in several projects, not only in Java but also in other languages. If you are familiar with generics in other languages, such as Java, the syntax that Swift uses will be very familiar. Generics allow us to write very flexible and reusable code; however, just like with subscripts, we need to make sure that we use them properly and do not overuse them.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bullet">What are generics?</li>
      <li class="bullet">How to create and use generic functions</li>
      <li class="bullet">How to create and use generic types</li>
      <li class="bullet">How to use associated types with protocols</li>
    </ul>
    <h1 id="_idParaDest-210" class="title">Introducing generics</h1>
    <p class="normal">The concept of generics <a id="_idIndexMarker490"/>has been around for a while, so it should not be a new concept to developers coming from languages such as Java or C#. The Swift implementation of generics is very similar to these languages. For those developers coming from languages that<a id="_idIndexMarker491"/> do not have generics, such as <strong class="keyword">Objective-C</strong>, they might seem a bit foreign at first, but once you start using them, you will realize how powerful they are.</p>
    <p class="normal">Generics allow us to write very flexible and reusable code that avoids duplication. With a type-safe language, such as Swift, we often need to write functions, classes, and structures that are valid for multiple types. Without generics, we need to write separate functions for each type we wish to support; however, with generics, we can write one generic function to provide the functionality for multiple types. Generics allow us to tell a function or type, "<em class="italic">I know Swift is a type-safe language, but I do not know the type that will be needed yet. I will give you a placeholder for now and will let you know what type to enforce later.</em>"</p>
    <p class="normal">In Swift, we have the<a id="_idIndexMarker492"/> ability to define both generic functions and generic types. Let's look at generic functions first.</p>
    <h1 id="_idParaDest-211" class="title">Generic functions</h1>
    <p class="normal">Let's begin by<a id="_idIndexMarker493"/> examining the problem that generics try to solve, and then we will see how generics solve this problem. Let's say that we wanted to create functions that swapped the values of two variables, as described in the first part of this chapter; however, for our application, we need to swap two <code class="Code-In-Text--PACKT-">integer</code> types, two <code class="Code-In-Text--PACKT-">Double</code> types, and two <code class="Code-In-Text--PACKT-">String</code> types. The following code shows what these functions could look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapInts</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> Int,b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> Int)</span> { 
    <span class="hljs-keyword">let</span> tmp = a
    a = b
    b = tmp
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapDoubles</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> Double,b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> Double)</span> { 
    <span class="hljs-keyword">let</span> tmp = a
    a = b
    b = tmp
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapStrings</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> String, b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> String)</span> { 
    <span class="hljs-keyword">let</span> tmp = a
    a = b
    b = tmp
} 
</code></pre>
    <p class="normal">With these three functions, we can swap the original values of two <code class="Code-In-Text--PACKT-">Integer</code> types, two <code class="Code-In-Text--PACKT-">Double</code> types, and two <code class="Code-In-Text--PACKT-">String</code> types. Now, let's say, as we develop our application further, we find out that we also need to swap the values of two unsigned <code class="Code-In-Text--PACKT-">Integer</code> types, two <code class="Code-In-Text--PACKT-">Float</code> types, and even a couple of custom types. We might easily end up with eight or more swap functions. The worst part is that each of these functions contains duplicate code. The only difference between these functions is that the parameter types change. While this solution does work, generics offer a much simpler and more elegant solution that eliminates all the duplicate code. Let's see how we would condense all three of the preceding functions into a single generic function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapGeneric</span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> T, b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> T)</span> { 
    <span class="hljs-keyword">let</span> tmp = a
    a = b
    b = tmp
}
</code></pre>
    <p class="normal">Let's look at how we defined the <code class="Code-In-Text--PACKT-">swapGeneric</code> function. The function itself looks pretty similar to a normal function, except for the capital <code class="Code-In-Text--PACKT-">T</code>. The capital <code class="Code-In-Text--PACKT-">T</code>, as used in the <code class="Code-In-Text--PACKT-">swapGeneric</code> function, is a placeholder type, and tells Swift that we will be defining the type later. When a type is defined, it will be used in place of all the placeholders.</p>
    <p class="normal">To define a generic function, we include the placeholder type between two angular brackets <code class="Code-In-Text--PACKT-">(&lt;T&gt;)</code> after the function's name. We can then use that placeholder type in place of any type definition within the parameter definitions, the return type, or the function itself. The big thing to keep in mind is that, once the placeholder is defined as a type, all the other placeholders assume that type. Therefore, any variable or constant defined with that <a id="_idIndexMarker494"/>placeholder must conform to that type.</p>
    <p class="normal">There is nothing special about the capital <code class="Code-In-Text--PACKT-">T</code>; we could use any valid identifier in place of <code class="Code-In-Text--PACKT-">T</code>. We can also use descriptive names, such as key and value, as the Swift language does with dictionaries. The following definitions are perfectly valid:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapGeneric</span><span class="hljs-function">&lt;G&gt;</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> G, b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> G)</span> {
<span class="hljs-comment">    //Statements</span>
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">swapGeneric</span><span class="hljs-function">&lt;xyz&gt;</span><span class="hljs-params">(a: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> xyz, b: </span><span class="hljs-keyword">inout</span><span class="hljs-params"> xyz)</span> {
<span class="hljs-comment">    //Statements</span>
}
</code></pre>
    <p class="normal">In most documentation, generic placeholders are defined with either <code class="Code-In-Text--PACKT-">T</code> (for type) or <code class="Code-In-Text--PACKT-">E</code> (for element). We will, for the purposes of this chapter, use the capital <code class="Code-In-Text--PACKT-">T</code> to define generic placeholders. It is also good practice to use the capital <code class="Code-In-Text--PACKT-">T</code> to define a generic placeholder within our code so that the placeholder is easily recognized when we are looking at the code at a later time.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">If you do not like using the capital <code class="Code-In-Text--PACKT-">T</code> or capital <code class="Code-In-Text--PACKT-">E</code> to define generics, try to be consistent. I would recommend that you avoid the use of different identifiers to define generics throughout your code.</p>
    </div>
    <p class="normal">If we need to use multiple generic types, we can create multiple placeholders by separating them with commas. The following example shows how to define multiple placeholders for a single function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testGeneric</span><span class="hljs-function">&lt;T,E&gt;</span><span class="hljs-params">(a: T, b: E)</span> {
<span class="hljs-comment">    //Statements</span>
}
</code></pre>
    <p class="normal">In this example, we are defining two generic placeholders, <code class="Code-In-Text--PACKT-">T</code> and <code class="Code-In-Text--PACKT-">E</code>. In this case, we can set the <code class="Code-In-Text--PACKT-">T</code> placeholder to one type and the <code class="Code-In-Text--PACKT-">E</code> placeholder to a different type.</p>
    <p class="normal">Let's look at how to call a generic function. The following code will swap two integers using the <code class="Code-In-Text--PACKT-">swapGeneric&lt;T&gt;(inout a: T, inout b: T)</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>
swapGeneric(a: &amp;a, b: &amp;b)
<span class="hljs-built_i">print</span>(<span class="hljs-string">"a:\(a) b:\(b)"</span>)
</code></pre>
    <p class="normal">If we run this <a id="_idIndexMarker495"/>code, the output will be <code class="Code-In-Text--PACKT-">a: 10 b: 5</code>. We can see that we do not have to do anything special to call a generic function. The function infers the type from the first parameter and then sets all the remaining placeholders to that type. Now, if we need to swap the values of two strings, we will call the same function, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> <span class="hljs-built_i">c</span> = <span class="hljs-string">"My String 1"</span>
<span class="hljs-keyword">var</span> d = <span class="hljs-string">"My String 2"</span>
swapGeneric(a: &amp;<span class="hljs-built_i">c</span>, b: &amp;d)
<span class="hljs-built_i">print</span>(<span class="hljs-string">"c:\(c) d:\(d)"</span>)
</code></pre>
    <p class="normal">We can see that the function is called in exactly the same way as we called it when we wanted to swap two integers. One thing that we cannot do is pass two different types into the swap function, because we defined only one generic placeholder. If we attempt to run the following code, we will receive an error:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> <span class="hljs-built_i">c</span> = <span class="hljs-string">"My String 1"</span>
swapGeneric(a: &amp;a, b: &amp;<span class="hljs-built_i">c</span>)
</code></pre>
    <p class="normal">The error that we will receive is that it cannot convert the value of type <code class="Code-In-Text--PACKT-">String</code> to expected argument type <code class="Code-In-Text--PACKT-">Int</code>, which tells us that we are attempting to use a <code class="Code-In-Text--PACKT-">String</code> value when an <code class="Code-In-Text--PACKT-">Int</code> value is expected. The reason the function is looking for an <code class="Code-In-Text--PACKT-">Int</code> value is because the first parameter that we pass into the function is an <code class="Code-In-Text--PACKT-">Int</code> value, and, therefore, all the generic types in the function become <code class="Code-In-Text--PACKT-">Int</code> types.</p>
    <p class="normal">Now, let's say we have the following function, which has multiple generic types defined:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testGeneric</span><span class="hljs-function">&lt;T,E&gt;</span><span class="hljs-params">(a: T, b: E)</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(a)\(b)"</span>)
}
</code></pre>
    <p class="normal">This function would accept parameters of different types; however, since they are of different types, we would be unable to swap the values because they are different. There are also other limitations to generics. For example, we may think that the following generic function would be valid; however, we would receive an error if we tried to implement it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">genericEqual</span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params">(a: T, b: T)</span> -&gt; <span class="hljs-type">Bool</span>{ 
    <span class="hljs-keyword">return</span> a == b
}
</code></pre>
    <p class="normal">We receive an error because the binary operator <code class="Code-In-Text--PACKT-">==</code> cannot be applied to two <code class="Code-In-Text--PACKT-">T</code> operands. Since the<a id="_idIndexMarker496"/> type of the arguments is unknown at the time the code is compiled, Swift does not know whether it can use the equal operator on the types, and, therefore, an error is thrown. We might think that this is a limit that will make generics hard to use. However, we have a way to tell Swift that we expect the type, represented by a placeholder, to have a certain functionality. This is done with type constraints.</p>
    <p class="normal">A type constraint specifies that a generic type must inherit from a specific class or conform to a particular protocol. This allows us to use the methods or properties defined by the parent class or protocol within the generic function. Let's look at how to use type constraints by rewriting the <code class="Code-In-Text--PACKT-">genericEqual</code> function to use the <code class="Code-In-Text--PACKT-">Comparable</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testGenericComparable</span><span class="hljs-function">&lt;T: Comparable&gt;</span><span class="hljs-params">(a: T, b: T)</span> -&gt; <span class="hljs-type">Bool</span>{ 
   a == b
}
</code></pre>
    <p class="normal">To specify the type constraint, we put the class or protocol constraint after the generic placeholder, where the generic placeholder and the constraint are separated by a colon. This new function works as we might expect, and it will compare the values of the two parameters and return <code class="Code-In-Text--PACKT-">true</code> if they are equal or <code class="Code-In-Text--PACKT-">false</code> if they are not.</p>
    <p class="normal">We can declare multiple constraints just like we declare multiple generic types. The following example shows how to declare two generic types with different constraints:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testFunction</span><span class="hljs-function">&lt;T: MyClass, E: MyProtocol&gt;</span><span class="hljs-params">(a: T, b: E)</span> {
<span class="hljs-comment">    //Statements</span>
}
</code></pre>
    <p class="normal">In this function, the type defined by the <code class="Code-In-Text--PACKT-">T</code> placeholder must inherit from the <code class="Code-In-Text--PACKT-">MyClass</code> class, and the type <a id="_idIndexMarker497"/>defined by the <code class="Code-In-Text--PACKT-">E</code> placeholder must conform to the <code class="Code-In-Text--PACKT-">MyProtocol</code> protocol. Now that we have looked at generic functions, let's look at generic types.</p>
    <h1 id="_idParaDest-212" class="title">Generic types</h1>
    <p class="normal">We already had a<a id="_idIndexMarker498"/> general introduction to how generic types work when we looked at Swift arrays and dictionaries. A generic type is a class, structure, or enumeration that can work with any type, just like the way Swift arrays and dictionaries work. As we recall, Swift arrays and dictionaries are written so that they can contain any type. The catch is that we cannot mix and match different types within an array or dictionary. When we create an instance of our generic type, we define the type that the instance will work with. After we define that type, we cannot change the type for that instance.</p>
    <p class="normal">To demonstrate how to create a generic type, let's create a simple <code class="Code-In-Text--PACKT-">List</code> class. This class will use a Swift array as the backend storage for the list, and will let us add items to the list or retrieve values from the list.</p>
    <p class="normal">Let's begin by seeing how to define our generic <code class="Code-In-Text--PACKT-">List</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt; </span>{
}
</code></pre>
    <p class="normal">The preceding code defines the generic <code class="Code-In-Text--PACKT-">List</code> type. We can see that we use the <code class="Code-In-Text--PACKT-">&lt;T&gt;</code> tag to define a generic placeholder, just like we did when we defined a generic function. This <code class="Code-In-Text--PACKT-">T</code> placeholder can then be used anywhere within the type instead of a concrete type definition.</p>
    <p class="normal">To create an instance of this type, we would need to define the type of items that our list will hold. The following example shows how to create instances of the generic <code class="Code-In-Text--PACKT-">List</code> type for various types:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> stringList = <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;() 
<span class="hljs-keyword">var</span> intList = <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;()
<span class="hljs-keyword">var</span> customList = <span class="hljs-type">List</span>&lt;<span class="hljs-type">MyObject</span>&gt;()
</code></pre>
    <p class="normal">The preceding example creates three instances of the <code class="Code-In-Text--PACKT-">List</code> class. The <code class="Code-In-Text--PACKT-">stringList</code> instance can be used with instances of the <code class="Code-In-Text--PACKT-">String</code> type, the <code class="Code-In-Text--PACKT-">intList</code> instance can be used with instances of the <code class="Code-In-Text--PACKT-">integer</code> type, and the <code class="Code-In-Text--PACKT-">customList</code> instance can be used with instances of the <code class="Code-In-Text--PACKT-">MyObject</code> type.</p>
    <p class="normal">We are not limited to using generics only with classes. We can also define structures and enumerations as generics. The following example shows how to define a generic structure and a generic enumeration:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">GenericStruct</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt; </span>{
}
   <span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">GenericEnum</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt; </span>{
}
</code></pre>
    <p class="normal">Now let's add the backend storage array to our <code class="Code-In-Text--PACKT-">List</code> class. The items that are stored in this array need to be of the same type that we define when we initiate the class; therefore, we will use the <code class="Code-In-Text--PACKT-">T</code> placeholder for the array's definition. The following code shows the <code class="Code-In-Text--PACKT-">List</code> class with an array named <code class="Code-In-Text--PACKT-">items</code>. The <code class="Code-In-Text--PACKT-">items</code> array will be defined using the <code class="Code-In-Text--PACKT-">T</code> placeholder, so<a id="_idIndexMarker499"/> it will hold the same types that we defined for the class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt; </span>{
   <span class="hljs-keyword">var</span> items = [<span class="hljs-type">T</span>]()
}
</code></pre>
    <p class="normal">This code defines our generic <code class="Code-In-Text--PACKT-">List</code> type and uses <code class="Code-In-Text--PACKT-">T</code> as the type placeholder. We can then use this <code class="Code-In-Text--PACKT-">T</code> placeholder anywhere in the class to define the type of an item. That item will then be of the same type that we defined when we created the instance of the <code class="Code-In-Text--PACKT-">List</code> class. Therefore, if we create an instance of the <code class="Code-In-Text--PACKT-">List</code> type, such as <code class="Code-In-Text--PACKT-">var stringList = List&lt;String&gt;()</code>, the <code class="Code-In-Text--PACKT-">items</code> array will be an array of string instances. If we created an instance of the <code class="Code-In-Text--PACKT-">List</code> type, such as <code class="Code-In-Text--PACKT-">var intList = List&lt;Int&gt;()</code>, the <code class="Code-In-Text--PACKT-">items</code> array will be an array of integer instances.</p>
    <p class="normal">Now, we need to create the <code class="Code-In-Text--PACKT-">add()</code> method, which will be used to add an item to the list. We will use the <code class="Code-In-Text--PACKT-">T</code> placeholder within the method declaration to define that the <code class="Code-In-Text--PACKT-">item</code> parameter will be of the same type that we declared when we initiated the class. Therefore, if we create an instance of the <code class="Code-In-Text--PACKT-">List</code> type to use the <code class="Code-In-Text--PACKT-">String</code> type, we will be required to use an instance of the <code class="Code-In-Text--PACKT-">String</code> type as the parameter for the <code class="Code-In-Text--PACKT-">add()</code> method. However, if we create an instance of the <code class="Code-In-Text--PACKT-">List</code> type to use the <code class="Code-In-Text--PACKT-">Int</code> type, we will be required to use an instance of the <code class="Code-In-Text--PACKT-">Int</code> type as the parameter for the <code class="Code-In-Text--PACKT-">add()</code> method.</p>
    <p class="normal">Here is the code for the <code class="Code-In-Text--PACKT-">add()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-params">(item: T)</span> { 
    items.append(item)
}
</code></pre>
    <p class="normal">To create a standalone generic function, we add the <code class="Code-In-Text--PACKT-">&lt;T&gt;</code> declaration after the function name to declare that it is a generic function; however, when we use a generic method within a generic type, we do not need the <code class="Code-In-Text--PACKT-">&lt;T&gt;</code> declaration. Instead, we just need to use the type that we defined in the class declaration. If we wanted to introduce another generic type, we could define it with the method declaration.</p>
    <p class="normal">Now, let's add the <code class="Code-In-Text--PACKT-">getItemAtIndex()</code> method, which will return the item from the backend array, at <a id="_idIndexMarker500"/>the specified index:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getItemAtIndex</span><span class="hljs-params">(index: Int)</span> -&gt; <span class="hljs-type">T?</span> { 
    <span class="hljs-keyword">if</span> items.<span class="hljs-built_i">count</span>&gt;index {
        <span class="hljs-keyword">return</span> items[index]
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">getItemAtIndex()</code> method accepts one argument, which is the index of the item we want to retrieve. We then use the <code class="Code-In-Text--PACKT-">T</code> placeholder to specify that our return type is an optional that might be of the <code class="Code-In-Text--PACKT-">T</code> type or that might be nil. If the backend storage array contains an item at the specified index, we will return that item; otherwise, we return <code class="Code-In-Text--PACKT-">nil</code>.</p>
    <p class="normal">Now, let's look at our entire generic <code class="Code-In-Text--PACKT-">List</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt; </span>{
    <span class="hljs-keyword">var</span> items = [<span class="hljs-type">T</span>]() 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-params">(item: T)</span> {
        items.append(item)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getItemAtIndex</span><span class="hljs-params">(index: Int)</span> -&gt; <span class="hljs-type">T?</span> { 
        <span class="hljs-keyword">guard</span> items.<span class="hljs-built_i">count</span> &lt; index <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> items[index]
         }
         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
}
</code></pre>
    <p class="normal">As we can see, we initially defined the generic <code class="Code-In-Text--PACKT-">T</code> placeholder type in the class declaration. We then used this placeholder type within our class. In our <code class="Code-In-Text--PACKT-">List</code> class, we used this placeholder in three places. We used it as the type for our <code class="Code-In-Text--PACKT-">items</code> array, as the parameter type for our <code class="Code-In-Text--PACKT-">add()</code> method, and as the optional return type in the <code class="Code-In-Text--PACKT-">getItemAtIndex() </code>method.</p>
    <p class="normal">Now, let's look at how to use the <code class="Code-In-Text--PACKT-">List</code> class. When we use a generic type, we define the type to be used within the class between angled brackets, such as <code class="Code-In-Text--PACKT-">&lt;type&gt;</code>. The following code shows how to use the <code class="Code-In-Text--PACKT-">List</code> class to store instances of the <code class="Code-In-Text--PACKT-">String</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> list = <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;()
list.add(item: <span class="hljs-string">"Hello"</span>)
list.add(item: <span class="hljs-string">"World"</span>)
<span class="hljs-built_i">print</span>(list.getItemAtIndex(index: <span class="hljs-number">1</span>))
</code></pre>
    <p class="normal">In the preceding <a id="_idIndexMarker501"/>code, we start off by creating an instance of the <code class="Code-In-Text--PACKT-">List</code> type, called <code class="Code-In-Text--PACKT-">list</code>, and specify that it will store instances of the <code class="Code-In-Text--PACKT-">String</code> type. We then use the <code class="Code-In-Text--PACKT-">add()</code> method twice to store two items in the <code class="Code-In-Text--PACKT-">list</code> instance. Finally, we use the <code class="Code-In-Text--PACKT-">getItemAtIndex()</code> method to retrieve the item at index number <code class="Code-In-Text--PACKT-">1</code>, which will display <code class="Code-In-Text--PACKT-">Optional(World)</code> to the console.</p>
    <p class="normal">We can also define our generic types with multiple placeholder types, similarly to how we use multiple placeholders in our generic methods. To use multiple placeholder types, we separate them with commas. The following example shows how to define multiple placeholder types:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">,</span><span class="hljs-title">E</span><span class="hljs-class">&gt;</span>{
<span class="hljs-comment">//Code</span>
}
</code></pre>
    <p class="normal">We then create an instance of the <code class="Code-In-Text--PACKT-">MyClass</code> type that uses instances of the <code class="Code-In-Text--PACKT-">String</code> and <code class="Code-In-Text--PACKT-">Int</code> types, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> mc = <span class="hljs-type">MyClass</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>&gt;()
</code></pre>
    <p class="normal">We can also use type constraints with generic types. Once again, using a type constraint for a generic type is exactly the same as using one with a generic function. The following code shows how to use a type constraint to ensure that the generic type conforms to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">: </span><span class="hljs-title">Comparable</span><span class="hljs-class">&gt;</span>{}
</code></pre>
    <p class="normal">So far in this chapter, we have seen how to use placeholder types with functions and types. Now let's see <a id="_idIndexMarker502"/>how we can conditionally add extensions to a generic type.</p>
    <h2 id="_idParaDest-213" class="title">Conditionally adding extensions with generics</h2>
    <p class="normal">We can add <a id="_idIndexMarker503"/>extensions to a generic type <a id="_idIndexMarker504"/>conditionally if the type conforms to a protocol. For example, if we wanted to add a <code class="Code-In-Text--PACKT-">sum()</code> method to our generic <code class="Code-In-Text--PACKT-">List</code> type only if the type for <code class="Code-In-Text--PACKT-">T</code> conforms to the numeric protocol, we could do the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class"> </span><span class="hljs-title">where</span><span class="hljs-class"> </span><span class="hljs-title">T</span><span class="hljs-class">: </span><span class="hljs-title">Numeric</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sum</span><span class="hljs-function"> </span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">T</span> {
       items.<span class="hljs-built_i">reduce</span> (<span class="hljs-number">0</span>, +)
    }
}
</code></pre>
    <p class="normal">This extension adds the <code class="Code-In-Text--PACKT-">sum()</code> method to any <code class="Code-In-Text--PACKT-">list</code> instance where the <code class="Code-In-Text--PACKT-">T</code> type conforms to the numeric protocol. This means that the <code class="Code-In-Text--PACKT-">list</code> instance in the previous example, where the list was created to hold <code class="Code-In-Text--PACKT-">String</code> instances, would not receive this method.</p>
    <p class="normal">In the following code, where we create an instance of the <code class="Code-In-Text--PACKT-">List</code> type that contains integers, the instance will receive <code class="Code-In-Text--PACKT-">sum()</code> and can be used as shown:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> list2 = <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;()
list2.add(item: <span class="hljs-number">2</span>)
list2.add(item: <span class="hljs-number">4</span>)
list2.add(item: <span class="hljs-number">6</span>)
<span class="hljs-built_i">print</span>(list2.sum())
</code></pre>
    <p class="normal">The output of this would be <code class="Code-In-Text--PACKT-">12</code>. We are also able to conditionally add functions inside a generic type or extension.</p>
    <h2 id="_idParaDest-214" class="title">Conditionally adding functions</h2>
    <p class="normal">Conditionally adding<a id="_idIndexMarker505"/> extensions, as we saw in the last<a id="_idIndexMarker506"/> section, works great; however, if we had separate functionality that we wished to add for different conditions, we would have to create separate extensions for each condition. Starting in Swift 5.3 with SE-0267, we are able to conditionally add functions to a generic type or extension. Let's take a look at this by rewriting the extension in the previous section:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sum</span><span class="hljs-function"> </span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">T</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">Numeric</span> {
       items.<span class="hljs-built_i">reduce</span> (<span class="hljs-number">0</span>, +)
    }
}
</code></pre>
    <p class="normal">With this code, we moved the <code class="Code-In-Text--PACKT-">where T: Numeric</code> clause out of the extensions declaration and into the function declaration. This will conditionally add the function if the type conforms to the <code class="Code-In-Text--PACKT-">Numeric</code> protocol. Now we can add additional functions to the extension with<a id="_idIndexMarker507"/> different conditions as shown in the<a id="_idIndexMarker508"/> following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sum</span><span class="hljs-function"> </span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">T</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">Numeric</span> {
        items.<span class="hljs-built_i">reduce</span> (<span class="hljs-number">0</span>, +)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sorted</span><span class="hljs-params">()</span> -&gt; [<span class="hljs-type">T</span>] <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">Comparable</span> {
        items.sorted()
    }
}
</code></pre>
    <p class="normal">In the previous code, we added an additional function named <code class="Code-In-Text--PACKT-">sorted()</code> that will only be applied to instances where the type conforms to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol. This enables us to put functions with different conditions in the same extension or generic type rather than creating multiple extensions. I would definitely recommend conditionally adding functions, as shown in this section, over conditionally adding extensions, as shown in the previous section.</p>
    <p class="normal">Now let's look at conditional conformance.</p>
    <h2 id="_idParaDest-215" class="title">Conditional conformance</h2>
    <p class="normal">Conditional<a id="_idIndexMarker509"/> conformance allows a generic type to<a id="_idIndexMarker510"/> conform to a protocol only if the type meets certain conditions. For example, if we wanted our <code class="Code-In-Text--PACKT-">List</code> type to conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol only if the type stored in the list also conformed to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol, we could use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">List</span><span class="hljs-class">: </span><span class="hljs-title">Equatable</span><span class="hljs-class"> </span><span class="hljs-title">where</span><span class="hljs-class"> </span><span class="hljs-title">T</span><span class="hljs-class">: </span><span class="hljs-title">Equatable</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> ==</span><span class="hljs-params">(l1:List, l2:List)</span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">if</span> l1.items.<span class="hljs-built_i">count</span> != l2.items.<span class="hljs-built_i">count</span> { 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">for</span> (e1, e2) <span class="hljs-keyword">in</span> <span class="hljs-built_i">zip</span>(l1.items, l2.items) { 
            <span class="hljs-keyword">if</span> e1 != e2 {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
}
</code></pre>
    <p class="normal">This code will add conformance to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol to any instance of the <code class="Code-In-Text--PACKT-">List</code> type where the type that is stored in the list also conforms to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">There is a new function shown here that we have not talked about: the <code class="Code-In-Text--PACKT-">zip() </code>function. This function will loop through two sequences, in our case arrays, simultaneously and create pairs (<code class="Code-In-Text--PACKT-">e1</code> and <code class="Code-In-Text--PACKT-">e2</code>) that we can compare.</p>
    </div>
    <p class="normal">The comparison function will first check to see that each array contains the same number of elements and if not, it will return <code class="Code-In-Text--PACKT-">false</code>. It then loops through each array, simultaneously<a id="_idIndexMarker511"/> comparing the elements of the arrays; if any of the<a id="_idIndexMarker512"/> pairs do not match, it will return <code class="Code-In-Text--PACKT-">false</code>. If the previous tests pass, <code class="Code-In-Text--PACKT-">true</code> is returned, which indicates that the <code class="Code-In-Text--PACKT-">list</code> instances are equal because the elements in the list are the same.</p>
    <p class="normal">Now let's see how we can add generic subscripts to a non-generic type.</p>
    <h1 id="_idParaDest-216" class="title">Generic subscripts</h1>
    <p class="normal">Prior to Swift 4, if we<a id="_idIndexMarker513"/> wanted to use generics with a subscript, we had to define the subscript at the class or structure level. This forced us to make generic methods when it felt like we should be using subscripts. Starting with Swift 4, we can create generic subscripts, where either the subscript's return type or its parameters may be generic. Let's look at how we can create a generic subscript. In this first example, we will create a subscript that will accept one generic parameter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Hashable</span>&gt;(item: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Int</span> { 
    <span class="hljs-keyword">return</span> item.hashValue
}
</code></pre>
    <p class="normal">When we create a generic subscript, we define the placeholder type after the <code class="Code-In-Text--PACKT-">subscript</code> keyword. In the previous example, we define the <code class="Code-In-Text--PACKT-">T</code> placeholder type and use a type constraint to ensure that the type conforms to the <code class="Code-In-Text--PACKT-">Hashable</code> protocol. This will allow us to pass in an instance of any type that conforms to the <code class="Code-In-Text--PACKT-">Hashable</code> protocol.</p>
    <p class="normal">As we mentioned at the start of this section, we can also use generics for the return type of a subscript. We define the generic placeholder for the return type exactly as we did for the generic parameter. The following example illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">T</span>&gt;(key: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">T?</span> { 
    <span class="hljs-keyword">return</span> dictionary[key] <span class="hljs-keyword">as</span>? <span class="hljs-type">T</span>
}
</code></pre>
    <p class="normal">In this example, we <a id="_idIndexMarker514"/>define the <code class="Code-In-Text--PACKT-">T</code> placeholder type after the <code class="Code-In-Text--PACKT-">subscript</code> keyword, as we did in the previous example. We then use this type as our return type for the <code class="Code-In-Text--PACKT-">subscript</code>.</p>
    <h1 id="_idParaDest-217" class="title">Associated types</h1>
    <p class="normal">An associated type <a id="_idIndexMarker515"/>declares a placeholder name that can be used instead of a type within a protocol. The actual type to be used is not specified until the protocol is adopted. When creating generic functions and types, we used a very similar syntax, as we have seen throughout this chapter. Defining associated types for a protocol, however, is very different. We specify an associated type using the <code class="Code-In-Text--PACKT-">associatedtype</code> keyword.</p>
    <p class="normal">Let's see how to use associated types when we define a protocol. In this example, we will define the <code class="Code-In-Text--PACKT-">QueueProtocol</code> protocol, which defines the capabilities that need to be implemented by the queue that implements it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">QueueProtocol</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">QueueType</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-params">(item: QueueType)</span> 
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getItem</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">QueueType?</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">count</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span>
}
</code></pre>
    <p class="normal">In this protocol, we defined one associated type, named <code class="Code-In-Text--PACKT-">QueueType</code>. We then used this associated type twice within the protocol: once as the parameter type for the <code class="Code-In-Text--PACKT-">add()</code> method and once when we defined the return type of the <code class="Code-In-Text--PACKT-">getItem()</code> method as an optional type that might return an associated type of <code class="Code-In-Text--PACKT-">QueueType</code> or <code class="Code-In-Text--PACKT-">nil</code>.</p>
    <p class="normal">Any type that implements the <code class="Code-In-Text--PACKT-">QueueProtocol</code> protocol must be able to specify the type to use for the <code class="Code-In-Text--PACKT-">QueueType</code> placeholder, and must also ensure that only items of that type are used where the protocol uses the <code class="Code-In-Text--PACKT-">QueueType</code> placeholder.</p>
    <p class="normal">Let's look at how to implement <code class="Code-In-Text--PACKT-">QueueProtocol</code> in a non-generic class called <code class="Code-In-Text--PACKT-">IntQueue</code>. This class will implement the <code class="Code-In-Text--PACKT-">QueueProtocol</code> protocol using the <code class="Code-In-Text--PACKT-">Integer</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">IntQueue</span><span class="hljs-class">: </span><span class="hljs-title">QueueProtocol</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> items = [<span class="hljs-type">Int</span>]()
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-params">(item: Int)</span> { 
        items.append(item)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getItem</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int?</span> {
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_i">count</span> &gt; <span class="hljs-number">0</span> ? items.remove(at: <span class="hljs-number">0</span>) : <span class="hljs-literal">nil</span>
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">count</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_i">count</span>
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">IntQueue</code> class, we<a id="_idIndexMarker516"/> begin by defining our backend storage mechanism as an array of integer types. We then implement each of the methods defined in the <code class="Code-In-Text--PACKT-">QueueProtocol</code> protocol, replacing the <code class="Code-In-Text--PACKT-">QueueType</code> placeholder defined in the protocol with the <code class="Code-In-Text--PACKT-">Int</code> type. In the <code class="Code-In-Text--PACKT-">add()</code> method, the <code class="Code-In-Text--PACKT-">parameter</code> type is defined as an instance of <code class="Code-In-Text--PACKT-">Int</code> type, and in the <code class="Code-In-Text--PACKT-">getItem()</code> method, the <code class="Code-In-Text--PACKT-">return</code> type is defined as an optional that might return an instance of <code class="Code-In-Text--PACKT-">Int</code> type or <code class="Code-In-Text--PACKT-">nil</code>.</p>
    <p class="normal">We use the <code class="Code-In-Text--PACKT-">IntQueue</code> class as we would use any other class. The following code shows this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> intQ = <span class="hljs-type">IntQueue</span>()
intQ.add(item: <span class="hljs-number">2</span>)
intQ.add(item: <span class="hljs-number">4</span>)
<span class="hljs-built_i">print</span>(intQ.getItem()!)
intQ.add(item: <span class="hljs-number">6</span>)
</code></pre>
    <p class="normal">We begin by creating an instance of the <code class="Code-In-Text--PACKT-">IntQueue</code> class, named <code class="Code-In-Text--PACKT-">intQ</code>. We then call the <code class="Code-In-Text--PACKT-">add()</code> method twice to add two values of the integer type to the <code class="Code-In-Text--PACKT-">intQ</code> instance. We then retrieve the first item in the <code class="Code-In-Text--PACKT-">intQ</code> instance by calling the <code class="Code-In-Text--PACKT-">getItem()</code> method. This line will print the number <code class="Code-In-Text--PACKT-">2</code> to the console. The final line of code adds another instance of the integer type to the <code class="Code-In-Text--PACKT-">intQ</code> instance.</p>
    <p class="normal">In the preceding example, we implemented the <code class="Code-In-Text--PACKT-">QueueProtocol</code> protocol in a non-generic way. This means that we replaced the placeholder types with an actual type. <code class="Code-In-Text--PACKT-">QueueType</code> was replaced by the <code class="Code-In-Text--PACKT-">Int</code> type. We can also implement <code class="Code-In-Text--PACKT-">QueueProtocol</code> with a generic type. Let's see how we would do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">GenericQueue</span><span class="hljs-class">&lt;</span><span class="hljs-title">T</span><span class="hljs-class">&gt;: </span><span class="hljs-title">QueueProtocol</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> items = [<span class="hljs-type">T</span>]()
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-params">(item: T)</span> {
        items.append(item)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getItem</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">T?</span> {
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_i">count</span> &gt; <span class="hljs-number">0</span> ? items.remove(at:<span class="hljs-number">0</span>) : <span class="hljs-literal">nil</span>
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">count</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> items.<span class="hljs-built_i">count</span>
    }
}
</code></pre>
    <p class="normal">As we can <a id="_idIndexMarker517"/>see, the <code class="Code-In-Text--PACKT-">GenericQueue</code> implementation is very similar to the <code class="Code-In-Text--PACKT-">IntQueue</code> implementation, except that we define the type to use as the generic placeholder <code class="Code-In-Text--PACKT-">T</code>. We can then use the <code class="Code-In-Text--PACKT-">GenericQueue</code> class as we would use any generic class. Let's look at how to use the <code class="Code-In-Text--PACKT-">GenericQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> intQ2 = <span class="hljs-type">GenericQueue</span>&lt;<span class="hljs-type">Int</span>&gt;()
intQ2.add(item: <span class="hljs-number">2</span>)
intQ2.add(item: <span class="hljs-number">4</span>)
<span class="hljs-built_i">print</span>(intQ2.getItem()!)
intQ2.add(item: <span class="hljs-number">6</span>)
</code></pre>
    <p class="normal">We begin by creating an instance of the <code class="Code-In-Text--PACKT-">GenericQueue</code> class that will use the <code class="Code-In-Text--PACKT-">Int</code> type and name it <code class="Code-In-Text--PACKT-">intQ2</code>. Next, we call the <code class="Code-In-Text--PACKT-">add()</code> method twice to add two instances of the integer type to the <code class="Code-In-Text--PACKT-">intQ2</code> instance. We then retrieve the first item in the queue that was added using the <code class="Code-In-Text--PACKT-">getItem()</code> method and print the value to the console. This line will print the number <code class="Code-In-Text--PACKT-">2</code> to the console.</p>
    <p class="normal">We can also use type constraints with associated types. When the protocol is adopted, the type defined for the associated type must inherit from the class or conform to the protocol defined by the type constraint. The following line defines an associated type with a type constraint:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">associatedtype</span> <span class="hljs-type">QueueType</span>: <span class="hljs-type">Hashable</span>
</code></pre>
    <p class="normal">In this example, we specify that when the protocol is implemented, the type defined for the associated type <a id="_idIndexMarker518"/>must conform to the <code class="Code-In-Text--PACKT-">Hashable</code> protocol.</p>
    <h1 id="_idParaDest-218" class="title">Summary</h1>
    <p class="normal">Generic types can be incredibly useful, and they are also the basis of the Swift standard collection types (arrays and dictionaries); however, as mentioned in the introduction to this chapter, we have to be careful to use them correctly.</p>
    <p class="normal">We saw a couple of examples in this chapter that show how generics can make our lives easier. The <code class="Code-In-Text--PACKT-">swapGeneric()</code> function that was shown at the beginning of the chapter is a good use of a generic function because it allows us to swap two values of any type we choose, while only implementing the swap code once.</p>
    <p class="normal">The generic <code class="Code-In-Text--PACKT-">List</code> type is also a good example of how to make custom collection types that can be used to hold any type. The way that we implemented the generic <code class="Code-In-Text--PACKT-">List</code> type in this chapter is similar to how Swift implements an array and dictionary with generics.</p>
    <p class="normal">In the next chapter, we will look at error handling with Swift and how we can make a feature available only if the device that the user is using has a certain version of the OS.</p>
  </div>
</body></html>