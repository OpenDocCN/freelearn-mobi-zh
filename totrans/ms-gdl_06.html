<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Gradle"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Gradle</h1></div></div></div><p>This chapter covers some more plugins such as <span class="strong"><strong>War</strong></span> and <span class="strong"><strong>Scala</strong></span>, which will be helpful in building web applications and Scala applications. Additionally, we will discuss diverse topics such as <span class="strong"><strong>Property Management</strong></span>, <span class="strong"><strong>Multi-Project build</strong></span>, and <span class="strong"><strong>logging</strong></span> aspects. In the <span class="emphasis"><em>Multi-project build</em></span> section, we will discuss how Gradle supports multi-project build through the root project's build file. It also provides the flexibility of treating each module as a separate project, plus all the modules together like a single project. In the final section of this chapter, we will learn the automated testing aspects with Gradle. You will learn to execute unit tests with different configurations. In this section, we will learn about testing concepts with the examples of two commonly used testing frameworks, JUnit and TestNG.</p><div class="section" title="The War plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>The War plugin</h1></div></div></div><p>The War plugin is used to build<a id="id293" class="indexterm"/> web projects, and like any other plugin, it can be added to the build file by adding the following line:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'war'</pre></div><p>
<code class="literal">War</code> plugin extends the Java plugin and helps to create the <code class="literal">war</code> archives. The <code class="literal">war</code> plugin automatically applies the Java plugin to the build file. During the build process, the plugin creates a <code class="literal">war</code> file instead of a <code class="literal">jar</code> file. The war plugin disables the <code class="literal">jar</code> task of the Java plugin and adds a default <code class="literal">war</code> archive task. By default, the content of the <code class="literal">war</code> file will be compiled classes from <code class="literal">src/main/java</code>; content from <code class="literal">src/main/webapp</code> and all the runtime dependencies. The content can be customized using the <code class="literal">war</code> closure as well.</p><p>In our example, we have created a simple <code class="literal">servlet</code> file to display the current date and time, a <code class="literal">web.xml</code> file and a <code class="literal">build.gradle</code> file. The project structure is displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/B02000_06_01.jpg" alt="The War plugin"/><div class="caption"><p>Figure 6.1</p></div></div><p>The <code class="literal">SimpleWebApp/build.gradle</code> file has the following content:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'war'

repositories {
  mavenCentral()
}

dependencies {
  providedCompile "javax.servlet:servlet-api:2.5"
  compile("commons-io:commons-io:2.4")
  compile 'javax.inject:javax.inject:1'
}</pre></div><p>The <code class="literal">war</code> plugin adds<a id="id294" class="indexterm"/> the <code class="literal">providedCompile</code> and <code class="literal">providedRuntime</code> dependency configurations on top of the Java plugin. The <code class="literal">providedCompile</code> and <code class="literal">providedRuntime</code> configurations have the same scope as <code class="literal">compile</code> and <code class="literal">runtime</code> respectively, but the only difference is that the libraries defined in these configurations will not be a part of the <code class="literal">war</code> archive. In our example, we have defined <code class="literal">servlet-api</code> as the <code class="literal">providedCompile</code> time dependency. So, this library is not included in the <code class="literal">WEB-INF/lib/</code> folder of the <code class="literal">war</code> file. This is because this library is provided by the servlet container such as Tomcat. So, when we deploy the application in a container, it is added by the container. You can confirm this by expanding the <code class="literal">war</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SimpleWebApp$ jar -tvf build/libs/SimpleWebApp.war</strong></span>
<span class="strong"><strong>    0 Mon Mar 16 17:56:04 IST 2015 META-INF/</strong></span>
<span class="strong"><strong>    25 Mon Mar 16 17:56:04 IST 2015 META-INF/MANIFEST.MF</strong></span>
<span class="strong"><strong>    0 Mon Mar 16 17:56:04 IST 2015 WEB-INF/</strong></span>
<span class="strong"><strong>    0 Mon Mar 16 17:56:04 IST 2015 WEB-INF/classes/</strong></span>
<span class="strong"><strong>    0 Mon Mar 16 17:56:04 IST 2015 WEB-INF/classes/ch6/</strong></span>
<span class="strong"><strong>1148 Mon Mar 16 17:56:04 IST 2015 WEB-INF/classes/ch6/DateTimeServlet.class</strong></span>
<span class="strong"><strong>    0 Mon Mar 16 17:56:04 IST 2015 WEB-INF/lib/</strong></span>
<span class="strong"><strong>185140 Mon Mar 16 12:32:50 IST 2015 WEB-INF/lib/commons-io-2.4.jar</strong></span>
<span class="strong"><strong>  2497 Mon Mar 16 13:49:32 IST 2015 WEB-INF/lib/javax.inject-1.jar</strong></span>
<span class="strong"><strong>  578 Mon Mar 16 16:45:16 IST 2015 WEB-INF/web.xml</strong></span>
</pre></div><p>Sometimes, we might<a id="id295" class="indexterm"/> need to customize the project's structure as well. For example, the <code class="literal">webapp</code> folder could be under the root project folder, not in the <code class="literal">src</code> folder. The <code class="literal">webapp</code> folder can also contain new folders such as <code class="literal">conf</code> and <code class="literal">resource</code> to store the properties files, Java scripts, images, and other assets. We might want to rename the <code class="literal">webapp</code> folder to <code class="literal">WebContent</code>. The proposed directory structure might look like this:</p><div class="mediaobject"><img src="graphics/B02000_06_02.jpg" alt="The War plugin"/><div class="caption"><p>Figure 6.2</p></div></div><p>We might also be interested in creating a <code class="literal">war</code> file with a custom name and version. Additionally, we might not want to copy any empty folder such as <code class="literal">images</code> or <code class="literal">js</code> to the <code class="literal">war</code> file.</p><p>To implement these <a id="id296" class="indexterm"/>new changes, add the additional properties to the <code class="literal">build.gradle</code> file as described here. The <a id="id297" class="indexterm"/>
<code class="literal">webAppDirName</code> property sets the new <code class="literal">webapp</code> folder location to the <code class="literal">WebContent</code> folder. The <code class="literal">war</code> closure defines properties such as version and name, and sets the <code class="literal">includeEmptyDirs</code> option as <code class="literal">false</code>. By default, <code class="literal">includeEmptyDirs</code> is set to <code class="literal">true</code>. This means any empty folder in the <code class="literal">webapp</code> directory will be copied to the <code class="literal">war</code> file. By setting it to <code class="literal">false</code>, the empty folders such as <code class="literal">images</code> and <code class="literal">js</code> will not be copied to the <code class="literal">war</code> file. </p><p>The following would be the contents of <code class="literal">CustomWebApp/build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'war'

repositories {
  mavenCentral()
}
dependencies {
  providedCompile "javax.servlet:servlet-api:2.5"
  compile("commons-io:commons-io:2.4")
  compile 'javax.inject:javax.inject:1'
}
webAppDirName="WebContent"

war{
  baseName = "simpleapp"
  version = "1.0"
  extension = "war"
  includeEmptyDirs = false
}</pre></div><p>After the build is successful, the <code class="literal">war</code> file will be created as <code class="literal">simpleapp-1.0.war</code>. Execute the <code class="literal">jar -tvf build/libs/simpleapp-1.0.war</code> command and verify the content of the <code class="literal">war</code> file. You will find the <code class="literal">conf</code> folder is added to the <code class="literal">war</code> file, whereas <code class="literal">images</code> and <code class="literal">js</code> folders are not included.</p><p>You might also find the Jetty plugin<a id="id298" class="indexterm"/> interesting for web application deployment, which enables you to deploy the web application in an embedded container. This plugin automatically applies the War plugin to the project. The Jetty plugin defines three tasks; <code class="literal">jettyRun</code>, <code class="literal">jettyRunWar</code>, and <code class="literal">jettyStop</code>. Task <code class="literal">jettyRun</code> runs the web application<a id="id299" class="indexterm"/> in an embedded Jetty web container, whereas the <code class="literal">jettyRunWar</code> task<a id="id300" class="indexterm"/> helps to build the <code class="literal">war</code> file and then run it in the<a id="id301" class="indexterm"/> embedded web container. Task <code class="literal">jettyStop</code>
<span class="strong"><strong> </strong></span>stops the container instance. Covering more on war configuration is beyond the scope of the<a id="id302" class="indexterm"/> book, so for more information <a id="id303" class="indexterm"/>please refer to the Gradle API documentation. Here is the link: <a class="ulink" href="https://docs.gradle.org/current/userguide/war_plugin.html">https://docs.gradle.org/current/userguide/war_plugin.html</a>.</p></div></div>
<div class="section" title="The Scala plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>The Scala plugin</h1></div></div></div><p>The <span class="strong"><strong>Scala</strong></span> plugin helps you to build the Scala application. Like any other plugin, the Scala plugin can be applied to the build file by adding the following line:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'scala'</pre></div><p>The Scala plugin also<a id="id304" class="indexterm"/> extends the Java plugin and adds a few more tasks such as <code class="literal">compileScala</code>, <code class="literal">compileTestScala</code>, and <code class="literal">scaladoc</code> to work with Scala files. The task names are pretty much all named after their Java equivalent, simply replacing the <code class="literal">java</code> part with <code class="literal">scala</code>. The Scala project's directory structure is also similar to a Java project structure where production code is typically written under <code class="literal">src/main/scala</code> directory and test code is kept under the <code class="literal">src/test/scala</code> directory. Figure 6.3 shows the directory structure of a Scala project. You can also observe from the directory structure that a Scala project can contain a mix of Java and Scala source files. The <code class="literal">HelloScala.scala</code> file has the following content. The output is <code class="literal">Hello, Scala...</code> on the console. This is a very basic code and we will not be able to discuss much detail on the Scala programming language. We<a id="id305" class="indexterm"/> request readers to refer to the Scala language documentation available at <a class="ulink" href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>.</p><div class="informalexample"><pre class="programlisting">package ch6

object HelloScala {
    def main(args: Array[String]) {
      println("Hello, Scala...")
    }
}</pre></div><p>To support the compilation of Scala source code, Scala libraries should be added in the dependency configuration:</p><div class="informalexample"><pre class="programlisting">dependencies {
  compile('org.scala-lang:scala-library:2.11.6')
}</pre></div><div class="mediaobject"><img src="graphics/B02000_06_03.jpg" alt="The Scala plugin"/><div class="caption"><p>Figure 6.3</p></div></div><p>As mentioned, the Scala <a id="id306" class="indexterm"/>plugin extends the Java plugin and adds a few new tasks. For example, the <code class="literal">compileScala</code> task depends on the <code class="literal">compileJava</code> task and the <code class="literal">compileTestScala</code> task depends on the <code class="literal">compileTestJava</code> task. This can be understood easily, by executing <code class="literal">classes</code> and <code class="literal">testClasses</code> tasks and looking at the output.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle classes</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:compileScala</strong></span>
<span class="strong"><strong>:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:classes</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle testClasses</strong></span>
<span class="strong"><strong>:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:compileScala UP-TO-DATE</strong></span>
<span class="strong"><strong>:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:classes UP-TO-DATE</strong></span>
<span class="strong"><strong>:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:compileTestScala UP-TO-DATE</strong></span>
<span class="strong"><strong>:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:testClasses UP-TO-DATE</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>
</p>
</td></tr></tbody></table></div><p>Scala projects are also packaged as <code class="literal">jar</code> files. The <code class="literal">jar</code> task or <code class="literal">assemble</code> task creates a <code class="literal">jar</code> file in the <code class="literal">build/libs</code> directory.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ jar -tvf build/libs/ScalaApplication-1.0.jar</strong></span>
<span class="strong"><strong>0 Thu Mar 26 23:49:04 IST 2015 META-INF/</strong></span>
<span class="strong"><strong>94 Thu Mar 26 23:49:04 IST 2015 META-INF/MANIFEST.MF</strong></span>
<span class="strong"><strong>0 Thu Mar 26 23:49:04 IST 2015 ch6/</strong></span>
<span class="strong"><strong>1194 Thu Mar 26 23:48:58 IST 2015 ch6/Customer.class</strong></span>
<span class="strong"><strong>609 Thu Mar 26 23:49:04 IST 2015 ch6/HelloScala$.class</strong></span>
<span class="strong"><strong>594 Thu Mar 26 23:49:04 IST 2015 ch6/HelloScala.class</strong></span>
<span class="strong"><strong>1375 Thu Mar 26 23:48:58 IST 2015 ch6/Order.class</strong></span>
</pre></div><p>The Scala plugin does not add any extra convention to the Java plugin. Therefore, the conventions defined in the Java plugin, such as lib directory and report directory can be reused in the Scala plugin. The <a id="id307" class="indexterm"/>Scala plugin only adds few <code class="literal">sourceSet</code> properties such as <code class="literal">allScala</code>, <code class="literal">scala.srcDirs</code>, and <code class="literal">scala</code> to work with source set. The following task example displays different properties available to the Scala plugin. This example is similar to the convention example task that we created in <a class="link" href="ch04.html" title="Chapter 4. Plugin Management">Chapter 4</a>, <span class="emphasis"><em>Plugin Management</em></span>. </p><p>The following is a code snippet from <code class="literal">ScalaApplication/build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'scala'
apply plugin: 'eclipse'

version = '1.0'

jar {
  manifest {
  attributes 'Implementation-Title': 'ScalaApplication', 'Implementation-Version': version
  }
}

repositories {
  mavenCentral()
}

dependencies {
  compile('org.scala-lang:scala-library:2.11.6')
  runtime('org.scala-lang:scala-compiler:2.11.6')
  compile('org.scala-lang:jline:2.9.0-1')
}

task displayScalaPluginConvention &lt;&lt; {
  println "Lib Directory: $libsDir"
  println "Lib Directory Name: $libsDirName"
  println "Reports Directory: $reportsDir"
  println "Test Result Directory: $testResultsDir"

  println "Source Code in two sourcesets: $sourceSets"
  println "Production Code: ${sourceSets.main.java.srcDirs}, ${sourceSets.main.scala.srcDirs}"
  println "Test Code: ${sourceSets.test.java.srcDirs}, ${sourceSets.test.scala.srcDirs}"
  println "Production code output: ${sourceSets.main.output.classesDir} &amp; ${sourceSets.main.output.resourcesDir}"
  println "Test code output: ${sourceSets.test.output.classesDir} &amp; ${sourceSets.test.output.resourcesDir}"
}</pre></div><p>The output of the<a id="id308" class="indexterm"/> task <code class="literal">displayScalaPluginConvention</code> is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle displayScalaPluginConvention</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>:displayScalaPluginConvention</strong></span>
<span class="strong"><strong>Lib Directory: &lt;path&gt;/ build/libs</strong></span>
<span class="strong"><strong>Lib Directory Name: libs</strong></span>
<span class="strong"><strong>Reports Directory: &lt;path&gt;/build/reports</strong></span>
<span class="strong"><strong>Test Result Directory: &lt;path&gt;/build/test-results</strong></span>
<span class="strong"><strong>Source Code in two sourcesets: [source set 'main', source set 'test']</strong></span>
<span class="strong"><strong>Production Code: [&lt;path&gt;/src/main/java], [&lt;path&gt;/src/main/scala]</strong></span>
<span class="strong"><strong>Test Code: [&lt;path&gt;/src/test/java], [&lt;path&gt;/src/test/scala]</strong></span>
<span class="strong"><strong>Production code output: &lt;path&gt;/build/classes/main &amp; &lt;path&gt;/build/resources/main</strong></span>
<span class="strong"><strong>Test code output: &lt;path&gt;/build/classes/test &amp; &lt;path&gt;/build/resources/test</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Finally, we will conclude this section by discussing how to execute Scala application from Gradle; we can create a simple task in the build file as follows.</p><div class="informalexample"><pre class="programlisting">task runMain(type: JavaExec){
  main = 'ch6.HelloScala'
  classpath = configurations.runtime + sourceSets.main.output + sourceSets.test.output
}</pre></div><p>The <code class="literal">HelloScala</code> source<a id="id309" class="indexterm"/> file has a main method which prints <code class="literal">Hello, Scala...</code> in the console. The <code class="literal">runMain</code> task executes the main method and displays the output in the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle runMain</strong></span>
<span class="strong"><strong>....</strong></span>
<span class="strong"><strong>:runMain</strong></span>
<span class="strong"><strong>Hello, Scala...</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div></div>
<div class="section" title="Logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Logging</h1></div></div></div><p>Until now we have used <code class="literal">println</code> everywhere in the build script to display the messages to the user. If you are coming from a Java background you know a <code class="literal">println</code> statement is not the right way to give information to the user. You need logging. Logging helps the user to classify the categories of messages to show at different levels. These different levels help users to print a correct <a id="id310" class="indexterm"/>message based on the situation. For example, when a user wants complete detailed tracking of your software, they can use debug level. Similarly, whenever a user wants very limited useful information while executing a task, they can use quiet or info level. Gradle provides the following different types of logging:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Log Level</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>ERROR</p>
</td><td style="text-align: left" valign="top">
<p>This is used to<a id="id311" class="indexterm"/> show error messages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>QUIET</p>
</td><td style="text-align: left" valign="top">
<p>This is used to show limited useful information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>WARNING</p>
</td><td style="text-align: left" valign="top">
<p>This is used to show warning messages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>LIFECYCLE</p>
</td><td style="text-align: left" valign="top">
<p>This is used to show the progress (default level)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>INFO</p>
</td><td style="text-align: left" valign="top">
<p>This is used to show information messages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>DEBUG</p>
</td><td style="text-align: left" valign="top">
<p>This is used to show debug messages (all logs)</p>
</td></tr></tbody></table></div><p>By default, the Gradle log level is LIFECYCLE. The following is the code snippet from <code class="literal">LogExample/build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">task showLogging &lt;&lt; {
  println "This is println example"
  logger.error "This is error message"
  logger.quiet "This is quiet message"
  logger.warn "This is WARNING message"
  logger.lifecycle "This is LIFECYCLE message"
  logger.info "This is INFO message"
  logger.debug "This is DEBUG message"
}</pre></div><p>Now, execute<a id="id312" class="indexterm"/> the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle showLogging</strong></span>

<span class="strong"><strong>:showLogging</strong></span>
<span class="strong"><strong>This is println example</strong></span>
<span class="strong"><strong>This is error message</strong></span>
<span class="strong"><strong>This is quiet message</strong></span>
<span class="strong"><strong>This is WARNING message</strong></span>
<span class="strong"><strong>This is LIFECYCLE message</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Here, Gradle has printed<a id="id313" class="indexterm"/> all the logger statements upto the lifecycle level (including lifecycle), which is Gradle's default log level. You can also control the log level from the command line.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-q</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This will show logs up to the quiet level. It will include error and quiet messages</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-i</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This will show logs up to the info level. It will include error, quiet, warning, lifecycle and info messages.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-s</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This prints out the stacktrace for all exceptions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-d</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This prints out all logs and debug information. This is most expressive log level, which will also print all the minor details.</p>
</td></tr></tbody></table></div><p>Now, execute <code class="literal">gradle showLogging -q</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>This is println example</strong></span>
<span class="strong"><strong>This is error message</strong></span>
<span class="strong"><strong>This is quiet message</strong></span>
</pre></div><p>Apart from the regular lifecycle, Gradle provides an additional option to provide stack trace in case of any exception. Stack trace is different from debug. In case of any failure, it allows tracking of all the nested functions, which are called in sequence up to the point where the stack trace is generated.</p><p>To verify, add the <code class="literal">assert</code> statement in the preceding task and execute the following:</p><div class="informalexample"><pre class="programlisting">task showLogging &lt;&lt; {
println "This is println example"
..
assert 1==2
}</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle showLogging -s</strong></span>
<span class="strong"><strong>……</strong></span>
<span class="strong"><strong>* Exception is:</strong></span>
<span class="strong"><strong>org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':showLogging'.</strong></span>
<span class="strong"><strong>at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:69)</strong></span>
<span class="strong"><strong>       at</strong></span>
<span class="strong"><strong>….</strong></span>
<span class="strong"><strong>org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)</strong></span>
<span class="strong"><strong>       at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)</strong></span>
<span class="strong"><strong>       at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:305)</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>With <code class="literal">stracktrace</code>, Gradle <a id="id314" class="indexterm"/>also provides two options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-s</code> or <code class="literal">--stracktrace</code>: This will print truncated stracktrace</li><li class="listitem" style="list-style-type: disc"><code class="literal">-S</code> or <code class="literal">--full-stracktrace</code>: This will print full stracktrace</li></ul></div></div>
<div class="section" title="File management"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>File management</h1></div></div></div><p>One of the key<a id="id315" class="indexterm"/> features of any build tool is I/O operations and how easily you can perform the I/O operations such as reading files, writing files, and directory-related operations. Developers with Ant or Maven backgrounds know how painful and complex it was to handle the files and directory operations in old build tools; sometimes you had to write custom tasks and plugins to perform these kinds of operations due to XML limitations in Ant and Maven. Since Gradle uses Groovy, it will make your life much easier while dealing with files and directory-related operations.</p><div class="section" title="Reading files"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Reading files</h2></div></div></div><p>Gradle provides simple ways to read the file. You just need to use the File API (application programing interface) and it provides everything to deal with the file. The following is the code <a id="id316" class="indexterm"/>snippet from <code class="literal">FileExample/build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">task showFile &lt;&lt; {
  File file1 = file("readme.txt")
  println file1    // will print name of the file
  file1.eachLine {
    println it  // will print contents line by line
  }
}</pre></div><p>To read the file, we have used <code class="literal">file(&lt;file Name&gt;)</code>. This is the default Gradle way to reference files because Gradle adds some path behavior <code class="literal">($PROJECT_PATH/&lt;filename&gt;)</code> due to absolute and relative referencing of files. Here, the first <code class="literal">println</code> statement will print the name of the file which is <code class="literal">readme.txt</code>. To read a file, Groovy provides the <code class="literal">eachLine</code> method to the <code class="literal">File</code> API, which reads all the lines of the file one by one.</p><p>To access the directory, you can use the following file API:</p><div class="informalexample"><pre class="programlisting">def dir1 = new File("src")
println "Checking directory "+dir1.isFile() // will return false for directory
println "Checking directory "+dir1.isDirectory() // will return true for directory</pre></div></div><div class="section" title="Writing files"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Writing files</h2></div></div></div><p>To write to the files, you can <a id="id317" class="indexterm"/>use either the <code class="literal">append</code> method to add contents to the end of the file or overwrite the file using the <code class="literal">setText</code> or <code class="literal">write</code> methods:</p><div class="informalexample"><pre class="programlisting">task fileWrite &lt;&lt; {
  File file1 = file ("readme.txt")

  // will append data at the end
  file1.append("\nAdding new line. \n")

  // will overwrite contents
  file1.setText("Overwriting existing contents")

  // will overwrite contents
  file1.write("Using write method")
}</pre></div></div><div class="section" title="Creating files/directories"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Creating files/directories</h2></div></div></div><p>You can create a new file<a id="id318" class="indexterm"/> by just writing some text to it:</p><div class="informalexample"><pre class="programlisting">task createFile &lt;&lt; {
  File file1 = new File("newFile.txt")
  file1.write("Using write method")
}</pre></div><p>By writing some data to the file, Groovy will automatically create the file if it does not exist.</p><p>To write content to<a id="id319" class="indexterm"/> file you can also use the leftshift operator (<code class="literal">&lt;&lt;</code>), it will append data at the end of the file:</p><div class="informalexample"><pre class="programlisting">file1 &lt;&lt; "New content"</pre></div><p>If you want to create an empty file, you can create a new file using the <code class="literal">createNewFile()</code> method.</p><div class="informalexample"><pre class="programlisting">task createNewFile &lt;&lt; {
  File file1 = new File("createNewFileMethod.txt")
  file1.createNewFile()
}</pre></div><p>A new directory can be created using the <code class="literal">mkdir</code> command. Gradle also allows you to create nested directories in a single command using <code class="literal">mkdirs</code>:</p><div class="informalexample"><pre class="programlisting">task createDir &lt;&lt; {
  def dir1 = new File("folder1")
  dir1.mkdir()

  def dir2 = new File("folder2")
  dir2.createTempDir()

  def dir3 = new File("folder3/subfolder31")
  dir3.mkdirs() // to create sub directories in one command
}</pre></div><p>In the preceding example, we are creating two directories, one using <code class="literal">mkdir()</code> and the other using <code class="literal">createTempDir()</code>. The difference is when we create a directory using <code class="literal">createTempDir()</code>, that directory gets automatically deleted once your build script execution is completed.</p></div><div class="section" title="File operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>File operations</h2></div></div></div><p>We will see examples of some of the frequently used methods while dealing with files, which will help you in<a id="id320" class="indexterm"/> build automation:</p><div class="informalexample"><pre class="programlisting">task fileOperations &lt;&lt; {
  File file1 = new File("readme.txt")
  println "File size is "+file1.size()
  println "Checking existence "+file1.exists()
  println "Reading contents "+file1.getText()
  println "Checking directory "+file1.isDirectory()
  println "File length "+file1.length()
  println "Hidden file "+file1.isHidden()

  // File paths
  println "File path is "+file1.path
  println "File absolute path is "+file1.absolutePath
  println "File canonical path is "+file1.canonicalPath

// Rename file
file1.renameTo("writeme.txt")

// File Permissions
file1.setReadOnly()
println "Checking read permission "+ file1.canRead()+" write permission "+file1.canWrite()
file1.setWritable(true)
println "Checking read permission "+ file1.canRead()+" write permission "+file1.canWrite()

}</pre></div><p>Most of the preceding methods are self-explanatory. Try to execute the preceding task and observe the output. If you try to execute the <code class="literal">fileOperations</code> task twice, you will get the exception <code class="literal">readme.txt (No such file or directory)</code> since you have renamed the file to <code class="literal">writeme.txt</code>.</p></div><div class="section" title="Filter files"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Filter files</h2></div></div></div><p>Certain file methods<a id="id321" class="indexterm"/> allow users to pass a regular expression as an argument. Regular expressions can be used to filter out only the required data, rather than fetch all the data. The following is an example of the <code class="literal">eachFileMatch()</code> method, which will list only the Groovy<a id="id322" class="indexterm"/> files in a directory:</p><div class="informalexample"><pre class="programlisting">task filterFiles &lt;&lt; {
  def dir1 = new File("dir1")
  dir1.eachFileMatch(~/.*.groovy/) {
    println it
  }
  dir1.eachFileRecurse { dir -&gt;
    if(dir.isDirectory()) {
      dir.eachFileMatch(~/.*.groovy/) {
        println it
      }
    }
  }
}</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle filterFiles</strong></span>

<span class="strong"><strong>:filterFiles</strong></span>
<span class="strong"><strong>dir1\groovySample.groovy</strong></span>
<span class="strong"><strong>dir1\subdir1\groovySample1.groovy</strong></span>
<span class="strong"><strong>dir1\subdir2\groovySample2.groovy</strong></span>
<span class="strong"><strong>dir1\subdir2\subDir3\groovySample3.groovy</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div></div><div class="section" title="Delete files and directories"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Delete files and directories</h2></div></div></div><p>Gradle provides the <a id="id323" class="indexterm"/>
<code class="literal">delete()</code> and <code class="literal">deleteDir()</code> APIs to delete files and directories<a id="id324" class="indexterm"/> respectively:</p><div class="informalexample"><pre class="programlisting">task deleteFile &lt;&lt; {
  def dir2 = new File("dir2")
  def file1 = new File("abc.txt")
  file1.createNewFile()
  dir2.mkdir()
  println "File path is "+file1.absolutePath
  println "Dir path is "+dir2.absolutePath
  file1.delete()
  dir2.deleteDir()
  println "Checking file(abc.txt) existence: "+file1.exists()+" and Directory(dir2) existence: "+dir2.exists()
}</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle deleteFile</strong></span>
<span class="strong"><strong>:deleteFile</strong></span>
<span class="strong"><strong>File path is Chapter6/FileExample/abc.txt</strong></span>
<span class="strong"><strong>Dir path is Chapter6/FileExample/dir2</strong></span>
<span class="strong"><strong>Checking file(abc.txt) existence:  false and Directory(dir2) existence:  false</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>The preceding<a id="id325" class="indexterm"/> task will create a directory <code class="literal">dir2</code> and a file <code class="literal">abc.txt</code>. Then it will print the absolute<a id="id326" class="indexterm"/> paths and finally delete them. You can verify whether it is deleted properly by calling the <code class="literal">exists()</code> function.</p></div><div class="section" title="FileTree"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>FileTree</h2></div></div></div><p>Until now, we have dealt with single file operations. Gradle provides plenty of user-friendly APIs to deal with file collections. One such API is <span class="strong"><strong>FileTree</strong></span>. A FileTree represents a hierarchy of files or directories. It <a id="id327" class="indexterm"/>extends the <code class="literal">FileCollection</code> interface. Several <a id="id328" class="indexterm"/>objects in Gradle such as <code class="literal">sourceSets</code>, implement the <code class="literal">FileTree</code> interface. You can initialize FileTree with the <code class="literal">fileTree()</code> method. The following are the different ways you can initialize the <code class="literal">fileTree</code> method:</p><div class="informalexample"><pre class="programlisting">task fileTreeSample &lt;&lt; {
  FileTree fTree = fileTree('dir1')
  fTree.each {
    println it.name
  }
  FileTree fTree1 = fileTree('dir1') {
    include '**/*.groovy'
  }
  println ""
  fTree1.each {
    println it.name
  }
  println ""
FileTree fTree2 = fileTree(dir:'dir1',excludes:['**/*.groovy'])
  fTree2.each {
    println it.absolutePath
  }
}</pre></div><p>Execute the <code class="literal">gradle fileTreeSample</code> command and observe the output. The first iteration will print all the files in <code class="literal">dir1</code>. The second iteration will only include Groovy files (with extension <code class="literal">.groovy</code>). The third iteration<a id="id329" class="indexterm"/> will exclude Groovy files (with extension <code class="literal">.groovy</code>) and print other files with absolute path.</p><p>You can also use FileTree to read contents from the archive files such as ZIP, JAR, or TAR files:</p><div class="informalexample"><pre class="programlisting">FileTree jarFile = zipTree('SampleProject-1.0.jar')
jarFile.each {
  println it.name
}</pre></div><p>The preceding code snippet will list all the files contained in a <code class="literal">jar</code> file.</p></div></div>
<div class="section" title="Property management"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Property management</h1></div></div></div><p>We cannot make a software available on different operating systems, or different environments without configuring it dynamically. One approach to configure software is by using the properties file or environment properties. The following are the different ways Gradle provides to configure<a id="id330" class="indexterm"/> properties to <code class="literal">build.gradle</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ext</code> closure</li><li class="listitem" style="list-style-type: disc"><code class="literal">gradle.properties</code></li><li class="listitem" style="list-style-type: disc">Command line</li><li class="listitem" style="list-style-type: disc">Custom properties file</li></ul></div><div class="section" title="ext closure"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>ext closure</h2></div></div></div><p>We saw many examples<a id="id331" class="indexterm"/> in <a class="link" href="ch03.html" title="Chapter 3. Managing Task">Chapter 3</a>, <span class="emphasis"><em>Managing Task</em></span>, of adding custom properties to a project using the <code class="literal">ext</code> closure. Thus, we will not discuss the topic in this chapter.</p></div><div class="section" title="gradle.properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>gradle.properties</h2></div></div></div><p>Gradle provides a default mechanism of reading the properties file using <code class="literal">gradle.properties</code>. You can add the <code class="literal">gradle.properties</code> file in any of the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;USER_HOME&gt;/.gradle</code>: <code class="literal">gradle.properties</code> defined under this directory would be accessible to all the projects. You can use this file to define global properties and you can <a id="id332" class="indexterm"/>access these properties using <code class="literal">$project.&lt;propertyname&gt;</code>. If you have defined <code class="literal">GRADLE_USER_HOME</code> to some other directory, then Gradle will skip the <code class="literal">&lt;USER_HOME&gt;/.gradle</code> directory and will read <code class="literal">gradle.properties</code> from the <code class="literal">GRADLE_USER_HOME</code> directory. By default <code class="literal">&lt;USER_HOME&gt;/.gradle</code> would be considered to read the <code class="literal">gradle.properties</code> file. If properties are defined in <code class="literal">&lt;USER_HOME&gt;/.gradle/gradle.properties</code>, but are not set by the user, it leads to an exception. If this is not desired, such properties should be checked using the <code class="literal">hasProperty</code> method of <code class="literal">project</code>, and if not set, it should be initialized with a default value. This property file may also be used for storing passwords.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;ProjectDir&gt;</code>: <code class="literal">gradle.propertie</code>s defined under this directory would be accessible to the current project. You cannot access these properties from any other project. So, all the project-specific properties can be defined in the project's <code class="literal">gradle.properties</code> file.<p>Along with project-level properties, you can also define system-level properties in the <code class="literal">gradle.properties</code> file. To define system-level properties, you can append properties with <code class="literal">systemProp</code>. So <code class="literal">systemProp.sProp1=sVal1</code> will set <code class="literal">sProp1</code> as a system-level property with the value <code class="literal">sVal1</code>.</p></li></ul></div><p>We will see an example in the next section.</p></div><div class="section" title="The command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>The command line</h2></div></div></div><p>You can define runtime properties on the command line also using the <code class="literal">-P</code> and <code class="literal">-D</code> options. Using <code class="literal">-P</code>, you can define <a id="id333" class="indexterm"/>project-specific properties. Using <code class="literal">-D</code>, you can define system-level properties. To access system-level properties, you can use <code class="literal">System.properties['&lt;propertyname&gt;'].</code>Note that, command line properties override <code class="literal">gradle.properties</code>. When you configure properties in multiple places, the following order applies and the last one gets the highest priority:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">gradle.properties</code> in project <code class="literal">build</code> dir.</li><li class="listitem" style="list-style-type: disc"><code class="literal">gradle.properties</code> in Gradle user home.</li><li class="listitem" style="list-style-type: disc">System properties set on the command line.</li></ul></div></div><div class="section" title="The Custom properties file"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>The Custom properties file</h2></div></div></div><p>You might want to use the <a id="id334" class="indexterm"/>custom filename for your properties file, for example, <code class="literal">login.properties</code> or <code class="literal">profile.properties</code>. To use the custom properties, simply read the file using <code class="literal">FileInputStream</code> and convert it to the properties object:</p><div class="informalexample"><pre class="programlisting">task showCustomProp &lt;&lt; {
  Properties props = new Properties()
  props.load(new FileInputStream("login.properties"))
  println props
  println props.get('loginKey1')
}</pre></div><p>The preceding code will read the <code class="literal">login.properties</code> file, and the first <code class="literal">println</code> statement will print all the properties while the second <code class="literal">println</code> statement will display the value of the <code class="literal">loginKey1</code> property.</p><p>Let's take a look at a comprehensive example. We will create one <code class="literal">gradle.properties</code> file in the <code class="literal">&lt;USER_HOME&gt;/.gradle</code> directory and another <code class="literal">gradle.properties</code> file in the project directory:</p><p>
<code class="literal">&lt;USER_HOME&gt;/.gradle/gradle.properties</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>globalProp1=globalVal1</strong></span>
<span class="strong"><strong>globalProp2=globalVal2</strong></span>
</pre></div><p>
<code class="literal">Chapter6/PropertyExample/Proj1/gradle.properties</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Proj1Prop1=Proj1Val1</strong></span>
<span class="strong"><strong>Proj1Prop2=Proj1Val2</strong></span>
<span class="strong"><strong>systemProp.sysProp1=sysVal1</strong></span>
</pre></div><p>Here is our build script, <code class="literal">Chapter6/PropertyExample/Proj1/build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">task showProps &lt;&lt; {
  println "local property "+Proj1Prop1
  println "local property "+Proj1Prop2
  println "local property via command line: "+projCommandProp1
  println "global property "+globalProp1
  println "global property "+globalProp2
  println "System property "+System.properties['sysProp1']
  println "System property via command line: "+System.properties['sysCommandProp1']
}</pre></div><p>Now, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$gradle -PprojCommandProp1=projCommandVal1-DsysCommandProp1=sysCommandVal1 showProps</strong></span>

<span class="strong"><strong>:showProps</strong></span>
<span class="strong"><strong>local property Proj1Val1</strong></span>
<span class="strong"><strong>local property Proj1Val2</strong></span>
<span class="strong"><strong>local property via command line: projCommandVal1</strong></span>
<span class="strong"><strong>global property globalVal1</strong></span>
<span class="strong"><strong>global property globalVal2</strong></span>
<span class="strong"><strong>System property sysVal1</strong></span>
<span class="strong"><strong>System property via command line: sysCommandVal1</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Here, you can see that the first two lines contain the properties defined in the project's <code class="literal">gradle.properties</code> file. The<a id="id335" class="indexterm"/> third line shows the property, which the user initialize with the <code class="literal">-P</code> option. The fourth and fifth lines show the properties defined in <code class="literal">&lt;USER_HOME&gt;/.gradle/gradle.properties</code>. The sixth line shows the system properties defined in the project's <code class="literal">gradle.properties</code> file, and finally, the example shows the system property passed in the command line using the <code class="literal">-D</code> option.</p></div></div>
<div class="section" title="Multi-project build"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Multi-project build</h1></div></div></div><p>We have explored many features of Gradle such as tasks, plugins, and dependency management. We have seen<a id="id336" class="indexterm"/> many examples of the build script involving in-built tasks, custom tasks, and dependencies between the tasks. Yet, we have not covered one of the main features of Gradle, which is <span class="strong"><strong>Multi-Project Build</strong></span>. Until now we have seen build files for a single project. A single project build file represents only one project or one module. It is a very common scenario in any software world that it starts with a single module initially and as the software matures and grows over time, it turns into a big project. Then we need to divide it again into different submodules, but overall, we build the project using one file only. Gradle provides the capability of treating different modules as a different project, which can be grouped under a root project. It also gives the flexibility of building a submodule independently without building the complete project.</p><p>Multi-project is not a<a id="id337" class="indexterm"/> new concept. The only additional capability Gradle provides is to build the modules separately as an individual subproject, and whenever required, you can build the entire module using the root project. The subproject has all the properties and features, which a project object has in Gradle. You can define modular dependencies to other projects. Gradle allows you to define subproject tasks' dependencies to other subprojects. You can build only one subproject (and its dependencies) to optimize the build performance time and so on.</p><div class="section" title="The Multi-project structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>The Multi-project structure</h2></div></div></div><p>Consider a simple user <a id="id338" class="indexterm"/>management Java application, which authenticates and authorizes the user, allows the user to manage his profile, and perform transactions. Let's say we divided this into three different subprojects or modules: login module, profile module, and transaction module.</p><p>One more question might arise, when we have already defined three subprojects why do we need the root project <code class="literal">UserManagement</code>, as it does not contain any source code? One of the purposes of the root project is to coordinate among the subprojects, define dependencies between the projects, if any, define common behaviors to avoid duplicate build configurations in each project, and more.</p><p>The purpose of these three modules is to work on them independently, build them separately, and if required, publish its artifacts without any dependency.</p><p>The directory structure will look like the following diagram:</p><div class="mediaobject"><img src="graphics/B02000_06_04.jpg" alt="The Multi-project structure"/><div class="caption"><p>Figure 6.4</p></div></div><p>Here, we have created three <a id="id339" class="indexterm"/>subprojects: <span class="strong"><strong>login</strong></span>, <span class="strong"><strong>profile</strong></span>, and <span class="strong"><strong>transaction</strong></span>, each module <a id="id340" class="indexterm"/>with its own <code class="literal">src/main/java</code> hierarchy. We <a id="id341" class="indexterm"/>have grouped the subprojects under the root project <span class="strong"><strong>UserManagement</strong></span>. Additionally, the root<a id="id342" class="indexterm"/> project contains one <a id="id343" class="indexterm"/>
<span class="strong"><strong>build.gradle</strong></span> file and a<a id="id344" class="indexterm"/> <span class="strong"><strong>settings.gradle</strong></span> file.</p><p>The <span class="strong"><strong>settings.gradle</strong></span> file is<a id="id345" class="indexterm"/> one of the key files in multi-project build. This file <a id="id346" class="indexterm"/>needs to be present in the root project's directory. It lists all the subprojects. The content of the <span class="strong"><strong>settings.gradle</strong></span> file is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>settings.gradle:</strong></span>
include 'login', 'profile', 'transactions'</pre></div><p>Here, we have included all the subprojects, which are part of the root project. On executing the following command, we get all the project details as output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle projects</strong></span>
<span class="strong"><strong>……</strong></span>
<span class="strong"><strong>Root project 'UserManagement'</strong></span>
<span class="strong"><strong>+--- Project ':login'</strong></span>
<span class="strong"><strong>+--- Project ':profile'</strong></span>
<span class="strong"><strong>\--- Project ':transactions'</strong></span>
<span class="strong"><strong>……</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>The output displays the root project <code class="literal">UserManagement</code>, and all the subprojects which are under the root project. Now, try to delete the <code class="literal">settings.gradle</code> file or remove the include statements in the <code class="literal">settings.gradle</code> file and run this command again. This time, it will display only root project details. The <code class="literal">settings.gradle</code> is an important file, which makes the root project aware of all the subprojects it should include. It is also possible to declare multiple levels of subprojects using <code class="literal">'subproject:subsubproject','subproject:subsubproject:subsubsubproject'</code>, and so on.</p><p>We talked about three phases of the Gradle build life cycle: initialization, configuration, and execution. Using the <code class="literal">settings.gradle</code> file during the initialization phase, Gradle adds all the subproject instances to the build process. You can also add projects by using the <code class="literal">include(String[])</code> method to this object.</p><p>The settings.gradle file<a id="id347" class="indexterm"/> also has access to the <code class="literal">gradle.properties</code> file defined in the settings directory of the build or <code class="literal">&lt;USER_HOME&gt;/.gradle</code> directory and properties provided on the command line using the <code class="literal">–P</code> option. The <code class="literal">settings.gradle</code> file can also execute Gradle tasks, and include plugins and other operations, which can be done in any <code class="literal">.gradle</code> file.</p></div><div class="section" title="The Multi-project execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>The Multi-project execution</h2></div></div></div><p>To determine if the current build process is part <a id="id348" class="indexterm"/>of a multi-project build, it searches for the <code class="literal">settings.gradle</code> file first in the current directory and then in its parent hierarchy. If it finds <code class="literal">settings.gradle</code> in the same directory, it considers itself as a parent project and then checks for subprojects. In another case, if it finds the <code class="literal">settings.gradle</code> file in its parent hierarchy, it checks whether or not the current subdirectory is a subproject of the root project that is found. If the current project is part of the root project, then it is executed as a part of the multi-project build, otherwise, as a single project build.</p><p>The following is the sample <code class="literal">build.gradle</code> under the <code class="literal">UserManagement</code> directory:</p><div class="informalexample"><pre class="programlisting">println "Project name is $name"

project(':login') {
  apply plugin: 'java'
  println "Project name is $name"
  task loginTask &lt;&lt; {
    println "Task name is $name"
  }
}

project(':profile') {
  apply plugin: 'java'
  println "Project name is $name"
  task profileTask &lt;&lt; {
    println "Task name is $name"
  }
}
project(':transactions') {
  apply plugin: 'java'
  println "Project name is $name"
  task transactionTask &lt;&lt; {
    println "Task name is $name"
  }
}</pre></div><p>Now, try to execute the following command from the <code class="literal">UserManagement</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement$ gradle</strong></span>

<span class="strong"><strong>Project name is UserManagement</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is profile</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>:help</strong></span>

<span class="strong"><strong>...</strong></span>
</pre></div><p>Now, go to the <code class="literal">login</code> directory and execute the same command; you will find a similar output. The difference is, in the subproject, the help task would be replaced by: <code class="literal">login:help</code>, because Gradle automatically detects the subproject you are in.</p><p>In the first scenario, Gradle<a id="id349" class="indexterm"/> found the settings.gradle file in the same directory and found three subprojects. Gradle initialized three subprojects and during configuration phase it executed the configuration statements. We did not mention any tasks, so no task is executed.</p><p>In the second scenario, when we executed the Gradle command from the login module, Gradle again started searching for the <code class="literal">settings.gradle</code> file and found this file in the parent directory, and also found the current project to be a part of the multi-project build, and thus, executed the build script as a multi-project build.</p><p>One thing you might have noticed here is that we did not define any <code class="literal">build.gradle</code> for any of the subprojects. We added all the subprojects to the root project's build file. This is one of the ways you can define the multi-project build. The alternative is to create individual build.gradle files in each <a id="id350" class="indexterm"/>of the subprojects. Just remove the project closures from the main build file and copy it to its respective project build file. The new project structure is shown in figure 6.4:</p><div class="mediaobject"><img src="graphics/B02000_06_05.jpg" alt="The Multi-project execution"/><div class="caption"><p>Figure 6.5</p></div></div></div><div class="section" title="Task execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Task execution</h2></div></div></div><p>Before executing a task in the multi-project build, Gradle will search for the task in the root project and in all the<a id="id351" class="indexterm"/> subprojects. If the task are found in multiple projects, it will execute all the tasks consecutively. Execute the following command from the <code class="literal">UserManagement</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle loginTask</strong></span>

<span class="strong"><strong>Project name is UserManagement</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is profile</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>:login:loginTask</strong></span>
<span class="strong"><strong>Task name is loginTask</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Now, copy <code class="literal">loginTask</code> to the transaction project and try to execute the same command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle loginTask</strong></span>
<span class="strong"><strong>….</strong></span>
<span class="strong"><strong>:login:loginTask</strong></span>
<span class="strong"><strong>Task name is loginTask</strong></span>
<span class="strong"><strong>:transactions:loginTask</strong></span>
<span class="strong"><strong>Task name is loginTask</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Here, you can see the Gradle-executed <code class="literal">loginTask</code> in both the <code class="literal">login</code> and <code class="literal">transactions</code> projects. To execute a project-specific task, prefix the task name with the project name and use colon (<code class="literal">:</code>) as a separator—<code class="literal">gradle project:task</code>. To execute <code class="literal">loginTask</code> for the <code class="literal">login</code> module, use the <code class="literal">$ gradle login:loginTask</code> command.</p><p>The multi-project build<a id="id352" class="indexterm"/> helps to avoid redundant configurations and allows optimizing and organizing the build file structure appropriately.</p><p>In the preceding example, we have three subprojects and all have a dependency on the Java plugin. These subprojects might depend on some common libraries as well. Instead of defining dependencies in each of the subproject build files, we can define a common configuration into the root project. By doing so, the entire subproject will inherit this common configuration. This can be done by using two closures: <code class="literal">allprojects</code> and <code class="literal">subprojects</code>. The configuration defined under <code class="literal">allprojects</code> will be shared by all the subprojects, including the root project, whereas configuration under <code class="literal">subprojects</code> will be shared by all the subprojects excluding the root project. Add the following <code class="literal">subprojects{}</code> and <code class="literal">allprojects{}</code> closures, which are used to build a file and remove the <code class="literal">apply plugin: 'java'</code> statement from each subproject:</p><div class="informalexample"><pre class="programlisting">println "Project name is $name"
allprojects {
  version = '2.0'
}
subprojects { // for all subprojects
  apply plugin: 'java'
  repositories {
    mavenCentral()
  }
  dependencies {
    compile 'log4j:log4j:1.2.16'
  }
}</pre></div><p>Here, we have added the Java plugin, <code class="literal">repositories</code> closure, and common dependencies to the <code class="literal">subprojects</code> closure. So, it will<a id="id353" class="indexterm"/> be shared by all the subprojects. We have added a version in <code class="literal">allprojects</code>, which would be shared by all the subprojects, including the root subproject.</p><p>Now, try to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle clean</strong></span>
<span class="strong"><strong>Project name is UserManagement</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is profile</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>:login:clean</strong></span>
<span class="strong"><strong>:profile:clean</strong></span>
<span class="strong"><strong>:transactions:clean</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>It has executed clean tasks in all the subprojects but not for the root project. Even if you try to execute <code class="literal">UserManagement:clean</code> task explicitly, it will throw an exception. If you add <code class="literal">apply plugin: 'java'</code> to the <code class="literal">allprojects</code> closure, it will add clean task to root project along with the subprojects.</p></div><div class="section" title="The Flat hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>The Flat hierarchy</h2></div></div></div><p>Apart from the parent/child hierarchy, you <a id="id354" class="indexterm"/>can also create the subprojects at the same level, which can be included using the <code class="literal">includeFlat '&lt;projectname&gt;'</code> syntax.</p><p>Let's add one more subproject department at the same level with the <code class="literal">UserManagement</code> module.</p><p>The <code class="literal">department</code> module can be added as a subproject to the <code class="literal">UserManagement</code> project by adding the following code in<a id="id355" class="indexterm"/> the <code class="literal">settings.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">includeFlat 'department'
// adding same level project as sub project</pre></div></div><div class="section" title="Interproject dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Interproject dependency</h2></div></div></div><p>When you execute some common<a id="id356" class="indexterm"/> tasks such as <code class="literal">clean</code> and <code class="literal">compile</code> (after adding the Java plugin) on a multi-project build, the default execution order is based on their alphabetical order:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle clean</strong></span>

<span class="strong"><strong>Project name is UserManagement</strong></span>
<span class="strong"><strong>Project name is department</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is profile</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>:department:clean UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:clean UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:clean UP-TO-DATE</strong></span>
<span class="strong"><strong>:transactions:clean UP-TO-DATE</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>The first root project is getting evaluated and then all the subprojects as per their alphabetical order. To override the default behavior, Gradle provides you with a different level of dependency management.</p></div><div class="section" title="Configuration-level dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Configuration-level dependency</h2></div></div></div><p>The configuration-level dependency evaluates or configures a project after the execution of the project<a id="id357" class="indexterm"/> on which it depends upon. For example, you want to set some properties in the profile project and you want to use those properties in the login project. You can achieve this using <code class="literal">evaluationDependsOn</code>. To enable this feature, you should have separate <code class="literal">build.gradle</code> files for each subproject. Let's create independent <code class="literal">build.gradle</code> for each subprojects.</p><p>You can create each subproject and <code class="literal">build.gradle</code> in the following pattern.</p><div class="informalexample"><pre class="programlisting">/&lt;project name&gt;/build.gradle
println "Project name is $name"
task &lt;projectName&gt;Task &lt;&lt; {
  println "Task name is $name "
}</pre></div><p>The root project <code class="literal">build.gradle</code> will look like the following code:</p><p>
<code class="literal">UserManagement_confDep/build.gradle</code>
</p><div class="informalexample"><pre class="programlisting">println "Project name is $name"
allprojects {
  version = '2.0'
}
subprojects { // for all sub projects
  apply plugin: 'java'
  repositories {
    mavenCentral()
  }
}</pre></div><p>Now, execute the following Gradle command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_confDep$ gradle</strong></span>

<span class="strong"><strong>Project name is UserManagement_confDep</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is profile</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>We have executed the Gradle command without any task. It has executed up to the configuration phase and you can see the preceding configuration order in alphabetical order (after root project configuration).</p><p>Now, add the following statement in your login project <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">evaluationDependsOn(':profile')</pre></div><p>Then, execute the Gradle command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_confDep$ gradle</strong></span>

<span class="strong"><strong>Project name is UserManagement_confDep</strong></span>
<span class="strong"><strong>Project name is profile    // Order is changed</strong></span>
<span class="strong"><strong>Project name is login</strong></span>
<span class="strong"><strong>Project name is transactions</strong></span>
<span class="strong"><strong>……</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Now, you can see<a id="id358" class="indexterm"/> that the profile configuration is evaluated before the login configuration.</p></div><div class="section" title="Task-level dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Task-level dependency</h2></div></div></div><p>There might be a situation when a task of a project may depend on another project task. Gradle allows you to maintain task-level dependencies across subprojects. Here is an <a id="id359" class="indexterm"/>example where <code class="literal">loginTask</code> depends on <code class="literal">profileTask</code>:</p><div class="informalexample"><pre class="programlisting">project(':login') {
  println "Project name is $name"
  task loginTask (dependsOn: ":profile:profileTask")&lt;&lt; {
    println "Task name is $name"
  }
}</pre></div><p>Now the output shows the dependency between the tasks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_taskDep$ gradle loginTask</strong></span>
<span class="strong"><strong>….</strong></span>
<span class="strong"><strong>:profile:profileTask</strong></span>
<span class="strong"><strong>Task name is profileTask</strong></span>
<span class="strong"><strong>:login:loginTask</strong></span>
<span class="strong"><strong>Task name is loginTask</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>If you declare an execution dependency between different projects with <code class="literal">dependsOn</code>, the default behavior of this method is to also create a configuration dependency between the two projects. </p></div><div class="section" title="Library dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Library dependency</h2></div></div></div><p>If one of the subprojects needs a class file or JAR file of another subproject to compile, this can be introduced as a compile time dependency. If the login project needs a profile jar in its classpath, you can<a id="id360" class="indexterm"/> introduce dependencies at compile level:</p><div class="informalexample"><pre class="programlisting">project(':login') {
  dependencies {
    compile project(':profile')
  }
  task loginTask (dependsOn: ":profile:profileTask")&lt;&lt; {
    println "Task name is $name"
  }
}</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_libDep$ gradle clean compileJava</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>:login:clean</strong></span>
<span class="strong"><strong>:profile:clean</strong></span>
<span class="strong"><strong>:transactions:clean</strong></span>
<span class="strong"><strong>:department:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:compileJava</strong></span>
<span class="strong"><strong>:profile:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:classes</strong></span>
<span class="strong"><strong>:profile:jar</strong></span>
<span class="strong"><strong>:login:compileJava</strong></span>
<span class="strong"><strong>:transactions:compileJava</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>From the output, we can realize that all the dependent modules were compiled before the login compile tasks were executed.</p></div><div class="section" title="Partial builds"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Partial builds</h2></div></div></div><p>During development, you might need to build the projects again and again. Sometimes you do not make any<a id="id361" class="indexterm"/> changes to your dependent subproject, but Gradle by default always builds the dependencies first and then builds the dependent subprojects. This process might affect overall build performance. To overcome this problem, Gradle provides a solution called partial builds. Partial builds enable you to build only the required project, not its dependency projects. In the preceding example, we have the compile dependency of the login module on the profile project. To compile the login project without the <a id="id362" class="indexterm"/>dependent profile project, command-line option <code class="literal">-a</code> can be applied:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle :login:compileJava -a</strong></span>
<span class="strong"><strong>:login:compileJava</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div></div><div class="section" title="buildDependents"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>buildDependents</h2></div></div></div><p>In an enterprise project, we have project dependencies. When you want to build a project and at the same time you want to build the other dependent projects, the Java plugin provides the<a id="id363" class="indexterm"/> <code class="literal">buildDependents</code> option.</p><p>In the previous example, the login project has compile time dependency on the profile project. We will try to build a profile with the <code class="literal">buildDependents</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_libDep$ gradle :profile:buildDependents</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>:profile:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:classes UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:jar UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:classes UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:jar</strong></span>
<span class="strong"><strong>:login:assemble</strong></span>
<span class="strong"><strong>:login:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:test UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:check UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:build</strong></span>
<span class="strong"><strong>:login:buildDependents</strong></span>
<span class="strong"><strong>:profile:assemble UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:test UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:check UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:build UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:buildDependents</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Since the login module <a id="id364" class="indexterm"/>depends on the profile module, executing the profile project also builds the login project.</p></div><div class="section" title="buildNeeded"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>buildNeeded</h2></div></div></div><p>When you build the project, it only compiles the code and prepares the JAR file. If you have compile-time dependencies on the other project, it only compiles the other project and prepares the JAR file. To check the functionality of the complete component, you might want to execute the test cases as well. To execute the test case of the subproject as well as the dependent project, use<a id="id365" class="indexterm"/> <code class="literal">buildNeeded</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/UserManagement_libDep$ gradle :login:buildNeeded</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>:login:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:test UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:check UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:build UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:assemble UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:test UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:check UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:build UP-TO-DATE</strong></span>
<span class="strong"><strong>:profile:buildNeeded UP-TO-DATE</strong></span>
<span class="strong"><strong>:login:buildNeeded UP-TO-DATE</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Here, <code class="literal">buildNeeded</code> not<a id="id366" class="indexterm"/> only executes the login test cases, it also executes the profile test cases.</p></div></div>
<div class="section" title="Testing with Gradle"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Testing with Gradle</h1></div></div></div><p>No piece of software is production ready unless it passes through a proper quality check. It helps to deliver software with minimum defects and saves lots of maintenance effort. However, manual test execution requires lots of time to execute tests and therefore the software release cycle is delayed. Release time<a id="id367" class="indexterm"/> and productivity can be improved if tests are automated.</p><p>Gradle provides an automated way to execute test code, especially for unit tests. In the following section, we'll explore how to integrate JUnit and TestNG with Gradle.</p><div class="section" title="JUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>JUnit</h2></div></div></div><p>Gradle's Java plugin provides a <a id="id368" class="indexterm"/>predefined structure to keep test code and test resources for configuration and execution. As with the source code structure, the default test<a id="id369" class="indexterm"/> code location is <code class="literal">src/test/java/&lt;test_package&gt;</code>. If you follow this convention, you just need to execute the <code class="literal">test</code> task to run the unit test cases as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle test</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:compileTestJava</strong></span>
<span class="strong"><strong>:processTestResources</strong></span>
<span class="strong"><strong>:testClasses</strong></span>
<span class="strong"><strong>:test</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>This test task will perform all the required operations such as the compilation of the source code, compilation of the test code, process resources, and finally, execution of the test cases and creation of reports.</p><p>JUnit provides a user-friendly format to understand the result. You will find the following hierarchy after executing the test task:</p><div class="mediaobject"><img src="graphics/B02000_06_06.jpg" alt="JUnit"/><div class="caption"><p>Figure 6.6</p></div></div><p>The <code class="literal">reports</code> folder <a id="id370" class="indexterm"/>contains a <code class="literal">tests</code> subdirectory, which has a test summary<a id="id371" class="indexterm"/> result in HTML format named <code class="literal">index.html</code>. If you open the <code class="literal">index.html</code> file, you will find the following output:</p><div class="mediaobject"><img src="graphics/B02000_06_07.jpg" alt="JUnit"/><div class="caption"><p>Figure 6.7</p></div></div><p>It provides a complete analysis of test case scenarios such as number of test cases executed, test cases failed, ignored, and so on. From the report, you can drill down further to the individual test<a id="id372" class="indexterm"/> case level by following the hyperlinks on the report page. The report will show a detailed explanation of the error/exception that occurred, if any, and the execution time in a tabular format. </p><p>Until now, we have only discussed the execution of the test cases using Gradle. To compile and execute test cases, we need a test framework library. Like any other configuration, you need to mention the JUnit JAR as a dependency for your project. Typically, the dependency is added as a <code class="literal">testCompile</code> configuration:</p><div class="informalexample"><pre class="programlisting">repositories {
  mavenCentral()
}
dependencies {
  testCompile 'junit:junit:4.12'
}</pre></div><p>This configuration will download the <code class="literal">junit-4.12.jar</code> from the Maven repository and the JAR file will be added to the classpath during the compilation and execution phase.</p><div class="section" title="Test configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Test configuration</h3></div></div></div><p>There are different configuration <a id="id373" class="indexterm"/>parameters that can be set for test configuration, which<a id="id374" class="indexterm"/> help to optimize the resources and customize the behavior based on project requirements.</p><p>Sometimes, the test directory structure does not follow the default convention, that is, <code class="literal">src/test/java</code>. In a similar way to the source code directory configuration, you can configure the new test code location<a id="id375" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">sourceSets {
  test {
    java {
      srcDir 'testSrc'
    }
  }
}</pre></div><div class="section" title="maxParallelForks"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec01"/>maxParallelForks</h4></div></div></div><p>Gradle executes the test cases in a separate JVM. By default, Gradle executes all the tests in a single process. You can <a id="id376" class="indexterm"/>specify the number of parallel processes by configuring the <code class="literal">maxParallelForks</code> property in the <code class="literal">test</code> closure. Its default value is one:</p><div class="informalexample"><pre class="programlisting">test {
maxParallelForks = 3
}</pre></div><p>To understand how it works exactly, we can modify our previous example. Just create multiple copies of the test class in <code class="literal">src/test/java</code>. In our example, in the <code class="literal">TestUsingJunitParallel</code> project, we have created a total of five copies of the same <code class="literal">LoginTest</code> class as <code class="literal">LoginTest1</code>, <code class="literal">LoginTest2</code>, and so on. Now, execute the Gradle command with the <code class="literal">--info</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>TestUsingJunitParallel$ gradle clean --info test | grep 'Test Executor'</strong></span>
<span class="strong"><strong>. . . .</strong></span>
<span class="strong"><strong>. . . .</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 2'</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 1'</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 3'</strong></span>
<span class="strong"><strong>Gradle Test Executor 2 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 3 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 1 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 3 finished executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 2 finished executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 1 finished executing tests.</strong></span>
</pre></div><p>The command-line output shows that three processes were created by Gradle and all the test cases were executed in<a id="id377" class="indexterm"/> those processes.</p></div><div class="section" title="The forkEvery option"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec02"/>The forkEvery option</h4></div></div></div><p>This option allows setting the number of test classes per process. The default value is <code class="literal">0</code>, that is, unlimited. If you set this option to a nonzero value, then a process will be created when this limit is<a id="id378" class="indexterm"/> reached.</p><p>In the previous example, we have five test classes and we have set the parallel process count to three. Now, we will set the <code class="literal">forkEvery</code> option to <code class="literal">1</code>, so every process will execute only one test class:</p><div class="informalexample"><pre class="programlisting">test {
  ignoreFailures = true
  maxParallelForks = 3
  forkEvery = 1
}</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>TestUsingJunitParallel$ gradle clean --info test | grep 'Test Executor'</strong></span>
<span class="strong"><strong>. . . .</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 1'</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 3'</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 2'</strong></span>
<span class="strong"><strong>Gradle Test Executor 1 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 2 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 3 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 1 finished executing tests.</strong></span>
<span class="strong"><strong>Starting process 'Gradle Test Executor 4'. Working directory:</strong></span>
<span class="strong"><strong>. . . .</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 4'</strong></span>
<span class="strong"><strong>Gradle Test Executor 3 finished executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 2 finished executing tests.</strong></span>
<span class="strong"><strong>Starting process 'Gradle Test Executor 5'. Working directory:</strong></span>
<span class="strong"><strong>. . . .</strong></span>
<span class="strong"><strong>Successfully started process 'Gradle Test Executor 5'</strong></span>
<span class="strong"><strong>Gradle Test Executor 4 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 5 started executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 4 finished executing tests.</strong></span>
<span class="strong"><strong>Gradle Test Executor 5 finished executing tests.</strong></span>
</pre></div><p>From the output, we can observe that Gradle first created three processes, which executed three test classes. Then, other two <a id="id379" class="indexterm"/>processes, for example, <code class="literal">'Gradle Test Executor 4'</code> and <code class="literal">'Gradle Test Executor 5'</code>, were created to execute another two test files.</p></div><div class="section" title="ignoreFailures"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec03"/>ignoreFailures</h4></div></div></div><p>Whenever any of the test cases <a id="id380" class="indexterm"/>fails, the build is marked as <code class="literal">FAILED</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle test</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>:test</strong></span>

<span class="strong"><strong>ch6.login.LoginTest &gt; testLogin1 FAILED</strong></span>
<span class="strong"><strong>  java.lang.AssertionError at LoginTest.java:26</strong></span>

<span class="strong"><strong>4 tests completed, 1 failed</strong></span>
<span class="strong"><strong>:test FAILED</strong></span>

<span class="strong"><strong>FAILURE: Build failed with an exception.</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>BUILD FAILED</strong></span>
</pre></div><p>If you want the build to succeed irrespective of the test case outcome, you can add <code class="literal">ignoreFailures=true</code> in the build script <code class="literal">test</code> closure, as shown in the previous example. Its default value is <code class="literal">false</code>. On executing the test task again, the build will be successful as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle test</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>ch6.login.LoginTest &gt; testLogin1 FAILED</strong></span>
<span class="strong"><strong>  java.lang.AssertionError at LoginTest.java:26</strong></span>

<span class="strong"><strong>4 tests completed, 1 failed</strong></span>
<span class="strong"><strong>. . .</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div></div><div class="section" title="filter"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec04"/>filter</h4></div></div></div><p>Gradle allows you a<a id="id381" class="indexterm"/> selective execution of test cases by filtering them based on different patterns. Suppose we have two test packages with four test cases.</p><p>
<code class="literal">/src/test/java/ch6/login/LoginTest.java</code> contains 2 test packages as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testUserLogin1()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">testUserLogin2()</code></li></ul></div><p>
<code class="literal">/src/test/java/ch6/profile/ProfileTest.java</code> contains 2 test packages as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testUserProfile1()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">testUserProfile2()</code></li></ul></div><p>The following code snippet shows how to apply a filter based on different patterns:</p><div class="informalexample"><pre class="programlisting">test {
  filter {
    // 1: execute only login test cases
    includeTestsMatching "ch6.login.*"

    //2: include all test cases matching *Test
    includeTestsMatching "*Test"

    //3: include all integration tests having 1 in their name
    includeTestsMatching "*1"

    //4: Other way to include/exclude packages
    include "ch6/profile/**"
  }
}</pre></div><p>The first filter will identify only two test cases from the <code class="literal">ch6.login</code> package. The second filter selects all four test cases, as test class names are matching the <code class="literal">*Test</code> pattern. The third statement finally filters only two test cases: <code class="literal">testUserLogin1()</code> and <code class="literal">testUserProfile1()</code>.</p><p>Just comment the first two patterns and execute the test with filter pattern <code class="literal">*1</code>. Although we have a total of four test cases, you will find that Gradle executes one test case from each package. You can also include or exclude packages by using <code class="literal">include</code> or <code class="literal">exclude</code> with the package structure mentioned in the preceding example. If you only want to execute a single test class, you can also execute it by appending test classes to the command-line option <code class="literal">--tests</code>. Command <code class="literal">gradle  tests --tests ch6.login.LoginTest</code> will execute only<a id="id382" class="indexterm"/> the test case mentioned in the <code class="literal">LoginTest</code> class:</p><div class="mediaobject"><img src="graphics/B02000_06_08.jpg" alt="filter"/><div class="caption"><p>Figure 6.8</p></div></div></div></div></div><div class="section" title="TestNG"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>TestNG</h2></div></div></div><p>Gradle also<a id="id383" class="indexterm"/> provides integration with the TestNG framework. To write test cases in TestNG, you need to <a id="id384" class="indexterm"/>add the dependency in the <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">dependencies {
  testCompile 'org.testng:testng:6.8.21'
}</pre></div><p>In our example, we have created a TestNG test class with three test cases. Now, by executing the test task, we get the report file created under <code class="literal">build/reports/tests</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle clean test</strong></span>
</pre></div><p>Now, open the <code class="literal">index.html</code> file and you will see the following output:</p><div class="mediaobject"><img src="graphics/B02000_06_09.jpg" alt="TestNG"/><div class="caption"><p>Figure 6.9</p></div></div><p>The look and feel of the report is similar to the JUnit that we saw earlier. Actually, JUnit and TestNG on their own generate completely different report formats, but Gradle reconciles them into <a id="id385" class="indexterm"/>a standard look and feel.</p><p>As explained in the<a id="id386" class="indexterm"/> <span class="emphasis"><em>JUnit</em></span> section, you can also define other properties in the <code class="literal">test</code> closure such as <code class="literal">ignoreFailures</code>, <code class="literal">maxParallelForks</code>, and so on.</p><div class="informalexample"><pre class="programlisting">test{
  useTestNG()
  ignoreFailures = true
  maxParallelForks = 2
  forkEvery = 1
}</pre></div><div class="section" title="Execution based on group"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Execution based on group</h3></div></div></div><p>In the preceding<a id="id387" class="indexterm"/> <code class="literal">test</code> closure, we have used the <code class="literal">useTestNG</code> option to enable <code class="literal">TestNG</code> support. You can also set other options such as groups and listeners in this closure. For example, the following setting only executes test cases with the group name <code class="literal">Smoke</code> and it creates an additional emailable <code class="literal">TestNG</code> report in the <code class="literal">reports/tests</code> folder:</p><div class="informalexample"><pre class="programlisting">useTestNG(){
  includeGroups 'Smoke'
  listeners &lt;&lt; 'org.testng.reporters.EmailableReporter'
}</pre></div><p>In <code class="literal">useTestNG</code>, you can group test cases based on the group attribute to the <code class="literal">@Test</code> annotation:</p><div class="informalexample"><pre class="programlisting">@Test(groups = "&lt;group name&gt;")</pre></div><p>In our example, we have grouped the test cases as <code class="literal">Smoke</code> and <code class="literal">Integration</code>. On executing the <code class="literal">test</code> task, only the <code class="literal">verifyArraySize</code> and <code class="literal">verifyArrayNotNull</code> test cases will be <a id="id388" class="indexterm"/>executed:</p><div class="informalexample"><pre class="programlisting">@Test(groups = "Smoke")
public void verifyArraySize()

@Test(groups = "Smoke")
public void verifyArrayNotNull()

@Test(groups = "Integration")
public void verifyArrayPosition()</pre></div></div><div class="section" title="Execution based on the TestNG suite file"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Execution based on the TestNG suite file</h3></div></div></div><p>TestNG suite files provide <a id="id389" class="indexterm"/>better control to execute tests. In a test suite file, you can define all the test classes and methods that will be included to execute the test case, any filter based on group name, listener information, and so on.</p><p>We have created a <code class="literal">testng.xml</code> file in the <code class="literal">src/test/resource</code> folder. The file has three key pieces of information; the <code class="literal">listener</code> configuration to create an emailable report format, included the test group as <code class="literal">Smoke</code> and added the <code class="literal">ArrayTest</code> file as a test class. Using the test suite file, you can also configure other properties such as thread pool size, whether test classes or test methods will run in parallel, and many more:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;
&lt;suite name="Suite1" verbose="1" &gt;
  &lt;listeners&gt;
    &lt;listener class-name="org.testng.reporters.EmailableReporter" /&gt;
  &lt;/listeners&gt;
  &lt;test name="Smoke Test"&gt;
    &lt;groups&gt;
      &lt;run&gt;
        &lt;exclude name="Integration" /&gt;
        &lt;include name="Smoke" /&gt;
      &lt;/run&gt;
    &lt;/groups&gt;

    &lt;classes&gt;
      &lt;class name="ch6.testng.example.ArrayTest"&gt;
      &lt;/class&gt;
    &lt;/classes&gt;
  &lt;/test&gt;
&lt;/suite&gt;</pre></div><p>This suite file can be included in the <code class="literal">test</code> closure as follows. Then, on executing the test task, reports will<a id="id390" class="indexterm"/> be created in the <code class="literal">reports/tests</code> folder:</p><div class="informalexample"><pre class="programlisting">test {
ignoreFailures = true
  useTestNG(){
    suites("src/test/resources/testng.xml")
  }
}</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, we have explored different topics of Gradle such as I/O operations, logging, Multi-Project build and testing using Gradle. We also learned how easy it is to generate assets for web applications and Scala projects with Gradle. In the <span class="emphasis"><em>Testing with Gradle</em></span> section, we learned some basics to execute tests with JUnit and TestNG.</p><p>In the next chapter, we will learn the code quality aspects of a Java project. We will analyze a few Gradle plugins such as Checkstyle and Sonar. Apart from learning these plugins, we will discuss another topic called Continuous Integration. These two topics will be combined and presented by exploration of two different continuous integration servers, namely Jenkins and TeamCity.</p></div></body></html>