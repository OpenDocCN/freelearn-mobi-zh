- en: Chapter 4. Exploring the Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we familiarized ourselves with the simplest and high
    level, Android-specific, asynchronous construct; the `android.os.AsyncTask`. The
    `AsyncTask` is a lean construct used to create background work that offers a simple
    interface to publish results and send progress to the main thread. In this chapter
    we are going to move our focus to `android.content.Loader`, a high level Android-specific
    pattern used to load content asynchronously from content providers or data sources
    over a worker thread with content change capabilities and component lifecycle
    awareness.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data with Loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building responsive apps with AsyncTaskLoader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building responsive apps with CursorLoader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, the job of `Loader` is to load data on behalf of other
    parts of the application, and to make that data available across activities and
    fragments within the same process. The Loaders framework was created to solve
    a couple of issues related to asynchronous loading in Activities and Fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background processing**: The heavy lifting is automatically performed on
    a background thread, and the results are safely introduced to the main thread
    on completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result caching**: Loaded data can be cached and redelivered on repeat calls
    for speed and efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifecycle awareness**: The framework gives us control over when a Loader
    instance is destroyed, and allows Loaders to live outside the `Activity` lifecycle,
    making their data available across the application and across `Activity` restarts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data change management**: Loaders monitor their underlying data source, and
    reload their data in the background when necessary. The framework includes lifecycle
    callbacks that allow us to properly dispose of any expensive resources held by
    our Loaders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Loader` API was introduced to the Android platform at API level 11, but
    are available for backwards compatibility through the support libraries. The examples
    in this chapter use the support library to target API levels 7 through 23.
  prefs: []
  type: TYPE_NORMAL
- en: The framework defines interfaces, abstract classes, and loader implementations
    to create first class Android data loaders for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Loaders are able to monitor the content and deliver new changes, and will
    survive across an Activity transition or across a replaced Activity triggered
    by a configuration change. The API classes and interfaces delivered by this framework
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.content.Loader<DataType>`: Nonfunctional (abstract) base class that
    defines the base methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.app.LoaderManager`: Manages loaders in Activities and Fragments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.app.LoaderManager.LoaderCallbacks`: Callbacks used to listen for Loader
    events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.content.AsyncTaskLoader<DataType>`: `Loader` subclass that executes
    the loading over an `AsyncTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.content.CursorLoader`: Loader implementation used to deal with Android
    internal databases and content providers'' data sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two classes are non-abstract subclasses that we will go into detail
    with examples in the next sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Loader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Loader` is a generic type class that, by itself, does not implement any asynchronous
    behavior and exposes one generic type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `<DataType>` generic type defines the result type that your `Loader` is
    going to deliver and should be defined by any subclass that implements a domain
    specific `Loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create your own loader there are five methods of `Loader` which we
    must implement to create a fully functional Loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `onStartLoading()` method is the method that subclass must implement to
    start loading data, the `onStopLoading()` is a method used to implement behavior
    when a loader stop was requested because the activity or fragment associated is
    stopped. At this state, the `Loader` may carry on processing but shouldn't deliver
    updates to the `Activity` until `onStartLoading()` is invoked again.
  prefs: []
  type: TYPE_NORMAL
- en: The `onForceLoad()` is a method that you should implement to ignore a previously
    loaded data set and load a new one, like clearing a cache, and the `onReset()`
    method is a method called for you automatically by LoaderManager to free any loader's
    resources if your loader is not invoked again.
  prefs: []
  type: TYPE_NORMAL
- en: The `onCancelLoad()` is a method invoked on the main thread used to implement
    behavior when the load is canceled after invoking the `Loader.cancelLoad()`.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can extend `Loader` directly, it is more common to use one of the
    two provided subclasses, `AsyncTaskLoader` or `CursorLoader`, depending on our
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTaskLoader` is a general-purpose `Loader`, which we can subclass when
    we want to load just about any kind of data from just about any kind of source,
    and do so off the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CursorLoader` extends `AsyncTaskLoader`, specializing it to efficiently source
    data from a local database and manage the associated database `Cursor` correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Loader Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use Loaders, we will not do so in isolation, because they form part
    of a small framework. Loaders are managed objects, and are looked after by a `LoaderManager`,
    which takes care of coordinating Loader lifecycle events with the `Fragment` and
    `Activity` lifecycles, and makes the `Loader` instances available to the client
    code throughout an application. The `LoaderManager` abstract class defined in
    `android.support.v4.content.LoaderManager` and `android.app.LoaderManager` is
    accessible in all the Activities and Fragments through the member function `getLoaderManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The LoaderManager provides an API that could be used by the client (Activity
    or Fragment) to set up, initialize, restart, and destroy loaders without being
    bound to the client lifecycle. The Loader Manager''s most relevant methods that
    are accessible when you retrieve the client-managed LoaderManager instance are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `id` argument in all the methods defined by the `LoaderManager` identifies
    the Loader on the client context, and moreover, is used in all the `LoaderManager`
    APIs to trigger any action in a specific Loader.
  prefs: []
  type: TYPE_NORMAL
- en: The `initLoader` method is used to initialize a certain loader but it does not
    create a new Loader if a Loader with the same ID already exists on the `LoaderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: The `restartLoader` method starts or restarts a loader, however if a Loader
    associated with the ID passed in already exists, the old loader will be destroyed
    when it completes its work.
  prefs: []
  type: TYPE_NORMAL
- en: The `destroyLoader` method stops and removes the `Loader` with the ID specified
    by the argument `id` explicitly from the `LoaderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: LoaderManager.LoaderCallbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To interact with the `LoaderManager`, the client needs to implement the `LoaderCallbacks<D>`
    interface and receive events to create a new `Loader` for a given ID, to receive
    the Loader results, or reset a Loader respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we detailed before, the `D` generic type specifies the data type that
    the Loader returns and these callbacks are called by the LoaderManager when a
    particular state is reached on the Loader lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreateLoader`: This is a creational method that bootstraps a Loader for
    a specified ID and with a given Bundle object. The Bundle object is used to pass
    arguments for the Loader creation. This method gets invoked when the client calls
    `initLoader` and no Loader with that ID exists on LoaderManager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadFinished`: This is the method called when the Loader gets its results;
    the callback is called with the results and with a reference for the loader that
    retrieved the result. When the Loader detects a content change on the data requested
    it will report back the new results, therefore this method could be called several
    times. This method is typically used to update the UI with the loaded data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoaderReset`: This is the method invoked when the Loader for a given ID
    is going to be destroyed. This is the best place to release some resources and
    references attached to one specified ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any Loader object managed by a `LoaderManager` can be in six different flags
    that defines the Loader state:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reset**: This is the flag that sets your loader when you create a Loaders
    instance. The flag would end up here if the `reset()` method is invoked. The `onReset()`
    is called when the reset is moving to this state, and the developer must use this
    method to release the resources allocated on the Loader and to reset any cache
    result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Started**: This is the flag set when your loader `startLoading()` is invoked.
    After your loader enters into this state, the `onStartLoading` method gets invoked
    to setup your loading resources. If the Loader has already delivered results you
    can call the `forceLoad()` to restart a new loading. Your loader should only deliver
    results when this flag is on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopped**: This is the flag set when the loader is stopped and is not able
    to deliver new results or delivery of content changes. In this state, the loader
    could store results to deliver when the loader is restarted. To implement behavior
    when the loader has this on, the developer must implement the `onStopLoading`
    and release any resources allocated to load the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abandoned**: This is an optional intermediate flag used to pinpoint whether
    the `Loader` was abandoned. Like the other methods, subclasses must implement
    the `onAbandon()` to implement behavior when the client is no longer interested
    in new data updates from the loader. At this state, prior to Reset, the Loader
    must not report any fresh updates but it can keep results to deliver when the
    loader is restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ContentChanged**: This is a flag used to notify that the Loader content has
    changed. The `onContentChanged` is callback invoked when a content change is detected
    on the Load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProcessingChange**: This is a flag used to notify that the Loader content
    is processing a change on its content. The following functions `takeContentChanged()`,
    `commitContentChanged()`, and `rollbackContentChanged()` are used to manage the
    data content changes and its processing state.![Loader lifecycle](img/Image_B05062_04_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 4.1: Loader Lifecycle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Loading data with Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only described theoretical entities and the classes available
    on the API so now is the right time to show these concepts with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: In our example we will show you how to use `LoaderManager`, `LoaderCallback`,
    and a `Loader` to present an `Activity` that lists the name of users that are
    currently online for a chat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create an Activity that will act as a client to the
    `LoaderManager` and will have three buttons, **INIT**, **RESTART**, and **DESTROY**;
    to initialize the loader, to restart, and to destroy the loader respectively.
    The Activity will receive the `LoaderCallbacks` callback directly since it implements
    that interface as member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Clicking on the **INIT** button will initialize the `Loader` with the ID specified
    and with a bundle object that we use to pass arguments to the `Loader`, and as
    said before the **RESTART** button will destroy a previous loader if it already
    exists and create a new one and the **DESTROY** button will destroy the loader
    with the given ID if it already exists in the `LoaderManager`. These buttons are
    used here only to help us to explain the interaction and flow between the `LoaderManager`
    and the `Loader`s.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific use case we are going to load the list of online users for
    the chat room developers.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at the `LoaderCallback` functions and implement the interface
    on our `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with `onCreateLoader`, this `LoaderCallback` callback gets called only
    if the loader does not previously exist or when the loader is restarted by calling
    `LoaderManager.restartLoader()`.
  prefs: []
  type: TYPE_NORMAL
- en: When we initialize `WhosOnlineLoader` via the `LoaderManager` `initLoader` method,
    it will either return an existing Loader with the given ID (`LOADER_ID`) or, if
    it doesn't yet have a `Loader` with that ID, it will invoke the first of the `LoaderCallbacks`
    methods—`onCreateLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: This means this method will not be called on for a configuration change because
    a previous loader with this ID is already available and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method creates the Loader instance calling the `WhosOnlineLoader` constructor
    and passing the chat group name that we are trying to load.
  prefs: []
  type: TYPE_NORMAL
- en: The next `LoaderCallback` function callback implemented is `onLoadFinished`;
    this callback gets called when the loader gets new results, when the data changes,
    or could be called when a configuration changes a `Loader` that already exists
    in the `LoaderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our example, when the `onLoadFinished` gets called, we update the `ListView`
    adapter with the list of users received from the loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnLoaderReset`, our last `LoaderCallback` function callback, gets called
    when the loader is destroyed, and in our example it simply cleans up the list
    view data in its adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The loader reset is called when the `LoaderManager.destroyLoader(id)` is called
    or when the `Activity` gets destroyed. The Loader reset, as described earlier,
    will not destroy the loader but tell the Loader not to publish further updates.
    Hence, it can span multiple Activities.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of this cake is our custom Loader, the `WhosOnlineLoader`, used
    to retrieve the list of online users. Our `WhosOnlineLoader` is not going to load
    any asynchronous results, since a `Loader` subclass does not manage a background
    thread to load the results. Hence, this Loader should only be used for example
    purposes and to explain the `LoaderManager` and custom Loader interaction idiosyncrasies.
  prefs: []
  type: TYPE_NORMAL
- en: For debugging purposes, the methods `onStartLoading`, `onStopLoading`, `onReset`,
    and `onForceLoad` have a log message printed every time they enter on a function.
    The `deliverResult()`, the Loader function that delivers the result of the load
    to the registered listener, will also print a message to the Android Log with
    the users online.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `WhosOnlineLoader` code is partially omitted on purpose, although the `WhosOnlineLoader`
    source code is available to download from the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With everything in place, if we start the Activity, the user online list will
    be empty, although clicking on the **INIT** button will result in a `LoaderManager.init`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have some trace messages at the beginning of each `Loader` lifecycle,
    we can follow the loader callback calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the log output, a new `Loader` object instance with the `hashCode`
    `ee07113` is created when we invoke the `LoaderManager.init` function and the
    `onCreateLoader` gets called in the meantime. Afterwards, the loader is started
    and the results are loaded on the `onLoadFinished` callback, delivering the list
    of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `Loader` with the ID now exists on the `LoaderManager`, lets check
    what happens when we click on the **restart** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Loader ee07113` was created previously, it will be stopped and reset,
    and a new loader instance will be created and started like it did on the `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to click on the **DESTROY** button and check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `LoaderManager.destroy` gets called, and after that the `onAbandon`,
    `onReset`, and the `onStopping Loader` member methods were called to stop delivering
    results, release the loader resources, and to stop loading data. When the Loader
    is stopped we must cancel any loading but it can still monitor the data source
    for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another situation that is really important to explain is the configuration change.
    In this situation, the `LoaderManager` will continue to receive the results and
    keep them in a local cache. Once the new activity becomes visible, the cache results
    are delivered over the method `LoaderCallbacks.onLoadFinished`.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical `Activity` transition where there is no configuration change involved,
    `LoaderManager` automatically resets the `Loader` resulting in calls to the loader
    stop and reset functions.
  prefs: []
  type: TYPE_NORMAL
- en: Given that now we understand how to use the `LoaderManager` to manage the loaders
    in activities, now we can focus our attention on how to use the subclasses `AsyncTaskLoader`
    and `LoaderCursor` to create asynchronous Loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Building responsive apps with AsyncTaskLoader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AsyncTaskLoader` is a Loader implementation that uses `AsyncTasks` to perform
    its background work, though this is largely hidden from us when we implement our
    own subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to trouble ourselves with the `AsyncTasks`—they are completely
    hidden by `AsyncTaskLoader`—but with what we learned earlier about `AsyncTask`,
    it is interesting to note that tasks are, by default, executed using `AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)`
    to ensure a high degree of concurrency when multiple Loaders are in use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AsyncTaskLoader` in the compatibility package (`android.support.v4.content`)
    does not rely on the public `AsyncTask` in the platform. Instead, the compatibility
    package uses an internal `ModernAsyncTask` implementation to avoid Android fragmentation.
    The `ModernAsyncTask` creates threads with the name `ModernAsyncTask #<N>`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will use `AsyncTaskLoader` to load in the background,
    a currency to Bitcoin exchange rate, and display an updated exchange rate in our
    `BitcoinExchangeRateActivity` making use of the `LoaderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: The exchange rate will be refreshed continuously using the `onContentChanged()`
    Loader method, used in this case to force a new exchange rate update in background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader is generically typed so when we implement it, we need to specify the
    type of object that it will load—in our case `Double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Loader abstract class requires a Context passed to its constructor, so
    we must pass a Context up the chain. We''ll also need to know which currency exchange
    rate to retrieve, and the refresh time interval, so we''ll also pass a string
    to identify the currency and an integer for the interval (milliseconds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to keep our own reference to the `Context` object—`Loader` exposes
    a `getContext()` method which we can call from anywhere in our class where we
    might need a Context.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can safely pass a reference to an Activity instance as the Context parameter,
    but we should not expect `getContext()` to return the same object! Loaders potentially
    live much longer than a single Activity, so the Loader superclass only keeps a
    reference to the application Context, a context tied to an application, to prevent
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several methods we will need to override which we''ll work through
    one at a time. The most important is `loadInBackground`—the workhorse of our `AsyncTaskLoader`,
    and the only method which does not run on the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `AsyncTaskLoader` is a Loader subclass based on `AsyncTask`. Under the hood,
    it calls the `loadInBackground` function in an AsyncTask's background thread.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to fetch the real-time bitcoin exchange rate from Internet, more
    precisely from the blockchain.info website, to delays to establish the connection,
    to transmit the data between the device and the remote endpoint and to some latency
    exposed by the access network. Since the delays can range from milliseconds to
    seconds, this task is a good candidate to perform off the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram displays the `Loader` lifecycle, showing callbacks invoked
    by `LoaderManager` and a typical `AsyncTaskLoader` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building responsive apps with AsyncTaskLoader](img/Image_B05062_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Given that loading the exchange rate from the network entails some delay due
    to blocking I/O reading from the network, and it is also possible that the remote
    website does not yet have enough resources to send the response back, we, as conscious
    developers who don't want to generate annoying Android ANRs, have to transfer
    these kinds of operations to the `AsyncTaskLoader.loadInBackground` method that
    is executed by the background thread in the system.
  prefs: []
  type: TYPE_NORMAL
- en: After we receive the response with the exchange rate, we need to decode the
    JSON response that comes in the HTTP response so this is also an operation we
    definitely want to perform off the main thread!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we execute the blocking operations suggested previously
    and as a result we return the exchange rate for the currency specified in the
    `Loader` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to cache a reference to the Double object that we''re delivering,
    so that any future calls can just return the same Double immediately. We''ll do
    this by overriding `deliverResult` invoked on the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `Loader` actually work, we still need to override a handful of
    lifecycle methods that are defined by the `Loader` base class. First and foremost
    is `onStartLoading`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check our cache (`mExchangeRate`) to see if we have a previously loaded
    result that we can deliver immediately via `deliverResult`. If the content data
    has changed recently, `contentChanged` flag is true, and we don't have a cached
    result, we force a background load to occur—we must do this otherwise our Loader
    won't ever load anything. As described before this callback runs on the main thread
    and the load will fire off a new load throughout `loadInBackground()` on the background
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a minimal working `Loader` implementation, but there is some housekeeping
    required if we want our `Loader` to play well with the framework.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to make sure that we clean up the exchange rate when our
    `Loader` is discarded. Loader provides a callback intended for that exact purpose—`onReset`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The framework will ensure that `onReset` is called when `Loader` is being discarded,
    which will happen when the app exits or when the `Loader` instance is explicitly
    discarded via `LoaderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more lifecycle methods, which are important to implement correctly
    if we want our app to be as responsive as possible: `onStopLoading` and `onCanceled`
    (be careful of the spelling of `onCanceled` here versus `onCancelled` in most
    places).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework will tell us when it doesn''t want us to waste cycles loading
    data by invoking the `onStopLoading` callback. It may still need the data we have
    already loaded though, and it may tell us to start loading again, so we should
    not clean up resources yet. In `AsyncTaskLoader` we''ll want to cancel the background
    work if possible, so we''ll just call the superclass `cancelLoad` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When the `Loader` is cancelled we don't stop the current rate loading; in spite
    of this, in other kinds of use cases, we might have a cancelling behavior on the
    `loadInBackground()` to stop the current loading by checking the `isAbandoned()`
    member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to implement `onCancelled` to clean up any data that might
    be loaded in the background after a cancellation has been issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the kind of data Loader produces, we may not need to worry about
    cleaning up the result of canceled work—ordinary Java objects will be cleaned
    up by the garbage collector when they are no longer referenced.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have implemented the asynchronous exchange rate loading, now we have
    to implement the refresh feature to continuously fetch the value from the blockchain.info
    website. To load a new value for the current exchange rate we shall coerce the
    loader to run the `loadInBackground` again and retrieve the current value for
    the exchange rate. The `Loader` abstract class offers us the method `onContentChanged()`,
    that will force a new load if the `Loader` is at the started state.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, once the loader is started with `startLoading()`, we must continuously
    call `onContentChanged` to mimic a value change and force a new load. We will
    achieve this by using a handler and by posting a `Runnable` that simply calls
    the `onContentChange` on our `Loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we are going to create the `Runnable` and create the handler in our loader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, we need to submit a delayed task to force the next reload, each time
    the `forceLoad()` is called. When the `Loader` is reset we don''t submit the next
    reload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Third, to force a new reload when the loader is cancelled and the task is restarted
    afterwards, `onCanceled()` sets the `ContentChange` flag on by calling `onContentChanged()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish, we must cancel the next reload if the loader is stopped or cancelled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far so good—we have a `Loader`. Now we need to connect it to a client Activity
    or Fragment. Since in our previous example we attached our Loader to an Activity,
    this time we are going to use a different `LoaderManager` client and connect the
    loader to a Fragment object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Fragment`, loaded by `BitcoinExchangeRateActivity`, is going to initialize
    our Loader and display the loader result on the fragment UI. Let''s get these
    easy bits out of the way first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we mainly load the UI layout used to present the exchange
    rate on the screen and we implement our loader initialization on the `onActivityCreated`
    member function. The `onActivityCreated` member class callback is either called
    when the activity has been created or when the `Activity` is recreated, after
    a configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: As we explained in previous sections, we call the `initLoader` passing an `int`
    identifier as the first argument, a Bundle of values—the second parameter—to configure
    the currency exchange rate that we want present on the screen, and a refresh rate
    interval between `onContextChange` calls. The third parameter is an object that
    implements `LoaderCallbacks`, which, in this case, is our `BitcoinExchangeRateFragment`
    instance, where we implement the loader callbacks directly on the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The `onCreateLoader` callback method that we implement on our Fragment is similar
    to the method that we create on the previous `WhoIsOnlineActivity` Loader, so
    it basically creates a new `BitcoinExchangeRateLoader` instance using the arguments
    passed on to the `Bundle` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `onLoadFdinished` must take the loaded exchange rate
    and display it in the `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we omitted the `LoaderCallbacks.onLoaderReset` since the method
    body is empty. This method should be used to release any resources used that are
    directly bound to the Loader lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code, with the Activity and `android.xml` layout is available
    on the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: When compared with `AsyncTask`, things here are more complicated—we've had to
    write more code and deal with more classes, but the payoff is that the data is
    cached for use across `Activity` restarts and can be used from other Fragments
    or Activities.
  prefs: []
  type: TYPE_NORMAL
- en: In our `BitcoinExchangeRateLoader`, the successive exchange rate updates are
    controlled by our refresh rate internal; however, in other kinds of `AsyncTaskLoaders`
    the rate where a content change happens could result in lots of `onLoadFinished`
    invocations, and hence potentially dominate the UI thread execution with UI updates
    and degrade the UI responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, the `AsyncTaskLoader` supplies a member function, called
    `setUpdateThrottle`, to control the minimum internal between successive data deliveries
    and as a result adjusts the interval between consecutive `onLoadFinished` invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This method must be called when you feel that your loader content change-rate
    might overload the UI and affect your application smoothness. If a higher update
    frequency is not required in your data, the developer can make use of this function
    to reduce the Loader content change deliver frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will get a detailed overview on the last Loader subclass
    type that comes out of box with Android SDK, the `CursorLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Building responsive apps with CursorLoader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CursorLoader` is a specialized subclass of `AsyncTaskLoader` that uses its
    lifecycle methods to correctly manage the resources associated with a database
    `Cursor`.'
  prefs: []
  type: TYPE_NORMAL
- en: A database `Cursor` is a little like an Iterator, in that it allows you to scroll
    through a dataset without having to worry where exactly the dataset is coming
    from or what data structure it is a part of.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use `CursorLoader` to query the Android device for a list of
    music albums available. Because `CursorLoader` is already implemented to correctly
    handle all of the details of working with a `Cursor`, we don''t need to subclass
    it. We can simply instantiate it, passing in the information it needs in order
    to open the `Cursor` it should manage for us. We can do this in the `onCreateLoader`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the previous example, we''ll implement the callbacks in our `Activity`
    subclass. We''re going to use `GridView` to display our album list, so we''ll
    implement an `Adapter` interface to supply views for its cells, and we''ll connect
    the `Adapter` to the `Cursor` created by our `Loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the parts in bold in the preceding code. We create an `AlbumCursorAdapter`,
    and pass it to the `GridView`, we then initialize our `CursorLoader`. When loading
    is completed, we pass the loaded Cursor to the Adapter, and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining piece to implement is `AlbumCursorAdapter`, which is going to
    start out as a very simple class. The job of our `CursorAdapter` is simply to
    map rows of data from the `Cursor` to each `View` in the individual row `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android SDK provides the very handy `SimpleCursorAdapter` class, which
    does just what we need; mapping a database data row into an Album Item View. So
    for now we''ll just subclass it and instruct it via constructor parameters which
    layout the inflation for each cell and the `Cursor` fields to map to each `View`
    within that layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The layout files and source code are available on the accompanying website.
    When you run this `Activity`, you'll see a grid list where each cell contains
    album artwork, the album artist, and the album name for each album.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll to somewhere in the middle of the list and rotate your device, and you'll
    notice that the Activity restarts and redisplays the grid immediately, without
    losing its place—this is because the `CursorLoader` survived the restart, and
    still holds the `Cursor` object with the same rows loaded.
  prefs: []
  type: TYPE_NORMAL
- en: This is technically all very interesting, but it isn't much to look at. In the
    next section we'll combine our two `Loaders` to implement a scrollable grid displaying
    the album art for each album.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections we developed a `CursorLoader` that loads a list of
    all available music albums on the system and an `AsynTaskLoader` that does a blocking
    IO operation in the background. Now we are going to use our previous `CursorLoader`
    together with `AsyncTaskLoader` which loads a thumbnail from the album ID to create
    an application that tiles the artwork of all the music albums on the device in
    a scrollable grid, performing all loading in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to our `CursorLoader`, we already have access to the IDs of the albums
    we need to load—we're displaying only the album name and album artist—so we just
    need to pass those IDs to our `AlbumArtworkLoader` for it to asynchronously load
    the image for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `AlbumArtworkLoader` could receive the album ID either on the constructor
    or later, to load an image for a particular `albumId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll enable `AlbumArtworkLoader` to load a new image instead of its current
    one, by setting a new `albumId`. Since the bitmap is cached (`mData`), just setting
    a new ID won''t suffice—we also need to trigger a reload by using the `Loader.onContentChanged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `onContentChanged,` as explained before, is a method of the abstract `Loader`
    superclass which will force a background load to occur if our `Loader` is currently
    in the started state. If we're currently stopped, a flag will be set and a background
    load will be triggered next time the `Loader` is started. Either way, when the
    background load completes, `onLoadFinished` will be triggered with the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement the `onStartLoading` method to correctly handle the case
    where we were `stopped` when `onContentChanged` was invoked. Let''s remind ourselves
    of what it used to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `onStartLoading` method again delivers its data immediately—if it has any.
  prefs: []
  type: TYPE_NORMAL
- en: It then calls `takeContentChanged` to see if we need to discard our cached `Bitmap`
    and load a new one. If `takeContentChanged` returns true, we invoke `forceLoad`
    to trigger a background load and redelivery.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can cause our `AlbumArtworkLoader` to load and cache a different image,
    but a single `AlbumArtworkLoader` can only load and cache one image at a time,
    so we're going to need more than one active instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the process of modifying `AlbumCursorAdapter` to initialize
    a `AlbumCursorAdapter` for each cell in the `GridView`, and to use those `Loader`s
    to asynchronously load the album artwork and display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have two methods to implement—`newView` and `bindView. GridView` will invoke
    `newView` until it has enough View objects to fill all of its visible cells, and
    from then on it will recycle these same View objects by passing them to `bindView`
    to be repopulated with data for a different cell as the grid scrolls. As a view
    scrolls out of sight, it becomes available for rebinding.
  prefs: []
  type: TYPE_NORMAL
- en: What this means for us is that we have a convenient method in which to initialize
    our `AlbumArtworkLoaders`—`newView`, and another convenient method in which to
    retask Loader to load a new thumbnail—`bindView`.
  prefs: []
  type: TYPE_NORMAL
- en: '`newView` first inflates the album item layout for the row and gives to the
    parent view, a unique ID based on the ID generated by the adapter class `hashcode()`
    method and based on the current number of Loaders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, the unique ID and the `imageView` is passed to a `ArtworkLoaderCallbacks`
    class, which we''ll meet in a moment. `ArtworkLoaderCallbacks` is in turn used
    to initialize a new `Loader`, which shares the ID of the parent View. In this
    way we are initializing a new Loader for each visible row in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In `bindView`, we are recycling each existing `View` to update the image, album
    name, and album artist that are being displayed by that `View`. So the first thing
    we do is clear out the old `Bitmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we look up the correct `Loader` by ID, extract the ID of the next image
    to load from the `Cursor`, and load it by passing the ID to the method of `AlbumArtworkLoader`—`setAlbumId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add one more method to our `Adapter` so that we can clean up `AlbumArtworkLoaders`
    when we no longer need them. We''ll call these ourselves when we no longer need
    these `Loaders`—for example, when our `Activity` is finishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s our completed `Adapter`. Next, let''s look at `ArtworkLoaderCallbacks`
    which, as you probably guessed, is just an implementation of `LoaderCallbacks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The only interesting thing `ArtworkLoaderCallbacks` does is create an instance
    of `AlbumArtworkLoader`, and set a loaded Bitmap to its `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Activity` is almost unchanged—we need to pass an extra parameter when
    instantiating `AlbumCursorAdapter` and, to avoid leaking the Loaders it creates,
    we need to invoke the `destroyLoaders` method of `AlbumCursorAdapter` in `onPause`
    or `onStop`, if the Activity is finishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The full source code is available from the Packt Publishing website. Take a
    look at the complete source code to appreciate how little there actually is, and
    run it on a device to get a feel for just how much functionality `Loaders` give
    you for relatively little effort!
  prefs: []
  type: TYPE_NORMAL
- en: Applications of Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The obvious applications include reading any kind of data from files or databases
    local to the device, or Android content providers, as we've done in the examples
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One strong advantage of `Loaders` over direct use of `AsyncTask` is that their
    lifecycle is very flexible with respect to the `Activity` and `Fragment` lifecycles.
    Without any extra effort we can handle configuration changes such as an orientation
    change.
  prefs: []
  type: TYPE_NORMAL
- en: We can even start loading in one `Activity`, navigate through the app, and collect
    the result in a completely separate `Activity`, if that makes sense for our app.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, this decoupling from the Activity lifecycle makes `Loader` a better
    candidate than `AsyncTask` to perform network transfers such as HTTP downloads;
    however, they require more code and still aren't a perfect fit.
  prefs: []
  type: TYPE_NORMAL
- en: The framework is very powerful for managing asynchronous data loading; however,
    it does not provide a mechanism to show the loading progress, as we have on the
    `AsyncTask` framework and there is no error handling callback function to manage
    loading errors or exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these issues, the developer must extend the basic Loader framework
    classes and implement these patterns to match his needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Loader` framework in Android does a wonderful job of making it easy to
    load data in the background and deliver it to the main thread when it is ready.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we learned about the essential characteristics of all Loaders—background
    loading, caching of loaded data, and a managed lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: We took a detailed look at `AsyncTaskLoader` as a means to perform arbitrary
    background loading, and `CursorLoader` for asynchronous loading from local database
    Cursors.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that `Loader` can free us from some of the constraints imposed by the
    `Activity` lifecycle, and took advantage of that to continue to work in the background
    even across `Activity` restarts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll free ourselves completely from the constraints of
    the `Activity` lifecycle and perform background operations with `Service`, even
    when our app is no longer in the foreground.
  prefs: []
  type: TYPE_NORMAL
