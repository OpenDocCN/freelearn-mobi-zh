- en: Chapter 4. Exploring the Loader
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：探索Loader
- en: In the previous chapter we familiarized ourselves with the simplest and high
    level, Android-specific, asynchronous construct; the `android.os.AsyncTask`. The
    `AsyncTask` is a lean construct used to create background work that offers a simple
    interface to publish results and send progress to the main thread. In this chapter
    we are going to move our focus to `android.content.Loader`, a high level Android-specific
    pattern used to load content asynchronously from content providers or data sources
    over a worker thread with content change capabilities and component lifecycle
    awareness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们熟悉了最简单和高级的、特定于Android的异步构造；即`android.os.AsyncTask`。`AsyncTask`是一个轻量级构造，用于创建后台工作，它提供了一个简单的接口来发布结果并将进度发送到主线程。在本章中，我们将把重点转移到`android.content.Loader`上，这是一个高级的、特定于Android的模式，用于通过工作线程异步从内容提供者或数据源加载数据，并具有内容变更能力和组件生命周期意识。
- en: 'In this chapter we will cover the the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing loaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍loaders
- en: Loader API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loader API
- en: Loader lifecycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loader生命周期
- en: Loading data with Loader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Loader加载数据
- en: Building responsive apps with AsyncTaskLoader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AsyncTaskLoader构建响应式应用
- en: Building responsive apps with CursorLoader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CursorLoader构建响应式应用
- en: Combining loaders
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合loaders
- en: Applications of loaders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loaders的应用
- en: Introducing Loaders
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Loaders
- en: 'As the name suggests, the job of `Loader` is to load data on behalf of other
    parts of the application, and to make that data available across activities and
    fragments within the same process. The Loaders framework was created to solve
    a couple of issues related to asynchronous loading in Activities and Fragments:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`Loader`的工作是代表应用的其他部分加载数据，并使该数据在相同进程内的活动（Activity）和片段（Fragment）之间可用。Loader框架被创建出来是为了解决与Activity和Fragment中异步加载相关的一些问题：
- en: '**Background processing**: The heavy lifting is automatically performed on
    a background thread, and the results are safely introduced to the main thread
    on completion.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台处理**：繁重的工作自动在后台线程上执行，并在完成后安全地将结果引入主线程。'
- en: '**Result caching**: Loaded data can be cached and redelivered on repeat calls
    for speed and efficiency.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果缓存**：加载的数据可以被缓存，并在重复调用时重新发送以提高速度和效率。'
- en: '**Lifecycle awareness**: The framework gives us control over when a Loader
    instance is destroyed, and allows Loaders to live outside the `Activity` lifecycle,
    making their data available across the application and across `Activity` restarts.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期意识**：该框架让我们能够控制Loader实例何时被销毁，并允许Loader在`Activity`生命周期之外存活，使得它们的数据可以在整个应用和`Activity`重启之间可用。'
- en: '**Data change management**: Loaders monitor their underlying data source, and
    reload their data in the background when necessary. The framework includes lifecycle
    callbacks that allow us to properly dispose of any expensive resources held by
    our Loaders.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据变更管理**：Loaders监控其底层数据源，并在必要时在后台重新加载数据。框架包括生命周期回调，允许我们正确地处理Loader持有的任何昂贵资源。'
- en: Loader API
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loader API
- en: The `Loader` API was introduced to the Android platform at API level 11, but
    are available for backwards compatibility through the support libraries. The examples
    in this chapter use the support library to target API levels 7 through 23.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loader` API是在API级别11引入到Android平台的，但通过支持库向后兼容。本章中的示例使用支持库针对API级别7到23。'
- en: The framework defines interfaces, abstract classes, and loader implementations
    to create first class Android data loaders for your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 框架定义了接口、抽象类和loader实现，以创建适用于您应用的Android一级数据加载器。
- en: 'The Loaders are able to monitor the content and deliver new changes, and will
    survive across an Activity transition or across a replaced Activity triggered
    by a configuration change. The API classes and interfaces delivered by this framework
    are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Loaders能够监控内容并传递新的变更，并且能够在活动过渡或由配置更改触发的替换活动之间存活。此框架提供的API类和接口包括：
- en: '`android.content.Loader<DataType>`: Nonfunctional (abstract) base class that
    defines the base methods'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.content.Loader<DataType>`：非功能性（抽象）基类，定义了基本方法'
- en: '`android.app.LoaderManager`: Manages loaders in Activities and Fragments'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.LoaderManager`：管理Activity和Fragment中的loader'
- en: '`android.app.LoaderManager.LoaderCallbacks`: Callbacks used to listen for Loader
    events'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.LoaderManager.LoaderCallbacks`：用于监听Loader事件的回调'
- en: '`android.content.AsyncTaskLoader<DataType>`: `Loader` subclass that executes
    the loading over an `AsyncTask`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.content.AsyncTaskLoader<DataType>`：执行加载操作的`Loader`子类'
- en: '`android.content.CursorLoader`: Loader implementation used to deal with Android
    internal databases and content providers'' data sources'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.content.CursorLoader`：用于处理 Android 内部数据库和内容提供者数据源的加载器实现'
- en: The last two classes are non-abstract subclasses that we will go into detail
    with examples in the next sections of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个类是非抽象子类，我们将在本章的下一节通过示例详细说明。
- en: Loader
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Loader
- en: '`Loader` is a generic type class that, by itself, does not implement any asynchronous
    behavior and exposes one generic type argument:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loader` 是一个泛型类型类，它本身不实现任何异步行为，并公开一个泛型类型参数：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `<DataType>` generic type defines the result type that your `Loader` is
    going to deliver and should be defined by any subclass that implements a domain
    specific `Loader`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`<DataType>` 泛型类型定义了 `Loader` 将要提供的结果类型，并且应该由实现特定领域 `Loader` 的任何子类定义。'
- en: 'When you create your own loader there are five methods of `Loader` which we
    must implement to create a fully functional Loader:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的加载器时，`Loader` 有五种方法我们必须实现以创建一个完全功能的加载器：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `onStartLoading()` method is the method that subclass must implement to
    start loading data, the `onStopLoading()` is a method used to implement behavior
    when a loader stop was requested because the activity or fragment associated is
    stopped. At this state, the `Loader` may carry on processing but shouldn't deliver
    updates to the `Activity` until `onStartLoading()` is invoked again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStartLoading()` 方法是子类必须实现的方法，用于开始加载数据，`onStopLoading()` 是一个用于实现当请求停止加载因为相关联的活动或片段停止时的行为的方法。在此状态下，`Loader`
    可能会继续处理，但不应在再次调用 `onStartLoading()` 之前向 `Activity` 提供更新。'
- en: The `onForceLoad()` is a method that you should implement to ignore a previously
    loaded data set and load a new one, like clearing a cache, and the `onReset()`
    method is a method called for you automatically by LoaderManager to free any loader's
    resources if your loader is not invoked again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`onForceLoad()` 是一个你应该实现的方法，用于忽略之前加载的数据集并加载一个新的数据集，就像清除缓存一样，而 `onReset()` 方法是
    LoaderManager 自动调用以释放任何未再次调用的加载器的资源的方法。'
- en: The `onCancelLoad()` is a method invoked on the main thread used to implement
    behavior when the load is canceled after invoking the `Loader.cancelLoad()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCancelLoad()` 是在主线程上调用，用于实现调用 `Loader.cancelLoad()` 后取消加载时的行为。'
- en: Although we can extend `Loader` directly, it is more common to use one of the
    two provided subclasses, `AsyncTaskLoader` or `CursorLoader`, depending on our
    requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以直接扩展 `Loader`，但更常见的是根据我们的需求使用提供的两个子类之一，`AsyncTaskLoader` 或 `CursorLoader`。
- en: '`AsyncTaskLoader` is a general-purpose `Loader`, which we can subclass when
    we want to load just about any kind of data from just about any kind of source,
    and do so off the main thread.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTaskLoader` 是一个通用目的的 `Loader`，当我们想要从任何类型的源加载几乎任何类型的数据，并且希望在主线程之外完成时，我们可以从它派生子类。'
- en: '`CursorLoader` extends `AsyncTaskLoader`, specializing it to efficiently source
    data from a local database and manage the associated database `Cursor` correctly.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`CursorLoader` 扩展了 `AsyncTaskLoader`，专门用于高效地从本地数据库获取数据并正确管理相关的数据库 `Cursor`。'
- en: Loader Manager
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Loader Manager
- en: 'When we use Loaders, we will not do so in isolation, because they form part
    of a small framework. Loaders are managed objects, and are looked after by a `LoaderManager`,
    which takes care of coordinating Loader lifecycle events with the `Fragment` and
    `Activity` lifecycles, and makes the `Loader` instances available to the client
    code throughout an application. The `LoaderManager` abstract class defined in
    `android.support.v4.content.LoaderManager` and `android.app.LoaderManager` is
    accessible in all the Activities and Fragments through the member function `getLoaderManager`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用加载器时，我们不会孤立地使用它们，因为它们是小型框架的一部分。加载器是管理对象，由 `LoaderManager` 负责管理，它负责协调加载器生命周期事件与
    `Fragment` 和 `Activity` 生命周期，并在整个应用程序中使 `Loader` 实例对客户端代码可用。在 `android.support.v4.content.LoaderManager`
    和 `android.app.LoaderManager` 中定义的 `LoaderManager` 抽象类可以通过所有活动和片段的成员函数 `getLoaderManager`
    访问：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The LoaderManager provides an API that could be used by the client (Activity
    or Fragment) to set up, initialize, restart, and destroy loaders without being
    bound to the client lifecycle. The Loader Manager''s most relevant methods that
    are accessible when you retrieve the client-managed LoaderManager instance are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: LoaderManager 提供了一个 API，客户端（活动或片段）可以使用它来设置、初始化、重新启动和销毁加载器，而无需绑定到客户端生命周期。当你检索客户端管理的
    LoaderManager 实例时，Loader Manager 的最相关的方法是：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `id` argument in all the methods defined by the `LoaderManager` identifies
    the Loader on the client context, and moreover, is used in all the `LoaderManager`
    APIs to trigger any action in a specific Loader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoaderManager` 定义的 所有方法中，`id` 参数用于标识客户端上下文中的Loader，并且还用于所有 `LoaderManager`
    API 中以触发特定Loader的任何操作。
- en: The `initLoader` method is used to initialize a certain loader but it does not
    create a new Loader if a Loader with the same ID already exists on the `LoaderManager`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`initLoader` 方法用于初始化特定的Loader，但如果 `LoaderManager` 中已经存在具有相同ID的Loader，则不会创建新的Loader。'
- en: The `restartLoader` method starts or restarts a loader, however if a Loader
    associated with the ID passed in already exists, the old loader will be destroyed
    when it completes its work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`restartLoader` 方法启动或重新启动一个Loader，但如果传入ID的Loader已经存在，则当它完成工作后，旧Loader将被销毁。'
- en: The `destroyLoader` method stops and removes the `Loader` with the ID specified
    by the argument `id` explicitly from the `LoaderManager`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroyLoader` 方法停止并从 `LoaderManager` 中显式移除由参数 `id` 指定的 `Loader`。'
- en: LoaderManager.LoaderCallbacks
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoaderManager.LoaderCallbacks
- en: 'To interact with the `LoaderManager`, the client needs to implement the `LoaderCallbacks<D>`
    interface and receive events to create a new `Loader` for a given ID, to receive
    the Loader results, or reset a Loader respectively:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `LoaderManager` 交互，客户端需要实现 `LoaderCallbacks<D>` 接口并接收事件以创建具有给定ID的新 `Loader`、接收Loader结果或重置Loader：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Like we detailed before, the `D` generic type specifies the data type that
    the Loader returns and these callbacks are called by the LoaderManager when a
    particular state is reached on the Loader lifecycle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前详细说明的，`D` 泛型类型指定了Loader返回的数据类型，并且当Loader的生命周期达到特定状态时，由LoaderManager调用这些回调：
- en: '`onCreateLoader`: This is a creational method that bootstraps a Loader for
    a specified ID and with a given Bundle object. The Bundle object is used to pass
    arguments for the Loader creation. This method gets invoked when the client calls
    `initLoader` and no Loader with that ID exists on LoaderManager.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateLoader`: 这是一个创建方法，用于为指定的ID和给定的Bundle对象启动一个Loader。Bundle对象用于传递Loader创建的参数。当客户端调用
    `initLoader` 而且LoaderManager中不存在具有该ID的Loader时，将调用此方法。'
- en: '`onLoadFinished`: This is the method called when the Loader gets its results;
    the callback is called with the results and with a reference for the loader that
    retrieved the result. When the Loader detects a content change on the data requested
    it will report back the new results, therefore this method could be called several
    times. This method is typically used to update the UI with the loaded data.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadFinished`: 当Loader获取到结果时，将调用此方法；回调将使用结果和检索结果的Loader引用被调用。当Loader检测到请求的数据内容发生变化时，它将报告新的结果，因此此方法可能会被多次调用。此方法通常用于使用加载的数据更新UI。'
- en: '`onLoaderReset`: This is the method invoked when the Loader for a given ID
    is going to be destroyed. This is the best place to release some resources and
    references attached to one specified ID.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoaderReset`: 当给定ID的Loader即将被销毁时，将调用此方法。这是释放与指定ID关联的一些资源和引用的最佳位置。'
- en: Loader lifecycle
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loader生命周期
- en: 'Any Loader object managed by a `LoaderManager` can be in six different flags
    that defines the Loader state:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `LoaderManager` 管理的任何Loader对象都可以处于六个不同的标志中，这些标志定义了Loader的状态：
- en: '**Reset**: This is the flag that sets your loader when you create a Loaders
    instance. The flag would end up here if the `reset()` method is invoked. The `onReset()`
    is called when the reset is moving to this state, and the developer must use this
    method to release the resources allocated on the Loader and to reset any cache
    result.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重置**: 当你创建 `Loaders` 实例时，将设置此标志。如果调用 `reset()` 方法，标志将结束于此。当重置移动到此状态时，将调用
    `onReset()`，开发者必须使用此方法释放Loader上分配的资源以及重置任何缓存结果。'
- en: '**Started**: This is the flag set when your loader `startLoading()` is invoked.
    After your loader enters into this state, the `onStartLoading` method gets invoked
    to setup your loading resources. If the Loader has already delivered results you
    can call the `forceLoad()` to restart a new loading. Your loader should only deliver
    results when this flag is on.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动**: 当调用你的 `loader` 的 `startLoading()` 方法时，将设置此标志。在Loader进入此状态后，`onStartLoading`
    方法会被调用以设置加载资源。如果Loader已经提供了结果，你可以调用 `forceLoad()` 来重新启动新的加载。你的Loader应该在标志处于开启状态时才提供结果。'
- en: '**Stopped**: This is the flag set when the loader is stopped and is not able
    to deliver new results or delivery of content changes. In this state, the loader
    could store results to deliver when the loader is restarted. To implement behavior
    when the loader has this on, the developer must implement the `onStopLoading`
    and release any resources allocated to load the results.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：当加载器停止且无法提供新结果或内容更改的交付时，会设置此标志。在此状态下，加载器可以存储结果以在加载器重新启动时交付。为了实现加载器具有此状态时的行为，开发者必须实现
    `onStopLoading` 并释放为加载结果分配的所有资源。'
- en: '**Abandoned**: This is an optional intermediate flag used to pinpoint whether
    the `Loader` was abandoned. Like the other methods, subclasses must implement
    the `onAbandon()` to implement behavior when the client is no longer interested
    in new data updates from the loader. At this state, prior to Reset, the Loader
    must not report any fresh updates but it can keep results to deliver when the
    loader is restarted.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**废弃**：这是一个可选的中间标志，用于确定 `Loader` 是否被废弃。与其他方法一样，子类必须实现 `onAbandon()` 以在客户端不再对来自加载器的新数据更新感兴趣时实现行为。在此状态下，在重置之前，加载器不得报告任何新的更新，但它可以保留在加载器重新启动时交付的结果。'
- en: '**ContentChanged**: This is a flag used to notify that the Loader content has
    changed. The `onContentChanged` is callback invoked when a content change is detected
    on the Load.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容更改**：这是一个用于通知 `Loader` 内容已更改的标志。当检测到 Load 上的内容更改时，会调用 `onContentChanged`
    回调。'
- en: '**ProcessingChange**: This is a flag used to notify that the Loader content
    is processing a change on its content. The following functions `takeContentChanged()`,
    `commitContentChanged()`, and `rollbackContentChanged()` are used to manage the
    data content changes and its processing state.![Loader lifecycle](img/Image_B05062_04_01.jpg)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理更改**：这是一个用于通知 `Loader` 内容正在处理其内容更改的标志。以下函数 `takeContentChanged()`、`commitContentChanged()`
    和 `rollbackContentChanged()` 用于管理数据内容更改及其处理状态。![Loader生命周期](img/Image_B05062_04_01.jpg)'
- en: 'Figure 4.1: Loader Lifecycle'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1：Loader 生命周期
- en: Loading data with Loader
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Loader 加载数据
- en: So far, we have only described theoretical entities and the classes available
    on the API so now is the right time to show these concepts with a simple example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只描述了理论实体和 API 上可用的类，因此现在是时候通过一个简单的示例来展示这些概念了。
- en: In our example we will show you how to use `LoaderManager`, `LoaderCallback`,
    and a `Loader` to present an `Activity` that lists the name of users that are
    currently online for a chat application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将向您展示如何使用 `LoaderManager`、`LoaderCallback` 和一个 `Loader` 来展示一个列出当前在线用户名称的
    `Activity`，适用于聊天应用程序。
- en: 'First, we are going to create an Activity that will act as a client to the
    `LoaderManager` and will have three buttons, **INIT**, **RESTART**, and **DESTROY**;
    to initialize the loader, to restart, and to destroy the loader respectively.
    The Activity will receive the `LoaderCallbacks` callback directly since it implements
    that interface as member functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 Activity，它将充当 `LoaderManager` 的客户端，并将有三个按钮，**初始化**、**重启** 和 **销毁**；分别用于初始化加载器、重启加载器和销毁加载器。Activity
    将直接接收 `LoaderCallbacks` 回调，因为它实现了该接口作为成员函数：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Clicking on the **INIT** button will initialize the `Loader` with the ID specified
    and with a bundle object that we use to pass arguments to the `Loader`, and as
    said before the **RESTART** button will destroy a previous loader if it already
    exists and create a new one and the **DESTROY** button will destroy the loader
    with the given ID if it already exists in the `LoaderManager`. These buttons are
    used here only to help us to explain the interaction and flow between the `LoaderManager`
    and the `Loader`s.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **初始化** 按钮将使用指定的 ID 和一个包含我们用于传递到 `Loader` 的参数的 bundle 对象初始化 `Loader`，正如之前所说的，**重启**
    按钮将销毁一个已存在的加载器并创建一个新的加载器，而 **销毁** 按钮将销毁具有给定 ID 的加载器（如果它已经在 `LoaderManager` 中存在）。这些按钮在这里仅用于帮助我们解释
    `LoaderManager` 和 `Loader` 之间的交互和流程。
- en: In this specific use case we are going to load the list of online users for
    the chat room developers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的用例中，我们将加载聊天室开发者的在线用户列表。
- en: Now let's take a look at the `LoaderCallback` functions and implement the interface
    on our `Activity`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `LoaderCallback` 函数，并在我们的 `Activity` 上实现该接口。
- en: Starting with `onCreateLoader`, this `LoaderCallback` callback gets called only
    if the loader does not previously exist or when the loader is restarted by calling
    `LoaderManager.restartLoader()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `onCreateLoader` 开始，这个 `LoaderCallback` 回调只有在加载器之前不存在或通过调用 `LoaderManager.restartLoader()`
    重新启动加载器时才会被调用。
- en: When we initialize `WhosOnlineLoader` via the `LoaderManager` `initLoader` method,
    it will either return an existing Loader with the given ID (`LOADER_ID`) or, if
    it doesn't yet have a `Loader` with that ID, it will invoke the first of the `LoaderCallbacks`
    methods—`onCreateLoader`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 `LoaderManager` 的 `initLoader` 方法初始化 `WhosOnlineLoader` 时，它将返回具有给定 ID
    (`LOADER_ID`) 的现有 Loader，或者如果没有具有该 ID 的 `Loader`，它将调用第一个 `LoaderCallbacks` 方法——`onCreateLoader`。
- en: This means this method will not be called on for a configuration change because
    a previous loader with this ID is already available and initialized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着此方法不会在配置更改时被调用，因为已经有一个具有此 ID 的先前加载器可用并已初始化。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method creates the Loader instance calling the `WhosOnlineLoader` constructor
    and passing the chat group name that we are trying to load.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过调用 `WhosOnlineLoader` 构造函数并传递我们试图加载的聊天组名称来创建 Loader 实例。
- en: The next `LoaderCallback` function callback implemented is `onLoadFinished`;
    this callback gets called when the loader gets new results, when the data changes,
    or could be called when a configuration changes a `Loader` that already exists
    in the `LoaderManager`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个实现的 `LoaderCallback` 函数回调是 `onLoadFinished`；此回调在加载器获得新结果、数据更改或配置更改已存在于 `LoaderManager`
    中的 `Loader` 时被调用。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our example, when the `onLoadFinished` gets called, we update the `ListView`
    adapter with the list of users received from the loader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当 `onLoadFinished` 被调用时，我们使用从加载器接收到的用户列表更新 `ListView` 适配器。
- en: 'The `OnLoaderReset`, our last `LoaderCallback` function callback, gets called
    when the loader is destroyed, and in our example it simply cleans up the list
    view data in its adapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnLoaderReset`，我们最后的 `LoaderCallback` 函数回调，在加载器被销毁时被调用，在我们的例子中，它只是在其适配器中清理列表视图数据：'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The loader reset is called when the `LoaderManager.destroyLoader(id)` is called
    or when the `Activity` gets destroyed. The Loader reset, as described earlier,
    will not destroy the loader but tell the Loader not to publish further updates.
    Hence, it can span multiple Activities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `LoaderManager.destroyLoader(id)` 或当 `Activity` 被销毁时，将调用加载器重置。如前所述，加载器重置不会销毁加载器，而是告诉加载器不要发布进一步的更新。因此，它可以跨越多个
    Activity。
- en: The last piece of this cake is our custom Loader, the `WhosOnlineLoader`, used
    to retrieve the list of online users. Our `WhosOnlineLoader` is not going to load
    any asynchronous results, since a `Loader` subclass does not manage a background
    thread to load the results. Hence, this Loader should only be used for example
    purposes and to explain the `LoaderManager` and custom Loader interaction idiosyncrasies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个蛋糕的最后一块是我们的自定义 Loader，即 `WhosOnlineLoader`，用于检索在线用户列表。我们的 `WhosOnlineLoader`
    不会加载任何异步结果，因为 `Loader` 子类不管理用于加载结果的后台线程。因此，这个 Loader 应仅用于示例目的，并解释 `LoaderManager`
    和自定义 Loader 的交互特性。
- en: For debugging purposes, the methods `onStartLoading`, `onStopLoading`, `onReset`,
    and `onForceLoad` have a log message printed every time they enter on a function.
    The `deliverResult()`, the Loader function that delivers the result of the load
    to the registered listener, will also print a message to the Android Log with
    the users online.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，方法 `onStartLoading`、`onStopLoading`、`onReset` 和 `onForceLoad` 在每次进入函数时都会打印一条日志消息。`deliverResult()`，即向已注册的监听器传递加载结果的
    Loader 函数，也会将包含在线用户信息的消息打印到 Android 日志中。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `WhosOnlineLoader` code is partially omitted on purpose, although the `WhosOnlineLoader`
    source code is available to download from the Packt Publishing website.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 故意省略了 `WhosOnlineLoader` 代码的部分内容，尽管 `WhosOnlineLoader` 的源代码可以从 Packt Publishing
    网站下载。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With everything in place, if we start the Activity, the user online list will
    be empty, although clicking on the **INIT** button will result in a `LoaderManager.init`
    call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，如果我们启动 Activity，在线用户列表将为空，尽管点击 **初始化** 按钮会导致 `LoaderManager.init` 调用。
- en: 'Since we have some trace messages at the beginning of each `Loader` lifecycle,
    we can follow the loader callback calls:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在每个 `Loader` 生命周期开始处有一些跟踪消息，我们可以跟踪加载器回调调用：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown in the log output, a new `Loader` object instance with the `hashCode`
    `ee07113` is created when we invoke the `LoaderManager.init` function and the
    `onCreateLoader` gets called in the meantime. Afterwards, the loader is started
    and the results are loaded on the `onLoadFinished` callback, delivering the list
    of users.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如日志输出所示，当我们调用 `LoaderManager.init` 函数并且在此期间调用 `onCreateLoader` 时，将创建一个新的 `Loader`
    对象实例，其 `hashCode` 为 `ee07113`。之后，加载器开始运行，并在 `onLoadFinished` 回调中加载结果，传递用户列表。
- en: 'Since the `Loader` with the ID now exists on the `LoaderManager`, lets check
    what happens when we click on the **restart** button:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在具有该 ID 的 `Loader` 已经存在于 `LoaderManager` 中，让我们检查当我们点击 **重启** 按钮时会发生什么：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the `Loader ee07113` was created previously, it will be stopped and reset,
    and a new loader instance will be created and started like it did on the `init`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前创建了 `Loader ee07113`，它将被停止并重置，并且将创建并启动一个新的加载器实例，就像在 `init` 中做的那样。
- en: 'Now we are going to click on the **DESTROY** button and check the results:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将点击 **销毁** 按钮并检查结果：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As expected, the `LoaderManager.destroy` gets called, and after that the `onAbandon`,
    `onReset`, and the `onStopping Loader` member methods were called to stop delivering
    results, release the loader resources, and to stop loading data. When the Loader
    is stopped we must cancel any loading but it can still monitor the data source
    for changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`LoaderManager.destroy` 被调用，之后调用了 `onAbandon`、`onReset` 和 `onStopping Loader`
    成员方法来停止发送结果，释放加载器资源，并停止加载数据。当加载器停止时，我们必须取消任何加载，但它仍然可以监控数据源的变化。
- en: Another situation that is really important to explain is the configuration change.
    In this situation, the `LoaderManager` will continue to receive the results and
    keep them in a local cache. Once the new activity becomes visible, the cache results
    are delivered over the method `LoaderCallbacks.onLoadFinished`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的情况需要解释的是配置更改。在这种情况下，`LoaderManager` 将继续接收结果并将它们保存在本地缓存中。一旦新的活动变得可见，缓存的结果将通过
    `LoaderCallbacks.onLoadFinished` 方法传递。
- en: In a typical `Activity` transition where there is no configuration change involved,
    `LoaderManager` automatically resets the `Loader` resulting in calls to the loader
    stop and reset functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有涉及配置更改的典型 `Activity` 转换中，`LoaderManager` 会自动重置 `Loader`，导致调用加载器停止和重置功能。
- en: Given that now we understand how to use the `LoaderManager` to manage the loaders
    in activities, now we can focus our attention on how to use the subclasses `AsyncTaskLoader`
    and `LoaderCursor` to create asynchronous Loaders.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在已经了解了如何使用 `LoaderManager` 来管理活动中的加载器，现在我们可以集中精力研究如何使用子类 `AsyncTaskLoader`
    和 `LoaderCursor` 来创建异步加载器。
- en: Building responsive apps with AsyncTaskLoader
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `AsyncTaskLoader` 构建响应式应用
- en: '`AsyncTaskLoader` is a Loader implementation that uses `AsyncTasks` to perform
    its background work, though this is largely hidden from us when we implement our
    own subclasses.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTaskLoader` 是一个使用 `AsyncTasks` 来执行其后台工作的加载器实现，尽管当我们实现自己的子类时，这部分对我们来说是隐藏的。'
- en: We don't need to trouble ourselves with the `AsyncTasks`—they are completely
    hidden by `AsyncTaskLoader`—but with what we learned earlier about `AsyncTask`,
    it is interesting to note that tasks are, by default, executed using `AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)`
    to ensure a high degree of concurrency when multiple Loaders are in use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心 `AsyncTasks`——它们被 `AsyncTaskLoader` 完全隐藏——但根据我们之前关于 `AsyncTask` 的了解，值得注意的是，任务默认情况下是使用
    `AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)` 执行的，以确保在多个加载器使用时具有高度的并发性。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `AsyncTaskLoader` in the compatibility package (`android.support.v4.content`)
    does not rely on the public `AsyncTask` in the platform. Instead, the compatibility
    package uses an internal `ModernAsyncTask` implementation to avoid Android fragmentation.
    The `ModernAsyncTask` creates threads with the name `ModernAsyncTask #<N>`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '兼容包中的 `AsyncTaskLoader` (`android.support.v4.content`) 并不依赖于平台中的公共 `AsyncTask`。相反，兼容包使用一个内部的
    `ModernAsyncTask` 实现来避免 Android 的碎片化。`ModernAsyncTask` 会创建名为 `ModernAsyncTask
    #<N>` 的线程。'
- en: In the next section we will use `AsyncTaskLoader` to load in the background,
    a currency to Bitcoin exchange rate, and display an updated exchange rate in our
    `BitcoinExchangeRateActivity` making use of the `LoaderManager`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 `AsyncTaskLoader` 在后台加载货币到比特币的汇率，并在我们的 `BitcoinExchangeRateActivity`
    中使用 `LoaderManager` 显示更新的汇率。
- en: The exchange rate will be refreshed continuously using the `onContentChanged()`
    Loader method, used in this case to force a new exchange rate update in background.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将会使用 `onContentChanged()` 加载器方法持续刷新汇率，这个方法在此情况下用于在后台强制进行新的汇率更新。
- en: 'Loader is generically typed so when we implement it, we need to specify the
    type of object that it will load—in our case `Double`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是泛型类型，因此当我们实现它时，需要指定它将加载的对象类型——在我们的例子中是 `Double`：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Loader abstract class requires a Context passed to its constructor, so
    we must pass a Context up the chain. We''ll also need to know which currency exchange
    rate to retrieve, and the refresh time interval, so we''ll also pass a string
    to identify the currency and an integer for the interval (milliseconds):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Loader 抽象类要求在构造函数中传递一个 Context，因此我们必须将 Context 传递到链中。我们还需要知道要检索哪种货币汇率以及刷新时间间隔，因此我们还将传递一个用于标识货币的字符串和一个表示间隔（毫秒）的整数：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We don't need to keep our own reference to the `Context` object—`Loader` exposes
    a `getContext()` method which we can call from anywhere in our class where we
    might need a Context.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要保留自己的 `Context` 对象引用——`Loader` 提供了一个 `getContext()` 方法，我们可以在类的任何可能需要 Context
    的地方调用它。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can safely pass a reference to an Activity instance as the Context parameter,
    but we should not expect `getContext()` to return the same object! Loaders potentially
    live much longer than a single Activity, so the Loader superclass only keeps a
    reference to the application Context, a context tied to an application, to prevent
    memory leaks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地将 Activity 实例的引用作为 Context 参数传递，但不应期望 `getContext()` 返回相同的对象！Loader 可能比单个
    Activity 存活时间更长，因此 Loader 类的父类只保留对应用程序 Context 的引用，这是一个与应用程序关联的 Context，以防止内存泄漏。
- en: 'There are several methods we will need to override which we''ll work through
    one at a time. The most important is `loadInBackground`—the workhorse of our `AsyncTaskLoader`,
    and the only method which does not run on the main thread:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖几个方法，我们将逐个处理。最重要的是 `loadInBackground`——我们的 `AsyncTaskLoader` 的主要工作马，并且是唯一不在主线程上运行的方法：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `AsyncTaskLoader` is a Loader subclass based on `AsyncTask`. Under the hood,
    it calls the `loadInBackground` function in an AsyncTask's background thread.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTaskLoader` 是基于 `AsyncTask` 的 Loader 子类。在底层，它在一个 AsyncTask 的后台线程中调用 `loadInBackground`
    函数。'
- en: We're going to fetch the real-time bitcoin exchange rate from Internet, more
    precisely from the blockchain.info website, to delays to establish the connection,
    to transmit the data between the device and the remote endpoint and to some latency
    exposed by the access network. Since the delays can range from milliseconds to
    seconds, this task is a good candidate to perform off the main thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从互联网上获取实时比特币汇率，更确切地说，从 blockchain.info 网站上获取，以建立连接的延迟，在设备与远程端点之间传输数据以及由接入网络暴露的一些延迟。由于延迟可以从毫秒到秒不等，这项任务是一个很好的候选任务，可以在主线程之外执行。
- en: 'The following diagram displays the `Loader` lifecycle, showing callbacks invoked
    by `LoaderManager` and a typical `AsyncTaskLoader` implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 `Loader` 的生命周期，显示了由 `LoaderManager` 触发的回调以及典型的 `AsyncTaskLoader` 实现：
- en: '![Building responsive apps with AsyncTaskLoader](img/Image_B05062_04_02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用 AsyncTaskLoader 构建响应式应用](img/Image_B05062_04_02.jpg)'
- en: Given that loading the exchange rate from the network entails some delay due
    to blocking I/O reading from the network, and it is also possible that the remote
    website does not yet have enough resources to send the response back, we, as conscious
    developers who don't want to generate annoying Android ANRs, have to transfer
    these kinds of operations to the `AsyncTaskLoader.loadInBackground` method that
    is executed by the background thread in the system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从网络加载汇率涉及到由于从网络进行阻塞 I/O 读取而导致的延迟，并且远程网站可能还没有足够的资源来发送响应，因此，作为不想生成令人烦恼的 Android
    ANR 的有意识的开发者，我们必须将这些操作转移到由系统后台线程执行的 `AsyncTaskLoader.loadInBackground` 方法中。
- en: After we receive the response with the exchange rate, we need to decode the
    JSON response that comes in the HTTP response so this is also an operation we
    definitely want to perform off the main thread!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收到包含汇率的响应后，我们需要解码 HTTP 响应中包含的 JSON 响应，因此这也是我们肯定希望在主线程之外执行的操作！
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we execute the blocking operations suggested previously
    and as a result we return the exchange rate for the currency specified in the
    `Loader` construct.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行了之前建议的阻塞操作，因此我们返回了在 `Loader` 构造中指定的货币的汇率。
- en: 'We''ll want to cache a reference to the Double object that we''re delivering,
    so that any future calls can just return the same Double immediately. We''ll do
    this by overriding `deliverResult` invoked on the main thread:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要缓存我们传递的 Double 对象的引用，以便任何未来的调用都可以立即返回相同的 Double。我们将通过覆盖在主线程上调用的 `deliverResult`
    方法来实现这一点：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make our `Loader` actually work, we still need to override a handful of
    lifecycle methods that are defined by the `Loader` base class. First and foremost
    is `onStartLoading`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`Loader`真正工作，我们仍然需要重写由`Loader`基类定义的一些生命周期方法。最重要的是`onStartLoading`：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we check our cache (`mExchangeRate`) to see if we have a previously loaded
    result that we can deliver immediately via `deliverResult`. If the content data
    has changed recently, `contentChanged` flag is true, and we don't have a cached
    result, we force a background load to occur—we must do this otherwise our Loader
    won't ever load anything. As described before this callback runs on the main thread
    and the load will fire off a new load throughout `loadInBackground()` on the background
    thread.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查我们的缓存（`mExchangeRate`）以查看我们是否有之前加载的结果，我们可以通过`deliverResult`立即交付。如果内容数据最近已更改，`contentChanged`标志为真，并且我们没有缓存的结果，我们将强制进行后台加载——否则我们的`Loader`将永远不会加载任何内容。如前所述，此回调在主线程上运行，加载将在后台线程上的`loadInBackground()`中触发新的加载。
- en: We now have a minimal working `Loader` implementation, but there is some housekeeping
    required if we want our `Loader` to play well with the framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个最小的工作`Loader`实现，但如果我们想让`Loader`与框架良好协作，还需要做一些维护工作。
- en: First of all, we need to make sure that we clean up the exchange rate when our
    `Loader` is discarded. Loader provides a callback intended for that exact purpose—`onReset`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保在`Loader`被丢弃时清理汇率。`Loader`提供了一个用于此特定目的的回调——`onReset`。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The framework will ensure that `onReset` is called when `Loader` is being discarded,
    which will happen when the app exits or when the `Loader` instance is explicitly
    discarded via `LoaderManager`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 框架将确保在`Loader`被丢弃时调用`onReset`，这将在应用退出或通过`LoaderManager`显式丢弃`Loader`实例时发生。
- en: 'There are two more lifecycle methods, which are important to implement correctly
    if we want our app to be as responsive as possible: `onStopLoading` and `onCanceled`
    (be careful of the spelling of `onCanceled` here versus `onCancelled` in most
    places).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个生命周期方法，如果我们想使我们的应用尽可能响应，则必须正确实现：`onStopLoading`和`onCanceled`（请注意`onCanceled`在这里的拼写与大多数地方的`onCancelled`不同）。
- en: 'The framework will tell us when it doesn''t want us to waste cycles loading
    data by invoking the `onStopLoading` callback. It may still need the data we have
    already loaded though, and it may tell us to start loading again, so we should
    not clean up resources yet. In `AsyncTaskLoader` we''ll want to cancel the background
    work if possible, so we''ll just call the superclass `cancelLoad` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 框架将通过调用`onStopLoading`回调来告诉我们它不想浪费周期加载数据。尽管如此，它可能仍然需要我们已加载的数据，并且它可能告诉我们再次开始加载，因此我们不应清理资源。在`AsyncTaskLoader`中，我们希望如果可能的话取消后台工作，所以我们只需调用超类`cancelLoad`方法：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `Loader` is cancelled we don't stop the current rate loading; in spite
    of this, in other kinds of use cases, we might have a cancelling behavior on the
    `loadInBackground()` to stop the current loading by checking the `isAbandoned()`
    member function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Loader`被取消时，我们不会停止当前汇率加载；尽管如此，在其他类型的用例中，我们可能在`loadInBackground()`上有一个取消行为，通过检查`isAbandoned()`成员函数来停止当前加载。
- en: 'Finally, we need to implement `onCancelled` to clean up any data that might
    be loaded in the background after a cancellation has been issued:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现`onCancelled`来清理在取消发出后可能在后台加载的任何数据：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Depending on the kind of data Loader produces, we may not need to worry about
    cleaning up the result of canceled work—ordinary Java objects will be cleaned
    up by the garbage collector when they are no longer referenced.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Loader产生的数据类型，我们可能不需要担心清理取消工作的结果——普通的Java对象将在它们不再被引用时由垃圾收集器清理。
- en: So far, we have implemented the asynchronous exchange rate loading, now we have
    to implement the refresh feature to continuously fetch the value from the blockchain.info
    website. To load a new value for the current exchange rate we shall coerce the
    loader to run the `loadInBackground` again and retrieve the current value for
    the exchange rate. The `Loader` abstract class offers us the method `onContentChanged()`,
    that will force a new load if the `Loader` is at the started state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了异步汇率加载，现在我们必须实现刷新功能，以便持续从blockchain.info网站获取值。为了为当前汇率加载新值，我们应该强制加载器再次运行`loadInBackground`并检索当前汇率值。`Loader`抽象类为我们提供了`onContentChanged()`方法，该方法将强制在`Loader`处于启动状态时进行新的加载。
- en: In our example, once the loader is started with `startLoading()`, we must continuously
    call `onContentChanged` to mimic a value change and force a new load. We will
    achieve this by using a handler and by posting a `Runnable` that simply calls
    the `onContentChange` on our `Loader`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一旦使用`startLoading()`启动Loader，我们必须连续调用`onContentChanged`来模拟值变化并强制重新加载。我们将通过使用handler和发布一个简单地调用我们的`Loader`上的`onContentChange`的`Runnable`来实现这一点。
- en: 'First we are going to create the `Runnable` and create the handler in our loader:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`Runnable`并在我们的Loader中创建handler：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Second, we need to submit a delayed task to force the next reload, each time
    the `forceLoad()` is called. When the `Loader` is reset we don''t submit the next
    reload:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们需要提交一个延迟任务来强制下一次重新加载，每次调用`forceLoad()`时。当`Loader`被重置时，我们不提交下一次重新加载：
- en: '[PRE23]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Third, to force a new reload when the loader is cancelled and the task is restarted
    afterwards, `onCanceled()` sets the `ContentChange` flag on by calling `onContentChanged()`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，为了在Loader被取消并在之后重新启动任务时强制重新加载，`onCanceled()`通过调用`onContentChanged()`来设置`ContentChange`标志：
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To finish, we must cancel the next reload if the loader is stopped or cancelled:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在Loader停止或取消时取消下一次重新加载：
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So far so good—we have a `Loader`. Now we need to connect it to a client Activity
    or Fragment. Since in our previous example we attached our Loader to an Activity,
    this time we are going to use a different `LoaderManager` client and connect the
    loader to a Fragment object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利——我们有一个`Loader`。现在我们需要将其连接到客户端Activity或Fragment。由于在之前的示例中我们将Loader附加到了Activity上，这次我们将使用不同的`LoaderManager`客户端并将Loader连接到Fragment对象。
- en: 'Our `Fragment`, loaded by `BitcoinExchangeRateActivity`, is going to initialize
    our Loader and display the loader result on the fragment UI. Let''s get these
    easy bits out of the way first:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们由`BitcoinExchangeRateActivity`加载的`Fragment`将初始化Loader并在片段UI上显示Loader的结果。让我们首先处理这些简单的部分：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we mainly load the UI layout used to present the exchange
    rate on the screen and we implement our loader initialization on the `onActivityCreated`
    member function. The `onActivityCreated` member class callback is either called
    when the activity has been created or when the `Activity` is recreated, after
    a configuration change.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们主要加载用于在屏幕上显示汇率的UI布局，并在`onActivityCreated`成员函数上实现我们的loader初始化。`onActivityCreated`成员类回调在活动被创建或配置更改后活动被重新创建时调用。
- en: As we explained in previous sections, we call the `initLoader` passing an `int`
    identifier as the first argument, a Bundle of values—the second parameter—to configure
    the currency exchange rate that we want present on the screen, and a refresh rate
    interval between `onContextChange` calls. The third parameter is an object that
    implements `LoaderCallbacks`, which, in this case, is our `BitcoinExchangeRateFragment`
    instance, where we implement the loader callbacks directly on the fragment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中解释的，我们调用`initLoader`，传递一个`int`标识符作为第一个参数，一个包含值`Bundle`的第二个参数来配置我们希望在屏幕上显示的货币汇率，以及`onContextChange`调用之间的刷新率间隔。第三个参数是实现`LoaderCallbacks`的对象，在这种情况下，是我们的`BitcoinExchangeRateFragment`实例，我们在片段上直接实现loader回调。
- en: The `onCreateLoader` callback method that we implement on our Fragment is similar
    to the method that we create on the previous `WhoIsOnlineActivity` Loader, so
    it basically creates a new `BitcoinExchangeRateLoader` instance using the arguments
    passed on to the `Bundle` object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Fragment上实现的`onCreateLoader`回调方法与我们在之前的`WhoIsOnlineActivity` Loader上创建的方法类似，因此它基本上使用传递给`Bundle`对象的参数创建一个新的`BitcoinExchangeRateLoader`实例。
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation of `onLoadFdinished` must take the loaded exchange rate
    and display it in the `TextView`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`onLoadFinished`的实现必须获取加载的汇率并在`TextView`中显示：'
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For brevity, we omitted the `LoaderCallbacks.onLoaderReset` since the method
    body is empty. This method should be used to release any resources used that are
    directly bound to the Loader lifecycle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们省略了`LoaderCallbacks.onLoaderReset`，因为该方法体为空。此方法应用于释放与Loader生命周期直接绑定的任何资源。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The full source code, with the Activity and `android.xml` layout is available
    on the Packt Publishing website.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，包括活动和`android.xml`布局，可在Packt Publishing网站上找到。
- en: When compared with `AsyncTask`, things here are more complicated—we've had to
    write more code and deal with more classes, but the payoff is that the data is
    cached for use across `Activity` restarts and can be used from other Fragments
    or Activities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AsyncTask`相比，这里的情况更复杂——我们不得不编写更多的代码并处理更多的类，但回报是数据被缓存以供`Activity`重启使用，并且可以从其他Fragment或Activity中使用。
- en: In our `BitcoinExchangeRateLoader`, the successive exchange rate updates are
    controlled by our refresh rate internal; however, in other kinds of `AsyncTaskLoaders`
    the rate where a content change happens could result in lots of `onLoadFinished`
    invocations, and hence potentially dominate the UI thread execution with UI updates
    and degrade the UI responsiveness.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`BitcoinExchangeRateLoader`中，连续的汇率更新由我们的刷新率间隔控制；然而，在其他类型的`AsyncTaskLoaders`中，内容变更发生的速率可能会导致大量的`onLoadFinished`调用，从而可能用UI更新主导UI线程执行，并降低UI响应性。
- en: 'To overcome this issue, the `AsyncTaskLoader` supplies a member function, called
    `setUpdateThrottle`, to control the minimum internal between successive data deliveries
    and as a result adjusts the interval between consecutive `onLoadFinished` invocations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，`AsyncTaskLoader`提供了一个名为`setUpdateThrottle`的成员函数，用于控制连续数据交付之间的最小间隔，从而调整连续`onLoadFinished`调用的间隔：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method must be called when you feel that your loader content change-rate
    might overload the UI and affect your application smoothness. If a higher update
    frequency is not required in your data, the developer can make use of this function
    to reduce the Loader content change deliver frequency.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你觉得你的loader内容变更率可能会超载UI并影响应用程序的流畅性时，必须调用此方法。如果你的数据不需要更高的更新频率，开发者可以利用此功能来减少Loader内容变更的交付频率。
- en: In the next section we will get a detailed overview on the last Loader subclass
    type that comes out of box with Android SDK, the `CursorLoader`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细概述Android SDK中随盒提供的最后一个Loader子类类型，即`CursorLoader`。
- en: Building responsive apps with CursorLoader
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CursorLoader构建响应式应用程序
- en: '`CursorLoader` is a specialized subclass of `AsyncTaskLoader` that uses its
    lifecycle methods to correctly manage the resources associated with a database
    `Cursor`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`CursorLoader`是`AsyncTaskLoader`的一个特殊子类，它使用其生命周期方法来正确管理与数据库`Cursor`相关的资源。'
- en: A database `Cursor` is a little like an Iterator, in that it allows you to scroll
    through a dataset without having to worry where exactly the dataset is coming
    from or what data structure it is a part of.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的`Cursor`有点像迭代器，因为它允许你滚动浏览数据集，而无需担心数据集的确切来源或它所属的数据结构。
- en: 'We''re going to use `CursorLoader` to query the Android device for a list of
    music albums available. Because `CursorLoader` is already implemented to correctly
    handle all of the details of working with a `Cursor`, we don''t need to subclass
    it. We can simply instantiate it, passing in the information it needs in order
    to open the `Cursor` it should manage for us. We can do this in the `onCreateLoader`
    callback:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CursorLoader`查询Android设备上可用的音乐专辑列表。因为`CursorLoader`已经实现了正确处理与数据库`Cursor`相关的所有细节，所以我们不需要对其子类化。我们可以简单地实例化它，传递给它需要的信息，以便它为我们管理`Cursor`。我们可以在`onCreateLoader`回调中这样做：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just as with the previous example, we''ll implement the callbacks in our `Activity`
    subclass. We''re going to use `GridView` to display our album list, so we''ll
    implement an `Adapter` interface to supply views for its cells, and we''ll connect
    the `Adapter` to the `Cursor` created by our `Loader`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前的示例一样，我们将在我们的`Activity`子类中实现回调。我们将使用`GridView`来显示我们的专辑列表，因此我们将实现一个`Adapter`接口来为其单元格提供视图，并将`Adapter`连接到由我们的`Loader`创建的`Cursor`：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Have a look at the parts in bold in the preceding code. We create an `AlbumCursorAdapter`,
    and pass it to the `GridView`, we then initialize our `CursorLoader`. When loading
    is completed, we pass the loaded Cursor to the Adapter, and we're done.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请看前面代码中加粗的部分。我们创建了一个`AlbumCursorAdapter`，并将其传递给`GridView`，然后初始化我们的`CursorLoader`。当加载完成时，我们将加载的Cursor传递给Adapter，任务就完成了。
- en: The remaining piece to implement is `AlbumCursorAdapter`, which is going to
    start out as a very simple class. The job of our `CursorAdapter` is simply to
    map rows of data from the `Cursor` to each `View` in the individual row `View`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的是`AlbumCursorAdapter`，它将从一个非常简单的类开始。我们的`CursorAdapter`的工作只是将`Cursor`中的数据行映射到单个行`View`中的每个`View`。
- en: 'The Android SDK provides the very handy `SimpleCursorAdapter` class, which
    does just what we need; mapping a database data row into an Album Item View. So
    for now we''ll just subclass it and instruct it via constructor parameters which
    layout the inflation for each cell and the `Cursor` fields to map to each `View`
    within that layout:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK提供了非常方便的`SimpleCursorAdapter`类，它正好符合我们的需求；将数据库数据行映射到专辑项视图中。所以现在我们只需继承它，并通过构造函数参数指定每个单元格的布局填充以及映射到该布局中每个`View`的`Cursor`字段：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The layout files and source code are available on the accompanying website.
    When you run this `Activity`, you'll see a grid list where each cell contains
    album artwork, the album artist, and the album name for each album.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件和源代码可在附带的网站上找到。当你运行此`Activity`时，你会看到一个网格列表，其中每个单元格包含每张专辑的艺术作品、专辑艺术家和专辑名称。
- en: Scroll to somewhere in the middle of the list and rotate your device, and you'll
    notice that the Activity restarts and redisplays the grid immediately, without
    losing its place—this is because the `CursorLoader` survived the restart, and
    still holds the `Cursor` object with the same rows loaded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到列表的中间位置，然后旋转你的设备，你会注意到Activity立即重新启动并立即重新显示网格，而不会丢失位置——这是因为`CursorLoader`在重启中幸存下来，并且仍然持有具有相同行的`Cursor`对象。
- en: This is technically all very interesting, but it isn't much to look at. In the
    next section we'll combine our two `Loaders` to implement a scrollable grid displaying
    the album art for each album.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这一切都非常有趣，但看起来并不怎么样。在下一节中，我们将结合我们的两个`Loaders`来实现一个可滚动的网格，显示每张专辑的艺术作品。
- en: Combining Loaders
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合加载器
- en: In the preceding sections we developed a `CursorLoader` that loads a list of
    all available music albums on the system and an `AsynTaskLoader` that does a blocking
    IO operation in the background. Now we are going to use our previous `CursorLoader`
    together with `AsyncTaskLoader` which loads a thumbnail from the album ID to create
    an application that tiles the artwork of all the music albums on the device in
    a scrollable grid, performing all loading in the background.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们开发了一个`CursorLoader`，用于加载系统上所有可用的音乐专辑列表，以及一个`AsynTaskLoader`，它在后台执行阻塞IO操作。现在我们将使用我们之前的`CursorLoader`与`AsyncTaskLoader`结合，从专辑ID加载缩略图，以创建一个应用，将设备上所有音乐专辑的艺术作品以可滚动的网格形式平铺，所有加载都在后台进行。
- en: Thanks to our `CursorLoader`, we already have access to the IDs of the albums
    we need to load—we're displaying only the album name and album artist—so we just
    need to pass those IDs to our `AlbumArtworkLoader` for it to asynchronously load
    the image for us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们的`CursorLoader`，我们已经可以访问需要加载的专辑ID——我们只显示专辑名称和专辑艺术家——所以我们只需将这些ID传递给我们的`AlbumArtworkLoader`，让它为我们异步加载图像。
- en: 'Our `AlbumArtworkLoader` could receive the album ID either on the constructor
    or later, to load an image for a particular `albumId`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AlbumArtworkLoader`可以在构造函数或之后接收专辑ID，以加载特定`albumId`的图像：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll enable `AlbumArtworkLoader` to load a new image instead of its current
    one, by setting a new `albumId`. Since the bitmap is cached (`mData`), just setting
    a new ID won''t suffice—we also need to trigger a reload by using the `Loader.onContentChanged`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过设置一个新的`albumId`来使`AlbumArtworkLoader`加载新的图像而不是当前的图像。由于位图已缓存（`mData`），仅设置新的ID是不够的——我们还需要通过使用`Loader.onContentChanged`来触发重新加载：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `onContentChanged,` as explained before, is a method of the abstract `Loader`
    superclass which will force a background load to occur if our `Loader` is currently
    in the started state. If we're currently stopped, a flag will be set and a background
    load will be triggered next time the `Loader` is started. Either way, when the
    background load completes, `onLoadFinished` will be triggered with the new data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`onContentChanged`是抽象`Loader`超类的一个方法，如果我们的`Loader`当前处于启动状态，它将强制执行后台加载。如果我们当前处于停止状态，将设置一个标志，并在下次`Loader`启动时触发后台加载。无论如何，当后台加载完成后，`onLoadFinished`将触发并带有新数据。
- en: 'We need to implement the `onStartLoading` method to correctly handle the case
    where we were `stopped` when `onContentChanged` was invoked. Let''s remind ourselves
    of what it used to look like:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`onStartLoading`方法，以正确处理在调用`onContentChanged`时我们处于`stopped`状态的情况。让我们回顾一下它曾经的样子：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `onStartLoading` method again delivers its data immediately—if it has any.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStartLoading`方法再次立即提供其数据（如果有的话）。'
- en: It then calls `takeContentChanged` to see if we need to discard our cached `Bitmap`
    and load a new one. If `takeContentChanged` returns true, we invoke `forceLoad`
    to trigger a background load and redelivery.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用 `takeContentChanged` 来查看我们是否需要丢弃缓存的 `Bitmap` 并加载一个新的。如果 `takeContentChanged`
    返回 true，我们调用 `forceLoad` 来触发后台加载和重新发送。
- en: Now we can cause our `AlbumArtworkLoader` to load and cache a different image,
    but a single `AlbumArtworkLoader` can only load and cache one image at a time,
    so we're going to need more than one active instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以让我们的 `AlbumArtworkLoader` 加载和缓存不同的图像，但单个 `AlbumArtworkLoader` 只能一次加载和缓存一个图像，所以我们需要多个活动实例。
- en: 'Let''s walk through the process of modifying `AlbumCursorAdapter` to initialize
    a `AlbumCursorAdapter` for each cell in the `GridView`, and to use those `Loader`s
    to asynchronously load the album artwork and display them:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看修改 `AlbumCursorAdapter` 的过程，以便为 `GridView` 中的每个单元格初始化一个 `AlbumCursorAdapter`，并使用这些
    `Loader` 异步加载专辑艺术作品并显示它们：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have two methods to implement—`newView` and `bindView. GridView` will invoke
    `newView` until it has enough View objects to fill all of its visible cells, and
    from then on it will recycle these same View objects by passing them to `bindView`
    to be repopulated with data for a different cell as the grid scrolls. As a view
    scrolls out of sight, it becomes available for rebinding.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种实现方法——`newView` 和 `bindView`。`GridView` 将会调用 `newView` 直到它有足够的 View 对象来填充所有可见的单元格，然后它将回收这些相同的
    View 对象，通过将它们传递给 `bindView` 来为不同的单元格异步加载数据，随着网格的滚动。当一个视图滚动出视野时，它就变得可以重新绑定。
- en: What this means for us is that we have a convenient method in which to initialize
    our `AlbumArtworkLoaders`—`newView`, and another convenient method in which to
    retask Loader to load a new thumbnail—`bindView`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说意味着我们有一个方便的方法来初始化我们的 `AlbumArtworkLoaders`——`newView`，还有一个方便的方法来重新分配 `Loader`
    以加载一个新的缩略图——`bindView`。
- en: '`newView` first inflates the album item layout for the row and gives to the
    parent view, a unique ID based on the ID generated by the adapter class `hashcode()`
    method and based on the current number of Loaders.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`newView` 首先为行填充专辑项布局并将其传递给父视图，一个基于适配器类 `hashcode()` 方法生成的 ID 和基于当前加载器数量的唯一
    ID。'
- en: 'Later, the unique ID and the `imageView` is passed to a `ArtworkLoaderCallbacks`
    class, which we''ll meet in a moment. `ArtworkLoaderCallbacks` is in turn used
    to initialize a new `Loader`, which shares the ID of the parent View. In this
    way we are initializing a new Loader for each visible row in the grid:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，唯一的 ID 和 `imageView` 被传递给一个 `ArtworkLoaderCallbacks` 类，我们稍后会遇到它。`ArtworkLoaderCallbacks`
    然后用于初始化一个新的 `Loader`，它共享父 View 的 ID。这样我们就在网格中的每一行初始化了一个新的 `Loader`：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In `bindView`, we are recycling each existing `View` to update the image, album
    name, and album artist that are being displayed by that `View`. So the first thing
    we do is clear out the old `Bitmap`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bindView` 中，我们正在回收每个现有的 `View` 以更新显示的图像、专辑名称和专辑艺术家。所以我们首先清除旧的 `Bitmap`。
- en: 'Next we look up the correct `Loader` by ID, extract the ID of the next image
    to load from the `Cursor`, and load it by passing the ID to the method of `AlbumArtworkLoader`—`setAlbumId`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过 ID 查找正确的 `Loader`，从 `Cursor` 中提取下一个要加载的图像的 ID，并通过将 ID 传递给 `AlbumArtworkLoader`
    的方法——`setAlbumId` 来加载它：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We need to add one more method to our `Adapter` so that we can clean up `AlbumArtworkLoaders`
    when we no longer need them. We''ll call these ourselves when we no longer need
    these `Loaders`—for example, when our `Activity` is finishing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的 `Adapter` 添加一个额外的方法，以便在我们不再需要它们时清理 `AlbumArtworkLoaders`。当我们不再需要这些
    `Loaders` 时——例如，当我们的 `Activity` 正在结束时——我们将自己调用这些方法：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s our completed `Adapter`. Next, let''s look at `ArtworkLoaderCallbacks`
    which, as you probably guessed, is just an implementation of `LoaderCallbacks`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的完成后的 `Adapter`。接下来，让我们看看 `ArtworkLoaderCallbacks`，正如你可能猜到的，它只是 `LoaderCallbacks`
    的一个实现：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The only interesting thing `ArtworkLoaderCallbacks` does is create an instance
    of `AlbumArtworkLoader`, and set a loaded Bitmap to its `ImageView`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtworkLoaderCallbacks` 唯一有趣的事情是创建一个 `AlbumArtworkLoader` 的实例，并将加载的 Bitmap
    设置到其 `ImageView` 中。'
- en: 'Our `Activity` is almost unchanged—we need to pass an extra parameter when
    instantiating `AlbumCursorAdapter` and, to avoid leaking the Loaders it creates,
    we need to invoke the `destroyLoaders` method of `AlbumCursorAdapter` in `onPause`
    or `onStop`, if the Activity is finishing:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Activity` 几乎没有变化——我们需要在实例化 `AlbumCursorAdapter` 时传递一个额外的参数，为了避免泄漏它创建的 `Loaders`，我们需要在
    `onPause` 或 `onStop` 中调用 `AlbumCursorAdapter` 的 `destroyLoaders` 方法，如果 `Activity`
    正在结束时：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The full source code is available from the Packt Publishing website. Take a
    look at the complete source code to appreciate how little there actually is, and
    run it on a device to get a feel for just how much functionality `Loaders` give
    you for relatively little effort!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在Packt Publishing网站上找到。查看完整的源代码，以欣赏实际上有多么简洁，并在设备上运行它，以了解`Loaders`只需相对较少的努力就能提供多少功能！
- en: Applications of Loader
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Loader`的应用'
- en: The obvious applications include reading any kind of data from files or databases
    local to the device, or Android content providers, as we've done in the examples
    in this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的用途包括从设备本地的文件或数据库中读取任何类型的数据，或者从Android内容提供者中读取，正如我们在本章的示例中所做的那样。
- en: One strong advantage of `Loaders` over direct use of `AsyncTask` is that their
    lifecycle is very flexible with respect to the `Activity` and `Fragment` lifecycles.
    Without any extra effort we can handle configuration changes such as an orientation
    change.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用`AsyncTask`相比，`Loaders`的一个显著优势是它们的生命周期在`Activity`和`Fragment`生命周期方面非常灵活。我们无需额外努力就能处理配置更改，例如方向变化。
- en: We can even start loading in one `Activity`, navigate through the app, and collect
    the result in a completely separate `Activity`, if that makes sense for our app.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在一个`Activity`中开始加载数据，在应用中导航，并在一个完全独立的`Activity`中收集结果，如果这对我们的应用有意义的话。
- en: In some ways, this decoupling from the Activity lifecycle makes `Loader` a better
    candidate than `AsyncTask` to perform network transfers such as HTTP downloads;
    however, they require more code and still aren't a perfect fit.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这种从`Activity`生命周期中解耦使得`Loader`比`AsyncTask`更适合执行网络传输，如HTTP下载；然而，它们需要更多的代码，并且仍然不是完美的选择。
- en: The framework is very powerful for managing asynchronous data loading; however,
    it does not provide a mechanism to show the loading progress, as we have on the
    `AsyncTask` framework and there is no error handling callback function to manage
    loading errors or exceptions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架在管理异步数据加载方面非常强大；然而，它不提供显示加载进度的机制，正如我们在`AsyncTask`框架中所做的那样，也没有错误处理回调函数来管理加载错误或异常。
- en: To overcome these issues, the developer must extend the basic Loader framework
    classes and implement these patterns to match his needs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，开发者必须扩展基本的`Loader`框架类并实现这些模式以匹配他的需求。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The `Loader` framework in Android does a wonderful job of making it easy to
    load data in the background and deliver it to the main thread when it is ready.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的`Loader`框架在使后台加载数据变得容易并将数据在准备好时传递到主线程方面做得非常出色。
- en: In this chapter we learned about the essential characteristics of all Loaders—background
    loading, caching of loaded data, and a managed lifecycle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了所有`Loader`的基本特征——后台加载、加载数据的缓存以及管理生命周期。
- en: We took a detailed look at `AsyncTaskLoader` as a means to perform arbitrary
    background loading, and `CursorLoader` for asynchronous loading from local database
    Cursors.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细探讨了`AsyncTaskLoader`作为执行任意后台加载的手段，以及`CursorLoader`用于从本地数据库游标异步加载。
- en: We saw that `Loader` can free us from some of the constraints imposed by the
    `Activity` lifecycle, and took advantage of that to continue to work in the background
    even across `Activity` restarts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Loader`可以让我们摆脱`Activity`生命周期强加的一些限制，并利用这一点在`Activity`重启时继续在后台工作。
- en: In the next chapter we'll free ourselves completely from the constraints of
    the `Activity` lifecycle and perform background operations with `Service`, even
    when our app is no longer in the foreground.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完全摆脱`Activity`生命周期的限制，并使用`Service`执行后台操作，即使我们的应用不再处于前台。
