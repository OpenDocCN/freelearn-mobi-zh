["```swift\nstatic func fromOpaque(value: COpaquePointer) -> Unmanaged<Instance> \nfunc toOpaque() -> COpaquePointer \n\n```", "```swift\nlet str0: CFString = \"Test string\" as CFString \nlet bits: Unmanaged<CFString> = Unmanaged.passRetained(str0) \nlet oPtr: COpaquePointer = bits.toOpaque() \nlet ptr: UnsafePointer<CFString> = UnsafePointer(oPtr) \n\nlet oPtr2 = COpaquePointer(ptr) \nlet str1: Unmanaged<CFString> = Unmanaged.fromOpaque(oPtr2) \nstr1.takeRetainedValue() \n\n```", "```swift\n static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged<Instance> \nfunc toOpaque() -> UnsafeMutableRawPointer \n\n```", "```swift\nlet str0: CFString = \"Test string\" as CFString \nlet bits = Unmanaged.passUnretained(str0) \nlet ptr = bits.toOpaque() \n\nlet str1: Unmanaged<CFString> = Unmanaged.fromOpaque(ptr) \nstr1.takeRetainedValue() \n\n```", "```swift\nlet msg: CFString = \"just a few characters\" as CFString \nlet unmgd: Unmanaged<CFString> = Unmanaged.passRetained(msg) \nlet ptr: UnsafeMutablePointer<CFString> = UnsafeMutablePointer(unmgd.toOpaque()) \n// reassign pointer address with new value \nptr[0] = \"testing...\" as CFString \n// use typed access of Int to access CFSTring memory location \nlet u = UnsafePointer<Int>(ptr)[0] \n\n```", "```swift\n    typealias ScoreBag<T> = [T]\n    typealias TriplePointTuple<T> = (T,T,T)\n    typealias AddPlotter<X:Hashable,Y> = Dictionary<X, Y>\n    typealias UndoItem<T> = [Date:T]\n\n```", "```swift\nprotocol Driving {} \nprotocol Parking {} \nprotocol Braking {} \nstruct Car: Driving, Parking, Braking {} \nlet zoomzoom: protocol<Driving, Braking, Parking> = Car() \n\n```", "```swift\nlet zoomzoom: Driving & Braking & Parking = Car() \n\n```", "```swift\npublic protocol Sequence { \n\n    associatedtype Iterator : IteratorProtocol \n\n    typealias Element = Iterator.Element \n\n    public func makeIterator() -> Iterator \n\n   func map<T>(_ transform: (Element) throws -> T)  \nrethrows -> [T] \n\n} \n\n```", "```swift\npublic func rounded(_ rule: FloatingPointRoundingRule) -> Self \npublic mutating func round(_ rule: FloatingPointRoundingRule) \npublic mutating func round() \n\npublic enum FloatingPointRoundingRule { \n   case toNearestOrAwayFromZero \n   case toNearestOrEven \n   case up \n         case down \n   case towardZero \n   case awayFromZero \n} \n\n```", "```swift\n(10.5).rounded(.down) // -> 10.0 \n(5.2).rounded(.up) // -> 6.0 \n\n```"]