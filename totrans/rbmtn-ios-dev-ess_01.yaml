- en: Chapter 1. Getting Ready for RubyMotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"You will never win if you never begin."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*–*Helen Rowland**'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to **RubyMotion** **iOS** development essentials. The goal of this book
    is to quickly acquaint you with RubyMotion and start building applications for
    your favorite iOS device. Ever since the introduction of the first iPhone, followed
    by the iPad, iOS devices have become very popular because of the way they have
    revolutionized how people work, and thereby have begun an era of increased productivity.
    The success behind the phenomenal growth of these devices lies in the applications
    bundled with them, which increases their functionality exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to develop iOS applications with RubyMotion by building sample
    applications from scratch. We will try to have something tangible with a running
    code by the end of every chapter so that you can see a clear progression from
    chapter to chapter. Though RubyMotion and iOS Cocoa APIs are vast, and part of
    a fast-moving framework, we'll focus on the smaller, more stable set of core RubyMotion
    techniques that have crystallized after its release. This means that the knowledge
    you gain here will not become obsolete quickly. This book is written keeping the
    Zero-to-Deployment approach in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Various ways to create iOS applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How RubyMotion is different from other frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RubyMotion installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I develop an iOS application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To develop iOS applications, there are various third-party frameworks available,
    apart from Apple libraries. If we broadly categorize the ways in which we can
    create iOS applications, we can divide them into three ways.
  prefs: []
  type: TYPE_NORMAL
- en: Native apps using Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the most standard way to build your application, by interacting with
    Apple APIs and writing apps in **Objective-C**. Applications made using native
    Apple APIs can use all possible device capabilities, and are relatively more reliable
    and high performing (however, the topic of performance is debatable based on the
    quality of the developer's code).
  prefs: []
  type: TYPE_NORMAL
- en: Mobile web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile web applications are simple web applications extended for mobile web
    browsers, which can be created using standard web technologies such as HTML5\.
    For example, if we browse through [http://www.twitter.com](http://www.twitter.com)
    in a mobile browser, it will be redirected to [http://mobile.twitter.com](http://mobile.twitter.com),
    which renders its corresponding views for mobile devices. These applications are
    easy to create but the downside is that they have limited access to user data
    (for example, phonebook) and hardware (for example, camera).
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These applications are somewhere in between mobile web apps and native applications.
    They are created using common web technologies such as HTML5 and JavaScript and
    have the ability to use device capabilities via their homegrown APIs. Some of
    the popular hybrid frameworks include Rhomobile and Phonegap.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compare the speed of development and user experience, it can be summed
    up with the following diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hybrid applications](img/5220_01_01.jpg)![Hybrid applications](img/5220_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagrams we see that mobile web apps can be created very
    quickly but we have to compromise on user experience. While native apps using
    Objective-C have good user experience, they have a very steep initial learning
    curve for web developers.
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion is good news for both users and developers. Users get an amazing
    experience of a native application and developers are able to develop applications
    rapidly in comparison to applications developed using Objective-C. Let's now learn
    about RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: What is RubyMotion?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RubyMotion is a toolchain that allows developers to develop native iOS applications
    using the Ruby programming language. RubyMotion acts as a compiler that interacts
    with the iOS **SDK** (**Software Development Kit**). This gives us enormous power
    to make use of Apple libraries; therefore, once the application has compiled and
    loaded, the device has no idea whether it's an application made using Objective-C
    or RubyMotion.
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion is a product of HipByte, founded by Laurent Sansonetti.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laurent Sansonetti is a former Apple employee and the brain behind MacRuby.
    MacRuby is the implementation of Ruby on top of Mac OS X core technologies, which
    was maintained by Apple for over 4 years. And the best part is that RubyMotion
    is based on MacRuby.
  prefs: []
  type: TYPE_NORMAL
- en: While developing applications with RubyMotion using Ruby, you always have access
    to the iOS SDK classes. This gives you the benefit of even mixing Objective-C
    and Ruby code, as RubyMotion implements Ruby on top of the Objective-C runtime
    and iOS Foundation classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is RubyMotion?](img/5220_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how a typical RubyMotion application works. The code written in RubyMotion
    is fully compiled into machine code, so the application created by RubyMotion
    is as fast as the one created using Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is RubyMotion?](img/5220_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why RubyMotion?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned what RubyMotion is, but the question that comes to mind
    is, why should we use RubyMotion? There are many reasons why RubyMotion is a good
    choice for building robust iOS apps. The following sections detail a few that
    we think matter the most.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not an Objective-C fan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a newbie developer, Objective-C is an arduous affair. It's complicated to
    code; even for doing a simple thing, we have to write many lines of code. Though
    it is a powerful language and one of the best object-oriented ones available,
    it is time consuming and the learning curve is very steep. On the other hand,
    Ruby is more expressive, simple, and productive in comparison to Objective-C.
    Because of its simplicity, developers can shift their focus onto problem solving
    rather than spending time on trivial stuff, which is taken care by Ruby itself.
    In short, we can say RubyMotion allows us to use the power of Objective-C with
    the simplicity of Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby classes used in RubyMotion are inherited from Objective-C classes. If you
    are familiar with the concept of object-oriented programming, you can understand
    its power. This means we can directly use Apple iOS SDK classes from your RubyMotion
    code. We will be discussing more on this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ruby classes in RubyMotion have the same ancestor as Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a bridge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion apps get direct access to iOS SDK APIs, which means the size of application
    and performance created using RubyMotion is comparable to the one created using
    Objective-C. It implements Ruby on top of the Objective-C runtime and iOS Foundation
    classes. RubyMotion uses a state-of-the-art static compiler based on **Low Level
    Virtual Machine** (**LLVM**), which converts the Ruby source code into a blazing
    fast machine code. The original source code is never present in the application
    bundle. A typical application weighs less than 1 MB, but the size can increase
    depending on the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key features of RubyMotion is that it takes care of memory management.
    Just like **ARC** (**Automatic Reference Counting**) with Xcode 4.4 and above,
    we don't have to take the pain of releasing the memory once an object is no longer
    used. RubyMotion does the magic and we don't need to think about it. It handles
    it on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal-based workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion has a terminal-based workflow; from creation of the application to
    deployment, everything can be done through terminals. If you are used to working
    on terminals, you know it adds to speedier development.
  prefs: []
  type: TYPE_NORMAL
- en: Easy debugging with REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terminal window where you run Rake also gives you the option to debug with
    **REPL** (**Read Evaluate Print Loop**), which lets you use Ruby expressions that
    are evaluated on the spot, and the results are reflected on the simulator while
    the application is still running. The ability to make live changes to the user
    interface and internal application data structures at runtime is extremely useful
    for testing and troubleshooting issues with the application, as this saves a lot
    of time and is much faster than a traditional **edit-compile-run** loop. If this
    confuses you right now, don't worry, as we will discuss more on this powerful
    feature in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REPL is similar to IRB in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: It is extendable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use RubyMotion salted gems easily by just adding them in the `Rakefile`.
    What are RubyMotion salted gems? We can't use all the gems that are available
    for Ruby right now, but there are a lot of gems specifically developed for RubyMotion.
    As the RubyMotion developer community expands, so will its gem bouquet, and this
    will make our application development rapid.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party Objective-C libraries can be easily used in a RubyMotion project.
    It supports CocoaPods, which is a dependency manager for Objective-C libraries,
    making this process a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion has a console-based inbuilt interactive debugger for troubleshooting
    the issues both on a simulator and on a device using **GDB** (**GNU Debugger**).
    GDB is extremely powerful on its own, and RubyMotion uses it for debugging the
    compiled Ruby code. Also, RubyMotion projects are fit for Test Driven Development
    (TDD). We can write a unit test for our code from the beginning. We can use Behavior
    Driven Development (BDD) with RubyMotion, which is integrated into every project.
    We will discuss more about testing in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RubyMine editor also supports RubyMotion and it has a very powerful debugging
    mechanism through breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q.1\. How can we distinguish between the iOS application created by RubyMotion
    and the iOS application created by Objective-C?
  prefs: []
  type: TYPE_NORMAL
- en: You can distinguish based on the user experience of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can distinguish based on the performance of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't distinguish based on the user experience and performance of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Solution: If your answer was option 3, you were right. We can''t distinguish
    between applications created by RubyMotion or Objective-C as the user experience
    and performance are similar.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Q.2\. How can we extend RubyMotion?
  prefs: []
  type: TYPE_NORMAL
- en: We can use Objective-C libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use all Ruby gems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use RubyMotion-flavored gems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't use any other libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Solution: If your answer was option 1 and 3, you were right. Yes, we can use
    Objective-C libraries and also RubyMotion-flavored gems.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RubyMotion installation – furnish your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have got a good introduction to RubyMotion, let's set up our development
    environment; but before that let's run through some of the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for RubyMotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need a Mac OS: we can''t develop iOS applications with RubyMotion on any
    other operating system; so we definitely need a Mac OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OSX 10.6 or higher: RubyMotion requires a Mac running OSX 10.6 or higher. OSX
    10.7 Lion is highly recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ruby: the Ruby framework comes preinstalled with Mac OS X. If you have multiple
    versions of Ruby, we recommend that you use **Ruby Version Manager** (**RVM**).
    For more details, visit [https://rvm.io/](https://rvm.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xcode: next we need to install Xcode, which includes the iOS SDK, developed
    by Apple and essential for developing iOS applications. It can be downloaded from
    the App Store for free. It also includes the iPhone/iPad simulator, which will
    be used for testing our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Line Tools**: after installing the Xcode toolchain, we need to install
    the command-line tools package, which is necessary for RubyMotion. To confirm
    that command-line tools is installed with your Xcode, open `Xcode` in your `Applications`
    folder, go to the **Preferences** window, and click on the **Downloads** tab.
    You should see the **Command Line Tools** package in this list. If it is not yet
    installed, make sure to click on the **Install** button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have an old version of Xcode, run the following command on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will set up the default Xcode path.
  prefs: []
  type: TYPE_NORMAL
- en: Installing RubyMotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion installation is really simple and takes no time at all. RubyMotion
    is a commercial product that you need to purchase from [www.rubymotion.com](http://www.rubymotion.com).
    Once purchased, you will receive your unique license key and installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'RubyMotion installation is a five-step procedure and is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have received the package, run the RubyMotion installer as follows:![Installing
    RubyMotion](img/5220_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read and accept the **EULA** (**End User License Agreement**).![Installing RubyMotion](img/5220_01_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the license number you have received as shown in the following screenshot:![Installing
    RubyMotion](img/5220_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for a short break—it will take a few minutes for RubyMotion to get downloaded
    and installed on your system. You can relax for some time.![Installing RubyMotion](img/5220_01_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yippee!! There is no step 5\. And that's how quick it is to start working with
    RubyMotion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update RubyMotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RubyMotion is a fast-moving framework and we need to upgrade it once there is
    a new release available. Upgrading RubyMotion is again really simple—with one
    command, you can easily upgrade it to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You need to be connected to the Internet for an upgrade to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to work on an old version, you can downgrade using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But we recommend using the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: How do we check we've done everything correctly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have installed our RubyMotion copy, it''s good practice to confirm
    which version we have installed; to do this, go to the terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command outputs the RubyMotion version installed on your machine. If you
    get an error, you need to reinstall.
  prefs: []
  type: TYPE_NORMAL
- en: Pick your own editor – you are not forced to use Xcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With RubyMotion, you are not forced to use Xcode. As every developer is more
    comfortable with a specific editor, you are open to choose what you like. However,
    we recommend the following editors for Ruby development:'
  prefs: []
  type: TYPE_NORMAL
- en: RubyMine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextMate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emacs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RubyMine now provides full support to a RubyMotion project.
  prefs: []
  type: TYPE_NORMAL
- en: How to get help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are facing some issues, the preferred way to get a solution is to discuss
    it at the RubyMotion Google group, ([https://groups.google.com/forum/?fromgroups#!forum/rubymotion](https://groups.google.com/forum/?fromgroups#!forum/rubymotion)),
    where you can interact with fellow developers from the community and get a speedy
    resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you might not get a precise response from the RubyMotion group. Not
    to worry, RubyMotion support is there to rescue you. If you have a feature request,
    an issue, or simply want to ask a question, you can log a support ticket—that
    too from the command line using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will open up a new window in your browser. You can fill and submit the
    form with your query. Your RubyMotion license key, email address, and environment
    details will be added automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RubyMotion community is growing at a very fast pace. In a short span of
    time, a lot of popular RubyMotion gems have been created by developers.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We believe no question is silly. By now you will have many questions in your
    mind regarding RubyMotion. We have tried to answer a few of the most frequently
    asked questions (FAQs) related to topics covered so far in this section. Here
    are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Q1\. Are the applications created by RubyMotion in keeping with Apple guidelines?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. Yes, RubyMotion strongly follows the review guidelines provided by Apple.
    Many applications created using RubyMotion are already available at the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. Will my RubyMotion application work on a Blackberry, Android, or Windows
    phone?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. No, applications created using RubyMotion are only for iOS devices;
    it is an alternative to programming in Objective-C. For a single-source multi-device
    application, we would recommend hybrid frameworks such as Rhomobile, Phonegap,
    and Titanium. For android development using Ruby, you can try Rubuto.
  prefs: []
  type: TYPE_NORMAL
- en: Q3\. Can I share an application with someone?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. Yes and no. With the Apple Developer Program membership, you can share
    your application only for testing purposes with a maximum of 100 devices, where
    each device has to be registered individually with Apple. Also, you cannot distribute
    your application on the App Store for testing. Once you have finished developing
    your application and are ready to ship, you can submit it to Apple for an App
    Store review.
  prefs: []
  type: TYPE_NORMAL
- en: Q4\. Can I use Ruby gems?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. Yes and no. No because we can't use normal Ruby gems, which you generally
    use in your Ruby on Rails projects; and yes because you can use gems that are
    specifically developed for RubyMotion, and there are already many such gems.
  prefs: []
  type: TYPE_NORMAL
- en: Q5\. Will my application work on iPad and iPod Touch?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. Absolutely, your application will work on any iOS devices, namely iPhone,
    iPad, and iPod Touch.
  prefs: []
  type: TYPE_NORMAL
- en: Q6 Is Ruby allowed on the App Store?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. The App Store can't distinguish between applications made using Objective-C
    and those made using RubyMotion. So, no worries, our RubyMotion applications are
    fit for the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Q7\. Can I use third-party Objective-C libraries?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. Certainly. Third-party Objective-C libraries can be used in your project.
    RubyMotion provides integration with the CocoaPods dependency manager, which helps
    in reducing the hassle. You also can use C/C++ code provided that you wrap it
    into the Objective-C classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Q8\. Is RubyMotion open source?
  prefs: []
  type: TYPE_NORMAL
- en: Answer. RubyMotion as a toolchain is open source (available at GitHub). The
    closed source part is the Ruby runtime, which is, however, very similar to MacRuby
    runtime (which is open source).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move to the next chapter, let's review all that we have learned so
    far. We first discussed the different ways to create iOS applications. Then we
    started with RubyMotion and discussed why to use it. And in the last section,
    we learned how to get started with RubyMotion and which editor fits with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our RubyMotion framework up and running, the next obvious task
    is to create our very first application, the most rudimentary `Hello World` application.
    In the next chapter, we will also learn the structure of the RubyMotion application
    in general.
  prefs: []
  type: TYPE_NORMAL
