- en: '*Chapter 6*: Testing, Loading, and Saving Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：测试、加载数据和保存数据'
- en: At the moment, we have structures to hold the information of one to-do item.
    A usable to-do item app has to show and manage several to-do items. In addition,
    when the user closes the app and opens it again, they expect the to-do items to
    still be there.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有结构来存储单个待办事项的信息。一个可用的待办事项应用必须显示和管理多个待办事项。此外，当用户关闭应用并再次打开时，他们期望待办事项仍然存在。
- en: This means our app needs structures that can store and load information of a
    list of to-do items.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用需要能够存储和加载待办事项列表信息的结构。
- en: In this chapter, we will add a class that stores and loads a list of to-do items
    to and from the filesystem of the iOS device. We will use the JSON format because
    it is a common choice in iOS development. It has the nice benefit in that it is
    easily readable by humans and computers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加一个类，用于将待办事项列表存储到 iOS 设备的文件系统中，并从中加载。我们将使用 JSON 格式，因为它在 iOS 开发中是一个常见的选择。它有一个很好的好处，那就是它既易于人类阅读，也易于计算机读取。
- en: 'The chapter is structured as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结构如下：
- en: Publishing changes with Combine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Combine 发布更改
- en: Checking items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查项目
- en: Storing and loading `ToDoItem`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储 `ToDoItem` 和加载
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码在此处可用：[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06).
- en: Publishing changes with Combine
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Combine 发布更改
- en: In today's iOS apps, communication between different parts is often implemented
    using the **Combine** framework by Apple. In Combine, data changes are published
    and can be subscribed to. This design pattern helps to decouple the code and make
    it easier to maintain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的 iOS 应用中，不同部分之间的通信通常使用苹果的 **Combine** 框架来实现。在 Combine 中，数据更改被发布并可以被订阅。这种设计模式有助于解耦代码并使其更容易维护。
- en: We will use Combine in our `ToDoItemStore` to inform, for example, the table
    view controller that something changed and the user interface should be updated
    with the new data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `ToDoItemStore` 中使用 Combine 来通知，例如，表格视图控制器有变化，用户界面应该使用新数据更新。
- en: Open Project Navigator and select the `ToDoItemStoreTests`. Import the `ToDo`
    module (`@testable import ToDo`) and remove the two test method templates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目导航器并选择 `ToDoItemStoreTests`。导入 `ToDo` 模块 (`@testable import ToDo`) 并移除两个测试方法模板。
- en: Testing asynchronous Combine code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异步 Combine 代码
- en: 'Up to now, all the code we''ve tested has been synchronous code. Publishing
    values in Combine is asynchronous. To be able to test Combine code, we need a
    way to halt the test and wait until the code we want to test is executed. `XCTest`
    provides `XCTestExpectation` for this task. Let''s see how this works:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们测试的所有代码都是同步代码。在 Combine 中发布值是异步的。为了能够测试 Combine 代码，我们需要一种方法来暂停测试并等待我们想要测试的代码执行。`XCTest`
    提供了 `XCTestExpectation` 来完成这项任务。让我们看看它是如何工作的：
- en: 'Add the following code to `ToDoItemStoreTests`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ToDoItemStoreTests` 中：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `toDoItemStore`, but using `sut` makes it easier to read, and it also allows
    us to copy and paste test code into other tests when appropriate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`toDoItemStore`，但使用 `sut` 使其更容易阅读，并且它还允许我们在适当的时候将测试代码复制粘贴到其他测试中。'
- en: 'The test is not yet finished, but it already fails because Xcode cannot find
    `ToDoItemStore` in the scope. Open Project Navigator again and select the `ToDoItemStore.swift`.
    Add the following class definition to `ToDoItemStore.swift`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试尚未完成，但它已经失败了，因为 Xcode 在作用域中找不到 `ToDoItemStore`。再次打开项目导航器并选择 `ToDoItemStore.swift`。将以下类定义添加到
    `ToDoItemStore.swift` 中：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is enough to make the test code compilable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以使测试代码可编译。
- en: 'Run the tests to make sure that they all pass and we can continue writing tests.
    Add the following code to `test_add_shouldPublishChange()`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确保它们全部通过，然后我们可以继续编写测试。将以下代码添加到 `test_add_shouldPublishChange()` 中：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we create an instance of `ToDoItemStore`. Next, we need an expectation
    to wait for the asynchronous execution of our Combine code. With `description`,
    we inform our future selves why we need this expectation. To figure out whether
    `publisher` worked as expected, we need to subscribe to it in the test and check
    the published value. We will store the value in the `receivedItems` variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`ToDoItemStore`实例。接下来，我们需要一个期望来等待我们的Combine代码的异步执行。通过`description`，我们告知未来的自己为什么需要这个期望。为了确定`publisher`是否按预期工作，我们需要在测试中订阅它并检查发布值。我们将值存储在`receivedItems`变量中。
- en: The last line is the beginning of the subscription to the publisher, but we
    have to pause before writing the rest because Xcode complains that **Value of
    type 'ToDoItemStore' has no member 'itemPublisher'**. This means we need to write
    some code in the main target to make the test compile again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是订阅发布者的开始，但我们必须暂停，因为Xcode抱怨说**类型`ToDoItemStore`没有成员`itemPublisher`**。这意味着我们需要在主目标中编写一些代码，以便再次使测试可编译。
- en: 'First, we need to import the Combine framework. Then, we can add the publisher,
    like this:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入Combine框架。然后，我们可以添加发布者，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you haven't worked with Combine or Generics yet, this syntax might look a
    bit strange. `[ToDoItem]` in `<[ToDoItem], Never>` means that the publisher sends
    arrays of `ToDoItems`. The second part, `Never`, is the failure type of this publisher.
    `Never` means that this publisher cannot fail. In summary, `CurrentValueSubject<[ToDoItem],
    Never>([])` creates an instance of a `CurrentValueSubject` publisher that sends
    arrays of `ToDoItems` that never fail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用Combine或泛型，这个语法可能看起来有点奇怪。`<[ToDoItem], Never>`中的`[ToDoItem]`表示发布者发送`ToDoItems`数组。第二部分`Never`是此发布者的失败类型。`Never`表示此发布者不能失败。总之，`CurrentValueSubject<[ToDoItem],
    Never>([])`创建了一个发送`ToDoItems`数组的`CurrentValueSubject`发布者实例，这些数组永远不会失败。
- en: This fixes the error reported by the static analyzer. We can switch back to
    the test code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了静态分析器报告的错误。我们可以切换回测试代码。
- en: 'Import Combine below the existing import statements and change the code in
    `test_add_shouldPublishChange()` so that it looks like this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有导入语句下方导入Combine，并更改`test_add_shouldPublishChange()`中的代码，使其看起来像这样：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This does not compile. But before we switch back to the production code, let''s
    see what we added here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这无法编译。但在我们切换回生产代码之前，让我们看看我们在这里添加了什么：
- en: First, we drop the first published value from `itemPublisher` using `dropFirst()`.
    We do this because a `CurrentValueSubject` publisher publishes the first current
    value as soon as we subscribe to it. But in the test, we only want to assert that
    the changes have been published.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用`dropFirst()`从`itemPublisher`中丢弃第一个发布的值。我们这样做是因为`CurrentValueSubject`发布者在我们订阅它时立即发布第一个当前值。但在测试中，我们只想断言更改已被发布。
- en: Next, we subscribe to the publisher using `sink(receiveValue:)`. The published
    value is passed into the `receivedValue` parameter. You can't see the parameter
    name in the code because we are using the trailing closure syntax as it is common
    in iOS development. We store the received value into the `receivedItems` variable.
    At this point, the asynchronous code we waited for in the test is finished. We
    tell the test runner that we don't need to wait any further by calling `fulfill()`
    on the expectation.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`sink(receiveValue:)`订阅发布者。发布的值传递到`receivedValue`参数中。你无法在代码中看到参数名称，因为我们正在使用尾随闭包语法，这在iOS开发中很常见。我们将接收到的值存储到`receivedItems`变量中。在这个时候，我们在测试中等待的异步代码已经完成。我们通过在期望上调用`fulfill()`来告诉测试运行器我们不再需要等待。
- en: The last two lines in this code are the execution of the method we want to test.
    We assume here that `ToDoItemStore` has an `add(_:)` method that allows us to
    add to-do items to the item store. As we haven't written this method yet, Xcode
    is complaining and we have to switch back to the production code. Follow the next
    step for that.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码的最后两行是我们想要测试的方法的执行。我们假设`ToDoItemStore`有一个`add(_:)`方法，允许我们将待办事项添加到项目存储中。由于我们还没有编写这个方法，Xcode在抱怨，我们必须切换回生产代码。按照下一步进行。
- en: 'Add the following code to `ToDoItemStore`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ToDoItemStore`中：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This makes the test compilable again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试再次可编译。
- en: 'Switch back to the test code and add the last three lines in the following
    code to `test_add_shouldPublishChange()`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回测试代码，并在以下代码中添加最后三行到`test_add_shouldPublishChange()`：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With `wait(for:timeout:)`, we tell the test runner to wait at this point until
    all expectations in the `first` parameter are fulfilled. If all the expectations
    are not fulfilled after the timeout has passed, the test fails. Next, we cancel
    the publisher. If we omitted this line, the compiler could remove the subscription
    because it looks like it is not used anywhere in the code. In the last line, we
    compare the received value with what we expect.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wait(for:timeout:)`，我们告诉测试运行器在此处等待，直到 `first` 参数中的所有期望都得到满足。如果超时后所有期望都没有得到满足，测试将失败。接下来，我们取消发布者的订阅。如果我们省略了这一行，编译器可能会删除订阅，因为它看起来在代码的任何地方都没有被使用。在最后一行，我们比较接收到的值与我们期望的值。
- en: Finally, we can run the test. As expected, the test we just added fails because
    the publisher hasn't published anything yet.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行测试。正如预期的那样，我们刚刚添加的测试失败了，因为发布者还没有发布任何内容。
- en: 'We would like to use the assertion like this: `XCTAssertEqual(receivedItems,
    [toDoItem])`. But this is not possible at the moment because `ToDoItem` does not
    conform to the `Equatable` protocol, which tells the compiler how to treat equality
    between two instances. We will fix that soon. But first, we need to make the tests
    green again.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用这样的断言：`XCTAssertEqual(receivedItems, [toDoItem])`。但目前还不行，因为 `ToDoItem`
    没有遵守 `Equatable` 协议，这告诉编译器如何处理两个实例之间的相等性。我们很快就会解决这个问题。但首先，我们需要让测试再次通过绿色。
- en: 'Change the code in `ToDoItemStore` so that it looks like this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ToDoItemStore` 中的代码，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this code, we added a `private` property to hold the to-do items in the
    item store. Whenever this property changes (for example, when a new item is added),
    it is published using the item publisher. As a result, in the `add(_:)` method,
    we only have to append the item to the items list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们在项目存储中添加了一个 `private` 属性来保存待办事项。每当这个属性发生变化（例如，当添加新项目时），它就会使用项目发布者进行发布。因此，在
    `add(_:)` 方法中，我们只需要将项目追加到项目列表中。
- en: Run the tests. All tests pass.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。所有测试通过。
- en: Now let's tackle the problem of `ToDoItem` not being equatable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解决 `ToDoItem` 不具有相等性的问题。
- en: Making ToDoItem equatable
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 ToDoItem 具有相等性
- en: 'The step of making `ToDoItem` equatable is a refactoring step. Up to this point,
    the code worked without `ToDoItem` being equatable. But the readability of the
    test would greatly benefit if we could use `XCTAssertEqual` directly on an array
    of `ToDoItems`. The following steps show you how to do that:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使 `ToDoItem` 具有相等性的步骤是一个重构步骤。到目前为止，代码在没有 `ToDoItem` 具有相等性的情况下也能工作。但如果我们可以直接在
    `ToDoItems` 数组上使用 `XCTAssertEqual`，测试的可读性将大大提高。以下步骤展示了如何做到这一点：
- en: 'First, add the `Equatable` protocol to the declaration of `ToDoItem`, like
    this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 `Equatable` 协议添加到 `ToDoItem` 声明中，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, do the same for the `Location` structure:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对 `Location` 结构体做同样的处理：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add the following method to the `Location` struct:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下方法添加到 `Location` 结构体中：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If Swift cannot automatically add `Equatable` conformance (for example, because
    one of the properties isn't `Equatable` itself), we need to add the `== (lhs:rhs:)`
    class method. The method looks a bit complicated but this is just because the
    `coordinate` property is optional. So, we also have to respect the cases when
    one coordinate is nil and the other isn't.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Swift 无法自动添加 `Equatable` 兼容性（例如，因为其中一个属性本身不是 `Equatable`），我们需要添加 `== (lhs:rhs:)`
    类方法。这个方法看起来有点复杂，但这只是因为 `coordinate` 属性是可选的。因此，我们还需要考虑一个坐标为 nil 而另一个不为 nil 的情况。
- en: 'Now, go back to `test_add_shouldPublishChange()` and replace the assertion
    call at the end with this:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到 `test_add_shouldPublishChange()` 并将最后的断言调用替换为以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the tests. All tests pass. The assertion now looks way better and we assert
    exactly what we expect from the test. But the test is still hard to read. All
    that Combine code is distracting from the main objective of the test.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。所有测试通过。现在的断言看起来好多了，我们确实断言了我们期望测试的结果。但是测试仍然难以阅读。所有那些 Combine 代码都分散了测试的主要目标。
- en: 'Let''s add a helper function to the test case to improve the test code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在测试用例中添加一个辅助函数来改进测试代码：
- en: 'The helper function we are going to add is inspired by a blog post ([https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/](https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/))
    by *John Sundell*. Add the following code at the end of `ToDoItemStoreTests.swift`
    but outside of the `ToDoItemStoreTests` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要添加的辅助函数受到了一篇博客文章的启发（[https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/](https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/)）由
    *John Sundell* 编写。在 `ToDoItemStoreTests.swift` 文件的末尾添加以下代码，但不要在 `ToDoItemStoreTests`
    类内部：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is similar to the code we wrote in `test_add_shouldPublishChange()`.
    It is modified a bit to make it work as an extension of `XCTestCase`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前在 `test_add_shouldPublishChange()` 中编写的代码类似。它经过一些修改，以便作为 `XCTestCase`
    的扩展工作。
- en: 'Now, we can replace the test code with the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以用以下代码替换测试代码：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This change makes the test easy to understand. Run the tests again. All tests
    still pass.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改使得测试易于理解。再次运行测试。所有测试仍然通过。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `wait` method we just added to `XCTestCase` can throw an error. As a result,
    we had to add the `try` keyword to the call of this method. We could wrap the
    call in a `do-catch` block but there is a better way. When we mark the test method
    itself as `throws`, an error thrown during the test invocation is registered by
    the test runner as a test failure. This again makes the test easier to read and
    understand. During the course of this book, we will always use this feature of
    `XCTest` instead of writing `do-catch` blocks in test methods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加到 `XCTestCase` 的 `wait` 方法可以抛出错误。因此，我们不得不在方法的调用中添加 `try` 关键字。我们可以将调用包裹在
    `do-catch` 块中，但有一个更好的方法。当我们将测试方法本身标记为 `throws` 时，测试调用期间抛出的错误会被测试运行器注册为测试失败。这再次使得测试更容易阅读和理解。在本书的整个过程中，我们将始终使用
    `XCTest` 的这个功能，而不是在测试方法中编写 `do-catch` 块。
- en: But how do we know that we didn't break the test? Let's make sure that the test
    can still fail. Go to `ToDoItemStore` and remove the `items.append(item)` line
    from `add(_:)`. Run the tests to make sure that the test we changed fails now.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但我们如何知道我们没有破坏测试？让我们确保测试仍然可以失败。转到 `ToDoItemStore` 并从 `add(_:)` 中删除 `items.append(item)`
    行。运行测试以确保我们更改的测试现在失败。
- en: 'But something is strange now. The test failure is shown as gray instead of
    red. The reason is that the failure is in the `wait` function we added to `XCTestCase`.
    To make the test failure be reported at the call site of that function, we need
    to change the function to this (we only show the relevant lines here):'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但现在有些奇怪。测试失败显示为灰色而不是红色。原因是失败出现在我们添加到 `XCTestCase` 的 `wait` 函数中。为了使测试失败在函数的调用位置被报告，我们需要将函数更改为以下形式（这里只显示相关行）：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function now has two more parameters, `file` and `line`. They are set to
    the default values, `#file` and `#line`, respectively. These parameters are then
    used in the call to `XCTUnwrap`. When `XCTUnwrap` now fails, Xcode uses the `file`
    and `line` parameters to figure out where this function was called and reports
    the failure at the call site. Run the tests again to see the difference.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在有两个额外的参数，`file` 和 `line`。它们分别设置为默认值 `#file` 和 `#line`。然后，这些参数被用于调用 `XCTUnwrap`。当
    `XCTUnwrap` 现在失败时，Xcode 使用 `file` 和 `line` 参数来确定这个函数被调用的位置，并在调用位置报告失败。再次运行测试以查看差异。
- en: Then, make the test pass again by adding the line you deleted.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过添加你删除的行，再次使测试通过。
- en: 'In the next section, we will implement an essential feature for a to-do list
    app: *checking items*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个待办事项应用的基本功能：*勾选项目*。
- en: Checking items
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 勾选项目
- en: In a to-do app, the user needs to be able to mark to-do items as done. This
    is an important feature of a to-do app because part of the reason people use such
    apps is the satisfying feeling when marking a to-do as done.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在待办事项应用中，用户需要能够将待办事项标记为已完成。这是待办事项应用的一个重要功能，因为人们使用此类应用的部分原因是在标记待办事项为已完成时获得的满足感。
- en: So, our app also needs this feature. As the process of building this app is
    driven by tests, we start with a new test for this feature. But before we can
    add the test for this feature, we need to think about how we can assert in the
    test that the feature works. This means we need a way to get all the to-do items
    that are already done. The easiest way to differentiate the done to-do items from
    the ones that are still to be done is with a property in the to-do item itself.
    This way, we can filter all the to-do items according to the value of that property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的应用也需要这个功能。由于构建此应用的过程是由测试驱动的，我们首先为这个功能编写一个新的测试。但在我们可以添加这个功能的测试之前，我们需要考虑如何在测试中断言这个功能是否工作。这意味着我们需要一种方法来获取所有已经完成的待办事项。区分已完成和尚未完成的待办事项的最简单方法是在待办事项本身中添加一个属性。这样，我们可以根据该属性的值过滤所有待办事项。
- en: 'With this plan, we can start writing the test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个计划，我们可以开始编写测试：
- en: 'Add the following method to `ToDoItemStoreTests.swift`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `ToDoItemStoreTests.swift`：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first four lines of this test, we set up `ToDoItemStore` with two to-do
    items. Next, we wait for the publisher and try to check the to-do item. Xcode
    tells us that the `check(_:)` method is missing. As the test code does not compile
    right now, we need to switch to the production code and add the `check(_:)` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试的前四行中，我们使用两个待办事项设置`ToDoItemStore`。接下来，我们等待发布者并尝试检查待办事项。Xcode告诉我们`check(_:)`方法缺失。由于测试代码现在无法编译，我们需要切换到生产代码并添加`check(_:)`方法。
- en: 'Go to `ToDoItemStore.swift` and add the following method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemStore.swift`并添加以下方法：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the tests to make the test code aware of this change. The test fails because
    the publisher does not publish anything when we call the `check(_:)` method. Change
    the code of the `check` method to the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以使测试代码意识到这个变化。测试失败，因为我们调用`check(_:)`方法时，发布者没有发布任何内容。将`check`方法的代码更改为以下：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Wait a minute! This is not what the `check` method should do. Yes, you are right.
    This is just the simplest code that makes the test at this stage pass. In TDD,
    you should always write the simplest code that makes the test pass. If you know
    the code is wrong, you need to add more tests until the feature actually works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！这个`check`方法不应该这样做。是的，你说得对。这只是使测试在这个阶段通过的最简单代码。在TDD中，你应该总是编写使测试通过的最简单代码。如果你知道代码是错误的，你需要添加更多测试，直到功能真正工作。
- en: 'Run the tests to confirm that all tests pass. Open `ToDoItemStore.swift` and
    change the code in `test_check_shouldPublishChangeInDoneItems()` such that it
    looks like this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试都通过。打开`ToDoItemStore.swift`并更改`test_check_shouldPublishChangeInDoneItems()`中的代码，使其看起来像这样：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last two lines before the closing curly braces are new. In these two lines,
    we first filter all done to-do items, and then we assert that the result is an
    array with only the to-do item we checked.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束括号前的最后两行是新的。在这两行中，我们首先过滤所有完成的待办事项，然后断言结果是一个只包含我们检查的待办事项的数组。
- en: 'The static analyzer of Xcode tells us that the `ToDoItem` type does not have
    a property with the name `done`. Open `ToDoItem.swift` and add this property:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode的静态分析器告诉我们`ToDoItem`类型没有名为`done`的属性。打开`ToDoItem.swift`并添加此属性：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, the code compiles again. Run the tests. The `test_check_shouldPublishChangeInDoneItems()`
    test fails because the array with the filtered items is empty. This is expected
    because the code we added to `check(_:)` does not check any item. It just adds
    a new item with an empty title.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码可以编译了。运行测试。`test_check_shouldPublishChangeInDoneItems()`测试失败，因为过滤后的项目数组为空。这是预期的，因为我们在`check(_:)`中添加的代码没有检查任何项目。它只是添加了一个带有空标题的新项目。
- en: 'Go back to `ToDoItemStore.swift`. We need to replace the to-do item in the
    array with the one in which we changed the `done` property to `true`. Replace
    the `check` method with the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`ToDoItemStore.swift`。我们需要将数组中的待办事项替换为我们更改了`done`属性为`true`的那个。将`check`方法替换为以下代码：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we get a mutable copy of the item. Next, we change `done` to `true` and
    finally, we replace the item in the items array with the changed item.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取项目的可变副本。然后，我们将`done`改为`true`，最后，我们将更改后的项目替换到项目数组中。
- en: Even though this should make the test pass, it still fails. Click the red diamond
    next to the failure message to expand it. Read the message carefully. The test
    fails because the two arrays are not the same. The to-do item in the result array
    has another value in the `done` property.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这应该使测试通过，但它仍然失败了。点击失败信息旁边的红色菱形以展开它。仔细阅读信息。测试失败是因为两个数组不相同。结果数组中的待办事项在`done`属性中有一个不同的值。
- en: '![Figure 6.1 – Expanded failure message telling us that the items are different'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 扩展的失败信息告诉我们项目不同'
- en: '](img/Figure_6.01_B18127.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B18127.jpg)'
- en: Figure 6.1 – Expanded failure message telling us that the items are different
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 扩展的失败信息告诉我们项目不同
- en: This makes sense. By adding the `done` property, we changed how Swift figures
    out whether two to-do items are the same. This is not what we want. A to-do item
    should have an identity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的。通过添加`done`属性，我们改变了Swift确定两个待办事项是否相同的方式。这不是我们想要的。待办事项应该有一个身份。
- en: 'Let''s add a property that provides the to-do item with an identity. Open `ToDoItem.swift`
    and replace the `ToDoItem` structure with the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个属性，为待办事项提供身份。打开`ToDoItem.swift`并将`ToDoItem`结构替换为以下代码：
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this code, we add an ID that is set when an item is created. In addition,
    we use this `id` property to figure out whether two to-do items are the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们添加了一个在创建项目时设置的 ID。此外，我们使用这个 `id` 属性来确定两个待办事项是否相同。
- en: Run the tests. All tests pass.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。所有测试都通过。
- en: 'Before we move on, we have to clean up the tests a bit. In the first line of
    each test, we create the system under test (`sut`). This code should be put into
    `setUpWithError()`. First, add the following property to `ToDoItemStoreTests`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须稍微清理一下测试。在测试的每一行的第一行，我们创建了一个系统测试（`sut`）。这段代码应该放入 `setUpWithError()`
    中。首先，将以下属性添加到 `ToDoItemStoreTests`：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, change `setUpWithError()` and `tearDownWithError()` like this:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `setUpWithError()` 和 `tearDownWithError()` 更改为以下内容：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can remove the following line of code from each of the tests:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从每个测试中删除以下代码行：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This makes the tests easier to understand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试更容易理解。
- en: We can now add and check to-do items using our `ToDoItemStore`. But at the moment,
    the to-do items are only held in memory as long as the app runs. `ToDoItemStore`
    needs to store the to-do items somewhere and load them into memory as soon as
    the app starts again. In the next section, we will implement exactly this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的 `ToDoItemStore` 添加和检查待办事项。但到目前为止，待办事项只会在应用程序运行期间保留在内存中。`ToDoItemStore`
    需要将待办事项存储在某个地方，并在应用程序再次启动时立即将它们加载到内存中。在下一节中，我们将实现这一点。
- en: Storing and loading ToDoItems
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和加载待办事项
- en: To test storing and loading to-do items, we first need to create an instance
    of the `ToDoItemStore` class, add a to-do item, destroy that store instance, and
    create a new one. When we add a to-do item in the first instance, all items should
    be stored in the filesystem. When creating the second instance, the stored items
    should be loaded again from the filesystem. This means when we find the item we
    added in the first instance after we created the second instance, storing and
    loading works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试存储和加载待办事项，我们首先需要创建 `ToDoItemStore` 类的实例，添加一个待办事项，销毁该存储实例，然后创建一个新的实例。当我们第一次实例中添加待办事项时，所有项目都应存储在文件系统中。当创建第二个实例时，存储的项目应再次从文件系统中加载。这意味着当我们创建第二个实例后找到我们第一次实例中添加的项目时，存储和加载是有效的。
- en: Implementing storing and loading
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储和加载
- en: 'It is essential that the test controls the environment needed for itself. This
    means for storing and loading to-do items, the test needs to control where the
    items are stored. For example, if we used Core Data to persist the to-do items,
    the test would be responsible for setting up a fake Core Data store just used
    for the test. In our app, we will store the to-do items in a JSON file. So, the
    test needs to control where the JSON file is stored. Let''s see how this can be
    done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试控制自身所需的环境是至关重要的。这意味着对于存储和加载待办事项，测试需要控制项目存储的位置。例如，如果我们使用 Core Data 来持久化待办事项，测试将负责设置一个仅用于测试的假
    Core Data 存储。在我们的应用程序中，我们将待办事项存储在 JSON 文件中。因此，测试需要控制 JSON 文件存储的位置。让我们看看如何做到这一点：
- en: 'Add the following test method code to `ToDoItemStore`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法代码添加到 `ToDoItemStore`：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this test, we don't use the instance created in `setUpWithError()` because
    we need to pass in the name of the store to be used. Xcode complains that we passed
    an argument to a call that takes no arguments. This means we have to pause writing
    the test code and switch to the production code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们不使用 `setUpWithError()` 中创建的实例，因为我们需要传递要使用的存储的名称。Xcode 抱怨我们向一个不接受任何参数的调用传递了一个参数。这意味着我们必须暂停编写测试代码，并切换到生产代码。
- en: 'Add the following initializer to `ToDoItemStore`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下初始化器添加到 `ToDoItemStore`：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is enough to make the test compile again. This initializer allows passing
    the filename for the JSON file into `ToDoItemStore`. The `fileName` parameter
    has a default value because in the production code, the `ToDoItemStore` class
    should control where the file is stored.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以让测试再次编译。这个初始化器允许将 JSON 文件的文件名传递给 `ToDoItemStore`。`fileName` 参数有一个默认值，因为在生产代码中，`ToDoItemStore`
    类应该控制文件存储的位置。
- en: 'Now we can write the rest of the test code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写测试代码的其余部分：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code looks a bit intimidating, but it only contains concepts we''ve already
    covered. Let''s go over that code step by step:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来有点令人畏惧，但它只包含我们已经覆盖过的概念。让我们一步一步地过一下这段代码：
- en: We create an instance of `ToDoItemStore` and a test expectation.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ToDoItemStore` 的实例和一个测试期望。
- en: Next, we add an item to the to-do item store and destroy the store by setting
    it to nil.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将一个项目添加到待办事项存储中，并通过将其设置为 nil 来销毁存储。
- en: Then, we create a new to-do item store and subscribe to its `itemPublisher`.
    But this time, we do not drop the first published value from the publisher. As
    the publisher is a `CurrentValueSubject` structure, the subscriber receives the
    current value as soon as it subscribes to the publisher.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的待办事项存储库并订阅其`itemPublisher`。但这次，我们不会丢弃发布者中的第一个发布值。因为发布者是一个`CurrentValueSubject`结构，订阅者一旦订阅发布者就会立即接收到当前值。
- en: Finally, we wait for the asynchronous execution of the Combine code and assert
    that the published items array contains the item we added to the initial to-do
    item store.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们等待Combine代码的异步执行，并断言发布的物品数组包含我们添加到初始待办事项存储库中的物品。
- en: Run the tests. This test fails, because we haven't implemented storing and loading
    yet. Let's implement the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。这个测试失败了，因为我们还没有实现存储和加载。让我们实现代码。
- en: 'We need to store the filename in a property and access it when we store and
    load the items. Add the following property and change the initializer to set that
    property:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在属性中存储文件名，并在存储和加载项目时访问它。添加以下属性并更改初始化器以设置该属性：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to make `ToDoItem` convertible to JSON format. Swift can do
    this for us if all the properties of a type are convertible to JSON. The only
    thing we as the developer have to do is to add the `Codable` protocol to the type.
    Change the declaration of `ToDoItem` such that it reads like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将`ToDoItem`转换为JSON格式。如果类型的所有属性都可以转换为JSON，Swift可以为我们完成这个任务。我们作为开发者需要做的只是将`Codable`协议添加到类型中。更改`ToDoItem`的声明，使其看起来像这样：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Xcode complains that `Location` property does not conform to `Codable` yet.
    Change the declaration of `Location` to the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode 抱怨 `Location` 属性还没有遵循 `Codable`。将 `Location` 的声明更改为以下内容：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now Xcode tells us that `Location` does not conform to `Codable`. Oh, bummer!
    `CLLocationCoordinate2D` does not conform to `Codable`. We could implement the
    conformance ourselves, but there is an easier way. We create a `Coordinate` struct
    that serves the same purpose but is `Codable`. Create a new Swift file with the
    *⌘**N* shortcut and call it `Coordinate`. Set **Group** to **ToDo** and make sure
    that it is added to the **ToDo** target.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Xcode 告诉我们`Location`不遵循`Codable`。哦，糟糕！`CLLocationCoordinate2D`也不遵循`Codable`。我们可以自己实现这个遵循，但有一个更简单的方法。我们创建一个`Coordinate`结构，它具有相同的功能，但却是`Codable`的。使用*⌘**N*快捷键创建一个新的Swift文件，并将其命名为`Coordinate`。将**组**设置为**ToDo**，并确保它被添加到**ToDo**目标中。
- en: '![Figure 6.2 – Creating a file for the Coordinate structure'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 为坐标结构创建文件'
- en: '](img/Figure_6.02_B18127.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B18127.jpg)'
- en: Figure 6.2 – Creating a file for the Coordinate structure
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 为坐标结构创建文件
- en: 'Add the following code to the new file:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新文件中：
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As Double is Codable, a structure only consisting of Double properties is also
    Codable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Double是可编码的，只包含Double属性的架构也是可编码的。
- en: 'Now we can replace the CLLocationCoordinate2D type in Location with our new
    Coordinate type:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以用我们新的Coordinate类型替换Location中的CLLocationCoordinate2D类型：
- en: '[PRE32]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this change, we no longer depend on Core Location and can remove its import
    from `Location.swift`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们不再依赖于Core Location，可以将其导入从`Location.swift`中移除。
- en: 'We have changed some code. How do we make sure that everything we implemented
    before still works? With our tests! To do that, we first have to disable the currently
    failing test because of the incomplete implementation of storing and loading to-do
    items. We know that this test still fails because we are not finished with the
    implementation. We only want to run the tests that were green before we started
    implementing storing and loading. Let''s get started:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了一些代码。我们如何确保我们之前实现的所有内容仍然有效？通过我们的测试！为了做到这一点，我们首先必须禁用当前失败的测试，因为存储和加载待办事项的不完整实现。我们知道这个测试仍然会失败，因为我们还没有完成实现。我们只想运行我们在开始实现存储和加载之前是绿色的测试。让我们开始吧：
- en: 'Go to `ToDoItemStoreTests` and add the following call of `XCTSkipIf(_:_:)`
    at the beginning of the test. Note that you also have to add the `throws` keyword
    to the test signature:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemStoreTests`并在测试的开头添加`XCTSkipIf(_:_:)`的调用。注意，你还需要将`throws`关键字添加到测试签名中：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this call, we tell the test runner that it should skip this test. When
    we are done with the change of the coordinate type, we just have to remove this
    line of code to activate the test again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个调用，我们告诉测试运行器它应该跳过这个测试。当我们完成坐标类型的更改后，我们只需移除这一行代码即可再次激活测试。
- en: 'Run the tests to figure out whether the coordinate change was successful or
    whether we missed something. The `test_init_setsCoordinate()` test does not compile
    because we changed the coordinate type. Replace the `CLLocationCoordinate2D` type
    with `Coordinate` and remove the import of `CoreLocation`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确定坐标更改是否成功或是否遗漏了某些内容。`test_init_setsCoordinate()`测试无法编译，因为我们更改了坐标类型。将`CLLocationCoordinate2D`类型替换为`Coordinate`并删除对`CoreLocation`的导入：
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the tests again. Now all tests pass.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。现在所有测试都通过了。
- en: This is huge! For the first time, we used unit tests to make refactoring easier.
    We didn't have to check each and every file to see whether the coordinate property
    was used and whether we had to adapt the type. We just had to run the tests. Now
    imagine we're working on a code base with hundreds of thousands of lines of code.
    The confidence you gain with a good test suite makes refactoring code effortless.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们第一次使用单元测试使重构变得更容易。我们不必检查每个文件以查看是否使用了坐标属性以及是否需要适配类型。我们只需运行测试。现在想象一下我们正在处理一个有数十万行代码的代码库。一个好的测试套件可以让你在重构代码时充满信心。
- en: Go back to `ToDoItemStoreTests` and remove the `XCTSkipIf(_:_:)` call. Run the
    tests to confirm that `test_init_shouldLoadPreviousToDoItems()` still fails.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`ToDoItemStoreTests`并删除`XCTSkipIf(_:_:)`调用。运行测试以确认`test_init_shouldLoadPreviousToDoItems()`仍然失败。
- en: 'Now that `ToDoItem` conforms to `Codable`, we can store a list of to-do items
    in a JSON structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`ToDoItem`符合`Codable`协议，我们可以在JSON结构中存储待办事项列表：
- en: 'Add the following method to `ToDoItemStore`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到`ToDoItemStore`中：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we get a file URL to store the JSON file to. Next, we get a `Data` object
    from the to-do items and write it to the file URL. As the conversion to JSON and
    writing to the file URL can throw an error, we embedded these calls into a `do-catch`
    block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取一个文件URL来存储JSON文件。接下来，我们从待办事项中获取一个`Data`对象并将其写入文件URL。由于将数据转换为JSON和写入文件URL可能会抛出错误，我们将这些调用嵌入到`do-catch`块中。
- en: 'The items need to be saved whenever something in the list of to-do items changes.
    Change the `add(_:)` method such that it looks like this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当待办事项列表中的任何内容发生变化时，都需要保存项目。修改`add(_:)`方法，使其看起来像这样：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we add a new item to the store, we save the list to the filesystem. We
    also need a method that loads the to-do items. Add the following method to `ToDoItemStore`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们向存储中添加新项目时，我们将列表保存到文件系统中。我们还需要一个加载待办事项的方法。将以下方法添加到`ToDoItemStore`中：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method is the reverse of the `saveItems` method. We get the same file URL
    in the beginning. Then, we load the data from the filesystem and convert it from
    the JSON format to a list of to-do items.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与`saveItems`方法相反。一开始我们得到相同的文件URL。然后，我们从文件系统中加载数据，并将其从JSON格式转换为待办事项列表。
- en: 'We call this method in the initializer of `ToDoItemStore`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`ToDoItemStore`的初始化器中调用此方法：
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That should make our test green. Run the tests to confirm.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会使我们的测试通过。运行测试以确认。
- en: 'Depending on your configuration, your tests might indeed be green. But most
    probably, some of the tests in `ToDoItemStoreTests` will fail. With storing and
    loading to-do items, the tests now depend on the tests that ran before. This is
    bad and should be avoided. When tests depend on the order in which they are executed,
    a test suite is not reliable. Tests can fail on some computers or in some environments.
    We need to fix this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的配置，您的测试可能确实是绿色的。但很可能是`ToDoItemStoreTests`中的某些测试会失败。在存储和加载待办事项时，测试现在依赖于之前运行的测试。这是不好的，应该避免。当测试依赖于它们执行的顺序时，测试套件是不可靠的。测试可能在某些计算机或某些环境中失败。我们需要修复这个问题：
- en: 'First, all tests should use a dummy JSON file. So, replace the setup code in
    `ToDoItemStoreTests` with this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，所有测试都应该使用一个虚拟的JSON文件。因此，将`ToDoItemStoreTests`中的设置代码替换为以下内容：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Second, we have to remove the JSON file after each test execution:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们必须在每次测试执行后删除JSON文件：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I know what you are thinking. We used the code to get the file URL for the JSON
    file a third time. We should clean that up. No worries, we will do that next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么。我们第三次使用了代码来获取JSON文件的文件URL。我们应该清理一下。不用担心，我们将在下一步做这件事。
- en: Run all tests twice. In the second run, all tests should be green.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 两次运行所有测试。在第二次运行中，所有测试都应该是绿色的。
- en: Cleaning up the code
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理代码
- en: In software development, we should follow the DRY principle. **DRY** stands
    for **don't repeat yourself**. By copying the code that creates the file URL for
    the JSON file two times, we violated this principle. Let's make this code reusable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，我们应该遵循 DRY 原则。**DRY** 代表 **不要重复自己**。通过复制两次创建 JSON 文件 URL 的代码，我们违反了这一原则。让我们使这段代码可重用。
- en: Select the `FileManagerExtension.swift` and make sure it is added to the main
    target of our project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `FileManagerExtension.swift` 并确保它已添加到我们项目的目标中。
- en: 'Follow these steps to remove the duplicated code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤删除重复的代码：
- en: 'Add this extension to `FileManagerExtension.swift`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将此扩展添加到 `FileManagerExtension.swift`:'
- en: '[PRE41]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open `ToDoItemStore.swift` and replace `saveItems()` with the following implementation:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ToDoItemStore.swift` 并将 `saveItems()` 替换为以下实现：
- en: '[PRE42]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, you wouldn't use the `FileManager` singleton directly here. In real
    code, you would rather pass in the kind of storage into the `ToDoItemStore` as
    a dependency using Dependency Injection. We take the approach above to keep the
    book as short as possible and to not distract from the main topic of this section.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，你不会直接在这里使用 `FileManager` 单例。在实际代码中，你更愿意通过依赖注入将这种存储类型传递给 `ToDoItemStore`。我们采取上述方法是为了使本书尽可能简短，并且不分散本节主题的注意力。
- en: 'Next, replace `loadItems()` with this code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `loadItems()` 替换为以下代码：
- en: '[PRE43]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, replace `tearDownWithError()` in `ToDoItemStoreTests.swift` with the
    following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `ToDoItemStoreTests.swift` 中的 `tearDownWithError()` 替换为以下代码：
- en: '[PRE44]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run all tests to make sure they still pass.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确保它们仍然通过。
- en: 'We are not done yet. There is one test missing. When the user checks a to-do
    item as done, the list of items should also be written to the filesystem. To make
    sure that is the case, add the following test to `ToDoItemStoreTests.swift`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们还没有完成。还缺少一个测试。当用户将待办事项标记为完成时，项目列表也应该写入文件系统。为了确保这一点，请将以下测试添加到 `ToDoItemStoreTests.swift`:'
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This test looks kind of like `test_init_shouldLoadPreviousToDoItems()`. But
    here, we check `toDoItem` before we destroy the to-do item store. In addition,
    we assert at the end that the loaded to-do item is checked as done.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试看起来有点像 `test_init_shouldLoadPreviousToDoItems()`。但在这里，我们在销毁待办事项存储之前检查 `toDoItem`。此外，我们在最后断言加载的待办事项已被标记为完成。
- en: 'To make this test pass, add the call to `saveItems()` within the `if let` conditional
    of the `check(_:)` method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，在 `check(_:)` 方法的 `if let` 条件中添加对 `saveItems()` 的调用：
- en: '[PRE46]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Before you move on, make sure that all tests pass.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保所有测试都通过。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored how to test Combine code. To make the tests
    easier to understand, we introduced a helper method and improved its failure message.
    We figured out how to make an `Equatable` type and how this can help in unit tests.
    Finally, we learned how to test storing and loading a JSON file to and from the
    filesystem of the iOS device.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何测试 Combine 代码。为了使测试更容易理解，我们引入了一个辅助方法并改进了其错误信息。我们弄清楚了如何创建一个 `Equatable`
    类型以及这如何有助于单元测试。最后，我们学习了如何测试将 JSON 文件存储到和从 iOS 设备的文件系统中读取。
- en: With these skills, you should be able to write tests for a variety of different
    model scenarios.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技能，你应该能够为各种不同的模型场景编写测试。
- en: In the next chapter, we will start building the user interface. We will start
    with the list of to-do items.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建用户界面。我们将从待办事项列表开始。
- en: Exercises
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Remove the expectation from the tests that test Combine code and check whether
    they fail.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试 Combine 代码的测试中移除期望，并检查它们是否失败。
- en: Think about what needs to be done to check whether the stored file is indeed
    in JSON format. Do you think such a test is of any use?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一下需要做什么来检查存储的文件是否确实为 JSON 格式。你认为这样的测试有任何用处吗？
