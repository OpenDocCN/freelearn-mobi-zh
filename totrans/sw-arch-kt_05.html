<html><head></head><body><div><div><div><h1 id="_idParaDest-103" class="chapter-number"><a id="_idTextAnchor125"/>5</h1>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor126"/>Exploring MVC, MVP, and MVVM</h1>
			<p>This chapter aims to provide a comprehensive comparison of <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), and <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>), demonstrating <a id="_idIndexMarker378"/>their <a id="_idIndexMarker379"/>similarities, differences, and<a id="_idIndexMarker380"/> the contexts in which they shine. By understanding the strengths and weaknesses of each pattern, developers can make informed decisions when architecting their applications.</p>
			<p>This chapter begins by exploring the principles of MVC, a pattern that has been widely adopted across various platforms, including web and mobile app development. We will delve into its three core components: the <em class="italic">Model</em>, responsible for business data; the <em class="italic">View</em>, responsible for the visual presentation of information to users; and the <em class="italic">Controller</em>, the intermediary between the Model and the View.</p>
			<p>Next, we will shift our focus to MVP, a pattern that emerged as an evolution of MVC. We will examine how MVP addresses some of the limitations of MVC by introducing the Presenter, which orchestrates the exchange of data and user interactions between the Model and the View. We will<a id="_idIndexMarker381"/> analyze the <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) achieved in MVP and how it enables improved testability and maintainability.</p>
			<p>Finally, we will explore MVVM, a pattern that became popular with data-binding frameworks. We will investigate how MVVM separates the concerns of the <em class="italic">Model</em>, <em class="italic">View</em>, and <em class="italic">ViewModel</em> and how data bindings facilitate the automatic synchronization of data between the View and the ViewModel. We will discuss the benefits of declarative programming and the increased SoC that MVVM offers.</p>
			<p>We will thus cover the following topics in this chapter:</p>
			<ul>
				<li>MVC</li>
				<li>MVP</li>
				<li>MVVM</li>
				<li>Comparing MVC, MVP, and MVVM</li>
				<li>Beyond MVC, MVP, and MVVM</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor127"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5</a></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor128"/>MVC</h1>
			<p>The MVC pattern <a id="_idIndexMarker382"/>originated in the 1970s when the concepts of MVC were developed to structure code and separate concerns in the <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) of<a id="_idIndexMarker383"/> desktop applications.</p>
			<p>In the late 1990s and early 2000s, web development became popular. MVC was adopted as part of web development <a id="_idIndexMarker384"/>frameworks; for example, <strong class="bold">JavaServer Pages</strong> (<strong class="bold">JSP</strong>), Ruby on Rails, ASP.NET, and so on.</p>
			<p>The MVC pattern divides an application into three interconnected components: the Model, the View, and the Controller. Each component has distinct responsibilities and interacts with the others in a coordinated manner. This pattern promotes SoC and a clear division of responsibilities.</p>
			<p>You may find various versions of interactions among the three components in different frameworks and languages. MVC represents the need to separate the Model, the View, and the Controller, and not as a prescription of how they work together.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor129"/>The Model</h2>
			<p>The Model<a id="_idIndexMarker385"/> is the<a id="_idIndexMarker386"/> application’s internal data, independent of the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). Data is validated, manipulated, and transformed to other formats within the Model. It encapsulates the core behavior and business logic and can be shared across different Views.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor130"/>The View</h2>
			<p>The View is <a id="_idIndexMarker387"/>responsible for presenting <a id="_idIndexMarker388"/>the UI to the end user. It displays the data from the Model and provides a mechanism to interact with users. The View is passive and reactive to users’ actions. It only contains simple logic that is related to rendering data and responding to user input.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor131"/>The Controller</h2>
			<p>The Controller is the <a id="_idIndexMarker389"/>intermediary <a id="_idIndexMarker390"/>coordinator between the Model, the View, and the user. It receives a request from the user and requests an update of the data in the Model. Once the Model accepts the request, the Controller updates the presentation in the View.</p>
			<p>The Controller orchestrates the flow of data and the sequence of changes between the Model and the View. In other words, the Controller determines the application’s behavior.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor132"/>The collaboration</h2>
			<p>One version <a id="_idIndexMarker391"/>of the collaboration among the Model, the View, and the Controller is illustrated in the following diagram:</p>
			<div><div><img src="img/B21737_05_1.jpg" alt="Figure 5.1 – The MVC pattern" width="865" height="1033"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The MVC pattern</p>
			<p>The user sees the View and makes requests to the Controller. The Controller updates the data in the Model and then the presentation in the View, and finally, the user sees a visual response to its previous request to the Controller. The View can also be updated when the Model <a id="_idIndexMarker392"/>changes, with the use of callback functions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is worth pointing out that the Model does not depend on the View or the Controller. On the contrary, the View depends on the Model. The Controller depends on both the View and the Model.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor133"/>The benefits of MVC</h2>
			<p>The MVC pattern<a id="_idIndexMarker393"/> separates the concerns of data management (the Model), UI (the View), and user interaction (the Controller). As a result, it promotes modularity, code reusability, and testability.</p>
			<p>The Model captures the application data and business logic, which can be reused among multiple UIs and user interactions. Multiple platforms, such as web browser interfaces and mobile app interfaces, can both depend on the Model as a module. A single update operation and a bulk update operation can reuse the same data structure and validation logic within the Model. The business logic in the Model can be tested in isolation without dependency on the View and the Controller.</p>
			<p>In addition, modularizing the Model, the View, and the Controller enables each of them to be replaced without breaking or affecting other modules. If we were to rewrite the current UI, it would now be possible to write the next-generation UI as an independent module in parallel with the current UI, without the fear of breaking any existing functionality or degrading user experience. We could still maintain the current UI for one team while the new UI was being built by another team.</p>
			<p>When the next-generation UI is launched, we can safely decommission the old UI module. This reduces a lot of dependencies and risks of releasing software.</p>
			<p>On the other hand, it is not as usual to reuse the View and the Controller. As described in the previous diagram, the View depends on the Model, and the Controller depends on both the View and the Model. Reusing either of them brings the Model as the transitive dependency, locking down the Model to be used. Additionally, the Controller is usually tightly<a id="_idIndexMarker394"/> coupled with the View, making very little room for reuse.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor134"/>A real-life example of MVC</h1>
			<p>We are going to <a id="_idIndexMarker395"/>apply MVC in building a frontend application for households to draft a contract for the exchange of service (the “contract”) with their neighbors. We will use Android Studio and the<a id="_idIndexMarker396"/> Android <strong class="bold">Software Development </strong><strong class="bold">Kit</strong> (<strong class="bold">SDK</strong>).</p>
			<p>The draft contract should contain basic information, such as each household’s name and the services to be exchanged. The household uses a mobile application to create a draft contract record. The application as the View has only two screens, as shown here:</p>
			<div><div><img src="img/B21737_05_2.jpg" alt="Figure 5.2 – Sample mobile application for drafting a contract" width="1648" height="968"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Sample mobile application for drafting a contract</p>
			<p>The first screen allows the household to enter its name and the service it provides. In this case, it is the Smith household that provides a cleaning service. On the other hand, the household enters the neighbor’s name and service in exchange. Specifically, here, it is the Lee household that provides a plumbing service.</p>
			<p>The layout of the screen is defined by XML files as resources under the <code>/app/src/main/res/layout</code> project folder. For instance, the text field of <strong class="bold">Your household</strong> is declared as follows:</p>
			<pre class="source-code">
    &lt;EditText
        android:id="@+id/your_household_name_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="25dp"
        android:ems="10"
        android:text="Name"
        app:layout_constraintTop_toBottomOf="@id/your_household_header"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintBottom_toTopOf="@id/your_household_service_edit" /&gt;</pre>			<p>The XML block defines the View as an <code>EditText</code> component with an assigned ID, alignments, and<a id="_idIndexMarker397"/> dimensions. Copies (that is, display text) shown in the UI can be defined in a separate file and bound here using identifiers. This separates the concerns of copywriting and visual layouts.</p>
			<p>View components in XML layouts can be bound to data sources in a declarative manner, using the Android Jetpack library. When the data changes in the Model, the View updates automatically without requiring manual updates in the code. This mechanism creates a more dynamic and responsive UI. The data binding can be expressed in the following XML:</p>
			<pre class="source-code">
    &lt;data&gt;
        &lt;variable
            name="household"
            type="com.example.Household" /&gt;
    &lt;/data&gt;</pre>			<p>With the data defined, the View can be bound to the Model. In the following example, <code>TextView</code> displays the name of <code>Household</code>:</p>
			<pre class="source-code">
        &lt;TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{household.name}" /&gt;</pre>			<p>When the <strong class="bold">SUBMIT</strong> button is clicked, the application navigates to the confirmation screen. On the screen, it acknowledges that the draft contract has been submitted, and the contract of exchanged service is shown to the user.</p>
			<p>The Model should have two data classes. <code>HouseholdInput</code> captures the name and service provided by a household, and <code>DraftContractInput</code> has two <code>HouseholdInput</code> objects<a id="_idIndexMarker398"/> to form a contract. The two data classes are shown here:</p>
			<pre class="source-code">
data class DraftContractInput(
    val initiator: HouseholdInput,
    val neighbor: HouseholdInput
)
data class HouseholdInput(
    val householdName: String,
    val serviceProvided: String
)</pre>			<p>There is also a sample repository class, <code>ContractRepository</code>, for handling the submission of draft contracts. The repository class is shown here:</p>
			<pre class="source-code">
class Co<a id="_idTextAnchor135"/>ntractRe<a id="_idTextAnchor136"/>pository {
    fun submit(contract: DraftContractInput): Boolean {
        return true.also {
            println("Persisted contract: $contract")
        }
    }
}</pre>			<p>The current implementation of the repository does not do anything but can be enhanced to validate and persist draft contracts.</p>
			<p>The <code>Controller</code> interface in the MVC pattern is the one that coordinates between the View and the Model. In this example, an interface is defined for what the Controller can do:</p>
			<pre class="source-code">
interface Controller {
    fun submitContract(contract: DraftContractInput)
}</pre>			<p>The <code>MainActivity</code> class implements the <code>Controller</code> interface and is a subclass of <code>AppCompatActivity</code> from the Android SDK. It sets up the content of the View, controls the screen<a id="_idIndexMarker399"/> navigation, and connects with the Model:</p>
			<pre class="source-code">
class MainActivity : AppCompatActivity(), Controller {
    private val contractRepository: ContractRepository = ContractRepository()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val contractDraftFragment = Cont<a id="_idTextAnchor137"/>ractDraftFragment()
supportFragmentManag<a id="_idTextAnchor138"/>er.beginTransaction().replace(R.id.fragment_container, c<a id="_idTextAnchor139"/>ontractDraftFragment).commit()
    }</pre>			<p>Up to this part of the <code>MainActivity</code> class, it creates a <code>ContractRepository</code> object from the Model. It also creates a <code>ContractDraftFragment</code> screen as the first application screen, as shown on the left in <em class="italic">Figure 5</em><em class="italic">.2</em>. The <code>submitContract</code> function from the <code>Controller</code> interface invokes the function in the Model to submit the draft contract:</p>
			<pre class="source-code">
    override fun submitContract(contract: DraftContractInput) {
        contractReposito<a id="_idTextAnchor140"/>ry.submit(contract)
  <a id="_idTextAnchor141"/>       val bundle = Bundle()
        bundle.putString("yourHouseholdName", contract.initiator.householdName)
        bundle.putString("yourHouseholdService", contract.initiator.serviceProvided)
        bundle.putString("yourNeighborName", contract.neighbor.householdName)
        bundle.putString("yourNeighborService", contract.neighbor.serviceProvided)
        val confirmationFragment = ConfirmationFragment()
        confirmationFragment<a id="_idTextAnchor142"/>.arguments = bundle
        supportFragmentManag<a id="_idTextAnchor143"/>er.beginTransaction().replace(R.id.fragment_container, <a id="_idTextAnchor144"/>confirmationFragment).commit()
    }</pre>			<p>Before the Controller<a id="_idIndexMarker400"/> navigates the View to the confirmation screen, it creates a <code>Bundle</code> object that contains the data submitted. The data is passed to <code>ConfirmationFragment</code>, which is the screen shown on the right in <em class="italic">Figure 5</em><em class="italic">.2</em>. The <code>ContractDraftFragment</code> sends user actions to the Controller for draft contract submission. This is implemented in the <code>onCreateView</code> function of the <code>Contract<a id="_idTextAnchor145"/>DraftFragment</code> class:</p>
			<pre class="source-code">
class Con<a id="_idTextAnchor146"/>tractDraftFragment : Fragment() {
    lateinit var controller: Controller
    lateinit var inflated: View
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        inflated = inflater.inflate(R.layout.fragment_contract_draft, container, false)
        controller = activity as Controller</pre>			<p>After the View is inflated, a click listener can be set to the <code>EditText</code> components are then extracted:</p>
			<p class="callout-heading">Basic elements in the Android SDK</p>
			<p class="callout">The Android SDK provides<a id="_idIndexMarker402"/> a comprehensive set of tools and components for building Android applications. There are a few key elements that are used throughout this chapter. An Activity is a single screen with a UI, acting as an entry point for user interaction with the application. Fragments are modular sections of an Activity, and they can be reused across multiple Activities. Views are the basic building blocks for UIs, such as buttons, text fields, and images. Layouts are the declarative definition of the UI in XML format, which specifies how Views are arranged on the screen.</p>
			<pre class="source-code">
        inflated.findViewById&lt;Butto<a id="_idTextAnchor147"/>n&gt;(R.id.subm<a id="_idTextAnchor148"/>it_button)
            ?.setOnClickListener {
                controller.submitContract(
                    DraftContractInput(
                        initiator = HouseholdInput(
                            householdName = inflated.findViewById&lt;EditText&gt;(R.id.your_household_name_edit).text.toString(),
                            serviceProvided = inflated.findViewById&lt;EditText&gt;(R.id.your_household_service_edit).text.toString(),
                        ),
                        neighbor = HouseholdInput(
                            householdName = inflated.findViewById&lt;EditText&gt;(R.id.your_neighbor_name_edit).text.toString(),
                            serviceProvided = inflated.findViewById&lt;EditText&gt;(R.id.your_neighbor_service_edit).text.toString(),
                        )
                    )
                )
            }
        return inflated
    }
}</pre>			<p>A <code>DraftContractInput</code> object from the Model is created from the extracted values in the <code>EditText</code> components. The <code>DraftContractInput</code> object is then submitted to the <code>ContractRepository</code> class for further processing.</p>
			<p>Finally, <code>ContractDraftFragment</code> retrieves the <code>Bundle</code> object passed from the previous screen. The View components are then set with the data from the <code>Bundle</code> object to<a id="_idIndexMarker403"/> display a confirmation screen with details<a id="_idTextAnchor149"/> of the draft contract:</p>
			<pre class="source-code">
class<a id="_idTextAnchor150"/> ConfirmationFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val inflated = inflater.inflate(R.layout.fragment_confirmati<a id="_idTextAnchor151"/>on, container, false)
        <a id="_idTextAnchor152"/>val yourHouseholdName = arguments?.getStri<a id="_idTextAnchor153"/>ng("yourHouseholdName")
        val<a id="_idTextAnchor154"/> yourHouseholdService = arguments?.getString(<a id="_idTextAnchor155"/>"yourHouseholdService")
        val yourNeighborName = arguments?.getStr<a id="_idTextAnchor156"/>ing("yourNeighborName")
        va<a id="_idTextAnchor157"/>l yourNeighborService = arguments?.getString("yourNeighborService")
        inflated.findViewById&lt;TextView&gt;(R.id.your_household_summary).text =
            "Your household \"$yourHouseholdName\" providing ${yourHouseholdService}"
        inflated.findViewById&lt;TextView&gt;(R.id.your_n<a id="_idTextAnchor158"/>eighbor_summa<a id="_idTextAnchor159"/>ry).text =
            "your neighbor \"$yourNeighborName\" providing ${yourNeighborService}"
        return inflated
    }
}</pre>			<p>In this example, users<a id="_idIndexMarker404"/> first see the UI and fill in the text fields. Then, the users click the <strong class="bold">SUBMIT</strong> button. This user action invokes the Controller to update the View by navigating to a confirmation screen. The Controller also updates the Model by submitting a draft contract object to the repository. At the end, users see the confirmation screen.</p>
			<p>It is worth pointing out that the code in the Model focuses merely on the business data and logic, and the View is solely responsible for rendering the UI. The Controller does all the coordination between the View and the Model, and this is how SoC is achieved in the MVC pattern.</p>
			<p>Coming next, we <a id="_idIndexMarker405"/>are moving on to MVP, an architecture pattern that can be seen <a id="_idTextAnchor160"/>as evolving from MVC.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor161"/>MVP</h1>
			<p>MVP can be<a id="_idIndexMarker406"/> considered a pattern evolving from the MVC pattern. MVP originated in the 1990s as a response to the limitations and challenges faced when applying MVC to desktop and web application development.</p>
			<p>MVP is built upon the concepts of MVC. The View and the Model concepts are shared between the two patterns, but interactions between the View and the Model have significantly changed.</p>
			<p>The major limitation of MVC is the tight coupling between the View and the Controller. It results in a limited ability to test the View and the Controller independently. Also, when the View is complex and has a lot of presentation logic, it becomes difficult to test and maintain.</p>
			<p>In addition, any variation or extension to the current View inevitably requires a proportional change in the Controller as the Controller needs to understand all the variations and extensions that exist.</p>
			<p>MVP promotes an even more decoupled relationship between the View and the Model by introducing the Presenter. The following diagram demonstrates the new relationships among the View, the Model, and the Presenter:</p>
			<div><div><img src="img/B21737_05_3.jpg" alt="Figure 5.3 – The MVP pattern" width="789" height="913"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The MVP pattern</p>
			<p>As you can see, the user sees the View and interacts with the UI. The View then sends the user action to the Presenter. The Presenter updates the data in the Model. The Model calls back the Presenter when the data is updated. The Presenter then updates the View according to<a id="_idIndexMarker407"/> the data changed in the Model. Eventually, the user sees an updated UI based on the previous interaction.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor162"/>Differences from MVC</h2>
			<p>The first noticeable difference<a id="_idIndexMarker408"/> between MVP and MVC is that the Model and the View do not interact. All messages come through the Presenter, and the Presenter depends on both the View and the Model. The View is self-contained and does not depend on either the Model or the Presenter.</p>
			<p>The second difference is that the View can be completely passive in the sense that it is only responsible for rendering the UI as a response to the Presenter’s request to update the View. However, the <em class="italic">Passive View</em> is considered an option for MVP. Passive View is a variant of MVP in which the View makes no decisions and contains no business logic.</p>
			<p>If not passive, the View can contain certain presentation logic that does not affect the Model or the Presenter. Simple field validation such as data type and length is a typical example.</p>
			<p>The third difference is that MVP typically enforces explicit communication with the View and the Model. The View informs the Presenter of user actions, and the Presenter then interprets and acts upon them. Defining explicit communication helps engineers understand and <a id="_idIndexMarker409"/>reason about the application’s behaviors, as a result making the application easier to maintain.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor163"/>The benefits of MVP</h2>
			<p>The further SoC <a id="_idIndexMarker410"/>among the View, the Model, and the Presenter brings about a few benefits on top of the MVC pattern.</p>
			<p>The View under MVP can be independently tested, without the involvement of the Presenter. The explicit incoming messages to the View can be used as the input of test cases, and the UI is used for verification. On the other hand, user interactions can be the input of test cases, and the explicit outgoing message from the View is used for verification.</p>
			<p>With MVP, it is now possible to have variants of View without any change in the Presenter. The variant of the View interprets messages from the Presenter differently. The variant might produce the same message to the Presenter from a slightly different user interaction. In this way, there is no need to change the Presenter to support a variant of the View. Nowadays, there are so many variations of UIs on different platforms, such as iOS applications, Android applications, web applications, and custom devices such as televisions. It is possible for these different Views to share the same Model and same Presenter while still giving users a unique experience that is tailored to the platform.</p>
			<p>MVP standardizes messages explicitly sent to and received by the Presenter. It ensures there is no confusion and no room for deviation by different frameworks or implementations. It <a id="_idIndexMarker411"/>brings clarity to engineers and makes the application easy to understand.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor164"/>A real-life example of MVP</h2>
			<p>We continue to use <a id="_idIndexMarker412"/>the same example we used for the MVC pattern. We are using the same real-life example used in MVP, where a household can draft a contract of exchanged services (the “contract”) with another household.</p>
			<p>Evolving from the MVC pattern, the View and the Model can be kept the same in MVP, but the ways of communication will change.</p>
			<p>The <code>Controller</code> interface is renamed as <code>Presenter</code>, even though the declared function has not changed:</p>
			<pre class="source-code">
interface Presenter {
    fun submitContract(contract: DraftContractInput)
}</pre>			<p>The Presenter has two-way communication with both the View and the Model. So, the first change would be to support a callback when the Model has changed:</p>
			<pre class="source-code">
typealias DraftContractSubmittedListener = (DraftContractInput) -&gt; Unit</pre>			<p>The <code>DraftContractSubmittedListener</code> type alias acts as a callback interface when the draft contract is submitted to the Model. The <code>ContractRepository</code> class is enhanced to keep a <code>DraftContractSubmittedListener</code> object and will invoke the callback when a draft contract is submitted. The implementation of the repository class is shown here:</p>
			<pre class="source-code">
class ContractRepository {
    var onSubmitListener: DraftCo<a id="_idTextAnchor165"/>ntractSu<a id="_idTextAnchor166"/>bmittedListener? = null
    fun submit(contract: DraftContractInput): Boolean {
        return true.also {
            onS<a id="_idTextAnchor167"/>ubmitLis<a id="_idTextAnchor168"/>tener?.invoke(contract)
        }.also {
            println("Persisted contract: $contract")
        }
    }
}</pre>			<p>The callback function, when the model is updated, can be used to navigate to the confirmation screen with the submitted draft contract. This is the updated <code>submitContract</code> function in the <code>MainActivity</code> class:</p>
			<pre class="source-code">
    override fun submitContract(contract: DraftContractInput) {
        contractRepository.onSubmitListener = {
            val confirmationFr<a id="_idTextAnchor169"/>agment = ConfirmationFragment()
            confirmationFragment.lastSubmittedContract = it           supportF<a id="_idTextAnchor170"/>ragmentManager.beginTransaction().replace(R.id.fragment<a id="_idTextAnchor171"/>_container, confirmationFragment).commit()
        }
        contractRepository.submit(contract)
    }</pre>			<p>On the other <a id="_idIndexMarker413"/>hand, the <code>ConfirmationFragment</code> class is updated. The screen takes the values directly from the submitted draft contract that was just set from <code>DraftContractSu<a id="_idTextAnchor172"/>bmittedListener</code> to <code>MainActivi<a id="_idTextAnchor173"/>ty</code>:</p>
			<pre class="source-code">
class ConfirmationFragment : Fragment() {
    lateinit var lastSubmittedContract: DraftContractInput
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val inflated = inflater.inflate(R.layout.fragment_confirmation, container, false)
        lastSubmittedContract?.also {
            inflated.findViewById&lt;TextView&gt;(R.id.your_household_summary).text =
                "Your household \"${it.initiator.householdName}\" providing ${it.initiator.serviceProvided}"
            inflated.findViewById&lt;TextView&gt;(R.<a id="_idTextAnchor174"/>id.your_neighbor_<a id="_idTextAnchor175"/>summary).text =
                "your neighbor \"${it.neighbor.householdName}\" providing ${it.neighbor.serviceProvided}"
        }
        return inflated
    }
}</pre>			<p>The major difference between this MVP example and the MVC example is that the loading of the confirmation screen is triggered by the change in the Model, with the use of a callback function. In this way, all communications between the View and the Model are through the Presenter. It is now possible to test the View logic in the <code>ConfirmationFragment</code> class, the Model logic in the <code>ContractRepository</code> class, and the Presenter logic in the <code>MainActivity</code> class independently.</p>
			<p>After MVP, we are <a id="_idIndexMarker414"/>going to delve into the MVVM pattern, which also aims to solve the same problem as MVC and MVP.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor176"/>MVVM</h1>
			<p>MVVM was <a id="_idIndexMarker415"/>first introduced by John Gossman at Microsoft in 2005. It was created for UI development <a id="_idIndexMarker416"/>using the <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) framework. Later it was adopted by other frameworks, such as the following:</p>
			<ul>
				<li>React</li>
				<li>Xamarin</li>
				<li>AngularJS</li>
			</ul>
			<p>MVVM fundamentally retains the concepts of the Model and the View from the older models, MVC and MVP. However, it uses the View Model as an intermediary between the View and the Model. There is also a substantial preference for using declarative data binding to coding. The <a id="_idIndexMarker417"/>data-binding feature of MVVM supports the automatic synchronization between the View and the View Model.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor177"/>The View Model</h2>
			<p>The View Model <a id="_idIndexMarker418"/>exposes data and commands that the view can bind to. The data binding allows an automatic two-way synchronization between the View and the View Model. In other words, updates from the View Model are reflected in the View automatically, and the View Model can react to user actions in the View. This reduces boilerplate code to manually synchronize the data between the View and the View Model and the code to update the View. The following diagram will throw more light on interactions among the View, the Model, and the View Model:</p>
			<div><div><img src="img/B21737_05_4.jpg" alt="Figure 5.4 – The MVVM pattern" width="898" height="1033"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The MVVM pattern</p>
			<p>As you can see here, the View Model reads data from the Model, transforms it for presentation, and<a id="_idIndexMarker419"/> provides properties and functions for the View. The View receives the properties and function callback to render the UI.</p>
			<p>A use case in which a user interacts with the View and ends up seeing changes in the View is demonstrated in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21737_05_5.jpg" alt="Figure 5.5 – User interacting and seeing changes in the View" width="926" height="1091"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – User interacting and seeing changes in the View</p>
			<p>When a user interacts with the View, the user actions are propagated to the View Model. The View Model executes commands to respond to the user actions, which typically involve <a id="_idIndexMarker420"/>updating the data in the Model. Once the data is updated in the Model, the View Model receives the data update and transforms it for presentation. Finally, the View receives the View Model changes and renders the UI as a response to the user actions.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor178"/>The benefits of MVVM</h2>
			<p>MVVM separates<a id="_idIndexMarker421"/> the concerns of business logic even further from the presentation in the View. The View Model encapsulates presentation logic without needing to be concerned about how it is rendered visually. This implies the View Model can be tested in isolation, independent of specific details of the UI.</p>
			<p>Properties and commands in the View Model can be shared while keeping the user experience consistent among multiple Views, such as web browsers, desktop applications, and mobile applications. Moreover, View changes can be made without updating the View Model. This promotes flexibility and extensibility to evolve the code base.</p>
			<p>UI designers can better collaborate with frontend engineers. UI designers can focus on styling, layout, and visual components without the need to interfere with the business logic. This promotes working in parallel and improves productivity.</p>
			<p>The automatic synchronization between the View and the View Model reduces boilerplate code <a id="_idIndexMarker422"/>to manually update the View when the View Model changes and vice versa.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor179"/>A real-life example of MVVM</h2>
			<p>Continuing from the <a id="_idIndexMarker423"/>same example we used for the MVP pattern, the code base is going to evolve to the MVVM pattern. We are using the same real-life example from MVC and MVP, and the code base evolves from them using the Android SDK.</p>
			<p>The View Model is introduced and named <code>DraftContractViewModel</code> to store transitional data before it is ready to become a draft contact:</p>
			<pre class="source-code">
class DraftContractViewModel : ViewModel() {
    var yourHouseholdName: String? = null
    var yourHouseholdService: String? = null
    var yourNeighborName: String? = null
    var yourNeighborService: String? = null
}</pre>			<p>The <code>DraftContractViewModel</code> object is going to be shared among <code>Fragments</code> to keep building the data required for a draft contract. This is reflected in the mutable fields (known as <code>var</code> in Kotlin). Moreover, the View Model acts as a bridge between the View and the Model. The <code>toModel</code> function converts a View Model <code>DraftContractViewModel</code> object to the Model <code>DraftContractInput</code> object:</p>
			<pre class="source-code">
fun DraftContractViewModel.toModel(): DraftContractInput? =
    if (yourHouseholdName != null
        &amp;&amp; yourHouseholdService != null
        &amp;&amp; yourNeighborName != null
        &amp;&amp; yourNeighborService != null
    ) {
        DraftContractInput(
            initiator = HouseholdInput(
                householdName = yourHouseholdName!!,
                serviceProvided = yourHouseholdService!!
            ),
            neighbor = HouseholdInput(
                householdName = yourNeighborName!!,
                serviceProvided = yourNeighborService!!
            )
        )
    } else {
        null
    }</pre>			<p>Note that data integrity logic has been applied to the function to ensure that the Model object can only<a id="_idIndexMarker424"/> be created when all fields are present. This conversion logic can also be teste<a id="_idTextAnchor180"/>d independently, as shown here:</p>
			<pre class="source-code">
    @Test
    fun `do n<a id="_idTextAnchor181"/>ot create model if the view model is empty`() {
        assertNull(DraftContr<a id="_idTextAnchor182"/>actViewModel().toModel())
    }
    @Test
    fun<a id="_idTextAnchor183"/> `crea<a id="_idTextAnchor184"/>te model when all fields are present`() {
        val viewModel = DraftContractViewModel().apply {
            yourHouseholdName = "Smith"
            yourHouseholdService = "Cleaning"
            yourNeighborName = "Lee"
            yourNeighborService = "Cooking"
        }
        val model = DraftContractInput(
            HouseholdInput("Smith", "Cleaning"),
            HouseholdInput("Lee", "Cooking")
        )
        assertEquals(model, viewModel.toModel())
    }</pre>			<p>This unit test <a id="_idIndexMarker425"/>is run by the <code>null</code>. The second test creates a View Model object with all fields not <code>null</code>, and therefore it can be converted to a Model object.</p>
			<p>The data between the View and the View Model is bound and synchronized automatically, using the following custom function:</p>
			<pre class="source-code">
fun EditText.bind(consume: (String) -&gt; Unit) {
    consume(text.toString())
    addTextChangedListener {
        consume(it.toString())
    }
}</pre>			<p>Initially, when the <code>EditText</code> View component is created, the default value is set to the View Model <code>DraftContractViewModel</code> object. Subsequently, any text change will trigger a callback to update the View Model. The data-binding process is kicked off in the <code>onCreate</code> function of the first screen, represented by the <code>ContractDraftFragment</code> class:</p>
			<pre class="source-code">
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val inflated = inflater.inflate(R.layout.fragment_contract_draft, container, false<a id="_idTextAnchor185"/>)
        val command = activity as Command
        val viewModel = Vie<a id="_idTextAnchor186"/>wModelProvider(activity as AppCompatActivity).get(DraftContractViewModel::class.java)</pre>			<p>The View Model is looked up here, and the owner is set to be the activity so that it can be shared with <a id="_idIndexMarker427"/>the next screen. Then, a callback is registered upon clicking the <code>toModel</code> function is used to convert the View Model to the Model object:</p>
			<pre class="source-code">
        infla<a id="_idTextAnchor187"/>ted.findView<a id="_idTextAnchor188"/>ById&lt;Button&gt;(R.id.submi<a id="_idTextAnchor189"/>t_button)
            ?.setOnClick<a id="_idTextAnchor190"/>Listener {
                viewModel.toModel()?.let {
                    command.submit<a id="_idTextAnchor191"/>Contract(it)
                }
            }</pre>			<p>The following code then binds the <code>EditText</code> View components with the View Model, field by field, using the <code>bind</code> function just mentioned previously:</p>
			<pre class="source-code">
inflated.findViewById&lt;EditText&gt;(R.id.your_household_name_edit)?.bind {
<a id="_idTextAnchor192"/>            viewModel.yourHouseholdName <a id="_idTextAnchor193"/>= it
        } inflated.findViewBy<a id="_idTextAnchor194"/>Id&lt;EditText&gt;(R.id.your_household_service_edit)?.bind {
            viewModel.yourHouseholdService <a id="_idTextAnchor195"/>= it
        } inflated.findVi<a id="_idTextAnchor196"/>ewById&lt;EditText&gt;(R.id.your_neighbor_name_edit)?.bind {<a id="_idTextAnchor197"/>
            viewModel.yourNeighborName <a id="_idTextAnchor198"/>= it
        } inflated.findViewB<a id="_idTextAnchor199"/>yId&lt;EditText&gt;(R.id.your_neighbor_service_edit)?.bind {
            viewModel.yourNeighborService = it
        }
        return inflated
    }</pre>			<p>The confirmation<a id="_idIndexMarker428"/> screen gets the<a id="_idTextAnchor200"/> submitted data from the View<a id="_idTextAnchor201"/> Model directly:</p>
			<pre class="source-code">
class ConfirmationFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val inflated = inflater.inflate(R.la<a id="_idTextAnchor202"/>yout.fragment_confirmation, container, false)
        val viewModel = V<a id="_idTextAnchor203"/>iewModelProvider(activity as AppCompatActivity).get(DraftContractViewModel::class.java)</pre>			<p>The View Model is looked up here with the activity as the owner shared with the first screen. Then, the View gets the data from the same View Model object. There are now two screens sharing the same View Model object, but the Views are rendered differently:</p>
			<pre class="source-code">
inflated.findViewById&lt;TextView&gt;(R.id.your_household_summary).text =
            "Your household \"${viewModel.yourHouseholdName}\" providing ${viewModel.yourHouseholdService}"
        inflated.findViewById<a id="_idTextAnchor204"/>&lt;TextView&gt;(R.<a id="_idTextAnchor205"/>id.your_neighbor_summary).text =
            "your neighbor \"${viewModel.yourNeighborName}\" providing ${viewModel.yourNeighborService}"
        return inflated
    }
}</pre>			<p>There are a few more potential features that can be added to this example. As the user types in the text fields, the callback function to synchronize the View Model keeps on being invoked. This makes it possible to provide real-time validation feedback to the user.</p>
			<p>As the View Model is shared among multiple screens in the same activity, the View can be evolved into a series of screens as a wizard-style multi-step activity.</p>
			<p>Also, if the Model is shared between two households in two copies of the application, the data of the draft contract can be synchronized in real time using a certain protocol such <a id="_idIndexMarker429"/>as a <strong class="bold">peer-to-peer</strong> (<strong class="bold">P2P</strong>) network. When the Model is updated externally from the network, the <a id="_idIndexMarker430"/>callback function for changes in the Model can populate the View Model and then update the View in real time.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor206"/>Comparing MVC, MVP, and MVVM</h1>
			<p>The MVC, MVP, and MVVM <a id="_idIndexMarker431"/>pattern<a id="_idIndexMarker432"/>s share<a id="_idIndexMarker433"/> the <a id="_idIndexMarker434"/>same <a id="_idIndexMarker435"/>concepts <a id="_idIndexMarker436"/>of the View and the Model. However, their relationships and ways of communication are different.</p>
			<p>In MVC, one Controller has access to multiple Views and usually calls the functions of View directly. The View and the Model are tightly coupled. User inputs are handled by the Controller. Unit testing is limited to the Model on business logic only. Modifying the View or the Model would require changing the Controller as well. It is suitable for small projects only because the code footprint is the smallest.</p>
			<p>In MVP, one Presenter manages at least one View. The View and the Model have no knowledge about the Presenter, but they communicate with the Presenter using callback functions. Also, the View and the Model are decoupled. User inputs are handled by the View, and then the View invokes the callback function provided by the Presenter. Unit testing can be done in the Model on business logic. The behaviors of callback functions from the Model and the View can also be tested. Modifying the View or the Model may not need to modify the Presenter if the callback function stays the same. It is suitable for small to more complex projects that <a id="_idTextAnchor207"/>require better testability of the Model and the View.</p>
			<p>In MVVM, one View Model maps to one or many Views. The View and the Model are also decoupled, but even more separation of bus<a id="_idTextAnchor208"/>iness logic from the View and communications are more event-driven and supported by <a id="_idTextAnchor209"/>the underlying frameworks. User inputs are handled by the View, and then the View invokes the callback function provided by the View Model. Unit testing can be done in the Model on business logic. The behaviors of callback functions from the Model, the View, and the View Model can also be tested.</p>
			<p>The concerns are<a id="_idIndexMarker437"/> easier <a id="_idIndexMarker438"/>to <a id="_idIndexMarker439"/>separate, and the functions can<a id="_idIndexMarker440"/> be <a id="_idIndexMarker441"/>small <a id="_idIndexMarker442"/>enough to conform <a id="_idIndexMarker443"/>to the <strong class="bold">single-responsibility principle</strong> (<strong class="bold">SRP</strong>). Modifying the View or the Model may not need to modify the View Model if the data binding has not changed. It is suitable for large and complex projects that may be deployed to multiple platforms and, therefore, multiple variants of the View and requires better isolation between the View and the Model.</p>
			<p>The comparison is summarized in the following table:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">MVC</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">MVP</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">MVVM</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View and Model tightly coupled.</p>
						</td>
						<td class="No-Table-Style">
							<p>View and Model are decoupled.</p>
						</td>
						<td class="No-Table-Style">
							<p>View and Model are decoupled.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Controller depends on View and Model.</p>
						</td>
						<td class="No-Table-Style">
							<p>One Presenter manages at least one View via callback functions.</p>
						</td>
						<td class="No-Table-Style">
							<p>One VIewmodel manages at least one View via callback functions.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Controller handles user input.</p>
						</td>
						<td class="No-Table-Style">
							<p>View handles user input.</p>
						</td>
						<td class="No-Table-Style">
							<p>View handles user input.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Unit testing on Model only.</p>
						</td>
						<td class="No-Table-Style">
							<p>Unit testing on Model and View.</p>
						</td>
						<td class="No-Table-Style">
							<p>Unit testing on Model, View and Viewmodel.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Comparison of MVC, MVP, and MVVM</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor210"/>Beyond MVC, MVP, and MVVM</h1>
			<p>More architectural patterns have evolved from the three patterns we discussed previously. The in-depth comparison of these patterns is beyond this chapter, but they are worth mentioning:</p>
			<ul>
				<li><strong class="bold">Model-View-Intent (MVI)</strong>: MVI <a id="_idIndexMarker444"/>emerged as a pattern influenced by MVC, MVP, and MVVM around the 2010s in the Android community. MVI has a unique focus on a unidirectional data flow to streamline state management. It also adopts reactive programming paradigms to asynchronously manage the unidirectional data flow, using libraries such as RxJava and RxJS. The interactions among them are shown in <em class="italic">Figure 5</em><em class="italic">.6</em>:</li>
			</ul>
			<div><div><img src="img/B21737_05_6.jpg" alt="Figure 5.6 – MVI interaction" width="937" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – MVI interaction</p>
			<ul>
				<li><strong class="bold">Atomic design</strong>: Introduced <a id="_idIndexMarker445"/>by Brad Frost in his book <em class="italic">Atomic Design</em> in 2013, atomic design breaks down the UI into five levels:<ul><li><strong class="bold">Atoms</strong>: Elemental building blocks such as text fields</li><li><strong class="bold">Molecules</strong>: Functional organization of atoms such as search bars</li><li><strong class="bold">Organisms</strong>: Sectional organization of molecules such as navigation panels</li><li><strong class="bold">Templates</strong>: Visual layout and organization of organisms that form a page</li><li><strong class="bold">Pages</strong>: Business-aware and specific instances of pages with real content</li></ul></li>
				<li><strong class="bold">Component-based</strong>: Focus on separating functionalities into self-contained and reusable components. Each component encapsulates the behaviors, hides its lower-level details, and only exposes higher-level functions via interfaces. It goes together with design systems that contain a library of reusable components with well-defined behaviors. It aims at providing a consistent user experience and optimizing productivity during development. Each component is developed, tested, and deployed independently, which makes it easier to update applications.</li>
				<li><strong class="bold">Server-side rendering (SSR)</strong>: SSR is primarily used in web development but can be extended to mobile and desktop applications. The content of a page is generated on the server instead of in the browser or on clients’ devices. It aims at improving performance and response time by reducing loads in the browser or on clients’ devices, which come in various computation powers. Optimization of data fetching can be done on the server side, and it reduces unnecessary traffic between client<a id="_idIndexMarker446"/> and server. It does, however, increase the server load for processing.</li>
			</ul>
			<h1 id="_idParaDest-123">Summar<a id="_idTextAnchor211"/>y</h1>
			<p>We began the chapter with the MVC pattern. We explored the Model, the View, and how the Controller interacts with them. We also illustrated the concepts with a real-life example of the drafting of a contract for the exchange of services among households. The UI of the drafting and confirmation screens was used in the example, with the Controller driving the navigation and submitting the draft contract.</p>
			<p>Then, we bought in the MVP pattern by evolving from MVC. The Presenter was introduced to replace the Controller, and callback functions from the Model were added to the pattern to further isolate the View and the Model. Then, we came back to the same real-life example, and the original code base of MVC was modified to become MVP.</p>
			<p>Afterward, we introduced the MVVM pattern by evolving from MVP. The View Model was added as an intermediary between the View and the Model. Data binding was supported to automatically synchronize data between the View and the View Model. We reused the same real-life example and refactored it to be an MVVM pattern. A custom bind function was introduced to bind values in View components to fields in the View Model. The View Model could be converted to the Model object upon submission. We discussed the potential enhancement provided by the MVVM pattern, such as real-time validation, distributed processing of the View, and multiple variants of the View.</p>
			<p>We compared the three patterns from multiple perspectives. We discussed the relationship between the View and the Model and how coupled they were in each pattern. The ways of communication among the three patterns were then compared, as well as the ease of unit testing. We looked at the chain of modifications needed in each pattern. In the end, we covered which pattern was suitable according to the scale of the project.</p>
			<p>Finally, we introduced a few architectural patterns in the frontend landscape that evolved from MVC, MVP, and MVVM.</p>
			<p>In the next chapter, we will look into another set of architectural patterns and compare them: monoliths, micro-frontend, microservices, nanoservices, and serverless. They are applied in either frontend or backend systems, but they do share similar fundamental concepts that are worth a discussion.</p>
		</div>
	</div></div></body></html>