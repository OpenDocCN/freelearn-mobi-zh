- en: Chapter 4. Give a Snake a Snack…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges of object-oriented design for a game is how to build fully
    cohesive objects that function as needed for a game. We will build this project
    with that focus in mind. The main class for the player will be as self-contained
    and self-sufficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-contained classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficulty levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling level progression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object lifespan control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project is…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will take on the often copied game that has graced pretty much
    every possible computing platform, from early cell phones to current consoles:
    the snake game. There are many variations under a variety of names, but the mechanics
    are generally the same. You control a snake that is always moving forward. You
    can turn the snake right or left (at right angles only), avoiding walls and eating
    mice (or other food). Each time you eat something, your snake gets longer. You
    can go on eating (and growing) until you run into a wall or your own tail.'
  prefs: []
  type: TYPE_NORMAL
- en: Design approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "classic" way to handle the snake's movement in a snake game is to draw
    a new body segment in the direction the snake is moving, and erase the one at
    the end. While this approach works, we want to use a more object-oriented approach
    in our design.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on letting the snake be as autonomous as possible. We want a `snake`
    class that we can simply instruct to move, and the `snake` object will handle
    the movement itself. The `snake` class will also be able to handle what to do
    when we pass it a message to "turn left" or "turn right".
  prefs: []
  type: TYPE_NORMAL
- en: 'The levels should be generated with a variable number of walls inside the playfield,
    as well as drawing outer walls around the edge of the screen. Finally, we need
    to have mice appear on the playfield as the food. These mice should have a limited
    lifespan, so they will disappear if they are not eaten in a given amount of time.
    When a mouse is eaten or runs out of life, we will replace it with another. Let''s
    see what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design approach](img/9007_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will also establish three difficulty levels, and incrementing game levels
    for each difficulty. Since the game is based primarily on random elements, we
    need to use the difficulty and the level number in setting the variable elements
    in the game (for example, high levels are faster with more mice and more walls),
    as well as the snake's movement speed. That doesn't sound too difficult, does
    it?
  prefs: []
  type: TYPE_NORMAL
- en: Building a better snake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to keep in mind is that the snake is of a variable length.
    The snake could be as short as one segment or as long as 100 segments (in theory—we
    won't get that long in our game). As we said during the design, the snake should
    be as autonomous as possible. With that in mind, let's look at the `SNSnake.h`
    file to see what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `FileSNSnake.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to track how fast the snake should move (`snakeSpeed`) and what direction
    it is moving in (`snakeDirection`). But what is this `SnakeHeading` variable type?
    We will again be placing our common definitions in a separate definitions file,
    `SNDefinitions.h`. Even though we did not import that file in this header, it
    is imported in the `SNSnakeSegment.h` file, which is then imported here, so we
    can use it freely. The definition of `SnakeHeading` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNDefinitions.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `SnakeHeading` type uses these four directional values (which are integers
    in disguise) to keep track which direction, relative to the playfield, the snake
    is facing. This is easier than trying to remember that one means "up".
  prefs: []
  type: TYPE_NORMAL
- en: The entire snake's body, including the head, will be stored in the `NSMutableArray`
    `snakeBody`. This array will contain objects of type `SNSnakeSegment`, but we
    don't have to provide those specifics in the header.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect worth pointing out is that we declare some of these variables as
    properties. Why only some, and not others? When you declare a property, it can
    be accessed from outside the class. A variable without a property declaration
    will be only usable inside the class in which it is defined. So here, we know
    we will want the main playfield to be able to use the `snakeSpeed`, `snakeDirection`,
    and `snakeBody`, so we declare those as properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `headRow` and `headColumn` are convenience variables to keep track of where
    we want the head of the snake to start in our playing grid. These could be done
    away with entirely and hardcode the starting values, but this allows us to easily
    relocate the snake's starting position without digging through the code to identify
    the values to change.
  prefs: []
  type: TYPE_NORMAL
- en: We will be handling all of the segment creation within this class (using the
    `addSegment` method), so we need to keep a reference to the game layer itself.
    This is stored in the `parentLayer` variable, which is of type `SNPlayfieldLayer`.
    As we discussed in [Chapter 3](ch03.html "Chapter 3. Thumping Moles for Fun"),
    *Thumping Moles for Fun*, the `@class` declaration at the top of the header file
    tells the compiler "we have a class called `SNPlayfieldLayer` , but that's all
    you need to know for now". Unlike our use of a forward declaration in [Chapter
    3](ch03.html "Chapter 3. Thumping Moles for Fun"), we do need to call a method
    from that class, so we will add the line `#import "SNPlayfieldLayer.h"` into the
    `SNSnake.m` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also provide several exposed methods in the header. These should all be
    fairly self-explanatory. We do need to point out the one class method, `createWithLayer:
    withLength:`. In earlier chapters, we often took the approach of using default
    `init` structures, and filled in the variables after the object was instantiated.
    While this does work, it is often cleaner to build your own class methods to ensure
    that no required parameters are overlooked. This approach also allows us to pursue
    our goal with this game of making the snake as self-contained as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a snake segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the `SNSnake` implementation, let's turn our attention to
    the `SNSnakeSegment`. This is the object that will represent each segment of the
    snake, both head and body. This class is a mostly unmodified subclass of `CCSprite`,
    but we will make a small, yet important change to its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnakeSegment.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We establish a property named `priorPosition` , which is the position where
    this sprite was before the last time it moved. We also keep a property for `parentSegment`.
    The `parentSegment` is the segment of the snake directly in front of the current
    segment. In this way, each snake segment has a direct connection to the segment
    in front of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnakeSegment.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This class is very brief, yet it will make our game a lot easier to build. In
    most ways this will behave as a normal `CCSprite`, except when the `setPosition`
    method is used. We are overriding `setPosition` to provide new behavior. First,
    we store our current position in the `priorPosition` variable, and then we call
    the `super setPosition` method, which actually calls the standard `CCSprite` `setPosition`
    method. All told, this will behave like a standard `setPosition`, except that
    it is quietly storing the coordinates of its last position before the move. To
    understand why, we will need to look at the snake's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with the `createWithLayer:withLength:` class method, and the related
    `initWithLayer:withLength:` instance method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We keep a reference to the layer passed (as `parentLayer`), initialize the `NSMutableArray
    snakeBody`, and set some default values for the rest of the variables. We then
    call `addHead` to add the snake's head. This must be called before we make any
    calls to `addSegment`, because we need the head to be the first element in the
    array. We then use the `startLength` variable to determine how many times we need
    to call the `addSegment` method. Notice that the `addSegment` loop will iterate
    one time less than the passed `startLength`. We do this because the head does
    count as a part of the snake length, so if we requested a `snakeLength` of five,
    we only need to generate four body segments.
  prefs: []
  type: TYPE_NORMAL
- en: Building the head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's look at the `addHead` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We begin this method by using the standard `CCSprite` `spriteWithSpriteFrameName`
    convenience method to create the sprite. Next we see one of the reasons we keep
    a reference to the `parentLayer`. To set the value of the `CGPoint newPos`, we
    call the `positionForRow:andColumn:` method directly from the parent layer. Calling
    the method from the parent layer guarantees we are using the same grid formula
    for all object position calculations, without having to maintain multiple versions
    of the same `positionForRow:` method in different classes. This is the only piece
    of code that uses the `headRow` and `headColumn` variables, so we could have avoided
    those variables and embedded the values directly in this method call if we wanted
    to tighten up the code. We set the position for our `newSeg` to the value of `newPos`,
    and then we set the value of `priorPosition` to the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line is the only real substantial difference between the head and
    a body segment: we set the `parentSegment` to nil. If the segment does not have
    a `parentSegment`, we can be sure it is the head segment.'
  prefs: []
  type: TYPE_NORMAL
- en: After adding the snake's head to the `snakeBody` array, we add the head as a
    child of the `parentLayer`. Notice we use a `Z` order of 100\. When we create
    the snake, we want the head to overlap the next body segment, so we start with
    a high `Z` value for the head.
  prefs: []
  type: TYPE_NORMAL
- en: Building the body segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now turn our attention to the `addSegment` method, which adds a single body
    segment to the snake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this looks very similar to the `addHead` method. Let's take
    a closer look. We use a different image for the body segments. Then we look up
    the last segment in the `snakeBody` array. Here we use the prior segment's position
    as the position for our new segment. We also set the `parentSegment` variable
    to point to the prior segment. So each segment now has a connection to the one
    in front of it, and it identifies its own position as being in the prior location
    of the parent segment. (For the initial building of the snake, these will all
    share the same coordinates, but this design will be essential when we are calling
    this method during gameplay.)
  prefs: []
  type: TYPE_NORMAL
- en: We add this segment to the `snakeBody` array, and then add this segment to the
    `parentLayer`. You will notice we assign the `Z` order as `100 – [snakeBody count].`
    This will essentially slip each segment under the segment in front of it, since
    a higher `Z` order is drawn on top of lower `Z` orders.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the snake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now turn our attention to the way we move the snake. Since we want as much
    of the snake's control inside the snake object, we will be generating our own
    `move` method, instead of using `setPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNDefinition.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `SNDefinitions.h` file we have created a `gridSize` definition that works
    well with the graphics we have defined for this project. Having a centralized
    `gridSize` definition allows us to alter the dimensions of the playfield in one
    place. With that definition fresh in our minds, let's look at the `move` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the `snakeDirection` variable and the defined `gridSize` to determine
    where to move the head of the snake. All of the snake's movements will be constrained
    to the grid. If we allowed free movement, it would be extremely easy to run into
    the edges of a wall. By constraining the snake's movements to a grid, we allow
    the snake to have "close calls" with walls without dying because they were one
    pixel too close.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate through all members of the `snakeBody` array. If the segment
    does not have a `parentSegment` defined, it is the head. We use the `ccpAdd` function
    to add the new `moveByCoords` to the head's current position. The `ccpAdd` function
    takes two `ccp` coordinates as arguments and adds them together into a new `ccp`
    value. The end result is a new position for the head segment, moved in the desired
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a `parentSegment` defined, it is a normal body segment. Here is
    where we take advantage of the extra variables we added to the `SNSnakeSegment`
    class. We set the segment's position to the prior position of their parent segment.
    This means for each segment, it will move to the same position just vacated by
    the segment in front of it. In this way, the snake's body will follow the same
    path as the head, even through multiple turns.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have addressed moving the snake, we need to make it turn. As we
    just saw in the `move` method, the movement is completely driven by the `snakeDirection`
    variable. All we need to do is adjust that variable, and the snake will move in
    the new direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the snake is sent the message to `turnLeft`, and the snake is currently facing
    up, the new direction will be facing left. We check each of the four movement
    directions, and change the snake's direction appropriately. Since the `switch`
    statements are using the integer values underlying the `SnakeHeading` type, it
    is very efficient and lightweight code. We repeat the same structure in the `turnRight`
    command, except we change the `snakeDirection` to turn in the correct "turn right"
    direction. (See the code bundle if you need to see how `turnRight` differs from
    `turnLeft`.)
  prefs: []
  type: TYPE_NORMAL
- en: Death of a snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one method left to complete the snake. At some point, the player will
    do something unfortunate and run into a wall (or their own tail). The snake dies,
    and game is over. We include the visual "death" in the snake class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNSnake.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We leverage `cocos2d` actions to give a nice death sequence. We set up two separate
    `CCRepeatForever` sequences that are run simultaneously on the snake's head. We
    flash red and then back to normal sprite color (setting the color to pure white
    gives the original sprite coloring). We also scale the head to twice its own size,
    and then back to normal. We set these with slightly different durations, so the
    two behaviors are not in lockstep with each other. Together, these provide a nice
    appearance of throbbing pain, perfect for the death of the snake.
  prefs: []
  type: TYPE_NORMAL
- en: Building the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The snake is now functionally complete, so we turn our attention to building
    an interesting environment for the snake to live in. All of our game objects use
    the same positioning method we saw when designing the snake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the designated row and column values and multiplies them by
    the `gridSize`. The additional modifiers (-2 and -4) are used to better align
    the walls so there is an equal size of partial walls on the outside edges of the
    screen. This is because the `gridSize` value of `22` does not exactly fit the
    dimensions of the iPhone screen. With this slight adjustment, it looks visually
    centered after we add the outer walls.
  prefs: []
  type: TYPE_NORMAL
- en: Outer walls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first part of the environment to build are the outer walls, since the snake
    needs to be contained on the screen. Let's look at that method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have two separate loops, one for each pair of edges on the screen. The loop
    for the left and right edges is the same, as is the top and bottom edge loop.
    We iterate from the minimum grid position through the maximum grid position for
    that edge of the screen. We base the maximum on the size of the screen divided
    by the `gridSize`, so we will always be at the outside edges, even if we change
    the `gridSize`.
  prefs: []
  type: TYPE_NORMAL
- en: For each position (and side of the screen), we create a new `CCSprite`, set
    its position, and add it to the layer. We also add it to the `wallsOnField` array.
    The `wallsOnField` array is critical to the collision handling routines we will
    address shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Inner walls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we move to building the inner walls, we have a couple of additional details
    to consider. We need to make sure the position is not already occupied by another
    object. We also want to make sure we don't build a wall in front of the snake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We start this method by creating a `CGRect` that is directly in front of the
    snake. This `CGRect` assumes the snake is facing up, which is the default we established
    in the `SNSnake` class. Our design does not allow for adding extra walls during
    a level, so we can be sure the snake is facing up when the environment is built.
  prefs: []
  type: TYPE_NORMAL
- en: We generate a random position, based on the screen size divided by the `gridSize`.
    We go ahead and build a new wall and add it to the layer. At this point, we don't
    know if the wall is in a good position or not, but we add it anyway. We then proceed
    to iterate through all of our arrays to see if the new wall we just created is
    overlapping an existing object, using a call to `CGRectIntersectsRect`. We also
    check to see if the new wall is in the "line of sight" of the snake. If the wall
    is in an empty position, we add it to the `wallsOnField` array. If it is in a
    bad (occupied) position, we remove the wall from the layer and then call the `createWall`
    method again to build a replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Building snake food
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only have one type of object left to complete the environment: mice to eat.
    If you recall from our original design, we want the mice to have a limited lifespan
    before they disappear from the playfield. We do this by creating `SNMouse`, a
    subclass of `CCSprite`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNMouse.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are using a new variable, `lifespan`, and we set it to a random value between
    10 and 20 (this is in seconds). This is defined when the mouse is instantiated,
    so it will be different for each mouse. (Note that we use a class convenience
    method that overrides the `spriteWithSpriteFrameName`. This is needed in `cocos2d
    2.0` because the `init` method is not called during instantiation.) The actual
    creation of the mouse is nearly the same as the `createWall` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only structural difference between this method and the `createWall` method
    is that we don't check for the snake's "line of sight" `CGRect`, since there's
    no harm in putting a mouse directly in front of the snake. That's all it takes
    to make snake food.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions and eating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all of the visible objects on the screen, we can move to the
    collision detection. Collision detection is actually the easy part. We have already
    written code that looks suspiciously like collision detection in the `createWall`
    and `createMouse` methods. The checks we perform are nearly the same, except we
    are concerned only with collisions involving the head of the snake, since it is
    the only part of the snake that can collide with another surface. Let's look at
    the `checkForCollisions` method in two sections. The first section contains the
    checking for game ending crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m` (`checkForCollisions`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First we get the head segment to use in all of our collision checking. We compare
    it against all segments in the `snakebody` array. If the `CGRectIntersectsRect`
    is true (that is, the two `CGRects` are overlapping at least a bit), and the segment
    it is testing is not the head, then it has crashed into its own tail. The second
    check is the same `boundingBox` check we used earlier against all the walls in
    the `wallsOnField` array. Any positive hits in these routines will cause the `snakeCrash`
    method to be called.
  prefs: []
  type: TYPE_NORMAL
- en: The second half is concerned with eating mice. It is a little more involved,
    but still fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m` (`checkForCollisions`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we look for collisions between the snake's head and the mice on the playfield.
    Because we want to eat the mice, not crash into them, we care more about which
    mouse is being eaten. In this case, we retain the mouse that has just been eaten
    in the `mouseToEat` variable. We do this because part of the process we must go
    through to remove the mouse would cause the array to mutate while iterating through
    it, which would cause the game to crash. So we set `mouseToEat` to reference the
    mouse in question, and set the `isMouseEaten` `BOOL` to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are safely outside of the loop through the `miceOnField` array, we can
    remove the mouse from the layer (`removeFromParentAndCleanup`) as well as removing
    it from the `miceOnField` array. We then trigger the creation of a new mouse.
    Since each mouse eaten should lengthen the snake by one, we then call the snake's
    `addSegment` method. This is the same method we used in the initial build of the
    snake.
  prefs: []
  type: TYPE_NORMAL
- en: Levels and difficulties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can play on the same level for only a limited time before your snake becomes
    so long that it is impossible to continue. To solve that issue, we will implement
    levels. Additionally, not everyone likes to play at the same speed to begin with,
    so we will also add difficulty or skill levels. We address this need by another
    custom `init` method for the `SNPlayfieldLayer` class, as shown in the following
    shortened form:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create the scene (and subsequently the layer), we pass it to the starting
    level and skill level. We store those passed values in the variables: `levelNum`
    and `currentSkill`. We want the level and skill-based parameters all centralized,
    so all of the level-control values are set in one method, `createSnake`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we see how we are setting a few important variables based on the `levelNum`
    and `currentSkill`. Part of the "behind the scenes" is our use of mathematical
    operations using the `currentSkill`. It is of type `SNSkillLevel`, which is another
    custom type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNDefinitions.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From this you can see that any reference to the `currentSkill` type is actually
    representing values of `1`, `2`, or `3`. So the number of walls we would create
    for a game on `kSkillHard` and level 10 would be `3 + (10 * 3) = 33`. This allows
    the game to slowly ramp up in difficulty, with the skill level determining not
    only that level 1 begins slightly harder, but the actual difficulty scales up
    faster on the harder skill levels.
  prefs: []
  type: TYPE_NORMAL
- en: The snake speed needs a little explanation. The speed is actually the delay
    between movements. So the lower the number, the faster it moves. Our calculation
    starts at `.3` and uses a formula to speed up as the levels increase. So the previously
    cited example of `kSkillHard` on level 10 would result in a snake speed of `0.3
    – (13 * 0.02)`, which is a pretty fast value of `0.04`. All of this logic was
    centralized in this method so we can tweak the parameters side-by-side as we approach
    our optimal gameplay experience.
  prefs: []
  type: TYPE_NORMAL
- en: The main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the remaining functionality is in the `update` method. There are three
    distinct sections of the loop, and we will look at them in turn. The first section
    handles the movement updates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We use a standard delta time counter to keep adding to the `stepTime` variable.
    On each loop, we check if the `stepTime` is greater than the `snakeSpeed` variable.
    If it is, then we need to move the snake. As discussed in the previous sections
    of the chapter, all we have to do is call the snake's `move` method. The only
    time we need to check for collisions is after the snake's `move` method is called,
    so we call that method next.
  prefs: []
  type: TYPE_NORMAL
- en: Level-up checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have hard-coded the value of `8` as being the total number of mice
    needed to be eaten per level before we advance. Although we don''t reproduce the
    `showLevelComplete` method here, it unschedules the update, gives a "Level Complete"
    display, and then makes the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We call `replaceScene`, requesting the current scene to be replaced with a fresh
    one that is exactly the same, except one level higher. The level-based variables
    we saw in the `createSnake` method will make the next level just a little bit
    harder, and the level up process can continue for as long as the player can keep
    up with it.
  prefs: []
  type: TYPE_NORMAL
- en: Dead mice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third and final piece of the update loop handles the `lifespan` we discussed
    for the mice. Every mouse already has a semi-random `lifespan`, but we haven't
    done anything with it yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We again use the delta time, but this time we subtract the delta from the `lifespan`
    of every mouse on the field. If a mouse's `lifespan` reaches zero, it died of
    old age. We add it to the `deadMice` array so we can get rid of it outside of
    the loop. We use an array in this method because there could be more than one
    mouse whose `lifespan` expires in the same iteration. We remove the dead mice
    from the `miceOnField` array, clear them from the layer, and create new mice in
    their place. This assures that the correct number of mice are on-screen at all
    times.
  prefs: []
  type: TYPE_NORMAL
- en: But…how do we control the snake?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic question of all has been completely ignored until now. We have
    dealt with how the game works internally, but we have actually left the player
    out in the cold. It is precisely because we have done so much "under the hood"
    work on the snake and its environment that makes the touch handler really anti-climatic.
    We will focus on the direct user interaction. (There is additional code that handles
    the game over and some basic splash screens that are outside of the scope of this
    chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `SNPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We start by using a standard conversion of the touch to OpenGL coordinate space.
    We evaluate the converted touch location and compare its `x` value to determine
    which half of the screen has been touched. If the left half of the screen was
    touched, we instruct the snake to turn left. For the right side, we instruct the
    snake to turn right. You will notice that we are using `ccTouchBegan`, rather
    than `ccTouchEnded`. We want responsiveness as soon as the screen is touched,
    not relying on the player lifting their finger off or moving it around. If they
    want to turn, we want to respond as fast as possible, and only trigger once. The
    touch will not trigger again until their finger is raised and tapped again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have focused more on internal structure than we have on
    complex gameplay. By designing each object as fully contained as possible, it
    insulates the layer from the object. If we wanted to change the way the snake's
    movement is handled, for example, we could make those changes in the `SNSnake`
    class without touching the `SNPlayfieldLayer` at all. We have experimented with
    overriding the `setPosition` method to control the serpentine nature of the snake's
    movement. We have implemented easy collision detection. We have also built our
    first game that includes several difficulty levels with increasingly more difficult
    playable levels. Finally, we have seen how adding a single variable can be all
    we really need to turn a `CCSprite` into a mouse with a life of its own (and how
    to get rid of dead ones).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will move on to a brick-breaking game using the `Box2D`
    physics engine. We will use plists to store level data and even build some simple
    power-ups that will change the physics of the game while the game is running.
  prefs: []
  type: TYPE_NORMAL
