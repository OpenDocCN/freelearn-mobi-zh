<html><head></head><body><div><div><h1 id="_idParaDest-128"><a id="_idTextAnchor159"/>Chapter 10: Testing and Debugging Compose Apps</h1>
			<p>Programming is a very creative process. Implementing great-looking <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) with slick animations is pure fun with Jetpack Compose. However, making an outstanding app involves more than just writing code. Testing and debugging are equally as important because no matter how carefully you design and implement your app, bugs and glitches are inevitable, at least in non-trivial programs. Yet there is nothing to fear, as there are powerful tools you can wield to check if your code is acting as intended.</p>
			<p>This chapter introduces you to these tools. Its main sections are listed here:</p>
			<ul>
				<li>Setting up and writing tests</li>
				<li><a id="_idTextAnchor160"/>Understanding semantics</li>
				<li>Debugging Compose apps</li>
			</ul>
			<p>In the first main section, I will walk you through important terms and techniques regarding testing. We will set up the infrastructure, write a simple unit test, and then turn to Compose specifics—for example, <code>createComposeRule()</code> and <code>createAndroidComposeRule()</code>.</p>
			<p>The <em class="italic">Understanding semantics</em> section builds on these foundations. We look at how composable functions are selected—or found—in a test, and why making your app accessible also helps to write better tests. You will also learn about actions and assertions.</p>
			<p>Failing tests often hint at bugs unless, of course, the failure is intentional. If you suspect the code being checked by a test is buggy, a debugging session is due. The final main section, <em class="italic">Debugging Compose apps</em>, explains how to examine your Compose code. We will be revisiting the semantics tree, discussed in the <em class="italic">Understanding semantics</em> section. Finally, I will show you how to take advantage of <code>InspectorInfo</code> and <code>InspectorValueInfo</code>.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>This chapter is based on the <code>TestingAndDebuggingDemo</code> sample. Please refer to <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10</a>.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor162"/>Setting up and writing tests</h1>
			<p>As a software developer, you probably enjoy writing code. Seeing an app gain functionality feels very rewarding, probably more than writing tests—or worse, finding bugs—yet testing and debugging are essential. Eventually, your code will contain bugs, because all non-trivial programs do. To make your developer life easier, you need to familiarize yourself with writing tests and with debugging your own and others' code. Testing an app has various facets that correspond to different types of tests, as outlined here:</p>
			<ul>
				<li><strong class="bold">Unit test</strong>: You<a id="_idIndexMarker356"/> need to make sure that the business logic works as expected. This, for example, means that formulae and calculations always produce correct results. </li>
				<li><strong class="bold">Integration tests</strong>: Are <a id="_idIndexMarker357"/>all building blocks of the app properly integrated? Depending on what the app does, this may include accessing remote services, talking to a database, or reading and writing files on the device. </li>
				<li><strong class="bold">UI tests</strong>: Is th<a id="_idIndexMarker358"/>e UI accurate? Are all UI elements visible on all supported screen sizes? Do they always show the right values? Do interactions such as button clicks or slider movements trigger the intended function? And something very important: are all parts of the app accessible?</li>
			</ul>
			<p>The number of <a id="_idIndexMarker359"/>tests varies among types. It has long been claimed that, ideally, most of your tests should be unit tests, followed by integration tests. This leads to the perception of a <strong class="bold">test pyramid</strong>, with <a id="_idIndexMarker360"/>unit tests being its foundation and UI tests the tip. As with all metaphors, the test pyramid has seen both support and harsh criticism. If you want to learn more about it, and testing strategies in<a id="_idIndexMarker361"/> general, please refer to the <em class="italic">Further reading</em> section at the end of this chapter. Jetpack Compose tests are UI tests. So, while you likely write many corresponding test cases, testing the underlying business logic using unit tests may well be even more important.</p>
			<p>To make testing reliable, comprehensible, and reproducible, automation is used. In the next section, I will show you how to write unit tests using the <em class="italic">JUnit 4</em> testing framework.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor163"/>Implementing unit tests</h2>
			<p>Units are small, isolated <a id="_idIndexMarker362"/>pieces of code—usually a function, method, subroutine, or property, depending on the programming language. Let's look at a simple Kotlin function in the following code snippet:</p>
			<pre>fun isEven(num: Int): Boolean {
  val div2 = num / 2
  return (div2 * 2) == num
}</pre>
			<p><code>isEven()</code> determines if the passed <code>Int</code> value is even. If this is the case, the function returns <code>true</code>; otherwise, it returns <code>false</code>. The algorithm is based on the fact that only even <code>Int</code> values can be divided by <code>2</code> without a remainder. Assuming we use the function often, we certainly want to make sure that the result is always correct. But how do we do that (how do we test that)? To verify <code>isEven()</code> exhaustively, we would need to check every possible input value, ranging from <code>Int.MIN_VALUE</code> to <code>Int.MAX_VALUE</code>. Even on fast computers, this may take some time. Part of the art of writing good unit tests is to identify all the important boundaries and transitions. Regarding <code>isEven()</code>, these might be the following ones:</p>
			<ul>
				<li><code>Int.MIN_VALUE</code> and <code>Int.MAX_VALUE</code></li>
				<li>One negative even and one negative odd <code>Int</code> value</li>
				<li>One positive even and one positive odd <code>Int</code> value</li>
			</ul>
			<p>To write and execute unit tests, you should add the following dependencies to your module-level <code>build.gradle</code> properties file:</p>
			<pre>androidTestImplementation "androidx.test.ext:junit:1.1.3"
androidTestImplementation "androidx.compose.ui:ui-test-
  junit4:$compose_version"
debugImplementation "androidx.compose.ui:ui-test-
  manifest:$compose_version"
testImplementation 'junit:junit:4.13.2'
androidTestImplementation "androidx.test.espresso:espresso-
  core:3.4.0"</pre>
			<p>Depending on which<a id="_idIndexMarker363"/> types of tests you will be adding to your app project, some of the preceding dependencies will be optional. For example, <code>androidx.test.espresso</code> is needed only if your app also contains old-fashioned Views you wish to test (such as in interoperability scenarios).</p>
			<p>Unit tests are executed on your development machine. Test classes are placed inside the <code>app/src/test/java</code> directory and are available through the <code>SimpleUnitTest</code>:</p>
			<div><div><img src="img/B17075_10_1.jpg" alt="Figure 10.1 – Unit tests in the Android Studio Project tool window&#13;&#10;" width="647" height="271"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Unit tests in the Android Studio Project tool window</p>
			<p>Let's look at the<a id="_idIndexMarker364"/> class in the following code snippet:</p>
			<pre>Package
  eu.thomaskuenneth.composebook.testinganddebuggingdemo
import org.junit.*
import org.junit.Assert.assertEquals
class SimpleUnitTest {
  companion object {
    @BeforeClass
    @JvmStatic
    fun setupAll() {
      println("Setting things up")
    }
  }
  @Before
  fun setup() {
    println("Setup test")
  }
  @After
  fun teardown() {
    println("Clean up test")
  }
  @Test
  fun testListOfInts() {
    val nums = listOf(Int.MIN_VALUE, -3, -2, 2, 3,
                      Int.MAX_VALUE)
    val results = listOf(true, false, true, true, false,
                         false)
    nums.forEachIndexed { index, num -&gt;
      val result = isEven(num)
      println("isEven($num) returns $result")
      assertEquals(result, results[index])
    }
  }
}</pre>
			<p>A test class contains<a id="_idIndexMarker365"/> one or more tests. A <code>@Test</code>. It checks certain<a id="_idIndexMarker367"/> well-defined situations, conditions, or criteria. Tests should be isolated, which means they should not rely on previous ones. My example tests if <code>isEven()</code> returns correct results for six input values. Such checks are based on <strong class="bold">assertions</strong>. An assertion<a id="_idIndexMarker368"/> formulates expected behavior. If an assertion is not met, the test fails.</p>
			<p>If you need something to be done before or after each test, you can implement functions and annotate them with <code>@Before</code> or <code>@After</code>. You can achieve something similar using <code>@Rule</code>. We will be looking at this in the following section. To run code before all tests, you need to implement a companion object with a function annotated with <code>@BeforeClass</code> and <code>@JvmStatic</code>. <code>@AfterClass</code> is useful for cleanup purposes after all tests hav<a id="_idTextAnchor164"/>e been run.</p>
			<p>You can run a unit test by right-clicking on the test class in the <strong class="bold">Project</strong> tool window and choosing <strong class="bold">Run '…'</strong>. Once a launch configuration for the test class has been created, you can also run the tests using the menu bar and the toolbar. Test results are presented in the <strong class="bold">Run</strong> tool window, as illustrated in the following screenshot: </p>
			<div><div><img src="img/B17075_10_2.jpg" alt="Figure 10.2 – Test results in the Android Studio Run tool window&#13;&#10;" width="1027" height="433"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Test results in the Android Studio Run tool window</p>
			<p>Although the test <a id="_idIndexMarker369"/>passes, my implementation of <code>isEven()</code> may still not be flawless. While the test checks the upper and lower bounds, it leaves the transition between negative and positive numbers untested. Let's correct this and add another test, as follows:</p>
			<pre>@Test
fun testIsEvenZero() {
  assertEquals(true, isEven(0))
}</pre>
			<p>Fortunately, this test passes, too. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Pay close attention to the parameters a unit receives and the result it produces. Always test boundaries and transitions. Make sure to cover all code paths (if possible) and watch for pitfalls such as exceptions due to invalid arguments (for example, division by zero or wrong number formats).</p>
			<p>Please remember that composable functions are top-level Kotlin functions, so they are prime candidates for unit tests. Let's see how this works. In the next section, you will learn to test a simple Compose UI.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor165"/>Testing composable functions</h2>
			<p>The <code>SimpleButtonDemo()</code> composable (which belongs to the <code>TestingAndDebuggingDemo</code> sample) shows<a id="_idIndexMarker370"/> a box with a button centered inside. Clicking the button for the first time changes its text from <strong class="bold">A</strong> to <strong class="bold">B</strong>. Subsequent clicks toggle between <strong class="bold">B</strong> and <strong class="bold">A</strong>. The code is illustrated in the following snippet:</p>
			<pre>@Composable
fun SimpleButtonDemo() {
  val a = stringResource(id = R.string.a)
  val b = stringResource(id = R.string.b)
  var text by remember { mutableStateOf(a) }
  Box(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.Center
  ) {
    Button(onClick = {
      text = if (text == a) b else a
    }) {
      Text(text = text)
    }
  }
}</pre>
			<p>The text is stored as a mutable <code>String</code> state. It is changed inside the <code>onClick</code> block and used as a parameter for the <code>Text()</code> composable. If we want to test <code>SimpleButtonDemo()</code>, some aspects we likely need to check are these:</p>
			<ul>
				<li><strong class="bold">Initial state of the UI</strong>: Is the initial button text <strong class="bold">A</strong>?</li>
				<li><strong class="bold">Behavior</strong>: Does the first button click change the text to <strong class="bold">B</strong>? <p>Do subsequent clicks toggle between <strong class="bold">B</strong> and <strong class="bold">A</strong>?</p></li>
			</ul>
			<p>Here's what<a id="_idIndexMarker371"/> a simple test class looks like:</p>
			<pre>@RunWith(AndroidJUnit4::class)
class SimpleInstrumentedTest {
  @get:Rule
  val rule = createComposeRule()
  @Before
  fun setup() {
    rule.setContent {
      SimpleButtonDemo()
    }
  }
  @Test
  fun testInitialLetterIsA() {
    rule.onNodeWithText("A").assertExists()
  }
}</pre>
			<p>Unlike the <code>SimpleUnitTest</code> class from the <em class="italic">Implementing unit tests</em> section, its source code is stored inside the <code>app/src/androidTest/java</code> directory (contrary to <code>…/test/…</code> for ordinary unit tests). <code>SimpleInstrumentedTest</code> is an <strong class="bold">instrumented test</strong>. Contrary to <a id="_idIndexMarker372"/>plain unit tests, they are not executed locally on the development machine, but on the Android Emulator or a real device, because they need Android-specific functionality to run. Instrumented tests are available through the <strong class="bold">Project</strong> tool window, as<a id="_idIndexMarker373"/> illustrated in the following screenshot: </p>
			<div><div><img src="img/B17075_10_3.jpg" alt="Figure 10.3 – Instrumented tests in the Android Studio Project tool window&#13;&#10;" width="635" height="181"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Instrumented tests in the Android Studio Project tool window</p>
			<p>You can run an instrumented test by right-clicking on the test class in the <strong class="bold">Project</strong> tool window and choosing <strong class="bold">Run '…'</strong>. Once a launch configuration for the test class has been created, you can also run the tests using the menu bar and the toolbar. Test results are presented in the <strong class="bold">Run</strong> tool window, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B17075_10_4.jpg" alt="Figure 10.4 – Instrumented test results in the Android Studio Run tool window&#13;&#10;" width="1650" height="386"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Instrumented test results in the Android Studio Run tool window</p>
			<p>JUnit <code>@Before</code> and <code>@After</code> annotations in your test class. There are several predefined rules—for example, the <code>TestName</code> rule can provide the current test name inside a test method, as follows:</p>
			<pre>@get:Rule
var name = TestName()
...
@Test
fun testPrintMethodName() {
  println(name.methodName)
}</pre>
			<p>When the <code>testPrintMethodName()</code> function runs, it prints its name. You can see the output <a id="_idIndexMarker375"/>in <code>@Rule</code> annotation to the property getter by adding <code>get:</code>. Failing to do so will result in a <code>ValidationError</code> (<code>The @Rule '…' must be public</code>) message during execution.</p>
			<p>Compose tests are based on rules. <code>createComposeRule()</code> returns an implementation of the <code>ComposeContentTestRule</code> interface, which extends <code>ComposeTestRule</code>. This interface in turn extends <code>org.junit.rules.TestRule</code>. Each <code>TestRule</code> instance implements <code>apply()</code>. This method receives <code>Statement</code> and returns the same, a modified, or completely new <code>Statement</code>. However, writing your own test rules is beyond the scope of this book. To learn more, please refer to the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<p>Which implementation of the <code>ComposeContentTestRule</code> interface <code>createComposeRule()</code> returns depends on the platform. It is <code>AndroidComposeTestRule&lt;ComponentActivity&gt;</code> on Android. That is why you should add a dependency to <code>androidx.compose.ui:ui-test-manifest</code> in the module-level <code>build.gradle</code> file. Otherwise, you may need to manually add a reference to <code>ComponentActivity</code> in the manifest file.</p>
			<p><code>createAndroidComposeRule()</code> allows you to create <code>AndroidComposeTestRule</code> for activity classes other than <code>ComponentActivity</code>. This is useful if you require the functionality of this activity in a test. On Compose for Desktop or Web, <code>createComposeRule()</code> may return different implementations of <code>ComposeContentTestRule</code>, depending on where the Compose UI is hosted. To help make your tests platform-independent, use <code>createComposeRule()</code> whenever possible.</p>
			<p>Your test cases use (among others) methods provided by <code>ComposeContentTestRule</code> implementations. For example, <code>setContent()</code> sets the composable function to act as the content of the current screen—that is, the UI to be tested. <code>setContent()</code> should be called exactly once per test. To achieve this, just invoke it in a <a id="_idIndexMarker376"/>function annotated with <code>@Before</code>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you want to reuse your tests among platforms, try to rely only on methods defined in the <code>ComposeContentTestRule</code>, <code>ComposeContentTestRule</code>, and <code>TestRule</code> interfaces. Avoid calling functions from the implementation.</p>
			<p>Next, let's look at <code>testInitialLetterIsA()</code>. This test case checks if the initial button text is <code>"A"</code>. This comparison is done with an <code>assertExists()</code> <code>onNodeWithText()</code> is called<a id="_idIndexMarker377"/> a <strong class="bold">finder</strong>. Finders work on <strong class="bold">semantics nodes</strong>, and you <a id="_idIndexMarker378"/>will learn more about these in the <em class="italic">Understanding semantics</em> section. But first: why do we need to <em class="italic">find</em> the composable to be tested anyway?</p>
			<p>Unlike the traditional View system, Jetpack Compose does not use references to identify individual UI elements. Please remember that such references are needed in an imperative approach to modify the component tree during runtime. But this is not how Compose works—instead, we declare how the UI should look based on state. Yet, to test if a particular composable looks and behaves as expected, we need to find it among all other children of a Compose hierarchy.</p>
			<p>This is where the <code>Role</code>, <code>Text</code>, and <code>Actions</code>. It is used for accessibility and testing.</p>
			<p>Before we move on, let's briefly recap: <code>onNodeWithText()</code> tries to find a composable (to be, more precisely, a semantics node) with a given text. <code>assertExists()</code> checks if a matching node is present in the current UI. If so, the test passes. Otherwise, it fails.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor166"/>Understanding semantics</h1>
			<p>In the previous section, I showed you a simple test case that checks if a button text matches a given string. Here is another test case. It performs a click on the button to see if the button text<a id="_idIndexMarker380"/> changes as expected:</p>
			<pre>@Test
fun testLetterAfterButtonClickIsB() {
  rule.onNodeWithText("A")
    .performClick()
    .assert(hasText("B"))
}</pre>
			<p>Again, we start by finding the button. <code>performClick()</code> (this is called an <code>Assert(hasText("B"))</code> checks if the button text is <strong class="bold">B</strong> afterward. Assertions determine if a test passes or fails.</p>
			<p><code>onNodeWithText()</code> (an extension function of <code>SemanticsNodeInteractions Provider</code>) returns a <code>SemanticsNodeInteraction</code> semantics node. The <code>SemanticsNodeInteractionsProvider</code> interface is the main entry point into testing and is typically implemented by a test rule. It defines two methods, as follows:</p>
			<ul>
				<li><code>onNode()</code> finds and returns a semantics node (<code>SemanticsNodeInteraction</code>) that matches the given condition.</li>
				<li><code>onAllNodes()</code> finds all semantics nodes that match the given condition. It returns a <code>SemanticsNodeInteractionCollection</code> instance.</li>
			</ul>
			<p>Both are called <strong class="bold">finders</strong> because <a id="_idIndexMarker381"/>they return (<em class="italic">find</em>) semantics nodes matching certain conditions.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor167"/>Working with semantics nodes</h2>
			<p>To see what the <a id="_idIndexMarker382"/>semantics node we tested with <code>testLetterAfterButtonClickIsB()</code> from the previous section looks like, you can add the following expression after <code>.assert(…)</code>:</p>
			<pre>.printToLog("SimpleInstrumentedTest")</pre>
			<p>The result is visible in <strong class="bold">Logcat</strong>, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B17075_10_5.jpg" alt="Figure 10.5 – A semantics node in Logcat&#13;&#10;" width="1103" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – A semantics node in Logcat</p>
			<p><code>SemanticsNodeInteraction</code> represents a semantics node. You can interact with a node by <a id="_idIndexMarker383"/>performing actions such as <code>performClick()</code> or assertions such as <code>assertHasClickAction()</code>, or you can navigate to other nodes such as <code>onChildren()</code>. Such functions are extension functions of <code>SemanticsNodeInteraction</code>. <code>SemanticsNodeInteractionCollection</code> is a collection of semantics nodes. </p>
			<p>Let's look at another finder function, <code>onNodeWithContentDescription()</code>. We will be using it to test if <code>Image()</code> is part of the current UI. The code is illustrated in the following snippet:</p>
			<pre>@Composable
fun ImageDemo() {
  Image(
    painter = painterResource(id =
        R.drawable.ic_baseline_airport_shuttle_24),
    contentDescription = stringResource(id =
        R.string.airport_shuttle),
    contentScale = ContentScale.FillBounds,
    modifier = Modifier
      .size(width = 128.dp, height = 128.dp)
      .background(Color.Blue)
  )
}</pre>
			<p>If the UI of your app contains images, you should add content descriptions for them in most cases. Content descriptions are used, for example, by accessibility software to describe to visually impaired people what is currently presented on screen. So, by adding them, you greatly enhance the usability. Additionally, content descriptions help in finding <a id="_idIndexMarker384"/>composables. You can see these being used in the following code snippet:</p>
			<pre>@RunWith(AndroidJUnit4::class)
class AnotherInstrumentedTest {
  @get:Rule
  val rule = createComposeRule()
  @Test
  fun testImage() {
    var contentDescription = ""
    rule.setContent {
      ImageDemo()
      contentDescription = stringResource(id =
          R.string.airport_shuttle)
    }
    rule.onNodeWithContentDescription(contentDescription)
      .assertWidthIsEqualTo(128.dp)
  }
}</pre>
			<p><code>testImage()</code> first sets the content (<code>ImageDemo()</code>). It then finds a semantics node with the given content description. Finally, <code>assertWidthIsEqualTo()</code> checks if the width of the UI element represented by this node is 128 density-independent pixels wide.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Have you noticed that I used <code>stringResource()</code> to obtain the content description? Hardcoded values can lead to subtle bugs in tests (for example, spelling errors or typos). To avoid them, try to write your tests in a way that they access the same values as the code being tested. But please keep in mind that under the hood, <code>stringResource()</code> relies on Android resources. So, the test case is platform-specific.</p>
			<p>Using <code>onNodeWithText()</code> and <code>onNodeWithContentDescription()</code> makes it easy to <a id="_idIndexMarker385"/>find composable functions that contain texts and images. But what if you need to find the semantics node for something else—for example, a <code>Box()</code>? The following example, <code>BoxButtonDemo()</code>, shows a <code>Box()</code> with a <code>Button()</code> centered inside. Clicking the button toggles the background color of the box from white to light gray and back:</p>
			<pre>val COLOR1 = Color.White
val COLOR2 = Color.LightGray
@Composable
fun BoxButtonDemo() {
  var color by remember { mutableStateOf(COLOR1) }
  Box(
    modifier = Modifier
      .fillMaxSize()
      .background(color = color),
    contentAlignment = Alignment.Center
  ) {
    Button(onClick = {
      color = if (color == COLOR1)
        COLOR2
      else
        COLOR1
    }) {
      Text(text = stringResource(id = R.string.toggle))
    }
  }
}</pre>
			<p>Testing <code>BoxButtonDemo()</code> means <a id="_idIndexMarker386"/>finding the box, checking its initial background color, clicking the button, and checking the color again. To be able to find the box, we tag it using the <code>testTag()</code> modifier, as illustrated in the following code snippet. Applying a tag allows us to find the modified element in tests:</p>
			<pre>val TAG1 = "BoxButtonDemo"
Box(
  modifier = ...
    .testTag(TAG1)
    ...</pre>
			<p>We can check if the box is present, as follows:</p>
			<pre>@Test
fun testBoxInitialBackgroundColorIsColor1() {
  rule.setContent {
    BoxButtonDemo()
  }
  rule.onNode(hasTestTag(TAG1)).assertExists()
}</pre>
			<p>The <code>onNode()</code> finder receives a <code>hasTestTag()</code> <code>hasTestTag()</code> finds a node with the given test tag. There are several predefined matchers. For example, <code>isEnabled()</code> returns whether the node is enabled, and <code>isToggleable()</code> returns <code>true</code> if the node can be toggled.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Google provides a testing cheat sheet at <a href="https://developer.android.com/jetpack/compose/testing-cheatsheet">https://developer.android.com/jetpack/compose/testing-cheatsheet</a>. It nicely groups finders, matchers, actions, and assertions.</p>
			<p>To complete the code for the test, we need to check the background color of the box. But how do we do that? Following previous examples, you may expect a <code>hasBackgroundColor()</code> matcher. Unfortunately, there currently is none. Tests can rely only on what is available through the semantics tree, yet if it does not contain the information we need, we can easily add it. I will show you ho<a id="_idTextAnchor168"/>w in the following section.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor169"/>Adding custom semantics properties</h2>
			<p>If you want to expose <a id="_idIndexMarker389"/>additional information to tests, you can create custom semantics properties. This requires the following:</p>
			<ul>
				<li>Defining <code>SemanticsPropertyKey</code></li>
				<li>Making it available using <code>SemanticsPropertyReceiver</code></li>
			</ul>
			<p>You can see these in use in the following code snippet:</p>
			<pre>val BackgroundColorKey =
        SemanticsPropertyKey&lt;Color&gt;("BackgroundColor")
var SemanticsPropertyReceiver.backgroundColor by
 BackgroundColorKey
@Composable
fun BoxButtonDemo() {
  ...
  Box(
    modifier = ...
      .semantics { backgroundColor = color }
      .background(color = color),
      ...</pre>
			<p>With <code>SemanticsPropertyKey</code>, you can set key-value pairs in semantics blocks in a type-safe way. Each key has one statically defined value type—in my example, this is <code>Color</code>. <code>SemanticsPropertyReceiver</code> is the scope provided by <code>semantics {}</code> blocks. It is intended for <a id="_idIndexMarker390"/>setting key-value pairs via extension functions.</p>
			<p>Here's how to access the custom semantic property in a test case:</p>
			<pre>@Test
fun testBoxInitialBackgroundColorIsColor1() {
  rule.setContent {
    BoxButtonDemo()
  }
  rule.onNode(SemanticsMatcher.expectValue
             (BackgroundColorKey,COLOR1))
     .assertExists()
}</pre>
			<p><code>expectValue()</code> checks whether the value of the given key is equal to the expected value.</p>
			<p>Adding custom values to the semantics tree can be of great help when writing tests. However, please carefully consider if you really need to rely on <code>SemanticsPropertyKey</code>. The semantics tree is also used by the accessibility framework and tools, so it is vital to not pollute the semantics tree with irrelevant information. A solution is to <a id="_idIndexMarker391"/>rethink the testing strategy. Instead of testing <em class="italic">if the initial background color of the box is white</em>, we may just test if the value we pass to the <code>background()</code> function represents white.</p>
			<p>This concludes the sections on testing composable functions. In the following section, we look at debugging Compose apps.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor170"/>Debugging Compose apps</h1>
			<p>The title of this section, <em class="italic">Debugging Compose apps</em>, may indicate major differences to debugging traditional <a id="_idIndexMarker392"/>View-based apps. Fortunately, this is not the case. On Android, all composable hierarchies are wrapped inside <code>androidx.compose.ui.platform.ComposeView</code>. This happens indirectly if you invoke the <code>setContent {}</code> extension function of <code>ComponentActivity</code>, or if you deliberately include a composable hierarchy inside a layout (see <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>). Either way, in the end, <code>ComposeView</code> is displayed on screen—for example, inside an Activity or a Fragment. Therefore, all aspects regarding the basic building blocks of an Android app (Activities, Fragments, Services, Broadcast Receiver, Intents, and Content Provider) remain the same.</p>
			<p>Of course, any UI framework advocates specific debugging habits. For example, the View system requires watching for <code>null</code> references. Also, you need to make sure that changes in state reliably trigger updates of the component tree. Fortunately, neither is relevant for Jetpack Compose. As composables are Kotlin functions, you can follow the creation of the composable hierarchy by stepping through the code and examining <code>State</code> when needed.</p>
			<p>To closely examine the visual representation of your composable functions during runtime, you can use the <strong class="bold">Layout Inspector</strong> of Android Studio, as illustrated in the following screenshot. Once you have deployed your app on the Emulator or a real device, open the tool with <strong class="bold">Layout Inspector</strong> in the <strong class="bold">Tools</strong> menu:</p>
			<div><div><img src="img/B17075_10_6.jpg" alt="Figure 10.6 – The Layout Inspector in Android Studio&#13;&#10;" width="1464" height="567"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – The Layout Inspector in Android Studio</p>
			<p>You can select<a id="_idIndexMarker393"/> the composable to inspect using the tree on the left-hand side of the Android Studio main window. Important attributes are presented on the right. The center of the tool window contains a configurable, zoomable preview. You can also enable a <strong class="bold">three-dimensional</strong> (<strong class="bold">3D</strong>) mode. This allows you to visually inspect the hierarchy by clicking and dragging to rotate the layout.</p>
			<p>If you want to log important values of a composable for debugging purposes, you can easily achieve this with modifiers. The following section shows you how to do this.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor171"/>Using custom modifiers for logging and debugging</h2>
			<p>As I explained in the <em class="italic">Modifying behavior</em> section of <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, a modifier is an ordered, immutable collection of modifier elements. Modifiers can<a id="_idIndexMarker394"/> change the look and behavior of Compose UI<a id="_idIndexMarker395"/> elements. You create custom modifiers by implementing an extension function of <code>Modifier</code>. The following code snippet uses the <code>DrawScope</code> interface to print the size of a composable:</p>
			<pre>fun Modifier.simpleDebug() = then(object : DrawModifier {
  override fun ContentDrawScope.draw() {
    println("width=${size.width}, height=${size.height}")
    drawContent()
  }
})</pre>
			<p>Depending on which interface you choose, you can log different aspects. Using <code>LayoutModifier</code> you could, for example, access layout-related information.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">While this may be a clever trick, it is certainly not the primary use case for modifiers. Therefore, if you implement a custom modifier merely for debugging purposes, you should add it to the modifier chain only when debugging.</p>
			<p>There is also a built-in<a id="_idIndexMarker396"/> feature to provide additional information for<a id="_idIndexMarker397"/> debugging purposes. Several modifiers can receive an <code>inspectorInfo</code> parameter, which is an extension function of <code>InspectorInfo</code>. This class is a builder for an <code>InspectableValue</code> interface (this interface defines a value that is inspectable by tools, giving access to private parts of a value). <code>InspectorInfo</code> has three properties, as follows:</p>
			<ul>
				<li><code>name</code> (provides <code>nameFallback</code> for <code>InspectableValue</code>)</li>
				<li><code>value</code> (provides <code>valueOverride</code> for <code>InspectableValue</code>)</li>
				<li><code>properties</code> (provides <code>inspectableElements</code> for <code>InspectableValue</code>)</li>
			</ul>
			<p>To understand how <code>inspectorInfo</code> is used, let's look in the following screenshot at the implementation of the <code>semantics {}</code> modifier, which adds semantics key-value pairs for testing and accessibility. Please refer to the <em class="italic">Adding custom semantics properties</em> section for details:</p>
			<div><div><img src="img/B17075_10_7.jpg" alt="Figure 10.7 – Source code of the semantics {} modifier&#13;&#10;" width="983" height="343"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Source code of the semantics {} modifier</p>
			<p><code>semantics {}</code> invokes the <code>composed {}</code> modifier, which receives two parameters, <code>inspectorInfo</code> and <code>factory</code> (the modifier to be composed). The <code>inspectorInfo</code> parameter gets the result of the <code>debugInspectorInfo {}</code> factory method (which receives a <code>name</code> instance and two elements for <code>properties</code> as parameters).</p>
			<p><code>composed {}</code> adds a <code>ComposedModifier</code> class<a id="_idIndexMarker398"/> to the modifier chain. This private class implements the <code>Modifier.Element</code> interface and extends <code>InspectorValueInfo</code>, which in <a id="_idIndexMarker399"/>turn implements <code>InspectorValueInfo</code>. The <code>inspectableElements</code> property keeps <code>Sequence</code> of <code>ValueElements</code>.</p>
			<p>To turn on debug inspector information, you must set the <code>isDebugInspectorInfoEnabled</code> global top-level variable in the <code>androidx.compose.ui.platform</code> package to <code>true</code>. Then, you can access and print debug inspector information using reflection. Here's the code you'll need:</p>
			<pre>.semantics { backgroundColor = color }.also {
  (it as CombinedModifier).run {
    val inner = this.javaClass.getDeclaredField("inner")
    inner.isAccessible = true
    val value = inner.get(this) as InspectorValueInfo
    value.inspectableElements.forEach {
      println(it)
    }
  }
}</pre>
			<p>The modifier <a id="_idIndexMarker400"/>returned by <code>semantics {}</code> is of type <code>CombinedModifier</code> because <code>composed {}</code> invokes <code>then()</code>, which uses <code>CombinedModifier</code> under the<a id="_idIndexMarker401"/> hood. Instead of just printing the raw inspectable element, you can customize the output to your needs.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor172"/>Summary</h1>
			<p>In this chapter, we looked at important terms and techniques regarding testing. In the first main section, we set up the infrastructure, wrote and ran a simple unit test locally on the development machine, and then turned to Compose specifics. I introduced you to <code>createComposeRule()</code> and <code>createAndroidComposeRule()</code>.</p>
			<p>Next, we looked at how composable functions are found in a Compose hierarchy, and why making your app accessible also helps in writing better tests. You also learned about actions and assertions. Finally, we added custom entries to the semantics tree.</p>
			<p>The final main section explained how to debug a Compose app. We revisited the semantics tree, and I showed you how to take advantage of <code>InspectorInfo</code> and <code>InspectorValueInfo</code> to debug custom modifiers.</p>
			<p><a href="B17505_11_ePub.xhtml#_idTextAnchor174"><em class="italic">Chapter 11</em></a>, <em class="italic">Conclusion and Next Steps,</em> concludes this book. We look in the crystal ball to see what future versions of Jetpack Compose may add. For example, we preview Material 3 for Compose, which brings <em class="italic">Material You</em> design concepts to Compose apps. And we look beyond Android and examine Compose on other platforms.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor173"/>Further reading</h1>
			<ul>
				<li>This book assumes a basic understanding of how to test Android apps. To learn more, please refer to <em class="italic">Test apps on Android</em> at <a href="https://developer.android.com/training/testing">https://developer.android.com/training/testing</a>.</li>
				<li><em class="italic">JUnit in Action</em> by <em class="italic">Catalin Tudose</em> (<em class="italic">Manning Publications</em>, <em class="italic">2020</em>, <em class="italic">ISBN 978-1617297045</em>) is a thorough introduction to the latest version of the JUnit testing framework.</li>
				<li>If you want to learn more about test automation, you may want to look at <em class="italic">Complete Guide to Test Automation: Techniques, Practices, and Patterns for Building and Maintaining Effective Software Projects</em> by <em class="italic">Arnon Axelrod</em> (<em class="italic">Apress</em>, <em class="italic">2018</em>, <em class="italic">ISBN 978-1484238318</em>).</li>
				<li>To get an insight into the test pyramid metaphor, you may want to refer to <em class="italic">The Practical Test Pyramid</em> by <em class="italic">Ham Vocke</em>, available at <a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>.</li>
			</ul>
		</div>
	</div></body></html>