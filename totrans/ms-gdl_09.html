<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Deployment</h1></div></div></div><p>A Gradle book will be incomplete, unless we talk about the deployment aspect of a software component. In my opinion, in software engineering the most logical step after build automation is deployment. Deployment itself is a different domain and this has very little to do with Gradle. But still I think it makes sense to discuss build and deployment tools together, so that the reader gets an overview <a id="id485" class="indexterm"/>of <strong>Build</strong>, <strong>Deploy</strong>, and <strong>Test</strong> workflow. In this chapter, we will discuss some basics of deployment to give a flavor of the build and<a id="id486" class="indexterm"/> deployment process. We will learn how to use tools such as Gradle, Jenkins, and Docker together to create a build, deployment, and test workflow. Before <a id="id487" class="indexterm"/>we start, we have to understand, what deployment is. Deployment is as important as the build process in the software life cycle. You can write and build great software, but unless the application is deployed, it does not produce much value. Deployment of software is not just about installing software and starting it. It varies from application to application, operating system to operating system. Some application can be deployed just by copying a JAR file to a particular location; some applications require deployment in a web container, or in external containers and so on. We can generalize the deployment process of software as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Prepare the prerequisite hardware and software environment where you want to deploy the application.</li><li class="listitem">Copy project assets on the prepared environment.</li><li class="listitem">Configure assets based on the environment.</li><li class="listitem">Prepare a life cycle of the application such as start, stop, restart, and so on.</li><li class="listitem">Do a sanity check of the application to verify its functionality.</li></ol></div><p>So deployment is not just copying the assets and notifying everyone that the application is ready to use. It also involves a lot of other pre and post steps. Deployment process has also been evolved along with the development processes and is still evolving with newer technologies. There was a time when the operation team used to deploy the application manually on specified nodes, configure load balancing mechanism and routing from box to box to effectively handle client requests. Now, with the help of new cloud infrastructures, such as<a id="id488" class="indexterm"/> <strong>Infrastructure as a Service</strong> (<strong>IaaS</strong>) or with various automation tools, with just one click or with some commands, developer can deploy application on one box, cluster environment, cloud-based environment or containerized environment. In this chapter, we will focus on the deployment process with Docker, an application containerization technology. We will have a detailed look into different aspects of Docker such as installation, configuration; benefits of Docker over virtual server node deployment; deploy application inside Docker; and how to make it available to the outside world.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Role of Gradle in deployment</h1></div></div></div><p>Gradle plays one<a id="id489" class="indexterm"/> of the major roles in the build and deployment process. Developer can use a combination of different tools based on the requirement to automate the complete build and deployment process. Tools such as Jenkins, Puppet, Chef, and Docker help to create the build and deployment infrastructure. But for very simple deployments, some of the Gradle features can be useful. Gradle provides a variety of tasks that can automate some of deployment tasks as mentioned previously. Few useful tasks are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Download task to downloading the artifacts (ZIP, WAR, EAR, and so on) and its dependencies.<p>You can download artifacts by just adding the list in the dependencies closure. In a similar fashion, you can download all the other dependencies needed to run the software. It is not needed to bundle the software with all the dependencies and make it heavy. It is good to download dependencies at the time of the installing the software to make it lightweight.</p></li><li class="listitem">Unzip or untar tasks to unzip the artifacts.<p>Once artifacts and their dependencies are downloaded, next step is to unzip or untar the artifact if required.</p></li><li class="listitem">Configure the application.<p>Configuration or localization of the application can be done in Gradle by adding custom tasks.</p></li><li class="listitem">Start/stop the application.<p>Start/Stop of the application can be performed using existing Gradle tasks, such as JavaExec or any other custom task.</p></li></ol></div><p>In my opinion, though these tasks can be automated in Gradle, a better alternative would be a scripting language such as Shell script or Perl. Later in this chapter when we create an example of build and deployment pipeline, the role of Gradle will be a pure build and test tool. We will not explore any task or plugin specific to deployment. Now we will move on to the next topic, Docker, that has become very popular in recent years with the emergence of micro-service architecture.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Docker overview</h1></div></div></div><p>Docker is an open source container-based virtualization technology that helps to automate the deployment of an application inside a container. Docker uses resource isolation features of the Linux kernel<a id="id490" class="indexterm"/> such as cgroups and kernel namespaces and it allows the running of multiple containers independently and isolated from each other on a host machine. The benefit of Docker over virtual machine is that Docker is a light-weight process compared to a virtual machine and it provides resource isolation when sharing the same kernel including drivers of the host machine. Docker is open source technology and supported on different platforms. As Docker is built on top of Linux kernel, it supports Windows and Mac using<a id="id491" class="indexterm"/> <strong>Boot2Docker</strong> application.</p><p>Some of the main features of<a id="id492" class="indexterm"/> Docker are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Docker Engine: The light-weight container to create, manage and containerize the application.</li><li class="listitem" style="list-style-type: disc">Portability: One of the important features is container-reuse. You can prepare one Tomcat image and use this image as a base image for all other web applications. This image can be deployed in any system like desktop, physical servers, virtual machines, and even in cloud.</li><li class="listitem" style="list-style-type: disc">Docker Hub: Docker also has its own SaaS-based public registry shared with developers across the globe. You can fid different kinds of images like MySQL, Tomcat, Java, Redis, and other technologies. Users can create and upload images to this repository.</li><li class="listitem" style="list-style-type: disc">Faster delivery: Docker containers are very fast compared to virtual machines. This feature helps in reducing the time for development, testing and deployment.</li><li class="listitem" style="list-style-type: disc">API: Docker supports a user friendly API to manage Docker containers.</li></ul></div><p>You might be using virtual machine in an organization infrastructure. Docker is very different from a virtual machine. A virtual machine has its own operating system with device drivers, memory, CPU shares, and son on. On the other hand, a container shares the host operating system and most of these resources with other container on the same host.</p><p>Let's look at some differences between Docker and virtual machines:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Docker uses Linux containers, which <a id="id493" class="indexterm"/>share the same operating system, whereas each virtual machine has its own operating system thus increasing the overhead</li><li class="listitem" style="list-style-type: disc">Docker uses <a id="id494" class="indexterm"/><strong>Another Union File System</strong> (<strong>AUFS</strong>) that is a layered file system. It <a id="id495" class="indexterm"/>has a read-only part that is shared by all containers and write part that is unique for each container to write its own data</li><li class="listitem" style="list-style-type: disc">Docker is a light weight technology that requires minimum resources of its own as it shares the maximum resources, whereas a full VM system shares minimum resources and gets most of resources of its own</li><li class="listitem" style="list-style-type: disc">Docker startup time is very less as compared to VM</li><li class="listitem" style="list-style-type: disc">Docker is mostly suitable for small applications (Micro Services) that can share the common resources and just isolate itself with some processes, whereas VM is suitable for heavier applications that need full isolation of resources</li></ul></div><p>Now in the next two sections, we will work with Docker installation and then we will learn some of the most used Docker commands.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Installing Docker</h1></div></div></div><p>To install Docker in Ubuntu <a id="id496" class="indexterm"/>Trusty 14.04 LTS, following commands can be used:</p><div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
<strong>$ sudo apt-get -y install docker.io</strong>
</pre></div><p>Alternatively, to get the latest version of Docker you can use this:</p><div><pre class="programlisting">
<strong>$ sudo wget -qO- https://get.docker.com/ | sh</strong>
</pre></div><p>To know the installed version, you have to run the <code class="literal">docker version</code> command, as follows:</p><div><pre class="programlisting">
<strong>$ docker version</strong>
<strong>Client version: 1.6.0</strong>
<strong>Client API version: 1.18</strong>
<strong>Go version (client): go1.4.2</strong>
<strong>Git commit (client): 4749651</strong>
<strong>...</strong>
</pre></div><p>Docker is also supported on Mac OS X, Windows, or cloud platforms. Docker installation guide for these <a id="id497" class="indexterm"/>platforms is available at <a class="ulink" href="https://docs.docker.com/">https://docs.docker.com/</a>.</p><p>To verify the installation, you can execute the <code class="literal">docker run hello-world</code> command. This command downloads a test image and runs the command in a container:</p><div><pre class="programlisting">
<strong>$ docker run hello-world</strong>
<strong>Unable to find image 'hello-world' locally</strong>
<strong>Pulling repository hello-world</strong>
<strong>91c95931e552: Download complete </strong>
<strong>a8219747be10: Download complete </strong>
<strong>Hello from Docker.</strong>
</pre></div><p>If the preceding message<a id="id498" class="indexterm"/> is displayed on the console, it means the installation is successful. In the next section, we will learn some of the useful Docker commands.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Docker commands</h1></div></div></div><p>Once Docker is installed on<a id="id499" class="indexterm"/> the host machine, it runs as a daemon process. The interface given to users is a Docker client. Communication between Docker daemon and users happens through Docker client. Docker provides a variety of commands for different needs, which helps to automate the deployment process very easily. Now we will learn different Docker commands. As this is not a Docker book, the discussion will be limited to some basic commands. You can  refer to the following Docker <a id="id500" class="indexterm"/>website for the complete reference guide at <a class="ulink" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Help command</h2></div></div></div><p>Once Docker is installed, to <a id="id501" class="indexterm"/>see the list of all the commands supported you can type <code class="literal">docker help</code>.</p><p>This command lists all the available Docker commands. The basic syntax of a Docker command is <code class="literal">docker &lt;options&gt; command &lt;argument&gt;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec106"/>Download image</h2></div></div></div><p>As we mentioned earlier, Docker provides its own public repository from where you can download the images to <a id="id502" class="indexterm"/>get started with Docker. You do not need to reinvent the wheel by creating the image, unless needed. In the repository, you can find lots of images varying from plain vanilla OS to images embedded with Java, Tomcat, MySQL, and so on. To download an image from the repository, you can use the <code class="literal">docker pull &lt;image name&gt;</code> command, as follows:</p><div><pre class="programlisting">
<strong>$ docker pull ubuntu</strong>

<strong>latest: Pulling from ubuntu</strong>

<strong>e9e06b06e14c: Pull complete </strong>
<strong>a82efea989f9: Pull complete </strong>
<strong>37bea4ee0c81: Pull complete </strong>
<strong>...</strong>
</pre></div><p>By default, this command <a id="id503" class="indexterm"/>pulls images from the public Docker registry, but you can configure private registry as well.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec107"/>The list of images</h2></div></div></div><p>Once the image is<a id="id504" class="indexterm"/> downloaded, you can find the list of images using the <code class="literal">docker images</code> command, as follows:</p><div><pre class="programlisting">
<strong>$ docker images</strong>
<strong>REPOSITORY          TAG                 IMAGE ID            CREATED VIRTUAL SIZE</strong>
<strong>&lt;none&gt;              &lt;none&gt;              07f8e8c5e660        14 hours ago        188.3 MB</strong>
<strong>python              2.7                 912046e33f03        8 days ago          747.9 MB</strong>
<strong>ubuntu              latest              d0955f21bf24        6 weeks ago         188.3 MB</strong>
</pre></div><p>It will list all the downloaded images available in the filesystem. You can create one or many containers using images.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec108"/>Creating a container</h2></div></div></div><p>Once image is<a id="id505" class="indexterm"/> downloaded, you can create a container using the Docker <code class="literal">run</code> command, as follows:</p><div><pre class="programlisting">
<strong>$ docker run -dit --name "testUbuntu1" ubuntu /bin/bash</strong>
<strong>b25a9d5806a71f411631c4bb5c4c2dd4d059d874a24fee2210110ac9e8c2909a</strong>
</pre></div><p>This command creates a container named <code class="literal">testUbuntu1</code> from the image Ubuntu and the command we have mentioned is <code class="literal">/bin/bash</code>, to just execute a shell or command-line interface. The output of this command is the container ID. You can access the container by its name <code class="literal">tesUbuntu1</code> or by the container ID.</p><p>Here the <code class="literal">-d</code> option will start it as a daemon process, the <code class="literal">-i</code> option is for interactive, and the <code class="literal">-t</code> option is to allocate a pseudo<code class="literal">-TTY</code>. Let's create another container as follows:</p><div><pre class="programlisting">
<strong>$ docker run -dit --name "testUbuntu2" ubuntu /bin/bash</strong>
<strong>f9cdd046cbf47f957ef972690592245f27784f5f79ded6ca836afab54b4f9a8f</strong>
</pre></div><p>It will create another container with the name <code class="literal">testUbuntu2</code>. You can create many containers with the same image by giving different names. If you do not specify any name, Docker assigns <a id="id506" class="indexterm"/>some default name. The syntax of the run command is <code class="literal">$ docker run &lt;options&gt; &lt;imagename&gt; &lt;command&gt;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec109"/>The container list</h2></div></div></div><p>To find the list of running<a id="id507" class="indexterm"/> containers use the Docker <code class="literal">ps</code> <a id="id508" class="indexterm"/>command, as shown here:</p><div><pre class="programlisting">
<strong>$ docker ps </strong>
<strong>CONTAINER ID      IMAGE             COMMAND         CREATED         STATUS            PORTS             NAMES</strong>
<strong>b25a9d5806a7      ubuntu:latest     /bin/bash         2 minutes ago   Up 2 minutes                          testUbuntu1 </strong>
</pre></div><p>Here, we have created two containers but the output shows only one container <code class="literal">testUbuntu1</code> that is running. Run the same command now with the <code class="literal">–a</code> option, as follows:</p><div><pre class="programlisting">
<strong>$ docker ps -a</strong>
<strong>CONTAINER ID      IMAGE             COMMAND           CREATED         STATUS                   PORTS             NAMES</strong>
<strong>f8148e333eb3      ubuntu:latest     echo hello world  7 seconds ago   Exited (1) 7 seconds ago                     testUbuntu2       </strong>
<strong>b25a9d5806a7      ubuntu:latest     /bin/bash         3 minutes ago   Up 3 minutes                                 testUbuntu1</strong>
</pre></div><p>The output lists all the containers with individual status. Notice that the <code class="literal">testUbuntu2</code> container is exited, that is, stopped, whereas <code class="literal">testUbuntu1</code> is still running.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec110"/>Start/stop container</h2></div></div></div><p>Once the container is<a id="id509" class="indexterm"/> created from the image, it can be started/stopped using the following commands:</p><div><pre class="programlisting">
<strong>$ docker start|stop containername|containerid</strong>
</pre></div><p>Following is an example of the preceding command:</p><div><pre class="programlisting">
<strong>$ docker stop testUbuntu1</strong>
<strong>$ docker start f8148e333eb3</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec111"/>Connecting to a container</h2></div></div></div><p>If you have started a <a id="id510" class="indexterm"/>container and then you want to connect to the running container console, the Docker <code class="literal">attach</code> command can be used as shown here:</p><div><pre class="programlisting">
<strong>$ docker attach testUbuntu1</strong>
<strong>[Enter]</strong>
<strong>root@b25a9d5806a7:/#</strong>
</pre></div><p>Use <em>Ctrl</em> + <em>P</em> + <em>Q</em> to exit the container. The <code class="literal">exit</code> or <code class="literal">^C</code> command will take you out of the container and additionally, it will stop the running container by killing all the running processes. If you<a id="id511" class="indexterm"/> want to just move out of the container without stopping, use <em>Ctrl</em> + <em>P</em> + <em>Q</em>. These commands could be different based on operating systems. Refer to the Docker documentation for more details.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec112"/>Deleting a container</h2></div></div></div><p>The Docker <code class="literal">rm</code> command deletes or removes <a id="id512" class="indexterm"/>a container<a id="id513" class="indexterm"/> from the machine, as follows:</p><div><pre class="programlisting">
<strong>$ docker rm testUbuntu2</strong>
<strong>testUbuntu2</strong>
</pre></div><p>You can check whether it is deleted properly by running the <code class="literal">docker ps -a</code> command:</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec113"/>Removing an image</h2></div></div></div><p>To remove an<a id="id514" class="indexterm"/> image from the system, use the <code class="literal">docker rmi</code> command. This command will remove the image from<a id="id515" class="indexterm"/> the machine. You need to stop any running container before removing the image. This is done as follows:</p><div><pre class="programlisting">
<strong>$ docker rmi ubuntu</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec114"/>Copying files to the container</h2></div></div></div><p>With the UNIX <code class="literal">cp</code> command, a file <a id="id516" class="indexterm"/>can be copied from the host to the container. For example, the following <a id="id517" class="indexterm"/>command copies the <code class="literal">dir1</code> folder from the host system to the container's <code class="literal">/home/mycontents</code> directory. Here we have to provide the absolute path of the container installed in the host machine:</p><div><pre class="programlisting">
<strong>$sudo cp -r dir1 /var/lib/docker/aufs/mnt/b25a9d5806a71f411631c4bb5c4c2dd4d059d874a24fee2210110ac9e8c2909a/home/mycontents/</strong>
</pre></div><p>But this is not a good practice. Alternative solution is to mount the directories when creating the container with the <code class="literal">–v</code> option:</p><div><pre class="programlisting">
<strong>$ docker run -ditP --name testUbuntu -v /home/user1/dir1:/home/dir1 ubuntu</strong>
</pre></div><p>The preceding command <a id="id518" class="indexterm"/>will create a container named <code class="literal">testUbuntu</code>. The command also maps the <code class="literal">/home/user1/dir1</code> directory of host machine to the <code class="literal">/home/dir1</code> directory of the container.</p><p>To copy the<a id="id519" class="indexterm"/> contents from the container to host machine, the <code class="literal">docker cp</code> command can be used, as shown here:</p><div><pre class="programlisting">
<strong>$ docker cp testUbuntu1:/home/dir1/readme.txt .</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Container details</h2></div></div></div><p>The Docker <code class="literal">inspect</code> command helps to<a id="id520" class="indexterm"/> find the complete details<a id="id521" class="indexterm"/> of container run as follows:</p><div><pre class="programlisting">$ docker inspect testUbuntu1
[{
  "Args": [],
  "Config": {
    "AttachStderr": false,
    "AttachStdin": false,
    "AttachStdout": false,
    "Cmd": [
    "/bin/bash"
    ],
    "CpuShares": 0,
    "Cpuset": "",
    "Domainname": "",
    "Entrypoint": null,
    "Env": [
    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    ],
...
...
    "PublishAllPorts": false,
    "VolumesFrom": null
  },
  "HostnamePath": "/var/lib/docker/containers/b25a9d5806a71f411631c4bb5c4c2dd4d059d874a24fee2210110ac9e8c2909a/hostname",
  "HostsPath": "/var/lib/docker/containers/b25a9d5806a71f411631c4bb5c4c2dd4d059d874a24fee2210110ac9e8c2909a/hosts",
"Id": "b25a9d5806a71f411631c4bb5c4c2dd4d059d874a24fee2210110ac9e8c2909a",
"Image": "d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07",
  "MountLabel": "",
  "Name": "/testUbuntu1",
  "NetworkSettings": {
      "Bridge": "docker0",
      "Gateway": "172.17.42.1",
      "IPAddress": "172.17.0.22",
      "IPPrefixLen": 16,
      "PortMapping": null,
      "Ports": {}
  },
  "Path": "/bin/bash",
...
...
}</pre></div><p>It will provide the<a id="id522" class="indexterm"/> complete detail of the container<a id="id523" class="indexterm"/> such as name, path, network settings, IP address, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Updating DNS settings</h2></div></div></div><p>To update DNS settings, you can edit the <code class="literal">/etc/default/docker</code> file. You can change proxy setting and DNS setting<a id="id524" class="indexterm"/> in this file. The content of the file is shown as follows:</p><div><pre class="programlisting"># Docker Upstart and SysVinit configuration file

# Customize location of Docker binary (especially for development testing).
#DOCKER="/usr/local/bin/docker"

# Use DOCKER_OPTS to modify the daemon startup options.
#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"

# If you need Docker to use an HTTP proxy, it can also be specified here.
#export http_proxy="http://127.0.0.1:3128/"

# This is also a handy place to tweak where Docker's temporary files go.
#export TMPDIR="/mnt/bigdrive/docker-tmp"</pre></div><p>Networking in an important<a id="id525" class="indexterm"/> concept and you should spend more time reading about it. More details can be found at <a class="ulink" href="https://docs.docker.com/articles/networking/">https://docs.docker.com/articles/networking/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Creating an image from a container</h2></div></div></div><p>You might be interested in<a id="id526" class="indexterm"/> creating new images from the base container with additional software. Consider an example where you have created the <code class="literal">testUbuntu1</code> container from the base Ubuntu image. Then you have installed Tomcat server, deployed web application, and maybe you have installed some other required software like Ant, Git, and so on. You might want to save all the changes for future. The following <code class="literal">docker commit</code> command is useful in this scenario:</p><div><pre class="programlisting">
<strong>$ docker commit  -m "Creating new image" testUbuntu1 user1/ubuntu_1</strong>
</pre></div><p>This command will create a new image <code class="literal">user1/ubuntu_1</code> that will comprise a basic Ubuntu image and all the applications installed by you on that container. This command will commit the new image to the local repository. Next time, you can start a container from the new image.</p><div><pre class="programlisting">
<strong>$ docker run -dit --name testUbuntu_1  user1/ubuntu_1</strong>
</pre></div><p>This command will create the <code class="literal">testUbuntu_1</code> container using the new image committed earlier. If you have created an account in the Docker<a id="id527" class="indexterm"/> repository (<a class="ulink" href="https://registry.hub.docker.com">https://registry.hub.docker.com</a>), you can even push the new images to the public repository.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Running an application in Docker</h1></div></div></div><p>So far, we have learnt <a id="id528" class="indexterm"/>what is Docker and the different commands to work with Docker. In this section, we will develop a web application and we will deploy the web application in a Docker container. For simplicity, we will download a Tomcat image from the Docker repository. Then the Docker container will be started with proper port mapping, so that it can be accessed from the host machine. Finally, a web application will be deployed in the running container.</p><p>To create a Tomcat container, we will pull an image<a id="id529" class="indexterm"/> from the central repository <a class="ulink" href="https://registry.hub.docker.com/_/tomcat/">https://registry.hub.docker.com/_/tomcat/</a>. The repository provides support for different versions of Tomcat such as 6, 7, and 8. For this application, we will use Tomcat 7.0.57 version. This version can be downloaded from the registry by running the <code class="literal">docker pull tomcat:7.0.57-jre7</code> command.</p><p>After the image is downloaded, we have to create the container using the downloaded image and then start it. The container is created and started with the <code class="literal">docker run</code> command with one of the options <code class="literal">-p &lt;host_port&gt;:&lt;container_port&gt;</code>. This option enables to access the running Tomcat container by routing the host port to the container port. The following command starts the container with the name as <code class="literal">userdetailsservice</code>. Additionally, the <code class="literal">–rm</code> option is used to remove the filesystem when the container exits. This is required for the cleanup process:</p><div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 --name "userdetailsservice" tomcat:7.0.57-jre7</strong>
<strong>Using CATALINA_BASE:   /usr/local/tomcat</strong>
<strong>Using CATALINA_HOME:   /usr/local/tomcat</strong>
<strong>Using CATALINA_TMPDIR: /usr/local/tomcat/temp</strong>
<strong>Using JRE_HOME:        /usr</strong>
<strong>Using CLASSPATH:     /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</strong>
<strong>May 03, 2015 5:03:07 PM org.apache.catalina.startup.VersionLoggerListener log</strong>
<strong>INFO: Server version:        Apache Tomcat/7.0.57</strong>
<strong>...</strong>
</pre></div><p>After running the <a id="id530" class="indexterm"/>command, the Tomcat server is accessible from the host machine at <code class="literal">http://localhost:8181</code>:</p><div><img src="img/B02000_09_01.jpg" alt="Running an application in Docker"/><div><p>Figure 9.1</p></div></div><p>Tomcat server is up and running; and the next task is to deploy the web application in the running container. Deploying the web application can be done in multiple ways. Here we will discuss three different approaches to deploy the web application.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding web application as a data volume: Already we have learnt how to mount a data volume with the container using the -v option. This approach can be applied even to deploy a web application. If we have the file structure of the web application on the host machine, it can be mounted to the webapps directory of Tomcat.<p>The following command shows an example of deploying an application named <code class="literal">userdetailsservice</code> in the <code class="literal">/usr/local/tomcat/webapps/</code> directory of the Tomcat container:</p><div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 -v ~/userdetailsservice:/usr/local/tomcat/webapps/userdetailsservice --name "userdetailsservice" tomcat:7.0.57-jre7</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">Copying WAR file from host to container: Another approach is to copy the application WAR file directly from the host machine to the container. To achieve this, first we have to start the container with the run command as explained previously:<div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 --name "userdetailsservice" tomcat:7.0.57-jre7</strong>
</pre></div><p>When<a id="id531" class="indexterm"/> the container is running, we have to find the long container ID. This can be done as follows using the <code class="literal">docker ps</code> command with the <code class="literal">--no-trunc</code> option:</p><div><pre class="programlisting">
<strong>$ docker ps --no-trunc</strong>
<strong>CONTAINER ID                                                       IMAGE                COMMAND             CREATED              STATUS               PORTS               NAMES</strong>
<strong>1ad08559109a0f5eec535d05d55e76c5ad3646ae7bb6f4fffa92ad4721955349   tomcat:7.0.57-jre7   "catalina.sh run"   About a minute ago   Up About a minute   0.0.0.0:8181-&gt;8080/</strong>
</pre></div><p>Then, we can use the simple UNIX <code class="literal">cp</code> command to copy the <code class="literal">.war</code> file to the Docker file system as shown here:</p><div><pre class="programlisting">
<strong>$ sudo cp ~/UserDetailsService/build/lib/userdetailsservice.war /var/lib/docker/aufs/mnt/1ad08559109a0f5eec535d05d55e76c5ad3646ae7bb6f4fffa92ad4721955349/usr/local/tomcat/webapps</strong>
</pre></div><p>However, this approach is not recommended as copying file from host to container is not a good option. Rather we should use the data mount option.</p></li><li class="listitem" style="list-style-type: disc">Tomcat Admin: Tomcat admin tool can be used to deploy web application from a web-based user interface. To deploy a web app from Tomcat admin, you need to have the proper access privilege to the Tomcat manager GUI. The Tomcat image that we downloaded for this example does not allow us to access the Tomcat admin page. So first, we have to enable access for a user by modifying the <code class="literal">tomcat-users.xml</code> file. We can simply use the <code class="literal">-v</code> option to bind an existing <code class="literal">tomcat-users.xml</code> file to the container as follows:<div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 -v ~/Downloads/tomcat-users.xml:/usr/local/tomcat/conf/tomcat-users.xml --name "userdetailsservice" tomcat:7.0.57-jre7</strong>
</pre></div><p>This approach works well. But if you want to modify the <code class="literal">tomcat-users.xml</code> file of the container permanently, a different approach can be taken. First, we have to start the Tomcat container with the following command:</p><div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 --name "userdetailsservice" tomcat:7.0.57-jre7 command.</strong>
</pre></div><p>Then from another terminal, enter the bash of the container using the Docker <code class="literal">exec</code> command. as shown here:</p><div><pre class="programlisting">
<strong>$ docker exec -it userdetailsservice /bin/bash</strong>
</pre></div></li></ul></div><p>Next step is to modify the <code class="literal">/usr/local/tomcat/conf/tomcat-users.xml</code> file from a text editor. To do this, we might need to install vim with the <code class="literal">apt-get</code> install <code class="literal">vim</code> command. You <a id="id532" class="indexterm"/>are free to use any text editor of your choice:</p><div><pre class="programlisting">
<strong>root@0ff13ab7f076:/usr/local/tomcat# apt-get update</strong>
<strong>root@0ff13ab7f076:/usr/local/tomcat# apt-get install vim</strong>
</pre></div><p>After vim is installed successfully, we have to add the following lines at the end of the <code class="literal">tomcat-users.xml</code> file (before <code class="literal">&lt;/tomcat-users&gt;</code>), to enable access to Tomcat-admin GUI for the admin user:</p><div><pre class="programlisting">&lt;role rolename="manager-gui"/&gt;
&lt;user username="admin" password="admin" roles="manager-gui"/&gt;</pre></div><p>Now, changes have been applied to the container and we have to save the new changes by creating a new image using the <code class="literal">docker commit</code> command as follows:</p><div><pre class="programlisting">
<strong>$ docker commit 0ff13ab7f076 usedetailsimage:v1</strong>
<strong>1d4cbdbe2b6ba97048431dbe2055f1df4d780cf5564200c5946e0944baf84b8f</strong>
</pre></div><p>The new image was saved as <code class="literal">usedetailsimage</code> with the <code class="literal">v1</code> tag. This can be verified by listing all the <code class="literal">docker images</code>:</p><div><pre class="programlisting">
<strong>$ docker images</strong>
<strong>REPOSITORY          TAG                 IMAGE ID            CREATED   VIRTUAL SIZE</strong>
<strong>usedetailsimage     v1                  1d4cbdbe2b6b        8 seconds ago       384.4 MB</strong>
<strong>hello-world         latest              91c95931e552        3 weeks ago         910 B</strong>
<strong>tomcat              7.0.57-jre7         b215f59f9987        3 months ago        345.9 MB</strong>
</pre></div><p>This newly created image can be used to start the Tomcat server as follows:</p><div><pre class="programlisting">
<strong>$ docker run -it --rm -p 8181:8080 --name "userdetailsservice" usedetailsimage:v1</strong>
</pre></div><p>After Tomcat is started successfully, we will be able to log in to the Tomcat administrator page at <code class="literal">http://localhost:8181/manager/</code> with the <code class="literal">admin/admin</code> credentials. The web application can be deployed by selecting the<a id="id533" class="indexterm"/> WAR file to deploy option. Application <code class="literal">userdetailsservice</code> takes few seconds to start up and it will be visible on the Tomcat admin page as shown<a id="id534" class="indexterm"/> in the following screenshot:</p><div><img src="img/B02000_09_02.jpg" alt="Running an application in Docker"/><div><p>Figure 9.2</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Build, Deployment, and Test pipeline</h1></div></div></div><p>In the last section, we <a id="id535" class="indexterm"/>have learned how to create a container like Apache Tomcat with Docker and how to deploy an application in the running <a id="id536" class="indexterm"/>container. Once the application is up and running, we can run some automated tests to verify the functionality. That should be easy! What else can be done? Well, throughout this book we have learned how to automate the build process with Gradle; also in <a class="link" href="ch07.html" title="Chapter 7. Continuous Integration">Chapter 7</a>, <em>Continuous Integration</em>, we discussed continuous integration tools, such as Jenkins. Now we should be able to apply all these knowledge to create a simple build, deploy, and test workflow to automate the complete process from build to deployment. Do not get confused with the continuous delivery pipeline. This is just a simple example to automate the build, deployment, and test together with tools, such as Gradle, Docker, and Jenkins. We can set up the pipeline with three simple steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Automate the process of creating or building the artifacts with Gradle.</li><li class="listitem" style="list-style-type: disc">Deploy the newly created libraries in a running container. The container is created and started with Docker.</li><li class="listitem" style="list-style-type: disc">Run automated tests to verify the functionalities of the deployed application.</li></ul></div><p>These steps can be sequentially configured and executed with the help of Jenkins. All we need to do is to create a new Freestyle project, say <code class="literal">build_deployment_pipeline</code>. Then, add the Source Code Management configuration such<a id="id537" class="indexterm"/> as Git (Git URL is <a class="ulink" href="https://github.com/mitramkm/mastering-gradle.git">https://github.com/mitramkm/mastering-gradle.git</a>) as shown in the following screenshot. For more<a id="id538" class="indexterm"/> details please refer <a class="link" href="ch07.html" title="Chapter 7. Continuous Integration">Chapter 7</a>, <em>Continuous Integration</em>. After the basic Jenkins job configuration, we have to configure<a id="id539" class="indexterm"/> three build steps to automate the build, deployment, and test execution:</p><div><img src="img/B02000_09_03.jpg" alt="Build, Deployment, and Test pipeline"/><div><p>Figure 9.3</p></div></div><p>After the source code management configuration, we have to add a build step in Jenkins to build the web application. In this step, we will execute the <code class="literal">clean war</code> task on a Gradle project named <code class="literal">UserDetailsService</code>. This is a simple web application to expose a RESTful service. The Gradle task will create a WAR file in the <code class="literal">build/libs</code> directory of the project. In the build step configuration, we have specified the <code class="literal">Root Build script</code> as <code class="literal">${workspace}/Chapter9/UserDetailsService</code>. So, the WAR file will be created in the <code class="literal">%JENKINS_HOME%/jobs/build_deployment_pipeline/workspace/Chapter9/UserDetailsService/build/libs/</code> directory:</p><div><img src="img/B02000_09_04.jpg" alt="Build, Deployment, and Test pipeline"/><div><p>Figure 9.4</p></div></div><p>We are done with the first step. Next step is to create a Tomcat container and deploy the WAR file. This can be done by running a shell script that automates the following tasks:</p><div><ol class="orderedlist arabic"><li class="listitem">Pull Tomcat<a id="id540" class="indexterm"/> container from the repository.</li><li class="listitem">Check whether any existing container is running. If any container is running, stop and remove that container.</li><li class="listitem">Start the<a id="id541" class="indexterm"/> container with the required configuration such as port, name, memory, and CPU.</li><li class="listitem">Finally, deploy the application.</li></ol></div><p>The following shell script automates all the operations mentioned previously:</p><div><pre class="programlisting">
<strong>#!/bin/sh</strong>

<strong>if [ -z "$1" ]; then</strong>
<strong>  BUILD_HOME=$(pwd)/UserDetailsService</strong>
<strong>else</strong>
<strong>  BUILD_HOME=$1</strong>
<strong>fi</strong>

<strong>docker pull tomcat:7.0.57-jre7</strong>

<strong>runningContainer=`docker ps -l | grep userdetailsservice | awk '{print $1}'`</strong>

<strong>if [ ! -z "$runningContainer" ]</strong>
<strong>then</strong>
<strong>  docker stop $runningContainer</strong>
<strong>  docker rm $runningContainer</strong>
<strong>fi</strong>

<strong>docker run -d -v $BUILD_HOME/build/libs/userdetailsservice.war:/usr/local/tomcat/webapps/userdetailsservice.war -p 8181:8080 --name "userdetailsservice" tomcat:7.0.57-jre7</strong>
</pre></div><p>The script is ready. We <a id="id542" class="indexterm"/>will configure and execute the script as the second build step in the deployment pipeline job. Though we are using shell script to control docker commands, even this can be done using Gradle tasks (such as Exec) or Gradle plugin for Docker. Some Docker<a id="id543" class="indexterm"/> plugins are available at <a class="ulink" href="https://plugins.gradle.org/">https://plugins.gradle.org/</a>. You can also explore these plugins, if you want to do everything in Gradle way:</p><div><img src="img/B02000_09_05.jpg" alt="Build, Deployment, and Test pipeline"/><div><p>Figure 9.5</p></div></div><p>After the execution of the second build step, the web application is up and running in the Tomcat container. Finally, we have to verify the functionality of the application by running an automated test suite. The sample web application is a RESTful service, which exposes the <code class="literal">getUsers()</code> and <code class="literal">createUser()</code> type functionalities as HTTP GET and POST methods. The following code snippet is an example of <code class="literal">TestNG</code> cases that can be executed as sanity checks. It makes HTTP GET and HTTP POST calls at <code class="literal">http://localhost:8080/userdetailsservice/userdetails</code>:</p><div><pre class="programlisting">@Test 
public void createUser() {
  User request = new User("User1", "User user", "user@abc.com");
  User response = resttemplate.postForObject(URL, request, User.class);
  Assert.assertEquals(response.getEmail(), "user@abc.com");
}
  
@Test(dependsOnMethods="createUser")
public void getUsers() {
  User[] response = resttemplate.getForObject(URL, User[].class);
  Assert.assertEquals(response.length, 1);
}</pre></div><p>To execute the test case, we will create a third build step in the Jenkins pipeline with the task as gradle test. In this example, for simplicity we have created integration test code in the <code class="literal">src/test</code> folder. Ideally, in the <code class="literal">src/test</code> directory, we should keep only unit test code. If you are writing any integration or regression test, it should be done in a separate Java project. Another <a id="id544" class="indexterm"/>point to remember is that, test task is primarily used to execute unit test code. If you are writing some integration test code, consider <a id="id545" class="indexterm"/>creating a new Gradle task (such as <code class="literal">integrationTest</code>) that runs JUnit, TestNG or any other test suite:</p><div><img src="img/B02000_09_06.jpg" alt="Build, Deployment, and Test pipeline"/><div><p>Figure 9.6</p></div></div><p>Now we are ready to run the job in Jenkins. The job executes three tasks sequentially—building a web application, deploying the application in a newly created container, and finally performing some integration tests. The console output of the complete job is displayed in the following screenshot:</p><div><img src="img/B02000_09_07.jpg" alt="Build, Deployment, and Test pipeline"/><div><p>Figure 9.7</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we discussed about application deployment and how to containerize an application with the help of Docker. We learned how to automate build, deploy, and test workflow with Gradle, Docker, and Jenkins.</p><p>In the next chapter, we will cover Android application development and its build process using Gradle.</p></div></body></html>