<html><head></head><body>
		    <div><div><h1 class="Title-1">Chapter 4. Moving to Real-World Hardware</h1>

  <p>In the previous chapter, you learned how to set up the necessary environment configurations and how to build your first vanilla system, targeting the emulator. In this chapter, we will have a quick overview of the fundamental tools of every expert Android user and we will complete our first system for a real device—configure, build, flash, and test.</p>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Debugging tools</h2>

  <p>Debugging tools are some of the tools that no developer can live without. With embedded systems such as Android systems they are even more important. Android provides lots of debugging tools to facilitate complex or boring tasks. The two most important tools are definitely <code class="literal">adb</code> and <code class="literal">fastboot</code>.</p>

  <h3 class="Title-2 sigil_not_in_toc">Introducing ADB</h3>

  <p>ADB stands for Android Debug Bridge and it's a toolkit made of two crucial parts:</p>

  <ul>
    <li>Adb server running on the device</li>

    <li>Adb client running on the PC</li>
  </ul>

  <p>Usually, <code class="literal">adb</code> is considered a command-line tool, but you can find a few graphical frontends online if you prefer to use it in a more graphical way. Android Studio, the official IDE by Google for Android development, uses <code class="literal">adb</code> to communicate with every device and provide cool tools such as <code class="literal">Android Device Monitor</code>. Using the graphical interface, we can analyze logs coming from the device or even take a screenshot for debugging purposes.</p>

  <p>The following screenshot shows how the <strong>Android Device Monitor</strong> can be used to retrieve huge amounts of information from devices and apps running on the devices:</p>

  <div><img class="width50" src="img/epub_36702041_48.jpeg" data-src="img/epub_36702041_48" style="max-width:800px;max-height:684px"/></div>

  <p>During our journey, we will use <code class="literal">adb</code> mostly on the command line, due to the embedded nature of our work. As we know, the emulator behaves like a hardware device, so we can easily use <code class="literal">adb</code> to communicate with it. Let's see a couple of useful commands to interact with our running emulator.</p>

  <p>First of all, we need a handy list of all the available commands. That's easily achievable with the following command:</p>
  <pre><strong>$ adb --help</strong>
</pre>

  <p>Now, we need to detect the connected devices. On our trusty Terminal, run the following command:</p>
  <pre><strong>$ adb devices</strong>
</pre>

  <div><img class="width50" src="img/epub_36702041_49.jpeg" data-src="img/epub_36702041_49" style="max-width:646px;max-height:176px"/></div>

  <p>The previous command will scan for every attached device and will list them. The previous screenshot shows that our emulator is attached and ready to communicate. In a multidevice scenario, we could have some issue when properly detecting our devices. Adb gives us a further option, <code class="literal">-l</code>:</p>

  <div><img class="width50" src="img/epub_36702041_50.jpeg" data-src="img/epub_36702041_50" style="max-width:694px;max-height:110px"/></div>

  <p>Using the <code class="literal">–l</code> option, <code class="literal">adb</code> will show more details about the devices, and this will help us to identify them properly, as shown in the previous screenshot.</p>

  <p>Once we have detected the device, we can communicate with it in a few ways. One of the most common way is connecting it to the device's internal shell. Every Android device comes with a system shell: it's a common tool for embedded or remote systems. To connect the the internal shell, we simply need to run the following command:</p>
  <pre><strong>$ adb shell</strong>
</pre>

  <p>If we have more then one device, we will need to specify which device we want to connect to, like this:</p>
  <pre><strong>$ adb -s ZX1B226467 shell</strong>
</pre>

  <p>Once we are connected to the internal shell, we can treat the system like a common <code class="literal">*nix</code> system. We can run an <code class="literal">ls</code> command:</p>
  <pre><strong>$ ls –l</strong>
</pre>

  <p>As shown in the next screenshot, we obtain the directory listing:</p>

  <div><img class="width50" src="img/epub_36702041_51.jpeg" data-src="img/epub_36702041_51" style="max-width:1000px;max-height:1015px"/></div>

  <p>We suggest you explore the filesystem and play around. You will find that you can do almost whatever you want, from manipulating files to manipulating applications.</p>

  <h4 class="Title-3 sigil_not_in_toc">Pushing files to devices</h4>

  <p>Adb gives us dozens of useful commands to manage our devices:</p>
  <pre><strong>$ adb push</strong>
</pre>

  <p>The <code class="literal">adb push</code> command is certainly one of the most useful. It allows us to copy files from our computer to our Android device. The next screenshot shows how to upload a single file to our device:</p>

  <div><img class="width50" src="img/epub_36702041_52.jpeg" data-src="img/epub_36702041_52" style="max-width:646px;max-height:162px"/></div>

  <p>We have created a new file, <code class="literal">pippo.txt</code>, containing a single line, <code class="literal">hello pippo</code>, then we uploaded this file to our connected device, into the <code class="literal">/sdcard/</code> folder. As you can see, the first argument is the filename and the second one is the destination we want to copy the file to.</p>

  <p>The next screenshot shows <code class="literal">pippo.txt</code> successfully uploaded to the device's <code class="literal">/sdcard/</code> folder:</p>

  <div><img class="width50" src="img/epub_36702041_53.jpeg" data-src="img/epub_36702041_53" style="max-width:600px;max-height:1066px"/></div>

  <h4 class="Title-3 sigil_not_in_toc">Pulling files from devices</h4>

  <p>During development, we could need to retrieve a file from the device. To achieve this, <code class="literal">adb</code> gives us the opposite of <code class="literal">push</code>, which is <code class="literal">pull</code>:</p>
  <pre><strong>$ adb pull</strong>
</pre>

  <p>The preceding command is able to retrieve a file from a connected device and copy it to our computer. The syntax is fairly similar to <code class="literal">push</code>, simply with an inverse outcome. The next screenshot shows how to <code class="literal">pull</code> our <code class="literal">pippo.txt</code> from the device and copy it to the current directory:</p>

  <div><img class="width50" src="img/epub_36702041_54.jpeg" data-src="img/epub_36702041_54" style="max-width:646px;max-height:178px"/></div>

  <p>We have deleted our original file from the current folder, pulled the one on the device to the current folder, using <code class="literal">.</code> as the destination, and checked that the copied <code class="literal">pippo.txt</code> file contains the expected line, <code class="literal">hello pippo</code>.</p>

  <h4 class="Title-3 sigil_not_in_toc">Installing Android APK files</h4>

  <p>As we know, any Android application is contained in an APK file. Usually, users don't see this file, because they install all their apps using the Google Play Store. As advanced users, we often deal with unreleased applications, for debugging and testing. These apps aren't available on Google Play Store yet, so <code class="literal">adb</code> gives us the opportunity to manually install them with the following command:</p>
  <pre><strong>~$ adb install &lt;path to .apk file&gt;</strong>
</pre>

  <p>The next screenshot shows how the APK file has been successfully installed on our device number ZX1B226467:</p>

  <div><img class="width50" src="img/epub_36702041_55.jpeg" data-src="img/epub_36702041_55" style="max-width:734px;max-height:131px"/></div>

  <h4 class="Title-3 sigil_not_in_toc">Logcat</h4>

  <p>Every complex system such as Android needs a logging system. Android provides logging capabilities via <code class="literal">logcat</code> to help users with development and monitoring. Using the following command:</p>
  <pre><strong>~$ adb logcat</strong>
</pre>

  <p>We can instruct <code class="literal">adb</code> to connect to the Android logging system, select the default buffer, and start printing every single system logging message, in real-time, to our terminal. Android provides other two logging buffers for advanced use:</p>

  <ul>
    <li><code class="literal">radio</code>: This contains all the relevant logging messages related to the radio communication system</li>

    <li><code class="literal">events</code>: This contains messages related to the system events</li>
  </ul>

  <p>We can select a buffer different from the default using the <code class="literal">–b</code> option. For instance, if we want all the logs related to events, we can use the following command:</p>
  <pre><strong>:~$ adb logcat –b events</strong>
</pre>

  <p>Adb <code class="literal">logcat</code> comes with a few interesting output modes. We can select them using the <code class="literal">–v</code> option and the mode name:</p>

  <ul>
    <li>brief</li>

    <li>color</li>

    <li>long</li>

    <li>printable</li>

    <li>process</li>

    <li>raw</li>

    <li>tag</li>

    <li>thread</li>

    <li>threadtime</li>

    <li>time</li>

    <li>usec</li>
  </ul>

  <p>The next screenshot shows <code class="literal">logcat</code> output when we choose the <code class="literal">color</code> mode:</p>

  <div><img class="width50" src="img/epub_36702041_56.jpeg" data-src="img/epub_36702041_56" style="max-width:646px;max-height:418px"/></div>

  <p>As you can see, <code class="literal">logcat</code> will use a different color for every different logging level. We can even filter according to the logging level itself, using the following command:</p>
  <pre><strong>~$ adb logcat *:E</strong>
</pre>

  <p>In this case, we are only displaying error messages. The next screenshot shows every available filtering argument we can use:</p>

  <div><img class="width50" src="img/epub_36702041_57.jpeg" data-src="img/epub_36702041_57" style="max-width:646px;max-height:178px"/></div>

  <p>For a complete list of all the possible options available with <code class="literal">logcat</code>, you can access the <code class="literal">logcat</code> command help using the following command:</p>
  <pre><strong>~$ adb logcat –h</strong>
</pre>

  <p>The following screenshot shows the full list of all the available options with their description:</p>

  <div><img class="width50" src="img/epub_36702041_58.jpeg" data-src="img/epub_36702041_58" style="max-width:1000px;max-height:1194px"/></div>

  <h3 class="Title-2 sigil_not_in_toc">Fastboot</h3>

  <p>Fastboot is the tool that Android gives us to manipulate the device Flash Memory and its partitions, using a computer and an USB connection. Fastboot does not communicate with the Android system. It communicates with a specific firmware able to interact in a minimal system environment: <code class="literal">bootloader mode</code>.</p>

  <p>In the bootloader mode, the system initializes only the minimal amount of hardware and software to accomplish the most critical operations of all:</p>

  <ul>
    <li><code class="literal">flash</code>: This option is used to deploy a new binary system image from the host computer to the device partitions</li>

    <li><code class="literal">erase</code>: This option is used to delete a specific partition</li>

    <li><code class="literal">reboot</code>: This option is used to reboot the device in one of the available booting modes: recovery, bootloader, or standard</li>

    <li><code class="literal">format</code>: This option is used to format a specific partition</li>
  </ul>

  <p>The next screenshot shows the output of the following command, the full list of all the available options of <code class="literal">fastboot</code>:</p>
  <pre><strong>~$ fastboot –-help</strong>
</pre>

  <p>As you can easily imagine, <code class="literal">fastboot</code> will be a big player in the future, when we will start building and testing our custom Android system:</p>

  <div><img class="width50" src="img/epub_36702041_59.jpeg" data-src="img/epub_36702041_59" style="max-width:1000px;max-height:1054px"/></div>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Choosing our hardware</h2>

  <p>In the previous chapters, we learned how to obtain the source code, how the build system works, and how to build our first custom Android system for the emulator. The only things we know about real hardware are that Android is primarily used on smartphones and tablets and that we can certify our hardware according to the Android <strong>Compatibility Definition Document (CDD)</strong>, with all its constraints and rules. The truth is that Android CDD aims to provide guidelines to bring to the market devices that are compliant with Google Mobile Services requirements. This is crucial information because it gives us the freedom to choose different hardware if our goal is not to develop a smartphone or a tablet for the main consumer market.</p>

  <p>In the last two years, the amount of devices not being a smartphone or a tablet, but being able to run Android has increased enormously. There is a whole new ecosystem of te so-called development boards that can run Android or Ubuntu Linux, for instance. Most of these boards are not CDD compliant—they don't have apps such as Google Play Store, YouTube, Google Maps, and so on, but they still run Android and they can still be tested against Android CTS. This is a great opportunity for manufactures or advanced users who want to experiment.</p>

  <p>This scenario is now possible because the actual hardware requirements to boot Android are getting very minimal nowadays. Keep in mind that Android is based on the Linux Kernel and the system itself has a few similarities if we strip away the Google apps ecosystem. Nowadays, most of the boards that are equipped with enough hardware to run Linux have a good chance of running Android as well.</p>

  <h3 class="Title-2 sigil_not_in_toc">Hardware architectures</h3>

  <p>The most popular hardware architecture we find in the Android market is definitely the ARM family, with its ARMv7 and ARMv8-A. Over time, the x86 and MIPS platforms received official support and they have gained market shares in recent months. As a further note, Android 5 Lollipop introduced support for 64-bit architectures.</p>

  <h4 class="Title-3 sigil_not_in_toc">Minimum requirements</h4>

  <p>In a fashion that reminds us of minimal requirements just for playing games, even Android as its own. For instance, Android 5.1 requires at least 512 MB RAM if it is going to be installed on a device with a standard display density device. Otherwise, you will need at least 1.8GB RAM if you are planning to port it to a device with a high density display.</p>

  <p>The previous versions are less demanding when it comes to RAM. Android 4.4 KitKat, for instance, requires only 512 MB RAM. Unfortunately, KitKat comes with other constraints—there is no support for 64-bit architectures and a OpenGL ES 2.0 GPU is necessary.</p>

  <p>Lots of other hardware components, such as cameras, GPS sensors, accelerometers, gyroscopes, touchscreens, and so on, are very common, but they are absolutely optional—if your device does not need a camera, you can just save money. You can tailor your system, starting from a very minimal system, up to what is specifically needed for your use cases.</p>

  <h4 class="Title-3 sigil_not_in_toc">System on Chip – SoC</h4>

  <p>The coming of advanced embedded systems, such as smartphones and tablets, created a huge demand for new embedded chips—more and more small and powerful. When you think about a computer, you think about CPUs, motherboards, video cards, and lots of external devices. In the embedded world, you think about SoC.</p>

  <p>SoC stands for System on Chip and it goes beyond the simple concept of a CPU. Most of the current SoC solutions embed a multicore CPU, RAM controller, ROMs, EEPROMs or Flash memories, USB support, Ethernet support, USART, SPI, and even a power management system. Everything is contained in one single chip, as shown in the next screenshot of an example SoC architecture:</p>

  <div><img class="width50" src="img/epub_36702041_60.jpeg" data-src="img/epub_36702041_60" style="max-width:487px;max-height:542px"/></div>

  <p>As you can imagine, the immediate advantage of this approach is the small size of the system. We can now have powerful, more and more feature complete and complex systems, with smaller and smaller power consumption in a smaller and smaller package, to satisfy every need that the market has.</p>

  <p>The biggest players here are as follows:</p>

  <ul>
    <li>Samsung</li>

    <li>Qualcomm</li>

    <li>Huawei</li>

    <li>Mediatek</li>

    <li>Nvidia</li>

    <li>Intel</li>

    <li>Freescale</li>

    <li>Texas Instrument</li>

    <li>Broadcom</li>
  </ul>

  <h4 class="Title-3 sigil_not_in_toc">The baseband processor</h4>

  <p>If you are planning to develop a smartphone or a radio-enabled device, you are going to deal with some kind of <strong>baseband processor (BP)</strong>. A baseband processor is a separated component; most of the time it is outside the SoC that is in charge of everything related to radio communications.</p>

  <p>The BP is a critical component and it's kept separate for security reasons. Governments have strict policies about radio component certifications and basically, every Government requires that these components are equipped with read-only firmwares. Due to its nature, a BP is usually equipped with a specific real-time operating system and communicates with the external world via an AT commands-based serial bus.</p>

  <h3 class="Title-2 sigil_not_in_toc">Our hardware choice</h3>

  <p>The goal of this book in mainly to teach how to create a custom system for an existing device and how to approach the creation of a working Android system for a device that can be turned into an Android device with a fair amount of will and effort.</p>

  <p>We are going to use two popular devices in this journey:</p>

  <ul>
    <li>Google Nexus 6 by Motorola</li>

    <li>UDOO by Aidilab and SECO</li>
  </ul>

  <h4 class="Title-3 sigil_not_in_toc">Motorola Nexus 6</h4>

  <p>In the second chapter, we learned about Google devices—smartphones, tablets, and so on. In this chapter, we will work with their latest smartphone currently available—the Nexus 6.</p>

  <div><img class="width50" src="img/epub_36702041_61.jpeg" data-src="img/epub_36702041_61" style="max-width:600px;max-height:331px"/></div>

  <p>Nexus 6, codename Shamu, is currently the top device available by Google. Its technical specifics are impressive:</p>

  <ul>
    <li>Qualcomm® Snapdragon™ 805 with quad-core 2.7 GHz CPU</li>

    <li>Display QHD AMOLED, 5.96" 2,560 x 1,440 (493 ppi), 16:9</li>

    <li>Back camera: 13 MP, Led flash, f/2.0</li>

    <li>Front camera: 2 MP</li>

    <li>GPU: Adreno 420</li>

    <li>Wireless: 802.11ac 2x2 (MIMO)</li>

    <li>Bluetooth: 4.1</li>

    <li>NFC</li>

    <li>RAM: 3 GB</li>

    <li>Storage: 32 GB or 64 GB</li>

    <li>Sensors: GPS, gyroscope, accelerometer, light sensor, barometer</li>

    <li>Networking:



      <ul>
        <li>GSM: 850/900/1,800/1,900 MHz</li>

        <li>Band WCDMA: 1/2/4/5/6/8/9/19</li>

        <li>Band LTE: 1/3/5/7/8/9/19/20/28/41</li>

        <li>CA DL: B3-B5, B3-B8</li>
      </ul>
    </li>

    <li>Battery: 3,220 mAh, wireless charging systems</li>
  </ul>

  <p>The following screenshot shows the internal structure—SoCs, battery, display panel:</p>

  <div><img class="width50" src="img/epub_36702041_62.jpeg" data-src="img/epub_36702041_62" style="max-width:600px;max-height:351px"/></div>

  <p>Nexus 6 is obviously a fully CDD and CTS-compliant platform. It's shipped with the full Google Apps package and will be our reference as a certified device.</p>

  <h4 class="Title-3 sigil_not_in_toc">UDOO Quad</h4>

  <p>Completely different compare to the Nexus 6, UDOO is not a smartphone or a Google certified device—there are no Google Apps here. It's a so-called Single Board Computer—a development and experimentation board that can be equipped with Android or Ubuntu Linux. UDOO will be our reference board to prove that we can create a working Android system out of hardware that's pretty different from a smartphone.</p>

  <p>Let's have a look at its technical specifics:</p>

  <ul>
    <li>Freescale ARM i.MX6 Cortex A9 Quad core 1GHz CPU</li>

    <li>GPU Vivante GC 2000 + Vivante GC 355 + Vivante GC 320</li>

    <li>Atmel SAM3X8E ARM Cortex-M3 CPU (same as Arduino Due)</li>

    <li>76 fully available GPIO: 62 digital + 14 digital/analog</li>

    <li>RAM: DDR3 1GB</li>

    <li>Ethernet up to 1,000Mbit/s</li>

    <li>On board micro SD card as primary storage</li>

    <li>HDMI port</li>

    <li>LVDS port</li>

    <li>Wi-Fi module</li>

    <li>SATA interface</li>

    <li>RTC module</li>

    <li>CSI camera connection</li>

    <li>2 USB ports</li>

    <li>2 x 3.5" ports for mic and speakers



      <div><img class="width50" src="img/epub_36702041_63.jpeg" data-src="img/epub_36702041_63" style="max-width:600px;max-height:444px"/></div>
    </li>
  </ul>

  <p>As you can see, there are no sensors—there is no fancy light sensor or gyroscope, no accelerometer, and no GPS. There is no Baseband Processor either—we can't make phone calls, but we have more than enough to run Android on it!</p>

  <h4 class="Title-3 sigil_not_in_toc">Note</h4>

  <p>You have surely spotted the Atmel microprocessor. Basically, UDOO comes with an embedded Arduino microprocessor that can be used to push your experimentations even further—go for it!</p>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Compiling Android for a real-world device</h2>

  <p>By now, you know everything you need to know about the build system and how to retrieve the source code. Retrieving the proper source code for Google official devices is no big deal, but life isn't always so easy. Working with many different devices, you will certainly come across a manufacturer who is not willing to give the source code away. They are not legally forced to release it. This is an unfortunate scenario that, hopefully, will be considered bad marketing and will disappear in the future.</p>

  <p>For our example, instead, we are going to play with two devices that offer great support and that will magnificently serve the purpose.</p>

  <h3 class="Title-2 sigil_not_in_toc">Nexus 6</h3>

  <p>The first device we are going to explore is the official Google Nexus 6 by Motorola. We have already had an overview of the device. If you want to push it even further, you can refer to the official Motorola Nexus 6 web page:</p>

  <p><a class="ulink" href="http://www.motorola.in/consumers/View-all-Mobile-Phones/Nexus-6-by-Motorola/nexus-6-in.html">http://www.motorola.in/consumers/View-all-Mobile-Phones/Nexus-6-by-Motorola/nexus-6-in.html</a></p>

  <p>In the second chapter, we learned how to retrieve the source code for Google official devices. The only thing we need to know now is the specific tag to refer:</p>
  <pre>android-5.1.1_r14</pre>

  <p>The moment we have the source code, we can set up the environment with the setup script and run the <code class="literal">lunch</code> command to specifically target our Nexus 6. The next screenshot shows how we are choosing device number 16, Nexus 6— codename Shamu:</p>
  <pre>aosp_shamu_userdebug</pre>

  <p>Here is the output:</p>

  <div><img class="width50" src="img/epub_36702041_64.jpeg" data-src="img/epub_36702041_64" style="max-width:646px;max-height:567px"/></div>

  <p>For security and copyright reasons, the source base we acquired does not contain everything we need to build the system. Real-world devices, unlike the emulator, come with proprietary software components that must be downloaded separately. For instance, our Nexus 6 has proprietary software by three of its component manufacturers:</p>

  <ul>
    <li><strong>Broadcom</strong>: NFC, Bluetooth, and Wi-Fi</li>

    <li><strong>Motorola</strong>: Media, audio, thermal, touchscreen, and sensors</li>

    <li><strong>Qualcomm</strong>: GPS, audio, camera, gesture, Graphics, DRM, video, and sensors</li>
  </ul>

  <p>The software components are distributed as binary files and can be downloaded at <a class="ulink" href="https://developers.google.com/android/nexus/drivers">https://developers.google.com/android/nexus/drivers</a>, by looking for Nexus 6, build codename LMY48M. Download the three files and extract them into your <code class="literal">WORKING_DIRECTORY</code>. The next screenshot shows the content of your download folder, with the three downloaded files:</p>

  <div><img class="width50" src="img/epub_36702041_65.jpeg" data-src="img/epub_36702041_65" style="max-width:646px;max-height:103px"/></div>

  <p>Every one of the downloaded packages contains a script, once you extract the content. The moment you run this script, it will show you a license you need to accept in order to continue. The next screenshot shows you the process for the <code class="literal">extract-broadcom-shamu.sh</code> file:</p>
  <pre><strong>$ chmod +x extract-broadcom-shamu.sh</strong>
<strong>$ ./extract-broadcom-shamu.sh</strong>
</pre>

  <div><img class="width50" src="img/epub_36702041_66.jpeg" data-src="img/epub_36702041_66" style="max-width:646px;max-height:471px"/></div>

  <p>These three scripts are the final configuration step before launching the actual build process. After we have accepted all the three licenses, we can run our trusted <code class="literal">make</code> command and, patiently, wait for the build process to complete.</p>

  <p>When the build process is over, the <code class="literal">out/target/product/shamu/</code> folder will contain your first Android build for the Google Nexus 6.</p>

  <h3 class="Title-2 sigil_not_in_toc">UDOO Quad</h3>

  <p>UDOO is one of the most popular development boards on the market. The hardware is top notch, the user community is great, it's well documented and it's the perfect workbench for an infinite number of experiments.</p>

  <p>UDOO is not a Google device, so there is no chance we could use the source code we already have to create out custom Android system. We must stick to the source code that UDOO manufacturers provide the advanced users with. You can download the source code from the following link:</p>

  <p><a class="ulink" href="http://download.udoo.org/files/Sources/UDOO_Android_4.4.2_Source_v1.0.tar.gz">http://download.udoo.org/files/Sources/UDOO_Android_4.4.2_Source_v1.0.tar.gz</a></p>

  <p>Once you have downloaded the file, you can extract it using your terminal and the following command:</p>
  <pre><strong>$ tar zxf  UDOO_Android_4.4.2_Source_v1.0.tar.gz</strong>
</pre>

  <h4 class="Title-3 sigil_not_in_toc">Note</h4>

  <p>As you have already figured out, the last available version of the UDOO Android source base is KitKat. When our adventure is over, you could try to port Lollipop to this platform as a new challenging Android project.</p>

  <p>The extracted files and folders look exactly like the official Android folder structure we saw for the Nexus 6. The only real difference is that UDOO provides us with the source code for almost every component—you will find the bootloader source code and even the Linux kernel source code. Both bootloader and kernel will be compiled during the building process, unlike the Nexus 6 scenario, where we got them as precompiled files. The Android system, bootloader, and kernel will be combined to create the final image set we will need to deploy to our UDOO.</p>

  <h4 class="Title-3 sigil_not_in_toc">Setup</h4>

  <p>Before launching the <code class="literal">envsetup</code> script, we need to configure the environment to be able to build the bootloader. We will learn a lot about the bootloader in the next sections. For now, you just need to open up your Terminal and run these commands:</p>
  <pre><strong>$ export ARCH=arm</strong>
<strong>"$ export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-</strong>
<strong>$ export PATH=$PWD/bootable/bootloader/u-boot-imx/tools:$PATH</strong>
<strong>$ source build/envsetup.sh</strong>
</pre>

  <p>As the last configuration step, we need to set up the build system to properly generate the system image for our UDOO:</p>
  <pre><strong>~$: lunch udoo-eng</strong>
</pre>

  <h4 class="Title-3 sigil_not_in_toc">Bootloader</h4>

  <p>Everything is in place. We can now compile the bootloader. Open a Terminal and navigate to the <code class="literal">bootloader</code> folder:</p>
  <pre><strong>$ cd bootbable/bootloader/uboot-imx</strong>
</pre>

  <p>This folder contains the executable to perform the bootloader compilation. Run it like this:</p>
  <pre><strong>$ ./compile –c</strong>
</pre>

  <p>The previous command will show a configuration dialog, like the one in the next screenshot. You will select the hardware configuration you are targeting—CPU, RAM, and so on. When everything is properly configured, the compilation process will be performed and it will generate the bootloader binary images:</p>

  <div><img class="width50" src="img/epub_36702041_67.jpeg" data-src="img/epub_36702041_67" style="max-width:717px;max-height:607px"/></div>

  <h4 class="Title-3 sigil_not_in_toc">System</h4>

  <p>Once we have the bootloader images, we can go back to the source code root folder and launch the main system image build process, using the following command:</p>
  <pre><strong>$ make</strong>
</pre>

  <p>This could take a while, so be patient. As usual, when the compilation is over, you will find all the binary images you will need in the <code class="literal">out/</code> folder, ready to be installed to our hardware and bring it to live.</p>

  <h4 class="Title-3 sigil_not_in_toc">Kernel</h4>

  <p>The Linux kernel will be compiled automatically during the Android system building process. If you want, you can also build the kernel by yourself, using the following commands:</p>
  <pre><strong>$ make -C kernel_imx imx6_udoo_android_defconfig</strong>
<strong>$ make bootimage</strong>
</pre>

  <p>The process will generate a brand new <code class="literal">boot.img</code> in the <code class="literal">out/</code> folder. You can find the specific kernel file in <code class="literal">kernel_imx/arch/arm/boot</code>.</p>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Bootloader mode</h2>

  <p>The previous sections guided you to your first system images, ready to be flashed to your hardware. These images will be deployed to the device memory. The Nexus 6 has an internal Nand memory. The UDOO has a pretty standard SD card. The first step of the deployment is switching the device into the bootloader mode.</p>

  <p>Bootloader mode is a particular state of the device that allows us to transfer and deploy a system image to the device itself, using the <code class="literal">fastboot</code> utility. Every device running Android has this mode, but not every device will let us access it. Some devices come with a locked bootloader, for security reasons or simply because of a short-sighted manufacturer.</p>

  <p>Obviously, we will be able to access the bootloader on our devices: Google is a generous manufacturer and every Nexus device comes with an unlocked or unlockable bootloader; UDOO, as a development board, is designed to be developer friendly, as well.</p>

  <h3 class="Title-2 sigil_not_in_toc">Nexus devices</h3>

  <p>Every Nexus device will let us to access bootloader mode, but every device will do it in its own way. According to the model, we will need a specific sequence of steps to boot the device in bootloader mode. The following table shows how to do it for every Nexus device. Be sure to turn off your device and unplug the USB cable, pick the model from the table, and press the right buttons:</p>

  <div><img class="width60" src="img/epub_36702041_68.jpeg" data-src="img/epub_36702041_68" style="max-width:973px;max-height:1139px"/></div>

  <p>For our Nexus 6, we need to press <em>Volume Down</em> then also press <em>Power</em> and keep both pressed. The smartphone will boot and you will land on a screen like the one in the following screenshot:</p>

  <div><img class="width50" src="img/epub_36702041_69.jpeg" data-src="img/epub_36702041_69" style="max-width:729px;max-height:1200px"/></div>

  <p>Here we are in <code class="literal">Bootloader Mode</code>!</p>

  <p>The first thing you will notice is the quite explicit:</p>

  <p><em>Device is LOCKED</em></p>

  <p>As we said, Nexus devices come with an unlockable bootloader. We just need to connect the device to our computer with a standard USB cable, open a terminal and run the following command:</p>
  <pre><strong>$ fastboot oem unlock</strong>
</pre>

  <p>You will see a notice message that will warn you that unlocking the bootloader will erase everything on your device. Yes, it will. That's unfortunate, but, from a security and system point of view, it's necessary.</p>

  <h4 class="Title-3 sigil_not_in_toc">Note</h4>

  <p>This is the right moment to think about a data backup. You can still abort the process, restart your smartphone, save your data and try again. We will wait for you!</p>

  <p>If you are brave enough and you just don't need all those pictures of little kitties on your phone anymore, just select <code class="literal">YES</code> and the bootloader will unlock smoothly. If for any reason you'd like the bootloader to lock again, you can use the following command:</p>
  <pre><strong>$ fastboot oem lock</strong>
</pre>

  <p>The moment we unlocked the bootloader, we gained full control of the Nand memory—we can erase partitions or flash the system images we have created. Unfortunately, Google does not release the source code of the bootloader, so we wouldn't know how they implement the whole fastboot protocol. Luckily for us, we are going to figure it out thanks to UDOO. The UDOO manufacturer provides us with the full source base, even the one for the bootloader.</p>

  <h3 class="Title-2 sigil_not_in_toc">UDOO family boards</h3>

  <p>UDOO comes as an open book. We can access every partition on its memory, with basically zero effort. There is no such thing as a "button ninja combination" to switch to bootloader mode. We can use a serial connection to analyze the whole boot process, stop it, and interact with it using the control console:</p>

  <ol>
    <li>Connect the serial interface</li>

    <li>Stop the boot sequence</li>

    <li>Access the uboot console</li>

    <li>Run fastboot</li>
  </ol>

  <p>We now have the <code class="literal">fastboot server</code> ready to go. With the server in place, we will be able to connect to fastboot from our computer, using the <code class="literal">fastboot client</code> we already know.</p>

  <p>This process could seem a bit harder than the one from Nexus. That's true. The fact is that UDOO does not ship with a default secret bootloader like the Nexus or any other mainstream smartphone on the market does. UDOO is mainly a development board and, as with lots of such devices, gives you the freedom and power to choose the bootloader you prefer. However, in an effort to be more developer friendly, UDOO can perfectly work with the most popular open source bootloader solution—<code class="literal">uboot</code>.</p>

  <p>The <code class="literal">uboot</code> solution is fully compliant with the standard requirements for a bootloader to properly launch an operating system—hardware initialization, memory test, and so on. It also implements the fastboot protocol and the extraction of the kernel contained in the <code class="literal">boot.img</code>, generated by the build system. These last two features make it fully compatible with Android.</p>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Flashing Android images</h2>

  <p>Here we are. Every piece of the puzzle is in place—you can finally move forward to installing your brand new custom Android version onto your device.</p>

  <h4 class="Title-3 sigil_not_in_toc">Note</h4>

  <p>As a reminder, we built the so-called stock version of the Android system: you won't find any of the Google apps in here—no YouTube, no Google Play Store.</p>

  <h3 class="Title-2 sigil_not_in_toc">Nexus 6</h3>

  <p>After the build process is complete, you will find all the system images you need in the <strong>out/target/product/shamu</strong> folder:</p>

  <ul>
    <li><code class="literal">system.img</code>: This is, well, the system image. It contains the whole operating system—Android Framework, system native libraries, and the system utility app, such as Calc or Clock.</li>

    <li><code class="literal">recovery.img</code>: This image contains what we are going to place in the <em>Recovery</em> partition. It contains a kernel and the recovery software itself.</li>

    <li><code class="literal">boot.img</code>: This image contains the Linux Kernel and a small RamDisk. This image will be placed in the boot partition and will contain all the files needed to initialize the system: <code class="literal">init.rc</code>, for instance, and every other component needed to start the system.</li>
  </ul>

  <p>Every partition can be flashed using a specific partition image and an appropriate command. Switch your Nexus into bootloader mode, plug the USB cable, and let's flash a few partitions. Launch your Terminal, navigate to <code class="literal">out/target/product/shamu</code>, and execute these commands:</p>
  <pre><strong>:$ fastboot flash system system.img</strong>
<strong>:$ fastboot flash boot boot.img</strong>
<strong>:$ fastboot flash recovery recovery.img</strong>
<strong>:$ fastboot reboot</strong>
</pre>

  <p>The last command will reboot your device and your brand new custom Android version will come to life! This first version of the system will definitely look bare without Google Play Store. With no possibility of installing applications, there is very little we can do with a device, indeed. No sad faces, please! In the next chapters, we will learn how to acquire and install the Google apps we need and how to customize our system.</p>

  <p>As a final note, in this first run, we used the Linux Kernel provided by Google—we didn't compile it from sources. In the next chapters, we will learn how to do it and take full control.</p>

  <h3 class="Title-2 sigil_not_in_toc">UDOO</h3>

  <p>As usual, UDOO is slightly different. We have a few possible paths to achieve our goal, but first things first—partitions. The first step is to prepare the SD card with the proper partitions set. Unlike the Nexus and its pre-partitioned Nand memory, ready to be flashed, with UDOO we have full control of the system, even of the memory partitioning.</p>

  <p>Freedom and power come with responsibility—we need to create the proper partitions before being able to install the system. Being developer friendly, the UDOO development team provides a handy script to speed up the job. The root folder of your UDOO working directory contains a <code class="literal">make_sd.sh</code> file. Insert the UDOO SD card in your computer and detect the disk number:</p>

  <ul>
    <li>On Linux, using <code class="literal">df –f</code>, you should look for something like <code class="literal">/dev/mmcblkX</code></li>

    <li>On OS X, using <code class="literal">diskutil list</code> you should look for something like <code class="literal">/dev/rdisksX</code></li>
  </ul>

  <p>A super easy trick is to insert the SD card and note down all the disk numbers. Extract the SD card and figure out the one that is now missing! Once you have detected the disk number, you can run the script like this by specifying the proper disk name:</p>
  <pre><strong>$ ./make_sd.sh /dev/mmcblkX</strong>
</pre>

  <p>The script will automatically erase the SD card, create the partition structure, and copy all the files the build system generated and deployed in <code class="literal">out/</code>. This could take a while, depending on the speed of your SD card.</p>

  <p>As we saw, developing for a Google device is pretty straightforward: we download the source code and start configuring the system to achieve our built images. We end up with a stock version of the system we can later decide to customize as we like. Developing or porting Android to a new hardware is a totally different matter: it is quite different and requires a bit of effort and commitment.</p>

  <p>When you decide to set out for a journey like this, the first crucial step is choosing the proper hardware platform. The market offers a large collection of vendors and every vendor offers his own particular solutions—different SoC, different on-board sensors, cheap low-end boards, or hyper-fast expensive boards. There is no place in this book for discussion about choosing an expensive board or not. We focus on the developer and their world and, as a professional, 99% of the time they will find themselves working with a so-called reference board<em>.</em></p>

  <p>A <strong>reference board</strong> is a particular kind of development board that every vendor offers to its potential clients. Usually, a reference board ships with everything possible on-board—tons of sensors, tons of external devices, tons of connectors, and possible purposes. The final goal is to provide developers with a board that can truly show off the full potential of the SoC and the whole hardware solution. Everything is tailored to make developers' life easy: the Linux Kernel source code is provided, the hardware components specifications are provided, and the documentation is provided.</p>

  <p>The UDOO board we played with in the chapter can be considered close to a reference board. It does not have every possible sensor, but it's easily expandable with external sensors and we know how to communicate with those sensors because the platform is open and easy to debug. An easy way to debug our software and hardware is crucial to make our developing time effective.</p>

  <p>UDOO comes with a handy micro-USB connection that is also a Serial-to-USB converter. Using this connection, we can interact with the board at one of the lowest level monitors and manipulate the boot sequence. To properly connect to the board console, we need to install a specific software on our computer: a modem control and terminal emulator named <code class="literal">minicom</code>.</p>

  <p>You can install it on Ubuntu using <code class="literal">apt-get</code>:</p>
  <pre><strong>$ sudo apt-get install minicom</strong>
</pre>

  <p>You can install it on OS X using <code class="literal">brew</code>:</p>
  <pre><strong>$ brew install minicom</strong>
</pre>

  <p>When we have <code class="literal">minicom</code>, we can connect the turned-off UDOO to the USB port and run the following command on our Terminal:</p>
  <pre><strong>$ minicom –b 115200 –D /dev/ttyUSB0</strong>
</pre>

  <p><code class="literal">ttyUSB0</code> is the system device that the operating system associated to the UDOO connection. It could be different on your system, that is <code class="literal">ttyUSB1</code>, <code class="literal">ttyUSB2</code>, according to the hardware configuration, other connected USB devices, and so on. A bit of trial and error could be necessary.</p>

  <p>We can now plug the power cable in and turn on the board. If the connection is properly configured, you will see the boot sequence as shown in the following screenshot:</p>

  <div><img class="width50" src="img/epub_36702041_70.jpeg" data-src="img/epub_36702041_70" style="max-width:646px;max-height:610px"/></div>

  <p>We can monitor the boot sequence and interact with the system in a few interesting ways. The one we are interested in now is stopping the boot sequence and switching to bootloader mode.</p>

  <p>During the boot sequence, you will see a message suggesting how to stop the boot sequence itself and access <code class="literal">uboot</code>. Once you are in, run <code class="literal">fastboot</code> as shown in the following screenshot:</p>

  <div><img class="width50" src="img/epub_36702041_71.jpeg" data-src="img/epub_36702041_71" style="max-width:646px;max-height:210px"/></div>

  <p>We can now flash the system images we have:</p>
  <pre><strong>$ fastboot flash system system.img</strong>
<strong>$ fastboot flash boot boot.img</strong>
<strong>$ fastboot flash recovery recovery.img</strong>
<strong>$ fastboot reboot</strong>
</pre>

  <p>Having the serial connection still on, when the system reboots, we can enjoy all the system messages that the boot sequence provides: system initialization and Linux kernel loading, until we reach Android loading and finish to Android system console prompt. This is the beauty and the power of having deep access to and knowledge about your system and your hardware. The following screenshot shows a part of the boot sequence in the precise moment of kernel deployment:</p>

  <div><img class="width50" src="img/epub_36702041_72.jpeg" data-src="img/epub_36702041_72" style="max-width:1000px;max-height:920px"/></div>
</div>
		    </div>
		  

		    <div><div><h2 class="Title-1">Summary</h2>

  <p>In this chapter, you have built and installed your first Android system for a real-world device. You now know a lot more about Google Nexus 6 and UDOO board. You have learned how to use ADB and Fastboot. You have learned how to interact with a development board using a serial connection and tools such as minicom, monitoring, and manipulating the boot sequence.</p>

  <p>In the next chapter, we will dig into the Linux kernel building and customization.</p>
</div>
		    </div>
		  </body></html>