["```swift\n$ xcrun swift\nWelcome to Swift version 2.2!  Type :help for assistance.\n>\n\n```", "```swift\n> \"Hello World\"\n$R0: String = \"Hello World\"\n> 3 + 4\n$R1: Int = 7\n> $R0\n$R2: String = \"Hello World\"\n> $R1\n$R3: Int = 7\n```", "```swift\n> 3.141\n$R0: Double = 3.141\n> 299_792_458\n$R1: Int = 299792458\n> -1\n$R2: Int = -1\n> 1_800_123456\n$R3: Int = 1800123456\n```", "```swift\n> 0b1010011\n$R0: Int = 83\n> 0o123\n$R1: Int = 83\n> 0123\n$R2: Int = 123\n> 0x7b\n$R3: Int = 123\n```", "```swift\n> 3.141\n$R0: Double = 3.141\n> Float(3.141)\n$R1: Float = 3.1400003\n```", "```swift\n> 299.792458e6\n$R0: Double = 299792458\n> 299.792_458_e6\n$R1: Double = 299792458\n> 0x1p8\n$R2: Double = 256\n> 0x1p10\n$R3: Double = 1024\n> 0x4p10\n$R4: Double = 4096\n> 1e-1\n$R5: Double = 0.10000000000000001\n> 1e-2\n$R6: Double = 0.01> 0x1p-1\n$R7: Double = 0.5\n> 0x1p-2\n$R8: Double = 0.25\n> 0xAp-1\n$R9: Double = 5\n```", "```swift\n> \"3+4 is \\(3+4)\"\n$R0: String = \"3+4 is 7\"\n> 3+4\n$R1: Int = 7\n> \"7 x 2 is \\($R1 * 2)\"\n$R2: String = \"7 x 2 is 14\"\n```", "```swift\n> let pi = 3.141\npi: Double = 3.141\n> pi = 3\n\nerror: cannot assign to value: 'pi' is a 'let' constant\nnote: change 'let' to 'var' to make it mutable\n> var i = 0\ni: Int = 0\n> ++i\n$R0: Int = 1\n```", "```swift\n> let e:Float = 2.718\ne: Float = 2.71799994\n```", "```swift\n> let ff:UInt8 = 255\nff: UInt8 = 255\n```", "```swift\n> let ooff = UInt16(ff)\nooff: UInt16 = 255\n> Int8(255)\nerror: integer overflows when converted from 'Int' to 'Int8'\nInt8(255)\n^\n> UInt8(Int8(-1))\nerror: negative integer cannot be converted to unsigned type 'UInt8'\nUInt8(Int8(-1))\n^\n```", "```swift\n> var shopping = [ \"Milk\", \"Eggs\", \"Coffee\", ]\nshopping: [String] = 3 values {\n  [0] = \"Milk\"\n  [1] = \"Eggs\"\n  [2] = \"Coffee\"\n}\n```", "```swift\n> var costs = [ \"Milk\":1, \"Eggs\":2, \"Coffee\":3, ]\ncosts: [String : Int] = {\n  [0] = { key = \"Coffee\" value = 3 }\n  [1] = { key = \"Milk\"   value = 1 }\n  [2] = { key = \"Eggs\"   value = 2 }\n}\n```", "```swift\n> shopping[0]\n$R0: String = \"Milk\"\n> costs[\"Milk\"]\n$R1: Int? = 1\n> shopping.count\n$R2: Int = 3\n> shopping += [\"Tea\"]\n> shopping.count\n$R3: Int = 4\n> costs.count\n$R4: Int = 3\n> costs[\"Tea\"] = \"String\"\nerror: cannot assign a value of type 'String' to a value of type 'Int?'\n> costs[\"Tea\"] = 4\n> costs.count\n$R5: Int = 4\n```", "```swift\n> var shoppingSet: Set = [ \"Milk\", \"Eggs\", \"Coffee\", ]\n> // same as: shoppingSet = Set( [ \"Milk\", \"Eggs\", \"Coffee\", ] )\n> shoppingSet.contains(\"Milk\")\n$R6: Bool = true\n> shoppingSet.contains(\"Tea\")\n$R7: Bool = false\n> shoppingSet.remove(\"Coffee\")\n$R8: String? = \"Coffee\"\n> shoppingSet.remove(\"Tea\")\n$R9: String? = nil\n> shoppingSet.insert(\"Tea\")\n> shoppingSet.contains(\"Tea\")\n$R10: Bool = true\n```", "```swift\n> var cannotBeNil: Int = 1\ncannotBeNil: Int = 1\n> cannotBeNil = nil\nerror: cannot assign a value of type 'nil' to a value of type 'Int'\ncannotBeNil = nil\n              ^\n> var canBeNil: Int? = 1\ncanBeNil: Int? = 1\n> canBeNil = nil\n$R0: Int? = nil\n```", "```swift\n> var opt = Optional(1)\nopt: Int? = 1\n> opt == nil\n$R1: Bool = false\n> opt!\n$R2: Int = 1\n```", "```swift\n> opt = nil\n> opt!\nfatal error: unexpectedly found nil while unwrapping an Optional value\nExecution interrupted. Enter Swift code to recover and continue.\nEnter LLDB commands to investigate (type :help for assistance.)\n```", "```swift\n> var implicitlyUnwrappedOptional:Int! = 1\nimplicitlyUnwrappedOptional: Int! = 1\n> implicitlyUnwrappedOptional + 2\n3\n> implicitlyUnwrappedOptional = nil\n> implicitlyUnwrappedOptional + 2\nfatal error: unexpectedly found nil while unwrapping an Optional value\n```", "```swift\n> 1 ?? 2\n$R0: Int = 1\n> nil ?? 2\n$R1: Int = 2\n```", "```swift\n> costs[\"Tea\"] ?? 0\n$R2: Int = 4\n> costs[\"Sugar\"] ?? 0\n$R3: Int = 0\n```", "```swift\n> var shopping = [ \"Milk\", \"Eggs\", \"Coffee\", \"Tea\", ]\n> var costs = [ \"Milk\":1, \"Eggs\":2, \"Coffee\":3, \"Tea\":4, ]\n> var cost = 0\n> if let cc = costs[\"Coffee\"] {\n.   cost += cc\n. }\n> cost\n$R0: Int = 3\n```", "```swift\n> if let cm = costs[\"Milk\"], let ct = costs[\"Tea\"] {\n.   cost += cm + ct\n. }\n> cost\n$R1: Int = 8\n```", "```swift\n> if let cb = costs[\"Bread\"] {\n.   cost += cb\n. } else {\n.   print(\"Cannot find any Bread\")\n. }\nCannot find any Bread\n```", "```swift\n> var i = 17\ni: Int = 17\n> i % 2 == 0 ? \"Even\" : \"Odd\"\n$R0: String = \"Odd\"\n```", "```swift\n> var position = 21\nposition: Int = 21\n> switch position {\n.   case 1: print(\"First\")\n.   case 2: print(\"Second\")\n.   case 3: print(\"Third\")\n.   case 4...20: print(\"\\(position)th\")\n.   case position where (position % 10) == 1:\n.     print(\"\\(position)st\")\n.   case let p where (p % 10) == 2:\n.     print(\"\\(p)nd\")\n.   case let p where (p % 10) == 3:\n.     print(\"\\(p)rd\")\n.   default: print(\"\\(position)th\")\n. }\n21st\n```", "```swift\n> 4...10 ~= 4\n$R0: Bool = true\n> 4...10 ~= 21\n$R1: Bool = false\n```", "```swift\n> for i in 1...12 {\n.   print(\"i is \\(i)\")\n. }\n```", "```swift\n> for _ in 1...12 {\n.   print(\"Looping...\")\n. }\n```", "```swift\n> var shopping = [ \"Milk\", \"Eggs\", \"Coffee\", \"Tea\", ]\n> var costs = [ \"Milk\":1, \"Eggs\":2, \"Coffee\":3, \"Tea\":4, ]\n> var cost = 0\n> for item in shopping {\n.   if let itemCost = costs[item] {\n.     cost += itemCost\n.   }\n. }\n> cost\ncost: Int = 10\n```", "```swift\n> Array(costs.keys)\n$R0: [String] = 4 values {\n  [0] = \"Coffee\"\n  [1] = \"Milk\"\n  [2] = \"Eggs\"\n  [3] = \"Tea\"\n}\n> Array(costs.values)\n$R1: [Int] = 4 values {\n  [0] = 3\n  [1] = 1\n  [2] = 2\n  [3] = 4\n}\n```", "```swift\n> costs.keys\n$R2: LazyMapCollection<[String : Int], String> = {\n  _base = {\n    _base = 4 key/value pairs {\n      [0] = { key = \"Coffee\" value = 3 }\n      [1] = { key = \"Milk\"   value = 1 }\n      [2] = { key = \"Eggs\"   value = 2 }\n      [3] = { key = \"Tea\"    value = 4 }\n    }\n  _transform =}\n}\n```", "```swift\n> for item in costs.keys {\n.   print(item)\n. }\nCoffee\nMilk\nEggs\nTea\n```", "```swift\n> var (a,b) = (1,2)\na: Int = 1\nb: Int = 2\n```", "```swift\n> for (item,cost) in costs {\n.   print(\"The \\(item) costs \\(cost)\")\n. }\nThe Coffee costs 3\nThe Milk costs 1\nThe Eggs costs 2\nThe Tea costs 4\n```", "```swift\n> var sum = 0\n. for var i=0; i<=10; ++i {\n.   sum += i\n. }\nsum: Int = 55\n```", "```swift\n> for var i = 0,j = 10; i<=10 && j >= 0; ++i,--j {\n.   print(\"\\(i), \\(j)\")\n. } \n0, 10\n1, 9\n…\n9, 1\n10, 0\n```", "```swift\n> var deck = [1...13, 1...13, 1...13, 1...13]\n> suits: for suit in deck {\n.   for card in suit {\n.     if card == 3 {\n.       continue // go to next card in same suit\n.     }\n.     if card == 5 {\n.       continue suits // go to next suit\n.     } \n.     if card == 7 {\n.       break // leave card loop\n.     }\n.     if card == 13 {\n.       break suits // leave suit loop\n.     }\n.   } \n. }\n```", "```swift\n> var shopping = [ \"Milk\", \"Eggs\", \"Coffee\", \"Tea\", ]\n> var costs = [ \"Milk\":1, \"Eggs\":2, \"Coffee\":3, \"Tea\":4, ]\n> func costOf(items:[String], _ costs:[String:Int]) -> Int {\n.   var cost = 0\n.   for item in items {\n.     if let ci = costs[item] {\n.       cost += ci\n.     }\n.   }\n.   return cost\n. }\n> costOf(shopping,costs)\n$R0: Int = 10\n```", "```swift\n> func costOf(basket items:[String], prices costs:[String:Int]) -> Int {\n.   var cost = 0\n.   for item in items {\n.     if let ci = costs[item] {\n.       cost += ci\n.     }\n.   }\n.   return cost\n. }\n> costOf(basket:shopping, prices:costs)\n$R1: Int = 10\n```", "```swift\n> func costOf(items items:[String], costs:[String:Int] = costs) -> Int {\n.   var cost = 0\n.   for item in items {\n.     if let ci = costs[item] {\n.       cost += ci\n.     }\n.   }\n.   return cost\n. }\n> costOf(items:shopping)\n$R2: Int = 10\n> costOf(items:shopping, costs:costs)\n$R3: Int = 10\n```", "```swift\nif card < 1 || card > 13 {\n  // report error\n  return\n}\n\n// or alternatively:\n\nif card >= 1 && card <= 13 {\n  // do something with card\n} else {\n  // report error\n}\n```", "```swift\n> func cardName(value:Int) -> String {\n.   guard value >= 1 && value <= 13 else {\n.     return \"Unknown card\"\n.   }\n.   let cardNames = [11:\"Jack\",12:\"Queen\",13:\"King\",1:\"Ace\",]\n.   return cardNames[value] ?? \"\\(value)\"\n. }\n```", "```swift\n> func firstElement(list:[Int]) -> String {\n.   guard let first = list.first else {\n.     return \"List is empty\"\n.   }\n.   return \"Value is \\(first)\"\n. }\n```", "```swift\n> var pair = (1,2)\npair: (Int, Int) ...\n```", "```swift\n> func minmax(numbers:Int…) -> (Int,Int) {\n.   var min = Int.max\n.   var max = Int.min\n.   for number in numbers {\n.     if number < min {\n.       min = number\n.     }\n.     if number > max {\n.       max = number\n.     }\n.   }\n.   return (min,max)\n. }\n> minmax(1,2,3,4)\n$R0: (Int, Int) = {\n  0 = 1\n  1 = 4\n}\n```", "```swift\n> minmax()\n$R1: (Int, Int) = {\n  0 = 9223372036854775807\n  1 = -9223372036854775808\n}\n```", "```swift\n> func minmax(numbers:Int...) -> (Int,Int)? {\n.   var min = Int.max\n.   var max = Int.min\n.   if numbers.count == 0 {\n.     return nil\n.   } else {\n.     for number in numbers {\n.       if number < min {\n.         min = number\n.       }\n.       if number > max {\n.         max = number\n.       }\n.     }\n.     return(min,max)\n.   }\n. }\n> minmax()\n$R2: (Int, Int)? = nil\n> minmax(1,2,3,4)\n$R3: (Int, Int)? = (0 = 1, 1 = 4)\n> var (minimum,maximum) = minmax(1,2,3,4)!\nminimum: Int = 1\nmaximum: Int = 4\n```", "```swift\n> struct MinMax {\n.   var min:Int\n.   var max:Int\n. }\n```", "```swift\n> func minmax(numbers:Int...) -> MinMax? {\n.   var minmax = MinMax(min:Int.max, max:Int.min)\n.   if numbers.count == 0 {\n.     return nil\n.   } else {\n.     for number in numbers {\n.       if number < minmax.min {\n.         minmax.min = number\n.       }\n.       if number > minmax.max {\n.         minmax.max = number\n.       }\n.     }\n.     return minmax\n.   }\n. }\n```", "```swift\n> struct Oops:ErrorType {\n.   let message:String\n. }\n```", "```swift\n> throw Oops(message:\"Something went wrong\")\n$E0: Oops = {\n  message = \"Something went wrong\"\n}\n```", "```swift\n> func cardName(value:Int) throws -> String {\n.   guard value >= 1 && value <= 13 else {\n.     throw Oops(message:\"Unknown card\")\n.   }\n.   let cardNames = [11:\"Jack\",12:\"Queen\",13:\"King\",1:\"Ace\",]\n.   return cardNames[value] ?? \"\\(value)\"\n. }\n```", "```swift\n> cardName(1)\n$R1: String = \"Ace\"\n> cardName(15)\n$E2: Oops = {\n  message = \"Unknown card\"\n}\n```", "```swift\n> do { \n.   let name = try cardName(15)\n.   print(\"You chose \\(name)\")\n. } catch {\n.   print(\"You chose an invalid card\")\n. }\n```", "```swift\n. } catch let e {\n.   print(\"There was a problem \\(e)\")\n. }\n```", "```swift\n> let ace = try! cardName(1)\nace: String = \"Ace\"\n```", "```swift\n> let unknown = try! cardName(15)\n\nFatal error: 'try!' expression unexpectedly raised an error: Oops(message: \"Unknown card\")\n```", "```swift\n> let ace = try? cardName(1)\nace: String? = \"Ace\"\n> let unknown = try? cardName(15)\nunknown: String? = nil\n```", "```swift\n> if let card = try? cardName(value) {\n.   print(\"You chose: \\(card)\")\n. }\n```", "```swift\n> func deferExample() {\n.   defer { print(\"C\") }\n.   print(\"A\")\n.   defer { print(\"B\") }\n. }\n> deferExample()\nA\nB\nC\n```", "```swift\n> func deferEarly() { \n.   defer { print(\"C\") } \n.   print(\"A\") \n.   return \n.   defer { print(\"B\") } // not executed\n. }    \n> deferEarly()\nA\nC\n```", "```swift\n#!/usr/bin/env xcrun swift\nprint(\"Hello World\")\n```", "```swift\nHello World\n```", "```swift\n#!/usr/bin/env xcrun swift\nimport func Darwin.exit\n# import func Glibc.exit # for Linux\nlet args = Process.arguments[1..<Process.arguments.count]\nfor arg in args {\n  print(\"\\(arg.uppercaseString)\")\n}\nexit(0)\n```", "```swift\n$ ./upper.swift hello world\nHELLO\nWORLD\n```", "```swift\n$ time ./upper.swift hello world    # Interpreted\nHELLO\nWORLD\nreal  0m0.145s\n$ xcrun swiftc -o upper upper.swift # Compile step\n$ time ./upper hello world          # Compiled\nHELLO\nWORLD\nreal  0m0.012s\n```"]