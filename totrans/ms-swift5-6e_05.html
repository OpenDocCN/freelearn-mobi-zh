<html><head></head><body>
  <div><h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-80" class="chapterTitle">Using Swift Collections</h1>
    <p class="normal">Once I got past the basic Hello, World! beginner applications, I quickly began to realize the shortcomings of variables, especially with the Mad Libs-style applications that I was starting to write. These applications requested that the user enter numerous strings, which resulted in the creation of separate variables for each input field that the user entered.</p>
    <p class="normal">Having all these separate variables quickly became cumbersome. I remember talking to a friend about this, and he asked me why I was not using arrays. At that time, I was not familiar with arrays, so I asked him to show me what they were. Even though he had a TI-99/4A and I had a Commodore Vic-20, the concept of arrays was the same. Even today, the arrays found in modern development languages have the same basic concepts as the arrays I used on my Commodore Vic-20. While it is definitely possible to create a useful application without using collections, such as arrays, when used properly, collections make application development significantly easier.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bullet">What an array is in Swift and how to use it</li>
      <li class="bullet">What a dictionary is in Swift and how to use it</li>
      <li class="bullet">What a set is in Swift and how to use it</li>
    </ul>
    <h1 id="_idParaDest-81" class="title">Swift collection types</h1>
    <p class="normal">A collection <a id="_idIndexMarker184"/>groups multiple items into a single unit. Swift provides three native collection types. These collection types are arrays, dictionaries, and sets. <em class="italic">Arrays </em>store data in an ordered collection, <em class="italic">dictionaries </em>are unordered collections of key-value pairs, and<em class="italic"> sets </em>are unordered collections of unique values. In an array, we access the data by the location or index within the array, whereas in a set we usually iterate through the collection, and dictionaries are accessed using a unique key.</p>
    <p class="normal">The data stored in a Swift collection must be of the same type. This means, as an example, that we are unable to store a string value in an array of integers. Since Swift does not allow us to mismatch data types in a collection, we can be certain of the data type when <a id="_idIndexMarker185"/>we retrieve elements from a collection. This is another feature that, on the surface, might seem like a shortcoming, but actually helps eliminate common programming mistakes.</p>
    <p class="normal">Let's start off by looking at mutability with collections.</p>
    <h2 id="_idParaDest-82" class="title">Mutability</h2>
    <p class="normal">For those who are familiar with Objective-C, you will know that there are different classes for <a id="_idIndexMarker186"/>mutable and immutable collections. For example, to define a mutable array, we use the <code class="Code-In-Text--PACKT-">NSMutableArray</code> class, and to define an immutable array, we use the <code class="Code-In-Text--PACKT-">NSArray</code> class. Swift is a little different because it does not contain separate classes for mutable and immutable collections. Instead, we define whether a collection is constant (immutable) or variable (mutable) by using the <code class="Code-In-Text--PACKT-">let</code> and <code class="Code-In-Text--PACKT-">var</code> keywords. This should seem familiar since we define constants with the <code class="Code-In-Text--PACKT-">let</code> keyword and variables with the <code class="Code-In-Text--PACKT-">var</code> keyword.</p>
    <div><p class="Information-Box--PACKT-">It is a good practice to create immutable collections unless there is a specific need to change the objects within the collection. This allows the compiler to optimize performance.</p>
    </div>
    <p class="normal">Let's begin our tour of collections by looking at the most common collection type: the array type.</p>
    <h1 id="_idParaDest-83" class="title">Arrays</h1>
    <p class="normal">Arrays can be found in <a id="_idIndexMarker187"/>virtually all modern programming languages. In Swift, an array is an ordered list of objects of the same type.</p>
    <p class="normal">When an array is created, we must declare the type of data that can be stored in it by explicit type declaration or through type inference. Typically, we only explicitly declare the data type of an array when we are creating an empty array. If we initialize an array with data, the compiler uses type inference to infer the data type for the array.</p>
    <p class="normal">Each object <a id="_idIndexMarker188"/>in an array is called an <strong class="keyword">element</strong>. Each of these elements is stored in a set order and can be accessed by searching for its location (index) in the array.</p>
    <h2 id="_idParaDest-84" class="title">Creating and initializing arrays</h2>
    <p class="normal">We can <a id="_idIndexMarker189"/>initialize an array with an array literal. An array literal is a set of <a id="_idIndexMarker190"/>values that prepopulates the array. The following example shows how to define an immutable array of integers using the <code class="Code-In-Text--PACKT-">let</code> keyword:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3]
</code></pre>
    <p class="normal">If we need to create a mutable array, we would use the <code class="Code-In-Text--PACKT-">var</code> keyword to define the array, as we did with standard variables. The following example shows how to define a mutable array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayTwo = [4,5,6]
</code></pre>
    <p class="normal">In the preceding two examples, the compiler inferred the type of values stored in the array by looking at the type of values stored in the array literal. If we want to create an empty array, we need to explicitly declare the type of values to store in the array. There are two ways to declare null arrays in Swift. The following examples show how to declare an empty mutable array that can be used to store integers:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayThree = [Int]()
var arrayThree: [Int] = []
</code></pre>
    <p class="normal">In the preceding examples, we created arrays with integer values, and the majority of the array examples in this chapter will also use integer values; however, we can create arrays in Swift with any type. The only rule is that, once an array is defined as containing a particular type, all the elements in the array must be of that type. The following example shows how we can create arrays of various data types:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [String]()
var arrayTwo = [Double]()
var arrayThree = [MyObject]()
</code></pre>
    <p class="normal">Swift provides special type aliases for working with nonspecific types. These aliases are <code class="Code-In-Text--PACKT-">AnyObject</code> and <code class="Code-In-Text--PACKT-">Any</code>. We can use these aliases to define arrays whose elements are of different types as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">var myArray: [Any] = [1,"Two"]
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">AnyObject</code> aliases can represent an instance of any class type, while the <code class="Code-In-Text--PACKT-">Any</code> aliases can represent an instance of any type, including function types. We should use the <code class="Code-In-Text--PACKT-">Any</code> and <code class="Code-In-Text--PACKT-">AnyObject</code> aliases only when there is an explicit need for this behavior. It is always better to be specific about the types of data our collections contain.</p>
    <div><p class="Information-Box--PACKT-">If there is a need to mix types in a single collection, we could consider using a tuple.</p>
    </div>
    <p class="normal">An array can also be initialized to a certain size with all the elements set to a predefined value. This can be very useful if we want to create an array and prepopulate it with default values. The following example defines an array with <code class="Code-In-Text--PACKT-">7</code> elements, with each element <a id="_idIndexMarker191"/>containing the number <code class="Code-In-Text--PACKT-">3</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayFour = [Int](repeating: 3, count: 7)
</code></pre>
    <div><p class="Information-Box--PACKT-">Starting in Swift 5.1, with SE-0245, we have the ability to create an uninitialized array. With this feature, we would not populate the array with a default value and instead could provide what is known as a <strong class="keyword">closure to populate the array</strong> as needed. We will show this feature in <em class="chapterRef">Chapter 14</em>, <em class="italic">Working with Closures</em>.</p>
    </div>
    <p class="normal">While the <a id="_idIndexMarker192"/>most common arrays are one-dimensional arrays, multidimensional arrays can also be created. A multidimensional array is really nothing more than an array of arrays. For example, a two-dimensional array is an array of arrays, while a three-dimensional array is an array of arrays of arrays. The following examples show the two ways to create a two-dimensional array in Swift:</p>
    <pre class="programlisting code"><code class="hljs-code">var multiArrayOne = [[1,2],[3,4],[5,6]]
var multiArrayTwo = [[Int]]()
</code></pre>
    <p class="normal">Now that we have seen how to initialize an array, let's look at how we can access the elements of an array. </p>
    <h2 id="_idParaDest-85" class="title">Accessing the array element</h2>
    <p class="normal">The subscript <a id="_idIndexMarker193"/>syntax is used to retrieve values from an array. Subscript syntax, for an array, is where a number appears between two square brackets, and that number specifies the location (index) within the array of the element we wish to retrieve. The following example shows how to retrieve elements from an array using the subscript syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3,4,5,6]
print(arrayOne[0]) //Displays '1'
print(arrayOne[3]) //Displays '4'
</code></pre>
    <p class="normal">In the preceding code, we create an array of integers that contains six numbers. We then print out the value at indexes <code class="Code-In-Text--PACKT-">0</code> and <code class="Code-In-Text--PACKT-">3</code>.</p>
    <div><p class="Information-Box--PACKT-">One important fact to note is that indices in Swift arrays start with the number zero. This means that the first item in an array has an index of <code class="Code-In-Text--PACKT-">0</code>. The second item in an array has an index of <code class="Code-In-Text--PACKT-">1</code>.</p>
    </div>
    <p class="normal">If we want to retrieve an individual value within a multidimensional array, we need to provide a subscript for each dimension of the array. If we do not provide a subscript for each dimension, we will retrieve an array rather than an individual value within the array. The following example shows how we can define a two-dimensional array and retrieve an individual value within the two dimensions:</p>
    <pre class="programlisting code"><code class="hljs-code">let multiArray = [[1,2],[3,4],[5,6]]
let arr = multiArray[0]  //arr contains the array [1,2]
let value = multiArray[0][1]  //value contains 2
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker194"/>preceding code, we begin by defining a two-dimensional array. When we retrieve the value at index <code class="Code-In-Text--PACKT-">0</code> of the first dimension (<code class="Code-In-Text--PACKT-">multiArray[0]</code>), we retrieve the array <code class="Code-In-Text--PACKT-">[1,2]</code>. When we retrieve the value at index <code class="Code-In-Text--PACKT-">0</code> of the first dimension and index <code class="Code-In-Text--PACKT-">1</code> of the second dimension (<code class="Code-In-Text--PACKT-">multiArray[0][1]</code>), we retrieve the integer <code class="Code-In-Text--PACKT-">2</code>.</p>
    <p class="normal">We can retrieve the first and last elements of an array using the <code class="Code-In-Text--PACKT-">first</code> and <code class="Code-In-Text--PACKT-">last</code> properties. The <code class="Code-In-Text--PACKT-">first</code> and <code class="Code-In-Text--PACKT-">last</code> properties return an optional value, since the values may be nil if the array is empty. The following example shows how to use these properties to retrieve the first and last elements of both a one-dimensional and a multidimensional array:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3,4,5,6]
let first = arrayOne.first    //first contains
let last = arrayOne.last    //last contains 6
let multiArray = [[1,2],[3,4],[5,6]]
let arrFirst1 = multiArray[0].first    //arrFirst1 contains 1
let arrFirst2 = multiArray.first    //arrFirst2 contains[1,2]
let arrLast1 = multiArray[0].last    //arrLast1 contains 2
let arrLast2 = multiArray.last    //arrLast2 contains [5,6]
</code></pre>
    <p class="normal">Now let's see how we can count the elements of an array.</p>
    <h2 id="_idParaDest-86" class="title">Counting the elements of an array</h2>
    <p class="normal">At times, it is <a id="_idIndexMarker195"/>essential to know the number of elements in an array. The array type in Swift contains a read-only <code class="Code-In-Text--PACKT-">count</code> property. The following example shows how to use this property to retrieve the number of elements in both single-dimensional and multidimensional arrays:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3]
let multiArrayOne = [[3,4],[5,6],[7,8]]
print(arrayOne.count)    //Displays 3
print(multiArrayOne.count)    //Displays 3 for the three array
print(multiArrayOne[0].count)    //Displays 2 for the two elements
</code></pre>
    <p class="normal">The value that is returned by the <code class="Code-In-Text--PACKT-">count</code> property is the number of elements in the array, and not the largest valid index of the array. For non-empty arrays, the largest valid index is the number of elements in the array minus 1. This is because the first element of the array has an index number of <code class="Code-In-Text--PACKT-">0</code>. As an example, if an array has two elements, the valid indexes are <code class="Code-In-Text--PACKT-">0</code> and <code class="Code-In-Text--PACKT-">1</code>, while the <code class="Code-In-Text--PACKT-">count</code> property would return <code class="Code-In-Text--PACKT-">2</code>. This is illustrated in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [0,1]
print(arrayOne[0])     //Displays 0
print(arrayOne[1])     //Displays 1
print(arrayOne.count)     //Displays 2
</code></pre>
    <p class="normal">If we attempt to retrieve an element from an array that is outside the range of the array, the application will throw an <strong class="keyword">array index out of range </strong>error. Therefore, if we are unsure of the size of an array, it is a good practice to verify that the index is not outside the range of the array. The following examples illustrate this concept:</p>
    <pre class="programlisting code"><code class="hljs-code">//This example will throw an array index out of range error 
let arrayOne = [1,2,3,4]
print(arrayOne[6])
//This example will not throw an array index out of range error 
let arrayTwo = [1,2,3,4]
if (arrayTwo.count &gt; 6) { 
    print(arrayTwo[6])
}
</code></pre>
    <p class="normal">In the preceding code, the first block would throw an <strong class="keyword">array index out of range </strong>error because we are attempting to access the value from the <code class="Code-In-Text--PACKT-">arrayOne</code> array at index <code class="Code-In-Text--PACKT-">6</code>; however, there are only four elements in the array. The second example would not throw the error <a id="_idIndexMarker196"/>because we are checking whether the <code class="Code-In-Text--PACKT-">arrayTwo</code> array contains more than six elements before trying to access the element at the sixth index.</p>
    <h2 id="_idParaDest-87" class="title">Is the array empty?</h2>
    <p class="normal">To check <a id="_idIndexMarker197"/>whether an array is empty (that is, it does not contain any elements), we use the <code class="Code-In-Text--PACKT-">isEmpty</code> property. This property will return <code class="Code-In-Text--PACKT-">true</code> if the array is empty and <code class="Code-In-Text--PACKT-">false</code> if it is not. The following example shows how to check whether an array is empty:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2]
var arrayTwo = [Int]()
arrayOne.isEmpty  //Returns false because the array is not empty
arrayTwo.isEmpty  //Returns true because the array is empty
</code></pre>
    <p class="normal">Now let's see how we can shuffle an array. </p>
    <h2 id="_idParaDest-88" class="title">Shuffling an array</h2>
    <p class="normal">An array can be very easily shuffled using the <code class="Code-In-Text--PACKT-">shuffle()</code> and <code class="Code-In-Text--PACKT-">shuffled()</code> methods. This can be <a id="_idIndexMarker198"/>very useful if we are creating a game, such as a card game, where the array contains the 52 cards in the deck. To shuffle the array in place, the <code class="Code-In-Text--PACKT-">shuffle()</code> method can be used; to put the shuffled results in a new array, leaving the original array untouched, the <code class="Code-In-Text--PACKT-">shuffled()</code> method would be used. The following examples show this:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5,6]
arrayOne.shuffle()
let shuffledArray = arrayOne.shuffled()
</code></pre>
    <p class="normal">Now let's look at how we can append data to an array.</p>
    <h2 id="_idParaDest-89" class="title">Appending to an array</h2>
    <p class="normal">A static <a id="_idIndexMarker199"/>array is somewhat useful but having the ability to add elements dynamically is what makes arrays really useful. To add an item to the end of an array, we can use the <code class="Code-In-Text--PACKT-">append</code> method. The following example shows how to append an item to the end of an array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2]
arrayOne.append(3)  //arrayOne will now contain 1, 2 and 3
</code></pre>
    <p class="normal">Swift also allows us to use the addition assignment operator (<code class="Code-In-Text--PACKT-">+=</code>) to append an array to another array. The following example shows how to use the addition assignment operator to append an array to the end of another array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2]
arrayOne += [3,4]    //arrayOne will now contain 1, 2, 3 and 4
</code></pre>
    <p class="normal">The way <a id="_idIndexMarker200"/>you append an element to the end of an array is really up to you. Personally, I prefer the assignment operator because, to me, it is a bit easier to read, but we will be using both in this book.</p>
    <h2 id="_idParaDest-90" class="title">Inserting a value into an array</h2>
    <p class="normal">We can insert a value into an array by using the <code class="Code-In-Text--PACKT-">insert</code> method. The <code class="Code-In-Text--PACKT-">insert</code> method will move all <a id="_idIndexMarker201"/>the items up one spot, starting at the specified index, to make room for the new element, and then insert the value into the specified index. The following example shows how to use this method to insert a new value into an array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5]
arrayOne.insert(10, at: 3)    //arrayOne now contains 1, 2, 3, 10, 4 and 5
</code></pre>
    <p class="normal">Now that we have seen how to insert a value, let's see how we can replace an element within an array.</p>
    <h2 id="_idParaDest-91" class="title">Replacing elements in an array</h2>
    <p class="normal">We use the subscript syntax to replace elements in an array. Using the subscript, we pick the <a id="_idIndexMarker202"/>element of the array we wish to update and then use the assignment operator to assign a new value. The following example shows how we will replace a value in an array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3]
arrayOne[1] = 10    //arrayOne now contains 1,10,3
</code></pre>
    <div><p class="Information-Box--PACKT-">You cannot update a value that is outside the current range of the array. Attempting to do so will throw the same <strong class="keyword">index out of range</strong> exception that was thrown when we tried to insert a value outside the range of the array.</p>
    </div>
    <p class="normal">Now let's <a id="_idIndexMarker203"/>look at how we can remove elements from an array.</p>
    <h2 id="_idParaDest-92" class="title">Removing elements from an array</h2>
    <p class="normal">There are <a id="_idIndexMarker204"/>three methods that we can use to remove one or all of the elements in an array. These methods are <code class="Code-In-Text--PACKT-">removeLast()</code>, <code class="Code-In-Text--PACKT-">remove(at:)</code>, and <code class="Code-In-Text--PACKT-">removeAll()</code>. The following example shows how to use the three methods to remove elements from an array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5]
arrayOne.removeLast()    //arrayOne now contains 1, 2, 3 and 4
arrayOne.remove(at:2)    //arrayOne now contains 1, 2 and 4
arrayOne.removeAll()    //arrayOne is now empty
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">removeLast()</code> and <code class="Code-In-Text--PACKT-">remove(at:)</code> methods will also return the value of the element being removed. Therefore, if we want to know the value of the item that was removed, we can rewrite the <code class="Code-In-Text--PACKT-">remove(at:)</code> and <code class="Code-In-Text--PACKT-">removeLast()</code> lines to capture the value, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5]
var removed1 = arrayOne.removeLast()  //removed1 contains the value 5
var removed = arrayOne.remove(at: 2)  //removed contains the value 3
</code></pre>
    <h2 id="_idParaDest-93" class="title">Merging two arrays</h2>
    <p class="normal">To create <a id="_idIndexMarker205"/>a new array by adding two arrays together, we use the addition (<code class="Code-In-Text--PACKT-">+</code>) operator. The following example shows how to use the addition (<code class="Code-In-Text--PACKT-">+</code>) operator to create a new array that contains all the elements of two other arrays:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2] let arrayTwo = [3,4]
var combined = arrayOne + arrayTwo   //combine contains 1, 2, 3 and 4
</code></pre>
    <p class="normal">In the preceding code, <code class="Code-In-Text--PACKT-">arrayOne</code> and <code class="Code-In-Text--PACKT-">arrayTwo</code> are left unchanged, while the <code class="Code-In-Text--PACKT-">combined</code> array contains the elements from <code class="Code-In-Text--PACKT-">arrayOne</code>, followed by the elements from <code class="Code-In-Text--PACKT-">arrayTwo</code>.</p>
    <h2 id="_idParaDest-94" class="title">Retrieving a subarray from an array</h2>
    <p class="normal">We can <a id="_idIndexMarker206"/>retrieve a subarray from an existing array by using the subscript syntax with a range operator. The following example shows how to retrieve <a id="_idIndexMarker207"/>a range of elements from an existing array:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3,4,5]
var subArray = arrayOne[2...4]    //subArray contains 3, 4 and 5
</code></pre>
    <p class="normal">The operator (three periods) is known as a <strong class="keyword">two-sided range operator</strong>. The range operator <a id="_idIndexMarker208"/>in the preceding code says that we want all the elements from <code class="Code-In-Text--PACKT-">2</code> to <code class="Code-In-Text--PACKT-">4</code> inclusively (elements <code class="Code-In-Text--PACKT-">2</code> and <code class="Code-In-Text--PACKT-">4</code> as well as what is between them). There is <a id="_idIndexMarker209"/>another two-sided range operator, ..&lt;, known as the<strong class="keyword"> half-open range operator</strong>. The half-open range operator functions the same as the previous range operator; however, it excludes the last element. The following example shows how to use the <code class="Code-In-Text--PACKT-">..&lt;</code> operator:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3,4,5]
var subArray = arrayOne[2..&lt;4]     //subArray contains 3 and 4
</code></pre>
    <p class="normal">In the preceding example, the subarray contains two elements: <code class="Code-In-Text--PACKT-">3</code> and <code class="Code-In-Text--PACKT-">4</code>. A two-sided range operator has numbers on either side of the operator. In Swift, we are not limited to two-sided range operators; we can also use one-sided range operators. The following examples show how we can use one-sided range operators:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [1,2,3,4,5]
var a = arrayOne[..&lt;3]    //subArray contains 1, 2 and 3 
var b = arrayOne[...3]    //subArray contains 1, 2, 3 and 4
var c = arrayOne[2...]    //subArray contains 3, 4 and 5
</code></pre>
    <p class="normal">The one-sided range operators were added in version 4 of the Swift language. The previous range operators enable us to access a contiguous range of elements from an array.</p>
    <p class="normal">SE-0270 enables us to fetch elements that are not contiguous, which means the elements may not be next to each other. This update to the Swift standard library introduced a new <code class="Code-In-Text--PACKT-">RangeSet</code> type, which is a subrange of indexes that are non-contiguous. Let's see how this works with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var numbers = [1,2,3,4,5,6,7,8,9,10]
let evenNum = numbers.subranges(where: { $0.isMultiple(of: 2) })
print(numbers[evenNum].count)
//numbers[evenNum] contains 2,4,6,8,10
</code></pre>
    <p class="normal">In this code, we define an array that contains the numbers <code class="Code-In-Text--PACKT-">1</code> through <code class="Code-In-Text--PACKT-">10</code>. We then use the <code class="Code-In-Text--PACKT-">subranges(where:)</code> method to retrieve the even elements. This method takes a closure <a id="_idIndexMarker210"/>as the argument, which hasn't been discussed yet. For now, we <a id="_idIndexMarker211"/>just need to know that we are able to retrieve non-contiguous subarrays and we will look at this again in <em class="chapterRef">Chapter 14</em>, <em class="italic">Working with Closures</em>.</p>
    <h2 id="_idParaDest-95" class="title">Making bulk changes to an array</h2>
    <p class="normal">We can <a id="_idIndexMarker212"/>use the subscript syntax with a range operator to change the values of multiple elements. The following example shows how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">arrayOne[1...2] = [12,13]  //arrayOne contains 1,12,13,4 and 5
</code></pre>
    <p class="normal">In the preceding code, the elements at indices <code class="Code-In-Text--PACKT-">1</code> and <code class="Code-In-Text--PACKT-">2</code> will be changed to the numbers <code class="Code-In-Text--PACKT-">12</code> and <code class="Code-In-Text--PACKT-">13</code>; therefore, <code class="Code-In-Text--PACKT-">arrayOne</code> will contain <code class="Code-In-Text--PACKT-">1</code>, <code class="Code-In-Text--PACKT-">12</code>, <code class="Code-In-Text--PACKT-">13</code>, <code class="Code-In-Text--PACKT-">4</code>, and <code class="Code-In-Text--PACKT-">5</code>.</p>
    <p class="normal">The number of elements that you are changing in the range operator does not need to match the number of values that you are passing in. Swift makes bulk changes by first removing the elements defined by the range operator and then inserting the new values. The following example demonstrates this concept:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5]
arrayOne[1...3] = [12,13]  //arrayOne now contains 1, 12, 13 and 5
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">arrayOne</code> array starts with five elements. We then replace the range of elements <code class="Code-In-Text--PACKT-">1</code> to <code class="Code-In-Text--PACKT-">3</code> inclusively. This causes elements <code class="Code-In-Text--PACKT-">1</code> through <code class="Code-In-Text--PACKT-">3</code> (that is, three elements) to be removed from the array first. After those three elements are removed, then the two new elements (<code class="Code-In-Text--PACKT-">12</code> and <code class="Code-In-Text--PACKT-">13</code>) are added to the array, starting at index <code class="Code-In-Text--PACKT-">1</code>. After this is complete, <code class="Code-In-Text--PACKT-">arrayOne</code> will contain four elements: <code class="Code-In-Text--PACKT-">1</code>, <code class="Code-In-Text--PACKT-">12</code>, <code class="Code-In-Text--PACKT-">13</code>, and <code class="Code-In-Text--PACKT-">5</code>. Using the same logic, we can also add more elements than we remove. The following example illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5] 
arrayOne[1...3] = [12,13,14,15] 
//arrayOne now contains 1, 12, 13, 14, 15 and 5 (six elements)
</code></pre>
    <p class="normal">In the preceding code, <code class="Code-In-Text--PACKT-">arrayOne</code> starts with five elements. We then say that we want to replace the range of elements <code class="Code-In-Text--PACKT-">1</code> through <code class="Code-In-Text--PACKT-">3</code> inclusively. As in the previous example, this causes elements <code class="Code-In-Text--PACKT-">1</code> through <code class="Code-In-Text--PACKT-">3</code> (three elements) to be removed from the array. We then add four elements (<code class="Code-In-Text--PACKT-">12</code>, <code class="Code-In-Text--PACKT-">13</code>, <code class="Code-In-Text--PACKT-">14</code>, and <code class="Code-In-Text--PACKT-">15</code>) to the array, starting at index <code class="Code-In-Text--PACKT-">1</code>. After this is complete, <code class="Code-In-Text--PACKT-">arrayOne</code> will <a id="_idIndexMarker213"/>contain six elements: <code class="Code-In-Text--PACKT-">1</code>, <code class="Code-In-Text--PACKT-">12</code>, <code class="Code-In-Text--PACKT-">13</code>, <code class="Code-In-Text--PACKT-">14</code>, <code class="Code-In-Text--PACKT-">15</code>, and <code class="Code-In-Text--PACKT-">5</code>.</p>
    <h2 id="_idParaDest-96" class="title">Algorithms for arrays</h2>
    <p class="normal">Swift arrays have several methods that take a closure as their argument. These methods transform <a id="_idIndexMarker214"/>the array in a way defined by the code in the closure. Closures are self-contained blocks of code that can be passed around, and are similar to blocks in Objective-C and lambdas in other languages. We will discuss closures in depth in <em class="chapterRef">Chapter 14</em>, <em class="italic">Working with Closures</em>. For now, the goal is to become familiar with how the algorithms work in Swift.</p>
    <h3 id="_idParaDest-97" class="title">Sort</h3>
    <p class="normal">The <strong class="keyword">sort</strong> algorithm <a id="_idIndexMarker215"/>sorts an array in place. This means that, when the <code class="Code-In-Text--PACKT-">sort()</code> method is used, the <a id="_idIndexMarker216"/>original array is replaced with the sorted one. The closure takes two arguments (represented by <code class="Code-In-Text--PACKT-">$0</code> and <code class="Code-In-Text--PACKT-">$1</code>), and it should return a Boolean value that indicates whether the first element should be placed before the second element. The following code shows how to use the sort algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [9,3,6,2,8,5]
arrayOne.sort(){ $0 &lt; $1 }
//arrayOne contains 2,3,5,6,8 and 9
</code></pre>
    <p class="normal">The preceding code will sort the array in ascending order. We know this because the rule will return true if the first number (<code class="Code-In-Text--PACKT-">$0</code>) is less than the second number (<code class="Code-In-Text--PACKT-">$1</code>). Therefore, when the sort algorithm begins, it compares the first two numbers (<code class="Code-In-Text--PACKT-">9</code> and <code class="Code-In-Text--PACKT-">3</code>) and returns <code class="Code-In-Text--PACKT-">true</code> if the first number (<code class="Code-In-Text--PACKT-">9</code>) is less than the second number (<code class="Code-In-Text--PACKT-">3</code>). In our case, the rule returns <code class="Code-In-Text--PACKT-">false</code>, so the numbers are reversed. The algorithm continues sorting in this manner until all of the numbers are sorted in the correct order.</p>
    <p class="normal">To sort an array in ascending order, we can actually use the <code class="Code-In-Text--PACKT-">sort()</code> method by itself without using a closure as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [9,3,6,2,8,5]
arrayOne.sort()
</code></pre>
    <p class="normal">The preceding examples sorted the array in a numerically-increasing order; if we wanted to reverse the order, we would reverse the arguments in the closure. The following code shows how to reverse the sort order:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [9,3,6,2,8,5]
arrayOne.sort(){ $1 &lt; $0 }
//arrayOne contains 9,8,6,5,3 and 2
</code></pre>
    <p class="normal">When we run this code, <code class="Code-In-Text--PACKT-">arrayOne</code> will contain the elements <code class="Code-In-Text--PACKT-">9</code>, <code class="Code-In-Text--PACKT-">8</code>, <code class="Code-In-Text--PACKT-">6</code>, <code class="Code-In-Text--PACKT-">5</code>, <code class="Code-In-Text--PACKT-">3</code>, and <code class="Code-In-Text--PACKT-">2</code>.</p>
    <p class="normal">The preceding <a id="_idIndexMarker217"/>code can be simplified by using the <code class="Code-In-Text--PACKT-">sort(by:)</code> method <a id="_idIndexMarker218"/>and passing in a greater-than or less-than operator, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayTwo = [9,3,6,2,8,5]
arrayTwo.sort(by: &lt;)
</code></pre>
    <p class="normal">In the preceding code, by using the less-than operator, the array is sorted in ascending order. If we'd used the greater-than operator, the array would have been sorted in descending order.</p>
    <h3 id="_idParaDest-98" class="title">Sorted</h3>
    <p class="normal">While the <a id="_idIndexMarker219"/>sort algorithm sorts the array in place (that is, it replaces the original array), the <strong class="keyword">sorted</strong> algorithm does not change the original array; it instead <a id="_idIndexMarker220"/>creates a new array with the sorted elements from the original array. The following example shows how to use the sorted algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [9,3,6,2,8,5]
let sorted = arrayOne.sorted(){ $0 &lt; $1 }
//sorted contains 2,3,5,6,8 and 9
//arrayOne contains 9,3,6,2,8 and 5
</code></pre>
    <p class="normal">After we run this code, <code class="Code-In-Text--PACKT-">arrayOne</code> will contain the original unsorted array (<code class="Code-In-Text--PACKT-">9</code>, <code class="Code-In-Text--PACKT-">3</code>, <code class="Code-In-Text--PACKT-">6</code>, <code class="Code-In-Text--PACKT-">2</code>, <code class="Code-In-Text--PACKT-">8</code>, and <code class="Code-In-Text--PACKT-">5</code>) and the <code class="Code-In-Text--PACKT-">sorted</code> array will contain the new sorted array (<code class="Code-In-Text--PACKT-">2</code>, <code class="Code-In-Text--PACKT-">3</code>, <code class="Code-In-Text--PACKT-">5</code>, <code class="Code-In-Text--PACKT-">6</code>, <code class="Code-In-Text--PACKT-">8</code>, and <code class="Code-In-Text--PACKT-">9</code>).</p>
    <h3 id="_idParaDest-99" class="title">Filter</h3>
    <p class="normal">The <strong class="keyword">filter</strong> algorithm <a id="_idIndexMarker221"/>will return a new array by filtering the original array. This is one of the most powerful array algorithms and may end up being the one <a id="_idIndexMarker222"/>you use the most. If you need to retrieve a subset of an array based on a set of rules, I recommend using this algorithm rather than trying to write your own method to filter the array.</p>
    <p class="normal">The closure takes one argument, and it should return a Boolean <code class="Code-In-Text--PACKT-">true</code> if the element should be included in the new array, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [1,2,3,4,5,6,7,8,9]
let filtered = arrayOne.filter{$0 &gt; 3 &amp;&amp; $0 &lt; 7}
//filtered contains 4,5 and 6
</code></pre>
    <p class="normal">In the preceding code, the rule that we are passing to the algorithm returns <code class="Code-In-Text--PACKT-">true</code> if the number is greater than <code class="Code-In-Text--PACKT-">3</code> and less than <code class="Code-In-Text--PACKT-">7</code>; therefore, any number that is greater than <code class="Code-In-Text--PACKT-">3</code> and less than <code class="Code-In-Text--PACKT-">7</code> is included in the new <code class="Code-In-Text--PACKT-">filtered</code> array.</p>
    <p class="normal">This next <a id="_idIndexMarker223"/>example shows how we can retrieve a subset <a id="_idIndexMarker224"/>of cities that contain the letter <code class="Code-In-Text--PACKT-">o</code> in their name:</p>
    <pre class="programlisting code"><code class="hljs-code">var city = ["Boston", "London", "Chicago", "Atlanta"] 
let filteredCity = city.filter{$0.range(of:"o") != nil}
//filtered contains "Boston", "London" and "Chicago"
</code></pre>
    <p class="normal">In the preceding code, we use the <code class="Code-In-Text--PACKT-">range(of:)</code> method to return <code class="Code-In-Text--PACKT-">true</code> if the string contains the letter <code class="Code-In-Text--PACKT-">o</code>. If the method returns <code class="Code-In-Text--PACKT-">true</code>, the string is included in the <code class="Code-In-Text--PACKT-">filtered</code> array.</p>
    <h3 id="_idParaDest-100" class="title">Map</h3>
    <p class="normal">While the <a id="_idIndexMarker225"/>filter algorithm is used to select only certain elements of an array, <strong class="keyword">map</strong> is used <a id="_idIndexMarker226"/>to apply logic to all elements in the array. The following <a id="_idIndexMarker227"/>example shows how to use the map algorithm to divide each number by 10:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [10, 20, 30, 40]
let applied = arrayOne.map{ $0 / 10}
//applied contains 1,2,3 and 4
</code></pre>
    <p class="normal">In the preceding code, the new array contains the numbers <code class="Code-In-Text--PACKT-">1</code>, <code class="Code-In-Text--PACKT-">2</code>, <code class="Code-In-Text--PACKT-">3</code>, and <code class="Code-In-Text--PACKT-">4</code>, which is the result of dividing each element of the original array by <code class="Code-In-Text--PACKT-">10</code>.</p>
    <p class="normal">The new array created by the map algorithm is not required to contain the same element types as the original array; however, all the elements in the new array must be of the same type. In the following example, the original array contains integer values, but the new array created by the map algorithm contains string elements:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayTwo = [1, 2, 3, 4]
let applied = arrayTwo.map{ "num:\($0)"}
//applied contains "num:1", "num:2", "num:3" and "num:4"
</code></pre>
    <p class="normal">In the preceding code, we created an array of strings that appends the numbers from the original array to the <code class="Code-In-Text--PACKT-">num:</code> string.</p>
    <h3 id="_idParaDest-101" class="title">Count</h3>
    <p class="normal">We can combine the filter algorithm with the <code class="Code-In-Text--PACKT-">count</code> method to count the number of items in <a id="_idIndexMarker228"/>an array that match a rule. For example, if we had an array that contained the grades from a test, we could use the <strong class="keyword">count</strong> algorithm <a id="_idIndexMarker229"/>to count how many of the grades were greater than or equal to <code class="Code-In-Text--PACKT-">90</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">let arrayOne = [95, 90, 75, 80,60]
let count = arrayOne.filter{ $0 &gt;= 90 }.count
</code></pre>
    <p class="normal">As we did with the filter algorithm, we can use methods from the array type, such as the <code class="Code-In-Text--PACKT-">range(of:)</code> method from the string type. For example, rather than returning a subset of cities that contain the letter <code class="Code-In-Text--PACKT-">o</code> in their name, as we did in the filter algorithm, we can count the cities like this:</p>
    <pre class="programlisting code"><code class="hljs-code">var city = ["Boston", "London", "Chicago", "Atlanta"] 
let count1 = city.filter{$0.range(of:"o") != nil}.count
</code></pre>
    <p class="normal">In the preceding count, the <code class="Code-In-Text--PACKT-">count1</code> constant contains <code class="Code-In-Text--PACKT-">3</code>.</p>
    <h3 id="_idParaDest-102" class="title">Diff</h3>
    <p class="normal">In Swift 5.1 with SE-0240, the <strong class="keyword">Diff</strong> algorithm was introduced. This addition to the Swift language <a id="_idIndexMarker230"/>enables support for <code class="Code-In-Text--PACKT-">diff</code> and patching of ordered collections like arrays. To really see the power of this change we need to understand how <code class="Code-In-Text--PACKT-">switch</code> <a id="_idIndexMarker231"/>statements work, which is introduced in <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>; therefore, we will briefly show how the Diff algorithm works here with the <code class="Code-In-Text--PACKT-">applying</code> method. We will look at this algorithm more when we cover the <code class="Code-In-Text--PACKT-">switch</code> statement in <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>.</p>
    <p class="normal">Let's look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var scores1 = [100, 81, 95, 98, 99, 65, 87]
var scores2 = [100, 98, 95, 91, 83, 88, 72]
let diff2 = scores2.difference(from: scores1)
var newArray = scores1.applying(diff2) ?? []
</code></pre>
    <p class="normal">In the preceding code, we started off by creating two arrays. We then used the <code class="Code-In-Text--PACKT-">difference(from:)</code> method, which returns the difference between the two arrays. This new array would now contain the values: <code class="Code-In-Text--PACKT-">100</code>, <code class="Code-In-Text--PACKT-">98</code>, <code class="Code-In-Text--PACKT-">95</code>, <code class="Code-In-Text--PACKT-">91</code>, <code class="Code-In-Text--PACKT-">83</code>, <code class="Code-In-Text--PACKT-">88</code>, and <code class="Code-In-Text--PACKT-">72</code>. The return value is a collection of enumerations that tell us how we can produce a collection, from one collection, that will contain the same elements as another collection. This might not make a <a id="_idIndexMarker232"/>whole lot of sense right now, but as we dive into more of this, it will become clear.</p>
    <p class="normal">The last <a id="_idIndexMarker233"/>line uses the <code class="Code-In-Text--PACKT-">applying()</code> method to apply the changes to the <code class="Code-In-Text--PACKT-">scores1</code> array and returns an array that has the same elements as the <code class="Code-In-Text--PACKT-">scores2</code> array; therefore, after this method is called, the <code class="Code-In-Text--PACKT-">newArray</code> array contains the same elements as the <code class="Code-In-Text--PACKT-">scores2</code> array.</p>
    <h3 id="_idParaDest-103" class="title">forEach</h3>
    <p class="normal">We can <a id="_idIndexMarker234"/>use the <code class="Code-In-Text--PACKT-">forEach</code> algorithm to iterate over a sequence. The following example shows how we would do this:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = [10, 20, 30, 40]
arrayOne.forEach{ print($0) }
</code></pre>
    <p class="normal">This example <a id="_idIndexMarker235"/>will print the following results to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">10
20
30
40
</code></pre>
    <p class="normal">While using the <code class="Code-In-Text--PACKT-">forEach</code> algorithm is very easy, it does have some limitations. The recommended way to iterate over an array is to use the <code class="Code-In-Text--PACKT-">for-in</code> loop, which we will see in the next section.</p>
    <h2 id="_idParaDest-104" class="title">Iterating over an array</h2>
    <p class="normal">We can iterate over all elements of an array, in order, with a <code class="Code-In-Text--PACKT-">for-in</code> loop. The <code class="Code-In-Text--PACKT-">for-in</code> loop will <a id="_idIndexMarker236"/>execute one or more statements for each element of the array. We will discuss the <code class="Code-In-Text--PACKT-">for-in</code> loop in greater detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>. The following example shows how we would iterate over the elements of an array:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = ["one", "two", "three"] 
for item in arrayOne {
    print(item)
}
</code></pre>
    <p class="normal">In the preceding example, the <code class="Code-In-Text--PACKT-">for-in</code> loop iterates over the array and executes the <code class="Code-In-Text--PACKT-">print(item)</code> line for each element in the array. If we run this code, it will display the following results in the console:</p>
    <pre class="programlisting con"><code class="hljs-con">one
two
three
</code></pre>
    <p class="normal">There are times when we would like to iterate over an array, as we did in the preceding example, but we would also like to know the index, as well as the value of an element. To do this, we can use the <code class="Code-In-Text--PACKT-">enumerated</code> method of an array, which returns a tuple for each item in the array that contains both the index and value of the element. The following example shows how to use this function:</p>
    <pre class="programlisting code"><code class="hljs-code">var arrayOne = ["one", "two", "three"]
for (index,value) in arrayOne.enumerated() { 
    print("\(index) \(value)")
}
</code></pre>
    <p class="normal">The preceding <a id="_idIndexMarker237"/>code will display the following results in the console:</p>
    <pre class="programlisting con"><code class="hljs-con">one
two
three
</code></pre>
    <p class="normal">Now that we have introduced arrays in Swift, let's move on to dictionaries.</p>
    <h1 id="_idParaDest-105" class="title">Dictionaries</h1>
    <p class="normal">While dictionaries are not as commonly used as arrays, they have additional functionality <a id="_idIndexMarker238"/>that makes them incredibly powerful. A dictionary is a container that stores multiple key-value pairs, where all the keys are of the same type and all the values are of the same type. The key is used as a unique identifier for the value. A dictionary does not guarantee the order in which the key-value pairs are stored since we look up the values by key rather than by the index of the value.</p>
    <p class="normal">Dictionaries are good for storing items that map to unique identifiers, where the unique identifier should be used to retrieve the item. Countries with their abbreviations are a good example of items that can be stored in a dictionary. In the following table, we show countries with their abbreviations as key-value pairs:</p>
    <table id="table001-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Key</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Value</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">US</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">United States</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">IN</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">India</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">UK</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">United Kingdom</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.1: Countries and their abbreviations</p>
    <h2 id="_idParaDest-106" class="title">Creating and initializing dictionaries</h2>
    <p class="normal">We can <a id="_idIndexMarker239"/>initialize a dictionary using a dictionary literal, similarly to how we initialized an array with the array literal. The following example shows how <a id="_idIndexMarker240"/>to create a dictionary using the key-value pairs in the preceding chart:</p>
    <pre class="programlisting code"><code class="hljs-code">let countries = ["US":"UnitedStates","IN":"India","UK":"UnitedKingdom"]
</code></pre>
    <p class="normal">The preceding code creates an immutable dictionary that contains each of the key-value pairs in the chart we saw before. Just like the array, to create a mutable dictionary we will need to use the <code class="Code-In-Text--PACKT-">var </code>keyword in place of <code class="Code-In-Text--PACKT-">let</code>. The following example shows how to create a mutable dictionary that contains the countries:</p>
    <pre class="programlisting code"><code class="hljs-code">var countries = ["US":"UnitedStates","IN":"India","UK":"UnitedKingdom"]
</code></pre>
    <p class="normal">In the preceding two examples, we created a dictionary where the key and value were both strings. The compiler inferred that the key and value were strings because that was the type of the keys and values used to initiate the dictionary. If we wanted to create an empty dictionary, we would need to tell the compiler what the key and value types are. The following examples create various dictionaries with different key-value types:</p>
    <pre class="programlisting code"><code class="hljs-code">var dic1 = [String:String]()
var dic2 = [Int:String]()
var dic3 = [String:MyObject]()
var dic4: [String:String] = [:]
var dic5: [Int:String] = [:]
</code></pre>
    <div><p class="Information-Box--PACKT-">If we want to use a custom object as the key in a dictionary, we will need to make the <a id="_idIndexMarker241"/>custom object conform to the <strong class="keyword">Hashable</strong> protocol from Swift's standard library. We will discuss protocols extensively later in this book, but for now just understand that it is possible to use custom objects as a key in a dictionary.</p>
    </div>
    <p class="normal">Now let's see how we can access the values of a dictionary.</p>
    <h2 id="_idParaDest-107" class="title">Accessing dictionary values</h2>
    <p class="normal">We use the subscript syntax to retrieve the value for a particular key. If the dictionary does not <a id="_idIndexMarker242"/>contain the key we are looking for, the dictionary will return <code class="Code-In-Text--PACKT-">nil</code>; therefore, the variable returned from this lookup is an optional variable. The following example shows how to retrieve a value from a dictionary using its key in the subscript syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">let countries = ["US":"United States", "IN":"India","UK":"UnitedKingdom"] 
var name = countries["US"]
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">name</code> variable contains the <code class="Code-In-Text--PACKT-">United States</code> string.</p>
    <h2 id="_idParaDest-108" class="title">Counting the keys or values in a dictionary</h2>
    <p class="normal">We use <a id="_idIndexMarker243"/>the <code class="Code-In-Text--PACKT-">count</code> property of the dictionary to get the number of key-value pairs in the dictionary. The following example shows how to use this property:</p>
    <pre class="programlisting code"><code class="hljs-code">let countries = ["US":"United States", "IN":"India","UK":"United Kingdom"] 
var cnt = countries.count    //cnt contains 3
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">cnt</code> variable will contain the number <code class="Code-In-Text--PACKT-">3</code> since there are three key-value pairs in the dictionary.</p>
    <h2 id="_idParaDest-109" class="title">Is the dictionary empty?</h2>
    <p class="normal">To test whether a dictionary contains any key-value pairs, we can use the <code class="Code-In-Text--PACKT-">isEmpty</code> property. This <a id="_idIndexMarker244"/>property will return <code class="Code-In-Text--PACKT-">false</code> if the dictionary contains one or more key-value pairs and <code class="Code-In-Text--PACKT-">true</code> if it is empty. The following example shows us how to use this property to determine whether our dictionary contains any key-value pairs:</p>
    <pre class="programlisting code"><code class="hljs-code">let countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]
var empty = countries.isEmpty
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker245"/>preceding code, the <code class="Code-In-Text--PACKT-">isEmpty</code> property returned <code class="Code-In-Text--PACKT-">false</code> as there are three key-value pairs in the dictionary.</p>
    <h2 id="_idParaDest-110" class="title">Updating the value of a key</h2>
    <p class="normal">To update the value of a key in a dictionary, we can use either the subscript syntax or the <code class="Code-In-Text--PACKT-">updateValue(_: ,forKey:)</code> method. The <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method has an additional <a id="_idIndexMarker246"/>feature that the subscript syntax doesn't: it returns the original value associated with the key prior to changing the value. The following example shows how to use both the subscript syntax and the <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method to update the value of a key:</p>
    <pre class="programlisting code"><code class="hljs-code">var countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]
countries["UK"] = "Great Britain"
//The value of UK is now set to "Great Britain"
var orig = countries.updateValue("Britain", forKey: "UK")
//The value of UK is now set to "Britain"
//The orig variable equals "Great Britain"
</code></pre>
    <p class="normal">In the preceding code, we use the subscript syntax to change the value associated with the <code class="Code-In-Text--PACKT-">UK</code> key from <code class="Code-In-Text--PACKT-">United Kingdom</code> to <code class="Code-In-Text--PACKT-">Great Britain</code>. The original value of <code class="Code-In-Text--PACKT-">United Kingdom</code> was not saved prior to replacing it. We then used the <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method to change the value associated with the <code class="Code-In-Text--PACKT-">UK</code> key from <code class="Code-In-Text--PACKT-">Great Britain</code> to <code class="Code-In-Text--PACKT-">Britain</code>. With the <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method, the original value of <code class="Code-In-Text--PACKT-">Great Britain</code> is assigned to the <code class="Code-In-Text--PACKT-">orig</code> variable prior to changing the value in the dictionary.</p>
    <h2 id="_idParaDest-111" class="title">Adding a key-value pair</h2>
    <p class="normal">To add a <a id="_idIndexMarker247"/>new key-value pair to a dictionary, we can use the subscript syntax or the same <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method that we used to update the value of a key. If we use the <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method and the key is not currently present in the dictionary, this method will add a new key-value pair and return <code class="Code-In-Text--PACKT-">nil</code>. The following example shows how to use both the subscript syntax and the <code class="Code-In-Text--PACKT-">updateValue(_:, forKey:)</code> method to add a new key-value pair to a dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">var countries = ["US":"United States", "IN":"India","UK":"United Kingdom"] 
countries["FR"] = "France" //The value of "FR" is set to"France"
var orig = countries.updateValue("Germany", forKey: "DE")
//The value of "DE" is set to "Germany" and orig is nil
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">countries</code> dictionary starts with three key-value pairs and we then add <a id="_idIndexMarker248"/>a fourth key-value pair (<code class="Code-In-Text--PACKT-">FR/France</code>) to the dictionary using the subscript syntax. We use the <code class="Code-In-Text--PACKT-">updateValue(_:,forKey:)</code> method to add a fifth key-value pair (<code class="Code-In-Text--PACKT-">DE/Germany</code>) to the dictionary. The <code class="Code-In-Text--PACKT-">orig</code> variable is set to <code class="Code-In-Text--PACKT-">nil</code> because the <code class="Code-In-Text--PACKT-">countries</code> dictionary did not contain a value associated with the <code class="Code-In-Text--PACKT-">DE</code> key.</p>
    <h2 id="_idParaDest-112" class="title">Removing a key-value pair</h2>
    <p class="normal">There may be times when we need to remove values from a dictionary. There are three ways to <a id="_idIndexMarker249"/>achieve this: the subscript syntax, the <code class="Code-In-Text--PACKT-">removeValue(forKey:)</code> method, or the <code class="Code-In-Text--PACKT-">removeAll()</code> method. The <code class="Code-In-Text--PACKT-">removeValue(forKey:)</code> method returns the value of the key prior to removing it. The <code class="Code-In-Text--PACKT-">removeAll()</code> method removes all the elements from the dictionary. The following example shows how to use all three methods to remove key-value pairs from a dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">var countries = ["US":"UnitedStates","IN":"India","UK":"United Kingdom"] 
countries["IN"] = nil //The "IN" key/value pair is removed
var orig = countries.removeValue(forKey:"UK")
//The "UK" key value pair is removed and orig contains "United Kingdom"
countries.removeAll()
//Removes all key/value pairs from the countries dictionary
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">countries</code> dictionary starts off with three key-value pairs. We then set the value associated with the <code class="Code-In-Text--PACKT-">IN</code> key to <code class="Code-In-Text--PACKT-">nil</code>, which removes the key-value pair from the dictionary. We use the <code class="Code-In-Text--PACKT-">removeValue(forKey:)</code> method to remove the key associated with the <code class="Code-In-Text--PACKT-">UK</code> key. Prior to removing the value associated with the <code class="Code-In-Text--PACKT-">UK</code> key, the <code class="Code-In-Text--PACKT-">removeValue(forKey:)</code> method saves the value in the <code class="Code-In-Text--PACKT-">orig</code> variable. Finally, we use the <code class="Code-In-Text--PACKT-">removeAll()</code> method to remove all the remaining key-value pairs in the <code class="Code-In-Text--PACKT-">countries</code> dictionary.</p>
    <p class="normal">Now let's look at the set type.</p>
    <h1 id="_idParaDest-113" class="title">Set</h1>
    <p class="normal">The set type is <a id="_idIndexMarker250"/>a generic collection that is similar to the array type. While the array type is an ordered collection that may contain duplicate items, the set type is an unordered collection where each item must be unique.</p>
    <p class="normal">Like the key in a dictionary, the type stored in an array must conform to the <strong class="keyword">Hashable </strong>protocol. This <a id="_idIndexMarker251"/>means that the type must provide a way to compute a hash value for itself. All of Swift's basic types, such as <code class="Code-In-Text--PACKT-">String</code>, <code class="Code-In-Text--PACKT-">Double</code>, <code class="Code-In-Text--PACKT-">Int</code>, and <code class="Code-In-Text--PACKT-">Bool</code>, conform to this protocol and can be used in a set by default.</p>
    <p class="normal">Let's look at how we would use the set type.</p>
    <h2 id="_idParaDest-114" class="title">Initializing a set</h2>
    <p class="normal">There are a couple of ways to initialize a set. Just like the array and dictionary types, Swift needs <a id="_idIndexMarker252"/>to know what type of data is going to be stored in it. This means that we must either tell Swift the type of data to store in the set or initialize it with some data so that it can infer the data type.</p>
    <p class="normal">Just like the array and dictionary types, we use the <code class="Code-In-Text--PACKT-">var</code> and <code class="Code-In-Text--PACKT-">let</code> keywords to declare whether the set is mutable:</p>
    <pre class="programlisting code"><code class="hljs-code">//Initializes an empty set of the String type 
var mySet = Set&lt;String&gt;()
//Initializes a mutable set of the String type with initial values 
var mySet = Set(["one", "two", "three"])
//Creates an immutable set of the String type. 
let mySet = Set(["one", "two", "three"])
</code></pre>
    <h2 id="_idParaDest-115" class="title">Inserting items into a set</h2>
    <p class="normal">We use <a id="_idIndexMarker253"/>the <code class="Code-In-Text--PACKT-">insert</code> method to insert an item into a set. If we attempt to insert an item that is already in the set, the item will be ignored. Here are some examples of inserting items into a set:</p>
    <pre class="programlisting code"><code class="hljs-code">var mySet = Set&lt;String&gt;() 
mySet.insert("One") 
mySet.insert("Two")
mySet.insert("Three")
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">insert()</code> method returns a tuple that we can use to verify that the value was successfully added to the set. The following example shows how to check the returned value to <a id="_idIndexMarker254"/>see whether it was added successfully:</p>
    <pre class="programlisting code"><code class="hljs-code">var mySet = Set&lt;String&gt;() 
mySet.insert("One")
mySet.insert("Two")
var results = mySet.insert("One")
if results.inserted {
    print("Success")
} else { 
    print("Failed")
  }
</code></pre>
    <p class="normal">In this example, <code class="Code-In-Text--PACKT-">Failed</code> would be printed to the console since we are attempting to add the <code class="Code-In-Text--PACKT-">One</code> value to the set when it is already in the set.</p>
    <h2 id="_idParaDest-116" class="title">Determining the number of items in a set</h2>
    <p class="normal">We can <a id="_idIndexMarker255"/>use the <code class="Code-In-Text--PACKT-">count</code> property to determine the number of items in a set. Here is an example of how to use this method:</p>
    <pre class="programlisting code"><code class="hljs-code">var mySet = Set&lt;String&gt;() 
mySet.insert("One") 
mySet.insert("Two")
mySet.insert("Three")
print("\(mySet.count) items")
</code></pre>
    <p class="normal">When executed, this code will print the message <code class="Code-In-Text--PACKT-">3 items</code> to the console because the set contains three items.</p>
    <h2 id="_idParaDest-117" class="title">Checking whether a set contains an item</h2>
    <p class="normal">We can <a id="_idIndexMarker256"/>verify whether a set contains an item by using the <code class="Code-In-Text--PACKT-">contains()</code> method, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">var mySet = Set&lt;String&gt;()
mySet.insert("One") 
mySet.insert("Two")
mySet.insert("Three")
var contain = mySet.contains("Two")
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker257"/>preceding example, the <code class="Code-In-Text--PACKT-">contain</code> variable is set to <code class="Code-In-Text--PACKT-">true</code> because the set contains <code class="Code-In-Text--PACKT-">a</code> string with a value of <code class="Code-In-Text--PACKT-">Two</code>.</p>
    <h2 id="_idParaDest-118" class="title">Iterating over a set</h2>
    <p class="normal">We can <a id="_idIndexMarker258"/>use the <code class="Code-In-Text--PACKT-">for-in</code> statement to iterate over the items in a set as we did with arrays. The following example shows how we would iterate through the items in a set:</p>
    <pre class="programlisting code"><code class="hljs-code">for item in mySet { 
    print(item)
}
</code></pre>
    <p class="normal">The preceding example will print out each item in the set to the console.</p>
    <h2 id="_idParaDest-119" class="title">Removing items in a set</h2>
    <p class="normal">We can <a id="_idIndexMarker259"/>remove a single item or all the items in a set. To remove a single item, we would use the <code class="Code-In-Text--PACKT-">remove()</code> method and, to remove all the items, we would use the <code class="Code-In-Text--PACKT-">removeAll()</code> method. The following example shows how to remove items from a set:</p>
    <pre class="programlisting code"><code class="hljs-code">//The remove method will return and remove an item from a set 
var item = mySet.remove("Two")
//The removeAll method will remove all items from a set 
mySet.removeAll()
</code></pre>
    <h2 id="_idParaDest-120" class="title">Set operations</h2>
    <p class="normal">Apple has <a id="_idIndexMarker260"/>provided four methods that we can use to construct a set from two other sets. These operations can be performed in place, on one of the sets, or used to create a new set. These operations are as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">union</code><strong class="keyword"> </strong>and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">formUnion</code>: These create a set with all the unique values from both sets <a id="_idIndexMarker261"/>and can be thought of as removing the duplicates.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">subtracting</code><strong class="keyword"> </strong>and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">subtract</code>: These create a set with values from the first set that are <a id="_idIndexMarker262"/>not in the second set.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">intersection</code><strong class="keyword"> </strong>and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">formIntersection</code>: These create a set with values that are common <a id="_idIndexMarker263"/>to both sets.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">symmetricDifference</code><strong class="keyword"> </strong>and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">formSymmetricDifference</code>: These create a new set with <a id="_idIndexMarker264"/>values that are in either set, but not in both sets.</li>
    </ul>
    <p class="normal">Let's look at some examples and see the results that can be obtained from each of these operations. For all the examples of set operations, we will be using the following two sets:</p>
    <pre class="programlisting code"><code class="hljs-code">var mySet1 = Set(["One", "Two", "Three", "abc"])
var mySet2 = Set(["abc","def","ghi", "One"])
</code></pre>
    <p class="normal">The first <a id="_idIndexMarker265"/>example uses the <code class="Code-In-Text--PACKT-">union</code> method. This method takes the unique values from both sets to make another set:</p>
    <pre class="programlisting code"><code class="hljs-code">var newSetUnion = mySet1.union(mySet2)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">newSetUnion</code> variable will contain the following values: <code class="Code-In-Text--PACKT-">One</code>, <code class="Code-In-Text--PACKT-">Two</code>, <code class="Code-In-Text--PACKT-">Three</code>, <code class="Code-In-Text--PACKT-">abc</code>, <code class="Code-In-Text--PACKT-">def</code>, and <code class="Code-In-Text--PACKT-">ghi</code>. We can use the <code class="Code-In-Text--PACKT-">formUnion</code> method to perform the <code class="Code-In-Text--PACKT-">union</code> function in place without creating a new set:</p>
    <pre class="programlisting code"><code class="hljs-code">mySet1.formUnion(mySet2)
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">mySet1set</code> set will contain all the unique values from the <code class="Code-In-Text--PACKT-">mySet1</code> and <code class="Code-In-Text--PACKT-">mySet2</code> sets.</p>
    <p class="normal">Now let's look at the <code class="Code-In-Text--PACKT-">subtract</code> and <code class="Code-In-Text--PACKT-">subtracting</code> methods. These methods will create a set with the values from the first set that are not in the second set:</p>
    <pre class="programlisting code"><code class="hljs-code">var newSetSubtract = mySet1.subtracting(mySet2)
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">newSetSubtract</code> variable will contain the <code class="Code-In-Text--PACKT-">Two</code> and <code class="Code-In-Text--PACKT-">Three</code> values because those are the only two values that are not also in the second set.</p>
    <p class="normal">We use the <code class="Code-In-Text--PACKT-">subtract</code> method to perform the subtraction function in place without creating a new set:</p>
    <pre class="programlisting code"><code class="hljs-code">mySet1.subtract(mySet2)
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">mySet1</code> set will contain the <code class="Code-In-Text--PACKT-">Two</code> and <code class="Code-In-Text--PACKT-">Three</code> values because those are the only two values that are not in the <code class="Code-In-Text--PACKT-">mySet2</code> set.</p>
    <p class="normal">Now let's look at the <code class="Code-In-Text--PACKT-">intersection</code> method, which creates a new set from the values that are common between the two sets:</p>
    <pre class="programlisting code"><code class="hljs-code">var newSetIntersect = mySet1.intersection(mySet2)
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">newSetIntersect</code> variable will contain the <code class="Code-In-Text--PACKT-">One</code> and <code class="Code-In-Text--PACKT-">abc</code> values since they are the values that are common between the two sets.</p>
    <p class="normal">We can use the <code class="Code-In-Text--PACKT-">formIntersection()</code> method to perform the intersection function in place without creating a new set:</p>
    <pre class="programlisting code"><code class="hljs-code">mySet1.formIntersection(mySet2)
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker266"/>example, the <code class="Code-In-Text--PACKT-">mySet1</code> set will contain the <code class="Code-In-Text--PACKT-">One</code> and <code class="Code-In-Text--PACKT-">abc</code> values since they are the values that are common between the two sets.</p>
    <p class="normal">Finally, let's look at the <code class="Code-In-Text--PACKT-">symmetricDifference()</code> methods. These methods will create a new set with values that are in either set, but not in both:</p>
    <pre class="programlisting code"><code class="hljs-code">var newSetExclusiveOr = mySet1.symmetricDifference(mySet2)
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">newSetExclusiveOr</code> variable will contain the <code class="Code-In-Text--PACKT-">Two</code>, <code class="Code-In-Text--PACKT-">Three</code>, <code class="Code-In-Text--PACKT-">def</code>, and <code class="Code-In-Text--PACKT-">ghi</code> values.</p>
    <p class="normal">To perform this method in place, we use the <code class="Code-In-Text--PACKT-">fromSymmetricDifference()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">mySet1.formSymmetricDifference(mySet2)
</code></pre>
    <p class="normal">These four operations (union, subtraction, intersection, and symmetric difference) add functionality that is not present with arrays. Combined with faster lookup speeds, as compared to an array, the set type can be a very useful alternative when the order of the collection is not important and the instances in the collection must be unique.</p>
    <h1 id="_idParaDest-121" class="title">Summary</h1>
    <p class="normal">In this chapter, we covered Swift collections. Having a good understanding of the native collection types of Swift is essential to architecting and developing applications in Swift since all but the most basic applications use them.</p>
    <p class="normal">The three Swift collection types are arrays, sets, and dictionaries. Arrays store data as an ordered collection. Sets store data as an unordered collection of unique values. Dictionaries store data in an unordered collection of key-value pairs.</p>
    <p class="normal">In the next chapter, we will look at how to use Swift's control flow statements.</p>
  </div>
</body></html>