- en: More on Operators and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about operators and how to use them. We
    learned how operators can help us in solving complex problems with ease. We got
    a grip on operators and their types, and we learned basic filtering operators
    and transforming operators in detail. It's time to move on to some interesting
    and advanced things you can do with operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining producers (Observable/Flowable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping emissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering/suppressing operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world HTTP client example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let's get started with combining producer (Observable/Flowable)
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Combining producers (Observable/Flowable)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications, it's a common situation to combine data from
    multiple sources before using them. One such situation is when you are building
    some offline application following an offline-first approach, and you want to
    combine the resultant data you got from the HTTP call with the data from the local
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, without wasting much time, let''s take a look at the operators that can
    help us combine producers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`startWith()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge()`, `mergeDelayError()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combineLatest()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, there are a few mechanisms to combine producers (Observables/Flowables).
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Merging producers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating producers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguous combination of producers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine latest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss all the previously mentioned techniques to combine producers
    in this chapter. However, let's start with an operator that we are already aware
    of.
  prefs: []
  type: TYPE_NORMAL
- en: The startWith operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We got introduced to the `startWith` operator in the previous chapter, but
    there''s still a lot to cover. This operator also lets you combine multiple producers.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can pass another source `Observable` or an `Iterator` instance to be prepended
    before the source `Observable` that the operator has subscribed to starts emitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding program, on comment `(1)`, we used the `startWith` operator
    and passed an `Interator` instance to it. The `startWith` operator internally
    converts the passed `Iterator` instance to an `Observable` instance (it''ll convert
    it to a `Flowable` instance in case you''re using `Flowable`). Here is the signature
    of the `startWith` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding signature of the `startWith` operator, we can also see that
    it uses `concatArray` internally, which we will be covering very soon in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we used the `startWith` operator with another source `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f451284-3231-439c-8882-2f532286a69a.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have got some grip on the `startWith` operator, now let's move forward
    with the `zip` operator. The `zip` operator implements a zipping mechanism to
    combine producers.
  prefs: []
  type: TYPE_NORMAL
- en: Zipping emissions – zip operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `zip` operator is quite interesting. Think of a situation where you''re
    working with multiple `Observable`/`Flowables` and want to perform some kind of
    operation on each subsequent emission of each producer. The `zip` operator enables
    you to perform exactly that. It accumulates emissions of multiple producers to
    create a new emission via the specified function. So, let''s look at a pictorial
    representation to delve deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9bcc79d-99a6-490f-94ce-5f00d05cfb18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the picture depicts, the `zip` operator accumulates emissions from multiple
    producers into a single emission. It also takes a function to apply on the emissions
    as the `scan` or `reduce` operator, but applies them to emissions from different
    producers.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we used two `Observable` in the preceding picture
    and the following example, but the `zip` operator works with up to nine `Observables`/`Flowables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zip` operator is defined in `companion object` (`static` method in Java)
    of the `Observable` class, thus can be directly accessed by writing `Observable.zip`
    itself. No need to access it through another instance. So, let''s take a look
    at the output before we proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f81d024-cb15-45c4-95aa-954067938d35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to understand and use the `zip` operator better, you need to keep
    the following points about it in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The `zip` operator works on each emission of the supplied producers. For example,
    if you pass three producers *x*, *y*, and *z* to the `zip` operator, it will accumulate
    the *n^(th)* emission of *x* with the *n^(th)* emission of *y* and *z*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `zip` operator waits for each of its producers to emit, before applying
    the function to them. For example, if you use `Observable.interval` as one of
    the producers in the `zip` operator, the `zip` operator will wait for each emission
    and will emit the accumulated values at the specified intervals as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the producers notify `onComplete` or `onError` without emitting the
    item it was waiting for, then it'll discard all emissions afterwards, including
    that particular one from other producers as well. For example, if producer *x*
    emits `10` items, producer *y* emits `11` items, and producer *z* emits `8` items,
    the `zip` operator will accumulate the first `8` emissions from all the producers
    and will discard all remaining emissions from producer *x* and *y*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zipWith operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instance version (that is, the copy of the function, which should be called
    with an instance rather than static) of the `zip` operator is `zipWith`, which
    can be called from the `Observable` instance itself. The only problem with this
    version is that you can pass only another source `Observable`. If you need to
    work with three or more `Observable` instances, you should rather consider using
    the `zip` operator instead of `zipWith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6e88bba-25d3-4737-b3ba-390da7fae31b.png)'
  prefs: []
  type: TYPE_IMG
- en: On comment `(1)`, we used the `zipWith` operator on the `Observable` instance,
    `observable1`, and passed another `Observable` instance, `observable2`, to it
    with a lambda to apply to the emissions. From the output, we can tell that the
    `zipWith` operator accumulates the producer it's subscribed to, with the producer
    it is provided with.
  prefs: []
  type: TYPE_NORMAL
- en: The combineLatest operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `combineLatest` operator works in a similar way like the `zip` operator.
    It accumulates the emissions of the provided producers. The only difference between
    `combineLatest` and `zip` is that the `zip` operator waits for each of its source
    producers to emit, before it starts processing all the emissions to create its
    new one, but the `combineLatest` operator starts as soon as it receives any emit
    from any of its source producers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this operator better, we will see an example with both, the `zip`
    and the `combineLatest` operator. Let''s first try the example with the `zip`
    operator, as we gained some grip on it already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows. As expected, it accumulates each and every emission
    and prints them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/608d635c-814e-4199-a81d-cf6e69c67487.png)'
  prefs: []
  type: TYPE_IMG
- en: In this program, we created `Observable` with a 100 milliseconds interval on
    comment `(1)`. On comment `(2)`, we created another `Observable` with a `250`
    milliseconds interval. In the output, we can see `3` emits, as, after zipping
    them, the total interval becomes `350` milliseconds, and within 1,100 milliseconds
    of delay, there is room for only `3` emits with `350` milliseconds interval in
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test the same code with `combineLatest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fba26bd-b03d-462c-ad06-38bbeb21d92b.png)'
  prefs: []
  type: TYPE_IMG
- en: As the output suggests, the `combineLatest` operator processes and emits the
    value as soon as it gets an emit from any of its source producers by using the
    last emitted value for all other source producers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move forward with merging producers, with the help of the `merge`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Merging Observables/Flowables – merge operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The zipping operation will let you accumulate emissions, but what if you want
    to subscribe to each emission by all the source producers? Say you have two different
    producers and have the same set of actions to be applied when subscribing to them;
    there's no way to mix imperative programming and reactive programming and repeatedly
    subscribe to both of the producers separately with the same code. It'll also result
    in redundant code. So, what is the solution here? You got it right; merging all
    the emissions of all the source producers together and subscribing to them as
    a whole is the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, on comment `(1)`, we will merge two `observable` and subscribe
    to them as a whole. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df6ceb40-6b39-4978-ac8d-51a2e27e0a61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the output shows, the `merge` operator merged two `Observables` and put the
    emissions of both the `Observables` in their order of emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The merging operation, however, doesn''t maintain the order specified; rather,
    it''ll start listening to all the provided producers instantly and will fire emissions
    as soon as they are emitted from the source. Let''s look at an example that illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, on comment `(1)` and `(2)`, we created two `Observable<Long>`
    instances with the `Observable.interval` operator, then mapped it with `Observable`
    numbering and got instances of `Observable<String>`. The objective of the `map`
    operator here is to inject an `Observable` identification in the output so we
    can easily identify the `Observable` source from the merged output.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the much discussed output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff22fe73-51f3-4f15-98fd-1b208241fa60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output clearly shows that the `merge` operator took emissions from `observable2`
    first, as they came first, even though we put `observable1` first in the `merge`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `merge` operator, however, supports up to four parameters. As a fallback,
    we have the `mergeArray` operator, which accepts `vararg` of `Observable`; the
    following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2589493f-e1c8-42b1-b8e2-1a7430d6c215.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with the `zip` operator, the `merge` operator also has a version for calling
    on instances of `Observable`''s rather than, statically, `mergeWith`; we can call
    this operator on `Observable` instances. So, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The program is simple enough. We are creating two `Observable` instances, and
    then merging `observable1` with `observable2` with the `mergeWith` operator called
    on the `observable1` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6229c197-8b2f-4b50-92df-86f4bbe2293d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The literal meaning of merging is combining two things together to create a
    new one, irrespective of any order; all the merging operators do the same thing.
    If you want to maintain the order, you have to concatenate one after another.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating producers (Observable/Flowable)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concatenating operators are almost the same with `merge` operators, except that
    the concatenating operators respect the prescribed ordering. Instead of subscribing
    to all provided producers in one go, it subscribes to the producers one after
    another; only once, it received `onComplete` from the previous subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify our last program with the `concatenate` operator and see
    the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we already mentioned, the `concat` operator subscribes to the next source
    `Observable` in the queue only after it got `onComplete` from its current source
    `Observable`; we also know that the `Observable` instances created with `Observable.interval`
    never emit `onComplete`. Rather, they keep emitting numbers until `Long.MAX_VALUE`
    is reached. So, as a quick fix, we used the `take` operator on comment `(1)`,
    which will take the first two emissions from `Observable.interval` and then will
    append an `onComplete` notification to it so that the `concat` operator can start
    listening to the next source Observable as well.
  prefs: []
  type: TYPE_NORMAL
- en: We are discussing the `take` operators in this chapter in the *Skipping and
    taking emissions* section. Don't forget to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af28c538-b870-460e-9eae-28b4c6925bc4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can clearly see that the `concat` operator is subscribed
    to the next supplied source `Observable` only after it got the `onComplete` notification
    from its first one.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the `merge` operator, the `concat` operator also has `concatArray`
    and `concatWith` variants, and they work in almost the same way, just concatenating
    instead of merging.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguously combining producers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ambiguous combination of producers is probably the easiest among all combination
    types. Think of a situation where you're fetching data from two data sources (may
    be two separate APIs or database tables), and want to proceed with the first one
    you got and discard the other one. In the imperative programming technique, you
    would probably be required to write checks for that; however, with RxKotlin, the
    `amb` operator is there to hold your back.
  prefs: []
  type: TYPE_NORMAL
- en: The `amb` operator takes a list of `Observable` (`Iterable<Observable>` instance)
    as parameter, subscribes to all `Observables` present in the `Iterable` instance,
    emits the items that it got from the first `Observable` it got an emit from, and
    discards the rest of `Observables` present on the `Iterable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will help us understand better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in this program, we created two `Observable`''s with a `500` and a `100`
    milliseconds interval on comment `(1)` and `(2)` respectively. On comment `(3)`,
    we used the `listOf` function to create a `List<Observable>` from those two `Observable` and
    passed it to the `amb` operator. Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a444006-a544-4e14-a511-161416f032af.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the output that the `amb` operator took the emissions from `observable2`
    and didn't care about `observable1`, as the `observable2` instance emitted first.
  prefs: []
  type: TYPE_NORMAL
- en: Just like other combination operators, `amb` also has `ambArray` and `ambWith`
    operator variants.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grouping is a powerful operation that can be achieved using RxKotlin. This operation
    allows you to group emissions based on their property. Say, for example, you have
    an `Observable` / `Flowable` emitting integer numbers (`Int`), and, as per your
    business logic, you have some separate code for even and odd numbers and want
    to handle them separately. Grouping is the best solution in that scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I've grouped emissions based on their remainder when divided
    by `5`, so, basically, there should be `5` groups (`0` through `4`). On comment
    `(1)` of this example, we used the `groupBy` operator and passed a predicate to
    it, upon which the grouping should be performed. The `groupBy` operator takes
    the result of the predicate to group emissions.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)` of this example, we used the `blockingSubscribe` operator to
    subscribe to the newly created `Observable<GroupedObservable<K, T>>` instance.
    We could also use the simple `subscribe` operator; however, as we are printing
    the output to the console, by using `subscribe`, everything will look like a mess.
    Mainly because the `subscribe` operator doesn't wait for the given task on emission
    to complete before taking the next emission. On the other hand, `blockingSubscribe`
    will make the program wait until it completes processing an emission, before proceeding
    to a new one.
  prefs: []
  type: TYPE_NORMAL
- en: The `groupBy` operator returns `Observable` that emits `GroupedObservable`,
    containing our groups; so, inside `blockingSubscribe`, we need to subscribe to
    the emitted `GroupedObservable` instance. On comment `(3)`, we did the same, after
    printing the `key` of the emitted `GroupedObservable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e4b8792-faec-4bba-bfb6-e69ecaf5e0a3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: flatMap, concatMap – In details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As promised in the previous chapter, now we will take a deeper dive into the
    `flatMap` and `concatMap` operators, as, by now, we have already gained some sort
    of expertise on the `merge` and `concat` operators and know the differences between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the differences between `flatMap` and `concatMap`, after which,
    we will also discuss their ideal implementation scenarios. We will also discuss
    some of their variants to know them better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we mentioned that `flatMap` internally uses the `merge`
    operator and `concatMap` internally uses the `concat` operator. However, what
    difference does that make? You just learned the differences between the `merge`
    and the `concat` operator, but what is the point of having two separate mapping
    operators based on them? So, let''s start with an example. We will see an example
    with `flatMap`, and then we will try to implement the same with `concatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created an `Observable` instance. We then used
    the `flatMap` operator with the `delay` operator on it to add a random delay to
    the emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d34b8d5-676e-409a-9f4b-c50b60f2b5e0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can see that the downstream didn't get the emissions in
    their prescribed order; I think you got the reason behind it, didn't you? That's
    right; the cause behind it is simply the `merge` operator, as the `merge` operator
    subscribes and reemits the emissions asynchronously all at one go, thus the order
    is not maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the code with the `concatMap` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa64ca05-a241-4e58-b7bc-b7b48ec15e2e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the `concatMap` operator uses `concat` internally, it maintains the prescribed
    order of emissions.
  prefs: []
  type: TYPE_NORMAL
- en: So, when to use which operator? Let's take a look at the following real-time
    scenarios; all of them are applicable, especially when you are building an app.
  prefs: []
  type: TYPE_NORMAL
- en: When to use flatMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following list—it contains the contexts and situations where
    `flatMap` will fit best:'
  prefs: []
  type: TYPE_NORMAL
- en: When you're working with a list of data within a page, activity, or fragment
    and want to send some data to a server or a database per item of the list. The
    `concatMap` operator will also do here; however, as the `flatMap` operator works
    asynchronously, it'll be faster, and, as you're sending data, the order doesn't
    really matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you want to perform any operation on list items asynchronously and
    in a comparatively short time period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use concatMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, when to use `concatMap`?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains the contexts and situations where `concatMap` will
    fit best:'
  prefs: []
  type: TYPE_NORMAL
- en: When you are downloading the list of data to display to the user. The order
    really matters here, you will surely not want to load and display the second item
    of the list after the third and fourth one are already displayed, would you?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing some operation on a sorted list, making sure the list stays the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding switchMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switchMap` operator is really interesting. It listens to all the emissions
    of the source producer (Observable/Flowable) asynchronously, but emits only the
    latest one within the timeframe. Let's explain it a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the source `Observable` emits more than one item consecutively before
    the `switchMap` has emitted any of them, `switchMap` will take the last one and
    discard any emission that came in between. Let''s take an example to understand
    it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60858640-4fdd-41eb-8dc1-b6b82683cfea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the program, we took two approaches at first, we used the `delay` operator,
    and then we reused the same with the `delay` operator. From the output, we can
    see that, for the second one, `switchMap` only emitted the last item, as it got
    consecutive emission for each one before it reemitted them. However, for the first
    one, it reemitted all the items before receiving any further emit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still confused? Let''s modify the program a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this program, instead of adding delay to all the emissions, we emitted all
    the numbers divisible by `3` without delay, and added a delay to the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70c95536-36a1-43b6-95c6-f5ead179e4ec.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `switchMap` operator emits the only those items which were
    emitted by the source without delay, and the last emitted item by the source.
    The reason is quite simple; the `switchMap` operator was able to emit them before
    it received the following item.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping and taking emissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the preceding situation in this chapter, where we used the `take`
    operator, there are often some scenarios where you would like to take some of
    the emissions and skip the remaining ones. The `skip` and `take` operators are
    of huge help in those scenarios. They are actually a part of the filtering operators
    we discussed in the previous chapter; however, honestly, they do deserve a dedicated
    discussion. So, here it is.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping emissions (skip, skipLast, skipUntil, and skipWhile)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be a requirement where you would like to skip some emissions at the
    beginning or skip emissions until a particular condition is met. You may even
    have to wait for another producer before taking emissions and skip all remaining
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: These operators are designed keeping the exact scenario in mind. They help you
    skip emissions in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'RxKotlin provides us with many variations and overloads of the `skip` operator;
    we will discuss the most important ones among them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`skip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipLast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipWhile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipUntil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a look at all of the preceding listed operators one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `skip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `skip` operator has two important overloads: `skip(count:Long)` and `skip(time:Long,
    unit:TimeUnit)`; the first overload works on count, discarding the first *n* number
    of emissions, while the second overload works on time, discarding all the emissions
    that came in the specified time duration.'
  prefs: []
  type: TYPE_NORMAL
- en: In this program, on comment `(1)`, we used the `skip(count)` operator to skip
    the first `5` emissions. On comment `(2)`, we used the `skip(time,unit)` operator
    to skip all emissions in the first `400` milliseconds (4 seconds) of the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/506e0abb-25c6-4dac-b820-a20fe9287f81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take a look at how the `skipLast` operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `skipLast` operator has many overloads like the `skip` operator. The only
    difference is that this operator discards emissions from last. In this program,
    we used the `skipLast(count)` operator to skip the last `5` emissions on comment
    `(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72778450-3956-42c5-ac04-9c3337ec6556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike `skip` and `skipLast`, both of which skip emissions on the basis of
    count or time, `skipWhile` skips them on the base of a predicate (logical expression).
    You''ve to pass a predicate to the `skipWhile` operator, just like the `filter`
    operator. It will keep skipping emissions while the predicate evaluates to true.
    It will start passing all emissions downstream as soon as the predicate returns
    false. Let''s take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c858ab3-fdba-42c1-92e5-ca5f9be5ed7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, unlike filter, the `skipWhile` operator will execute the predicate
    until it returns false and pass all the emissions thereafter. If you want the
    predicate, check on all the emissions; you should rather consider the `filter`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a situation where you''re working with two producers, producer1 and
    producer2, and want to start processing emissions from producer1 as soon as producer2
    starts emitting. In this scenario, `skipUntil` can help you out. Let''s look at
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will explain the code, but take a look at the output first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/167b8199-a206-4b24-904b-ece08f0cb4b4.png)'
  prefs: []
  type: TYPE_IMG
- en: On comment `(1)`, we created an `Observable` instance (`observable2`) with `Observable.timer`,
    which should trigger emission after `500` milliseconds. On comment `(2)`, we used
    that `Observable` instance (`observable2`) as the parameter to the `skipUntil`
    operator, which will make it discard all the emissions of `observable1` until
    `observable2` emits.
  prefs: []
  type: TYPE_NORMAL
- en: Take operators (take, takeLast, takeWhile, and takeUntil)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `take` operators work in exactly the opposite way than the `skip` operators.
    Let''s take an example of them one by one and understand how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This program is almost like the program with `skip`. The difference is that
    here, we used `take` instead of `skip`. Let''s check the difference to understand
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f9ecce8-1164-4214-aaf3-0acac163aedf.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows it clearly. In the exact opposite way than the `skip` operator,
    the `take` operator passes the specified emissions to downstream, discarding the
    remaining ones. Most importantly, it also sends `onComplete` notifications to
    downstream on its own, as soon as it completes passing all the specified emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it with `takeLast` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is the output; it prints the last `5` numbers in the emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b68993d0-5f7f-4e5c-a9b7-30d127ae0b96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now take a look at the `takeWhile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the exact opposite of `skipWhile`; instead of skipping the first
    `10` numbers, it prints them and discards the remaining ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b09b0f74-c355-4734-8478-f8ddfd573c14.png)'
  prefs: []
  type: TYPE_IMG
- en: The error handling operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While developing applications, errors may occur. We have to handle those errors
    properly to make sure our applications perform seamlessly on the user''s end.
    Take the following program as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ce81943-b2e2-46d0-854d-6202f1815d5e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the program threw an error and that is a bad thing if that occurs
    on the user end. So, let's take a look at how we can handle errors in a reactive
    way. RxKotlin provides us with a few operators for error handling, which we'll
    take a look at. We will use the previous program and apply various error handling
    operators to them to understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: onErrorReturn – return a default value on error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `onErrorReturn` provides you with a technique to specify a default value
    to return to the downstream in case an error occurred in the upstream. Take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `onErrorReturn` operator to return `-1` whenever an error occurs.
    The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b47f7737-4dd2-4843-8c97-6de780c3e88c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the output, the `onErrorReturn` operator returns the specified
    default value. The downstream didn't receive any item further as the upstream
    stopped emitting items as soon as the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, both `onError` and `onComplete` are terminal operators,
    so the downstream stops listening to that upstream as soon as it receives any
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: The onErrorResumeNext operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onErrorResumeNext` operator helps you subscribe to a different producer
    in case any error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a5eb34f-e255-4706-b80b-929b6810fed6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This operator is especially useful when you want to subscribe to another source
    producer in case any error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying on error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `retry` operator is another error handling operator that enables you to
    retry/re-subscribe to the same producer when an error occurs. You just need to
    provide a predicate or retry-limit when it should stop retrying. So, let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On comment `(1)`, we used the `retry` operator with a retry limit, and on comment
    `(2)`, we used the `retry` operator with a predicate. The `retry` operator will
    keep retrying until the predicate returns true and will pass the error to downstream
    whenever the predicate returns false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0eb2a87c-b227-44ed-a8ed-883acece3045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An HTTP example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any learning is not complete until and unless we apply it to a real-time scenario.
    So far, you have learned many concepts of reactive programming. Now, it's time
    to apply them to a real-world scenario, where we will use an API to get some data
    through an HTTP request and print the response data to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used one additional plugin for this example—`RxJava-Apache-HTTP`. If you''re
    using Gradle as your build tool, add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we used `HttpAsyncClients.createDefault()` to get an instance
    of `CloseableHttpAsyncClient`. Before starting an HTTP request, we first need
    to start the client. We did this in the code on comment `(2)`, with `httpClient.start()`.
    On comment `(3)`, we created a GET request and converted it to an observable of
    type `ObservableHttpResponse`, so we used the `flatMap` operator to get access
    to the content of the response. Inside the `flatMap` operator, we used the `map`
    operator to convert the byte response into a `String` on comment `(4)`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(5)`, we used the `onErrorReturn` operator to return a default `String`
    in case there's an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the `onErrorReturn` operator, we subscribed to the chain and
    printed the response on comment `(6)`. We closed the `httpClient` as soon as we
    were done with the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is partly a screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44dfe194-ba14-4a85-b8c0-5760ff6aeb3b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a rather a long chapter. You learned about combining producers, and
    learned, in depth, about the `flatMap`, `concatMap`, and `switchMap` operators.
    You got introduced to the `take` and `skip` operators and their variants. You
    learned about the error handling approaches in reactive programming. We also tried
    our skills with an HTTP client example, where we requested an API to fetch JSON
    data and print it to the console. We didn't try to parse the JSON data, as it
    could increase complexity at this level. Later in this book, we will definitely
    parse data and display that properly.
  prefs: []
  type: TYPE_NORMAL
- en: While this and [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml), *Asynchronous
    Data Operators and Transformations* were more about operators, the next chapter,
    [Chapter 7](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml), *Concurrency and Parallel
    Processing in RxKotlin with Schedulers*, is mainly about schedulers, handling
    concurrency, and multi-threading, and we will get a deeper dive in asynchronous
    programming with RxKotlin. As we are gradually moving to more advanced topics
    and chapters through this book, you need to pay more attention to each chapter
    to get a proper grasp on each aspect of reactive programming in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are you waiting for? Turn the page, [Chapter 7](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml), *Concurrency
    and Parallel Processing in RxKotlin with Schedulers* is waiting for you.
  prefs: []
  type: TYPE_NORMAL
