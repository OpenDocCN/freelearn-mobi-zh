- en: Chapter 2. Functions and Closures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had an overview of functional programming and the
    Swift programming language. It introduced some of the key concepts about functions.
    As functions are the fundamental building blocks in functional programming, this
    chapter dives deeper into it and explains all the aspects related to the definition
    and usage of functions in functional Swift, together with coding examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a definition of functions, continues with other related
    topics such as function types and tuples, and finally concludes with more advanced
    topics such as first-class functions, higher-order functions, function composition,
    closures, currying, recursion, and memoization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax of functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using function parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting internal and external parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting default parameter values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using variadic functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values from functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using nested functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of a custom operator
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using closures
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function currying
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a function?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) looks very natural to most developers
    as it simulates a real-life situation of classes or, in other words, blueprints
    and their instances, but it brought a lot of complexities and problems such as
    instance and memory management, complex multithreading, and concurrency programming.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Before OOP became mainstream, we were used to developing in procedural languages.
    In the C programming language, we did not have objects and classes; we would use
    structs and function pointers. So now we are talking about functional programming
    that relies mostly on functions just as procedural languages relied on procedures.
    We are able to develop very powerful programs in C without classes; in fact, most
    operating systems are developed in C. There are other multipurpose programming
    languages such as Go by Google that is not object-oriented and is getting very
    popular because of its performance and simplicity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: So, are we going to be able to write very complex applications without classes
    in Swift? We might wonder why we should do this. Generally, we should not, but
    attempting it will introduce us to the capabilities of functional programming.
    This is why we will have a whole chapter about functions before talking about
    other building blocks such as `classes`, `structs`, and `enums`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A function is a block of code that executes a specific task, can be stored,
    can persist data, and can be passed around. We define them in standalone Swift
    files as global functions or inside other building blocks such as `classes`, `structs`,
    `enums`, and `protocols` as methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: They are called methods if they are defined in classes but, in terms of definition,
    there is no difference between a function and method in Swift.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Defining them in other building blocks enables methods to use the scope of the
    parent or to be able to change it. They can access the scope of their parent and
    they have their own scope. Any variable that is defined inside a function is not
    accessible outside of it. The variables defined inside them and the corresponding
    allocated memory go away when the function terminates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Functions are very powerful in Swift. We can compose a program with only functions
    as functions can receive and return functions, capture variables that exist in
    the context they were declared, and can persist data inside themselves. To understand
    the functional programming paradigms, we need to understand the capability of
    functions in detail. We need to think if we can avoid classes and only use functions,
    so we will cover all the details related to functions in upcoming sections of
    this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax of functions and methods
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define functions or methods as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we know already, when functions are defined in objects, they become methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to define a method is to tell the compiler from where it can
    be accessed. This concept is called access control in Swift and there are three
    levels of access control. We are going to explain them for methods as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Public access**: Any entity can access a method that is defined as public
    if it is in the same module. If an entity is not in the same module, we will need
    to import the module to be able to call the method. We need to mark our methods
    and objects as `public` when we develop frameworks in order to enable other modules
    to use them.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal access**: Any method that is defined as `internal` can be accessed
    from other entities in a module but cannot be accessed from other modules.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private access**: Any method that is defined as `private` can be accessed
    only from the same source file.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, if we do not provide the access modifier, a variable or function
    becomes internal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Using these access modifiers, we can structure our code properly; for instance,
    we can hide details from other modules if we define an entity as internal. We
    can even hide the details of a method from other files if we define them as private.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Before Swift 2.0, we had to define everything as public or add all source files
    to the testing target. Swift 2.0 introduced the `@testable import` syntax that
    enables us to define internal or private methods that can be accessed from testing
    modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can generally be in three forms:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance methods**: We need to obtain an instance of an object (in this book
    we will refer to `classes`, `structs`, and `enums` as objects) in order to be
    able to call the method defined in it, and then we will be able to access the
    scope and data of the object.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static methods**: Swift names them type methods also. They do not need any
    instances of objects and they cannot access the instance data. They are called
    by putting a dot after the name of the object type (for example, `Person.sayHi()`).
    The `static` methods cannot be overridden by the subclasses of the object that
    they reside in.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class methods**: Class methods are like the `static` methods but they can
    be overridden by subclasses.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered the keywords that are required for method definitions; now we
    will concentrate on the syntax that is shared among functions and methods. There
    are other concepts related to methods that are out of scope of this book as we
    will concentrate on functional programming in Swift.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to cover the function definition, now comes the `func` keyword that
    is mandatory and is used to tell the compiler that it is going to deal with a
    function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the function name that is mandatory and is recommended to be camel-cased
    with the first letter as lowercase. The function name should be stating what the
    function does and is recommended to be in the form of a verb when we define our
    methods in objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our classes will be named nouns and methods will be verbs that are
    in the form of orders to the class. In pure functional programming, as the function
    does not reside in other objects, they can be named by their functionalities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Parameters follow the `func` name. They will be defined in parentheses to pass
    arguments to the function. Parentheses are mandatory even if we do not have any
    parameters. We will cover all aspects of parameters in *Defining and using function
    parameters* section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Then comes `throws`, which is not mandatory. A function or method that is marked
    with the `throws` keyword may or may not throw errors. We will cover error handling
    mechanisms in upcoming chapters. At this point, it is enough to know what they
    are when we see them in a function or method signature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The next entity in a function type declaration is the return type. If a function
    is not void, the return type will come after the `->` sign. The return type indicates
    the type of entity that is going to be returned from a function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: We will cover return types in detail in *Returning values from functions* section
    of this chapter, so now we can move on to the last piece of function that is present
    in most programming languages, our beloved `{ }`. We defined functions as blocks
    of functionality and `{ }` defines the borders of the block so that the function
    body is declared and execution happens in there. We will write the functionality
    inside `{ }`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in function definition
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are proven best practices for function and method definition provided
    by amazing software engineering resources, such as *Clean Code: A Handbook of
    Agile Software Craftsmanship*, by *Robert C. Martin*, *Code Complete: A Practical
    Handbook of Software Construction, Second Edition*, by *Steve McConnell*, and
    Coding Horror ([https://blog.codinghorror.com/code-smells/](https://blog.codinghorror.com/code-smells/)),
    that we can summarize as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Try not to exceed 8-10 lines of code in each function as shorter functions or
    methods are easier to read, understand, and maintain.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the number of parameters minimal because the more parameters a function
    has, the more complex it is.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should have at least one parameter and one return value.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using type names in function names as it is going to be redundant.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aim for one and only one functionality in a function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name a function or method in a way that describes its functionality properly
    and is easy to understand.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name functions and methods consistently. If we have a connect function, we can
    have a disconnect one.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write functions to solve the current problem and generalize it when needed.
    Try to avoid what-if scenarios as probably **you aren't gonna need it** (**YAGNI**).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered a general syntax to define a function and method if it resides
    in an object. Now it is time to talk about how we call our defined functions and
    methods. To call a function, we will use its name and provide its required parameters.
    There are complexities with providing parameters that we will cover in upcoming
    section. For now, we are going to cover the most basic type of parameter, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This type of function calling should be familiar to Objective-C developers as
    the first parameter name is not named and the rest are named.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a method, we need to use the dot notation provided by Swift. The following
    examples are for class instance methods and static class methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Defining and using function parameters
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In function definition, parameters follow the function name and they are constants
    by default so we will not able to alter them inside the function body if we do
    not mark them with `var`. In functional programming, we avoid mutability; therefore,
    we would never use mutable parameters in functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters should be inside parentheses. If we do not have any parameters,
    we simply put open and close parentheses without any characters between them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In functional programming, it is important to have functions that have at least
    one parameter. We will explain why it is important in upcoming sections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have multiple parameters separated by commas. In Swift, parameters are
    named so we need to provide the parameter name and type after putting a colon,
    as shown in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ParameterType` can also be an optional type so the function becomes the following
    if our parameters need to be optionals:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Swift enables us to provide external parameter names that will be used when
    functions are called. The following example presents the syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Only the local parameter name is usable in the function body.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to omit parameter names with the `_` syntax; for instance, if
    we do not want to provide any parameter name when the function is called, we can
    use `_` as `externalParamName` for the second or subsequent parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have a parameter name for the first parameter name in function
    calls, we can basically provide the local parameter name as external also. In
    this book, we are going to use the default function parameter definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters can have default values as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Parameters can be defined as `inout` to enable function callers obtaining parameters
    that are going to be changed in the body of a function. As we can use tuples for
    function returns, it is not recommended to use `inout` parameters unless we really
    need them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define function parameters as tuples. For instance, the following example
    function accepts a tuple of the `(Int, Int)` type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As, under the hood, variables are represented by tuples in Swift, the parameters
    to a function can also be tuples. For instance, let''s have a simple `convert`
    function that takes an array of `Int` and a multiplier and converts it to a different
    structure. Let''s not worry about the implementation of this function for now;
    we will have [Chapter 6](ch06.html "Chapter 6. Map, Filter, and Reduce"), *Map,
    Filter, and Reduce* that will cover the map function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we use this function as `let resultOfConversion = convert(numbers: numbers,
    multiplier: 3)`, the result is going to be `["0: 9", "1: 15", "2: 27", "3: 30"]`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call our function with a tuple. Let''s create a tuple and pass it to
    our function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result is identical to our previous function call. However, passing tuples
    in function calls is removed from Swift 3.0, so it is not recommended to use them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define higher-order functions that can receive functions as parameters.
    In the following example, we define `funcParam` as a function type of `(Int, Int)
    -> Int`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Swift, parameters can be of a generic type. The following example presents
    a function that has two generic parameters. In this syntax, any type (for example,
    `T` or `V`) that we put inside `<>` should be used in parameter definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will cover generics in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*; at this point, knowing
    the syntax should be enough.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using variadic functions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift enables us to define functions with variadic parameters. A variadic parameter
    accepts zero or more values of a specified type. Variadic parameters are similar
    to array parameters but they are more readable and can only be used as the last
    parameter in multiparameter functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As variadic parameters can accept zero values, we will need to check whether
    they are empty.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a function with variadic parameters of the `String`
    type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Returning values from functions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need our function to return a value, tuple, or another function, we can
    specify it by providing `ReturnType` after `->`. For instance, the following example
    returns `String`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any function that has `ReturnType` in its definition should have a `return`
    keyword with the matching type in its body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Return types can be optionals in Swift so the function becomes as follows if
    the return needs to be optional:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Tuples can be used to provide multiple return values. For instance, the following
    function returns a tuple of the `(Int, String)` type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we are using parentheses for tuples, we should avoid using parentheses for
    single return value functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuple return types can be optional too so the syntax becomes as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This syntax makes the entire tuple optional; if we want to make only `status`
    optional, we can define the function as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Swift, functions can return functions. The following example presents a
    function with the return type of a function that takes two `Int` values and returns
    an `Int` value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we do not expect a function to return any value, tuple, or function, we
    simply do not provide `ReturnType`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could also explicitly declare it with the `Void` keyword:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In functional programming, it is important to have return types in functions.
    In other words, it is a good practice to avoid functions that have `Void` as return
    type. A function with the `Void` return type typically is a function that changes
    another entity in the code; otherwise, why would we need to have a function? OK,
    we might have wanted to log an expression to the console/log file or write data
    to a database or a file to a filesystem. In these cases, it is also preferable
    to have a return or feedback related to the success of the operation. As we try
    to avoid mutability and stateful programming in functional programming, we can
    assume that our functions will have returns in different forms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'This requirement is in line with mathematical underlying bases of functional
    programming. In mathematics, a simple function is defined as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `f` is a function that takes `x` and returns `y`. Therefore, a function
    receives at least one parameter and returns at least a value. In functional programming,
    following the same paradigm makes reasoning easier, function composition possible,
    and code more readable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are functions that do not possess any side effects; in other
    words, they do not change or alter any data or state outside of themselves. Additionally,
    they do not access any data or state except their provided parameters. Pure functions
    are like mathematical functions that are pure by nature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions return a value that is only determined by its parameter values.
    Pure functions are easy to test as they rely only on their parameters and do not
    change or access any data or state outside of themselves. Pure functions are suitable
    for concurrency as they do not access and change global data or states.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list presents examples of pure and not pure functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Printing a String literal to a console is not pure as it modifies an external
    state.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file is not pure as it depends on the external state at different
    times.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length of a String is pure as it does not rely on a state. It only takes a String
    as input and returns the length as output.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the current date is not pure as it returns different values when called
    at different dates.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a random number is not pure as it returns different values each time
    it is called.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pure functions may sound very restrictive and impossible to utilize in
    real-world scenarios, but there are other tools that can provide the same functionality,
    which we will discuss later in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We will see the benefits of pure functions in more detail in the next chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function parameter type along with its return type defines the type of the
    function. For instance, the function type for the following coding example is
    `(Int, Double) -> String`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will be able to use function types in the way we use other types. The following
    code example presents a function type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `simpleMathOperator` is a variable of a function of the `(Double, Double)
    -> Double` type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define `typealias` for the function type as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use this `typealias` in the `simpleMathOperator` definition as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can define functions with the same type and assign them to our `simpleMathOperator`.
    The type of functions in the following code snippet is `(Double, Double) -> Double`,
    which is in fact `SimpleOperator`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Therefore, we are able to assign these functions to `simpleMathOperator` as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means that `simpleMathOperator` refers to the `multiplyTwoNumbers` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As the other three functions also have the same function type, we will be able
    to assign them to the same variable:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use `SimpleOperator` as a parameter type of other functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the `calculateResult` function has three parameters. The `mathOperator`
    parameter is a type of function type. The `a` and `b` parameters are `Double`.
    When we call this function, we pass a `simpleMathOperator` function and two `Double`
    values for `a` and `b`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that we pass only a reference to `simpleMathOperator`
    and this is not going to execute it. In the function body, we use this function
    and call it with `a` and `b`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `SimpleOperator` as a return type of a function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `choosePlusMinus` function has a `Bool` parameter; in its body, it
    checks for this parameter and returns `addTwoNumbers` or `subtractTwoNumbers`
    that have the same type, `SimpleOperator`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand that calling `choosePlusMinus(true)` does not
    execute the returned function and in fact only returns the reference to `addTwoNumbers`.
    We save this reference in `chosenOperator`. The `chosenOperator` variable becomes
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we call `chosenOperator(3.5, 5.5)`, we pass these two numbers to the `addTwoNumbers`
    function and execute it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The capability to define function types makes functions first-class citizens
    in Swift. Function types are used for first-class and higher-order functions.
    These capabilities empower us to apply functional programming paradigms in Swift.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using nested functions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, it is possible to define functions inside other functions. In other
    words, we can nest functions inside other functions. Nested functions are only
    accessible inside their enclosing functions and are hidden from the outside world
    by default. The enclosing function can return the nested function in order to
    allow the nested function to be used in other scopes. The following example presents
    a function that contains two nested functions and returns one of them according
    to the value of its `isPlus` parameter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First-class functions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Function types* section of this chapter, we have seen that we can define
    function types and store and pass functions around. In practice, this means that
    Swift treats functions as values. To explain this, we will need to examine a couple
    of examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code example, we create a constant of the `String` type and `name` and
    store a value (`"Your name"`) in it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define a function, we need to specify the type of parameters:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, our `name` parameter is of the `String` type. This parameter
    could be any other value type or reference type. Simply, it could be `Int`, `Double`,
    `Dictionary`, `Array`, `Set`, or it could be an object type such as an instance
    of `class`, `struct`, or `enum`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call this function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we pass a value for this parameter. In other words, we pass one of the
    previously mentioned types with their respective values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift treats functions like the other aforementioned types so we can store
    a function in a variable as we were able to with other types:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we saved the `sayHello` function in a variable that can be
    used later on and passed around as a value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In pure OOP, we do not have functions; instead, we have methods. In other words,
    functions can only reside in objects and then they are called methods. In OOP,
    classes are first-class citizens and methods are not. Methods are not solely reachable
    and cannot be stored or passed around. In OOP, methods access the object's data
    that they are defined in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, functions are first-class citizens. Just like other
    types, they can be stored and passed around. In contrast to OOP, that method could
    only access their parent object's data and change it; in functional programming,
    they can be stored and passed to other objects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: This notion enables us to compose our applications with functions as they are
    just another type that can be used. We will talk about this in more detail; for
    now, it is important to understand why we call functions as first-class citizens
    in Swift.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the *Defining and using function parameters* and *Function
    types* sections of this chapter, functions can accept functions as parameters
    in Swift. Functions that can accept other functions as parameters are called higher-order
    functions. This concept along with first-class functions empower functional programming
    and function decomposition.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As this topic is essential in functional programming, we will go through another
    simple example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we need to develop two functions that add and subtract two `Int`
    values as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, we need to develop functions to calculate the square and triple of two
    `Int` values as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Suppose we need another function that subtracts the squared two values:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Suppose we need to add two squared values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s say that we need another function that triples a value and adds it to
    another tripled value:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This way, we had to write a lot of redundant and inflexible functions. Using
    higher-order functions, we could write a flexible function as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This higher-order function takes two other functions as parameters and uses
    them. We can call it for different scenarios as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This simple example presents the utility of higher-order functions in function
    composition and subsequently in program modularity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen an example of higher-order functions that
    could accept two different functions and execute them in a predefined order. This
    function was not so flexible in the sense that it would break if we wanted to
    combine two accepted functions differently. Function composition can solve this
    issue and make it even more flexible. To present this concept, we will examine
    an example of non-functional composition first, and then we will be introduced
    to functional composition.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, in our application, we need to interact with a backend RESTful
    API and receive a `String` value that contains a list of prices in order. The
    backend RESTful API is being developed by a third-party and is not designed properly.
    Unfortunately, it returns a `String` with numbers in it separated by commas:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to format the content that we are receiving before using it. We will
    extract elements from `String` and create an array, and then we will append `$`
    as currency to each item to use it in a tableview. The following code example
    presents an approach to this problem:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code example, we treated each function individually. We could use the
    result of the first function as an input parameter for the second function. Either
    approach is verbose and not functional. Additionally, we use the `map` function,
    which is a higher-order function, but our approach is still not functional.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Let's approach this problem in a functional way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to identify function types for each function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`extractElements`: `String -> [String]`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formatWithCurrency`: `[String] -> [String]`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we pipe these functions, we will get the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can combine these functions with a functional composition and the composed
    function will be of the `String -> [String]` type. The following example shows
    the composition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, we define `composedFunction`, which is composed of two other
    functions. We are able to compose functions like this as each function has at
    least one parameter and return value. This composition is like the mathematical
    composition of functions. Suppose that we have a function `f(x)` that returns
    `y` and a `g(y)` function that returns `z`. We can compose the `g` function as
    `g(f(x)) -> z`. This composition makes our `g` function take `x` as a parameter
    and return `z` as a result. This is exactly what we have done in our `composedFunction`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Custom operators
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `composedFunction` is less verbose than the non-functional version,
    it does not look great. Also, it is not easy to read as we need to read it inside
    out. Let's make this function simpler and more readable. One solution will be
    to define a custom operator that will be used instead of our composed function.
    In the following sections, we will examine what are the standard operators that
    are allowed to define a custom operator. We will also explore the custom operator
    definition technique. It is important to learn this concept as we will be using
    it in the rest of the book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Allowed operators
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swift standard library provides a number of operators that can be used to
    define custom operators. Custom operators can begin with one of the ASCII characters—`/`,
    `=`, `-`, `+`, `!`, `*`, `%`, `<`, `>`, `&`, `|`, `^`, `?`, or `~` or one of the
    Unicode characters. After the first character, combining Unicode characters is
    allowed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We can also define custom operators that begin with a dot. If an operator does
    not start with a dot, it cannot contain a dot elsewhere. Although we can define
    custom operators that contain a question mark `?`, they cannot consist of a single
    question mark character only. Additionally, although operators can contain an
    exclamation point `!`, postfix operators cannot begin with either a question mark
    or exclamation point.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Custom operator definition
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define custom operators using the following syntax:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, `operatorType` can be one of the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: prefix
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: infix
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: postfix
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom infix operators can also specify a precedence and an associativity:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The possible values for associativity are `left`, `right`, and `none`. Left-associative
    operators associate to the left if written next to other left-associative operators
    of the same precedence. Similarly, right-associative operators associate to the
    right if written next to other right-associative operators of the same precedence.
    Non-associative operators cannot be written next to other operators with the same
    precedence.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The associativity value defaults to `none` if it is not specified. The precedence
    value defaults to `100` if it is not specified.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Any custom operator defined with the preceding syntax will not have an existing
    meaning in Swift; therefore, a function with `operatorName` as its name should
    be defined and implemented. In the following section, we will examine an example
    of custom operator definition with its respective function definition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: A composed function with a custom operator
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a new custom operator to use instead of our composed function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we have defined a new operator, `|>`, that takes two generic
    functions and combines them, returning a function that has the first function's
    input as the parameter and the second function's return as the return type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: As this new operator is going to combine two functions and is binary, we defined
    it as infix. Then we need to use the operator keyword. The next step will be to
    choose the notation for our new custom operator. As we will group functions to
    the left, we need to specify it as **associativity left**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use this operator, we need to define a corresponding function.
    Our function takes two functions as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`f`: This function takes a generic type of `T` and returns a generic type of
    `V`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: This function takes a generic type of `V` and returns a generic type of
    `V`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we had the following functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`extractElements`: `String -> [String]`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formatWithCurrency`: `[String] -> [String]`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So `T` becomes `String` and `V` becomes `[String]`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Our `|>` function returns a function that takes a generic type of `T` and returns
    a generic type of `V`. We need to receive `String -> [String]` from the composed
    function so, again, `T` becomes `String` and `V` becomes `[String]`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Using our `|>` custom operator makes our code more readable and less verbose.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures are functions without the `func` keyword. Closures are self-contained
    blocks of code that provide a specific functionality and can be stored, passed
    around, and used in the code like functions. Closures capture the constant and
    variables of the context in which they are defined. Although closures are equivalent
    of blocks in Objective-C, they have a simpler syntax in Swift compared to the
    C and Objective-C block syntax. Nested functions, which we have covered in a previous
    section, are special cases of closures. Closures are reference types that can
    be stored as variables, constants, and type aliases. They can be passed to and
    returned from functions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Closure syntax
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A general closure syntax is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A closure definition starts with `{`, then we define the closure type, and finally
    we use the `in` keyword to separate the closure definition from its implementation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: After the `in` keyword, we write the body of the closure and finish our closure
    by closing `}`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures can be used to define variables. The following closure defines a variable
    of a type closure that accepts `Int` and returns `Int`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Closures can be stored as optional variables. The following closure defines
    a variable of a type closure that accepts `Int` and returns `Optional Int`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Closures can be defined as `typealiases`. The following example presents `typealias`
    of a closure that has two `Int` parameters and returns`Int`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The same `typealias` could be used for a function type definition as functions
    are named closures in Swift.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures can be used as an argument to a function call. For instance, the following
    example presents a function that is called with a closure that receives `Int`
    and returns `Int`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Closures can be used as function parameters. The following example shows an
    array sort method that receives a closure:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This syntax can be simplified with implied types as the Swift compiler has
    the ability to infer the types for parameters from the context:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The syntax can be further simplified with implied return types using the Swift
    type inference:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Swift enables us to eliminate the open and close parentheses if we need to
    pass the closure as the last parameter of a function, in other words, if our closure
    is a trailing closure:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, Swift provides a shorthand argument notation that can be used instead
    of using arguments:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can simplify this syntax even further by eliminating the `return` keyword
    as we have only one line of expression as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using the Swift type inference, we were able to simplify the closure syntax
    drastically.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Capturing values
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures can capture variables and constants from the surrounding context in
    which they are created. Closures can refer to these variables and modify them
    within their body, even if the original scope that defined variables no longer
    exists.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: A closure is said to escape a function when the closure is passed as an argument
    to the function but is called after the function returns. One way that a closure
    can escape is by being stored in a variable that is defined outside the function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of escaping closures, in other words, completion
    handlers:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have a function named `sendRequest` that have two parameters—`responseType`
    of the `String.Type` type and `completion` which is type of closure that takes
    a `String`, and an optional `NSError` parameters and does not return any value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we execute some asynchronous time-consuming operations in the body
    of the function, such as reading from a file, reading from a database, or calling
    a web service.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: To call this function, we provide `String.self` and a closure as arguments.
    Our closure has two variables in it—a variable named `response` of the `Optional
    String` type and an error variable of the `NSError` optional type. As our function
    does not have any return type, it does not return any value to its caller. Here
    comes the concept of escaping a function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，我们需要提供`String.self`和一个闭包作为参数。我们的闭包中有两个变量——一个名为`response`的`Optional String`类型的变量和一个名为`error`的`NSError`可选类型的变量。由于我们的函数没有返回类型，它不会向其调用者返回任何值。这就是函数逃逸的概念。
- en: 'Our passed closure escapes our function as it will be called after our time-consuming
    asynchronous operation finishes with success and the following call happens:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的闭包在函数外部逃逸，因为它将在耗时的异步操作成功完成后被调用，并且随后发生调用：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this call, we pass the `responseData` and error and call back the completion
    closure. Then the body of closure in the caller function is executed with passed
    variables. This concept is a very powerful concept that eases all asynchronous
    operations. It is very readable and easy to follow compared with mechanisms such
    as delegation and notification.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用中，我们传递`responseData`和错误，并调用完成闭包。然后调用函数的闭包体使用传递的变量执行。这个概念是一个非常强大的概念，它简化了所有的异步操作。与委托和通知等机制相比，它非常易于阅读和跟踪。
- en: Function currying
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: 'Function currying translates a single function with multiple arguments into
    a series of functions each with one argument. Let''s examine an example. Suppose
    that we have a function that combines `firstName` and `lastName` to return the
    full name:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数柯里化将具有多个参数的单个函数转换为一系列具有一个参数的函数。让我们看看一个例子。假设我们有一个将`firstName`和`lastName`组合起来返回全名的函数：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This function can be translated into a curried function as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以转换为以下柯里化函数：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As seen from this example, we replace the comma with `) (` parentheses.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，我们可以看到我们将逗号替换为`) (`括号。
- en: 'So now we can use this function as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在我们可以使用此函数如下：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, `fnIncludingFirstName` will have `firstName` in it so that, when we use
    it, we can provide `lastName` and extract the full name. We will use this technique
    in upcoming chapters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fnIncludingFirstName`将包含`firstName`，这样当我们使用它时，我们可以提供`lastName`并提取全名。我们将在接下来的章节中使用这种技术。
- en: 'Starting with Swift 2.2, Apple has deprecated function currying and removed
    it from Swift 3.0\. It is proposed to convert the function currying to returning
    a closure explicitly:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift 2.2开始，Apple已经弃用了函数柯里化，并将其从Swift 3.0中移除。建议将函数柯里化转换为显式返回闭包：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s convert our curried function to return the closure version explicitly:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的柯里化函数显式地转换为返回闭包版本：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can use this function as follows and the result is going to be identical:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数如下，结果将是相同的：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Recursion
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion is the process of calling a function inside itself. The function that
    calls itself is a recursive function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是函数在其内部调用自己的过程。调用自己的函数是递归函数。
- en: Recursion is best used for problems where a large problem can be broken down
    into a repetitive subproblem. As a recursive function calls itself to solve these
    subproblems, eventually the function will come across a subproblem that it can
    handle without calling itself. This is known as a base case, and it is needed
    to prevent the function from calling itself over and over again without stopping.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 递归最适合用于可以将大问题分解为重复子问题的问题。由于递归函数会调用自己来解决这些子问题，最终函数将遇到一个它可以不调用自己就能处理的子问题。这被称为基本情况，这是防止函数不断调用自己而停止所需的。
- en: 'In the base case, the function does not call itself. However, when a function
    does have to call itself in order to deal with its subproblem, then this is known
    as a recursive case. So, there are two types of cases when using a recursive algorithm:
    base cases and recursive cases. It is important to remember that when using recursion
    and when we are trying to solve a problem, we should ask ourselves: *what is my
    base case and what is my recursive case?*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本情况中，函数不会调用自己。然而，当一个函数必须调用自己以处理其子问题时，这被称为递归情况。因此，在使用递归算法时，有两种类型的情况：基本情况递归情况。重要的是要记住，在递归和尝试解决问题时，我们应该问自己：*我的基本情况是什么，我的递归情况是什么？*
- en: 'To apply this simple process, let''s start with an example of recursion: the
    factorial function. In mathematics, an exclamation mark after a number (*n!*)
    presents the factorial of the number. A factorial of a number `n` is the product
    of all integers between `1` and `n`. So, if `n` is equal to `3`, then the factorial
    of `n` would be *3 * 2 * 1*, which equals `6`. We could also say that the factorial
    of `3` is equal to `3` multiplied by the factorial of `2`, which would be *3 *
    2!* or *3 * 2 * 1*. So, the factorial of any number `n` could also be defined
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We also need to know the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note how we defined the factorial of a number as that number multiplied by
    the factorial of the integer that is `1` less than the number *(n * (n - 1)!)*.
    So, what we have done is essentially broken the problem into a subproblem and,
    in order to find the factorial of a number, we keep finding the factorials of
    the integers below that number and multiplying. So, the factorial of `3` is equal
    to `3` multiplied by the factorial of `2` and the factorial of `2` is equal to
    `2` multiplied by the factorial of `1`. So, if we have a function to find the
    factorial of a given number, then our code for the recursive case would look something
    like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we want to find `n` number's factorial.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we divided the problem into a subproblem. There is still one
    problem that we need to solve. We need to check for the base case in order to
    be able to stop the function from calling itself infinitely.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can modify our factorial example as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As seen in this example, we check for `n`; if it is 0 or `1`, we return `1`
    and stop the recursion.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a simple recursive function is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The non-recursive version of this example is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As we can see from this example, the recursive version is more expressive and
    shorter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a function that repeats a given string for a
    desired time:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following code snippet presents the same functionality without using recursion,
    in other words, in the imperative programming style:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The non-recursive, imperative version is slightly longer and we need to use
    a `for` loop and variable to be able to achieve the same result. Some functional
    programming languages such as Haskell do not have `for` loop mechanisms and we
    have to use recursion; in Swift, we have `for` loops but as we have seen here,
    it is better to use recursive functions whenever we can.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursion is a special case of recursion where the calling function does
    no more execution after making a recursive call to itself. In other words, a function
    is named tail recursive if its final expression is a recursive call. The previous
    recursion examples that we have been introduced to were not tail recursive functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to understand tail recursion, we will develop the `factorial` function
    that we have developed before with the tail recursion technique. Then we will
    talk about the differences:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note that we provide a default argument of `1` for `currentFactorial`, but this
    only applies to the very first call of the function. When the factorial function
    is called recursively, the default argument is overridden with whatever value
    is passed by the recursive call. We need to have that second argument there because
    it will hold the current factorial value that we intend on passing to the function.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand how it works and how it is different from the other
    factorial function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this function, each time the factorial function is called, a new value for
    `currentFactorial` is passed to the function. The function basically updates `currentFactorial`
    with each call to itself. We are able to save the current factorial value as it
    accepts `currentFactorial` as a parameter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: All of the recursive calls to the factorial such as `factorial(2, 1 * 3)` do
    not actually need to return in order to get the final value. We can see that we
    actually arrive at the value of `6` before any of the recursive calls actually
    return.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a function is tail recursive if the final result of the recursive
    call—in this example, `6`—is also the final result of the function itself. The
    non-tail recursive function is not in its final state in the last function call
    because all of the recursive calls leading up to the last function call must also
    return in order to actually come up with the final result.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memoization is the process of storing the result of functions, given their input,
    in order to improve the performance of our programs. We can memoize pure functions
    as pure functions do not rely on external data and do not change anything outside
    themselves. Pure functions provide the same result for a given input every time.
    Therefore, we can save or cache the results—in other words, memoize the results—given
    their inputs and use them in the future without going through the calculation
    process.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to understand the concept, let''s look at the following example
    in which we will manually memoize the `power2` function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As we can see from the example, we define a dictionary of the `[Int, Int]` type.
    We save the result of the function given its input to this dictionary.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: This approach works properly but we need to manually modify and maintain a collection
    outside of the function to be able to memoize the results of the function. Also,
    it adds a lot of boilerplate code to each function that we need memoization for.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The advanced Swift session presented in **Worldwide Developers Conference**
    (**WWDC**) 2014 ( [https://developer.apple.com/videos/play/wwdc2014-404/](https://developer.apple.com/videos/play/wwdc2014-404/))
    provides a very convenient function for memoization that can be used with any
    pure function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Watching the video is highly recommended. Let''s see if we could automatize
    this functionality and reuse it using the `memoize` function from that session:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The function looks complex but don't worry, we will go through it in detail.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is a generic function. Do not worry about generics—we will
    cover generics in detail in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*—and `Hashable` is used
    because we need to store `T` as a key in a dictionary.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the signature of the function, we see that the `memoize` function
    takes a function (`fn`) with two parameters and a return type. So the signature
    of `fn`, which is a function, is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first parameter of `fn` is a function of the `(T) -> U` type and the second
    parameter is of the `T` type and finally `fn` returns `U`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: OK, the `memoize` function received `fn`, which is described in the preceding
    code snippet.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the `memoize` function returns a function of the `(T) -> U` type.
    Now let's look at the body of the `memoize` function. First, we need to have a
    dictionary to cache the results. Second, we need to define the result type, which
    is a closure. In the closure body, we check whether we already have the key in
    our dictionary. If we do, we return it, otherwise, we call the function and save
    the result in our memo dictionary.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use this function to memoize the results of different function calls
    and improve the performance of our programs.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents the memoized version of the factorial function:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `memoize` function expects a closure as input, therefore, we can use the
    trailing closure syntax. In the preceding example, we provided the factorial function
    and `x` parameters as input to the closure and the line after the `in` keyword
    is the body of the closure. In the previous example, we used memoize for a recursive
    function and it works properly. Let''s look at another example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this example, we use the `memoize` function to have a memoized version of
    the `powerOf2` function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Writing the memoize function once, we will be able to use it for any pure functions
    to cache the data and improve the performance of our programs.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by explaining function definition and usage in detail by
    giving examples for parameter and return types. Then it continued to cover functional
    programming-related concepts such as pure, first-class, higher-order, and nested
    functions. Finally, it covered function compositions, closures, currying, and
    memoization. At this point, we should be familiar with different types of functions
    and closures and their usages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will cover types and explore the concept of value
    types versus reference types. Also, we will look at value type characteristics
    in detail and cover type equality, identity, and casting.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
