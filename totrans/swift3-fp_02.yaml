- en: Chapter 2. Functions and Closures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 函数和闭包
- en: In the previous chapter, we had an overview of functional programming and the
    Swift programming language. It introduced some of the key concepts about functions.
    As functions are the fundamental building blocks in functional programming, this
    chapter dives deeper into it and explains all the aspects related to the definition
    and usage of functions in functional Swift, together with coding examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们概述了函数式编程和Swift编程语言，介绍了一些关于函数的关键概念。由于函数是函数式编程的基本构建块，本章将深入探讨它，并解释与函数式Swift中函数的定义和用法相关的所有方面，同时附上代码示例。
- en: This chapter starts with a definition of functions, continues with other related
    topics such as function types and tuples, and finally concludes with more advanced
    topics such as first-class functions, higher-order functions, function composition,
    closures, currying, recursion, and memoization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从函数的定义开始，继续讨论其他相关主题，如函数类型和元组，最后以更高级的主题结束，如首等函数、高阶函数、函数组合、闭包、柯里化和缓存。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题，并附上代码示例：
- en: The general syntax of functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的一般语法
- en: Defining and using function parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用函数参数
- en: Setting internal and external parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内部和外部参数
- en: Setting default parameter values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置默认参数值
- en: Defining and using variadic functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用可变参数函数
- en: Returning values from functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: Defining and using nested functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用嵌套函数
- en: Function types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Pure functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: First-class functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首等函数
- en: Higher-order functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Function composition
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: The definition of a custom operator
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义运算符的定义
- en: Defining and using closures
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用闭包
- en: Function currying
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: Recursion
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Memoization
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: What is a function?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: '**Object-oriented programming** (**OOP**) looks very natural to most developers
    as it simulates a real-life situation of classes or, in other words, blueprints
    and their instances, but it brought a lot of complexities and problems such as
    instance and memory management, complex multithreading, and concurrency programming.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）对大多数开发者来说看起来非常自然，因为它模拟了现实生活中的类或换句话说，蓝图及其实例，但它带来了许多复杂性和问题，例如实例和内存管理、复杂的多线程和并发编程。'
- en: Before OOP became mainstream, we were used to developing in procedural languages.
    In the C programming language, we did not have objects and classes; we would use
    structs and function pointers. So now we are talking about functional programming
    that relies mostly on functions just as procedural languages relied on procedures.
    We are able to develop very powerful programs in C without classes; in fact, most
    operating systems are developed in C. There are other multipurpose programming
    languages such as Go by Google that is not object-oriented and is getting very
    popular because of its performance and simplicity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）成为主流之前，我们习惯于使用过程式语言进行开发。在C编程语言中，我们没有对象和类；我们会使用结构体和函数指针。因此，我们现在讨论的是主要依赖于函数的过程式编程，就像过程式语言依赖于过程一样。我们能够在C语言中不使用类就开发出非常强大的程序；事实上，大多数操作系统都是用C语言开发的。还有其他多用途的编程语言，例如谷歌的Go语言，它不是面向对象的，但由于其性能和简单性而变得越来越受欢迎。
- en: So, are we going to be able to write very complex applications without classes
    in Swift? We might wonder why we should do this. Generally, we should not, but
    attempting it will introduce us to the capabilities of functional programming.
    This is why we will have a whole chapter about functions before talking about
    other building blocks such as `classes`, `structs`, and `enums`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是否能够在Swift中不使用类就编写非常复杂的应用程序呢？我们可能会想知道为什么我们应该这样做。通常，我们不应该这样做，但尝试这样做将使我们了解函数式编程的能力。这就是为什么在讨论其他构建块，如`类`、`结构体`和`枚举`之前，我们将有一个关于函数的整个章节。
- en: A function is a block of code that executes a specific task, can be stored,
    can persist data, and can be passed around. We define them in standalone Swift
    files as global functions or inside other building blocks such as `classes`, `structs`,
    `enums`, and `protocols` as methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段执行特定任务的代码块，可以存储，可以持久化数据，并且可以被传递。我们将其定义在独立的Swift文件中作为全局函数，或者在其他构建块如`类`、`结构体`、`枚举`和`协议`中作为方法。
- en: They are called methods if they are defined in classes but, in terms of definition,
    there is no difference between a function and method in Swift.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们在类中定义，它们被称为方法，但在定义上，Swift中函数和方法之间没有区别。
- en: Defining them in other building blocks enables methods to use the scope of the
    parent or to be able to change it. They can access the scope of their parent and
    they have their own scope. Any variable that is defined inside a function is not
    accessible outside of it. The variables defined inside them and the corresponding
    allocated memory go away when the function terminates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他构建块中定义它们使得方法可以使用父级的范围，或者能够改变它。它们可以访问其父级的范围，并且它们有自己的范围。在函数内部定义的任何变量都不可以在函数外部访问。它们内部定义的变量以及相应的分配的内存将在函数终止时消失。
- en: Functions are very powerful in Swift. We can compose a program with only functions
    as functions can receive and return functions, capture variables that exist in
    the context they were declared, and can persist data inside themselves. To understand
    the functional programming paradigms, we need to understand the capability of
    functions in detail. We need to think if we can avoid classes and only use functions,
    so we will cover all the details related to functions in upcoming sections of
    this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在Swift中非常强大。我们可以仅使用函数来组合程序，因为函数可以接收和返回函数，捕获它们声明上下文中的变量，并且可以在内部持久化数据。为了理解函数式编程范式，我们需要详细了解函数的能力。我们需要思考是否可以避免类而只使用函数，因此我们将在本章的后续部分涵盖与函数相关的所有细节。
- en: The general syntax of functions and methods
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法的通用语法
- en: 'We can define functions or methods as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下定义函数或方法：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we know already, when functions are defined in objects, they become methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，当函数在对象中定义时，它们就变成了方法。
- en: 'The first step to define a method is to tell the compiler from where it can
    be accessed. This concept is called access control in Swift and there are three
    levels of access control. We are going to explain them for methods as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方法的第一步是告诉编译器它可以从哪里访问。这个概念在Swift中被称为访问控制，并且有三种访问控制级别。我们将如下解释方法级别的访问控制：
- en: '**Public access**: Any entity can access a method that is defined as public
    if it is in the same module. If an entity is not in the same module, we will need
    to import the module to be able to call the method. We need to mark our methods
    and objects as `public` when we develop frameworks in order to enable other modules
    to use them.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共访问**：如果实体在同一模块中，它可以访问被定义为`public`的方法。如果实体不在同一模块中，我们需要导入该模块才能调用该方法。当我们开发框架时，我们需要将我们的方法和对象标记为`public`，以便其他模块可以使用它们。'
- en: '**Internal access**: Any method that is defined as `internal` can be accessed
    from other entities in a module but cannot be accessed from other modules.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部访问**：任何被定义为`internal`的方法可以从模块中的其他实体访问，但不能从其他模块访问。'
- en: '**Private access**: Any method that is defined as `private` can be accessed
    only from the same source file.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有访问**：任何被定义为`private`的方法只能从同一源文件中访问。'
- en: By default, if we do not provide the access modifier, a variable or function
    becomes internal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们没有提供访问修饰符，变量或函数就变为内部访问。
- en: Using these access modifiers, we can structure our code properly; for instance,
    we can hide details from other modules if we define an entity as internal. We
    can even hide the details of a method from other files if we define them as private.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些访问修饰符，我们可以正确地组织我们的代码；例如，如果我们定义一个实体为内部访问，我们可以从其他模块中隐藏细节。我们甚至可以将方法的细节隐藏在其他文件中，如果我们将它们定义为私有。
- en: Before Swift 2.0, we had to define everything as public or add all source files
    to the testing target. Swift 2.0 introduced the `@testable import` syntax that
    enables us to define internal or private methods that can be accessed from testing
    modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2.0之前，我们必须将所有内容定义为公共的，或者将所有源文件添加到测试目标中。Swift 2.0引入了`@testable import`语法，使我们能够定义内部或私有方法，这些方法可以从测试模块中访问。
- en: 'Methods can generally be in three forms:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常可以以三种形式存在：
- en: '**Instance methods**: We need to obtain an instance of an object (in this book
    we will refer to `classes`, `structs`, and `enums` as objects) in order to be
    able to call the method defined in it, and then we will be able to access the
    scope and data of the object.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例方法**：我们需要获取一个对象的实例（在这本书中，我们将`classes`、`structs`和`enums`称为对象）才能调用其中定义的方法，然后我们才能访问该对象的范围和数据。'
- en: '**Static methods**: Swift names them type methods also. They do not need any
    instances of objects and they cannot access the instance data. They are called
    by putting a dot after the name of the object type (for example, `Person.sayHi()`).
    The `static` methods cannot be overridden by the subclasses of the object that
    they reside in.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态方法**：Swift也称之为类型方法。它们不需要任何对象实例，并且不能访问实例数据。它们通过在对象类型名称后放置一个点来调用（例如，`Person.sayHi()`）。`static`方法不能被它们所在的对象的子类覆盖。'
- en: '**Class methods**: Class methods are like the `static` methods but they can
    be overridden by subclasses.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类方法**：类方法类似于`static`方法，但它们可以被子类覆盖。'
- en: We have covered the keywords that are required for method definitions; now we
    will concentrate on the syntax that is shared among functions and methods. There
    are other concepts related to methods that are out of scope of this book as we
    will concentrate on functional programming in Swift.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了方法定义所需的关键字；现在我们将集中讨论函数和方法共有的语法。本书不涉及与方法相关的一些概念，因为我们将在Swift中专注于函数式编程。
- en: Continuing to cover the function definition, now comes the `func` keyword that
    is mandatory and is used to tell the compiler that it is going to deal with a
    function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论函数定义，现在出现的是强制使用的`func`关键字，它用于告诉编译器它将处理一个函数。
- en: Then comes the function name that is mandatory and is recommended to be camel-cased
    with the first letter as lowercase. The function name should be stating what the
    function does and is recommended to be in the form of a verb when we define our
    methods in objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是函数名，这也是强制性的，建议使用驼峰式命名法，首字母小写。函数名应该说明函数的功能，并且在我们定义对象的方法时，建议使用动词形式。
- en: Basically, our classes will be named nouns and methods will be verbs that are
    in the form of orders to the class. In pure functional programming, as the function
    does not reside in other objects, they can be named by their functionalities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的类将被命名为名词，方法将被命名为动词，它们是对类的命令。在纯函数式编程中，由于函数不驻留在其他对象中，它们可以按其功能命名。
- en: Parameters follow the `func` name. They will be defined in parentheses to pass
    arguments to the function. Parentheses are mandatory even if we do not have any
    parameters. We will cover all aspects of parameters in *Defining and using function
    parameters* section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参数跟在`func`名称之后。它们将在括号内定义，以向函数传递参数。即使我们没有参数，括号也是强制性的。我们将在本章的“定义和使用函数参数”部分中涵盖参数的所有方面。
- en: Then comes `throws`, which is not mandatory. A function or method that is marked
    with the `throws` keyword may or may not throw errors. We will cover error handling
    mechanisms in upcoming chapters. At this point, it is enough to know what they
    are when we see them in a function or method signature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`throws`关键字，它不是强制性的。标记了`throws`关键字的函数或方法可能会抛出错误，也可能不会。我们将在后续章节中介绍错误处理机制。目前，当我们看到函数或方法签名中的它们时，了解它们是什么就足够了。
- en: The next entity in a function type declaration is the return type. If a function
    is not void, the return type will come after the `->` sign. The return type indicates
    the type of entity that is going to be returned from a function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型声明中的下一个实体是返回类型。如果一个函数不是void类型，返回类型将位于`->`符号之后。返回类型表明了函数将要返回的实体类型。
- en: We will cover return types in detail in *Returning values from functions* section
    of this chapter, so now we can move on to the last piece of function that is present
    in most programming languages, our beloved `{ }`. We defined functions as blocks
    of functionality and `{ }` defines the borders of the block so that the function
    body is declared and execution happens in there. We will write the functionality
    inside `{ }`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“从函数返回值”部分详细讨论返回类型，因此现在我们可以继续讨论大多数编程语言中普遍存在的函数的最后一部分，那就是我们喜爱的`{ }`。我们将函数定义为功能块，而`{
    }`定义了块的边界，以便函数体在这里声明并执行。我们将在`{ }`内编写功能。
- en: Best practices in function definition
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数定义的最佳实践
- en: 'There are proven best practices for function and method definition provided
    by amazing software engineering resources, such as *Clean Code: A Handbook of
    Agile Software Craftsmanship*, by *Robert C. Martin*, *Code Complete: A Practical
    Handbook of Software Construction, Second Edition*, by *Steve McConnell*, and
    Coding Horror ([https://blog.codinghorror.com/code-smells/](https://blog.codinghorror.com/code-smells/)),
    that we can summarize as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '有一些经过验证的最佳实践是由出色的软件工程资源提供的，例如 *Clean Code: A Handbook of Agile Software Craftsmanship*，由
    *Robert C. Martin* 编著，*Code Complete: A Practical Handbook of Software Construction,
    Second Edition*，由 *Steve McConnell* 编著，以及 Coding Horror ([https://blog.codinghorror.com/code-smells/](https://blog.codinghorror.com/code-smells/))，我们可以总结如下：'
- en: Try not to exceed 8-10 lines of code in each function as shorter functions or
    methods are easier to read, understand, and maintain.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要让每个函数的代码行数超过 8-10 行，因为较短的函数或方法更容易阅读、理解和维护。
- en: Keep the number of parameters minimal because the more parameters a function
    has, the more complex it is.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量保持参数数量最小，因为一个函数拥有的参数越多，它就越复杂。
- en: Functions should have at least one parameter and one return value.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数至少应该有一个参数和一个返回值。
- en: Avoid using type names in function names as it is going to be redundant.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在函数名称中使用类型名称，因为这将是多余的。
- en: Aim for one and only one functionality in a function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力求函数只实现一个功能。
- en: Name a function or method in a way that describes its functionality properly
    and is easy to understand.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给函数或方法命名时，要确保它能正确描述其功能且易于理解。
- en: Name functions and methods consistently. If we have a connect function, we can
    have a disconnect one.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致地命名函数和方法。如果我们有一个连接函数，我们可以有一个断开连接的函数。
- en: Write functions to solve the current problem and generalize it when needed.
    Try to avoid what-if scenarios as probably **you aren't gonna need it** (**YAGNI**).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数来解决当前问题，并在需要时进行泛化。尽量避免假设场景，因为可能**你不会用到它**（YAGNI）。
- en: Calling functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'We have covered a general syntax to define a function and method if it resides
    in an object. Now it is time to talk about how we call our defined functions and
    methods. To call a function, we will use its name and provide its required parameters.
    There are complexities with providing parameters that we will cover in upcoming
    section. For now, we are going to cover the most basic type of parameter, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数定义在对象中，我们已经介绍了一种通用的语法来定义函数和方法。现在，我们来谈谈如何调用我们定义的函数和方法。要调用一个函数，我们将使用其名称并提供其所需的参数。在提供参数时存在一些复杂性，我们将在下一节中介绍。现在，我们将介绍最基本的参数类型，如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This type of function calling should be familiar to Objective-C developers as
    the first parameter name is not named and the rest are named.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的函数调用应该对 Objective-C 开发者来说很熟悉，因为第一个参数名称未命名，其余的都命名了。
- en: 'To call a method, we need to use the dot notation provided by Swift. The following
    examples are for class instance methods and static class methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用方法，我们需要使用 Swift 提供的点符号。以下示例适用于类实例方法和静态类方法：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Defining and using function parameters
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用函数参数
- en: In function definition, parameters follow the function name and they are constants
    by default so we will not able to alter them inside the function body if we do
    not mark them with `var`. In functional programming, we avoid mutability; therefore,
    we would never use mutable parameters in functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，参数跟在函数名称后面，并且默认情况下是常量，因此如果我们不使用 `var` 标记它们，我们无法在函数体内部修改它们。在函数式编程中，我们避免可变性；因此，我们永远不会在函数中使用可变参数。
- en: 'Parameters should be inside parentheses. If we do not have any parameters,
    we simply put open and close parentheses without any characters between them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 参数应放在括号内。如果我们没有任何参数，我们只需简单地放置一对括号，中间不包含任何字符：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In functional programming, it is important to have functions that have at least
    one parameter. We will explain why it is important in upcoming sections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，拥有至少一个参数的函数非常重要。我们将在接下来的章节中解释为什么它很重要。
- en: 'We can have multiple parameters separated by commas. In Swift, parameters are
    named so we need to provide the parameter name and type after putting a colon,
    as shown in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有多个参数，用逗号分隔。在 Swift 中，参数是有名的，因此我们需要在冒号后提供参数名称和类型，如下例所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ParameterType` can also be an optional type so the function becomes the following
    if our parameters need to be optionals:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParameterType` 也可以是一个可选类型，因此如果我们的参数需要是可选的，函数将变为以下形式：'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Swift enables us to provide external parameter names that will be used when
    functions are called. The following example presents the syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许我们提供外部参数名称，这些名称将在调用函数时使用。以下示例展示了语法：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Only the local parameter name is usable in the function body.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中只能使用局部参数名称。
- en: It is possible to omit parameter names with the `_` syntax; for instance, if
    we do not want to provide any parameter name when the function is called, we can
    use `_` as `externalParamName` for the second or subsequent parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `_` 语法可以省略参数名称；例如，如果我们不想在调用函数时提供任何参数名称，我们可以使用 `_` 作为 `externalParamName`
    来表示第二个或后续参数。
- en: If we want to have a parameter name for the first parameter name in function
    calls, we can basically provide the local parameter name as external also. In
    this book, we are going to use the default function parameter definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在函数调用中为第一个参数提供参数名称，我们基本上也可以将局部参数名称作为外部参数提供。在这本书中，我们将使用默认的函数参数定义。
- en: 'Parameters can have default values as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以有默认值，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Parameters can be defined as `inout` to enable function callers obtaining parameters
    that are going to be changed in the body of a function. As we can use tuples for
    function returns, it is not recommended to use `inout` parameters unless we really
    need them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以被定义为 `inout` 以允许函数调用者获取在函数体中将要被改变的参数。由于我们可以使用元组作为函数的返回值，除非我们确实需要它们，否则不建议使用
    `inout` 参数。
- en: 'We can define function parameters as tuples. For instance, the following example
    function accepts a tuple of the `(Int, Int)` type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将函数参数定义为元组。例如，以下示例函数接受一个 `(Int, Int)` 类型的元组：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As, under the hood, variables are represented by tuples in Swift, the parameters
    to a function can also be tuples. For instance, let''s have a simple `convert`
    function that takes an array of `Int` and a multiplier and converts it to a different
    structure. Let''s not worry about the implementation of this function for now;
    we will have [Chapter 6](ch06.html "Chapter 6. Map, Filter, and Reduce"), *Map,
    Filter, and Reduce* that will cover the map function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，变量在底层是以元组的形式表示的，因此函数的参数也可以是元组。例如，让我们有一个简单的 `convert` 函数，它接受一个 `Int`
    类型的数组和乘数，并将其转换为不同的结构。现在我们不必担心这个函数的实现；我们将在 [第 6 章](ch06.html "第 6 章。Map、Filter
    和 Reduce") 中介绍 map 函数：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we use this function as `let resultOfConversion = convert(numbers: numbers,
    multiplier: 3)`, the result is going to be `["0: 9", "1: 15", "2: 27", "3: 30"]`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们将此函数用作 `let resultOfConversion = convert(numbers: numbers, multiplier:
    3)`，结果将是 `["0: 9", "1: 15", "2: 27", "3: 30"]`。'
- en: 'We can call our function with a tuple. Let''s create a tuple and pass it to
    our function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用元组来调用我们的函数。让我们创建一个元组并将其传递给我们的函数：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result is identical to our previous function call. However, passing tuples
    in function calls is removed from Swift 3.0, so it is not recommended to use them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前的函数调用相同。然而，从 Swift 3.0 开始，函数调用中传递元组已被移除，因此不建议使用它们。
- en: 'We can define higher-order functions that can receive functions as parameters.
    In the following example, we define `funcParam` as a function type of `(Int, Int)
    -> Int`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义高阶函数，这些函数可以接收函数作为参数。在以下示例中，我们将 `funcParam` 定义为 `(Int, Int) -> Int` 类型的函数类型：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Swift, parameters can be of a generic type. The following example presents
    a function that has two generic parameters. In this syntax, any type (for example,
    `T` or `V`) that we put inside `<>` should be used in parameter definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，参数可以是泛型类型。以下示例展示了一个具有两个泛型参数的函数。在这个语法中，我们可以在 `<>` 内放置任何类型（例如，`T` 或
    `V`），这些类型应该用于参数定义：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will cover generics in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*; at this point, knowing
    the syntax should be enough.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 5 章](ch05.html "第 5 章。泛型和关联类型协议") 中介绍泛型；到目前为止，了解语法就足够了。
- en: Defining and using variadic functions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用可变函数
- en: Swift enables us to define functions with variadic parameters. A variadic parameter
    accepts zero or more values of a specified type. Variadic parameters are similar
    to array parameters but they are more readable and can only be used as the last
    parameter in multiparameter functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许我们定义具有可变参数的函数。可变参数可以接受零个或多个指定类型的值。可变参数类似于数组参数，但它们更易于阅读，并且只能作为多参数函数中的最后一个参数使用。
- en: As variadic parameters can accept zero values, we will need to check whether
    they are empty.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可变参数可以接受零值，我们需要检查它们是否为空。
- en: 'The following example presents a function with variadic parameters of the `String`
    type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个具有可变参数的`String`类型的函数：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Returning values from functions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数中返回值
- en: 'If we need our function to return a value, tuple, or another function, we can
    specify it by providing `ReturnType` after `->`. For instance, the following example
    returns `String`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要我们的函数返回一个值、元组或另一个函数，我们可以在`->`之后提供`ReturnType`来指定它。例如，以下示例返回`String`：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any function that has `ReturnType` in its definition should have a `return`
    keyword with the matching type in its body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在其定义中包含`ReturnType`的函数，其体中都应该有一个与匹配类型的`return`关键字。
- en: 'Return types can be optionals in Swift so the function becomes as follows if
    the return needs to be optional:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，返回类型可以是可选的，因此如果需要返回值是可选的，函数可以如下所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Tuples can be used to provide multiple return values. For instance, the following
    function returns a tuple of the `(Int, String)` type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以用来提供多个返回值。例如，以下函数返回一个`(Int, String)`类型的元组：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we are using parentheses for tuples, we should avoid using parentheses for
    single return value functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用括号表示元组，因此应避免在单返回值函数中使用括号。
- en: 'Tuple return types can be optional too so the syntax becomes as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 元组返回类型也可以是可选的，因此语法如下：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This syntax makes the entire tuple optional; if we want to make only `status`
    optional, we can define the function as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法使得整个元组都是可选的；如果我们只想使`status`可选，我们可以将函数定义为如下：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Swift, functions can return functions. The following example presents a
    function with the return type of a function that takes two `Int` values and returns
    an `Int` value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，函数可以返回函数。以下示例展示了一个返回类型为函数的函数，该函数接受两个`Int`值并返回一个`Int`值：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we do not expect a function to return any value, tuple, or function, we
    simply do not provide `ReturnType`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预期一个函数不返回任何值、元组或函数，我们只需不提供`ReturnType`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could also explicitly declare it with the `Void` keyword:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`Void`关键字显式声明它：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In functional programming, it is important to have return types in functions.
    In other words, it is a good practice to avoid functions that have `Void` as return
    type. A function with the `Void` return type typically is a function that changes
    another entity in the code; otherwise, why would we need to have a function? OK,
    we might have wanted to log an expression to the console/log file or write data
    to a database or a file to a filesystem. In these cases, it is also preferable
    to have a return or feedback related to the success of the operation. As we try
    to avoid mutability and stateful programming in functional programming, we can
    assume that our functions will have returns in different forms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数中具有返回类型非常重要。换句话说，避免具有`Void`作为返回类型的函数是一种良好的实践。具有`Void`返回类型的函数通常是一个会改变代码中另一个实体的函数；否则，我们为什么需要函数呢？好吧，我们可能想要将表达式记录到控制台/日志文件中，或将数据写入数据库或文件系统中的文件。在这些情况下，最好也有关于操作成功与否的返回或反馈。随着我们试图在函数式编程中避免可变性和有状态编程，我们可以假设我们的函数将以不同的形式返回。
- en: 'This requirement is in line with mathematical underlying bases of functional
    programming. In mathematics, a simple function is defined as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求与函数式编程的数学基础相一致。在数学中，一个简单的函数定义如下：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `f` is a function that takes `x` and returns `y`. Therefore, a function
    receives at least one parameter and returns at least a value. In functional programming,
    following the same paradigm makes reasoning easier, function composition possible,
    and code more readable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`f`是一个接受`x`并返回`y`的函数。因此，一个函数至少接收一个参数并返回至少一个值。在函数式编程中，遵循相同的范式可以使推理更容易，函数组合成为可能，代码更易于阅读。
- en: Pure functions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: Pure functions are functions that do not possess any side effects; in other
    words, they do not change or alter any data or state outside of themselves. Additionally,
    they do not access any data or state except their provided parameters. Pure functions
    are like mathematical functions that are pure by nature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是没有任何副作用的功能；换句话说，它们不会改变或修改自身之外的数据或状态。此外，它们不访问任何数据或状态，除了提供的参数。纯函数就像数学函数，它们本质上是纯的。
- en: Pure functions return a value that is only determined by its parameter values.
    Pure functions are easy to test as they rely only on their parameters and do not
    change or access any data or state outside of themselves. Pure functions are suitable
    for concurrency as they do not access and change global data or states.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数返回的值仅由其参数值决定。纯函数易于测试，因为它们只依赖于它们的参数，并且不改变或访问任何自身之外的数据或状态。纯函数适合并发，因为它们不访问和改变全局数据或状态。
- en: 'The following list presents examples of pure and not pure functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了纯函数和非纯函数的示例：
- en: Printing a String literal to a console is not pure as it modifies an external
    state.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串字面量打印到控制台不是纯函数，因为它修改了外部状态。
- en: Reading a file is not pure as it depends on the external state at different
    times.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件不是纯函数，因为它依赖于不同时间的外部状态。
- en: Length of a String is pure as it does not rely on a state. It only takes a String
    as input and returns the length as output.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的长度是纯函数，因为它不依赖于状态。它只接受一个字符串作为输入，并返回长度作为输出。
- en: Getting the current date is not pure as it returns different values when called
    at different dates.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前日期不是纯函数，因为它在不同的日期调用时返回不同的值。
- en: Getting a random number is not pure as it returns different values each time
    it is called.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取随机数不是纯函数，因为它每次调用时都返回不同的值。
- en: Using pure functions may sound very restrictive and impossible to utilize in
    real-world scenarios, but there are other tools that can provide the same functionality,
    which we will discuss later in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数可能听起来非常限制性，在现实场景中似乎无法利用，但本书后面将讨论其他可以提供相同功能的工具。
- en: We will see the benefits of pure functions in more detail in the next chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地了解纯函数的好处。
- en: Function types
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'A function parameter type along with its return type defines the type of the
    function. For instance, the function type for the following coding example is
    `(Int, Double) -> String`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数类型及其返回类型定义了函数的类型。例如，以下代码示例的函数类型是`(Int, Double) -> String`：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will be able to use function types in the way we use other types. The following
    code example presents a function type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够以使用其他类型的方式使用函数类型。以下代码示例展示了函数类型：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `simpleMathOperator` is a variable of a function of the `(Double, Double)
    -> Double` type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`simpleMathOperator`是一个`(Double, Double) -> Double`类型的函数变量。
- en: 'We could define `typealias` for the function type as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下定义函数类型的`typealias`：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use this `typealias` in the `simpleMathOperator` definition as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`simpleMathOperator`定义中使用此`typealias`如下：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can define functions with the same type and assign them to our `simpleMathOperator`.
    The type of functions in the following code snippet is `(Double, Double) -> Double`,
    which is in fact `SimpleOperator`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义具有相同类型的函数并将它们分配给我们的`simpleMathOperator`。以下代码片段中的函数类型是`(Double, Double)
    -> Double`，这实际上是`SimpleOperator`：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Therefore, we are able to assign these functions to `simpleMathOperator` as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将这些函数分配给`simpleMathOperator`，如下所示：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means that `simpleMathOperator` refers to the `multiplyTwoNumbers` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`simpleMathOperator`指向`multiplyTwoNumbers`函数：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As the other three functions also have the same function type, we will be able
    to assign them to the same variable:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其他三个函数也有相同的函数类型，我们将能够将它们分配给相同的变量：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use `SimpleOperator` as a parameter type of other functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`SimpleOperator`用作其他函数的参数类型：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the `calculateResult` function has three parameters. The `mathOperator`
    parameter is a type of function type. The `a` and `b` parameters are `Double`.
    When we call this function, we pass a `simpleMathOperator` function and two `Double`
    values for `a` and `b`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`calculateResult`函数有三个参数。`mathOperator`参数是函数类型。`a`和`b`参数是`Double`类型。当我们调用这个函数时，我们传递一个`simpleMathOperator`函数和两个`Double`值作为`a`和`b`。
- en: It is important to know that we pass only a reference to `simpleMathOperator`
    and this is not going to execute it. In the function body, we use this function
    and call it with `a` and `b`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道我们只传递了`simpleMathOperator`的引用，这不会执行它。在函数体中，我们使用这个函数，并用`a`和`b`调用它。
- en: 'We can use `SimpleOperator` as a return type of a function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`SimpleOperator`用作函数的返回类型：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `choosePlusMinus` function has a `Bool` parameter; in its body, it
    checks for this parameter and returns `addTwoNumbers` or `subtractTwoNumbers`
    that have the same type, `SimpleOperator`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`choosePlusMinus`函数有一个`Bool`参数；在其主体中，它检查此参数并返回具有相同类型`SimpleOperator`的`addTwoNumbers`或`subtractTwoNumbers`。
- en: 'It is important to understand that calling `choosePlusMinus(true)` does not
    execute the returned function and in fact only returns the reference to `addTwoNumbers`.
    We save this reference in `chosenOperator`. The `chosenOperator` variable becomes
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，调用`choosePlusMinus(true)`不会执行返回的函数，实际上只是返回了`addTwoNumbers`的引用。我们将这个引用保存在`chosenOperator`中。`chosenOperator`变量变成了以下：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we call `chosenOperator(3.5, 5.5)`, we pass these two numbers to the `addTwoNumbers`
    function and execute it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`chosenOperator(3.5, 5.5)`时，我们将这两个数字传递给`addTwoNumbers`函数并执行它。
- en: The capability to define function types makes functions first-class citizens
    in Swift. Function types are used for first-class and higher-order functions.
    These capabilities empower us to apply functional programming paradigms in Swift.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数类型的能力使得函数在Swift中成为一等公民。函数类型用于一等和更高阶函数。这些能力使我们能够在Swift中应用函数式编程范式。
- en: Defining and using nested functions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用嵌套函数
- en: 'In Swift, it is possible to define functions inside other functions. In other
    words, we can nest functions inside other functions. Nested functions are only
    accessible inside their enclosing functions and are hidden from the outside world
    by default. The enclosing function can return the nested function in order to
    allow the nested function to be used in other scopes. The following example presents
    a function that contains two nested functions and returns one of them according
    to the value of its `isPlus` parameter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，我们可以在其他函数内部定义函数。换句话说，我们可以在其他函数内部嵌套函数。嵌套函数只能在它们的封装函数内部访问，并且默认情况下对外界隐藏。封装函数可以返回嵌套函数，以便允许嵌套函数在其他作用域中使用。以下示例展示了一个包含两个嵌套函数的函数，并根据其`isPlus`参数的值返回其中一个：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First-class functions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等函数
- en: 'In the *Function types* section of this chapter, we have seen that we can define
    function types and store and pass functions around. In practice, this means that
    Swift treats functions as values. To explain this, we will need to examine a couple
    of examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的“函数类型”部分，我们看到了我们可以定义函数类型并存储和传递函数。在实践中，这意味着Swift将函数视为值。为了解释这一点，我们需要检查几个示例：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code example, we create a constant of the `String` type and `name` and
    store a value (`"Your name"`) in it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们创建了一个`String`类型的常量`name`，并将其中的值（`"Your name"”）存储在其中。
- en: 'When we define a function, we need to specify the type of parameters:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们需要指定参数的类型：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, our `name` parameter is of the `String` type. This parameter
    could be any other value type or reference type. Simply, it could be `Int`, `Double`,
    `Dictionary`, `Array`, `Set`, or it could be an object type such as an instance
    of `class`, `struct`, or `enum`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的`name`参数是`String`类型。这个参数可以是任何其他值类型或引用类型。简单来说，它可以是`Int`、`Double`、`Dictionary`、`Array`、`Set`，或者它可以是`class`、`struct`或`enum`等对象类型。
- en: 'Now, let''s call this function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用这个函数：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we pass a value for this parameter. In other words, we pass one of the
    previously mentioned types with their respective values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们为这个参数传递了一个值。换句话说，我们传递了之前提到的类型及其相应的值。
- en: 'Swift treats functions like the other aforementioned types so we can store
    a function in a variable as we were able to with other types:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Swift将函数视为上述其他类型，因此我们可以像其他类型一样将函数存储在变量中：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we saved the `sayHello` function in a variable that can be
    used later on and passed around as a value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`sayHello`函数保存在一个变量中，稍后可以使用，并将其作为值传递。
- en: In pure OOP, we do not have functions; instead, we have methods. In other words,
    functions can only reside in objects and then they are called methods. In OOP,
    classes are first-class citizens and methods are not. Methods are not solely reachable
    and cannot be stored or passed around. In OOP, methods access the object's data
    that they are defined in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯面向对象编程（OOP）中，我们没有函数；相反，我们有方法。换句话说，函数只能存在于对象中，然后它们被称为方法。在OOP中，类是一等公民，而方法不是。方法不是唯一可访问的，也不能被存储或传递。在OOP中，方法访问它们定义在其中的对象的数据。
- en: In functional programming, functions are first-class citizens. Just like other
    types, they can be stored and passed around. In contrast to OOP, that method could
    only access their parent object's data and change it; in functional programming,
    they can be stored and passed to other objects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数是一等公民。就像其他类型一样，它们可以被存储和传递。与OOP不同，那种方法只能访问其父对象的数据并更改它；在函数式编程中，它们可以被存储并传递给其他对象。
- en: This notion enables us to compose our applications with functions as they are
    just another type that can be used. We will talk about this in more detail; for
    now, it is important to understand why we call functions as first-class citizens
    in Swift.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念使我们能够以函数作为另一种类型来组合我们的应用程序。我们将更详细地讨论这个问题；现在，重要的是要理解为什么我们在Swift中将函数称为一等公民。
- en: Higher-order functions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: As we have seen in the *Defining and using function parameters* and *Function
    types* sections of this chapter, functions can accept functions as parameters
    in Swift. Functions that can accept other functions as parameters are called higher-order
    functions. This concept along with first-class functions empower functional programming
    and function decomposition.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的*定义和使用函数参数*和*函数类型*部分所看到的，在Swift中，函数可以接受函数作为参数。可以接受其他函数作为参数的函数称为高阶函数。这个概念与一等函数一起赋予了函数式编程和函数分解能力。
- en: As this topic is essential in functional programming, we will go through another
    simple example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个主题在函数式编程中至关重要，我们将通过另一个简单的例子来探讨。
- en: 'Suppose that we need to develop two functions that add and subtract two `Int`
    values as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要开发两个函数，将两个`Int`值相加和相减，如下所示：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, we need to develop functions to calculate the square and triple of two
    `Int` values as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要开发函数来计算两个`Int`值的平方和立方，如下所示：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Suppose we need another function that subtracts the squared two values:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要另一个函数，该函数从两个平方值中减去：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Suppose we need to add two squared values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要添加两个平方值：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s say that we need another function that triples a value and adds it to
    another tripled value:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要另一个函数，该函数将一个值乘以三并加到另一个乘以三的值上：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This way, we had to write a lot of redundant and inflexible functions. Using
    higher-order functions, we could write a flexible function as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们不得不编写很多冗余和不灵活的函数。使用高阶函数，我们可以编写一个灵活的函数，如下所示：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This higher-order function takes two other functions as parameters and uses
    them. We can call it for different scenarios as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数接受两个其他函数作为参数并使用它们。我们可以根据不同的场景调用它，如下所示：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This simple example presents the utility of higher-order functions in function
    composition and subsequently in program modularity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了高阶函数在函数组合和程序模块化中的实用性。
- en: Function composition
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: In the previous section, we have seen an example of higher-order functions that
    could accept two different functions and execute them in a predefined order. This
    function was not so flexible in the sense that it would break if we wanted to
    combine two accepted functions differently. Function composition can solve this
    issue and make it even more flexible. To present this concept, we will examine
    an example of non-functional composition first, and then we will be introduced
    to functional composition.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个可以接受两个不同函数并按预定义顺序执行它们的高阶函数的例子。这个函数在灵活性方面并不强，如果我们想以不同的方式组合这两个接受的函数，它就会崩溃。函数组合可以解决这个问题，并使其更加灵活。为了展示这个概念，我们首先将检查一个非函数组合的例子，然后我们将介绍函数组合。
- en: 'Suppose that, in our application, we need to interact with a backend RESTful
    API and receive a `String` value that contains a list of prices in order. The
    backend RESTful API is being developed by a third-party and is not designed properly.
    Unfortunately, it returns a `String` with numbers in it separated by commas:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的应用中，我们需要与一个后端RESTful API进行交互，并接收一个包含按顺序排列的价格列表的`String`值。这个后端RESTful API是由第三方开发的，并且设计得并不完善。不幸的是，它返回的`String`中包含用逗号分隔的数字：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to format the content that we are receiving before using it. We will
    extract elements from `String` and create an array, and then we will append `$`
    as currency to each item to use it in a tableview. The following code example
    presents an approach to this problem:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们需要格式化我们接收到的内容。我们将从`String`中提取元素并创建一个数组，然后我们将为每个项目添加`$`作为货币符号，以便在表格视图中使用。以下代码示例展示了解决这个问题的一种方法：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code example, we treated each function individually. We could use the
    result of the first function as an input parameter for the second function. Either
    approach is verbose and not functional. Additionally, we use the `map` function,
    which is a higher-order function, but our approach is still not functional.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们单独处理每个函数。我们可以将第一个函数的结果作为第二个函数的输入参数。两种方法都很冗长，并且不具有函数式风格。此外，我们使用了`map`函数，这是一个高阶函数，但我们的方法仍然不是函数式的。
- en: Let's approach this problem in a functional way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以函数式的方式解决这个问题。
- en: 'The first step will be to identify function types for each function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是识别每个函数的函数类型：
- en: '`extractElements`: `String -> [String]`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extractElements`: `String -> [String]`'
- en: '`formatWithCurrency`: `[String] -> [String]`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formatWithCurrency`: `[String] -> [String]`'
- en: 'If we pipe these functions, we will get the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些函数连接起来，我们将得到以下结果：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can combine these functions with a functional composition and the composed
    function will be of the `String -> [String]` type. The following example shows
    the composition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些函数与函数组合结合，组合后的函数将是`String -> [String]`类型。以下示例显示了组合过程：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, we define `composedFunction`, which is composed of two other
    functions. We are able to compose functions like this as each function has at
    least one parameter and return value. This composition is like the mathematical
    composition of functions. Suppose that we have a function `f(x)` that returns
    `y` and a `g(y)` function that returns `z`. We can compose the `g` function as
    `g(f(x)) -> z`. This composition makes our `g` function take `x` as a parameter
    and return `z` as a result. This is exactly what we have done in our `composedFunction`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了`composedFunction`，它由两个其他函数组成。我们能够以这种方式组合函数，因为每个函数至少有一个参数和一个返回值。这种组合类似于函数的数学组合。假设我们有一个函数`f(x)`返回`y`，以及一个`g(y)`函数返回`z`。我们可以将`g`函数组合为`g(f(x))
    -> z`。这种组合使我们的`g`函数接受`x`作为参数并返回`z`作为结果。这正是我们在`composedFunction`中所做的。
- en: Custom operators
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义操作符
- en: Although `composedFunction` is less verbose than the non-functional version,
    it does not look great. Also, it is not easy to read as we need to read it inside
    out. Let's make this function simpler and more readable. One solution will be
    to define a custom operator that will be used instead of our composed function.
    In the following sections, we will examine what are the standard operators that
    are allowed to define a custom operator. We will also explore the custom operator
    definition technique. It is important to learn this concept as we will be using
    it in the rest of the book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`composedFunction`比非函数版本更简洁，但它看起来并不美观。而且，它也不容易阅读，因为我们需要从内向外阅读它。让我们使这个函数更简单、更易读。一个解决方案是定义一个自定义操作符，用它来代替我们的组合函数。在接下来的章节中，我们将探讨可以用来定义自定义操作符的标准操作符。我们还将探索自定义操作符定义技术。学习这个概念很重要，因为我们将在这本书的其余部分使用它。
- en: Allowed operators
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许的操作符
- en: The Swift standard library provides a number of operators that can be used to
    define custom operators. Custom operators can begin with one of the ASCII characters—`/`,
    `=`, `-`, `+`, `!`, `*`, `%`, `<`, `>`, `&`, `|`, `^`, `?`, or `~` or one of the
    Unicode characters. After the first character, combining Unicode characters is
    allowed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Swift标准库提供了一些可以用来定义自定义操作符的操作符。自定义操作符可以以一个ASCII字符——`/`, `=`, `-`, `+`, `!`, `*`,
    `%`, `<`, `>`, `&`, `|`, `^`, `?`, 或 `~` 或一个Unicode字符开头。在第一个字符之后，允许组合Unicode字符。
- en: We can also define custom operators that begin with a dot. If an operator does
    not start with a dot, it cannot contain a dot elsewhere. Although we can define
    custom operators that contain a question mark `?`, they cannot consist of a single
    question mark character only. Additionally, although operators can contain an
    exclamation point `!`, postfix operators cannot begin with either a question mark
    or exclamation point.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义以点开头的自定义操作符。如果一个操作符不以点开头，它不能在其他地方包含点。尽管我们可以定义包含问号`?`的自定义操作符，但它们不能仅由一个问号字符组成。此外，尽管操作符可以包含感叹号`!`，后缀操作符不能以问号或感叹号开头。
- en: Custom operator definition
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义操作符定义
- en: 'We can define custom operators using the following syntax:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法定义自定义操作符：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, `operatorType` can be one of the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`operatorType`可以是以下之一：
- en: prefix
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀
- en: infix
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中缀
- en: postfix
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀
- en: 'Custom infix operators can also specify a precedence and an associativity:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中缀操作符也可以指定优先级和结合性：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The possible values for associativity are `left`, `right`, and `none`. Left-associative
    operators associate to the left if written next to other left-associative operators
    of the same precedence. Similarly, right-associative operators associate to the
    right if written next to other right-associative operators of the same precedence.
    Non-associative operators cannot be written next to other operators with the same
    precedence.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关联性的可能值是 `left`、`right` 和 `none`。左结合性运算符如果与相同优先级的其他左结合性运算符相邻，则与左侧结合。同样，右结合性运算符如果与相同优先级的其他右结合性运算符相邻，则与右侧结合。非结合性运算符不能与具有相同优先级的其他运算符相邻。
- en: The associativity value defaults to `none` if it is not specified. The precedence
    value defaults to `100` if it is not specified.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，关联性值默认为 `none`。如果未指定，优先级值默认为 `100`。
- en: Any custom operator defined with the preceding syntax will not have an existing
    meaning in Swift; therefore, a function with `operatorName` as its name should
    be defined and implemented. In the following section, we will examine an example
    of custom operator definition with its respective function definition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的语法定义的任何自定义运算符在 Swift 中都不会有现有的意义；因此，应该定义并实现一个名为 `operatorName` 的函数。在下一节中，我们将检查自定义运算符定义及其相应函数定义的示例。
- en: A composed function with a custom operator
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有自定义运算符的组合函数
- en: 'Let''s define a new custom operator to use instead of our composed function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个新的自定义运算符来代替我们的组合函数：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we have defined a new operator, `|>`, that takes two generic
    functions and combines them, returning a function that has the first function's
    input as the parameter and the second function's return as the return type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个新的运算符 `|>`，它接受两个泛型函数并将它们组合起来，返回一个函数，该函数的第一个函数的输入作为参数，第二个函数的返回值作为返回类型。
- en: As this new operator is going to combine two functions and is binary, we defined
    it as infix. Then we need to use the operator keyword. The next step will be to
    choose the notation for our new custom operator. As we will group functions to
    the left, we need to specify it as **associativity left**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个新运算符将要组合两个函数并且是二元的，我们将其定义为中缀运算符。然后我们需要使用运算符关键字。下一步将是选择我们新自定义运算符的表示法。由于我们将函数组合到左侧，我们需要将其指定为
    **左结合性**。
- en: 'To be able to use this operator, we need to define a corresponding function.
    Our function takes two functions as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用此运算符，我们需要定义相应的函数。我们的函数接受两个函数，如下所示：
- en: '`f`: This function takes a generic type of `T` and returns a generic type of
    `V`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`: 这个函数接受一个泛型类型 `T` 并返回一个泛型类型 `V`'
- en: '`g`: This function takes a generic type of `V` and returns a generic type of
    `V`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`: 这个函数接受一个泛型类型 `V` 并返回一个泛型类型 `V`'
- en: 'In our example, we had the following functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有以下函数：
- en: '`extractElements`: `String -> [String]`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extractElements`: `String -> [String]`'
- en: '`formatWithCurrency`: `[String] -> [String]`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formatWithCurrency`: `[String] -> [String]`'
- en: So `T` becomes `String` and `V` becomes `[String]`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`T` 变为 `String`，而 `V` 变为 `[String]`。
- en: Our `|>` function returns a function that takes a generic type of `T` and returns
    a generic type of `V`. We need to receive `String -> [String]` from the composed
    function so, again, `T` becomes `String` and `V` becomes `[String]`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `|>` 函数返回一个函数，该函数接受一个泛型类型 `T` 并返回一个泛型类型 `V`。我们需要从组合函数接收 `String -> [String]`，因此，`T`
    再次变为 `String`，而 `V` 变为 `[String]`。
- en: Using our `|>` custom operator makes our code more readable and less verbose.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `|>` 自定义运算符可以使我们的代码更易读且更简洁。
- en: Closures
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are functions without the `func` keyword. Closures are self-contained
    blocks of code that provide a specific functionality and can be stored, passed
    around, and used in the code like functions. Closures capture the constant and
    variables of the context in which they are defined. Although closures are equivalent
    of blocks in Objective-C, they have a simpler syntax in Swift compared to the
    C and Objective-C block syntax. Nested functions, which we have covered in a previous
    section, are special cases of closures. Closures are reference types that can
    be stored as variables, constants, and type aliases. They can be passed to and
    returned from functions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是没有 `func` 关键字的函数。闭包是包含特定功能的自包含代码块，可以被存储、传递并在代码中像函数一样使用。闭包捕获它们定义的上下文中的常量和变量。尽管闭包在
    Objective-C 中等同于代码块，但与 C 和 Objective-C 的代码块语法相比，Swift 中的闭包语法更简单。我们在前面的部分中已经介绍过的嵌套函数是闭包的特殊情况。闭包是引用类型，可以作为变量、常量和类型别名存储。它们可以被传递给函数并从函数返回。
- en: Closure syntax
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包语法
- en: 'A general closure syntax is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的一般语法如下：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A closure definition starts with `{`, then we define the closure type, and finally
    we use the `in` keyword to separate the closure definition from its implementation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包定义以`{`开始，然后我们定义闭包类型，最后使用`in`关键字将闭包定义与其实现分开。
- en: After the `in` keyword, we write the body of the closure and finish our closure
    by closing `}`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`in`关键字之后，我们编写闭包体，并通过关闭`}`来完成我们的闭包。
- en: 'Closures can be used to define variables. The following closure defines a variable
    of a type closure that accepts `Int` and returns `Int`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以用来定义变量。以下闭包定义了一个接受`Int`并返回`Int`的类型闭包变量：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Closures can be stored as optional variables. The following closure defines
    a variable of a type closure that accepts `Int` and returns `Optional Int`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以存储为可选变量。以下闭包定义了一个接受`Int`并返回`Optional Int`的类型闭包变量：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Closures can be defined as `typealiases`. The following example presents `typealias`
    of a closure that has two `Int` parameters and returns`Int`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以被定义为`类型别名`。以下示例展示了具有两个`Int`参数并返回`Int`的闭包的`typealias`：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The same `typealias` could be used for a function type definition as functions
    are named closures in Swift.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`typealias`也可以用于函数类型定义，因为在Swift中函数被命名为命名的闭包。
- en: 'Closures can be used as an argument to a function call. For instance, the following
    example presents a function that is called with a closure that receives `Int`
    and returns `Int`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以用作函数调用的参数。例如，以下示例展示了一个使用闭包作为参数的函数调用，该闭包接收`Int`并返回`Int`：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Closures can be used as function parameters. The following example shows an
    array sort method that receives a closure:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以用作函数参数。以下示例展示了一个接收闭包的数组排序方法：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This syntax can be simplified with implied types as the Swift compiler has
    the ability to infer the types for parameters from the context:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法可以通过隐式类型简化，因为Swift编译器能够从上下文中推断参数的类型：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The syntax can be further simplified with implied return types using the Swift
    type inference:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swift的类型推断，可以通过隐式返回类型进一步简化语法：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Swift enables us to eliminate the open and close parentheses if we need to
    pass the closure as the last parameter of a function, in other words, if our closure
    is a trailing closure:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将闭包作为函数的最后一个参数传递时，Swift允许我们省略开闭括号，换句话说，如果我们的闭包是尾随闭包：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, Swift provides a shorthand argument notation that can be used instead
    of using arguments:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Swift还提供了一个简写参数符号，可以用作替代使用参数：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can simplify this syntax even further by eliminating the `return` keyword
    as we have only one line of expression as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过消除`return`关键字进一步简化此语法，因为我们只有一行表达式如下：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using the Swift type inference, we were able to simplify the closure syntax
    drastically.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swift的类型推断，我们能够极大地简化闭包的语法。
- en: Capturing values
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获值
- en: Closures can capture variables and constants from the surrounding context in
    which they are created. Closures can refer to these variables and modify them
    within their body, even if the original scope that defined variables no longer
    exists.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以捕获它们创建的周围上下文中的变量和常量。闭包可以在其体内部引用这些变量并修改它们，即使定义变量的原始作用域不再存在。
- en: A closure is said to escape a function when the closure is passed as an argument
    to the function but is called after the function returns. One way that a closure
    can escape is by being stored in a variable that is defined outside the function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包作为函数的参数传递但函数返回后调用时，称闭包逃逸了函数。闭包逃逸的一种方式是将其存储在函数外部定义的变量中。
- en: 'The following is an example of escaping closures, in other words, completion
    handlers:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个逃逸闭包的示例，换句话说，是完成处理程序：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have a function named `sendRequest` that have two parameters—`responseType`
    of the `String.Type` type and `completion` which is type of closure that takes
    a `String`, and an optional `NSError` parameters and does not return any value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`sendRequest`的函数，它有两个参数——`responseType`为`String.Type`类型，以及`completion`，它是一个闭包类型，接受一个`String`和一个可选的`NSError`参数，并且不返回任何值。
- en: Suppose that we execute some asynchronous time-consuming operations in the body
    of the function, such as reading from a file, reading from a database, or calling
    a web service.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在函数体中执行一些异步耗时操作，例如从文件中读取、从数据库中读取或调用网络服务。
- en: To call this function, we provide `String.self` and a closure as arguments.
    Our closure has two variables in it—a variable named `response` of the `Optional
    String` type and an error variable of the `NSError` optional type. As our function
    does not have any return type, it does not return any value to its caller. Here
    comes the concept of escaping a function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，我们需要提供`String.self`和一个闭包作为参数。我们的闭包中有两个变量——一个名为`response`的`Optional String`类型的变量和一个名为`error`的`NSError`可选类型的变量。由于我们的函数没有返回类型，它不会向其调用者返回任何值。这就是函数逃逸的概念。
- en: 'Our passed closure escapes our function as it will be called after our time-consuming
    asynchronous operation finishes with success and the following call happens:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的闭包在函数外部逃逸，因为它将在耗时的异步操作成功完成后被调用，并且随后发生调用：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this call, we pass the `responseData` and error and call back the completion
    closure. Then the body of closure in the caller function is executed with passed
    variables. This concept is a very powerful concept that eases all asynchronous
    operations. It is very readable and easy to follow compared with mechanisms such
    as delegation and notification.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用中，我们传递`responseData`和错误，并调用完成闭包。然后调用函数的闭包体使用传递的变量执行。这个概念是一个非常强大的概念，它简化了所有的异步操作。与委托和通知等机制相比，它非常易于阅读和跟踪。
- en: Function currying
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: 'Function currying translates a single function with multiple arguments into
    a series of functions each with one argument. Let''s examine an example. Suppose
    that we have a function that combines `firstName` and `lastName` to return the
    full name:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数柯里化将具有多个参数的单个函数转换为一系列具有一个参数的函数。让我们看看一个例子。假设我们有一个将`firstName`和`lastName`组合起来返回全名的函数：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This function can be translated into a curried function as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以转换为以下柯里化函数：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As seen from this example, we replace the comma with `) (` parentheses.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，我们可以看到我们将逗号替换为`) (`括号。
- en: 'So now we can use this function as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在我们可以使用此函数如下：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, `fnIncludingFirstName` will have `firstName` in it so that, when we use
    it, we can provide `lastName` and extract the full name. We will use this technique
    in upcoming chapters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fnIncludingFirstName`将包含`firstName`，这样当我们使用它时，我们可以提供`lastName`并提取全名。我们将在接下来的章节中使用这种技术。
- en: 'Starting with Swift 2.2, Apple has deprecated function currying and removed
    it from Swift 3.0\. It is proposed to convert the function currying to returning
    a closure explicitly:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift 2.2开始，Apple已经弃用了函数柯里化，并将其从Swift 3.0中移除。建议将函数柯里化转换为显式返回闭包：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s convert our curried function to return the closure version explicitly:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的柯里化函数显式地转换为返回闭包版本：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can use this function as follows and the result is going to be identical:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数如下，结果将是相同的：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Recursion
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion is the process of calling a function inside itself. The function that
    calls itself is a recursive function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是函数在其内部调用自己的过程。调用自己的函数是递归函数。
- en: Recursion is best used for problems where a large problem can be broken down
    into a repetitive subproblem. As a recursive function calls itself to solve these
    subproblems, eventually the function will come across a subproblem that it can
    handle without calling itself. This is known as a base case, and it is needed
    to prevent the function from calling itself over and over again without stopping.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 递归最适合用于可以将大问题分解为重复子问题的问题。由于递归函数会调用自己来解决这些子问题，最终函数将遇到一个它可以不调用自己就能处理的子问题。这被称为基本情况，这是防止函数不断调用自己而停止所需的。
- en: 'In the base case, the function does not call itself. However, when a function
    does have to call itself in order to deal with its subproblem, then this is known
    as a recursive case. So, there are two types of cases when using a recursive algorithm:
    base cases and recursive cases. It is important to remember that when using recursion
    and when we are trying to solve a problem, we should ask ourselves: *what is my
    base case and what is my recursive case?*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本情况中，函数不会调用自己。然而，当一个函数必须调用自己以处理其子问题时，这被称为递归情况。因此，在使用递归算法时，有两种类型的情况：基本情况递归情况。重要的是要记住，在递归和尝试解决问题时，我们应该问自己：*我的基本情况是什么，我的递归情况是什么？*
- en: 'To apply this simple process, let''s start with an example of recursion: the
    factorial function. In mathematics, an exclamation mark after a number (*n!*)
    presents the factorial of the number. A factorial of a number `n` is the product
    of all integers between `1` and `n`. So, if `n` is equal to `3`, then the factorial
    of `n` would be *3 * 2 * 1*, which equals `6`. We could also say that the factorial
    of `3` is equal to `3` multiplied by the factorial of `2`, which would be *3 *
    2!* or *3 * 2 * 1*. So, the factorial of any number `n` could also be defined
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个简单的过程，让我们从一个递归的例子开始：阶乘函数。在数学中，一个数字后面的感叹号（*n!*）表示该数字的阶乘。一个数字 `n` 的阶乘是介于
    `1` 和 `n` 之间所有整数的乘积。所以，如果 `n` 等于 `3`，那么 `n` 的阶乘将是 *3 * 2 * 1*，等于 `6`。我们也可以说 `3`
    的阶乘等于 `3` 乘以 `2` 的阶乘，即 *3 * 2!* 或 *3 * 2 * 1*。所以，任何数字 `n` 的阶乘也可以定义为以下形式：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We also need to know the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要了解以下内容：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note how we defined the factorial of a number as that number multiplied by
    the factorial of the integer that is `1` less than the number *(n * (n - 1)!)*.
    So, what we have done is essentially broken the problem into a subproblem and,
    in order to find the factorial of a number, we keep finding the factorials of
    the integers below that number and multiplying. So, the factorial of `3` is equal
    to `3` multiplied by the factorial of `2` and the factorial of `2` is equal to
    `2` multiplied by the factorial of `1`. So, if we have a function to find the
    factorial of a given number, then our code for the recursive case would look something
    like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何定义一个数字的阶乘为该数字乘以比该数字小 `1` 的整数的阶乘 *(n * (n - 1)!)*。所以，我们实际上是将问题分解为一个子问题，为了找到某个数字的阶乘，我们不断寻找比该数字小的整数的阶乘并将其相乘。所以，`3`
    的阶乘等于 `3` 乘以 `2` 的阶乘，而 `2` 的阶乘等于 `2` 乘以 `1` 的阶乘。所以，如果我们有一个函数来找到给定数字的阶乘，那么我们的递归情况代码将类似于以下这样：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we want to find `n` number's factorial.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要找到 `n` 个数的阶乘。
- en: In this example, we divided the problem into a subproblem. There is still one
    problem that we need to solve. We need to check for the base case in order to
    be able to stop the function from calling itself infinitely.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将问题分解为一个子问题。仍然有一个问题需要我们解决。我们需要检查基本情况，以便能够停止函数无限调用自身。
- en: 'Therefore, we can modify our factorial example as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以修改我们的阶乘示例如下：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As seen in this example, we check for `n`; if it is 0 or `1`, we return `1`
    and stop the recursion.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们检查 `n`；如果它是 `0` 或 `1`，则返回 `1` 并停止递归。
- en: 'Another example of a simple recursive function is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单递归函数的例子如下：
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The non-recursive version of this example is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的非递归版本如下：
- en: '[PRE77]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As we can see from this example, the recursive version is more expressive and
    shorter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，递归版本更具有表达性和更简洁。
- en: 'The following example presents a function that repeats a given string for a
    desired time:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个重复给定字符串所需时间的函数：
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following code snippet presents the same functionality without using recursion,
    in other words, in the imperative programming style:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了不使用递归实现相同功能的方式，换句话说，以命令式编程风格：
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The non-recursive, imperative version is slightly longer and we need to use
    a `for` loop and variable to be able to achieve the same result. Some functional
    programming languages such as Haskell do not have `for` loop mechanisms and we
    have to use recursion; in Swift, we have `for` loops but as we have seen here,
    it is better to use recursive functions whenever we can.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 非递归、命令式版本的代码稍微长一些，我们需要使用 `for` 循环和变量才能达到相同的结果。一些函数式编程语言，如 Haskell，没有 `for` 循环机制，我们必须使用递归；在
    Swift 中，我们有 `for` 循环，但正如我们在这里看到的，尽可能使用递归函数会更好。
- en: Tail recursion
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: Tail recursion is a special case of recursion where the calling function does
    no more execution after making a recursive call to itself. In other words, a function
    is named tail recursive if its final expression is a recursive call. The previous
    recursion examples that we have been introduced to were not tail recursive functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是递归的一种特殊情况，在这种情况中，调用函数在对自己进行递归调用后不再执行任何操作。换句话说，如果一个函数的最终表达式是一个递归调用，那么这个函数就被称为尾递归函数。我们之前介绍过的递归示例都不是尾递归函数。
- en: 'To be able to understand tail recursion, we will develop the `factorial` function
    that we have developed before with the tail recursion technique. Then we will
    talk about the differences:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解尾递归，我们将使用尾递归技术开发我们之前开发的 `factorial` 函数。然后我们将讨论它们之间的区别：
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note that we provide a default argument of `1` for `currentFactorial`, but this
    only applies to the very first call of the function. When the factorial function
    is called recursively, the default argument is overridden with whatever value
    is passed by the recursive call. We need to have that second argument there because
    it will hold the current factorial value that we intend on passing to the function.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为 `currentFactorial` 提供了一个默认参数 `1`，但这只适用于函数的第一次调用。当阶乘函数递归调用时，默认参数会被递归调用传递的任何值覆盖。我们需要有那个第二个参数，因为它将保存我们打算传递给函数的当前阶乘值。
- en: 'Let''s try to understand how it works and how it is different from the other
    factorial function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解它是如何工作的，以及它与另一个阶乘函数的不同之处：
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this function, each time the factorial function is called, a new value for
    `currentFactorial` is passed to the function. The function basically updates `currentFactorial`
    with each call to itself. We are able to save the current factorial value as it
    accepts `currentFactorial` as a parameter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，每次调用阶乘函数时，都会将一个新的 `currentFactorial` 值传递给函数。函数基本上通过每次对自己的调用来更新 `currentFactorial`。由于它接受
    `currentFactorial` 作为参数，我们能够保存当前的阶乘值。
- en: All of the recursive calls to the factorial such as `factorial(2, 1 * 3)` do
    not actually need to return in order to get the final value. We can see that we
    actually arrive at the value of `6` before any of the recursive calls actually
    return.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对阶乘的递归调用，如 `factorial(2, 1 * 3)`，实际上并不需要返回才能得到最终值。我们可以看到，在任何一个递归调用实际返回之前，我们实际上已经到达了
    `6` 这个值。
- en: Therefore, a function is tail recursive if the final result of the recursive
    call—in this example, `6`—is also the final result of the function itself. The
    non-tail recursive function is not in its final state in the last function call
    because all of the recursive calls leading up to the last function call must also
    return in order to actually come up with the final result.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个函数的递归调用的最终结果——在这个例子中是 `6`——也是函数本身的最终结果，那么这个函数就是尾递归的。非尾递归函数在其最后一个函数调用中并没有达到最终状态，因为所有导致最后一个函数调用的递归调用都必须返回，才能得到最终结果。
- en: Memoization
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: Memoization is the process of storing the result of functions, given their input,
    in order to improve the performance of our programs. We can memoize pure functions
    as pure functions do not rely on external data and do not change anything outside
    themselves. Pure functions provide the same result for a given input every time.
    Therefore, we can save or cache the results—in other words, memoize the results—given
    their inputs and use them in the future without going through the calculation
    process.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是将函数的输入结果存储起来的过程，以便提高我们程序的性能。我们可以记忆化纯函数，因为纯函数不依赖于外部数据，也不改变自身之外的内容。纯函数对于给定的输入每次都提供相同的结果。因此，我们可以保存或缓存结果——换句话说，记忆化结果——并使用它们在将来而不必经过计算过程。
- en: 'To be able to understand the concept, let''s look at the following example
    in which we will manually memoize the `power2` function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，让我们看看以下示例，我们将手动记忆化 `power2` 函数：
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As we can see from the example, we define a dictionary of the `[Int, Int]` type.
    We save the result of the function given its input to this dictionary.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们定义了一个 `[Int, Int]` 类型的字典。我们将函数的输入结果保存到这个字典中。
- en: This approach works properly but we need to manually modify and maintain a collection
    outside of the function to be able to memoize the results of the function. Also,
    it adds a lot of boilerplate code to each function that we need memoization for.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以正常工作，但我们需要手动修改和维护函数外部的一个集合，以便能够记忆化函数的结果。此外，它还为每个需要记忆化的函数添加了大量的模板代码。
- en: The advanced Swift session presented in **Worldwide Developers Conference**
    (**WWDC**) 2014 ( [https://developer.apple.com/videos/play/wwdc2014-404/](https://developer.apple.com/videos/play/wwdc2014-404/))
    provides a very convenient function for memoization that can be used with any
    pure function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年的**全球开发者大会**（**WWDC**）上展示的**高级Swift**会议（[https://developer.apple.com/videos/play/wwdc2014-404/](https://developer.apple.com/videos/play/wwdc2014-404/））提供了一个非常方便的记忆化函数，可以与任何纯函数一起使用。
- en: 'Watching the video is highly recommended. Let''s see if we could automatize
    this functionality and reuse it using the `memoize` function from that session:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 观看视频是非常推荐的。让我们看看我们能否使用该会话中的 `memoize` 函数来自动化这个功能并重用它：
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The function looks complex but don't worry, we will go through it in detail.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数看起来很复杂，但不用担心，我们将详细讲解它。
- en: First of all, it is a generic function. Do not worry about generics—we will
    cover generics in detail in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*—and `Hashable` is used
    because we need to store `T` as a key in a dictionary.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它是一个泛型函数。不要担心泛型——我们将在第 5 章[泛型和关联类型协议](ch05.html "第 5 章。泛型和关联类型协议")中详细讲解泛型，并且使用
    `Hashable` 是因为我们需要将 `T` 作为键存储在字典中。
- en: 'If we look at the signature of the function, we see that the `memoize` function
    takes a function (`fn`) with two parameters and a return type. So the signature
    of `fn`, which is a function, is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看函数的签名，我们会看到 `memoize` 函数接受一个有两个参数和返回类型的函数。因此，`fn` 的签名，它是一个函数，如下所示：
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first parameter of `fn` is a function of the `(T) -> U` type and the second
    parameter is of the `T` type and finally `fn` returns `U`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` 的第一个参数是 `(T) -> U` 类型的函数，第二个参数是 `T` 类型，最后 `fn` 返回 `U` 类型。'
- en: OK, the `memoize` function received `fn`, which is described in the preceding
    code snippet.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`memoize` 函数接收了前面代码片段中描述的 `fn`。
- en: At the end, the `memoize` function returns a function of the `(T) -> U` type.
    Now let's look at the body of the `memoize` function. First, we need to have a
    dictionary to cache the results. Second, we need to define the result type, which
    is a closure. In the closure body, we check whether we already have the key in
    our dictionary. If we do, we return it, otherwise, we call the function and save
    the result in our memo dictionary.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`memoize` 函数返回一个 `(T) -> U` 类型的函数。现在让我们看看 `memoize` 函数的主体。首先，我们需要一个字典来缓存结果。其次，我们需要定义结果类型，它是一个闭包。在闭包体中，我们检查是否已经在我们的字典中有了这个键。如果有，我们返回它，否则调用函数并将结果保存在我们的缓存字典中。
- en: Now we can use this function to memoize the results of different function calls
    and improve the performance of our programs.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个函数来缓存不同函数调用的结果，并提高我们程序的性能。
- en: 'The following example presents the memoized version of the factorial function:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了阶乘函数的缓存版本：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `memoize` function expects a closure as input, therefore, we can use the
    trailing closure syntax. In the preceding example, we provided the factorial function
    and `x` parameters as input to the closure and the line after the `in` keyword
    is the body of the closure. In the previous example, we used memoize for a recursive
    function and it works properly. Let''s look at another example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize` 函数期望一个闭包作为输入，因此我们可以使用尾随闭包语法。在先前的例子中，我们将阶乘函数和 `x` 参数作为输入传递给闭包，`in`
    关键字之后的行是闭包的主体。在先前的例子中，我们使用 `memoize` 对递归函数进行了缓存，并且它工作得很好。让我们看看另一个例子：'
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this example, we use the `memoize` function to have a memoized version of
    the `powerOf2` function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `memoize` 函数来获取 `powerOf2` 函数的缓存版本。
- en: Writing the memoize function once, we will be able to use it for any pure functions
    to cache the data and improve the performance of our programs.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 只需编写一次 `memoize` 函数，我们就能将其用于任何纯函数来缓存数据并提高我们程序的性能。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started by explaining function definition and usage in detail by
    giving examples for parameter and return types. Then it continued to cover functional
    programming-related concepts such as pure, first-class, higher-order, and nested
    functions. Finally, it covered function compositions, closures, currying, and
    memoization. At this point, we should be familiar with different types of functions
    and closures and their usages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从详细解释函数定义和用法开始，通过给出参数和返回类型的示例。然后，它继续介绍与函数式编程相关的概念，如纯函数、一等函数、高阶函数和嵌套函数。最后，它涵盖了函数组合、闭包、柯里化和缓存。到这一点，我们应该熟悉不同类型的函数和闭包及其用法。
- en: In the following chapter, we will cover types and explore the concept of value
    types versus reference types. Also, we will look at value type characteristics
    in detail and cover type equality, identity, and casting.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍类型，并探讨值类型与引用类型的概念。同时，我们将详细探讨值类型的特性，包括类型相等性、身份和转换。
