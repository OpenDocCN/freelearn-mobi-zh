- en: Chapter 2. Functions and Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had an overview of functional programming and the
    Swift programming language. It introduced some of the key concepts about functions.
    As functions are the fundamental building blocks in functional programming, this
    chapter dives deeper into it and explains all the aspects related to the definition
    and usage of functions in functional Swift, together with coding examples.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a definition of functions, continues with other related
    topics such as function types and tuples, and finally concludes with more advanced
    topics such as first-class functions, higher-order functions, function composition,
    closures, currying, recursion, and memoization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting internal and external parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting default parameter values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using variadic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values from functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using nested functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of a custom operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a function?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) looks very natural to most developers
    as it simulates a real-life situation of classes or, in other words, blueprints
    and their instances, but it brought a lot of complexities and problems such as
    instance and memory management, complex multithreading, and concurrency programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Before OOP became mainstream, we were used to developing in procedural languages.
    In the C programming language, we did not have objects and classes; we would use
    structs and function pointers. So now we are talking about functional programming
    that relies mostly on functions just as procedural languages relied on procedures.
    We are able to develop very powerful programs in C without classes; in fact, most
    operating systems are developed in C. There are other multipurpose programming
    languages such as Go by Google that is not object-oriented and is getting very
    popular because of its performance and simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: So, are we going to be able to write very complex applications without classes
    in Swift? We might wonder why we should do this. Generally, we should not, but
    attempting it will introduce us to the capabilities of functional programming.
    This is why we will have a whole chapter about functions before talking about
    other building blocks such as `classes`, `structs`, and `enums`.
  prefs: []
  type: TYPE_NORMAL
- en: A function is a block of code that executes a specific task, can be stored,
    can persist data, and can be passed around. We define them in standalone Swift
    files as global functions or inside other building blocks such as `classes`, `structs`,
    `enums`, and `protocols` as methods.
  prefs: []
  type: TYPE_NORMAL
- en: They are called methods if they are defined in classes but, in terms of definition,
    there is no difference between a function and method in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Defining them in other building blocks enables methods to use the scope of the
    parent or to be able to change it. They can access the scope of their parent and
    they have their own scope. Any variable that is defined inside a function is not
    accessible outside of it. The variables defined inside them and the corresponding
    allocated memory go away when the function terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are very powerful in Swift. We can compose a program with only functions
    as functions can receive and return functions, capture variables that exist in
    the context they were declared, and can persist data inside themselves. To understand
    the functional programming paradigms, we need to understand the capability of
    functions in detail. We need to think if we can avoid classes and only use functions,
    so we will cover all the details related to functions in upcoming sections of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax of functions and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define functions or methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we know already, when functions are defined in objects, they become methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to define a method is to tell the compiler from where it can
    be accessed. This concept is called access control in Swift and there are three
    levels of access control. We are going to explain them for methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public access**: Any entity can access a method that is defined as public
    if it is in the same module. If an entity is not in the same module, we will need
    to import the module to be able to call the method. We need to mark our methods
    and objects as `public` when we develop frameworks in order to enable other modules
    to use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal access**: Any method that is defined as `internal` can be accessed
    from other entities in a module but cannot be accessed from other modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private access**: Any method that is defined as `private` can be accessed
    only from the same source file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, if we do not provide the access modifier, a variable or function
    becomes internal.
  prefs: []
  type: TYPE_NORMAL
- en: Using these access modifiers, we can structure our code properly; for instance,
    we can hide details from other modules if we define an entity as internal. We
    can even hide the details of a method from other files if we define them as private.
  prefs: []
  type: TYPE_NORMAL
- en: Before Swift 2.0, we had to define everything as public or add all source files
    to the testing target. Swift 2.0 introduced the `@testable import` syntax that
    enables us to define internal or private methods that can be accessed from testing
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can generally be in three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance methods**: We need to obtain an instance of an object (in this book
    we will refer to `classes`, `structs`, and `enums` as objects) in order to be
    able to call the method defined in it, and then we will be able to access the
    scope and data of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static methods**: Swift names them type methods also. They do not need any
    instances of objects and they cannot access the instance data. They are called
    by putting a dot after the name of the object type (for example, `Person.sayHi()`).
    The `static` methods cannot be overridden by the subclasses of the object that
    they reside in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class methods**: Class methods are like the `static` methods but they can
    be overridden by subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered the keywords that are required for method definitions; now we
    will concentrate on the syntax that is shared among functions and methods. There
    are other concepts related to methods that are out of scope of this book as we
    will concentrate on functional programming in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to cover the function definition, now comes the `func` keyword that
    is mandatory and is used to tell the compiler that it is going to deal with a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the function name that is mandatory and is recommended to be camel-cased
    with the first letter as lowercase. The function name should be stating what the
    function does and is recommended to be in the form of a verb when we define our
    methods in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our classes will be named nouns and methods will be verbs that are
    in the form of orders to the class. In pure functional programming, as the function
    does not reside in other objects, they can be named by their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters follow the `func` name. They will be defined in parentheses to pass
    arguments to the function. Parentheses are mandatory even if we do not have any
    parameters. We will cover all aspects of parameters in *Defining and using function
    parameters* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes `throws`, which is not mandatory. A function or method that is marked
    with the `throws` keyword may or may not throw errors. We will cover error handling
    mechanisms in upcoming chapters. At this point, it is enough to know what they
    are when we see them in a function or method signature.
  prefs: []
  type: TYPE_NORMAL
- en: The next entity in a function type declaration is the return type. If a function
    is not void, the return type will come after the `->` sign. The return type indicates
    the type of entity that is going to be returned from a function.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover return types in detail in *Returning values from functions* section
    of this chapter, so now we can move on to the last piece of function that is present
    in most programming languages, our beloved `{ }`. We defined functions as blocks
    of functionality and `{ }` defines the borders of the block so that the function
    body is declared and execution happens in there. We will write the functionality
    inside `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in function definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are proven best practices for function and method definition provided
    by amazing software engineering resources, such as *Clean Code: A Handbook of
    Agile Software Craftsmanship*, by *Robert C. Martin*, *Code Complete: A Practical
    Handbook of Software Construction, Second Edition*, by *Steve McConnell*, and
    Coding Horror ([https://blog.codinghorror.com/code-smells/](https://blog.codinghorror.com/code-smells/)),
    that we can summarize as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Try not to exceed 8-10 lines of code in each function as shorter functions or
    methods are easier to read, understand, and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the number of parameters minimal because the more parameters a function
    has, the more complex it is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should have at least one parameter and one return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using type names in function names as it is going to be redundant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aim for one and only one functionality in a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name a function or method in a way that describes its functionality properly
    and is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name functions and methods consistently. If we have a connect function, we can
    have a disconnect one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write functions to solve the current problem and generalize it when needed.
    Try to avoid what-if scenarios as probably **you aren't gonna need it** (**YAGNI**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered a general syntax to define a function and method if it resides
    in an object. Now it is time to talk about how we call our defined functions and
    methods. To call a function, we will use its name and provide its required parameters.
    There are complexities with providing parameters that we will cover in upcoming
    section. For now, we are going to cover the most basic type of parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This type of function calling should be familiar to Objective-C developers as
    the first parameter name is not named and the rest are named.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a method, we need to use the dot notation provided by Swift. The following
    examples are for class instance methods and static class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Defining and using function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In function definition, parameters follow the function name and they are constants
    by default so we will not able to alter them inside the function body if we do
    not mark them with `var`. In functional programming, we avoid mutability; therefore,
    we would never use mutable parameters in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters should be inside parentheses. If we do not have any parameters,
    we simply put open and close parentheses without any characters between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In functional programming, it is important to have functions that have at least
    one parameter. We will explain why it is important in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have multiple parameters separated by commas. In Swift, parameters are
    named so we need to provide the parameter name and type after putting a colon,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ParameterType` can also be an optional type so the function becomes the following
    if our parameters need to be optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift enables us to provide external parameter names that will be used when
    functions are called. The following example presents the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Only the local parameter name is usable in the function body.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to omit parameter names with the `_` syntax; for instance, if
    we do not want to provide any parameter name when the function is called, we can
    use `_` as `externalParamName` for the second or subsequent parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have a parameter name for the first parameter name in function
    calls, we can basically provide the local parameter name as external also. In
    this book, we are going to use the default function parameter definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters can have default values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Parameters can be defined as `inout` to enable function callers obtaining parameters
    that are going to be changed in the body of a function. As we can use tuples for
    function returns, it is not recommended to use `inout` parameters unless we really
    need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define function parameters as tuples. For instance, the following example
    function accepts a tuple of the `(Int, Int)` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As, under the hood, variables are represented by tuples in Swift, the parameters
    to a function can also be tuples. For instance, let''s have a simple `convert`
    function that takes an array of `Int` and a multiplier and converts it to a different
    structure. Let''s not worry about the implementation of this function for now;
    we will have [Chapter 6](ch06.html "Chapter 6. Map, Filter, and Reduce"), *Map,
    Filter, and Reduce* that will cover the map function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this function as `let resultOfConversion = convert(numbers: numbers,
    multiplier: 3)`, the result is going to be `["0: 9", "1: 15", "2: 27", "3: 30"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call our function with a tuple. Let''s create a tuple and pass it to
    our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The result is identical to our previous function call. However, passing tuples
    in function calls is removed from Swift 3.0, so it is not recommended to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define higher-order functions that can receive functions as parameters.
    In the following example, we define `funcParam` as a function type of `(Int, Int)
    -> Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, parameters can be of a generic type. The following example presents
    a function that has two generic parameters. In this syntax, any type (for example,
    `T` or `V`) that we put inside `<>` should be used in parameter definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will cover generics in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*; at this point, knowing
    the syntax should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using variadic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift enables us to define functions with variadic parameters. A variadic parameter
    accepts zero or more values of a specified type. Variadic parameters are similar
    to array parameters but they are more readable and can only be used as the last
    parameter in multiparameter functions.
  prefs: []
  type: TYPE_NORMAL
- en: As variadic parameters can accept zero values, we will need to check whether
    they are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a function with variadic parameters of the `String`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Returning values from functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need our function to return a value, tuple, or another function, we can
    specify it by providing `ReturnType` after `->`. For instance, the following example
    returns `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Any function that has `ReturnType` in its definition should have a `return`
    keyword with the matching type in its body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return types can be optionals in Swift so the function becomes as follows if
    the return needs to be optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples can be used to provide multiple return values. For instance, the following
    function returns a tuple of the `(Int, String)` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we are using parentheses for tuples, we should avoid using parentheses for
    single return value functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuple return types can be optional too so the syntax becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax makes the entire tuple optional; if we want to make only `status`
    optional, we can define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, functions can return functions. The following example presents a
    function with the return type of a function that takes two `Int` values and returns
    an `Int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not expect a function to return any value, tuple, or function, we
    simply do not provide `ReturnType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also explicitly declare it with the `Void` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In functional programming, it is important to have return types in functions.
    In other words, it is a good practice to avoid functions that have `Void` as return
    type. A function with the `Void` return type typically is a function that changes
    another entity in the code; otherwise, why would we need to have a function? OK,
    we might have wanted to log an expression to the console/log file or write data
    to a database or a file to a filesystem. In these cases, it is also preferable
    to have a return or feedback related to the success of the operation. As we try
    to avoid mutability and stateful programming in functional programming, we can
    assume that our functions will have returns in different forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requirement is in line with mathematical underlying bases of functional
    programming. In mathematics, a simple function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `f` is a function that takes `x` and returns `y`. Therefore, a function
    receives at least one parameter and returns at least a value. In functional programming,
    following the same paradigm makes reasoning easier, function composition possible,
    and code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are functions that do not possess any side effects; in other
    words, they do not change or alter any data or state outside of themselves. Additionally,
    they do not access any data or state except their provided parameters. Pure functions
    are like mathematical functions that are pure by nature.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions return a value that is only determined by its parameter values.
    Pure functions are easy to test as they rely only on their parameters and do not
    change or access any data or state outside of themselves. Pure functions are suitable
    for concurrency as they do not access and change global data or states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list presents examples of pure and not pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Printing a String literal to a console is not pure as it modifies an external
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file is not pure as it depends on the external state at different
    times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length of a String is pure as it does not rely on a state. It only takes a String
    as input and returns the length as output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the current date is not pure as it returns different values when called
    at different dates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a random number is not pure as it returns different values each time
    it is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pure functions may sound very restrictive and impossible to utilize in
    real-world scenarios, but there are other tools that can provide the same functionality,
    which we will discuss later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the benefits of pure functions in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function parameter type along with its return type defines the type of the
    function. For instance, the function type for the following coding example is
    `(Int, Double) -> String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to use function types in the way we use other types. The following
    code example presents a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, `simpleMathOperator` is a variable of a function of the `(Double, Double)
    -> Double` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define `typealias` for the function type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this `typealias` in the `simpleMathOperator` definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define functions with the same type and assign them to our `simpleMathOperator`.
    The type of functions in the following code snippet is `(Double, Double) -> Double`,
    which is in fact `SimpleOperator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we are able to assign these functions to `simpleMathOperator` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that `simpleMathOperator` refers to the `multiplyTwoNumbers` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As the other three functions also have the same function type, we will be able
    to assign them to the same variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `SimpleOperator` as a parameter type of other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `calculateResult` function has three parameters. The `mathOperator`
    parameter is a type of function type. The `a` and `b` parameters are `Double`.
    When we call this function, we pass a `simpleMathOperator` function and two `Double`
    values for `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that we pass only a reference to `simpleMathOperator`
    and this is not going to execute it. In the function body, we use this function
    and call it with `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `SimpleOperator` as a return type of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `choosePlusMinus` function has a `Bool` parameter; in its body, it
    checks for this parameter and returns `addTwoNumbers` or `subtractTwoNumbers`
    that have the same type, `SimpleOperator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand that calling `choosePlusMinus(true)` does not
    execute the returned function and in fact only returns the reference to `addTwoNumbers`.
    We save this reference in `chosenOperator`. The `chosenOperator` variable becomes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When we call `chosenOperator(3.5, 5.5)`, we pass these two numbers to the `addTwoNumbers`
    function and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The capability to define function types makes functions first-class citizens
    in Swift. Function types are used for first-class and higher-order functions.
    These capabilities empower us to apply functional programming paradigms in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using nested functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, it is possible to define functions inside other functions. In other
    words, we can nest functions inside other functions. Nested functions are only
    accessible inside their enclosing functions and are hidden from the outside world
    by default. The enclosing function can return the nested function in order to
    allow the nested function to be used in other scopes. The following example presents
    a function that contains two nested functions and returns one of them according
    to the value of its `isPlus` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Function types* section of this chapter, we have seen that we can define
    function types and store and pass functions around. In practice, this means that
    Swift treats functions as values. To explain this, we will need to examine a couple
    of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we create a constant of the `String` type and `name` and
    store a value (`"Your name"`) in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define a function, we need to specify the type of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our `name` parameter is of the `String` type. This parameter
    could be any other value type or reference type. Simply, it could be `Int`, `Double`,
    `Dictionary`, `Array`, `Set`, or it could be an object type such as an instance
    of `class`, `struct`, or `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass a value for this parameter. In other words, we pass one of the
    previously mentioned types with their respective values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift treats functions like the other aforementioned types so we can store
    a function in a variable as we were able to with other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we saved the `sayHello` function in a variable that can be
    used later on and passed around as a value.
  prefs: []
  type: TYPE_NORMAL
- en: In pure OOP, we do not have functions; instead, we have methods. In other words,
    functions can only reside in objects and then they are called methods. In OOP,
    classes are first-class citizens and methods are not. Methods are not solely reachable
    and cannot be stored or passed around. In OOP, methods access the object's data
    that they are defined in.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, functions are first-class citizens. Just like other
    types, they can be stored and passed around. In contrast to OOP, that method could
    only access their parent object's data and change it; in functional programming,
    they can be stored and passed to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: This notion enables us to compose our applications with functions as they are
    just another type that can be used. We will talk about this in more detail; for
    now, it is important to understand why we call functions as first-class citizens
    in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the *Defining and using function parameters* and *Function
    types* sections of this chapter, functions can accept functions as parameters
    in Swift. Functions that can accept other functions as parameters are called higher-order
    functions. This concept along with first-class functions empower functional programming
    and function decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: As this topic is essential in functional programming, we will go through another
    simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we need to develop two functions that add and subtract two `Int`
    values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to develop functions to calculate the square and triple of two
    `Int` values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we need another function that subtracts the squared two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we need to add two squared values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that we need another function that triples a value and adds it to
    another tripled value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we had to write a lot of redundant and inflexible functions. Using
    higher-order functions, we could write a flexible function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This higher-order function takes two other functions as parameters and uses
    them. We can call it for different scenarios as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This simple example presents the utility of higher-order functions in function
    composition and subsequently in program modularity.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen an example of higher-order functions that
    could accept two different functions and execute them in a predefined order. This
    function was not so flexible in the sense that it would break if we wanted to
    combine two accepted functions differently. Function composition can solve this
    issue and make it even more flexible. To present this concept, we will examine
    an example of non-functional composition first, and then we will be introduced
    to functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, in our application, we need to interact with a backend RESTful
    API and receive a `String` value that contains a list of prices in order. The
    backend RESTful API is being developed by a third-party and is not designed properly.
    Unfortunately, it returns a `String` with numbers in it separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to format the content that we are receiving before using it. We will
    extract elements from `String` and create an array, and then we will append `$`
    as currency to each item to use it in a tableview. The following code example
    presents an approach to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we treated each function individually. We could use the
    result of the first function as an input parameter for the second function. Either
    approach is verbose and not functional. Additionally, we use the `map` function,
    which is a higher-order function, but our approach is still not functional.
  prefs: []
  type: TYPE_NORMAL
- en: Let's approach this problem in a functional way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to identify function types for each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extractElements`: `String -> [String]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formatWithCurrency`: `[String] -> [String]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we pipe these functions, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine these functions with a functional composition and the composed
    function will be of the `String -> [String]` type. The following example shows
    the composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define `composedFunction`, which is composed of two other
    functions. We are able to compose functions like this as each function has at
    least one parameter and return value. This composition is like the mathematical
    composition of functions. Suppose that we have a function `f(x)` that returns
    `y` and a `g(y)` function that returns `z`. We can compose the `g` function as
    `g(f(x)) -> z`. This composition makes our `g` function take `x` as a parameter
    and return `z` as a result. This is exactly what we have done in our `composedFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `composedFunction` is less verbose than the non-functional version,
    it does not look great. Also, it is not easy to read as we need to read it inside
    out. Let's make this function simpler and more readable. One solution will be
    to define a custom operator that will be used instead of our composed function.
    In the following sections, we will examine what are the standard operators that
    are allowed to define a custom operator. We will also explore the custom operator
    definition technique. It is important to learn this concept as we will be using
    it in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Allowed operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swift standard library provides a number of operators that can be used to
    define custom operators. Custom operators can begin with one of the ASCII characters—`/`,
    `=`, `-`, `+`, `!`, `*`, `%`, `<`, `>`, `&`, `|`, `^`, `?`, or `~` or one of the
    Unicode characters. After the first character, combining Unicode characters is
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: We can also define custom operators that begin with a dot. If an operator does
    not start with a dot, it cannot contain a dot elsewhere. Although we can define
    custom operators that contain a question mark `?`, they cannot consist of a single
    question mark character only. Additionally, although operators can contain an
    exclamation point `!`, postfix operators cannot begin with either a question mark
    or exclamation point.
  prefs: []
  type: TYPE_NORMAL
- en: Custom operator definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define custom operators using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `operatorType` can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: infix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: postfix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom infix operators can also specify a precedence and an associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The possible values for associativity are `left`, `right`, and `none`. Left-associative
    operators associate to the left if written next to other left-associative operators
    of the same precedence. Similarly, right-associative operators associate to the
    right if written next to other right-associative operators of the same precedence.
    Non-associative operators cannot be written next to other operators with the same
    precedence.
  prefs: []
  type: TYPE_NORMAL
- en: The associativity value defaults to `none` if it is not specified. The precedence
    value defaults to `100` if it is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Any custom operator defined with the preceding syntax will not have an existing
    meaning in Swift; therefore, a function with `operatorName` as its name should
    be defined and implemented. In the following section, we will examine an example
    of custom operator definition with its respective function definition.
  prefs: []
  type: TYPE_NORMAL
- en: A composed function with a custom operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a new custom operator to use instead of our composed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have defined a new operator, `|>`, that takes two generic
    functions and combines them, returning a function that has the first function's
    input as the parameter and the second function's return as the return type.
  prefs: []
  type: TYPE_NORMAL
- en: As this new operator is going to combine two functions and is binary, we defined
    it as infix. Then we need to use the operator keyword. The next step will be to
    choose the notation for our new custom operator. As we will group functions to
    the left, we need to specify it as **associativity left**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use this operator, we need to define a corresponding function.
    Our function takes two functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f`: This function takes a generic type of `T` and returns a generic type of
    `V`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: This function takes a generic type of `V` and returns a generic type of
    `V`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we had the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extractElements`: `String -> [String]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formatWithCurrency`: `[String] -> [String]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So `T` becomes `String` and `V` becomes `[String]`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `|>` function returns a function that takes a generic type of `T` and returns
    a generic type of `V`. We need to receive `String -> [String]` from the composed
    function so, again, `T` becomes `String` and `V` becomes `[String]`.
  prefs: []
  type: TYPE_NORMAL
- en: Using our `|>` custom operator makes our code more readable and less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures are functions without the `func` keyword. Closures are self-contained
    blocks of code that provide a specific functionality and can be stored, passed
    around, and used in the code like functions. Closures capture the constant and
    variables of the context in which they are defined. Although closures are equivalent
    of blocks in Objective-C, they have a simpler syntax in Swift compared to the
    C and Objective-C block syntax. Nested functions, which we have covered in a previous
    section, are special cases of closures. Closures are reference types that can
    be stored as variables, constants, and type aliases. They can be passed to and
    returned from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Closure syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A general closure syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: A closure definition starts with `{`, then we define the closure type, and finally
    we use the `in` keyword to separate the closure definition from its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: After the `in` keyword, we write the body of the closure and finish our closure
    by closing `}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures can be used to define variables. The following closure defines a variable
    of a type closure that accepts `Int` and returns `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Closures can be stored as optional variables. The following closure defines
    a variable of a type closure that accepts `Int` and returns `Optional Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Closures can be defined as `typealiases`. The following example presents `typealias`
    of a closure that has two `Int` parameters and returns`Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The same `typealias` could be used for a function type definition as functions
    are named closures in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures can be used as an argument to a function call. For instance, the following
    example presents a function that is called with a closure that receives `Int`
    and returns `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Closures can be used as function parameters. The following example shows an
    array sort method that receives a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax can be simplified with implied types as the Swift compiler has
    the ability to infer the types for parameters from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax can be further simplified with implied return types using the Swift
    type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift enables us to eliminate the open and close parentheses if we need to
    pass the closure as the last parameter of a function, in other words, if our closure
    is a trailing closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, Swift provides a shorthand argument notation that can be used instead
    of using arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify this syntax even further by eliminating the `return` keyword
    as we have only one line of expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using the Swift type inference, we were able to simplify the closure syntax
    drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures can capture variables and constants from the surrounding context in
    which they are created. Closures can refer to these variables and modify them
    within their body, even if the original scope that defined variables no longer
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: A closure is said to escape a function when the closure is passed as an argument
    to the function but is called after the function returns. One way that a closure
    can escape is by being stored in a variable that is defined outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of escaping closures, in other words, completion
    handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have a function named `sendRequest` that have two parameters—`responseType`
    of the `String.Type` type and `completion` which is type of closure that takes
    a `String`, and an optional `NSError` parameters and does not return any value.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we execute some asynchronous time-consuming operations in the body
    of the function, such as reading from a file, reading from a database, or calling
    a web service.
  prefs: []
  type: TYPE_NORMAL
- en: To call this function, we provide `String.self` and a closure as arguments.
    Our closure has two variables in it—a variable named `response` of the `Optional
    String` type and an error variable of the `NSError` optional type. As our function
    does not have any return type, it does not return any value to its caller. Here
    comes the concept of escaping a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our passed closure escapes our function as it will be called after our time-consuming
    asynchronous operation finishes with success and the following call happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this call, we pass the `responseData` and error and call back the completion
    closure. Then the body of closure in the caller function is executed with passed
    variables. This concept is a very powerful concept that eases all asynchronous
    operations. It is very readable and easy to follow compared with mechanisms such
    as delegation and notification.
  prefs: []
  type: TYPE_NORMAL
- en: Function currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function currying translates a single function with multiple arguments into
    a series of functions each with one argument. Let''s examine an example. Suppose
    that we have a function that combines `firstName` and `lastName` to return the
    full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be translated into a curried function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As seen from this example, we replace the comma with `) (` parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fnIncludingFirstName` will have `firstName` in it so that, when we use
    it, we can provide `lastName` and extract the full name. We will use this technique
    in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Swift 2.2, Apple has deprecated function currying and removed
    it from Swift 3.0\. It is proposed to convert the function currying to returning
    a closure explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s convert our curried function to return the closure version explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function as follows and the result is going to be identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is the process of calling a function inside itself. The function that
    calls itself is a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is best used for problems where a large problem can be broken down
    into a repetitive subproblem. As a recursive function calls itself to solve these
    subproblems, eventually the function will come across a subproblem that it can
    handle without calling itself. This is known as a base case, and it is needed
    to prevent the function from calling itself over and over again without stopping.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the base case, the function does not call itself. However, when a function
    does have to call itself in order to deal with its subproblem, then this is known
    as a recursive case. So, there are two types of cases when using a recursive algorithm:
    base cases and recursive cases. It is important to remember that when using recursion
    and when we are trying to solve a problem, we should ask ourselves: *what is my
    base case and what is my recursive case?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this simple process, let''s start with an example of recursion: the
    factorial function. In mathematics, an exclamation mark after a number (*n!*)
    presents the factorial of the number. A factorial of a number `n` is the product
    of all integers between `1` and `n`. So, if `n` is equal to `3`, then the factorial
    of `n` would be *3 * 2 * 1*, which equals `6`. We could also say that the factorial
    of `3` is equal to `3` multiplied by the factorial of `2`, which would be *3 *
    2!* or *3 * 2 * 1*. So, the factorial of any number `n` could also be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we defined the factorial of a number as that number multiplied by
    the factorial of the integer that is `1` less than the number *(n * (n - 1)!)*.
    So, what we have done is essentially broken the problem into a subproblem and,
    in order to find the factorial of a number, we keep finding the factorials of
    the integers below that number and multiplying. So, the factorial of `3` is equal
    to `3` multiplied by the factorial of `2` and the factorial of `2` is equal to
    `2` multiplied by the factorial of `1`. So, if we have a function to find the
    factorial of a given number, then our code for the recursive case would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we want to find `n` number's factorial.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we divided the problem into a subproblem. There is still one
    problem that we need to solve. We need to check for the base case in order to
    be able to stop the function from calling itself infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can modify our factorial example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As seen in this example, we check for `n`; if it is 0 or `1`, we return `1`
    and stop the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a simple recursive function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-recursive version of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from this example, the recursive version is more expressive and
    shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a function that repeats a given string for a
    desired time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet presents the same functionality without using recursion,
    in other words, in the imperative programming style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The non-recursive, imperative version is slightly longer and we need to use
    a `for` loop and variable to be able to achieve the same result. Some functional
    programming languages such as Haskell do not have `for` loop mechanisms and we
    have to use recursion; in Swift, we have `for` loops but as we have seen here,
    it is better to use recursive functions whenever we can.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursion is a special case of recursion where the calling function does
    no more execution after making a recursive call to itself. In other words, a function
    is named tail recursive if its final expression is a recursive call. The previous
    recursion examples that we have been introduced to were not tail recursive functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to understand tail recursion, we will develop the `factorial` function
    that we have developed before with the tail recursion technique. Then we will
    talk about the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that we provide a default argument of `1` for `currentFactorial`, but this
    only applies to the very first call of the function. When the factorial function
    is called recursively, the default argument is overridden with whatever value
    is passed by the recursive call. We need to have that second argument there because
    it will hold the current factorial value that we intend on passing to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand how it works and how it is different from the other
    factorial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this function, each time the factorial function is called, a new value for
    `currentFactorial` is passed to the function. The function basically updates `currentFactorial`
    with each call to itself. We are able to save the current factorial value as it
    accepts `currentFactorial` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: All of the recursive calls to the factorial such as `factorial(2, 1 * 3)` do
    not actually need to return in order to get the final value. We can see that we
    actually arrive at the value of `6` before any of the recursive calls actually
    return.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a function is tail recursive if the final result of the recursive
    call—in this example, `6`—is also the final result of the function itself. The
    non-tail recursive function is not in its final state in the last function call
    because all of the recursive calls leading up to the last function call must also
    return in order to actually come up with the final result.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memoization is the process of storing the result of functions, given their input,
    in order to improve the performance of our programs. We can memoize pure functions
    as pure functions do not rely on external data and do not change anything outside
    themselves. Pure functions provide the same result for a given input every time.
    Therefore, we can save or cache the results—in other words, memoize the results—given
    their inputs and use them in the future without going through the calculation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to understand the concept, let''s look at the following example
    in which we will manually memoize the `power2` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the example, we define a dictionary of the `[Int, Int]` type.
    We save the result of the function given its input to this dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works properly but we need to manually modify and maintain a collection
    outside of the function to be able to memoize the results of the function. Also,
    it adds a lot of boilerplate code to each function that we need memoization for.
  prefs: []
  type: TYPE_NORMAL
- en: The advanced Swift session presented in **Worldwide Developers Conference**
    (**WWDC**) 2014 ( [https://developer.apple.com/videos/play/wwdc2014-404/](https://developer.apple.com/videos/play/wwdc2014-404/))
    provides a very convenient function for memoization that can be used with any
    pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Watching the video is highly recommended. Let''s see if we could automatize
    this functionality and reuse it using the `memoize` function from that session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The function looks complex but don't worry, we will go through it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is a generic function. Do not worry about generics—we will
    cover generics in detail in [Chapter 5](ch05.html "Chapter 5. Generics and Associated
    Type Protocols"), *Generics and Associated Type Protocols*—and `Hashable` is used
    because we need to store `T` as a key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the signature of the function, we see that the `memoize` function
    takes a function (`fn`) with two parameters and a return type. So the signature
    of `fn`, which is a function, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of `fn` is a function of the `(T) -> U` type and the second
    parameter is of the `T` type and finally `fn` returns `U`.
  prefs: []
  type: TYPE_NORMAL
- en: OK, the `memoize` function received `fn`, which is described in the preceding
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the `memoize` function returns a function of the `(T) -> U` type.
    Now let's look at the body of the `memoize` function. First, we need to have a
    dictionary to cache the results. Second, we need to define the result type, which
    is a closure. In the closure body, we check whether we already have the key in
    our dictionary. If we do, we return it, otherwise, we call the function and save
    the result in our memo dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use this function to memoize the results of different function calls
    and improve the performance of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents the memoized version of the factorial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `memoize` function expects a closure as input, therefore, we can use the
    trailing closure syntax. In the preceding example, we provided the factorial function
    and `x` parameters as input to the closure and the line after the `in` keyword
    is the body of the closure. In the previous example, we used memoize for a recursive
    function and it works properly. Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `memoize` function to have a memoized version of
    the `powerOf2` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the memoize function once, we will be able to use it for any pure functions
    to cache the data and improve the performance of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by explaining function definition and usage in detail by
    giving examples for parameter and return types. Then it continued to cover functional
    programming-related concepts such as pure, first-class, higher-order, and nested
    functions. Finally, it covered function compositions, closures, currying, and
    memoization. At this point, we should be familiar with different types of functions
    and closures and their usages.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will cover types and explore the concept of value
    types versus reference types. Also, we will look at value type characteristics
    in detail and cover type equality, identity, and casting.
  prefs: []
  type: TYPE_NORMAL
