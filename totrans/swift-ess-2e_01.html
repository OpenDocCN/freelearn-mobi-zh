<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Exploring Swift</h1></div></div></div><p class="calibre8">Apple announced Swift at WWDC 2014 as a new programming language that combines experience with the Objective-C platform and advances in dynamic and statically typed languages over the last few decades. Before Swift, most code written for iOS and OS X applications was in Objective-C, a set of object-oriented extensions to the C programming language. Swift aims to build upon patterns and frameworks of Objective-C but with a more modern runtime and automatic memory management. In December 2015, Apple open sourced <a id="id0" class="calibre1"/>Swift <a id="id1" class="calibre1"/>at <a class="calibre1" href="https://swift.org">https://swift.org</a> and made binaries available for Linux as well as OS X. The content in this chapter can be run on either Linux or OS X, but the remainder of the book is either Xcode-specific or depends on iOS frameworks that are not open source. Developing iOS applications requires Xcode and OS X.</p><p class="calibre8">This chapter will present the following topics:</p><div><ul class="itemizedlist"><li class="listitem">How to use the Swift REPL to evaluate Swift code</li><li class="listitem">The different types of Swift literals</li><li class="listitem">How to use arrays and dictionaries</li><li class="listitem">Functions and the different types of function arguments</li><li class="listitem">Compiling and running Swift from the command line</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>Open source Swift</h1></div></div></div><p class="calibre8">Apple released <a id="id2" class="calibre1"/>Swift as an open source project in December 2015, hosted at <a class="calibre1" href="https://github.com/apple/swift/">https://github.com/apple/swift/</a> and related repositories. Information about the open source version of Swift is available from the <a class="calibre1" href="https://swift.org">https://swift.org</a> site. The<a id="id3" class="calibre1"/> open-source version of Swift is similar from a runtime perspective on both Linux and OS X; however, the set of libraries available differ between the two platforms.</p><p class="calibre8">For example, the Objective-C runtime was not present in the initial release of Swift for Linux; as a result, several methods that are delegated to Objective-C implementations are not available. <code class="literal">"hello".hasPrefix("he")</code> compiles and runs successfully on OS X and iOS <a id="id4" class="calibre1"/>but is a compile error in the first Swift release for Linux. In addition to missing functions, there is also a different set of modules (frameworks) between the two platforms. The base functionality on OS X and iOS is provided by the <code class="literal">Darwin</code> module, but on Linux, the base functionality is provided by the <code class="literal">Glibc</code> module. The <code class="literal">Foundation</code> module, which provides many of the data types that are outside of the base-collections library, is implemented in Objective-C on OS X and iOS, but on Linux, it is a clean-room reimplementation in Swift. As Swift on Linux evolves, more of this functionality will be filled in, but it is worth testing on both OS X and Linux specifically if cross platform functionality is required.</p><p class="calibre8">Finally, although the <a id="id5" class="calibre1"/>Swift language and core libraries have been open sourced, this does not apply to the iOS libraries or other functionality in Xcode. As a result, it is not possible to compile iOS or OS X applications from Linux, and building iOS applications and editing user interfaces is something that must be done in Xcode on OS X.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Getting started with Swift</h1></div></div></div><p class="calibre8">Swift provides a <a id="id6" class="calibre1"/>runtime interpreter that executes statements and expressions. Swift is <a id="id7" class="calibre1"/>open source, and precompiled binaries can be downloaded from <a class="calibre1" href="https://swift.org/download/">https://swift.org/download/</a> for both OS X and Linux platforms. Ports are in progress to other platforms and operating systems but are not supported by the Swift development team.</p><p class="calibre8">The Swift interpreter is called <em class="calibre11">swift</em> and on OS X can be launched using the <code class="literal">xcrun</code> command in a <code class="literal">Terminal.app</code> shell:</p><div><pre class="programlisting">
<strong class="calibre2">$ xcrun swift</strong>
<strong class="calibre2">Welcome to Swift version 2.2!  Type :help for assistance.</strong>
<strong class="calibre2">&gt;</strong>
</pre></div><p class="calibre8">The <code class="literal">xcrun</code> command allows a toolchain command to be executed; in this case, it finds <code class="literal">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift</code>. The <code class="literal">swift</code> command sits alongside other compilation tools, such as <code class="literal">clang</code> and <code class="literal">ld</code>, and permits multiple versions of the commands and libraries on the same machine without conflicting.</p><p class="calibre8">On Linux, the <code class="literal">swift</code> binary can be executed provided that it and the dependent libraries are in a suitable location.</p><p class="calibre8">The Swift prompt displays <code class="literal">&gt;</code> for new statements and <code class="literal">.</code> for a continuation. Statements and expressions that are typed into the interpreter are evaluated and displayed. Anonymous values are given references so that they can be used subsequently:</p><div><pre class="programlisting">&gt; "Hello World"
$R0: String = "Hello World"
&gt; 3 + 4
$R1: Int = 7
&gt; $R0
$R2: String = "Hello World"
&gt; $R1
$R3: Int = 7</pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Numeric literals</h2></div></div></div><p class="calibre8">Numeric types<a id="id8" class="calibre1"/> in Swift can represent both signed and unsigned integral <a id="id9" class="calibre1"/>values with sizes of 8, 16, 32, or 64 bits, as well as signed 32 or 64 bit floating point values. Numbers can include underscores to provide better readability; so, 68_040 is the same as 68040:</p><div><pre class="programlisting">&gt; 3.141
$R0: Double = 3.141
&gt; 299_792_458
$R1: Int = 299792458
&gt; -1
$R2: Int = -1
&gt; 1_800_123456
$R3: Int = 1800123456</pre></div><p class="calibre8">Numbers can also be written in<a id="id10" class="calibre1"/> <strong class="calibre2">binary</strong>, <strong class="calibre2">octal</strong>, or <strong class="calibre2">hexadecimal</strong> <a id="id11" class="calibre1"/>using prefixes <code class="literal">0b</code>, <code class="literal">0o</code> (zero and the letter "o") or <code class="literal">0x.</code> Please <a id="id12" class="calibre1"/>note that Swift does not inherit C's use of a leading zero (<code class="literal">0</code>) to represent an octal value, unlike Java and JavaScript which do. Examples include:</p><div><pre class="programlisting">&gt; 0b1010011
$R0: Int = 83
&gt; 0o123
$R1: Int = 83
&gt; 0123
$R2: Int = 123
&gt; 0x7b
$R3: Int = 123</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Floating point literals</h2></div></div></div><p class="calibre8">There are<a id="id13" class="calibre1"/> three floating point types that are available in Swift which <a id="id14" class="calibre1"/>use the IEEE754 floating point standard. The <code class="literal">Double</code> type represents 64 bits worth of data, while <code class="literal">Float</code> stores 32 bits of data. In addition, <code class="literal">Float80</code> is a specialized type that stores 80 bits worth of data (<code class="literal">Float32</code> and <code class="literal">Float64</code> are available as aliases for <code class="literal">Float</code> and <code class="literal">Double</code>, respectively, although they are not commonly used in Swift programs).</p><p class="calibre8">Some CPUs internally use 80 bit precision to perform math operations, and the <code class="literal">Float80</code> type allows this accuracy to be used in Swift. Not all architectures support <code class="literal">Float80</code> natively, so this should be used sparingly.</p><p class="calibre8">By default, floating point<a id="id15" class="calibre1"/> values in Swift use the <code class="literal">Double</code> type. As <a id="id16" class="calibre1"/>floating point representation cannot represent some numbers exactly, some values will be displayed with a rounding error; for example:</p><div><pre class="programlisting">&gt; 3.141
$R0: Double = 3.141
&gt; Float(3.141)
$R1: Float = 3.1400003</pre></div><p class="calibre8">Floating point values can be specified in decimal or hexadecimal. Decimal floating point uses <code class="literal">e</code> as the exponent for base 10, whereas hexadecimal floating point uses <code class="literal">p</code> as the exponent for base 2. A value of <code class="literal">AeB</code> has the value <code class="literal">A*10^B</code> and a value of <code class="literal">0xApB</code> has the value <code class="literal">A*2^B</code>. For example:</p><div><pre class="programlisting">&gt; 299.792458e6
$R0: Double = 299792458
&gt; 299.792_458_e6
$R1: Double = 299792458
&gt; 0x1p8
$R2: Double = 256
&gt; 0x1p10
$R3: Double = 1024
&gt; 0x4p10
$R4: Double = 4096
&gt; 1e-1
$R5: Double = 0.10000000000000001
&gt; 1e-2
$R6: Double = 0.01&gt; 0x1p-1
$R7: Double = 0.5
&gt; 0x1p-2
$R8: Double = 0.25
&gt; 0xAp-1
$R9: Double = 5</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>String literals</h2></div></div></div><p class="calibre8">Strings<a id="id17" class="calibre1"/> can contain escaped characters, Unicode characters, and interpolated<a id="id18" class="calibre1"/> expressions. Escaped characters start with a slash (\) and can be one of the following:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">\\</code>: This is a literal slash <code class="literal">\</code></li><li class="listitem"><code class="literal">\0</code>: This is the null character</li><li class="listitem"><code class="literal">\':</code> This is a literal single quote <code class="literal">'</code></li><li class="listitem"><code class="literal">\"</code>: This is a literal double quote <code class="literal">"</code></li><li class="listitem"><code class="literal">\t</code>: This is a tab</li><li class="listitem"><code class="literal">\n</code>: This is a line feed</li><li class="listitem"><code class="literal">\r</code>: This is a carriage return</li><li class="listitem"><code class="literal">\u{NNN}</code>: This is a Unicode character, such as the Euro symbol <code class="literal">\u{20AC}</code>, or a smiley <code class="literal">\u{1F600}</code></li></ul></div><p class="calibre8">An <em class="calibre11">interpolated string</em> has <a id="id19" class="calibre1"/>an embedded expression, which is evaluated, converted into a <code class="literal">String</code>, and inserted into the result:</p><div><pre class="programlisting">&gt; "3+4 is \(3+4)"
$R0: String = "3+4 is 7"
&gt; 3+4
$R1: Int = 7
&gt; "7 x 2 is \($R1 * 2)"
$R2: String = "7 x 2 is 14"</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec10" class="calibre1"/>Variables and constants</h2></div></div></div><p class="calibre8">Swift <a id="id20" class="calibre1"/>distinguishes between variables (which can be modified) and constants (which cannot be changed after assignment). Identifiers start with an underscore <a id="id21" class="calibre1"/>or alphabetic character followed by an underscore or alphanumeric character. In addition, other Unicode character points (such as emoji) can be used although box lines and arrows are not allowed; consult the Swift language guide for the full set of allowable Unicode characters. Generally, Unicode private use areas are not allowed, and identifiers cannot start with a combining character (such as an accent).</p><p class="calibre8">Variables are defined with the <code class="literal">var</code> keyword, and constants are defined with the <code class="literal">let</code> keyword. If the type is not specified, it is automatically inferred:</p><div><pre class="programlisting">&gt; let pi = 3.141
pi: Double = 3.141
&gt; pi = 3

error: cannot assign to value: 'pi' is a 'let' constant
note: change 'let' to 'var' to make it mutable
&gt; var i = 0
i: Int = 0
&gt; ++i
$R0: Int = 1</pre></div><p class="calibre8">Types can be explicitly specified. For example, to store a 32 bit floating point value, the variable can be explicitly defined as a <code class="literal">Float</code>:</p><div><pre class="programlisting">&gt; let e:Float = 2.718
e: Float = 2.71799994</pre></div><p class="calibre8">Similarly, to store a value as an unsigned 8 bit integer, explicitly declare the type as <code class="literal">UInt8</code>:</p><div><pre class="programlisting">&gt; let ff:UInt8 = 255
ff: UInt8 = 255</pre></div><p class="calibre8">A<a id="id22" class="calibre1"/> number <a id="id23" class="calibre1"/>can be converted to a different type using the type initializer or a literal that is assigned to a variable of a different type, provided that it does not underflow or overflow:</p><div><pre class="programlisting">&gt; let ooff = UInt16(ff)
ooff: UInt16 = 255
&gt; Int8(255)
error: integer overflows when converted from 'Int' to 'Int8'
Int8(255)
^
&gt; UInt8(Int8(-1))
error: negative integer cannot be converted to unsigned type 'UInt8'
UInt8(Int8(-1))
^</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec11" class="calibre1"/>Collection types</h2></div></div></div><p class="calibre8">Swift <a id="id24" class="calibre1"/>has <a id="id25" class="calibre1"/>three collection types: <em class="calibre11">Array</em>, <em class="calibre11">Dictionary</em>, and <em class="calibre11">Set</em>. They are strongly typed and generic, which ensures that the values of types that are assigned are compatible with the element type. Collections that are defined with <code class="literal">var</code> are mutable; collections defined with <code class="literal">let</code> are immutable.</p><p class="calibre8">The literal syntax for arrays uses <code class="literal">[]</code> to store a comma-separated list:</p><div><pre class="programlisting">&gt; var shopping = [ "Milk", "Eggs", "Coffee", ]
shopping: [String] = 3 values {
  [0] = "Milk"
  [1] = "Eggs"
  [2] = "Coffee"
}</pre></div><p class="calibre8">Literal dictionaries are defined with a comma-separated <code class="literal">[key:value]</code> format for entries:</p><div><pre class="programlisting">&gt; var costs = [ "Milk":1, "Eggs":2, "Coffee":3, ]
costs: [String : Int] = {
  [0] = { key = "Coffee" value = 3 }
  [1] = { key = "Milk"   value = 1 }
  [2] = { key = "Eggs"   value = 2 }
}</pre></div><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">For readability, array and dictionary literals can have a trailing comma. This allows initialization to be split over multiple lines, and if the last element ends with a trailing comma, adding new items does not result in an SCM diff to the previous line.</p></div><p class="calibre8">Arrays <a id="id26" class="calibre1"/>and <a id="id27" class="calibre1"/>dictionaries can be indexed using subscript operators that are reassigned and added to:</p><div><pre class="programlisting">&gt; shopping[0]
$R0: String = "Milk"
&gt; costs["Milk"]
$R1: Int? = 1
&gt; shopping.count
$R2: Int = 3
&gt; shopping += ["Tea"]
&gt; shopping.count
$R3: Int = 4
&gt; costs.count
$R4: Int = 3
&gt; costs["Tea"] = "String"
error: cannot assign a value of type 'String' to a value of type 'Int?'
&gt; costs["Tea"] = 4
&gt; costs.count
$R5: Int = 4</pre></div><p class="calibre8">Sets are similar to dictionaries; the keys are unordered and can be looked up efficiently. However, unlike dictionaries, keys don't have an associated value. As a result, they don't have array subscripts, but they do have the <code class="literal">insert</code>, <code class="literal">remove</code>, and <code class="literal">contains</code> methods. They also have efficient set intersection methods, such as <code class="literal">union</code> and <code class="literal">intersect</code>. They can be created from an array literal if the type is defined or using the set initializer directly:</p><div><pre class="programlisting">&gt; var shoppingSet: Set = [ "Milk", "Eggs", "Coffee", ]
&gt; // same as: shoppingSet = Set( [ "Milk", "Eggs", "Coffee", ] )
&gt; shoppingSet.contains("Milk")
$R6: Bool = true
&gt; shoppingSet.contains("Tea")
$R7: Bool = false
&gt; shoppingSet.remove("Coffee")
$R8: String? = "Coffee"
&gt; shoppingSet.remove("Tea")
$R9: String? = nil
&gt; shoppingSet.insert("Tea")
&gt; shoppingSet.contains("Tea")
$R10: Bool = true</pre></div><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">When creating sets, use the explicit <code class="literal">Set</code> constructor as otherwise the type will be inferred to be an <code class="literal">Array</code>, which will have a different performance profile.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec12" class="calibre1"/>Optional types</h2></div></div></div><p class="calibre8">In the <a id="id28" class="calibre1"/>previous example, the return type of <code class="literal">costs["Milk"]</code> is <code class="literal">Int?</code> and <a id="id29" class="calibre1"/>not <code class="literal">Int</code>. This is an <em class="calibre11">optional type</em>; there may be an <code class="literal">Int</code> value or it may be empty. For a dictionary containing elements of type <code class="literal">T</code>, subscripting the dictionary will have an <code class="literal">Optional&lt;T&gt;</code> type, which can be abbreviated as <code class="literal">T?</code> If the value doesn't exist in the dictionary, then the returned value will be <code class="literal">nil</code>. Other object-oriented languages, such as Objective-C, C++, Java, and C#, have optional types by default; any object value (or pointer) can be <code class="literal">null</code>. By representing optionality in the type system, Swift can determine whether a value really has to exist or might be <code class="literal">nil</code>:</p><div><pre class="programlisting">&gt; var cannotBeNil: Int = 1
cannotBeNil: Int = 1
&gt; cannotBeNil = nil
error: cannot assign a value of type 'nil' to a value of type 'Int'
cannotBeNil = nil
              ^
&gt; var canBeNil: Int? = 1
canBeNil: Int? = 1
&gt; canBeNil = nil
$R0: Int? = nil</pre></div><p class="calibre8">Optional types can be explicitly created using the <code class="literal">Optional</code> constructor. Given a value <code class="literal">x</code> of type <code class="literal">X</code>, an optional <code class="literal">X?</code> value can be created using <code class="literal">Optional(x)</code>. The value can be tested against <code class="literal">nil</code> to find out whether it contains a value and then unwrapped with <code class="literal">opt!</code>, for example:</p><div><pre class="programlisting">&gt; var opt = Optional(1)
opt: Int? = 1
&gt; opt == nil
$R1: Bool = false
&gt; opt!
$R2: Int = 1</pre></div><p class="calibre8">If a <code class="literal">nil</code> value is unwrapped, an error occurs:</p><div><pre class="programlisting">&gt; opt = nil
&gt; opt!
fatal error: unexpectedly found nil while unwrapping an Optional value
Execution interrupted. Enter Swift code to recover and continue.
Enter LLDB commands to investigate (type :help for assistance.)</pre></div><p class="calibre8">Particularly when <a id="id30" class="calibre1"/>working with Objective-C based APIs, it is common for values to be declared as <a id="id31" class="calibre1"/>an optional although they are always expected to return a value. It is possible to declare such variables as <em class="calibre11">implicitly unwrapped optionals</em>; these variables behave as optional values (they may contain <code class="literal">nil</code>), but when the value is accessed, they are automatically unwrapped on demand:</p><div><pre class="programlisting">&gt; var implicitlyUnwrappedOptional:Int! = 1
implicitlyUnwrappedOptional: Int! = 1
&gt; implicitlyUnwrappedOptional + 2
3
&gt; implicitlyUnwrappedOptional = nil
&gt; implicitlyUnwrappedOptional + 2
fatal error: unexpectedly found nil while unwrapping an Optional value</pre></div><div><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">In general, implicitly unwrapped optionals should be avoided as they are likely to lead to errors. They are mainly useful for interaction with existing Objective-C APIs when the value is known to have an instance.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec13" class="calibre1"/>Nil coalescing operator</h2></div></div></div><p class="calibre8">Swift <a id="id32" class="calibre1"/>has a <em class="calibre11">nil coalescing operator</em>, which is similar to Groovy's <code class="literal">?:</code> operator or C#'s <code class="literal">??</code> operator. This provides a means to specify a default value if an expression is <code class="literal">nil</code>:</p><div><pre class="programlisting">&gt; 1 ?? 2
$R0: Int = 1
&gt; nil ?? 2
$R1: Int = 2</pre></div><p class="calibre8">The <code class="literal">nil</code> coalescing operator<a id="id33" class="calibre1"/> can also be used to unwrap an optional value. If the optional value is present, it is unwrapped and returned; if it is missing, then the right-hand side of the expression is returned. Similar to the <code class="literal">||</code> shortcut, and the <code class="literal">&amp;&amp;</code> operators, the right-hand side is not evaluated unless necessary:</p><div><pre class="programlisting">&gt; costs["Tea"] ?? 0
$R2: Int = 4
&gt; costs["Sugar"] ?? 0
$R3: Int = 0</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Conditional logic</h1></div></div></div><p class="calibre8">There are <a id="id34" class="calibre1"/>three key types of conditional logic in Swift (known as branch statements in the grammar): the <code class="literal">if</code> statement, the <code class="literal">switch</code> statement, and the <code class="literal">guard</code> statement. Unlike other languages, the body of the <code class="literal">if</code> must be surrounded with braces <code class="literal">{}</code>; and if typed in at the interpreter, the <code class="literal">{</code> opening brace must be on the same line as the <code class="literal">if</code> statement. The <code class="literal">guard</code> statement is a specialized <code class="literal">if</code> statement for use with functions and is covered in the section on functions later in this chapter.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec14" class="calibre1"/>If statements</h2></div></div></div><p class="calibre8">Conditionally<a id="id35" class="calibre1"/> unwrapping an optional value is so common that a specific Swift pattern <em class="calibre11">optional binding</em> has been created to avoid evaluating the expression twice:</p><div><pre class="programlisting">&gt; var shopping = [ "Milk", "Eggs", "Coffee", "Tea", ]
&gt; var costs = [ "Milk":1, "Eggs":2, "Coffee":3, "Tea":4, ]
&gt; var cost = 0
&gt; if let cc = costs["Coffee"] {
.   cost += cc
. }
&gt; cost
$R0: Int = 3</pre></div><p class="calibre8">The <code class="literal">if</code> block only executes if the optional value exists. The definition of the <code class="literal">cc</code> constant only exists for the body of the <code class="literal">if</code> block, and it does not exist outside of that scope. Furthermore, <code class="literal">cc</code> is a non-optional type, so it is guaranteed not to be <code class="literal">nil</code>.</p><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">Swift 1 only allowed a single <code class="literal">let</code> assignment in an <code class="literal">if</code> block causing a pyramid of nested <code class="literal">if</code> statements. Swift 2 allows multiple comma-separated <code class="literal">let</code> assignments in a single <code class="literal">if</code> statement.</p><div><pre class="programlisting">&gt; if let cm = costs["Milk"], let ct = costs["Tea"] {
.   cost += cm + ct
. }
&gt; cost
$R1: Int = 8</pre></div></div><p class="calibre8">To execute an alternative block if the item cannot be found, an <code class="literal">else</code> block can be used:</p><div><pre class="programlisting">&gt; if let cb = costs["Bread"] {
.   cost += cb
. } else {
.   print("Cannot find any Bread")
. }
Cannot find any Bread</pre></div><p class="calibre8">Other boolean <a id="id36" class="calibre1"/>expressions can include the <code class="literal">true</code> and <code class="literal">false</code> literals, and any expression that conforms to the <code class="literal">BooleanType</code> protocol, the <code class="literal">==</code> and <code class="literal">!=</code> equality operators, the <code class="literal">===</code> and <code class="literal">!==</code> identity operators, as well as the <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> comparison operators. The <code class="literal">is type</code> operator provides a test to see whether an element is of a particular type.</p><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">The difference between the equality operator and the identity operator is relevant for classes or other reference types. The equality operator asks <em class="calibre11">Are these two values equivalent to each other?</em>, whereas the identity operator asks <em class="calibre11">Are these two references equal to each other?</em>
</p></div><p class="calibre8">There is a boolean operator that is specific to Swift, which is the <code class="literal">~=</code> <em class="calibre11">pattern match operator</em>. Despite the name, this isn't anything to do with regular expressions; rather, it's a way of asking whether a pattern matches a particular value. This is used in the implementation of the <code class="literal">switch</code> block, which is covered in the next section.</p><p class="calibre8">As well as the <code class="literal">if</code> statement, there is a <em class="calibre11">ternary if expression</em> that is similar to other languages. After a condition, a question mark (?) is used followed by an expression to be used if the condition is true, then a colon (:) followed by the false expression:</p><div><pre class="programlisting">&gt; var i = 17
i: Int = 17
&gt; i % 2 == 0 ? "Even" : "Odd"
$R0: String = "Odd"</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec15" class="calibre1"/>Switch statements</h2></div></div></div><p class="calibre8">Swift has a<a id="id37" class="calibre1"/> <code class="literal">switch</code> statement that is similar to C and Java's <code class="literal">switch</code>. However, it differs in two important ways. Firstly, <code class="literal">case</code> statements no longer have a default fall-through behavior (so there are no bugs introduced by missing a <code class="literal">break</code> statement), and secondly, the value of the <code class="literal">case</code> statements can be expressions instead of values, pattern matching on type and range. At the end of the corresponding <code class="literal">case</code> statement, the evaluation jumps to the end of the <code class="literal">switch</code> block unless the <code class="literal">fallthrough</code> keyword is used. If no <code class="literal">case</code> statements match, the <code class="literal">default</code> statements are executed.</p><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">A <code class="literal">default</code> statement is required when the list of cases is not exhaustive. If they are not, the compiler will give an error saying that the list is not exhaustive and that a <code class="literal">default</code> statement is required.</p></div><div><pre class="programlisting">&gt; var position = 21
position: Int = 21
&gt; switch position {
.   case 1: print("First")
.   case 2: print("Second")
.   case 3: print("Third")
.   case 4...20: print("\(position)th")
.   case position where (position % 10) == 1:
.     print("\(position)st")
.   case let p where (p % 10) == 2:
.     print("\(p)nd")
.   case let p where (p % 10) == 3:
.     print("\(p)rd")
.   default: print("\(position)th")
. }
21st</pre></div><p class="calibre8">In the preceding <a id="id38" class="calibre1"/>example, the expression prints out <code class="literal">First</code>, <code class="literal">Second</code>, or <code class="literal">Third</code> if the position is <code class="literal">1</code>, <code class="literal">2</code>, or <code class="literal">3</code>, respectively. For numbers between <code class="literal">4</code> and <code class="literal">20</code> (inclusive), it prints out the position with a <code class="literal">th</code> ordinal. Otherwise, for numbers that end with 1, it prints <code class="literal">st</code>; for numbers that end with 2, it prints <code class="literal">nd</code>, and for numbers that end with 3, it prints <code class="literal">rd</code>. For all other numbers it prints <code class="literal">th</code>.</p><p class="calibre8">The <code class="literal">4...20</code> range expression in a <code class="literal">case</code> statement represents a pattern. If the value of the expression matches that pattern, then the corresponding statements will be executed:</p><div><pre class="programlisting">&gt; 4...10 ~= 4
$R0: Bool = true
&gt; 4...10 ~= 21
$R1: Bool = false</pre></div><p class="calibre8">There are two range operators in Swift: an inclusive or <em class="calibre11">closed range</em>, and an exclusive or <em class="calibre11">half-open range</em>. The closed range is specified with three dots; so <code class="literal">1...12</code> will give a list of integers between one and twelve. The half-open range is specified with two dots and a less than operator; so <code class="literal">1..&lt;10</code> will provide integers from 1 to 9 but excluding 10.</p><p class="calibre8">The <code class="literal">where</code> clause in the <code class="literal">switch</code> block allows an arbitrary expression to be evaluated provided that the pattern matches. These are evaluated in order, in the sequence they are in the source file. If a <code class="literal">where</code> clause evaluates to <code class="literal">true</code>, then the corresponding set of statements will be executed.</p><p class="calibre8">The <code class="literal">let</code> variable syntax can be used to define a constant that refers to the value in the <code class="literal">switch</code> block. This local constant can be used in the <code class="literal">where</code> clause or the corresponding statements for that specific case. Alternatively, variables can be used from the surrounding scope.</p><div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">If multiple <code class="literal">case</code> statements need to match the same pattern, they can be separated with commas as an expression list. Alternatively, the <code class="literal">fallthrough</code> keyword can be used to allow the same implementation to be used for multiple <code class="literal">case</code> statements.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Iteration</h1></div></div></div><p class="calibre8">Ranges can <a id="id39" class="calibre1"/>be used to iterate a fixed number of times, for example, <code class="literal">for i in 1...12</code>. To print out these numbers, a loop such as the following can be used:</p><div><pre class="programlisting">&gt; for i in 1...12 {
.   print("i is \(i)")
. }</pre></div><p class="calibre8">If the number is not required, then an underscore (<code class="literal">_</code>) can be used as a hole to act as a throwaway value. An underscore can be assigned to but not read:</p><div><pre class="programlisting">&gt; for _ in 1...12 {
.   print("Looping...")
. }</pre></div><p class="calibre8">However, it is more common to iterate over a collection's contents using a <code class="literal">for in</code> pattern. This steps through each of the items in the collection, and the body of the <code class="literal">for</code> loop is executed over each one:</p><div><pre class="programlisting">&gt; var shopping = [ "Milk", "Eggs", "Coffee", "Tea", ]
&gt; var costs = [ "Milk":1, "Eggs":2, "Coffee":3, "Tea":4, ]
&gt; var cost = 0
&gt; for item in shopping {
.   if let itemCost = costs[item] {
.     cost += itemCost
.   }
. }
&gt; cost
cost: Int = 10</pre></div><p class="calibre8">To iterate over a dictionary, it is possible to extract the keys or the values and process them as an array:</p><div><pre class="programlisting">&gt; Array(costs.keys)
$R0: [String] = 4 values {
  [0] = "Coffee"
  [1] = "Milk"
  [2] = "Eggs"
  [3] = "Tea"
}
&gt; Array(costs.values)
$R1: [Int] = 4 values {
  [0] = 3
  [1] = 1
  [2] = 2
  [3] = 4
}</pre></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">The order of keys in a dictionary is not guaranteed; as the dictionary changes, the order may change.</p></div><p class="calibre8">Converting a<a id="id40" class="calibre1"/> dictionary's values to an array will result in a copy of the data being made, which can lead to poor performance. As the underlying <code class="literal">keys</code> and <code class="literal">values</code> are of a <code class="literal">LazyMapCollection</code> type, they can be iterated over directly:</p><div><pre class="programlisting">&gt; costs.keys
$R2: LazyMapCollection&lt;[String : Int], String&gt; = {
  _base = {
    _base = 4 key/value pairs {
      [0] = { key = "Coffee" value = 3 }
      [1] = { key = "Milk"   value = 1 }
      [2] = { key = "Eggs"   value = 2 }
      [3] = { key = "Tea"    value = 4 }
    }
  _transform =}
}</pre></div><p class="calibre8">To print out all the keys in a dictionary, the <code class="literal">keys</code> property can be used with a <code class="literal">for in</code> loop:</p><div><pre class="programlisting">&gt; for item in costs.keys {
.   print(item)
. }
Coffee
Milk
Eggs
Tea</pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec16" class="calibre1"/>Iterating over keys and values in a dictionary</h2></div></div></div><p class="calibre8">Traversing a <a id="id41" class="calibre1"/>dictionary to obtain all of the keys and then subsequently looking up values will result in searching the data structure twice. Instead, both the key and the value can be iterated at the same time, using a <em class="calibre11">tuple</em>. A tuple is like a fixed-sized array, but one that allows assigning pairs (or more) of values at a time:</p><div><pre class="programlisting">&gt; var (a,b) = (1,2)
a: Int = 1
b: Int = 2</pre></div><p class="calibre8">Tuples can be used to iterate pairwise over both the keys and values of a dictionary:</p><div><pre class="programlisting">&gt; for (item,cost) in costs {
.   print("The \(item) costs \(cost)")
. }
The Coffee costs 3
The Milk costs 1
The Eggs costs 2
The Tea costs 4</pre></div><p class="calibre8">Both <code class="literal">Array</code> and <code class="literal">Dictionary</code> conform to the <code class="literal">SequenceType</code> protocol, which allows them to be iterated <a id="id42" class="calibre1"/>with a <code class="literal">for in</code> loop. Collections (as well as other objects, such as <code class="literal">Range</code>) that implement <code class="literal">SequenceType</code> have a <code class="literal">generate</code> method, which returns a <code class="literal">GeneratorType</code> that allows the data to be iterated over. It is possible for custom Swift objects to implement <code class="literal">SequenceType</code> to allow them to be used in a <code class="literal">for in</code> loop.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec17" class="calibre1"/>Iteration with for loops</h2></div></div></div><p class="calibre8">Although the most common use of the <code class="literal">for</code> operator in Swift is in a <code class="literal">for in</code> loop, it is also possible (in Swift 1 and 2) to use a more traditional form of the <code class="literal">for</code> loop. This has an initialization, a condition that is tested at the start of each loop, and a step operation that is evaluated at the end of each loop. Although the parentheses around the <code class="literal">for</code> loop are optional, the braces for the block of code are mandatory.</p><div><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">It has been proposed that both the traditional <code class="literal">for</code> loop and the increment/decrement operators should be removed from Swift 3. It is recommended that these forms of loops be avoided where possible.</p></div><p class="calibre8">Calculating<a id="id43" class="calibre1"/> the sum of integers between 1 and 10 can be performed without using the range operator:</p><div><pre class="programlisting">&gt; var sum = 0
. for var i=0; i&lt;=10; ++i {
.   sum += i
. }
sum: Int = 55</pre></div><p class="calibre8">If multiple variables need to be updated in the <code class="literal">for</code> loop, Swift has an <em class="calibre11">expression list</em> that is a set of comma-separated expressions. To step through two sets of variables in a for loop, the following can be used:</p><div><pre class="programlisting">&gt; for var i = 0,j = 10; i&lt;=10 &amp;&amp; j &gt;= 0; ++i,--j {
.   print("\(i), \(j)")
. } 
0, 10
1, 9
…
9, 1
10, 0</pre></div><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">Apple recommends the use of <code class="literal">++i</code> instead of <code class="literal">i++</code> (and conversely, <code class="literal">--i</code> instead of <code class="literal">i--</code>) because they will return the result of <code class="literal">i</code> after the operation, which may be the expected value. As noted earlier, these operators may be removed in a future version of Swift.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec18" class="calibre1"/>Break and continue</h2></div></div></div><p class="calibre8">The <code class="literal">break</code> statement<a id="id44" class="calibre1"/> leaves the innermost loop early, and control jumps to the end of the loop. The <code class="literal">continue</code> statement<a id="id45" class="calibre1"/> takes execution to the top of the innermost loop and the next item.</p><p class="calibre8">To <em class="calibre11">break</em> or <em class="calibre11">continue</em> from nested loops, a <em class="calibre11">label</em> can be used. Labels in Swift can only be applied to a loop statement, such as <code class="literal">while</code> or <code class="literal">for</code>. A label is introduced by an identifier and a colon just before the loop statement:</p><div><pre class="programlisting">&gt; var deck = [1...13, 1...13, 1...13, 1...13]
&gt; suits: for suit in deck {
.   for card in suit {
.     if card == 3 {
.       continue // go to next card in same suit
.     }
.     if card == 5 {
.       continue suits // go to next suit
.     } 
.     if card == 7 {
.       break // leave card loop
.     }
.     if card == 13 {
.       break suits // leave suit loop
.     }
.   } 
. }</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Functions</h1></div></div></div><p class="calibre8">Functions can<a id="id46" class="calibre1"/> be created using the <code class="literal">func</code> keyword, which takes a set of arguments and a body of statements. The <code class="literal">return</code> statement can be used to leave a function:</p><div><pre class="programlisting">&gt; var shopping = [ "Milk", "Eggs", "Coffee", "Tea", ]
&gt; var costs = [ "Milk":1, "Eggs":2, "Coffee":3, "Tea":4, ]
&gt; func costOf(items:[String], _ costs:[String:Int]) -&gt; Int {
.   var cost = 0
.   for item in items {
.     if let ci = costs[item] {
.       cost += ci
.     }
.   }
.   return cost
. }
&gt; costOf(shopping,costs)
$R0: Int = 10</pre></div><p class="calibre8">The return type of the function is specified after the arguments with an arrow (<code class="literal">-&gt;</code>). If missing, the function cannot return a value; if present, the function must return a value of that type.</p><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">The underscore (<code class="literal">_</code>) on the front of the <code class="literal">costs</code> parameter is required to avoid it being a named argument. The second and subsequent arguments in Swift functions are implicitly named. To ensure that it is treated as a positional argument, the <code class="literal">_</code> before the argument name is required.</p></div><p class="calibre8">Functions with <em class="calibre11">positional arguments</em> can be called with parentheses, such as the <code class="literal">costOf(shopping,costs)</code> call. If a function takes no arguments, then the parentheses are still required.</p><p class="calibre8">The <code class="literal">foo()</code> expression calls the <code class="literal">foo</code> function with no argument. The <code class="literal">foo</code> expression represents the function itself, so an expression, such as <code class="literal">let copyOfFoo = foo</code>, results in a copy of the function; as a result, <code class="literal">copyOfFoo()</code> and <code class="literal">foo()</code> have the same effect.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec19" class="calibre1"/>Named arguments</h2></div></div></div><p class="calibre8">Swift<a id="id47" class="calibre1"/> also supports <em class="calibre11">named arguments</em>, which can either use the name of the variable or can be defined with an <em class="calibre11">external parameter name</em>. To modify the function to support calling with <code class="literal">basket</code> and <code class="literal">prices</code> as argument names, the following can be done:</p><div><pre class="programlisting">&gt; func costOf(basket items:[String], prices costs:[String:Int]) -&gt; Int {
.   var cost = 0
.   for item in items {
.     if let ci = costs[item] {
.       cost += ci
.     }
.   }
.   return cost
. }
&gt; costOf(basket:shopping, prices:costs)
$R1: Int = 10</pre></div><p class="calibre8">This example<a id="id48" class="calibre1"/> defines external parameter names <code class="literal">basket</code> and <code class="literal">prices</code> for the function. The function signature is often referred to as <code class="literal">costOf(basket:prices:)</code> and is useful when it may not be clear what the arguments are for (particularly if they are of the same type).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec20" class="calibre1"/>Optional arguments and default values</h2></div></div></div><p class="calibre8">Swift functions can have <em class="calibre11">optional arguments</em> by specifying <em class="calibre11">default values</em> in the function definition. When the function is called, if an optional argument is missing, the default value for that argument is used.</p><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">An optional argument is one that can be omitted in the function call rather than a required argument that takes an optional value. This naming is unfortunate. It may help to think of these as default arguments rather than optional arguments.</p></div><p class="calibre8">A<a id="id49" class="calibre1"/> default parameter value is specified after the type in the function signature, with an equals (<code class="literal">=</code>) and then the expression. This expression is re-evaluated each time the<a id="id50" class="calibre1"/> function is called without a corresponding argument.</p><p class="calibre8">In the <code class="literal">costOf</code> example, instead of passing the value of <code class="literal">costs</code> each time, it could be defined with a default parameter:</p><div><pre class="programlisting">&gt; func costOf(items items:[String], costs:[String:Int] = costs) -&gt; Int {
.   var cost = 0
.   for item in items {
.     if let ci = costs[item] {
.       cost += ci
.     }
.   }
.   return cost
. }
&gt; costOf(items:shopping)
$R2: Int = 10
&gt; costOf(items:shopping, costs:costs)
$R3: Int = 10</pre></div><p class="calibre8">Please note that <a id="id51" class="calibre1"/>the captured <code class="literal">costs</code> variable is bound when the function is defined.</p><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">To use a named argument as the first parameter in a function, the argument name has to be duplicated. Swift 1 used a hash (<code class="literal">#</code>) to represent an implicit parameter name, but this was removed from Swift 2.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec21" class="calibre1"/>Guards</h2></div></div></div><p class="calibre8">It is a common<a id="id52" class="calibre1"/> code pattern for a function to require arguments that meet certain conditions before the function can run successfully. For example, an optional value must have a value or an integer argument must be in a certain range.</p><p class="calibre8">Typically, the pattern to implement this is either to have a number of <code class="literal">if</code> statements that break out of the function at the top, or to have an <code class="literal">if</code> block wrapping the entire method body:</p><div><pre class="programlisting">if card &lt; 1 || card &gt; 13 {
  // report error
  return
}

// or alternatively:

if card &gt;= 1 &amp;&amp; card &lt;= 13 {
  // do something with card
} else {
  // report error
}</pre></div><p class="calibre8">Both of these approaches have drawbacks. In the first case, the condition has been negated; instead of looking for valid values, it's checking for invalid values. This can cause subtle bugs to creep in; for example, <code class="literal">card &lt; 1 &amp;&amp; card &gt; 13</code> would never succeed, but it may inadvertently pass a code review. There's also the problem of what happens if the block doesn't <code class="literal">return</code> or <code class="literal">break</code>; it could be perfectly valid Swift code but still include errors.</p><p class="calibre8">In the second case, the main body of the function is indented at least one level in the body of the <code class="literal">if</code> statement. When multiple conditions are required, there may be many nested <code class="literal">if</code> statements, each with their own error handling or cleanup requirements. If new conditions are required, then the body of the code may be indented even further, leading to code churn in the repository even when only whitespace has changed.</p><p class="calibre8">Swift 2 adds a <code class="literal">guard</code> statement<a id="id53" class="calibre1"/>, which is conceptually identical to an <code class="literal">if</code> statement, except that it only has an <code class="literal">else</code> clause body. In addition, the compiler checks that the <code class="literal">else</code> block returns from the function, either by returning or by throwing an exception:</p><div><pre class="programlisting">&gt; func cardName(value:Int) -&gt; String {
.   guard value &gt;= 1 &amp;&amp; value &lt;= 13 else {
.     return "Unknown card"
.   }
.   let cardNames = [11:"Jack",12:"Queen",13:"King",1:"Ace",]
.   return cardNames[value] ?? "\(value)"
. }</pre></div><p class="calibre8">The Swift compiler checks that the <code class="literal">guard</code> <code class="literal">else</code> block leaves the function, and reports a compile error if it does not. Code that appears after the <code class="literal">guard</code> statement can guarantee that the value is in the <code class="literal">1...13</code> range without having to perform further tests.</p><p class="calibre8">The <code class="literal">guard</code> block can also be used to perform <em class="calibre11">optional binding</em>; if the <code class="literal">guard</code> condition is a <code class="literal">let</code> assignment that performs an optional test, then the code that is subsequent to the <code class="literal">guard</code> statement can use the value without further unwrapping:</p><div><pre class="programlisting">&gt; func firstElement(list:[Int]) -&gt; String {
.   guard let first = list.first else {
.     return "List is empty"
.   }
.   return "Value is \(first)"
. }</pre></div><p class="calibre8">As the <code class="literal">first</code> element of an array is an optional value, the <code class="literal">guard</code> test here acquires the value and unwraps it. When it is used later in the function, the unwrapped value is available for use without requiring further unwrapping.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec22" class="calibre1"/>Multiple return values and arguments</h2></div></div></div><p class="calibre8">So far, the <a id="id54" class="calibre1"/>examples of functions have all returned a single type. What happens if there is more than one return result from a function? In an object-oriented language, the answer is to return a class; however, Swift has tuples, which can be used to return multiple values. The type of a tuple is the type of its constituent parts:</p><div><pre class="programlisting">&gt; var pair = (1,2)
pair: (Int, Int) ...</pre></div><p class="calibre8">This can be used to return multiple values from the function; instead of just returning one value, it is possible to return a tuple of values.</p><div><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">Swift also has in-out arguments, which will be seen in the <em class="calibre11">Handling errors</em> section of <a class="calibre1" title="Chapter 6. Parsing Networked Data" href="part0045_split_000.html#1AT9A2-d7e55eb5242648e89c396442afe4f84b">Chapter 6</a>, <em class="calibre11">Parsing Networked Data</em>.</p></div><p class="calibre8">Separately, it <a id="id55" class="calibre1"/>is also possible to take a variable number of arguments. A function can easily take an array of values with <code class="literal">[]</code>, but Swift provides a mechanism to allow calling with multiple arguments, using a <em class="calibre11">variadic</em> parameter, which is denoted as an ellipses (…) after the type. The value can then be used as an array in the function.</p><div><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">Swift 1 only allowed the variadic argument as the last argument; Swift 2 relaxed that restriction to allow a single variadic argument to appear anywhere in the function's parameters.</p></div><p class="calibre8">Taken together, these two features allow the creation of a <code class="literal">minmax</code> function, which returns both the minimum and maximum from a list of integers:</p><div><pre class="programlisting">&gt; func minmax(numbers:Int…) -&gt; (Int,Int) {
.   var min = Int.max
.   var max = Int.min
.   for number in numbers {
.     if number &lt; min {
.       min = number
.     }
.     if number &gt; max {
.       max = number
.     }
.   }
.   return (min,max)
. }
&gt; minmax(1,2,3,4)
$R0: (Int, Int) = {
  0 = 1
  1 = 4
}</pre></div><p class="calibre8">The <code class="literal">numbers:Int…</code> argument indicates that a variable number of arguments can be passed into the function. Inside the function, it is processed as an ordinary array; in this case, iterating through using a <code class="literal">for in</code> loop.</p><div><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">
<code class="literal">Int.max</code> is a constant representing the largest <code class="literal">Int</code> value, and <code class="literal">Int.min</code> is a constant representing the smallest <code class="literal">Int</code> value. Similar constants exist for other integral types, such as <code class="literal">UInt8.max</code>, and <code class="literal">Int64.min</code>.</p></div><p class="calibre8">What if no arguments are passed in? If run on a 64 bit system, then the output will be:</p><div><pre class="programlisting">&gt; minmax()
$R1: (Int, Int) = {
  0 = 9223372036854775807
  1 = -9223372036854775808
}</pre></div><p class="calibre8">This may not make <a id="id56" class="calibre1"/>sense for a <code class="literal">minmax</code> function. Instead of returning an error value or a default value, the type system can be used. By making the tuple optional, it is possible to return a <code class="literal">nil</code> value if it doesn't exist, or a tuple if it does:</p><div><pre class="programlisting">&gt; func minmax(numbers:Int...) -&gt; (Int,Int)? {
.   var min = Int.max
.   var max = Int.min
.   if numbers.count == 0 {
.     return nil
.   } else {
.     for number in numbers {
.       if number &lt; min {
.         min = number
.       }
.       if number &gt; max {
.         max = number
.       }
.     }
.     return(min,max)
.   }
. }
&gt; minmax()
$R2: (Int, Int)? = nil
&gt; minmax(1,2,3,4)
$R3: (Int, Int)? = (0 = 1, 1 = 4)
&gt; var (minimum,maximum) = minmax(1,2,3,4)!
minimum: Int = 1
maximum: Int = 4</pre></div><p class="calibre8">Returning an optional value allows the caller to determine what should happen in cases where the maximum and minimum are not present.</p><div><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">If a function does not always have a valid return value, use an optional type to encode that possibility into the type system.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec23" class="calibre1"/>Returning structured values</h2></div></div></div><p class="calibre8">A tuple is an <a id="id57" class="calibre1"/>ordered set of data. The entries in the tuple are ordered, but it can quickly become unclear as to what data is stored, particularly if they are of the same type. In the <code class="literal">minmax</code> tuple, it is not clear which value is the minimum and which value is the maximum, and this can lead to subtle programming errors later on.</p><p class="calibre8">A structure (<code class="literal">struct</code>) is like a tuple but with named values. This allows members to be accessed by name instead of by position, leading to fewer errors and greater transparency. Named values can be added to tuples as well; in essence, tuples with named values are anonymous structures.</p><div><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">Structs are passed in a copy-by-value manner like tuples. If two variables are assigned the same struct or tuple, then changes to one do not affect the values of another.</p></div><p class="calibre8">A <code class="literal">struct</code> is defined with the <code class="literal">struct</code> keyword and has variables or values in the body:</p><div><pre class="programlisting">&gt; struct MinMax {
.   var min:Int
.   var max:Int
. }</pre></div><p class="calibre8">This defines a <code class="literal">MinMax</code> type, which can be used in place of any of the types that are seen so far. It can be used in the <code class="literal">minmax</code> function to return a <code class="literal">struct</code> instead of a tuple:</p><div><pre class="programlisting">&gt; func minmax(numbers:Int...) -&gt; MinMax? {
.   var minmax = MinMax(min:Int.max, max:Int.min)
.   if numbers.count == 0 {
.     return nil
.   } else {
.     for number in numbers {
.       if number &lt; minmax.min {
.         minmax.min = number
.       }
.       if number &gt; minmax.max {
.         minmax.max = number
.       }
.     }
.     return minmax
.   }
. }</pre></div><p class="calibre8">The <code class="literal">struct</code> is initialized with a type initializer; if <code class="literal">MinMax()</code> is used, then the default values for each of the structure types are given (based on the structure definition), but these can be overridden explicitly if desired with <code class="literal">MinMax(min:-10,max:11)</code>. For example, if the <code class="literal">MinMax</code> struct is defined as <code class="literal">struct MinMax { var min:Int = Int.max; var max:Int = Int.min }</code>, then <code class="literal">MinMax()</code> will return a structure with the appropriate minimum <a id="id58" class="calibre1"/>and maximum values filled in.</p><div><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">When a structure is initialized, all the non-optional fields must be assigned. They can be passed in as named arguments in the initializer or specified in the structure definition.</p></div><p class="calibre8">Swift also has classes; these are covered in the Swift classes section in the next chapter.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec24" class="calibre1"/>Error handling</h2></div></div></div><p class="calibre8">In the <a id="id59" class="calibre1"/>original Swift release, error handling consisted of either returning a <code class="literal">Bool</code> or an optional value from function results. This tended to work inconsistently with Objective-C, which used an optional <code class="literal">NSError</code> pointer on various calls that was set if a condition had occurred.</p><p class="calibre8">Swift 2 adds an exception-like error model, which allows code to be written in a more compact way while ensuring that errors are handled accordingly. Although this isn't implemented in quite the same way as C++ exception handling, the semantics of the error handling are quite similar.</p><p class="calibre8">Errors can be created using a new <code class="literal">throw</code> keyword, and errors are stored as a subtype of <code class="literal">ErrorType</code>. Although swift <code class="literal">enum</code> values (covered in <a class="calibre1" title="Chapter 3. Creating an iOS Swift App" href="part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b">Chapter 3</a>, <em class="calibre11">Creating an iOS Swift App</em>) are often used as error types, <code class="literal">struct</code> values can be used as well.</p><p class="calibre8">Exception types can be created as subtypes of <code class="literal">ErrorType</code> by appending the supertype after the type name:</p><div><pre class="programlisting">&gt; struct Oops:ErrorType {
.   let message:String
. }</pre></div><p class="calibre8">Exceptions are thrown using the <code class="literal">throw</code> keyword and creating an instance of the exception type:</p><div><pre class="programlisting">&gt; throw Oops(message:"Something went wrong")
$E0: Oops = {
  message = "Something went wrong"
}</pre></div><div><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">The REPL displays exception results with the <code class="literal">$E</code> prefix; ordinary results are displayed with the <code class="literal">$R</code> prefix.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec25" class="calibre1"/>Throwing errors</h2></div></div></div><p class="calibre8">Functions <a id="id60" class="calibre1"/>can declare that they return an error using the <code class="literal">throws</code> keyword before the return type, if any. The previous <code class="literal">cardName</code> function, which returned a dummy value if the argument was out of range, can be upgraded to throw an exception instead by adding the <code class="literal">throws</code> keyword before the return type and changing the <code class="literal">return</code> to a <code class="literal">throw</code>:</p><div><pre class="programlisting">&gt; func cardName(value:Int) <strong class="calibre2">throws</strong> -&gt; String {
.   guard value &gt;= 1 &amp;&amp; value &lt;= 13 else {
.     <strong class="calibre2">throw Oops(message:"Unknown card")</strong>
.   }
.   let cardNames = [11:"Jack",12:"Queen",13:"King",1:"Ace",]
.   return cardNames[value] ?? "\(value)"
. }</pre></div><p class="calibre8">When the function is called with a real value, the result is returned; when it is passed an invalid value, an exception is thrown instead:</p><div><pre class="programlisting">&gt; cardName(1)
$R1: String = "Ace"
&gt; cardName(15)
$E2: Oops = {
  message = "Unknown card"
}</pre></div><p class="calibre8">When interfacing with Objective-C code, methods that take an <code class="literal">NSError**</code> argument are automatically represented in Swift as methods that throw. In general, any method whose arguments ends in <code class="literal">NSError**</code> is treated as throwing an exception in Swift.</p><div><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">Exception throwing in C++ and Objective-C is not as performant as exception handling in Swift because the latter does not perform stack unwinding. As a result, exception throwing in Swift is equivalent (from a performance perspective) to dealing with return values. Expect the Swift library to evolve in the future towards a throws-based means of error detection and away from Objective-C's use of <code class="literal">**NSError</code> pointers.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_8"><a id="ch01lvl2sec26" class="calibre1"/>Catching errors</h2></div></div></div><p class="calibre8">The other <a id="id61" class="calibre1"/>half of exception handling is the ability to catch errors when they occur. As with other languages, Swift now has a <code class="literal">try/catch</code> block that can be used to handle error conditions. Unlike other languages, the syntax is a little different; instead of a <code class="literal">try/catch</code> block, there is a <code class="literal">do/catch</code> block, and each expression that may throw an error is annotated with its own <code class="literal">try</code> statement:</p><div><pre class="programlisting">&gt; do { 
.   let name = try cardName(15)
.   print("You chose \(name)")
. } catch {
.   print("You chose an invalid card")
. }</pre></div><p class="calibre8">When the<a id="id62" class="calibre1"/> preceding code is executed, it will print out the generic error message. If a different choice is given, then it will run the successful path instead.</p><p class="calibre8">It's possible to capture the error object and use it in the catch block:</p><div><pre class="programlisting">. } catch let e {
.   print("There was a problem \(e)")
. }</pre></div><div><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">The default <code class="literal">catch</code> block will bind to a variable called <code class="literal">error</code> if not specified</p></div><p class="calibre8">Both of these two preceding examples will catch any errors thrown from the body of the code.</p><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">It's possible to catch explicitly based on type if the type is an <code class="literal">enum</code> that is using pattern matching, for example, <code class="literal">catch Oops(let message)</code>. However, as this does not work for struct values, it cannot be tested here. <a class="calibre1" title="Chapter 3. Creating an iOS Swift App" href="part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b">Chapter 3</a>, <em class="calibre11">Creating an iOS Swift App</em> introduces <code class="literal">enum</code> types.</p></div><p class="calibre8">Sometimes code will always work, and there is no way it can fail. In these cases, it's cumbersome to have to wrap the code with a <code class="literal">do/try/catch</code> block when it is known that the problem can never occur. Swift provides a short-cut for this using the <code class="literal">try!</code> statement, which catches and filters the exception:</p><div><pre class="programlisting">&gt; let ace = try! cardName(1)
ace: String = "Ace"</pre></div><p class="calibre8">If the expression really does fail, then it translates to a runtime error and halts the program:</p><div><pre class="programlisting">&gt; let unknown = try! cardName(15)

Fatal error: 'try!' expression unexpectedly raised an error: Oops(message: "Unknown card")</pre></div><div><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8">Using <code class="literal">try!</code> is not generally recommended; if an error occurs then the program will crash. However, it is often used with user interface codes as Objective-C has a number of optional methods and values that are conventionally known not to be <code class="literal">nil</code>, such as the reference to the enclosing window.</p></div><p class="calibre8">A better approach is to use <code class="literal">try?</code>, which translates the expression into an optional value: if evaluation<a id="id63" class="calibre1"/> succeeds, then it returns an optional with a value; if evaluation fails, then it returns a <code class="literal">nil</code> value:</p><div><pre class="programlisting">&gt; let ace = try? cardName(1)
ace: String? = "Ace"
&gt; let unknown = try? cardName(15)
unknown: String? = nil</pre></div><p class="calibre8">This is handy for use in the <code class="literal">if let</code> or <code class="literal">guard let</code> constructs, to avoid having to wrap in a <code class="literal">do/catch</code> block:</p><div><pre class="programlisting">&gt; if let card = try? cardName(value) {
.   print("You chose: \(card)")
. }</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_9"><a id="ch01lvl2sec27" class="calibre1"/>Cleaning up after errors</h2></div></div></div><p class="calibre8">It is <a id="id64" class="calibre1"/>common to have a function that needs to perform some cleanup before the function returns, regardless of whether the function has completed successfully or not. An example would be working with files; at the start of the function the file may be opened, and by the end of the function it should be closed again, whether or not an error occurs.</p><p class="calibre8">A traditional way of handling this is to use an optional value to hold the file reference, and at the end of the method if it is not <code class="literal">nil</code>, then the file is closed. However, if there is the possibility of an error occurring during the method's execution, there needs to be a <code class="literal">do/catch</code> block to ensure that the cleanup is correctly called, or a set of nested <code class="literal">if</code> statements that are only executed if the file is successful.</p><p class="calibre8">The downside with this approach is that the actual body of the code tends to be indented several times each with different levels of error handling and recovery at the end of the method. The syntactic separation between where the resource is acquired and where the resource is cleaned up can lead to bugs.</p><p class="calibre8">Swift has a <code class="literal">defer</code> statement, which can be used to register a block of code to be run at the end of the function call. This block is run regardless of whether the function returns normally (with the <code class="literal">return</code> statement) or if an error occurs (with the <code class="literal">throw</code> statement). Deferred blocks are executed in reverse order of execution, for example:</p><div><pre class="programlisting">&gt; func deferExample() {
.   defer { print("C") }
.   print("A")
.   defer { print("B") }
. }
&gt; deferExample()
A
B
C</pre></div><p class="calibre8">Please note that if a <code class="literal">defer</code> statement is not executed, then the block is not executed at the end of the <a id="id65" class="calibre1"/>method. This allows a <code class="literal">guard</code> statement to leave the function early, while executing the <code class="literal">defer</code> statements that have been added so far:</p><div><pre class="programlisting">&gt; func deferEarly() { 
.   defer { print("C") } 
.   print("A") 
.   return 
.   defer { print("B") } // not executed
. }    
&gt; deferEarly()
A
C</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Command-line Swift</h1></div></div></div><p class="calibre8">As Swift can <a id="id66" class="calibre1"/>be interpreted, it is possible to use it in shell scripts. By setting the interpreter to <code class="literal">swift</code> with a <em class="calibre11">hashbang</em>, the script can be executed without requiring a separate compilation step. Alternatively, Swift scripts can be compiled to a native executable that can be run without the overhead of the interpreter.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec28" class="calibre1"/>Interpreted Swift scripts</h2></div></div></div><p class="calibre8">Save the<a id="id67" class="calibre1"/> following as <code class="literal">hello.swift</code>:</p><div><pre class="programlisting">#!/usr/bin/env xcrun swift
print("Hello World")</pre></div><div><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre8">In Linux, the first line should point to the location of the <code class="literal">swift</code> executable, such as <code class="literal">#!/usr/bin/swift</code>.</p></div><p class="calibre8">After saving, make<a id="id68" class="calibre1"/> the file executable by running <code class="literal">chmod a+x hello.swift</code>. The program can then be run by typing <code class="literal">./hello.swift</code>, and the traditional greeting will be seen:</p><div><pre class="programlisting">Hello World</pre></div><p class="calibre8">Arguments can be passed from the command line and interrogated in the process using the <code class="literal">Process</code> class through the <code class="literal">arguments</code> constant. As with other Unix commands, the first element (0) is the name of the process executable; the arguments that are passed from the command line start from one (1).</p><p class="calibre8">The program<a id="id69" class="calibre1"/> can be terminated using the <code class="literal">exit</code> function; however, this is defined in the operating system libraries and so it needs to be<a id="id70" class="calibre1"/> imported in order to call this function. Modules in Swift correspond to Frameworks in Objective-C and give access to all functions that are defined as public API in the module. The syntax to import all elements from a module is <code class="literal">import module</code> although it's also possible to import a single function using <code class="literal">import func module.functionName</code>.</p><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">Not all foundation libraries are implemented for Linux, which results in some differences of behavior. In addition, the underlying module for the base functionality is <code class="literal">Darwin</code> on iOS and OS X, and is <code class="literal">Glibc</code> on Linux. These can also be accessed with <code class="literal">import Foundation</code>, which will include the appropriate operating system module.</p></div><p class="calibre8">A Swift program to print arguments in uppercase can be implemented as a script:</p><div><pre class="programlisting">#!/usr/bin/env xcrun swift
import func Darwin.exit
# import func Glibc.exit # for Linux
let args = Process.arguments[1..&lt;Process.arguments.count]
for arg in args {
  print("\(arg.uppercaseString)")
}
exit(0)</pre></div><p class="calibre8">Running this with <code class="literal">hello world</code> results in the following:</p><div><pre class="programlisting">$ ./upper.swift hello world
HELLO
WORLD</pre></div><p class="calibre8">Conventionally, the entry point to Swift programs is via a script called <code class="literal">main.swift</code>. If starting a Swift-based command-line application project in Xcode, a <code class="literal">main.swift</code> file will be created automatically. Scripts do not need to have a <code class="literal">.swift</code> extension; for example, the previous example could be called <code class="literal">upper</code> and it would still work.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec29" class="calibre1"/>Compiled Swift scripts</h2></div></div></div><p class="calibre8">While<a id="id71" class="calibre1"/> interpreted Swift scripts are useful for experimenting<a id="id72" class="calibre1"/> and writing, each time the script is started, it is interpreted using the Swift compiler and then executed. For simple scripts (such as converting arguments to upper case), this can be a large proportion of the script's execution time.</p><p class="calibre8">To compile a Swift script into a native executable, use the <code class="literal">swiftc</code> command with the <code class="literal">-o</code> output flag to <a id="id73" class="calibre1"/>specify a file to write to. This will then <a id="id74" class="calibre1"/>generate an executable that does exactly the same as the interpreted script, only much faster. The <code class="literal">time</code> command can be used to compare the running time of the interpreted and compiled versions:</p><div><pre class="programlisting">$ time ./upper.swift hello world    # Interpreted
HELLO
WORLD
real  0m0.145s
$ xcrun swiftc -o upper upper.swift # Compile step
$ time ./upper hello world          # Compiled
HELLO
WORLD
real  0m0.012s</pre></div><p class="calibre8">Of course, the numbers will vary, and the initial step only happens once, but startup is very lightweight in Swift. The numbers are not meant to be taken in magnitude but rather as relative to each other.</p><p class="calibre8">The compile step can also be used to link together many individual Swift files into one executable, which helps create a more organized project; Xcode will encourage having multiple Swift files as well.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">The Swift interpreter is a great way of learning how to program in Swift. It allows expressions, statements, and functions to be created and tested along with a command-line history that provides editing support. The basic collection types of arrays and collections, the standard data types, such as strings and numbers, optional values, and structures, were presented. Control flow and functions with positional, named, and variadic arguments, along with default values were also presented. Finally, the ability to write Swift scripts and run them from the command line was also demonstrated.</p><p class="calibre8">The next chapter will look at the other way of working with Swift code that is available on OS X, through the Xcode playground.</p></div></body></html>