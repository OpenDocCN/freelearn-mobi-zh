<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Specialties of the Mobile Device &#x2013; Touch and Tilt"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Specialties of the Mobile Device – Touch and Tilt</h1></div></div></div><p>
<span class="emphasis"><em>In the previous chapter, we learned about Pathfinding and AI. We expanded our Tank Battle game to include enemy tanks. We created points for them to spawn at, and made them shoot at the player. Utilizing Unity's pathfinding system, we made the tanks chase the player. Also, the player was given the ability to destroy the tanks. Once destroyed, the player receives some points and a new enemy tank is spawned.</em></span>
</p><p>
<span class="emphasis"><em>In this chapter, we start working on a new game as we explore some of the specialties of the mobile device. We will be creating a Space Fighter game. The player will take control of a space ship and blast enemy ships, mines, and asteroids for points. To steer their ship, the player will have to tilt the mobile device. To shoot, the player will touch the screen where they want their laser blast to hit.</em></span>
</p><p>In this chapter, we will be covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Touch controls</li><li class="listitem" style="list-style-type: disc">Tilt controls</li></ul></div><p>We will be creating a new project for this chapter, so start up Unity and we will begin.</p><div class="section" title="Setting up"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec85"/>Setting up</h1></div></div></div><p>As with every project,<a id="id411" class="indexterm"/> we need a little bit of preparation work in order to prepare our development environment. Don't worry, the setup for this chapter is simple and straightforward.</p></div></div>
<div class="section" title="Time for action &#x2013; creating the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec86"/>Time for action – creating the project</h1></div></div></div><p>Let's get started. The first step<a id="id412" class="indexterm"/> is, of course, to start Unity and create a new project. Naming the project <code class="literal">Ch6_SpaceFighter</code> will work well:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once Unity has finished initializing, this is a perfect opportunity to set our build settings. Open the <span class="strong"><strong>Build Settings</strong></span> window, select <span class="strong"><strong>Android</strong></span> from the list of platforms, and hit <span class="strong"><strong>Switch Platform</strong></span> to change the target platform.</li><li class="listitem">While at the <span class="strong"><strong>Build Settings</strong></span> window, select <span class="strong"><strong>Player Settings</strong></span> to open the player settings in the <span class="strong"><strong>Inspector</strong></span>. Adjust the <span class="strong"><strong>Company Name</strong></span>, <span class="strong"><strong>Product Name</strong></span>, and especially the <span class="strong"><strong>Bundle Identifier</strong></span>.</li><li class="listitem">We need to create a few folders to keep the project organized. The <code class="literal">Scripts</code>, <code class="literal">Models</code>, and <code class="literal">Prefabs</code> folders should be created in the <span class="strong"><strong>Project</strong></span> window.</li><li class="listitem">We now need to import the assets for this project. We are going to need a space ship for the player, an enemy space ship, an explosive mine, and some asteroids. Luckily, all of these have already been prepared and are available with the starting assets for this chapter. Import <code class="literal">PlayerShip.blend</code>, <code class="literal">PlayerShip.png</code>, <code class="literal">EnemyShip.blend</code>, <code class="literal">EnemyShip.png</code>, <code class="literal">Asteroid.blend</code>, <code class="literal">Asteroid.png</code>, <code class="literal">SpaceMine.blend</code>, and <code class="literal">SpaceMine.png</code> to the <code class="literal">Models</code> folder that you just created.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We just finished the setup for this chapter's project. Once again, a little bit of effort at the beginning of the project will save time and frustration later. Especially, as a project grows in size, the organization done at the beginning becomes most important.</p></div></div>
<div class="section" title="Controlling with tilt"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec87"/>Controlling with tilt</h1></div></div></div><p>Modern mobile devices possess a broad variety of internal sensors for detecting and providing information about the surronding world. Though you may not have thought of them in such a way, you are certainly most familiar with the microphone and speaker that are required for making calls. There is a Wi-Fi receiver for connecting to the Internet and a camera for taking pictures.<a id="id413" class="indexterm"/> Your device almost certainly has a magnetometer to work with your GPS to provide directions.</p><p>The sensor we are interested in right now is the<a id="id414" class="indexterm"/> <span class="strong"><strong>gyroscope</strong></span>. This sensor detects local rotation of the device. In general, it is used to determine the orientation of the device. We are going to use it to steer our ship. When the user tilts their device left and right, their space ship will turn to the side. When the device is tilted up and down, the ship will go up and down.</p></div>
<div class="section" title="Time for action &#x2013; steering the space ship"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec88"/>Time for action – steering the space ship</h1></div></div></div><p>To steer our ship, we will need to create a single script and apply it to our ship:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start this off, create a new script and name it <code class="literal">TiltSteering</code>.</li><li class="listitem">As with all of our <a id="id415" class="indexterm"/>other scripts, we will begin this one with a few variables. The first two variables control the speed with which the ship will rotate as the device is tilted. The second two are going to be used to limit the rotation of the ship. These will determine how tight a circle the player's ship can turn in.<div class="informalexample"><pre class="programlisting">public float horizRotateSpeed = 7f;
public float vertRotateSpeed = 3f;

public float horizMax = 60f;
public float vertMax = 45f;</pre></div></li><li class="listitem">Next, we will make use of the <code class="literal">Update</code> function. We start out by creating a variable to store the ship's current rotation. Next, we have to adjust the rotation. When working with Euler rotations, Unity adjusts values to be between zero and 360. This way, the values are never negative. Anything below zero simply wraps around and starts counting down from 360; anything above 360 wraps back to start counting up from zero again. We need the negative values. So, if the parts of the rotation are above 180, we subtract 360 to determine their negative values. Also, we are not making adjustments to the z component because the ship will not be rotating around its forward axis.<div class="informalexample"><pre class="programlisting">public void Update() {
  Vector3 rotation = transform.eulerAngles;

  if(rotation.y &gt; 180f) rotation.y -= 360f;
  if(rotation.x &gt; 180f) rotation.x -= 360f;</pre></div></li><li class="listitem">Next, we apply the accelerometer measurement. When the device is held horizontally, with the home button on the right and the screen towards the user, the x component holds the rotation of the device while it is facing the user. The z component holds the rotation of the screen being tilted up and down. The components are multiplied by their respective speeds and are added to the rotation. The y rotation controls pointing left and right while the x component controls pointing up and down. However, the z acceleration is the opposite of how the ship should rotate, so we take the negative.<div class="informalexample"><pre class="programlisting">rotation.y += Input.acceleration.x * horizRotateSpeed;
rotation.x += -Input.acceleration.z * vertRotateSpeed;</pre></div></li><li class="listitem">After the acceleration is applied, we need to limit the rotations so that the ship is not rotated too far. We use the <code class="literal">Mathf.Clamp</code> function to limit the rotation components between the negative of the max and the max of the relevant values.<div class="informalexample"><pre class="programlisting">rotation.y = Mathf.Clamp(rotation.y, -horizMax, horizMax);
rotation.x = Mathf.Clamp(rotation.x, -vertMax, vertMax);</pre></div></li><li class="listitem">Finally, we apply the rotation to the ship's transform and close off the function for the script.<div class="informalexample"><pre class="programlisting">  transform.eulerAngles = rotation;
}</pre></div></li><li class="listitem">In order to <a id="id416" class="indexterm"/>make use of our new script, we need to do some setup for the player's ship. Start by creating an empty <span class="strong"><strong>GameObject</strong></span> and setting its position to zero. Rename it to <code class="literal">PlayerShipPivot</code>. This will allow us to control the movement and appearance of the player's ship independently.</li><li class="listitem">Drag your <code class="literal">PlayerShip</code> model from the <span class="strong"><strong>Project</strong></span> window and drop it on the pivot point we just created. Be sure to center your ship on the point and rotate it to face forward along the z axis.</li><li class="listitem">You can now add the script to the pivot point.</li><li class="listitem">This is the point when it is especially important to have Unity Remote. With your device attached and Unity Remote running, you can hold it up and steer the ship. Feel free to adjust the rotation speeds and limits until you find the settings that feel natural to control.</li><li class="listitem">We will need to be able to see past the ship, so that we can later shoot at targets we are flying towards. Adjust the position of the camera so the ship is centered horizontally and a little below center.</li><li class="listitem">The scene also needs to be slightly lit. The light in deep space tends to be very general, so we can get away with just adjusting the ambient light. Click on <span class="strong"><strong>Edit</strong></span> in the menu bar of Unity, and then click on <span class="strong"><strong>Render Settings</strong></span>. By setting the <span class="strong"><strong>Ambient Light</strong></span> to white, our scene will be bright enough to see everything.</li><li class="listitem">Once all the settings are in place, be sure to save the scene. Name it <code class="literal">SpaceFighter</code>.<div class="mediaobject"><img src="graphics/2014OT_06_01.jpg" alt="Time for action – steering the space ship"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We made use of the<a id="id417" class="indexterm"/> accelerometer to provide steering control of a spaceship. By measuring how the player is tilting their device, we are able to rotate the ship accordingly. We did not make the ship actually move, but just rotated it in place. We will come to understand why in a little bit.</p></div><div class="section" title="Making things move in space"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Making things move in space</h2></div></div></div><p>Your first instinct to make the ship move would be probably to just change the position of the ship. However, things get weird when objects are really far from the world origin. In programming, there are actually limits on the size of the number that a variable can hold. This limit causes the rendering system to begin failing when the vertex positions become too large, resulting in the model being distorted beyond recognition. Admittedly, we are talking about positional values in the hundreds of thousands and beyond. However, say the player were to just fly straight for a long time; eventually, they could reach this distance of distortion.</p><p>As a potential solution, we could force the player to turn, or stop their forward progress, or wrap their position so they continue flying from the opposite side of a finite space. However, it is so much more fun to fly through an infinite space. We can achieve this by leaving the player's ship in place and moving everything else around it. As a new space is entered, new enemies and objects can be spawned to fill the space. Old objects and enemies that are too far away can be destroyed by removing them where the player won't see. This would give the illusion of an infinite amount of space.</p></div></div>
<div class="section" title="Time for action &#x2013; flying asteroids"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec89"/>Time for action – flying asteroids</h1></div></div></div><p>The first objects we <a id="id418" class="indexterm"/>will be avoiding in our infinite space will be asteroids:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To make the asteroids work, we will first need to make the player ship's rotation and speed available for the asteroids to use. To do this, we need to create a new script and call it <code class="literal">PlayerShip</code>.</li><li class="listitem">Again, this script starts with a group of variables. The first is the speed of the player's ship. The asteroids and other objects in the space will use it to move around the player. The second variable will hold a reference to the <code class="literal">TiltSteering</code> script that we created earlier. This will give us access to the ship's rotational speed. The last variable is a static variable that will hold a reference to the instance of this script that exists in the scene. This will allow other scripts to access the information stored by this script. We call the <code class="literal">use</code> variable to indicate to other scripts that this is the instance they should access.<div class="informalexample"><pre class="programlisting">public float speed = 10f;
public TiltSteering tilt;

private static PlayerShip use;</pre></div></li><li class="listitem">Next, we make use of the <code class="literal">Awake</code> function. This function is automatically called at the beginning of the game, making it perfect for initialization. We are using it to simply set the <code class="literal">use</code> variable that we created earlier to the current instance of the script.<div class="informalexample"><pre class="programlisting">public void Awake() {
  use = this;
}</pre></div></li><li class="listitem">The next function is for providing other scripts with the player's current rotation. Being static, any script can call it at any time. The function first checks to see whether a reference is available to the current instance of the script. If it cannot be found, a neutral rotation, <code class="literal">Quaternion.identity</code>, is returned. Otherwise, the rotation of the transform that the script instance is attached to is returned.<div class="informalexample"><pre class="programlisting">public static Quaternion GetRotation() {
  if(use == null) return Quaternion.identity;

  return use.transform.rotation;
}</pre></div></li><li class="listitem">The <code class="literal">Rotate</code> function here is for faking the movement of the player. This function takes<a id="id419" class="indexterm"/> the transform that is passed to it and moves and rotates it to make it look like it is the player that has moved through space. As with the previous <code class="literal">GetRotation</code> function, it first checks for a reference to the player and does nothing if there isn't one.<div class="informalexample"><pre class="programlisting">public static void Rotate(Transform other) {
  if(use == null) return;</pre></div></li><li class="listitem">To rotate the asteroid, and anything else, around the player's position, its current position needs to be multiplied by the mirror of the player's current rotation. To do that, we need to adjust the rotation so that it can be mirrored properly. The Euler angles of the player's rotation are stored in a variable for manipulation. We then shift the values that are greater than 180, just as we did earlier. The rotation is then scaled by the player ship's rotation speed. Finally, it is multiplied by the frame speed to keep it in time.<div class="informalexample"><pre class="programlisting">Vector3 euler = use.transform.eulerAngles;
if(euler.x &gt; 180f) euler.x -= 360f;
if(euler.y &gt; 180f) euler.y -= 360f;
euler.Scale(new Vector3(use.tilt.vertRotateSpeed, use.tilt.horizRotateSpeed, 0));
euler *= Time.deltaTime;</pre></div></li><li class="listitem">We turn the negative Euler rotation, which is the mirrored rotation, back into a Quaternion and store it in a variable for use.<div class="informalexample"><pre class="programlisting">Quaternion mirror = Quaternion.Euler(-euler);</pre></div></li><li class="listitem">The mirrored rotation is then multiplied by the passed object's position, updating the position to be rotated around the player as if they were turning. The player's rotation is then multiplied by a forward-facing vector, the player's speed, and finally the frame speed. This is all subtracted from the object's current position in order to imitate the player's forward movement. Finally, the passed object's rotation is multiplied by the mirrored rotation to change its orientation. Altogether, this fakes the movement of the player.<div class="informalexample"><pre class="programlisting">other.position = mirror * other.position;
other.position -= playerRotation * Vector3.forward * use.speed * Time.deltaTime;
other.rotation *= mirror;</pre></div></li><li class="listitem">Add the script to the <code class="literal">PlayerShipPivot</code> object that was created previously. Be sure to connect the <code class="literal">TiltSteering</code> reference.</li><li class="listitem">Next, we need to make use of that script by creating another. Name it <code class="literal">Asteroid</code>. This script will control an asteroid as it flies through space and the player is forced to avoid it.</li><li class="listitem">The first two of the variables for this script are used for determining a random speed at which the asteroid will fly through space. The third variable will hold the<a id="id420" class="indexterm"/> random speed. The final variable will hold the random direction in which the asteroid is flying through space.<div class="informalexample"><pre class="programlisting">public float minSpeed = 5f;
public float maxSpeed = 10f;

private float speed = 1f;
private Vector3 direction = Vector3.forward;</pre></div></li><li class="listitem">Next, we again make use of the <code class="literal">Awake</code> function<a id="id421" class="indexterm"/> for initialization. Any point that lies on the surface of a sphere with a radius of one is essentially a vector that points in a random direction. Therefore, we use <code class="literal">Random.onUnitSphere</code> to find a random direction for the asteroid to go. It is followed by the use of <code class="literal">Random.Range</code> and the first two variables to determine a random speed for the asteroid to travel.<div class="informalexample"><pre class="programlisting">public void Awake() {
  direction = Random.onUnitSphere;
  speed = Random.Range(minSpeed, maxSpeed);
}</pre></div></li><li class="listitem">The last function for this script is <code class="literal">LateUpdate</code>. We need the asteroid to move after the player's ship has updated its rotation; that is why we use this function. The first line of the function uses the <code class="literal">GetRotation</code> function<a id="id422" class="indexterm"/> that we created for the <code class="literal">PlayerShip</code> script and stores it in a variable for use.<div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  Quaternion playerRotation = PlayerShip.GetRotation();</pre></div></li><li class="listitem">Next, we make a call to the <code class="literal">PlayerShip.Rotate</code> function<a id="id423" class="indexterm"/>, passing it the asteroid's transform, so that the asteroid can be moved to fake the player's movement.<div class="informalexample"><pre class="programlisting">PlayerShip.Rotate(transform);</pre></div></li><li class="listitem">The next line of code rotates the asteroid's movement direction by the player's rotation, again making a change that fakes the player's movement. The position is again updated with the asteroid's own movement in the adjusted direction.<div class="informalexample"><pre class="programlisting">direction = playerRotation * direction;
transform.position += direction * speed * Time.deltaTime;</pre></div></li><li class="listitem">The function and the script finishes with a check to see if the asteroid is too far away from the player. We do this by checking <code class="literal">sqrMagnitude</code> of the asteroid's position. The length of a vector is its magnitude. For positional vectors, this is the distance from the center point. The <code class="literal">sqrMagnitude</code> is the square of the<a id="id424" class="indexterm"/> vector's magnitude. This is much faster to calculate and just as easy for comparison. We just need to compare it to the square of the desired value. In this case a max distance of about 300, whose square is 100,000, will work well for our needs. If you remember from math class, 1e5 is the same as a one with five zeros behind it, which is 1 million. Finally, if the asteroid is too far away, it is destroyed.<div class="informalexample"><pre class="programlisting">  if(transform.position.sqrMagnitude &gt; 1e5) Destroy(gameObject);
}</pre></div></li><li class="listitem">In order to test this script, we need an asteroid prefab. To create it, start off by adding the <code class="literal">Asteroid</code> model to the scene and deleting two of the three meshes.</li><li class="listitem">Add the script to the model and drag it to the <code class="literal">Prefabs</code> folder, turning it into a prefab.<div class="mediaobject"><img src="graphics/2014OT_06_02.jpg" alt="Time for action – flying asteroids"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created two scripts and a prefab. The first script is used by the player's ship to relay information about its rotation and speed to other scripts. The second script controls the motion of asteroids in the<a id="id425" class="indexterm"/> game world. Because of the weirdness in the model's behavior when subjected to extreme distances, the player never actually moves. The game world and all of the objects in it are instead moved around the player. Finally, we created an asteroid prefab. Try adding several prefabs to the scene and try them out. You can fly in, out, and around them even though your ship never actually moves.</p></div><div class="section" title="Adding space collisions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Adding space collisions</h2></div></div></div><p>Flying around, you probably noticed that you can fly straight through the asteroids. To make it possible for the player to hit them, we need to add some collision to the player's ship and the asteroid. This is similar to what was done for the Tank Battle game. We will be going into more <a id="id426" class="indexterm"/>detail about how the collision works in the next chapter, but we will need to make use of the <span class="strong"><strong>Rigidbody</strong></span> component. It provides access to Physics calculations and allows us to group colliders to make more complex collision shapes.</p></div></div>
<div class="section" title="Time for action &#x2013; adding collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec90"/>Time for action – adding collisions</h1></div></div></div><p>We need to add some collision capabilities to our space objects, so that they can crash into each other and be shot at properly:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by giving collision to the asteroid. Do this by first selecting the mesh for the asteroid and adding a <span class="strong"><strong>MeshCollider</strong></span> component. This will later let us shoot at the asteroid.</li><li class="listitem">Next, select the same object that holds our <code class="literal">Asteroid</code> script component. Add a <span class="strong"><strong>SphereCollider</strong></span> component to the object and adjust the <span class="strong"><strong>Radius</strong></span> to be a little larger than the asteroid. This collider will detect when the asteroid has collided with the player.<div class="mediaobject"><img src="graphics/2014OT_06_03.jpg" alt="Time for action – adding collisions"/></div></li><li class="listitem">The <span class="strong"><strong>SphereCollider</strong></span> needs to have the <span class="strong"><strong>Is Trigger</strong></span> checkbox checked. We are not checking the true collision, just an approximate one. With this checkbox checked, objects <a id="id427" class="indexterm"/>will no longer be stopped by the collider, but instead trigger an event in script when an object enters the collider volume. When the player enters the collider, it will be close enough that we can assume and act as if it has collided.</li><li class="listitem">When you are satisfied with the changes, be sure to apply them to the prefab. Otherwise, the other asteroids will not be updated and collidable.</li><li class="listitem">To detect when the player has entered the new trigger area, we need to add a short function to the <code class="literal">Asteroid</code> script. We add a <code class="literal">OnTriggerEnter</code> function to the end of the script. This function is automatically called by the Physics system when one collider enters another. The collider that is passed to it is the one that it collided with. However, the function only works if at least one of the objects has a <span class="strong"><strong>Rigidbody</strong></span> component attached. We will be covering it in detail in <a class="link" href="ch07.html" title="Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera">Chapter 7</a>, <span class="emphasis"><em>Throwing Your Weight Around – Physics and a 2D Camera</em></span>, but the Rigidbody component is what actually connects an object into Unity's Physics engine, giving our scripts access to the <code class="literal">OnTrigger</code> and <code class="literal">OnCollision</code> groups of functions. We will be adding this to the player's ship. When the function is called, it simply destroys the asteroid.<div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider other) {
  Destroy(gameObject);
}</pre></div></li><li class="listitem">Next, we need to add collision to the the player's ship. Start by adding that <span class="strong"><strong>Rigidbody</strong></span> component to the <span class="strong"><strong>PlayerShipPivot</strong></span> GameObject that we created earlier.</li><li class="listitem">Be sure to check the <span class="strong"><strong>Is Kinematic</strong></span> checkbox of the new component. This tells the Physics system that we want to control the object's motion through the script. If it was not checked, the ship would begin to fall as soon we start playing the game.</li><li class="listitem">One of the features of a <span class="strong"><strong>Rigidbody</strong></span> component is that it treats all colliders on child objects in<a id="id428" class="indexterm"/> the <span class="strong"><strong>Hierarchy</strong></span> as a part of a single collision shape. This way, we are able to build a complex collision shape using several simple and faster process colliders. By creating an empty <span class="strong"><strong>GameObject</strong></span> and adding the simple colliders, we size and position them to cover the player's ship. Be sure to make the collider objects children of the ship's pivot point.<div class="mediaobject"><img src="graphics/2014OT_06_04.jpg" alt="Time for action – adding collisions"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We added collision to the asteroids and the player's ship. This gives the player the ability to crash into and destroy the asteroids. We are utilizing a trigger collider to approximate collision with the asteroid. Also, we make use of the <span class="strong"><strong>Rigidbody</strong></span> component, allowing our ship to collide with other things in the scene. Additionally, this gives us the advantage of being able to build a complex collision shape out of the simple colliders that are provided by Unity. Although it is technically possible to just use a <span class="strong"><strong>MeshCollider</strong></span> to exactly match<a id="id429" class="indexterm"/> the shape of the ship, it is not recommended. The <span class="strong"><strong>Rigidbody</strong></span> and <span class="strong"><strong>MeshCollider</strong></span> components do not mix well. Also, several simple colliders are much faster for the computer to calculate than a single <span class="strong"><strong>MeshCollider</strong></span>.</p></div><div class="section" title="Have a go hero – adding points"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Have a go hero – adding points</h2></div></div></div><p>It is great that we can make the player ship collide with the asteroids, but it doesn't mean much in terms of a game. There is<a id="id430" class="indexterm"/> no penalty for the collision. This challenge is for you to implement a scoring system similar to the one we used for the Tank Battle game from the previous chapters. When the player collides with asteroids, subtract points from the score. Use the <code class="literal">SendMessage</code> function on the other collider from the <code class="literal">OnTriggerEnter</code> function<a id="id431" class="indexterm"/>. Don't just subtract points when the trigger is entered, because (as you will find out later) the asteroids will not be colliding only with the player.</p></div><div class="section" title="Creating the enemy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Creating the enemy</h2></div></div></div><p>Flying around space with a handful of asteroids is great, but it doesn't make for much of a fight. That is why we are going <a id="id432" class="indexterm"/>to add an enemy spaceship that will chase and shoot at the player. We have no mesh to use for pathfinding, so we cannot use the techniques we learned in the previous chapter. However, there are no buildings in space to navigate around, so the chasing of the player will be much simpler.</p></div></div>
<div class="section" title="Time for action &#x2013; adding an enemy ship"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec91"/>Time for action – adding an enemy ship</h1></div></div></div><p>To make our enemy ships, we will need a script to turn our enemy ship into a prefab:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create a <a id="id433" class="indexterm"/>new script and call it <code class="literal">EnemyShip</code>. This script will control the movement and shooting of the enemy ships.</li><li class="listitem">The script starts off with several variables. The first two define the speed with which the ship moves forward and how fast it turns.<div class="informalexample"><pre class="programlisting">public float moveSpeed = 8f;
public float turnSpeed = 0.5f;</pre></div></li><li class="listitem">The next three variables are for controlling the shooting of the ship. First is the rate at which bullets are fired. It is followed by the range that the ship has to be within to fire at the player. Third is a holder for how long it has been since the last bullet was fired. This will work with the rate of fire to dictate when the ship can fire again.<div class="informalexample"><pre class="programlisting">public float fireRate = 1.5f;
public float fireRange = 60f;
private float fireTime = 0;</pre></div></li><li class="listitem">The last two variables will hold a reference to the bullet prefab that will be fired and the point from which the bullet will be released. This is similar to how we made the<a id="id434" class="indexterm"/> enemy tanks shoot in the previous chapter. The difference is that space games tend to have a lot of laser blasts flying around that force the player to dodge.<div class="informalexample"><pre class="programlisting">public GameObject bullet;
public Transform muzzlePoint;</pre></div></li><li class="listitem">In the <code class="literal">Update</code> function, we will do the work of actually shooting. It starts by tracking how long it has been since a bullet was last fired. Then we check to see if it has been long enough since the last firing in order to fire again, and exit the function if it is not. The third line of code in the function checks the range. This is done in exactly the same way as we checked to see if the asteroids moved too far away from the player. Next, we check to make sure the ship is pointed at the player. This is done in the same way as we did when the enemy tanks were to shoot at the player. A comparison of the forward direction is done with the direction to the player to check the angle. If it is pointing close enough at the player, the ship can start shooting. The shooting is done with a call to the <code class="literal">Instantiate</code> function. By passing it the <code class="literal">muzzlePoint</code> variable's position and rotation, the new bullet is automatically rotated. A separate script will be handling the movement of the bullet. Finally, the time since the ship last fired is reset to zero.<div class="informalexample"><pre class="programlisting">public void Update() {
  fireTime += Time.deltaTime;
  if(fireTime &lt; fireRate) return;

  if(transform.position.sqrMagnitude &gt; fireRange * fireRange) return;

  if(Vector3.Angle(transform.forward, -transform.position) &gt; 10) return;

  Instantiate(bullet, muzzlePoint.position, muzzlePoint.rotation);
  fireTime = 0;
}</pre></div></li><li class="listitem">The next function is the <code class="literal">LateUpdate</code> function<a id="id435" class="indexterm"/>. We are going to use this function just as we did for the asteroid. The first line of code just calls out to the <code class="literal">PlayerShip</code> script to have the ship rotated and moved to fake the player's movement.<div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  PlayerShip.Rotate(transform);</pre></div></li><li class="listitem">The next line of code applies movement to the ship. The process is similar to how we made the enemy turrets rotate to face the player in the previous chapter. The <code class="literal">step</code> variable is used to dictate how fast the ship turns towards the player. We use<a id="id436" class="indexterm"/> the <code class="literal">Slerp</code> function<a id="id437" class="indexterm"/> to change the ship's current rotation towards the target rotation. In this case, the rotation is the one that looks at the player. Lastly, the ship is moved forward. Altogether, this results in movements similar to how a car turns.<div class="informalexample"><pre class="programlisting">float step = turnSpeed * Time.deltaTime;
Quaternion toPlayer = Quaternion.LookRotation(-transform.position);
transform.rotation = Quaternion.Slerp(transform.rotation, toPlayer, step);
transform.position += transform.forward * moveSpeed * Time.deltaTime;</pre></div></li><li class="listitem">The last code snippet for the function and the script is the check to see if the ship is too far away. It is exactly the same as the one used by the asteroid.<div class="informalexample"><pre class="programlisting">  if(transform.position.sqrMagnitude &gt; 1e5) Destroy(gameObject);
}</pre></div></li><li class="listitem">Before we can put our enemy ship together, we need to make one more short script. Create a new script and name it <code class="literal">Bullet</code>. As you might guess, this is the script that will control the movement of the enemy bullets.</li><li class="listitem">This script starts with a single variable, that is, how fast the bullet will move through space.<div class="informalexample"><pre class="programlisting">public float speed = 20f;</pre></div></li><li class="listitem">Next, we make use of the <code class="literal">LateUpdate</code> function<a id="id438" class="indexterm"/> again. This function first uses <code class="literal">PlayerShip.Rotate</code> to reposition the bullet, just as with all the other objects in the game world. It then moves forward with speed. Last, it does the check for being out of range.<div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  PlayerShip.Rotate(transform);

  transform.position += transform.forward * speed * Time.deltaTime;
  if(transform.position.sqrMagnitude &gt; 1e5) Destroy(gameObject);
}</pre></div></li><li class="listitem">The last function for the script, <code class="literal">OnTriggerEnter</code>, works just like the one for the asteroid. If the bullet makes contact with a ship, it will destroy itself.<div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider other) {
  Destroy(gameObject);
}</pre></div></li><li class="listitem">Now that we have our scripts, the next step is to create the enemy ship and bullet prefabs. To create the bullet, start by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Sphere</strong></span>.</li><li class="listitem">Rename the new<a id="id439" class="indexterm"/> sphere to <code class="literal">Bullet</code> and scale it to about half of its original size.</li><li class="listitem">Next, add the <code class="literal">Bullet</code> script to the object and be sure to check the <span class="strong"><strong>Is Trigger</strong></span> checkbox in its <span class="strong"><strong>SphereCollider</strong></span> component. Without that box checked, the bullet won't work properly.</li><li class="listitem">Finally, drag the object to the <code class="literal">Prefabs</code> folder to turn it into a prefab.</li><li class="listitem">Next, we need to make the enemy ship. Start by creating an empty <span class="strong"><strong>GameObject</strong></span> and renaming it to <code class="literal">EnemyShipPivot</code>.</li><li class="listitem">Add a copy of the <code class="literal">EnemyShip</code> model to the scene and make it a child of the pivot point we just created. Be sure to rotate it to face forward along the z axis, and position it to be centered on the pivot point.</li><li class="listitem">Next, use simple colliders and empty <span class="strong"><strong>GameObject</strong></span> to create a collision shape for the ship. This is exactly like what we did for the player's ship. Be sure to make all of the colliders children of the enemy ship's pivot point.<div class="mediaobject"><img src="graphics/2014OT_06_05.jpg" alt="Time for action – adding an enemy ship"/></div></li><li class="listitem">We need to create a muzzle point and position it in front of the enemy ship. Do it just as we did for the tanks. Be sure to also make it a child of the ship's pivot point.</li><li class="listitem">Now, add the <code class="literal">EnemyShip</code> script and a <span class="strong"><strong>Rigidbody</strong></span> component to the pivot point.</li><li class="listitem">Almost done. Drag the muzzle point from the <span class="strong"><strong>Hierarchy</strong></span> window and drop it on the appropriate slot in the script component in the <span class="strong"><strong>Inspector</strong></span>. Also, drag-and-drop the <span class="strong"><strong>Bullet</strong></span> <a id="id440" class="indexterm"/>prefab from the <span class="strong"><strong>Project</strong></span> window to the waiting slot.</li><li class="listitem">Finally, make the ship into a prefab by dragging it from the <span class="strong"><strong>Hierarchy</strong></span> window to the <code class="literal">Prefabs</code> folder.</li><li class="listitem">Add a couple of extra ships to the scene and try it out.<div class="mediaobject"><img src="graphics/2014OT_06_06.jpg" alt="Time for action – adding an enemy ship"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created an enemy space ship. The ships will fly after the player and begin shooting when within range. Like the asteroids, they move around the player to fake the player's movement. However, instead of moving in a random direction, the enemy ships turn towards the player. By slowing down how fast the ships can turn, they move in arcs rather than pivoting quickly in place. Also, because of the <span class="strong"><strong>Rigidbody</strong></span> component attached to the enemy ships, they can collide with the asteroids that are in the scene.</p></div><div class="section" title="Have a go hero – skybox and fog"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Have a go hero – skybox and fog</h2></div></div></div><p>Now that we have several objects flying<a id="id441" class="indexterm"/> around in space, it is a good idea to make the scene look a little better. For our Tank Battle game, we added a skybox to make the scene look like it is actually on a planet. However, we are flying around in space. The challenge is for you to find or make a skybox that looks like outer space. Also, adding some distant fog will obscure objects as they move too far away from the player. If the fog is black, it will look like the objects are swallowed by the blackness of deep space.</p></div></div>
<div class="section" title="Controlling with touch"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec92"/>Controlling with touch</h1></div></div></div><p>Now that we have several objects flying around in our space scene, including some that will shoot at the player, we should give the player the ability to do more than just dodge. One of the most obvious features of the modern mobile device is the touch screen. The devices use the electrical conductivity of the user's finger and many tiny contact points to determine the location that is being touched. Unity <a id="id442" class="indexterm"/>provides us with easy access to the touch inputs. By combining the input with ray casts, as we did for making the tanks fire, we can determine which object in the 3D space was touched by the user. For us, this means we can give the player the ability to shoot at and destroy the objects in space.</p></div>
<div class="section" title="Time for action &#x2013; touch to shoot"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec93"/>Time for action – touch to shoot</h1></div></div></div><p>For making use of the touch inputs, we will need to add a single script to our player's ship:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To give the player the ability to shoot, we need to first create a new script and call it <code class="literal">TouchShoot</code>.</li><li class="listitem">This script begins with a <a id="id443" class="indexterm"/>single variable. A <code class="literal">LayerMask</code> is used to selectively hit objects with a raycast. There are essentially a lot of layers that should be hit. This one will be used to determine what the player can or cannot shoot.<div class="informalexample"><pre class="programlisting">public LayerMask touchMask = -1;</pre></div></li><li class="listitem">The <code class="literal">Update</code> function<a id="id444" class="indexterm"/> is the only function in this script. It starts with a loop. The <code class="literal">Input</code> class provides us with the <code class="literal">touchCount</code> value, which is simply a counter for how many fingers are currently touching the device screen.<div class="informalexample"><pre class="programlisting">public void Update() {
  for(int i=0;i&lt;Input.touchCount;i++) {</pre></div></li><li class="listitem">As we progress through the loop, we use the <code class="literal">Input.GetTouch</code> function to access information about each touch. This line of code checks the phase of the touch. Every touch has five potential phases: <span class="strong"><strong>Began</strong></span>, <span class="strong"><strong>Moved</strong></span>, <span class="strong"><strong>Stationary</strong></span>, <span class="strong"><strong>Ended</strong></span>, and <span class="strong"><strong>Cancelled</strong></span>:<div class="informalexample"><pre class="programlisting">if(Input.GetTouch(i).phase == TouchPhase.Began) {</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Began</strong></span>: This phase of touch is when the user first touches the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Moved</strong></span>: This phase of touch is when the user moves his/her finger across the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stationary</strong></span>: This phase<a id="id445" class="indexterm"/> of touch is the opposite of the previous phase; it is when the finger is not moving across the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ended</strong></span>: This phase of touch is when the finger is lifted off the screen. This is the normal way for a touch to complete.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cancelled</strong></span>: This phase of touch is when an error occurs while tracking the touch. This phase tends to occur most often when a finger is touching the screen, but not moving for too long. The touch system is not perfect, so it assumes it missed the finger being lifted off the screen and just cancels it.</li></ul></div></li><li class="listitem">Next, we create a pair of variables. The first is a <code class="literal">Ray</code>, which is just a container for storing a point in space and a directional vector. The <code class="literal">ScreenPointToRay</code> function<a id="id446" class="indexterm"/> is specially provided by the camera for converting touch positions from the 2D space of the screen to the 3D space of the game world. As with our tanks, the second is a holder for what was hit by our raycast.<div class="informalexample"><pre class="programlisting">Ray ray = Camera.main.ScreenPointToRay(Input.GetTouch(i).position);
RaycastHit hit;</pre></div></li><li class="listitem">The last step for the function is to call the <code class="literal">Raycast</code> function. We pass the ray, and the tracking variable to the function. Next, we have to give it a distance, and finally the <code class="literal">LayerMask</code>. If an object is hit, it is destroyed. Also, there are several curly braces required to close off the if statements, loop, and function.<div class="informalexample"><pre class="programlisting">      if(Physics.Raycast(ray, out hit, Mathf.Infinity, touchMask)) {
        Destroy(hit.transform.gameObject);
      }
    }
  }
}</pre></div></li><li class="listitem">To try the script out, simply add it to the <span class="strong"><strong>PlayerShipPivot</strong></span> GameObject. Be careful. At this point, if you were to touch the player's ship while testing, it would be destroyed.</li><li class="listitem">In order to fix this issue,<a id="id447" class="indexterm"/> we need to create a new layer. Start by going to the menu bar of Unity and clicking on <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Tags</strong></span>. This is just a second path to the same location where we created layers for the Tank Battle game.</li><li class="listitem">Click on the right of <span class="strong"><strong>User Layer 8</strong></span> and input <code class="literal">Player</code> in the field. This will create the new layer.</li><li class="listitem">Select the <span class="strong"><strong>PlayerShipPivot</strong></span> object in the <span class="strong"><strong>Hierarchy</strong></span> window.</li><li class="listitem">In the top-right corner of the <span class="strong"><strong>Inspector</strong></span> window, select the layer we just created from the <span class="strong"><strong>Layers</strong></span> drop-down list.</li><li class="listitem">When Unity asks whether you want to change the children objects as well, confirm that you do.</li><li class="listitem">For the <code class="literal">TouchShoot</code> script, deselect the new layer from the <span class="strong"><strong>Touch Mask</strong></span> list. This will allow the player to shoot everything but themselves.</li><li class="listitem">There is one last thing we need to do. Go to the menu bar of Unity and click on <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span>. This opens a new set of controls in the <span class="strong"><strong>Inspector</strong></span> window that adjust how the Physics engine runs.</li><li class="listitem">At the moment, we only care about the <span class="strong"><strong>Raycasts Hit Triggers</strong></span> checkbox<a id="id448" class="indexterm"/>. Uncheck it. If we don't, the players will hit the trigger volume that is around the asteroid when they shoot, rather than the asteroid itself. It is not so great an issue for the asteroids. But, if we were to create something, such as an explosive mine, the trigger volume would be much larger. That would make it very odd-looking for shooting at the mine.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We gave the player the ability to shoot when they touch the screen. By looping through the list of touches, the player is able to use more than one finger for shooting at targets. The special <a id="id449" class="indexterm"/>
<code class="literal">ScreenPointToRay</code> function provided by the camera allows us to change 2D screen touches into 3D game world interactions. By making use of the <code class="literal">LayerMask</code>, we also prevent the player from shooting and destroying themselves.</p></div><div class="section" title="Have a go hero – healthy ships"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Have a go hero – healthy ships</h2></div></div></div><p>The challenge here is to give the enemy ships some health. When we created the enemy tanks in the previous chapter, we caused them to take a few shots from the player before they would be destroyed. Do the same thing here for the enemy ships.</p></div><div class="section" title="Spawning in space"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Spawning in space</h2></div></div></div><p>So far, we have created a space game that allows the player to fly infinitely through space. The player never actually moves; instead, the objects in the scene move around it to fake the movement. We have asteroids that will fly in a random direction through space. We also created enemy spaceships that fly after the player and shoot at them. Finally, we have the ability to shoot at and destroy the objects in the scene. However, at this point we can quickly run out of things to shoot at. Either they get too far away, or we destroy them. To fix this, we will now create a system that will randomly spawn all that we have created around the player.</p></div></div>
<div class="section" title="Time for action &#x2013; creating a space spawn"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec94"/>Time for action – creating a space spawn</h1></div></div></div><p>Our last script will populate <a id="id450" class="indexterm"/>our space and will be attached to the player's ship, since it is the center of the game world:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To fill our space with the objects, we need to create another script. Name it <code class="literal">SpaceSpawn</code>.</li><li class="listitem">We start it out with two variables. These two define the space within which the new objects will be spawned. They will be created outside the minimum range but within the maximum range.<div class="informalexample"><pre class="programlisting">public float minRange = 200f;
public float maxRange = 300f;</pre></div></li><li class="listitem">Next, we have two variables for controlling the frequency at which objects should be spawned. These will work the same as the ones we used for making the enemy ships shoot at the player.<div class="informalexample"><pre class="programlisting">public float frequency = 0.3f;
private float spawnTime = 0;</pre></div></li><li class="listitem">The final variable for this script, is an array. It is simply a list of all of the objects that can be spawned. We will be filling it in a little bit, when we return to Unity to set it up.<div class="informalexample"><pre class="programlisting">public GameObject[] spawnList = new GameObject[0];</pre></div></li><li class="listitem"><code class="literal">Update</code> is once again our function of choice for the script. We start it off by making sure that there is something in the list to be spawned. If there are no objects to be spawned, there is no point in continuing.<div class="informalexample"><pre class="programlisting">public void Update() {
  if(spawnList.Length &lt;= 0) return;</pre></div></li><li class="listitem">Next, we track how long it has been since the last spawn and check to see if it has been long enough to spawn once more. Again, this works just like the shooting of the enemy ships.<div class="informalexample"><pre class="programlisting">spawnTime += Time.deltaTime;
if(spawnTime &lt; frequency) return;</pre></div></li><li class="listitem">Now, we need to figure out where to spawn the next object in space. To do this, we first use <code class="literal">Random.onUnitSphere</code> to find a random direction. Next, we find a random distance that lies within our min and max ranges. Finally, they are multiplied together to give us a position.<div class="informalexample"><pre class="programlisting">Vector3 direction = Random.onUnitSphere;
float distance = Random.Range(minRange, maxRange);
Vector3 position = direction * distance;</pre></div></li><li class="listitem">To pick a random object, we use <code class="literal">Random.Range</code> and pass the length of the list of objects to it.<a id="id451" class="indexterm"/> This will give us the index of one of the slots of the list. The following line of code makes sure that there is an object in the slot. If there isn't, we cannot spawn it.<div class="informalexample"><pre class="programlisting">int index = Random.Range(0, spawnList.Length);
if(spawnList[index] == null) return;</pre></div></li><li class="listitem">Next, we actually spawn the object using our good friend, the <code class="literal">Instantiate</code> function. We pass the object we randomly selected, the position we found, and finally, a random rotation to the <a id="id452" class="indexterm"/><code class="literal">Instantiate</code> function. As a result, the object is created in the scene and set into place.<div class="informalexample"><pre class="programlisting">Instantiate(spawnList[index], position, Random.rotation);</pre></div></li><li class="listitem">Finally, we subtract the <code class="literal">frequency</code> variable from our time tracker to finish off the function and the script. This will cause a spawn to occur on every frequency tick without losing any time.<div class="informalexample"><pre class="programlisting">  spawnTime -= frequency;
}</pre></div></li><li class="listitem">We now return to Unity to set up the script. Add it to the <code class="literal">PlayerShipPivot</code> object. It will work as well here as anywhere else.</li><li class="listitem">To fill the list, just drag your prefabs from the <span class="strong"><strong>Project</strong></span> window and drop them on <span class="strong"><strong>Spawn List</strong></span> in the <span class="strong"><strong>Inspector</strong></span> window. The little triangle to the left of the field will let you expand the list and see what is currently in it. If you want to adjust the chances of the various objects appearing, just change how many of them are in the list. There is nothing keeping you from putting nine references to the asteroid prefab into the list and a single reference to the enemy ship prefab, to give the ship a one in 10 chance of being spawned. Whatever you choose, use the list to set the object chances and include at least one of each obstacle we have created.</li><li class="listitem">Finally, test it out. Hit play and fly around to see the objects spawn and fly around.<div class="mediaobject"><img src="graphics/2014OT_06_07.jpg" alt="Time for action – creating a space spawn"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created a system for<a id="id453" class="indexterm"/> spawning objects randomly in space. First, we tracked time in the same way as we did for making the enemy ships shoot at the player. Next, we found a random direction and the range with which we determined a position. After that, the system selects a random object from the list and finally spawns it. In order to adjust the chances of any single object appearing, we just adjust how often it appears in the list of objects to be spawned, relative to the other objects in the list.</p></div><div class="section" title="Have a go hero – more to spawn and shoot"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Have a go hero – more to spawn and shoot</h2></div></div></div><p>Included in the starting assets for this chapter are two more asteroid meshes and a mine. Using these, you can create more objects to be spawned in the game. The mine can also be created with a much larger trigger volume. This would allow it to explode when ships get close, not just hit it. If you were additionally inclined, you could at least make the asteroids randomly pick a scale when they are spawned. This would give the appearance of even greater variety in the asteroids, even though there are only a few.</p><p>Also, try creating another ship or several other ships. Perhaps one is a transport ship and it flees from the player. A hard one would be a ship that splits into two smaller ships when destroyed. Or, just recreate your favorite space ships from your favorite sci-fi media. In this game, the universe is the limit.</p><p>For the Tank Battle game, <a id="id454" class="indexterm"/>we created a turbo boost button for getting the player across the city quickly. It is also useful for fleeing enemies. Implement it for the space fighter. It would be useful for catching enemies and dodging bullets.</p></div><div class="section" title="Pop Quiz – understanding Android components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Pop Quiz – understanding Android components</h2></div></div></div><p>Modern mobile devices have many parts that perform a huge variety of functions. Knowing what they are and how they work together is the first step towards being able to use them. Are the following statements true or false?</p><p>Q1. The magnometer and accelerometer work together to give position on a map.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q2. The gyroscope detects rotation and movement of the device.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q3. 2D positions on the touch screen can be translated into 3D positions in the game.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q4. What line of code will allow us to translate the user's touch to a 3D position in the game?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Camera.main.ScreenPointToRay(Input.GetTouch(0).position)</code></li><li class="listitem"><code class="literal">Input.GetMouseButton(0)</code></li><li class="listitem"><code class="literal">Camera.main.WorldToScreenPoint(Input.GetTouch(0).position)</code></li></ol></div><p>Q5. What line of code will give us the device's acceleration?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Input.gyro</code></li><li class="listitem"><code class="literal">Input.compass</code></li><li class="listitem"><code class="literal">Input.acceleration</code></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec95"/>Summary</h1></div></div></div><p>In this chapter, we learned about the specialties of the modern mobile device. We created a Space Fighter game to try it out. We gained access to the device's accelerometer to detect when it is rotated. This gave our spaceship the ability to be steered. We also made use of the touch screen to give a player the ability to shoot enemies in the game. Because we wanted an infinite amount of space to fly through, we had to make it all without the player moving. Instead, everything else moves around the player, faking the player's movement. It also required a system that continuously spawned new enemies and obstacles around the player, allowing us to keep flying and finding new things to play with.</p><p>In the next chapter, we will be taking a short break from our Space Fighter game. Almost certainly the most popular mobile game on the market, Angry Birds is a distinct and not uncommon type of game. In order to learn about Physics in Unity and the possibility of a 2D-style game, we will be making an Angry Birds clone. We will also take a look at Parallax scrolling to create a pleasing background. Before you know it, we will be creating all of the Angry Birds levels that you always wished you could play.</p></div></body></html>