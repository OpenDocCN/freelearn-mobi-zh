["```swift\n        override func viewWillLayoutSubviews() {\n            super.viewWillLayoutSubviews()\n            // Create our scene:\n            let scene = GameScene()\n            // Configure the view:\n            let skView = self.view as! SKView\n            skView.showsFPS = true\n            skView.showsNodeCount = true\n            skView.ignoresSiblingOrder = true\n            scene.scaleMode = .AspectFill\n            // size our scene to fit the view exactly:\n            scene.size = view.bounds.size\n            // Show the new scene:\n            skView.presentScene(scene)\n        }\n        ```", "```swift\n        override func supportedInterfaceOrientations() -> Int {\n            return Int(\n            UIInterfaceOrientationMask.Landscape.rawValue);\n        }\n        ```", "```swift\noverride func didMoveToView(view: SKView) {\n    // Instantiate a constant, mySprite, instance of SKSpriteNode\n    // The SKSpriteNode constructor can set color and size\n    // Note: UIColor is a UIKit class with built-in color presets\n    // Note: CGSize is a type we use to set node sizes\n    let mySprite = SKSpriteNode(color: UIColor.blueColor(), size: \n        CGSize(width: 50, height: 50))\n\n    // Assign our sprite a position in points, relative to its \n    // parent node (in this case, the scene)\n    mySprite.position = CGPoint(x: 300, y: 300)\n\n    // Finally, we need to add our sprite node into the node tree.\n    // Call the SKScene's addChild function to add the node\n    // Note: In Swift, 'self' is an automatic property\n    // on any type instance, exactly equal to the instance itself\n    // So in this instance, it refers to the GameScene instance\n    self.addChild(mySprite)\n}\n```", "```swift\n// Create a new constant for our action instance\n// Use the moveTo action to provide a goal position for a node\n// SpriteKit will tween to the new position over the course of the\n// duration, in this case 5 seconds\nlet demoAction = SKAction.moveTo(CGPoint(x: 100, y: 100), \n    duration: 5)\n// Tell our square node to execute the action!\nmySprite.runAction(demoAction)\n```", "```swift\nlet demoAction = SKAction.scaleTo(4, duration: 5)\n```", "```swift\n// Scale up to 4x initial scale\nlet demoAction1 = SKAction.scaleTo(4, duration: 5)\n// Rotate 5 radians\nlet demoAction2 = SKAction.rotateByAngle(5, duration: 5)\n// Group the actions\nlet actionGroup = SKAction.group([demoAction1, demoAction2])\n// Execute the group!\nmySprite.runAction(actionGroup)\n```", "```swift\n// Group the actions into a sequence\nlet actionSequence = SKAction.sequence([demoAction1, demoAction2])\n\n// Execute the sequence!\nmySprite.runAction(actionSequence)\n```", "```swift\noverride func didMoveToView(view: SKView) {\n    // Instantiate a constant, mySprite, instance of SKSpriteNode\n    let mySprite = SKSpriteNode(color: UIColor.blueColor(), size: \n        CGSize(width: 50, height: 50))\n\n    // Assign our sprite a position\n    mySprite.position = CGPoint(x: 300, y: 300)\n\n    // Add our sprite node into the node tree\n    self.addChild(mySprite)\n\n    // Scale up to 4x initial scale\n    let demoAction1 = SKAction.scaleTo(CGFloat(4), duration: 2)\n    // Rotate 5 radians\n    let demoAction2 = SKAction.rotateByAngle(5, duration: 2)\n\n    // Group the actions into a sequence\n    let actionSequence = SKAction.sequence([demoAction1, \n        demoAction2])\n\n    // Execute the sequence!\n    mySprite.runAction(actionSequence)\n}\n```", "```swift\noverride func didMoveToView(view: SKView) {\n    // set the scene's background to a nice sky blue\n    // Note: UIColor uses a scale from 0 to 1 for its colors\n    self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: \n        0.95, alpha: 1.0);\n\n    // create our bee sprite node\n    let bee = SKSpriteNode(imageNamed: \"bee.png\")\n    // size our bee node\n    bee.size = CGSize(width: 100, height: 100)\n    // position our bee node\n    bee.position = CGPoint(x: 250, y: 250)\n    // attach our bee to the scene's node tree\n    self.addChild(bee)\n}\n```", "```swift\n    // size our bee in points:\n    bee.size = CGSize(width: 28, height: 24)\n    ```", "```swift\n// create our bee sprite\n// notice the new image name: bee_fly.png\nlet bee = SKSpriteNode(imageNamed: \"bee_fly.png\")\n```", "```swift\noverride func didMoveToView(view: SKView) {\n    self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: \n        0.95, alpha: 1.0)\n\n    // create our bee sprite\n    // Note: Remove all prior arguments from this line:\n    let bee = SKSpriteNode()\n    bee.position = CGPoint(x: 250, y: 250)\n    bee.size = CGSize(width: 28, height: 24)\n    self.addChild(bee)\n\n    // Find our new bee texture atlas\n    let beeAtlas = SKTextureAtlas(named:\"bee.atlas\")\n    // Grab the two bee frames from the texture atlas in an array\n    // Note: Check out the syntax explicitly declaring beeFrames\n    // as an array of SKTextures. This is not strictly necessary,\n    // but it makes the intent of the code more readable, so I \n    // chose to include the explicit type declaration here:\n    let beeFrames:[SKTexture] = [\n        beeAtlas.textureNamed(\"bee.png\"), \n        beeAtlas.textureNamed(\"bee_fly.png\")]\n    // Create a new SKAction to animate between the frames once\n    let flyAction = SKAction.animateWithTextures(beeFrames, \n        timePerFrame: 0.14)\n    // Create an SKAction to run the flyAction repeatedly\n    let beeAction = SKAction.repeatActionForever(flyAction)\n    // Instruct our bee to run the final repeat action:\n    bee.runAction(beeAction)\n}\n```", "```swift\n// Set up new actions to move our bee back and forth:\nlet pathLeft = SKAction.moveByX(-200, y: -10, duration: 2)\nlet pathRight = SKAction.moveByX(200, y: 10, duration: 2)\n// These two scaleXTo actions flip the texture back and forth\n// We will use these to turn the bee to face left and right\nlet flipTextureNegative = SKAction.scaleXTo(-1, duration: 0)\nlet flipTexturePositive = SKAction.scaleXTo(1, duration: 0)\n// Combine actions into a cohesive flight sequence for our bee\nlet flightOfTheBee = SKAction.sequence([pathLeft, \n    flipTextureNegative, pathRight, flipTexturePositive])\n// Last, create a looping action that will repeat forever\nlet neverEndingFlight = \n    SKAction.repeatActionForever(flightOfTheBee)\n\n// Tell our bee to run the flight path, and away it goes!\nbee.runAction(neverEndingFlight)\n```", "```swift\nimport SpriteKit\n\nclass GameScene: SKScene {\n    // Create the world as a generic SKNode\n    let world = SKNode()\n    // Create our bee node as a property of GameScene so we can \n    // access it throughout the class\n    // (Make sure to remove the old bee declaration inside the \n    // didMoveToView function.)\n    let bee = SKSpriteNode()\n\n    override func didMoveToView(view: SKView) {\n        self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: \n            0.95, alpha: 1.0)\n\n        // Add the world node as a child of the scene\n        self.addChild(world)\n        // Call the new bee function\n        self.addTheFlyingBee()\n    }\n\n    // I moved all of our bee animation code into a new function:\n    func addTheFlyingBee() {\n        // Position our bee\n        bee.position = CGPoint(x: 250, y: 250)\n        bee.size = CGSize(width: 28, height: 24)\n        // Notice we now attach our bee node to the world node:\n        world.addChild(bee)\n\n        /*\n            all of the same bee animation code remains here,\n            I am excluding it in this text for brevity\n        */\n    }\n\n    // A new function\n    override func didSimulatePhysics() {\n        // To find the correct position, subtract half of the   \n        // scene size from the bee's position, adjusted for any  \n        // world scaling.\n        // Multiply by -1 and you have the adjustment to keep our \n        // sprite centered:\n        let worldXPos = -(bee.position.x * world.xScale - \n            (self.size.width / 2))\n        let worldYPos = -(bee.position.y * world.yScale - \n            (self.size.height / 2))\n        // Move the world so that the bee is centered in the scene\n        world.position = CGPoint(x: worldXPos, y: worldYPos)\n    }\n\n}\n```"]