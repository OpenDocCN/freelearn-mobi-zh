["```swift\nimplementation \"androidx.work:work-runtime:2.8.0\"\n```", "```swift\nclass CatStretchingWorker(\n  context: Context, workerParameters: WorkerParameters\n) : Worker(context, workerParameters) {\n  override fun doWork(): Result {\n    val catAgentId =\n      inputData.getString(INPUT_DATA_CAT_AGENT_ID)\n    Thread.sleep(3000L)\n    val outputData = Data.Builder()\n      .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)\n      .build()\n      return Result.success(outputData)\n  }\n  companion object {\n    const val INPUT_DATA_CAT_AGENT_ID = \"id\"\n    const val OUTPUT_DATA_CAT_AGENT_ID = \"id\"\n  }\n}\n```", "```swift\nval catStretchingInputData = Data.Builder()\n  .putString(CatStretchingWorker.INPUT_DATA_CAT_AGENT_ID,\n  \"catAgentId\").build()\nval catStretchingRequest = OneTimeWorkRequest\n  .Builder(CatStretchingWorker::class.java)\nval catStretchingRequest = OneTimeWorkRequest.Builder(\n  CatStretchingWorker::class.java)\n    .setConstraints(networkConstraints)\n    .setInputData(catStretchingInputData)\n    .build()\n...\nWorkManager.getInstance(this)\n  .beginWith(catStretchingRequest)\n  .then(catFurGroomingRequest)\n  .then(catLitterBoxSittingRequest)\n  .then(catSuitUpRequest)\n  .enqueue()\n```", "```swift\nworkManager.getWorkInfoByIdLiveData(\n  catStretchingRequest.id\n).observe(this) { info ->\n  if (info.state.isFinished) { doSomething() }\n}\n```", "```swift\n    dependencies {\n        ...\n        implementation \"androidx.work:work-runtime:2.8.0\"\n        ...\n    }\n    ```", "```swift\n    package com.example.catagenttracker.worker\n    [imports]\n    class CatStretchingWorker(\n      context: Context, workerParameters: WorkerParameters\n    ) : Worker(context, workerParameters) {\n      override fun doWork(): Result {\n        val catAgentId =\n          inputData.getString(INPUT_DATA_CAT_AGENT_ID)\n        Thread.sleep(3000L)\n        val outputData = Data.Builder()\n          .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)\n          .build()\n        return Result.success(outputData)\n      }\n      companion object {\n        const val INPUT_DATA_CAT_AGENT_ID = \"inId\"\n        const val OUTPUT_DATA_CAT_AGENT_ID = \"outId\"\n      }\n    }\n    ```", "```swift\n    private fun getCatAgentIdInputData(\n      catAgentIdKey: String, catAgentIdValue: String) =\n      Data.Builder()\n        .putString(catAgentIdKey, catAgentIdValue).build()\n    ```", "```swift\n    override fun onCreate(savedInstanceState: Bundle?) {\n      super.onCreate(savedInstanceState)\n      setContentView(R.layout.activity_main)\n      val networkConstraints = Constraints.Builder()\n        .setRequiredNetworkType(NetworkType.CONNECTED)\n        .build()\n      val catAgentId = \"CatAgent1\"\n      val catStretchingRequest = OneTimeWorkRequest.\n        Builder(CatLitterBoxSittingWorker::class.java)\n        .setConstraints(networkConstraints)\n        .setInputData(\n          getCatAgentIdInputData(CatStretchingWorker\n            .INPUT_DATA_CAT_AGENT_ID, catAgentId)\n          ).build()\n      val catFurGroomingRequest = OneTimeWorkRequest.\n        Builder(CatFurGroomingWorker::class.java)\n        .setConstraints(networkConstraints)\n        .setInputData(getCatAgentIdInputData(\n          CatFurGroomingWorker.INPUT_DATA_CAT_AGENT_ID,\n            catAgentId)\n        ).build()\n      val catLitterBoxSittingRequest = OneTimeWorkRequest.\n        Builder(CatLitterBoxSittingWorker::class.java)\n        .setConstraints(networkConstraints)\n        .setInputData(getCatAgentIdInputData(\n    CatLitterBoxSittingWorker.INPUT_DATA_CAT_AGENT_ID,\n          catAgentId)\n        ).build()\n      val catSuitUpRequest = OneTimeWorkRequest.Builder(\n        CatSuitUpWorker::class.java\n      ).setConstraints(networkConstraints)\n        .setInputData(getCatAgentIdInputData(CatSuitUpWorker.\n          INPUT_DATA_CAT_AGENT_ID, catAgentId)\n        ).build()\n    }\n    ```", "```swift\n    private val workManager = WorkManager.getInstance(this)\n    ```", "```swift\n    val catSuitUpRequest = ...\n    workManager.beginWith(catStretchingRequest)\n        .then(catFurGroomingRequest)\n        .then(catLitterBoxSittingRequest)\n        .then(catSuitUpRequest)\n        .enqueue()\n    ```", "```swift\n    private fun showResult(message: String) {\n        Toast.makeText(this, message, LENGTH_SHORT).show()\n    }\n    ```", "```swift\n    workManager.beginWith(catStretchingRequest)\n        ...\n        .enqueue()\n    workManager.getWorkInfoByIdLiveData(\n        catStretchingRequest.id).observe(this) { info ->\n            if (info.state.isFinished) {\n                showResult(\"Agent done stretching\")\n            }\n        }\n    workManager.getWorkInfoByIdLiveData(\n        catFurGroomingRequest.id).observe(this) { info ->\n            if (info.state.isFinished) {\n                showResult(\"Agent done grooming its fur\")\n            }\n        }\n    workManager.getWorkInfoByIdLiveData(\n    catLitterBoxSittingRequest.id).observe(this) { info ->\n            if (info.state.isFinished) {\n                showResult(\"Agent done sitting in litter box\")\n            }\n        }\n    workManager.getWorkInfoByIdLiveData(\n        catSuitUpRequest.id).observe(this) { info ->\n             if (info.state.isFinished) {\n        showResult(\"Agent done suiting up. Ready to go!\")\n             }\n    }\n    ```", "```swift\nprivate fun onCreate() {\n  val channelId = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n    val newChannelId = \"ChannelId\"\n    val channelName = \"My Background Service\"\n    val channel = NotificationChannel(newChannelId,\n      channelName, NotificationManager.IMPORTANCE_DEFAULT)\n    val service = getSystemService(\n      Context.NOTIFICATION_SERVICE) as NotificationManager\n    service.createNotificationChannel(channel)\n    newChannelId\n  } else { \"\" }\n    val flag = if (Build.VERSION.SDK_INT >=\n      Build.VERSION_CODES.S) FLAG_IMMUTABLE else 0\n  val pendingIntent = Intent(this,\n    MainActivity::class.java).let { notificationIntent ->\n      PendingIntent.getActivity(this, 0,\n        notificationIntent, flag)\n    }\n  val notification =\n    NotificationCompat.Builder(this, channelId)\n      .setContentTitle(\"Content title\")\n      .setContentText(\"Content text\")\n      .setSmallIcon(R.drawable.notification_icon)\n      .setContentIntent(pendingIntent)\n      .setTicker(\"Ticker message\").build()\n  startForeground(NOTIFICATION_ID, notificationBuilder.build())\n}\n```", "```swift\nval notification =\n  NotificationCompat.Builder(this, channelId)\n    .setContentTitle(\"Content title\")\n    .setContentText(\"Content text\")\n    .setSmallIcon(R.drawable.notification_icon)\n    .setContentIntent(pendingIntent)\n    .setTicker(\"Ticker message\")\n    .build()\n```", "```swift\nclass ToastBroadcastReceiver : BroadcastReceiver() {\n  override fun onReceive(context: Context, intent: Intent) {\n    StringBuilder().apply {\n      append(\"Action: ${intent.action}\\n\")\n      append(\n        \"URI:${intent.toUri(Intent.URI_INTENT_SCHEME)}\\n\")\n      toString().let { eventText ->\n        Toast.makeText(context, eventText,\n        Toast.LENGTH_LONG).show()\n      }\n    }\n  }\n}\n```", "```swift\n<receiver android:name=\".ToastBroadcastReceiver\"\nandroid:exported=\"true\">\n  <intent-filter>\n    <action android:name=\n      \"android.intent.action.ACTION_POWER_CONNECTED\" />\n  </intent-filter>\n</receiver>\n```", "```swift\nval filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply { addAction(Intent.ACTION_POWER_CONNECTED) }\nregisterReceiver(ToastBroadcastReceiver(), filter)\n```", "```swift\ncompanion object {\n  private val mutableWorkCompletion = MutableLiveData<String>()\n  val workCompletion: LiveData<String> = mutableWorkCompletion\n}\n```", "```swift\n<application ...>\n    <service android:name=\"ForegroundService\" />\n</application>\n```", "```swift\nval serviceIntent = Intent(this, ForegroundService::class.java).apply {\n    putExtra(\"ExtraData\", \"Extra value\")\n}\n```", "```swift\n    implementation \"androidx.work:work-runtime:2.8.0\"\n    ```", "```swift\n    class RouteTrackingService : Service() {\n      override fun onBind(intent: Intent): IBinder? = null\n    }\n    ```", "```swift\n    companion object {\n        const val NOTIFICATION_ID = 0xCA7\n        const val EXTRA_SECRET_CAT_AGENT_ID = \"scaId\"\n        private val mutableTrackingCompletion =\n            MutableLiveData<String>()\n        val trackingCompletion: LiveData<String> =\n            mutableTrackingCompletion\n    }\n    ```", "```swift\n    private fun getPendingIntent(): PendingIntent {\n      val flag = if (Build.VERSION.SDK_INT >= Build.VERSION_\n        CODES.S) FLAG_IMMUTABLE else 0\n      return PendingIntent.getActivity(this, 0, Intent(this, \n        MainActivity::class.java), flag)\n    ```", "```swift\n    private fun createNotificationChannel(): String =\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        val newChannelId = \"CatDispatch\"\n        val channelName = \"Cat Dispatch Tracking\"\n        val channel = NotificationChannel(\n          newChannelId, channelName,\n          NotificationManager.IMPORTANCE_DEFAULT\n        )\n        val service = requireNotNull(\n          ContextCompat.getSystemService(this,\n            NotificationManager::class.java)\n        )\n        service.createNotificationChannel(channel)\n        newChannelId\n      } else { \"\" }\n    ```", "```swift\n    private fun getNotificationBuilder(pendingIntent:\n    PendingIntent, channelId: String) =\n        NotificationCompat.Builder(this, channelId)\n        .setContentTitle(\"Agent approaching destination\")\n        .setContentText(\"Agent dispatched\")\n        .setSmallIcon(R.drawable.ic_launcher_foreground)\n        .setContentIntent(pendingIntent)\n        .setTicker(\"Agent dispatched, tracking movement\")\n        .setOngoing(true)\n    ```", "```swift\n    private fun startForegroundService():\n    NotificationCompat.Builder {\n      val pendingIntent = getPendingIntent()\n      val channelId = if (Build.VERSION.SDK_INT >=\n        Build.VERSION_CODES.O) {\n          createNotificationChannel()\n      } else { \"\" }\n      val notificationBuilder = getNotificationBuilder(\n        pendingIntent, channelId)\n      startForeground(NOTIFICATION_ID, notificationBuilder.build())\n      return notificationBuilder\n    }\n    ```", "```swift\n    private lateinit var notificationBuilder:\n    NotificationCompat.Builder\n    private lateinit var serviceHandler: Handler\n    ```", "```swift\n    override fun onCreate() {\n      super.onCreate()\n      notificationBuilder = startForegroundService()\n      val handlerThread =\n        HandlerThread(\"RouteTracking\").apply { start() }\n      serviceHandler = Handler(handlerThread.looper)\n    }\n    ```", "```swift\n    private fun trackToDestination(notificationBuilder: NotificationCompat.Builder) {\n      val notificationManager = getSystemService(NOTIFICATION_\n        SERVICE) as NotificationManager\n      for (i in 10 downTo 0) {\n        Thread.sleep(1000L)\n        notificationBuilder.setContentText(\n          \"$i seconds to destination\").setSilent(true)\n        notificationManager.notify(NOTIFICATION_ID,\n          notificationBuilder.build())\n      }\n    }\n    ```", "```swift\n    private fun notifyCompletion(agentId: String) {\n        Handler(Looper.getMainLooper()).post {\n            mutableTrackingCompletion.value = agentId\n        }\n    }\n    ```", "```swift\n    override fun onStartCommand(intent: Intent?, flags:\n    Int, startId: Int): Int {\n      val returnValue = super.onStartCommand(intent,\n        flags, startId)\n      val agentId = intent?.getStringExtra(EXTRA_SECRET_CAT_\n        AGENT_ID)\n        ?: throw IllegalStateException(\"Agent ID must be \n        provided\")\n      serviceHandler.post {\n        trackToDestination(notificationBuilder)\n        notifyCompletion(agentId)\n        stopForeground(true)\n        stopSelf()\n      }\n      return returnValue\n    }\n    ```", "```swift\n    <manifest ...>\n      <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n      <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n      <application ...>\n        <service\n          android:name=\".RouteTrackingService\"\n          android:enabled=\"true\"\n          android:exported=\"true\" />\n        <activity ...>\n    ```", "```swift\n    private fun launchTrackingService() {\n      RouteTrackingService.trackingCompletion.observe(\n        this) { agentId ->\n            showResult(\"Agent $agentId arrived!\")\n        }\n      val serviceIntent = Intent(this,\n        RouteTrackingService::class.java).apply {\n          putExtra(EXTRA_SECRET_CAT_AGENT_ID, \"007\")\n        }\n      ContextCompat.startForegroundService(this, \n      serviceIntent)\n    }\n    ```", "```swift\n    workManager.getWorkInfoByIdLiveData(\n      catSuitUpRequest.id).observe(this) { info ->\n      if (info.state.isFinished) {\n        showResult(\"Agent done suiting up. Ready to go!\")\n        launchTrackingService()\n      }\n    }\n    ```"]