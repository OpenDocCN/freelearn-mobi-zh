- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding and Interacting with RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to add lists and grids of items to your
    apps and effectively leverage the recycling power of `RecyclerView`. You’ll also
    learn how to handle user interaction with the item views on the screen and support
    different item view types – for example, for titles. Later in the chapter, you’ll
    add and remove items dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have the skills required to present your
    users with interactive lists of rich items.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to fetch data, including lists of items
    and image URLs, from APIs, and how to load images from URLs. Combining that knowledge
    with the ability to display lists of items is the goal of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, you will want to present your users with a list of items. For example,
    you might want to show them a list of pictures on their device or let them select
    their country from a list of all countries. To do that, you would need to populate
    multiple views, all sharing the same layout but presenting different content.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, this was achieved by using `ListView` or `GridView`. While both
    are still viable options, they do not offer the robustness and flexibility of
    `RecyclerView`. For example, they do not support large datasets well, they do
    not support horizontal scrolling, and they do not offer rich divider customization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the divider between items in `RecyclerView` can be easily achieved
    using `RecyclerView.ItemDecorator`.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does `RecyclerView` do? `RecyclerView` orchestrates the creation, population,
    and reuse (hence the name) of views representing lists of items. To use `RecyclerView`,
    you need to familiarize yourself with two of its dependencies – the adapter (and
    through it, the view holder) and the layout manager. These dependencies provide
    our `RecyclerView` with the content to show, as well as tell it how to present
    that content and lay it out on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter provides `RecyclerView` with child views (nested Android views within
    `RecyclerView` used to represent individual data items) to draw on the screen,
    binds those views to data (via `ViewHolder` instances), and reports user interaction
    with those views.
  prefs: []
  type: TYPE_NORMAL
- en: The layout manager tells `RecyclerView` how to lay its children out. We are
    provided with three layout types by default – linear, grid, and staggered grid
    – managed by `LinearLayoutManager`, `GridLayoutManager`, and `StaggeredGridLayoutManager`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter relies on the use of the Jetpack RecyclerView library: [https://packt.link/FBX4d](https://packt.link/FBX4d).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop an app that lists secret agents and whether
    they are currently active or sleeping (and, thus, unavailable). The app will then
    allow us to add new agents or delete existing ones by swiping them away. There
    is a twist, though – as you saw in [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312),
    *Essential Libraries: Retrofit, Moshi, and Glide*, all our agents will be cats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `RecyclerView` to our layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating `RecyclerView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to clicks in `RecylerView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different item types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swiping to remove items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding items interactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/IJbeG](https://packt.link/IJbeG)
  prefs: []
  type: TYPE_NORMAL
- en: Adding RecyclerView to our layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19411_03.xhtml#_idTextAnchor163), *Developing the UI with
    Fragments*, we saw how we can add views to our layouts to be inflated by activities,
    fragments, or custom views. `RecyclerView` is just another such view. To add it
    to our layout, we need to add the following tag to our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should already be able to recognize the `android:id` attribute, as well
    as the `android:layout_width` and `android:layout_height` ones.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the optional `tools:listitem` attribute to tell Android Studio which
    layout to inflate as a list item in our preview toolbar. This will give us an
    idea of how `RecyclerView` might look in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a `RecyclerView` tag to our layout means we now have an empty container
    to hold the child views representing our list items. Once populated, it will handle
    the presenting, scrolling, and recycling of child views for us.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.01 – adding an empty RecyclerView to your main activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use `RecyclerView` in your app, you first need to add it to one of your
    layouts. Let’s add it to the layout inflated by our main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new empty activity project (`My RecyclerView App`. Make
    sure your package name is `com.example.myrecyclerviewapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the save location to where you want to save your project. Leave everything
    else at their default values and click **Finish**. Make sure you are on the **Android**
    view in your **Project** pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The Android view in the Project pane](img/B19411_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The Android view in the Project pane
  prefs: []
  type: TYPE_NORMAL
- en: Open your `activity_main.xml` file in **Text** mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To turn your label into a title at the top of the screen under which you can
    add your `RecyclerView`, add an ID to `TextView` and align it to the top, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following after the `TextView` tag to add an empty `RecyclerView` element
    to your layout, constrained below your `hello_label` `TextView` title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your layout file should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app by clicking the **Run app** button or pressing *Ctrl* + *R* (*Shift*
    + *F10* in Windows). On the emulator, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The app with an empty RecyclerView (image cropped for space)](img/B19411_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The app with an empty RecyclerView (image cropped for space)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our app runs, and our layout is presented on the screen. However,
    we do not see our `RecyclerView`. Why is that? At this stage, our `RecyclerView`
    has no content. `RecyclerView` with no content does not render by default – so,
    while our `RecyclerView` is indeed on the screen, it is not visible. This brings
    us to the next step – populating `RecyclerView` with content that we can actually
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Populating RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we added `RecyclerView` to our layout. For us to benefit from `RecyclerView`,
    we need to add content to it. Let’s see how we go about doing that.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, to add content to our `RecyclerView`, we would need
    to implement an adapter. An adapter binds our data to child views. In simpler
    terms, this means it tells `RecyclerView` how to plug data into views designed
    to present that data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say we want to present a list of employees.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to design our UI model. This will be a data object holding all
    the information needed by our view to present a single employee. Because this
    is a UI model, one convention is to suffix its name with `UiModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define `EmployeeRole` and `Gender` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The values are provided as an example, of course. Feel free to add more of your
    own!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The model’s hierarchy](img/B19411_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The model’s hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know what data to expect when binding to a view, so we can design our
    view to present this data (this is a simplified version of the actual layout,
    which we’ll save as `item_employee.xml`). We’ll start with `ImageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add a `TextView` for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, there is nothing new. You should be able to recognize all of the different
    view types from [*Chapter 2*](B19411_02.xhtml#_idTextAnchor103), *Building User*
    *Screen Flows*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – A preview of the item_cat.xml layout file](img/B19411_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – A preview of the item_cat.xml layout file
  prefs: []
  type: TYPE_NORMAL
- en: 'With a data model and a layout, we now have everything we need to bind our
    data to the view. To do that, we will implement a view holder. Usually, a view
    holder has two responsibilities – it holds a reference to a view (as its name
    implies), but it also binds data to that view. We will implement our view holder
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things worth noting in the preceding code. First, by convention,
    we suffixed the name of our view holder with `ViewHolder`. Second, note that `EmployeeViewHolder`
    needs to implement the abstract `RecyclerView.ViewHolder` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is required so that the generic type of our adapter can be our view holder.
    Lastly, we lazily keep references to the views we are interested in. The first
    time `bindData(EmployeeUiModel)` is called, we will find these views in the layout
    and keep references to them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced a `bindData(EmployeeUiModel)` function. This function will
    be called by our adapter to bind the data to the view held by the view holder.
    The last but most important thing to note is that we always make sure to set a
    state for all modified views for every possible input.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our view holder set up, we can proceed to implement our adapter. We will
    start by implementing the minimum required functions, plus a function to set the
    data. Our adapter will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over this implementation. First, we inject our dependencies into the
    adapter via its constructor. This will make testing our adapter much easier but
    will also allow us to change some of its behavior (for example, replace the image
    loading library) painlessly. In fact, we would not need to change the adapter
    at all in that case.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a private mutable list of `EmployeeUiModel` to store the data
    currently provided by the adapter to `RecyclerView`. We also introduce a method
    (`setData`) to populate that list. Note that we keep a local list and set its
    contents, rather than allowing `employees` to be set directly.
  prefs: []
  type: TYPE_NORMAL
- en: This is mainly because Kotlin, just like Java, passes variables by reference.
    Passing variables by reference means changes to the content of the list passed
    into the adapter would change the list held by the adapter. So, for example, if
    an item was removed outside of the adapter, the adapter would have that item removed
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes a problem because the adapter would not be aware of that change,
    and so would not be able to notify `RecyclerView`. There are other risks around
    a list being modified outside of the adapter, but covering them is beyond the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of encapsulating the modification of data in a function is that
    we avoid the risk of forgetting to notify `RecyclerView` that a dataset has changed,
    which we do by calling `notifyDataSetChanged()`.
  prefs: []
  type: TYPE_NORMAL
- en: We proceed to implement the adapter’s `onCreateViewHolder(ViewGroup, Int)` function.
    This function is called when `RecyclerView` needs a new `ViewHolder` to render
    data on a screen. It provides us with a `ViewGroup` container and a view type
    (we’ll look into view types later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The function then expects us to return a view holder initialized with a view
    (in our case, an inflated one). So, we inflate the view we designed earlier, passing
    it to a new `EmployeeViewHolder` instance. Note that the last argument to the
    inflated function is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes sure we do not attach the newly inflated view to the parent. Attaching
    and detaching views will be managed by the layout manager. Setting the view to
    `true` or omitting it would result in `IllegalStateException` being thrown. Finally,
    we return the newly created `EmployeeViewHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: To implement `getItemCount()`, we simply return the size of our `employees`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we implement `onBindViewHolder(EmployeeViewHolder, Int)`. This is done
    by passing `EmployeeUiModel`, stored in `employees`, at the given position to
    the `bindData(EmployeeUiModel)` function of our view holder. Our adapter is now
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we tried to plug our adapter into our `RecyclerView` at this point and run
    our app, we would still see no content. This is because we are still missing two
    small steps – setting data on our adapter and assigning a layout manager to our
    `RecyclerView`. The complete working code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running our app now, we would see a list of our employees.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we hardcoded the list of employees. In a production app, following
    a `ViewModel`. It is also important to note that we kept a reference to `employeesAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: This is so that we could, later on, set the data to different values. Some implementations
    rely on reading the adapter from `RecyclerView` itself – this can potentially
    result in unnecessary casting operations and unexpected states where the adapter
    is not yet assigned to `RecyclerView`, so this is generally not a recommended
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note that we chose to use `LinearLayoutManager`, providing it with the
    activity for context, a `VERTICAL` orientation flag, and `false` to tell it that
    we do not want the order of the items in the list reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.02 – populating your RecyclerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RecyclerView` is not very interesting without any content. It is time to populate
    `RecyclerView` by adding your secret cat agents to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick recap before you dive in – in the previous exercise, we introduced
    an empty list designed to hold a list of secret cat agents that users have at
    their disposal. In this exercise, you will be populating that list to present
    the users with the available secret cat agents in the agency:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our file structure tidy, we will start by creating a model package.
    Right-click on the package name of our app, and then select **New** | **Package**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Creating a new package](img/B19411_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Creating a new package
  prefs: []
  type: TYPE_NORMAL
- en: Name the new package `model`. Click **OK** to create the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create our first model data class, right-click on the newly created model
    package, and then select **New** | **Kotlin File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `CatUiModel`. Leave **kind** as **File** and click on **OK**. This will
    be the class holding the data we have about every individual cat agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the newly created `CatUiModel.kt` file to define the data
    class with all the relevant properties of a cat agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each cat agent, other than their name and photo, we want to know their gender,
    breed, and biography. This will help us choose the right agent for a mission.
  prefs: []
  type: TYPE_NORMAL
- en: Again, right-click on the model package, and then navigate to **New** | **Kotlin
    File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, name the new file `CatBreed` and set `kind` to the `Enum` class.
    This class will hold our different cat breeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your newly created `enum` with some initial values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat *step 6* and *step 7*, only this time call your file `Gender`. This will
    hold the accepted values for a cat agent’s gender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `Gender` enum, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to define the layout of the view holding the data about each cat agent,
    create a new layout resource file by right-clicking on `layout` and then selecting
    **New** | **Layout** **resource file**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Creating a new layout resource file](img/B19411_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Creating a new layout resource file
  prefs: []
  type: TYPE_NORMAL
- en: Name your resource `item_cat`. Leave all the other fields as they are and click
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the contents of the newly created `item_cat.xml` file (the following
    code block has been truncated for space, so use the following link to see the
    full code that you need to add):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: item_cat.xml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this step can be found at [http://packt.live/3sopUjo](http://packt.live/3sopUjo).
  prefs: []
  type: TYPE_NORMAL
- en: This will create a layout with an image and text fields for a name, breed, and
    biography to be used in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need a copy of `ImageLoader.kt`, introduced in [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312),
    *Essential Libraries: Retrofit, Moshi, and Glide*, so right-click on the package
    name of your app, navigate to `ImageLoader` and **kind** to **Interface**, and
    click **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312), *Essential Libraries:
    Retrofit, Moshi, and Glide*, you only need to add one function here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to import `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the package name of your app again, and then select **New** |
    **Kotlin File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the new file `CatViewHolder`. Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement `CatViewHolder`, which will bind the cat agent data to your views,
    replace the contents of the `CatViewHolder.kt` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still under our app package name, create a new Kotlin file named `CatsAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement `CatsAdapter`, which is responsible for storing the data for `RecyclerView`,
    as well as creating instances of your view holder and using them to bind data
    to views, replace the contents of the `CatsAdapter.kt` file with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you need to include Glide in your project. Start by adding the
    following line of code to the `dependencies` block inside your app’s `gradle.build`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `GlideImageLoader` class in your app package path, containing the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple implementation assuming the loaded image should always be center-cropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `MainActivity` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will define your adapter, attach it to `RecyclerView`, and populate it
    with some hardcoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `AndroidManifest.xml` file, add the following in the `manifest` tag
    before the application tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having this tag will allow your app to download images from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some final touches, such as giving our title view a proper name and text,
    update your `activity_main.xml` file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, update your `strings.xml` file to give your app a proper name and title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your app. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – RecyclerView with hardcoded secret cat agents](img/B19411_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – RecyclerView with hardcoded secret cat agents
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `RecyclerView` now has content, and your app is starting to
    take shape. Note how the same layout is used to present different items based
    on the data bound to each instance. As you would expect, if you add enough items
    for them to go off screen, scrolling works. Next, we’ll look into allowing a user
    to interact with the items inside our `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to clicks in RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we want to let our users select an item from a presented list? To achieve
    that, we need to communicate clicks back to our app.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in implementing click interaction is to capture clicks on items
    at the `ViewHolder` level. To maintain separation between our view holder and
    the adapter, we define a nested `OnClickListener` interface in our view holder.
    We choose to define the interface within the view holder because that and the
    listener are tightly coupled.
  prefs: []
  type: TYPE_NORMAL
- en: The interface will, in our case, have only one function. The purpose of this
    function is to inform the owner of the view holder about the clicks. The owner
    of a view holder is usually a `Fragment` or an `Activity`. Since we know that
    a view holder can be reused, we know that it can be challenging to define it at
    construction time in a way that would tell us which item was clicked (since that
    item will change over time with reuse).
  prefs: []
  type: TYPE_NORMAL
- en: 'We work around that by passing the currently presented item back to the owner
    of the view holder on clicking. This means our interface would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add this listener as a parameter to our `ViewHolder` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want our adapter to pass in a listener. In turn, that listener will
    be responsible for informing the owner of the adapter about the click. This means
    our adapter, too, would need a nested listener interface, quite similar to the
    one we implemented in our view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While this seems like duplication that can be avoided by reusing the same listener,
    that is not a great idea, as it leads to tight coupling between the view holder
    and the adapter through the listener. What happens when you want your adapter
    to also report other events through the listener? You would have to handle those
    events coming from the view holder, even though they would not actually be implemented
    in the view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to handle the click event and show a dialog, we define a listener in
    our activity and pass it to our adapter. We set that listener to show a dialog
    on clicking. In an MVVM implementation, you would be notifying the `ViewModel`
    of the click at this point instead. `ViewModel` would then update its state, telling
    the view (our activity) that it should display the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.03 – responding to clicks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your app already shows the user a list of secret cat agents. It is time to
    allow your user to choose a secret cat agent by clicking on its view. Click events
    are delegated from the view holder to the adapter to the activity, as shown in
    *Figure 6**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The flow of click events](img/B19411_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The flow of click events
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps that you need to follow to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `CatViewHolder.kt` file. Add a nested interface to it right before
    the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be the interface that a listener will have to implement in order to
    register for click events on individual cat items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `CatViewHolder` constructor to accept `OnClickListener` and make
    `containerView` accessible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when constructing a `CatViewHolder` constructor, you also register for
    clicks on item views.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your `bindData(CatUiModel)` function, add the following to intercept
    clicks and report them to the provided listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open your `CatsAdapter.kt` file. Add this nested interface right before
    the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines the interface that listeners will have to implement to receive
    item click events from the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `CatsAdapter` constructor to accept a call implementing the `OnClickListener`
    adapter you just defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `onCreateViewHolder(ViewGroup, Int)`, update the creation of the view holder,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add an anonymous class that delegates the `ViewHolder` click events
    to the adapter listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open your `MainActivity.kt` file. Update your `catsAdapter` construction
    as follows to provide the required dependencies to the adapter, in the form of
    an anonymous listener handling click events by showing a dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function right before the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will show a dialog with the name of the cat whose data was passed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to import the right version of `AlertDialog`, which is `androidx.appcompat.app.AlertDialog`,
    not `android.app.AlertDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The AppCompat version is usually a better choice because it offers backward
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your app. Clicking on one of the cats should now open a dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – A dialog showing an agent was selected](img/B19411_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – A dialog showing an agent was selected
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking the different items, and note the different messages presented.
    You now know how to respond to users clicking on items inside your `RecyclerView`.
    Next, we will look at how we can support different item types in our lists.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different Item types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to handle a list of items of a single
    type (in our case, all our items were `CatUiModel`). What happens if you want
    to support more than one type of item? A good example of this would be having
    group titles on our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that instead of getting a list of cats, we get a list containing
    happy cats and sad cats. Each of the two groups of cats is preceded by a title
    of the corresponding group. Instead of a list of `CatUiModel` instances, our list
    would now contain `ListItem` instances. `ListItem` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list of items may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this case, having just one layout type will not do. Luckily, as you may have
    noticed in our earlier exercises, `RecyclerView.Adapter` provides us with a mechanism
    to handle this (remember the `viewType` parameter used in the `onCreateViewHolder(ViewGroup,`
    `Int)` function?).
  prefs: []
  type: TYPE_NORMAL
- en: 'To help the adapter determine which view type is needed for each item, we override
    its `getItemViewType(Int)` function. An example of an implementation that would
    do the trick for us is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT` are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This implementation maps the data type at a given position to a constant value,
    representing one of our known layout types. In our case, we know about titles
    and cats, thus the two types. The values we use can be any integer values as they’re
    passed back to us, as is the case in the `onCreateViewHolder(ViewGroup, Int)`
    function. All we need to do is make sure not to repeat the same value more than
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have told the adapter which view types are supported, we also need
    to tell it which view holder to use for each view type. This is done by implementing
    the `onCreateViewHolder(ViewGroup,` `Int)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the earlier implementations of this function, we now take the value of
    `viewType` into account.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know, `viewType` is expected to be one of the values we returned from
    `getItem``ViewType(Int)`.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these values (`VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT`), we inflate
    the corresponding layout and construct a suitable view holder. Note that we never
    expect to receive any other value, so we throw an exception if such a value is
    encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your needs, you could instead return a default view holder with
    a layout, showing an error or nothing at all. It may also be a good idea to log
    such values to allow you to investigate why you received them and decide how to
    handle them.
  prefs: []
  type: TYPE_NORMAL
- en: For our group title layout, a simple `TextView` may be sufficient. For a cat,
    the `item_cat.xml` layout can be used as is.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the view holder. We need to create a view holder for the
    group title. This means we will now have two different view holders. However,
    our adapter only supports one adapter type. The easiest solution is to define
    a common view holder that both `GroupViewHolder` and `CatViewHolder` will extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call it `ListItemViewHolder`. The `ListItemViewHolder` class can be abstract,
    as we never intend to use it directly. To make it easy to bind data, we can also
    introduce a function in our abstract view holder – `abstract fun` `bindData(listItem:
    ListItemUiModel)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our concrete implementations can expect to receive a specific type, and so
    we can add the following lines to both `GroupViewHolder` and `CatViewHolder` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, in `CatViewHolder`, thanks to some Kotlin magic, we can then use
    `define val cat = listItem.cat` and leave the rest of the class unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Having made those changes, we can now expect to see the `Happy Cats` and `Sad
    Cats` group titles, each followed by the relevant cats.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.04 – adding titles to RecyclerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now want to be able to present our secret cat agents in two groups – active
    agents that are available for us to deploy to the field and sleeper agents that
    cannot currently be deployed. We will do that by adding a title above the active
    agents and another above the sleeper agents:'
  prefs: []
  type: TYPE_NORMAL
- en: Under `com.example.myrecyclerviewapp.model`, create a new Kotlin file called
    `ListItemUiModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the `ListItemUiModel.kt` file, defining our two data types
    – titles and cats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new Kotlin file in `com.example.myrecyclerviewapp` named `ListItem`
    **ViewHolder**. This will be our base view holder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the `ListItemViewHolder.kt` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `CatViewHolder.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make `CatViewHolder` extend `ListItemViewHolder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `bindData(CatUiModel)` parameter with `ListItemUiModel` and make
    it override the `ListItemViewHolder` abstract function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following two lines to the top of the `bindData(ListItemUiModel)` function
    to enforce casting `ListItemUiModel` to `ListItemUiModel.Cat` and to fetch the
    cat data from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leave the rest of the file untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layout file. Name your layout `item_title`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the default content of the newly created `item_title.xml` file with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This new layout, containing only a `TextView` with a 16 sp-sized bold font,
    will host our titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – A preview of the item_title.xml layout](img/B19411_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – A preview of the item_title.xml layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `TitleViewHolder` in a new file with the same name under `com.example.myrecyclerviewapp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is very similar to `CatViewHolder`, but since we only set the text on `TextView`,
    it is also much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to make things tidier, select `CatViewHolder`, `ListItemViewHolder`, and
    `TitleViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all the files to a new namespace; right-click on one of the files, and
    then select **Refactor** | **Move** (or press *F6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append `/viewholder` to the prefilled **To directory** field. Leave **Search
    references** and **Update package directive (Kotlin files)** checked and **Open
    moved files in editor** unchecked. Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CatsAdapter.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, rename `CatsAdapter` `ListItemsAdapter`. Right-click on the `CatsAdapter`
    class name in the code window, and then select **Refactor** | **Rename** (or *Shift*
    + *F6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to maintain the naming of variables, functions, and classes
    to reflect their actual usage to avoid future confusion.
  prefs: []
  type: TYPE_NORMAL
- en: When `CatsAdapter` is highlighted, type `ListItemsAdapter` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the adapter generic type to `ListItemViewHolder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `listData` and `setData(List<CatUiModel>)` to handle `ListItemUiModel`
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `onBindViewHolder(CatViewHolder)` to comply with the adapter contract
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of the file, after the imports and before the class definition,
    add the view type constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `getItemViewType(Int)`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, change your `onCreateViewHolder(ViewGroup, Int)` implementation, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `MainActivity` to populate the adapter with appropriate data, replacing
    the previous `catsAdapter.setData(List<CatUiModel>)` call (note that the following
    code has been truncated for space; refer to the link after the code block to access
    the full code that you need to add):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MainActivity.kt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this step can be found at [http://packt.live/3icCrSt](http://packt.live/3icCrSt).
  prefs: []
  type: TYPE_NORMAL
- en: Since `catsAdapter` is no longer holding `CatsAdapter` but `ListItemsAdapter`,
    rename it accordingly. Name it `listItemsAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app. You should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header
    views](img/B19411_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header
    views
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we now have titles above our two agent groups. Unlike the `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping to remove Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to present different view types. However,
    up until now, we have worked with a fixed list of items. What if you want to be
    able to remove items from the list? There are a few common mechanisms to achieve
    that – fixed **delete** buttons on each item, swiping to delete, and long-clicking
    to select and then a tapping a **delete** button, to name a few. In this section,
    we will focus on the *swiping to* *delete* approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the deletion functionality to our adapter. To tell the
    adapter to remove an item, we need to indicate which item we want to remove. The
    simplest way to achieve this is by providing the position of the item. In our
    implementation, this will directly correlate to the position of the item in our
    `listData` list. So, our `removeItem(Int)` function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Just like when setting data, we need to notify `RecyclerView` that the dataset
    has changed – in this case, an item was removed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to define swipe gesture detection. This is done by utilizing `ItemTouchHelper`,
    which handles certain touch events, namely dragging and swiping, by reporting
    them to us via a callback. We handle these callbacks by implementing `ItemTouchHelper.Callback`.
    Also, `RecyclerView` provides `ItemTouchHelper.SimpleCallback`, which takes away
    the writing of a lot of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to respond to swipe gestures but ignore move gestures. More specifically,
    we want to respond to swipes to the right. Moving is used to reorder items, which
    is beyond the scope of this chapter. So, our implementation of `SwipToDeleteCallback`
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Because our implementation is tightly coupled to our adapter and its view types,
    we can comfortably define it as an inner class. The benefit we gain is the ability
    to directly call methods on the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we return `false` from the `onMove(RecyclerView, ViewHolder,
    ViewHolder)` function. This means we ignore move events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to tell `ItemTouchHelper` which items can be swiped. We achieve
    this by overriding `getMovementFlags(RecyclerView, ViewHolder)`. This function
    is called when a user is about to start a drag or swipe gesture. `ItemTouchHelper`
    expects us to return the valid gestures for the provided view holder.
  prefs: []
  type: TYPE_NORMAL
- en: We check the `ViewHolder` class, and if it is `CatViewHolder`, we want to allow
    swiping; otherwise, we do not. We use `makeMovementFlags(Int, Int)`, which is
    a helper function used to construct flags in a way that `ItemTouchHelper` can
    decipher them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we define rules for `ACTION_STATE_IDLE`, which is the starting state
    of a gesture, thus allowing a gesture to start from the left or the right. We
    then combine it (using `or`) with the `ACTION_STATE_SWIPE` flags, allowing the
    ongoing gesture to swipe left or right. Returning `0` means neither swiping nor
    moving will occur for the provided view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Once a swipe action is completed, `onSwiped(ViewHolder, Int)` is called. We
    then obtain the position from the passed-in view holder by calling `adapterPosition`.
    Now, `adapterPosition` is important because it is the only reliable way to obtain
    the real position of the item presented by the view holder.
  prefs: []
  type: TYPE_NORMAL
- en: With the correct position, we can remove the item by calling `removeItem(Int)`
    in the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: To expose our newly created `SwipeToDeleteCallback` implementation, we define
    a read-only variable within our adapter named `swipeToDeleteCallback`, and set
    it to a new instance of `SwipeToDeleteCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to plug our `callback` mechanism to `RecyclerView`, we need to construct
    a new `ItemTouchHelper` and attach it to our `RecyclerView`. We should do this
    when setting up our `RecyclerView`, which we do in the `onCreate(Bundle?)` function
    of our main activity. This is how the creation and attaching looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can now swipe items to remove them from the list. Note how our titles cannot
    be swiped, just as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed a small glitch – the last item is cut off as it animates
    upward. This is happening because `RecyclerView` shrinks to accommodate the new
    (smaller) number of items before the animation starts. A quick fix to this would
    be to fix the height of our `RecyclerView` by confining its bottom to the bottom
    of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.05 – adding swipe to delete functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously added `RecyclerView` to our app and then added items of different
    types to it. We will now allow users to delete some items (we want to let the
    users remove secret cat agents but not titles) by swiping them left or right:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add item removal functionality to our adapter, add the following function
    to `ListItemsAdapter` right after the `setData(List<ListItemUiModel>)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, right before the closing curly bracket of your `ListItemsAdapter` class,
    add the following `callback` implementation to handle the user swiping a cat agent
    left or right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have implemented an `ItemTouchHelper.SimpleCallback` instance, passing in
    the directions we were interested in – `LEFT` and `RIGHT`. Joining the values
    is achieved by using the `or` Boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: We have overridden the `getMovementFlags` function to make sure we have only
    handled swiping on a cat agent view and not on a title. Creating flags for both
    `ItemTouchHelper.ACTION_STATE_SWIPE` and `ItemTouchHelper.ACTION_STATE_IDLE` allows
    us to intercept both swipe and release events respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Once a swipe is completed (the user has lifted their finger from the screen),
    `onSwiped` will be called, and in response, we remove the item at the position
    provided by the dragged view holder.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your adapter, expose an instance of the `SwipeToDeleteCallback`
    class you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, tie it all together by implementing `ItemViewHelper` and attaching
    it to our `RecyclerView`. Add the following code to the `onCreate(Bundle?)` function
    of your `MainActivity` file right after assigning the layout manager to your adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To address the small visual glitch you would get when items are removed, scale
    `RecyclerView` to fit the screen by updating the code in `activity_main.xml`,
    as follows. The changes are in the `RecyclerView` tag, right before the `app:layout_constraintTop_toBottomOf`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that there are two changes – we added a constraint at the bottom of the
    view to the bottom of the parent, and we set the layout height to `0dp`. The latter
    change tells our app to calculate the height of `RecyclerView` based on its constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – RecyclerView taking the full height of the layout](img/B19411_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – RecyclerView taking the full height of the layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your app. You should now be able to swipe secret cat agents left or right
    to remove them from the list. Note that `RecyclerView` handles the collapsing
    animation for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – A cat being swiped to the right](img/B19411_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – A cat being swiped to the right
  prefs: []
  type: TYPE_NORMAL
- en: Note how even though titles are item views, they cannot be swiped. You have
    implemented a callback for swiping gestures that distinguishes between different
    item types and responds to a swipe by deleting the swiped item. Now, you know
    how to remove items interactively. Next, you will learn how to add new items as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding items interactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned how to remove items interactively. What about adding new
    items? Let’s look into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the way we implemented the removal of items, we start by adding
    a function to our adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that the implementation is very similar to the `removeItem(Int)` function
    we implemented earlier. This time, we also receive an item to add and a position
    to add it to. We then add it to our `listData` list and notify `RecyclerView`
    that we added an item in the requested position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger a call to `addItem(Int, ListItemUiModel)`, we can add a button to
    our main activity layout. This button can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The app will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The main layout with a button to add a cat](img/B19411_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The main layout with a button to add a cat
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to update your `RecyclerView` so that its bottom will be constrained
    to the top of this button. Otherwise, the button and `RecyclerView` will overlap.
  prefs: []
  type: TYPE_NORMAL
- en: In a production app, you could add a rationale about what a new item would be.
    For example, you could have a form for a user to fill in different details. For
    the sake of simplicity, in our example, we will always add the same dummy item
    – an anonymous female secret cat agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the item, we set `OnClickListener` on our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: And that is it. We add the item at position `1` so that it is added right below
    our first title, which is the item at position `0`. In a production app, you could
    have logic to determine the correct place to insert an item. It could be below
    the relevant title or always be added at the top, bottom, or in the correct place
    to preserve some existing order.
  prefs: []
  type: TYPE_NORMAL
- en: We can now run the app. We will now have a new `RecyclerView`. The newly added
    cats can be swiped away to be removed, just like the hardcoded cats before them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.06 – implementing an Add A Cat button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having implemented a mechanism to remove items, it is time we implemented a
    mechanism to add items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to `ListItemsAdapter` to support adding items. Add it below
    the `removeItem(Int)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button to `activity_main.xml`, right after the `RecyclerView` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `android:text="Add A Cat"` is highlighted. If you hover your mouse
    over it, you will see that this is because of the hardcoded string. Click on the
    **Add** word to place the editor cursor over it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Option* + *Enter* (iOS) or *Alt* + *Enter* (Windows) to show the context
    menu, and then press *Enter* again to show the **Extract** **Resource** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the resource `add_button_label`. Press **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To change the bottom constraint on `RecyclerView` so that the button and `RecyclerView`
    do not overlap, within your `RecyclerView` tag, locate the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a lazy field, holding a reference to the button at the top of the class,
    right after the definition of `recyclerView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `addItemButton` is defined as a view. This is because, in our code,
    we don’t need to know the type of view to add a click listener to it. Choosing
    the more abstract type allows us to later change the type of view in the layout
    without having to modify this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, update `MainActivity` to handle the click. Find the line that says
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right after it, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will add a new item to `RecyclerView` every time the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app. You should see a new button at the bottom of your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – An anonymous cat is added with the click of a button](img/B19411_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – An anonymous cat is added with the click of a button
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking it a few times. Every time you click it, a new, anonymous secret
    cat agent is added to your `RecyclerView`. You can swipe away the newly added
    cats, just like you could with the hardcoded ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you added new items to `RecyclerView` in response to user
    interaction. You now know how to change the contents of `RecyclerView` at runtime.
    It is useful to know how to update lists at runtime because, quite often, the
    data you are presenting to your users changes while the app is running, and you
    want to present your users with a fresh, up-to-date state.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.01 – managing a list of Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you want to develop a recipe management app. Your app would support
    sweet and savory recipes. Users of your app could add new sweet or savory recipes,
    scroll through the list of added recipes – grouped by flavor (sweet or savory)
    – click a recipe to get information about it, and finally, delete recipes by swiping
    them aside.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to create an app with `RecyclerView` that lists
    the title of recipes, grouped by flavor. `RecyclerView` will support user interaction.
    Each recipe will have a title, a description, and a flavor. Interactions will
    include clicks and swipes.
  prefs: []
  type: TYPE_NORMAL
- en: A click will present a user with a dialog showing the description of the recipe.
    A swipe will remove the swiped recipe from the app. Finally, with two `EditText`
    fields (see [*Chapter 3*](B19411_03.xhtml#_idTextAnchor163), *Developing the UI
    with Fragments*) and two buttons, a user can add a new sweet or savory recipe
    respectively, with the title and description set to the values set in the `EditText`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to complete this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty activity app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `RecyclerView` support to the app’s `build.gradle` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `RecyclerView`, two `EditText` fields, and two buttons to the main layout.
    It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The layout with RecyclerView, two EditText fields, and two
    buttons](img/B19411_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons
  prefs: []
  type: TYPE_NORMAL
- en: Add models for the flavor titles and recipes, and an enum for flavor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a layout for the flavor titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a layout for the recipe titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add view holders for the flavor titles and recipe titles, as well as an adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add click listeners to show a dialog with recipe descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `MainActivity` to construct the new adapter, and hook up the buttons
    to add new savory and sweet recipes. Make sure the form is cleared after a recipe
    is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a swipe helper to remove items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.17 – The Recipe Book \uFEFF\uFEFFapp](img/B19411_06_017.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The Recipe Book app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to add `RecyclerView` support to our project.
    We also learned how to add `RecyclerView` to our layout and how to populate it
    with items. We went through adding different item types, which is particularly
    useful for titles. We covered interaction with `RecyclerView`, responding to clicks
    on individual items and responding to swipe gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned how to dynamically add and remove items to and from `RecyclerView`.
    The world of `RecyclerView` is very rich, and we have only scratched the surface.
    Going further would be beyond the scope of this book. However, it is strongly
    recommended that you investigate it on your own so that you can have carousels,
    designed dividers, and fancier swipe effects in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start your exploration here: [https://packt.link/ClmMn](https://packt.link/ClmMn).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into requesting special permissions on behalf
    of our app to enable it to perform certain tasks, such as accessing a user’s contacts
    list or microphone. We will also look into using Google’s Maps API and accessing
    a user’s physical location.
  prefs: []
  type: TYPE_NORMAL
