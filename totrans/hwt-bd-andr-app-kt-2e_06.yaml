- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Adding and Interacting with RecyclerView
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和与RecyclerView交互
- en: In this chapter, you will learn how to add lists and grids of items to your
    apps and effectively leverage the recycling power of `RecyclerView`. You’ll also
    learn how to handle user interaction with the item views on the screen and support
    different item view types – for example, for titles. Later in the chapter, you’ll
    add and remove items dynamically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将项目列表和网格添加到你的应用中，并有效地利用`RecyclerView`的回收能力。你还将学习如何处理屏幕上项目视图的用户交互，并支持不同的项目视图类型——例如，用于标题。在本章的后面部分，你将动态地添加和删除项目。
- en: By the end of the chapter, you will have the skills required to present your
    users with interactive lists of rich items.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握向用户展示丰富项目交互式列表所需的所有技能。
- en: In the previous chapter, we learned how to fetch data, including lists of items
    and image URLs, from APIs, and how to load images from URLs. Combining that knowledge
    with the ability to display lists of items is the goal of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何从API中获取数据，包括项目列表和图像URL，以及如何从URL加载图像。将这一知识结合展示项目列表的能力，是本章的目标。
- en: Quite often, you will want to present your users with a list of items. For example,
    you might want to show them a list of pictures on their device or let them select
    their country from a list of all countries. To do that, you would need to populate
    multiple views, all sharing the same layout but presenting different content.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很频繁地，你将想要向用户展示一个项目列表。例如，你可能想向他们展示设备上的图片列表，或者让他们从一个包含所有国家的列表中选择他们的国家。为此，你需要填充多个视图，所有这些视图共享相同的布局，但展示不同的内容。
- en: Historically, this was achieved by using `ListView` or `GridView`. While both
    are still viable options, they do not offer the robustness and flexibility of
    `RecyclerView`. For example, they do not support large datasets well, they do
    not support horizontal scrolling, and they do not offer rich divider customization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，这是通过使用`ListView`或`GridView`来实现的。虽然这两种方法仍然是可行的选项，但它们并不提供`RecyclerView`的强大功能和灵活性。例如，它们不支持大型数据集，不支持水平滚动，并且不提供丰富的分隔符自定义。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Customizing the divider between items in `RecyclerView` can be easily achieved
    using `RecyclerView.ItemDecorator`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RecyclerView.ItemDecorator`可以轻松地自定义`RecyclerView`中项目之间的分隔符。
- en: So, what does `RecyclerView` do? `RecyclerView` orchestrates the creation, population,
    and reuse (hence the name) of views representing lists of items. To use `RecyclerView`,
    you need to familiarize yourself with two of its dependencies – the adapter (and
    through it, the view holder) and the layout manager. These dependencies provide
    our `RecyclerView` with the content to show, as well as tell it how to present
    that content and lay it out on the screen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`RecyclerView`到底做了什么？`RecyclerView`负责协调表示项目列表的视图的创建、填充和重用（因此得名）。要使用`RecyclerView`，你需要熟悉其两个依赖项——适配器（以及通过它，视图持有者）和布局管理器。这些依赖项为我们的`RecyclerView`提供要显示的内容，并告诉它如何呈现这些内容以及如何在屏幕上布局。
- en: The adapter provides `RecyclerView` with child views (nested Android views within
    `RecyclerView` used to represent individual data items) to draw on the screen,
    binds those views to data (via `ViewHolder` instances), and reports user interaction
    with those views.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器为`RecyclerView`提供绘制在屏幕上的子视图（在`RecyclerView`中嵌套的Android视图，用于表示单个数据项），将这些视图绑定到数据（通过`ViewHolder`实例），并报告用户与这些视图的交互。
- en: The layout manager tells `RecyclerView` how to lay its children out. We are
    provided with three layout types by default – linear, grid, and staggered grid
    – managed by `LinearLayoutManager`, `GridLayoutManager`, and `StaggeredGridLayoutManager`
    respectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 布局管理器告诉`RecyclerView`如何布局其子项。我们默认提供了三种布局类型——线性、网格和交错网格，分别由`LinearLayoutManager`、`GridLayoutManager`和`StaggeredGridLayoutManager`管理。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This chapter relies on the use of the Jetpack RecyclerView library: [https://packt.link/FBX4d](https://packt.link/FBX4d).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于使用Jetpack `RecyclerView`库：[https://packt.link/FBX4d](https://packt.link/FBX4d)。
- en: 'In this chapter, we will develop an app that lists secret agents and whether
    they are currently active or sleeping (and, thus, unavailable). The app will then
    allow us to add new agents or delete existing ones by swiping them away. There
    is a twist, though – as you saw in [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312),
    *Essential Libraries: Retrofit, Moshi, and Glide*, all our agents will be cats.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个应用，列出特工及其当前是否活跃或睡眠（因此不可用）。然后，应用将允许我们通过滑动来添加新特工或删除现有特工。不过，有一个转折——正如你在
    [*第 5 章*](B19411_05.xhtml#_idTextAnchor312)，“基本库：Retrofit、Moshi 和 Glide”中所看到的，我们所有的特工都将变成猫。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding `RecyclerView` to our layout
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `RecyclerView` 添加到我们的布局
- en: Populating `RecyclerView`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充 `RecyclerView`
- en: Responding to clicks in `RecylerView`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `RecyclerView` 中响应用户点击
- en: Supporting different item types
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的项目类型
- en: Swiping to remove items
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动删除项目
- en: Adding items interactively
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式添加项目
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/IJbeG](https://packt.link/IJbeG)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在 GitHub 上找到，链接为 [https://packt.link/IJbeG](https://packt.link/IJbeG)
- en: Adding RecyclerView to our layout
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `RecyclerView` 添加到我们的布局
- en: 'In [*Chapter 3*](B19411_03.xhtml#_idTextAnchor163), *Developing the UI with
    Fragments*, we saw how we can add views to our layouts to be inflated by activities,
    fragments, or custom views. `RecyclerView` is just another such view. To add it
    to our layout, we need to add the following tag to our layout:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B19411_03.xhtml#_idTextAnchor163)，“使用片段开发 UI”，我们看到了如何将视图添加到我们的布局中，以便由活动、片段或自定义视图填充。`RecyclerView`
    就是这样的另一个视图。要将它添加到我们的布局中，我们需要在布局中添加以下标签：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should already be able to recognize the `android:id` attribute, as well
    as the `android:layout_width` and `android:layout_height` ones.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经能够识别 `android:id` 属性，以及 `android:layout_width` 和 `android:layout_height`
    属性。
- en: We can use the optional `tools:listitem` attribute to tell Android Studio which
    layout to inflate as a list item in our preview toolbar. This will give us an
    idea of how `RecyclerView` might look in our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可选的 `tools:listitem` 属性来告诉 Android Studio 在预览工具栏中哪个布局应该被填充为列表项。这将给我们一个关于
    `RecyclerView` 在我们的应用中可能看起来如何的印象。
- en: Adding a `RecyclerView` tag to our layout means we now have an empty container
    to hold the child views representing our list items. Once populated, it will handle
    the presenting, scrolling, and recycling of child views for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的布局中添加一个 `RecyclerView` 标签意味着我们现在有一个空容器来存放代表列表项的子视图。一旦填充，它将为我们处理子视图的展示、滚动和回收。
- en: Exercise 6.01 – adding an empty RecyclerView to your main activity
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01 – 在主活动中添加一个空的 RecyclerView
- en: 'To use `RecyclerView` in your app, you first need to add it to one of your
    layouts. Let’s add it to the layout inflated by our main activity:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的应用中使用 `RecyclerView`，你首先需要将它添加到你的布局之一中。让我们将它添加到由我们的主活动填充的布局中：
- en: Start by creating a new empty activity project (`My RecyclerView App`. Make
    sure your package name is `com.example.myrecyclerviewapp`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的空活动项目（`My RecyclerView App`）。确保你的包名为 `com.example.myrecyclerviewapp`。
- en: 'Set the save location to where you want to save your project. Leave everything
    else at their default values and click **Finish**. Make sure you are on the **Android**
    view in your **Project** pane:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为你要保存项目的地方。将其他所有内容保留在默认值，并点击 **完成**。确保你正在你的 **项目** 面板中的 **Android** 视图中：
- en: '![Figure 6.1 – The Android view in the Project pane](img/B19411_06_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 项目面板中的 Android 视图](img/B19411_06_01.jpg)'
- en: Figure 6.1 – The Android view in the Project pane
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 项目面板中的 Android 视图
- en: Open your `activity_main.xml` file in **Text** mode.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 **文本** 模式打开你的 `activity_main.xml` 文件。
- en: 'To turn your label into a title at the top of the screen under which you can
    add your `RecyclerView`, add an ID to `TextView` and align it to the top, like
    so:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将你的标签变成屏幕顶部的标题，并在其下方添加你的 `RecyclerView`，请给 `TextView` 添加一个 ID 并将其对齐到顶部，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following after the `TextView` tag to add an empty `RecyclerView` element
    to your layout, constrained below your `hello_label` `TextView` title:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TextView` 标签之后添加以下内容，以将一个空的 `RecyclerView` 元素添加到你的布局中，并限制在 `hello_label`
    `TextView` 标题下方：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your layout file should now look something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你的布局文件现在应该看起来像这样：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your app by clicking the **Run app** button or pressing *Ctrl* + *R* (*Shift*
    + *F10* in Windows). On the emulator, it should look like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **运行应用** 按钮或按 *Ctrl* + *R*（在 Windows 中为 *Shift* + *F10*）来运行你的应用。在模拟器上，它应该看起来像这样：
- en: '![Figure 6.2 – The app with an empty RecyclerView (image cropped for space)](img/B19411_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 具有空 RecyclerView 的应用（图像裁剪以节省空间）](img/B19411_06_02.jpg)'
- en: Figure 6.2 – The app with an empty RecyclerView (image cropped for space)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 具有空 RecyclerView 的应用（图像裁剪以节省空间）
- en: As you can see, our app runs, and our layout is presented on the screen. However,
    we do not see our `RecyclerView`. Why is that? At this stage, our `RecyclerView`
    has no content. `RecyclerView` with no content does not render by default – so,
    while our `RecyclerView` is indeed on the screen, it is not visible. This brings
    us to the next step – populating `RecyclerView` with content that we can actually
    see.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用正在运行，并且我们的布局已显示在屏幕上。然而，我们没有看到我们的 `RecyclerView`。为什么是这样？在这个阶段，我们的 `RecyclerView`
    没有内容。默认情况下，没有内容的 `RecyclerView` 不会渲染——因此，尽管我们的 `RecyclerView` 确实在屏幕上，但它不可见。这使我们来到了下一步——用我们可以实际看到的内容填充
    `RecyclerView`。
- en: Populating RecyclerView
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充 RecyclerView
- en: So, we added `RecyclerView` to our layout. For us to benefit from `RecyclerView`,
    we need to add content to it. Let’s see how we go about doing that.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在布局中添加了 `RecyclerView`。为了从 `RecyclerView` 中受益，我们需要向其中添加内容。让我们看看我们是如何做到这一点的。
- en: As we mentioned before, to add content to our `RecyclerView`, we would need
    to implement an adapter. An adapter binds our data to child views. In simpler
    terms, this means it tells `RecyclerView` how to plug data into views designed
    to present that data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，为了向我们的 `RecyclerView` 添加内容，我们需要实现一个适配器。适配器将我们的数据绑定到子视图。用更简单的话说，这意味着它告诉
    `RecyclerView` 如何将数据插入到设计用来展示该数据的视图。
- en: For example, let’s say we want to present a list of employees.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要展示员工列表。
- en: 'First, we need to design our UI model. This will be a data object holding all
    the information needed by our view to present a single employee. Because this
    is a UI model, one convention is to suffix its name with `UiModel`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设计我们的 UI 模型。这将是一个数据对象，包含我们的视图展示单个员工所需的所有信息。因为这是一个 UI 模型，一个惯例是在其名称后缀加上
    `UiModel`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will define `EmployeeRole` and `Gender` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下定义 `EmployeeRole` 和 `Gender`：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values are provided as an example, of course. Feel free to add more of your
    own!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值当然只是作为示例提供的。请随意添加更多您自己的内容！
- en: '![Figure 6.3 – The model’s hierarchy](img/B19411_06_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 模型的层次结构](img/B19411_06_03.jpg)'
- en: Figure 6.3 – The model’s hierarchy
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 模型的层次结构
- en: 'Now, we know what data to expect when binding to a view, so we can design our
    view to present this data (this is a simplified version of the actual layout,
    which we’ll save as `item_employee.xml`). We’ll start with `ImageView`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道在绑定到视图时可以期待什么数据，因此我们可以设计我们的视图来展示这些数据（这是实际布局的简化版本，我们将将其保存为 `item_employee.xml`）。我们将从
    `ImageView` 开始：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we will add a `TextView` for each field:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为每个字段添加一个 `TextView`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So far, there is nothing new. You should be able to recognize all of the different
    view types from [*Chapter 2*](B19411_02.xhtml#_idTextAnchor103), *Building User*
    *Screen Flows*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新的内容。你应该能够识别出从 [*第 2 章*](B19411_02.xhtml#_idTextAnchor103)，*构建用户*
    *屏幕流程* 中提到的所有不同的视图类型：
- en: '![Figure 6.4 – A preview of the item_cat.xml layout file](img/B19411_06_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – item_cat.xml 布局文件的预览](img/B19411_06_04.jpg)'
- en: Figure 6.4 – A preview of the item_cat.xml layout file
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – item_cat.xml 布局文件的预览
- en: 'With a data model and a layout, we now have everything we need to bind our
    data to the view. To do that, we will implement a view holder. Usually, a view
    holder has two responsibilities – it holds a reference to a view (as its name
    implies), but it also binds data to that view. We will implement our view holder
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据模型和布局，我们已经拥有了将数据绑定到视图所需的一切。为此，我们将实现一个视图持有者。通常，视图持有者有两个职责——它持有对视图的引用（正如其名称所暗示的），但它还负责将数据绑定到该视图。我们将如下实现我们的视图持有者：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are a few things worth noting in the preceding code. First, by convention,
    we suffixed the name of our view holder with `ViewHolder`. Second, note that `EmployeeViewHolder`
    needs to implement the abstract `RecyclerView.ViewHolder` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有几个值得注意的地方。首先，按照惯例，我们在视图持有者的名称后缀加上 `ViewHolder`。其次，请注意 `EmployeeViewHolder`
    需要实现抽象的 `RecyclerView.ViewHolder` 类。
- en: This is required so that the generic type of our adapter can be our view holder.
    Lastly, we lazily keep references to the views we are interested in. The first
    time `bindData(EmployeeUiModel)` is called, we will find these views in the layout
    and keep references to them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保我们的适配器的泛型可以是我们的视图持有者。最后，我们懒加载地保留对我们感兴趣的视图的引用。当第一次调用 `bindData(EmployeeUiModel)`
    时，我们将在布局中找到这些视图并保留它们的引用。
- en: Next, we introduced a `bindData(EmployeeUiModel)` function. This function will
    be called by our adapter to bind the data to the view held by the view holder.
    The last but most important thing to note is that we always make sure to set a
    state for all modified views for every possible input.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入了一个`bindData(EmployeeUiModel)`函数。这个函数将由我们的适配器调用，以将数据绑定到视图持有者持有的视图。最后但同样重要的是，我们总是确保为所有可能的输入设置所有修改视图的状态。
- en: 'With our view holder set up, we can proceed to implement our adapter. We will
    start by implementing the minimum required functions, plus a function to set the
    data. Our adapter will look something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好视图持有者之后，我们可以继续实现我们的适配器。我们将从实现所需的最小函数以及一个设置数据的函数开始。我们的适配器看起来可能像这样：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s go over this implementation. First, we inject our dependencies into the
    adapter via its constructor. This will make testing our adapter much easier but
    will also allow us to change some of its behavior (for example, replace the image
    loading library) painlessly. In fact, we would not need to change the adapter
    at all in that case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个实现。首先，我们通过适配器的构造函数注入我们的依赖项。这将使测试我们的适配器变得容易得多，但也会允许我们轻松地更改其某些行为（例如，替换图像加载库）。实际上，在这种情况下，我们甚至不需要更改适配器。
- en: Then, we define a private mutable list of `EmployeeUiModel` to store the data
    currently provided by the adapter to `RecyclerView`. We also introduce a method
    (`setData`) to populate that list. Note that we keep a local list and set its
    contents, rather than allowing `employees` to be set directly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个私有的可变`EmployeeUiModel`列表来存储适配器当前提供给`RecyclerView`的数据。我们还引入了一个`setData`方法来填充该列表。请注意，我们保留一个本地列表并设置其内容，而不是直接设置`employees`。
- en: This is mainly because Kotlin, just like Java, passes variables by reference.
    Passing variables by reference means changes to the content of the list passed
    into the adapter would change the list held by the adapter. So, for example, if
    an item was removed outside of the adapter, the adapter would have that item removed
    as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是因为Kotlin，就像Java一样，通过引用传递变量。通过引用传递变量意味着传递给适配器的列表内容的变化会改变适配器持有的列表。例如，如果某个项目在适配器外部被删除，适配器也会删除该项目。
- en: This becomes a problem because the adapter would not be aware of that change,
    and so would not be able to notify `RecyclerView`. There are other risks around
    a list being modified outside of the adapter, but covering them is beyond the
    scope of this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这成为一个问题，因为适配器不会意识到这个变化，因此无法通知`RecyclerView`。在适配器外部修改列表周围还有其他风险，但涵盖这些风险超出了本书的范围。
- en: Another benefit of encapsulating the modification of data in a function is that
    we avoid the risk of forgetting to notify `RecyclerView` that a dataset has changed,
    which we do by calling `notifyDataSetChanged()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据修改封装在函数中的另一个好处是，我们避免了忘记通知`RecyclerView`数据集已更改的风险，这是通过调用`notifyDataSetChanged()`来实现的。
- en: We proceed to implement the adapter’s `onCreateViewHolder(ViewGroup, Int)` function.
    This function is called when `RecyclerView` needs a new `ViewHolder` to render
    data on a screen. It provides us with a `ViewGroup` container and a view type
    (we’ll look into view types later in this chapter).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续实现适配器的`onCreateViewHolder(ViewGroup, Int)`函数。当`RecyclerView`需要一个新的`ViewHolder`来在屏幕上渲染数据时，会调用此函数。它为我们提供了一个`ViewGroup`容器和一个视图类型（我们将在本章后面讨论视图类型）。
- en: The function then expects us to return a view holder initialized with a view
    (in our case, an inflated one). So, we inflate the view we designed earlier, passing
    it to a new `EmployeeViewHolder` instance. Note that the last argument to the
    inflated function is `false`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后期望我们返回一个使用视图初始化的视图持有者（在我们的情况下，是一个已充气的视图）。因此，我们充气我们之前设计的视图，并将其传递给一个新的`EmployeeViewHolder`实例。请注意，传递给充气函数的最后一个参数是`false`。
- en: This makes sure we do not attach the newly inflated view to the parent. Attaching
    and detaching views will be managed by the layout manager. Setting the view to
    `true` or omitting it would result in `IllegalStateException` being thrown. Finally,
    we return the newly created `EmployeeViewHolder`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保我们不会将新充气的视图附加到父视图上。视图的附加和分离将由布局管理器管理。将视图设置为`true`或省略它会导致抛出`IllegalStateException`。最后，我们返回新创建的`EmployeeViewHolder`。
- en: To implement `getItemCount()`, we simply return the size of our `employees`
    list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`getItemCount()`，我们只需返回我们的`employees`列表的大小。
- en: Lastly, we implement `onBindViewHolder(EmployeeViewHolder, Int)`. This is done
    by passing `EmployeeUiModel`, stored in `employees`, at the given position to
    the `bindData(EmployeeUiModel)` function of our view holder. Our adapter is now
    ready.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现`onBindViewHolder(EmployeeViewHolder, Int)`。这是通过将存储在`employees`中的`EmployeeUiModel`传递给视图持有者的`bindData(EmployeeUiModel)`函数来完成的。我们的适配器现在已准备就绪。
- en: 'If we tried to plug our adapter into our `RecyclerView` at this point and run
    our app, we would still see no content. This is because we are still missing two
    small steps – setting data on our adapter and assigning a layout manager to our
    `RecyclerView`. The complete working code would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试将适配器连接到我们的`RecyclerView`并运行应用程序，我们仍然看不到任何内容。这是因为我们仍然缺少两个小步骤——在适配器上设置数据并将布局管理器分配给我们的`RecyclerView`。完整的有效代码将如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running our app now, we would see a list of our employees.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的应用程序，我们会看到员工列表。
- en: Note that we hardcoded the list of employees. In a production app, following
    a `ViewModel`. It is also important to note that we kept a reference to `employeesAdapter`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们硬编码了员工列表。在生产应用中，遵循`ViewModel`。还应注意，我们保留了`employeesAdapter`的引用。
- en: This is so that we could, later on, set the data to different values. Some implementations
    rely on reading the adapter from `RecyclerView` itself – this can potentially
    result in unnecessary casting operations and unexpected states where the adapter
    is not yet assigned to `RecyclerView`, so this is generally not a recommended
    approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在以后设置不同的值。一些实现依赖于从`RecyclerView`本身读取适配器——这可能导致不必要的类型转换操作和适配器尚未分配给`RecyclerView`的意外状态，因此这通常不是一个推荐的方法。
- en: Lastly, note that we chose to use `LinearLayoutManager`, providing it with the
    activity for context, a `VERTICAL` orientation flag, and `false` to tell it that
    we do not want the order of the items in the list reversed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们选择使用`LinearLayoutManager`，并提供活动作为上下文、`VERTICAL`方向标志以及`false`来告诉它我们不希望列表中项目的顺序颠倒。
- en: Exercise 6.02 – populating your RecyclerView
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02 – 填充您的RecyclerView
- en: '`RecyclerView` is not very interesting without any content. It is time to populate
    `RecyclerView` by adding your secret cat agents to it.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有内容的`RecyclerView`并不有趣。是时候通过添加您的秘密猫代理来填充`RecyclerView`了。
- en: 'A quick recap before you dive in – in the previous exercise, we introduced
    an empty list designed to hold a list of secret cat agents that users have at
    their disposal. In this exercise, you will be populating that list to present
    the users with the available secret cat agents in the agency:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始之前，快速回顾一下——在前一个练习中，我们介绍了一个空列表，用于存储用户可用的秘密猫代理列表。在这个练习中，您将填充这个列表，向用户展示机构中可用的秘密猫代理：
- en: 'To keep our file structure tidy, we will start by creating a model package.
    Right-click on the package name of our app, and then select **New** | **Package**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持我们的文件结构整洁，我们首先创建一个模型包。右键单击应用程序的包名，然后选择**新建** | **包**：
- en: '![Figure 6.5 – Creating a new package](img/B19411_06_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 创建新包](img/B19411_06_05.jpg)'
- en: Figure 6.5 – Creating a new package
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 创建新包
- en: Name the new package `model`. Click **OK** to create the package.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新包命名为`model`。点击**确定**以创建包。
- en: To create our first model data class, right-click on the newly created model
    package, and then select **New** | **Kotlin File/Class**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的第一个模型数据类，右键单击新创建的模型包，然后选择**新建** | **Kotlin 文件/类**。
- en: Under `CatUiModel`. Leave **kind** as **File** and click on **OK**. This will
    be the class holding the data we have about every individual cat agent.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CatUiModel`下，将**kind**保留为**文件**，然后点击**确定**。这将是我们关于每个单独猫代理的数据的类。
- en: 'Add the following to the newly created `CatUiModel.kt` file to define the data
    class with all the relevant properties of a cat agent:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到新创建的`CatUiModel.kt`文件中，以定义包含猫代理所有相关属性的数据类：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each cat agent, other than their name and photo, we want to know their gender,
    breed, and biography. This will help us choose the right agent for a mission.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个猫代理，除了他们的名字和照片，我们还想了解他们的性别、品种和传记。这将帮助我们选择适合任务的正确代理。
- en: Again, right-click on the model package, and then navigate to **New** | **Kotlin
    File/Class**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击模型包，然后导航到**新建** | **Kotlin 文件/类**。
- en: This time, name the new file `CatBreed` and set `kind` to the `Enum` class.
    This class will hold our different cat breeds.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，将新文件命名为`CatBreed`并将`kind`设置为`Enum`类。这个类将包含我们的不同猫品种。
- en: 'Update your newly created `enum` with some initial values, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您新创建的`enum`，添加一些初始值，如下所示：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Repeat *step 6* and *step 7*, only this time call your file `Gender`. This will
    hold the accepted values for a cat agent’s gender.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 6* 和 *步骤 7*，这次将文件命名为 `Gender`。这将包含猫代理性别的有效值。
- en: 'Update the `Gender` enum, like so:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Gender` 枚举，如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to define the layout of the view holding the data about each cat agent,
    create a new layout resource file by right-clicking on `layout` and then selecting
    **New** | **Layout** **resource file**:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了定义包含每个猫代理数据的视图的布局，通过右键单击 `layout` 并选择 **新建** | **布局资源文件** 创建一个新的布局资源文件：
- en: '![Figure 6.6 – Creating a new layout resource file](img/B19411_06_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 创建新的布局资源文件](img/B19411_06_06.jpg)'
- en: Figure 6.6 – Creating a new layout resource file
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 创建新的布局资源文件
- en: Name your resource `item_cat`. Leave all the other fields as they are and click
    **OK**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资源命名为 `item_cat`。保留所有其他字段不变，然后点击 **确定**。
- en: 'Update the contents of the newly created `item_cat.xml` file (the following
    code block has been truncated for space, so use the following link to see the
    full code that you need to add):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新新创建的 `item_cat.xml` 文件的内容（以下代码块因空间限制已被截断，请使用以下链接查看需要添加的完整代码）：
- en: item_cat.xml
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: item_cat.xml
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The complete code for this step can be found at [http://packt.live/3sopUjo](http://packt.live/3sopUjo).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在 [http://packt.live/3sopUjo](http://packt.live/3sopUjo) 找到。
- en: This will create a layout with an image and text fields for a name, breed, and
    biography to be used in our list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含用于我们列表中的名称、品种和传记的图片和文本字段的布局。
- en: 'You will need a copy of `ImageLoader.kt`, introduced in [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312),
    *Essential Libraries: Retrofit, Moshi, and Glide*, so right-click on the package
    name of your app, navigate to `ImageLoader` and **kind** to **Interface**, and
    click **OK**.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '您需要一份 `ImageLoader.kt` 的副本，它在 [*第 5 章*](B19411_05.xhtml#_idTextAnchor312) 的
    *Essential Libraries: Retrofit, Moshi, and Glide* 中介绍过，因此右键单击您的应用包名称，导航到 `ImageLoader`
    并将其转换为 **接口**，然后点击 **确定**。'
- en: 'Similar to [*Chapter 5*](B19411_05.xhtml#_idTextAnchor312), *Essential Libraries:
    Retrofit, Moshi, and Glide*, you only need to add one function here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '与 [*第 5 章*](B19411_05.xhtml#_idTextAnchor312) 中的 *Essential Libraries: Retrofit,
    Moshi, and Glide* 类似，您在这里只需要添加一个函数：'
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make sure to import `ImageView`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保导入 `ImageView`。
- en: Right-click on the package name of your app again, and then select **New** |
    **Kotlin File/Class**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击您的应用包名称，然后选择 **新建** | **Kotlin 文件/类**。
- en: Call the new file `CatViewHolder`. Click **OK**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为 `CatViewHolder`。点击 **确定**。
- en: 'To implement `CatViewHolder`, which will bind the cat agent data to your views,
    replace the contents of the `CatViewHolder.kt` file with the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `CatViewHolder`，它将绑定猫代理数据到您的视图，用以下内容替换 `CatViewHolder.kt` 文件的内容：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Still under our app package name, create a new Kotlin file named `CatsAdapter`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在我们的应用包名称下，创建一个名为 `CatsAdapter` 的新 Kotlin 文件。
- en: 'To implement `CatsAdapter`, which is responsible for storing the data for `RecyclerView`,
    as well as creating instances of your view holder and using them to bind data
    to views, replace the contents of the `CatsAdapter.kt` file with this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `CatsAdapter`，它负责存储 `RecyclerView` 的数据以及创建视图持有实例并使用它们将数据绑定到视图，用以下内容替换 `CatsAdapter.kt`
    文件的内容：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, you need to include Glide in your project. Start by adding the
    following line of code to the `dependencies` block inside your app’s `gradle.build`
    file:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，您需要在项目中包含 Glide。首先，将以下行代码添加到您的应用 `gradle.build` 文件中的 `dependencies` 块内：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `GlideImageLoader` class in your app package path, containing the
    following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用包路径中创建一个 `GlideImageLoader` 类，包含以下内容：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a simple implementation assuming the loaded image should always be center-cropped.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现，假设加载的图片应该始终居中裁剪。
- en: 'Update your `MainActivity` file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的 `MainActivity` 文件：
- en: '[PRE20]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will define your adapter, attach it to `RecyclerView`, and populate it
    with some hardcoded data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义您的适配器，将其附加到 `RecyclerView` 并用一些硬编码的数据填充它。
- en: 'In your `AndroidManifest.xml` file, add the following in the `manifest` tag
    before the application tag:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `AndroidManifest.xml` 文件中，在 `manifest` 标签中的应用标签之前添加以下内容：
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having this tag will allow your app to download images from the internet.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个标签将允许您的应用从互联网下载图片。
- en: 'For some final touches, such as giving our title view a proper name and text,
    update your `activity_main.xml` file, like so:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行一些最后的润色，例如给我们的标题视图一个合适的名称和文本，更新您的 `activity_main.xml` 文件，如下所示：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, update your `strings.xml` file to give your app a proper name and title:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，更新您的 `strings.xml` 文件，为您的应用提供一个合适的名称和标题：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run your app. It should look like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用。它应该看起来像这样：
- en: '![Figure 6.7 – RecyclerView with hardcoded secret cat agents](img/B19411_06_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 带有硬编码的秘密猫特工的RecyclerView](img/B19411_06_07.jpg)'
- en: Figure 6.7 – RecyclerView with hardcoded secret cat agents
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 带有硬编码的秘密猫特工的RecyclerView
- en: As you can see, `RecyclerView` now has content, and your app is starting to
    take shape. Note how the same layout is used to present different items based
    on the data bound to each instance. As you would expect, if you add enough items
    for them to go off screen, scrolling works. Next, we’ll look into allowing a user
    to interact with the items inside our `RecyclerView`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`RecyclerView`现在有了内容，您的应用开始成形。注意，相同的布局被用来根据绑定到每个实例的数据展示不同的项目。正如您所期望的，如果您添加足够的项目使它们超出屏幕，则可以滚动。接下来，我们将探讨允许用户与`RecyclerView`内部的项目进行交互。
- en: Responding to clicks in RecyclerView
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RecyclerView中响应点击
- en: What if we want to let our users select an item from a presented list? To achieve
    that, we need to communicate clicks back to our app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让用户从显示的列表中选择一个项目呢？为了实现这一点，我们需要将点击事件回传到我们的应用中。
- en: The first step in implementing click interaction is to capture clicks on items
    at the `ViewHolder` level. To maintain separation between our view holder and
    the adapter, we define a nested `OnClickListener` interface in our view holder.
    We choose to define the interface within the view holder because that and the
    listener are tightly coupled.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实现点击交互的第一步是在`ViewHolder`级别捕获项目的点击。为了保持我们的视图持有者和适配器之间的分离，我们在视图持有者中定义了一个嵌套的`OnClickListener`接口。我们选择在视图持有者中定义接口，因为那和监听器是紧密耦合的。
- en: The interface will, in our case, have only one function. The purpose of this
    function is to inform the owner of the view holder about the clicks. The owner
    of a view holder is usually a `Fragment` or an `Activity`. Since we know that
    a view holder can be reused, we know that it can be challenging to define it at
    construction time in a way that would tell us which item was clicked (since that
    item will change over time with reuse).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个接口将只有一个功能。这个函数的目的是通知视图持有者的所有者关于点击的信息。视图持有者的所有者通常是`Fragment`或`Activity`。由于我们知道视图持有者可以被重用，我们知道在构造时定义它可能会很有挑战性，这样我们就能知道哪个项目被点击了（因为随着重用，那个项目会随时间改变）。
- en: 'We work around that by passing the currently presented item back to the owner
    of the view holder on clicking. This means our interface would look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在点击时将当前显示的项目回传给视图持有者的所有者来解决这个问题。这意味着我们的接口看起来会是这样：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also add this listener as a parameter to our `ViewHolder` constructor:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把这个监听器作为一个参数添加到我们的`ViewHolder`构造函数中：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It will be used like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它将这样使用：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we want our adapter to pass in a listener. In turn, that listener will
    be responsible for informing the owner of the adapter about the click. This means
    our adapter, too, would need a nested listener interface, quite similar to the
    one we implemented in our view holder.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望我们的适配器传递一个监听器。反过来，这个监听器将负责通知适配器的所有者关于点击的信息。这意味着我们的适配器也需要一个嵌套的监听器接口，这与我们在视图持有者中实现的接口非常相似。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While this seems like duplication that can be avoided by reusing the same listener,
    that is not a great idea, as it leads to tight coupling between the view holder
    and the adapter through the listener. What happens when you want your adapter
    to also report other events through the listener? You would have to handle those
    events coming from the view holder, even though they would not actually be implemented
    in the view holder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这似乎是重复的，可以通过重用相同的监听器来避免，但这并不是一个好主意，因为它会导致通过监听器在视图持有者和适配器之间产生紧密耦合。当你想要你的适配器也通过监听器报告其他事件时会发生什么？你将不得不处理来自视图持有者的这些事件，即使它们实际上并没有在视图持有者中实现。
- en: Finally, to handle the click event and show a dialog, we define a listener in
    our activity and pass it to our adapter. We set that listener to show a dialog
    on clicking. In an MVVM implementation, you would be notifying the `ViewModel`
    of the click at this point instead. `ViewModel` would then update its state, telling
    the view (our activity) that it should display the dialog.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了处理点击事件并显示对话框，我们在活动中定义了一个监听器，并将其传递给适配器。我们设置这个监听器，在点击时显示对话框。在MVVM实现中，你会在这一点通知`ViewModel`关于点击的信息。`ViewModel`随后会更新其状态，告诉视图（我们的活动）应该显示对话框。
- en: Exercise 6.03 – responding to clicks
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03 – 响应点击
- en: 'Your app already shows the user a list of secret cat agents. It is time to
    allow your user to choose a secret cat agent by clicking on its view. Click events
    are delegated from the view holder to the adapter to the activity, as shown in
    *Figure 6**.9*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用已经向用户展示了秘密猫特工的列表。现在是时候允许用户通过点击其视图来选择一个秘密猫特工了。点击事件从视图持有器委托到适配器再到活动，如图*图6.9*所示：
- en: '![Figure 6.8 – The flow of click events](img/B19411_06_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 点击事件流程](img/B19411_06_08.jpg)'
- en: Figure 6.8 – The flow of click events
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 点击事件流程
- en: 'The following are the steps that you need to follow to complete this exercise:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习需要遵循以下步骤：
- en: 'Open your `CatViewHolder.kt` file. Add a nested interface to it right before
    the final closing curly bracket:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`CatViewHolder.kt`文件。在最后的闭合花括号之前向其中添加一个嵌套接口：
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will be the interface that a listener will have to implement in order to
    register for click events on individual cat items.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是监听器必须实现以注册对单个猫项目点击事件的接口。
- en: 'Update the `CatViewHolder` constructor to accept `OnClickListener` and make
    `containerView` accessible:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CatViewHolder`构造函数以接受`OnClickListener`并使`containerView`可访问：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, when constructing a `CatViewHolder` constructor, you also register for
    clicks on item views.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当构建`CatViewHolder`构造函数时，你还需要为项目视图注册点击事件。
- en: 'At the top of your `bindData(CatUiModel)` function, add the following to intercept
    clicks and report them to the provided listener:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bindData(CatUiModel)`函数的顶部添加以下内容以拦截点击并报告给提供的监听器：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, open your `CatsAdapter.kt` file. Add this nested interface right before
    the final closing curly bracket:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你的`CatsAdapter.kt`文件。在最后的闭合花括号之前添加这个嵌套接口：
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This defines the interface that listeners will have to implement to receive
    item click events from the adapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了监听器必须实现的接口，以接收来自适配器的项目点击事件。
- en: 'Update the `CatsAdapter` constructor to accept a call implementing the `OnClickListener`
    adapter you just defined:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CatsAdapter`构造函数以接受一个实现你刚刚定义的`OnClickListener`适配器的调用：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `onCreateViewHolder(ViewGroup, Int)`, update the creation of the view holder,
    as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreateViewHolder(ViewGroup, Int)`中，更新视图持有者的创建，如下所示：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will add an anonymous class that delegates the `ViewHolder` click events
    to the adapter listener.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加一个匿名类，将`ViewHolder`的点击事件委托给适配器监听器。
- en: 'Finally, open your `MainActivity.kt` file. Update your `catsAdapter` construction
    as follows to provide the required dependencies to the adapter, in the form of
    an anonymous listener handling click events by showing a dialog:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开你的`MainActivity.kt`文件。按照以下方式更新`catsAdapter`的构建，以向适配器提供所需的依赖项，形式为一个匿名监听器，通过显示对话框来处理点击事件：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following function right before the final closing curly bracket:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后的闭合花括号之前添加以下函数：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function will show a dialog with the name of the cat whose data was passed
    in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将显示一个对话框，显示传递进来的猫的数据名称。
- en: Make sure to import the right version of `AlertDialog`, which is `androidx.appcompat.app.AlertDialog`,
    not `android.app.AlertDialog`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保导入正确的`AlertDialog`版本，即`androidx.appcompat.app.AlertDialog`，而不是`android.app.AlertDialog`。
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The AppCompat version is usually a better choice because it offers backward
    compatibility.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AppCompat版本通常是一个更好的选择，因为它提供了向后兼容性。
- en: 'Run your app. Clicking on one of the cats should now open a dialog:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用。点击猫中的一个应该现在会打开一个对话框：
- en: '![Figure 6.9 – A dialog showing an agent was selected](img/B19411_06_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 显示已选择代理的对话框](img/B19411_06_09.jpg)'
- en: Figure 6.9 – A dialog showing an agent was selected
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 显示已选择代理的对话框
- en: Try clicking the different items, and note the different messages presented.
    You now know how to respond to users clicking on items inside your `RecyclerView`.
    Next, we will look at how we can support different item types in our lists.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击不同的项目，并注意显示的不同消息。你现在知道如何响应用户在`RecyclerView`内部点击物品。接下来，我们将探讨如何在我们的列表中支持不同的项目类型。
- en: Supporting different Item types
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同的项目类型
- en: In the previous sections, we learned how to handle a list of items of a single
    type (in our case, all our items were `CatUiModel`). What happens if you want
    to support more than one type of item? A good example of this would be having
    group titles on our list.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何处理单一类型的物品列表（在我们的案例中，所有物品都是`CatUiModel`）。如果你想要支持多种类型的物品，会发生什么？一个很好的例子是在我们的列表中添加分组标题。
- en: 'Let’s say that instead of getting a list of cats, we get a list containing
    happy cats and sad cats. Each of the two groups of cats is preceded by a title
    of the corresponding group. Instead of a list of `CatUiModel` instances, our list
    would now contain `ListItem` instances. `ListItem` might look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是得到猫的列表，而是得到包含快乐猫和悲伤猫的列表。这两组猫的前面都有对应组的标题。我们的列表现在将包含 `ListItem` 实例，而不是 `CatUiModel`
    实例的列表。`ListItem` 可能看起来像这样：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our list of items may look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目列表可能看起来像这样：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, having just one layout type will not do. Luckily, as you may have
    noticed in our earlier exercises, `RecyclerView.Adapter` provides us with a mechanism
    to handle this (remember the `viewType` parameter used in the `onCreateViewHolder(ViewGroup,`
    `Int)` function?).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个布局类型是不够的。幸运的是，正如您可能在我们早期的练习中注意到的，`RecyclerView.Adapter` 为我们提供了一个处理这种情况的机制（记得在
    `onCreateViewHolder(ViewGroup, Int)` 函数中使用的 `viewType` 参数吗？）。
- en: 'To help the adapter determine which view type is needed for each item, we override
    its `getItemViewType(Int)` function. An example of an implementation that would
    do the trick for us is the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助适配器确定每个项目所需的视图类型，我们重写了它的 `getItemViewType(Int)` 函数。以下是一个实现示例，它可以为我们完成这项工作：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, `VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT` are defined as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`VIEW_TYPE_GROUP` 和 `VIEW_TYPE_CAT` 定义如下：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This implementation maps the data type at a given position to a constant value,
    representing one of our known layout types. In our case, we know about titles
    and cats, thus the two types. The values we use can be any integer values as they’re
    passed back to us, as is the case in the `onCreateViewHolder(ViewGroup, Int)`
    function. All we need to do is make sure not to repeat the same value more than
    once.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将给定位置的 数据类型映射到表示我们已知布局类型之一的常量值。在我们的情况下，我们知道有标题和猫，因此有两种类型。我们使用的值可以是任何整数值，因为它们会回传给我们，就像在
    `onCreateViewHolder(ViewGroup, Int)` 函数中一样。我们唯一需要做的是确保不要重复使用相同的值。
- en: 'Now that we have told the adapter which view types are supported, we also need
    to tell it which view holder to use for each view type. This is done by implementing
    the `onCreateViewHolder(ViewGroup,` `Int)` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经告诉适配器支持哪些视图类型，我们还需要告诉它每种视图类型应该使用哪个视图持有者。这是通过实现 `onCreateViewHolder(ViewGroup,
    Int)` 函数来完成的：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unlike the earlier implementations of this function, we now take the value of
    `viewType` into account.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与此函数的早期实现不同，我们现在考虑了 `viewType` 的值。
- en: As we now know, `viewType` is expected to be one of the values we returned from
    `getItem``ViewType(Int)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`viewType` 应该是我们从 `getItemViewType(Int)` 返回的值之一。
- en: For each of these values (`VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT`), we inflate
    the corresponding layout and construct a suitable view holder. Note that we never
    expect to receive any other value, so we throw an exception if such a value is
    encountered.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些值（`VIEW_TYPE_GROUP` 和 `VIEW_TYPE_CAT`），我们填充相应的布局并构建合适的视图持有者。请注意，我们从未期望收到任何其他值，因此如果遇到这样的值，我们会抛出异常。
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your needs, you could instead return a default view holder with
    a layout, showing an error or nothing at all. It may also be a good idea to log
    such values to allow you to investigate why you received them and decide how to
    handle them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，您可以选择返回一个带有布局的默认视图持有者，显示错误或什么也不显示。记录这样的值可能也是一个好主意，这样您可以调查为什么收到它们，并决定如何处理它们。
- en: For our group title layout, a simple `TextView` may be sufficient. For a cat,
    the `item_cat.xml` layout can be used as is.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的组标题布局，一个简单的 `TextView` 可能就足够了。对于猫，可以使用 `item_cat.xml` 布局。
- en: Now, let’s move on to the view holder. We need to create a view holder for the
    group title. This means we will now have two different view holders. However,
    our adapter only supports one adapter type. The easiest solution is to define
    a common view holder that both `GroupViewHolder` and `CatViewHolder` will extend.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到视图持有者。我们需要为组标题创建一个视图持有者。这意味着我们现在将有两个不同的视图持有者。然而，我们的适配器只支持一种适配器类型。最简单的解决方案是定义一个通用的视图持有者，`GroupViewHolder`
    和 `CatViewHolder` 都会扩展它。
- en: 'Let’s call it `ListItemViewHolder`. The `ListItemViewHolder` class can be abstract,
    as we never intend to use it directly. To make it easy to bind data, we can also
    introduce a function in our abstract view holder – `abstract fun` `bindData(listItem:
    ListItemUiModel)`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们称它为 `ListItemViewHolder`。`ListItemViewHolder` 类可以是抽象的，因为我们从不打算直接使用它。为了使其更容易绑定数据，我们还可以在我们的抽象视图持有者中引入一个函数——`abstract
    fun bindData(listItem: ListItemUiModel)`。'
- en: 'Our concrete implementations can expect to receive a specific type, and so
    we can add the following lines to both `GroupViewHolder` and `CatViewHolder` respectively:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的具体实现可以期望接收特定类型，因此我们可以在 `GroupViewHolder` 和 `CatViewHolder` 分别添加以下行：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Specifically, in `CatViewHolder`, thanks to some Kotlin magic, we can then use
    `define val cat = listItem.cat` and leave the rest of the class unchanged.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在 `CatViewHolder` 中，得益于一些 Kotlin 魔法，我们可以使用 `define val cat = listItem.cat`
    并保持类中其余部分不变。
- en: Having made those changes, we can now expect to see the `Happy Cats` and `Sad
    Cats` group titles, each followed by the relevant cats.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了这些更改后，我们现在可以期待看到 `快乐猫` 和 `悲伤猫` 组标题，每个标题后面跟着相关的猫。
- en: Exercise 6.04 – adding titles to RecyclerView
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04 – 向 RecyclerView 添加标题
- en: 'We now want to be able to present our secret cat agents in two groups – active
    agents that are available for us to deploy to the field and sleeper agents that
    cannot currently be deployed. We will do that by adding a title above the active
    agents and another above the sleeper agents:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在希望能够以两组形式展示我们的秘密猫特工 – 可用于部署到现场的活跃特工和目前无法部署的卧底特工。我们将通过在活跃特工和卧底特工上方添加标题来实现这一点：
- en: Under `com.example.myrecyclerviewapp.model`, create a new Kotlin file called
    `ListItemUiModel`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.myrecyclerviewapp.model` 下创建一个名为 `ListItemUiModel` 的新 Kotlin
    文件。
- en: 'Add the following to the `ListItemUiModel.kt` file, defining our two data types
    – titles and cats:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ListItemUiModel.kt` 文件中添加以下内容，定义我们的两种数据类型 – 标题和猫：
- en: '[PRE41]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a new Kotlin file in `com.example.myrecyclerviewapp` named `ListItem`
    **ViewHolder**. This will be our base view holder.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.myrecyclerviewapp` 下创建一个名为 `ListItem ViewHolder` 的新 Kotlin 文件。这将是我们的基础视图持有者。
- en: 'Populate the `ListItemViewHolder.kt` file with the following:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ListItemViewHolder.kt` 文件中填充以下内容：
- en: '[PRE42]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open the `CatViewHolder.kt` file.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CatViewHolder.kt` 文件。
- en: 'Make `CatViewHolder` extend `ListItemViewHolder`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使 `CatViewHolder` 继承 `ListItemViewHolder`:'
- en: '[PRE43]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the `bindData(CatUiModel)` parameter with `ListItemUiModel` and make
    it override the `ListItemViewHolder` abstract function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `bindData(CatUiModel)` 参数替换为 `ListItemUiModel` 并使其覆盖 `ListItemViewHolder`
    抽象函数：
- en: '[PRE44]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following two lines to the top of the `bindData(ListItemUiModel)` function
    to enforce casting `ListItemUiModel` to `ListItemUiModel.Cat` and to fetch the
    cat data from it:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bindData(ListItemUiModel)` 函数顶部添加以下两行，以强制将 `ListItemUiModel` 强制转换为 `ListItemUiModel.Cat`
    并从中获取猫数据：
- en: '[PRE45]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Leave the rest of the file untouched.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 保持文件其余部分不变。
- en: Create a new layout file. Name your layout `item_title`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布局文件。将你的布局命名为 `item_title`。
- en: 'Replace the default content of the newly created `item_title.xml` file with
    the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的 `item_title.xml` 文件中的默认内容替换为以下内容：
- en: '[PRE46]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This new layout, containing only a `TextView` with a 16 sp-sized bold font,
    will host our titles:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的布局，仅包含一个 16 sp 大小加粗字体的 `TextView`，将承载我们的标题：
- en: '![Figure 6.10 – A preview of the item_title.xml layout](img/B19411_06_010.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – item_title.xml 布局的预览](img/B19411_06_010.jpg)'
- en: Figure 6.10 – A preview of the item_title.xml layout
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – item_title.xml 布局的预览
- en: 'Implement `TitleViewHolder` in a new file with the same name under `com.example.myrecyclerviewapp`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.myrecyclerviewapp` 下以相同名称创建一个新文件，实现 `TitleViewHolder`：
- en: '[PRE47]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is very similar to `CatViewHolder`, but since we only set the text on `TextView`,
    it is also much simpler.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `CatViewHolder` 非常相似，但由于我们只在 `TextView` 上设置文本，因此它也简单得多。
- en: Now, to make things tidier, select `CatViewHolder`, `ListItemViewHolder`, and
    `TitleViewHolder`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使事情更整洁，选择 `CatViewHolder`、`ListItemViewHolder` 和 `TitleViewHolder`。
- en: Move all the files to a new namespace; right-click on one of the files, and
    then select **Refactor** | **Move** (or press *F6*).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文件移动到新的命名空间；在文件上右键单击，然后选择 **重构** | **移动**（或按 *F6*）。
- en: Append `/viewholder` to the prefilled **To directory** field. Leave **Search
    references** and **Update package directive (Kotlin files)** checked and **Open
    moved files in editor** unchecked. Click **OK**.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `/viewholder` 添加到预填充的 **目标目录** 字段。保留 **搜索引用** 和 **更新包指令（Kotlin 文件）** 复选框，并取消选中
    **在编辑器中打开移动的文件**。点击 **确定**。
- en: Open the `CatsAdapter.kt` file.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CatsAdapter.kt` 文件。
- en: Now, rename `CatsAdapter` `ListItemsAdapter`. Right-click on the `CatsAdapter`
    class name in the code window, and then select **Refactor** | **Rename** (or *Shift*
    + *F6*).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `CatsAdapter` 重命名为 `ListItemsAdapter`。在代码窗口中右键单击 `CatsAdapter` 类名，然后选择
    **重构** | **重命名**（或按 *Shift* + *F6*）。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to maintain the naming of variables, functions, and classes
    to reflect their actual usage to avoid future confusion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 维护变量、函数和类的命名以反映它们的实际使用，这对于避免未来的混淆非常重要。
- en: When `CatsAdapter` is highlighted, type `ListItemsAdapter` and press *Enter*.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CatsAdapter`被高亮显示时，输入`ListItemsAdapter`并按*Enter*。
- en: 'Change the adapter generic type to `ListItemViewHolder`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将适配器泛型类型更改为`ListItemViewHolder`：
- en: '[PRE48]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update `listData` and `setData(List<CatUiModel>)` to handle `ListItemUiModel`
    instead:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`listData`和`setData(List<CatUiModel>)`以处理`ListItemUiModel`：
- en: '[PRE49]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Update `onBindViewHolder(CatViewHolder)` to comply with the adapter contract
    change:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`onBindViewHolder(CatViewHolder)`以符合适配器合约更改：
- en: '[PRE50]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At the top of the file, after the imports and before the class definition,
    add the view type constants:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，在导入之后和类定义之前，添加视图类型常量：
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement `getItemViewType(Int)`, like so:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getItemViewType(Int)`，如下所示：
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, change your `onCreateViewHolder(ViewGroup, Int)` implementation, as
    follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更改你的`onCreateViewHolder(ViewGroup, Int)`实现，如下所示：
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update `MainActivity` to populate the adapter with appropriate data, replacing
    the previous `catsAdapter.setData(List<CatUiModel>)` call (note that the following
    code has been truncated for space; refer to the link after the code block to access
    the full code that you need to add):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MainActivity`以用适当的数据填充适配器，替换之前的`catsAdapter.setData(List<CatUiModel>)`调用（注意以下代码因空间限制已被截断；请参阅代码块后的链接以获取需要添加的完整代码）：
- en: MainActivity.kt
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MainActivity.kt
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The complete code for this step can be found at [http://packt.live/3icCrSt](http://packt.live/3icCrSt).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[http://packt.live/3icCrSt](http://packt.live/3icCrSt)找到。
- en: Since `catsAdapter` is no longer holding `CatsAdapter` but `ListItemsAdapter`,
    rename it accordingly. Name it `listItemsAdapter`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`catsAdapter`不再持有`CatsAdapter`而是`ListItemsAdapter`，因此相应地重命名它。命名为`listItemsAdapter`。
- en: 'Run the app. You should see something similar to the following:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用。你应该看到以下类似的内容：
- en: '![Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header
    views](img/B19411_06_011.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 带有睡眠者和活动者头部视图的RecyclerView](img/B19411_06_011.jpg)'
- en: Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header
    views
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 带有睡眠者和活动者头部视图的RecyclerView
- en: As you can see, we now have titles above our two agent groups. Unlike the `RecyclerView`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在在我们的两个代理组上方有标题。与`RecyclerView`不同。
- en: Swiping to remove Items
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动删除项目
- en: In the previous sections, we learned how to present different view types. However,
    up until now, we have worked with a fixed list of items. What if you want to be
    able to remove items from the list? There are a few common mechanisms to achieve
    that – fixed **delete** buttons on each item, swiping to delete, and long-clicking
    to select and then a tapping a **delete** button, to name a few. In this section,
    we will focus on the *swiping to* *delete* approach.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何展示不同的视图类型。然而，到目前为止，我们一直在使用固定列表的项目。如果你想要能够从列表中删除项目怎么办？有一些常见的机制可以实现这一点——每个项目上的固定**删除**按钮、滑动删除和长按选择然后点击**删除**按钮，仅举几例。在本节中，我们将重点关注*滑动删除*的方法。
- en: 'Let’s start by adding the deletion functionality to our adapter. To tell the
    adapter to remove an item, we need to indicate which item we want to remove. The
    simplest way to achieve this is by providing the position of the item. In our
    implementation, this will directly correlate to the position of the item in our
    `listData` list. So, our `removeItem(Int)` function should look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们给我们的适配器添加删除功能。要告诉适配器删除一个项目，我们需要指出我们想要删除哪个项目。实现这一点的最简单方法是通过提供项目的位置。在我们的实现中，这将直接关联到`listData`列表中项目的位置。因此，我们的`removeItem(Int)`函数应该看起来像这样：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just like when setting data, we need to notify `RecyclerView` that the dataset
    has changed – in this case, an item was removed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就像设置数据一样，我们需要通知`RecyclerView`数据集已更改——在这种情况下，一个项目已被删除。
- en: Next, we need to define swipe gesture detection. This is done by utilizing `ItemTouchHelper`,
    which handles certain touch events, namely dragging and swiping, by reporting
    them to us via a callback. We handle these callbacks by implementing `ItemTouchHelper.Callback`.
    Also, `RecyclerView` provides `ItemTouchHelper.SimpleCallback`, which takes away
    the writing of a lot of boilerplate code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义滑动手势检测。这是通过利用`ItemTouchHelper`来完成的，它通过回调报告给我们某些触摸事件，即拖动和滑动。我们通过实现`ItemTouchHelper.Callback`来处理这些回调。此外，`RecyclerView`提供了`ItemTouchHelper.SimpleCallback`，它减少了大量样板代码的编写。
- en: 'We want to respond to swipe gestures but ignore move gestures. More specifically,
    we want to respond to swipes to the right. Moving is used to reorder items, which
    is beyond the scope of this chapter. So, our implementation of `SwipToDeleteCallback`
    will look as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望响应滑动手势但忽略移动手势。更具体地说，我们希望响应向右的滑动。移动用于重新排序项目，这超出了本章的范围。因此，我们的 `SwipToDeleteCallback`
    实现将如下所示：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Because our implementation is tightly coupled to our adapter and its view types,
    we can comfortably define it as an inner class. The benefit we gain is the ability
    to directly call methods on the adapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的实现与我们的适配器和其视图类型紧密耦合，我们可以舒适地将它定义为内部类。我们获得的好处是能够直接调用适配器的方法。
- en: As you can see, we return `false` from the `onMove(RecyclerView, ViewHolder,
    ViewHolder)` function. This means we ignore move events.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从 `onMove(RecyclerView, ViewHolder, ViewHolder)` 函数中返回 `false`。这意味着我们忽略移动事件。
- en: Next, we need to tell `ItemTouchHelper` which items can be swiped. We achieve
    this by overriding `getMovementFlags(RecyclerView, ViewHolder)`. This function
    is called when a user is about to start a drag or swipe gesture. `ItemTouchHelper`
    expects us to return the valid gestures for the provided view holder.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉 `ItemTouchHelper` 哪些项目可以被滑动。我们通过重写 `getMovementFlags(RecyclerView,
    ViewHolder)` 来实现这一点。当用户即将开始拖拽或滑动手势时，会调用此函数。`ItemTouchHelper` 期望我们返回给定视图持有者的有效手势。
- en: We check the `ViewHolder` class, and if it is `CatViewHolder`, we want to allow
    swiping; otherwise, we do not. We use `makeMovementFlags(Int, Int)`, which is
    a helper function used to construct flags in a way that `ItemTouchHelper` can
    decipher them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查 `ViewHolder` 类，如果是 `CatViewHolder`，我们希望允许滑动；否则，我们不允许。我们使用 `makeMovementFlags(Int,
    Int)`，这是一个辅助函数，用于以 `ItemTouchHelper` 可以解析的方式构造标志。
- en: Note that we define rules for `ACTION_STATE_IDLE`, which is the starting state
    of a gesture, thus allowing a gesture to start from the left or the right. We
    then combine it (using `or`) with the `ACTION_STATE_SWIPE` flags, allowing the
    ongoing gesture to swipe left or right. Returning `0` means neither swiping nor
    moving will occur for the provided view holder.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为 `ACTION_STATE_IDLE` 定义了规则，这是手势的起始状态，因此允许手势从左侧或右侧开始。然后我们（使用 `or`）将其与 `ACTION_STATE_SWIPE`
    标志结合，允许进行中的手势向左或向右滑动。返回 `0` 表示对于提供的视图持有者既不会滑动也不会移动。
- en: Once a swipe action is completed, `onSwiped(ViewHolder, Int)` is called. We
    then obtain the position from the passed-in view holder by calling `adapterPosition`.
    Now, `adapterPosition` is important because it is the only reliable way to obtain
    the real position of the item presented by the view holder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦滑动动作完成，就会调用 `onSwiped(ViewHolder, Int)`。然后，我们通过调用 `adapterPosition` 从传入的视图持有者中获取位置。现在，`adapterPosition`
    非常重要，因为它是获取视图持有者展示的项目真实位置的唯一可靠方式。
- en: With the correct position, we can remove the item by calling `removeItem(Int)`
    in the adapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得正确的位置后，我们可以通过在适配器中调用 `removeItem(Int)` 来删除项目。
- en: To expose our newly created `SwipeToDeleteCallback` implementation, we define
    a read-only variable within our adapter named `swipeToDeleteCallback`, and set
    it to a new instance of `SwipeToDeleteCallback`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公开我们新创建的 `SwipeToDeleteCallback` 实现方式，我们在适配器中定义一个只读变量 `swipeToDeleteCallback`，并将其设置为
    `SwipeToDeleteCallback` 的新实例。
- en: 'Finally, to plug our `callback` mechanism to `RecyclerView`, we need to construct
    a new `ItemTouchHelper` and attach it to our `RecyclerView`. We should do this
    when setting up our `RecyclerView`, which we do in the `onCreate(Bundle?)` function
    of our main activity. This is how the creation and attaching looks:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将我们的 `callback` 机制连接到 `RecyclerView`，我们需要构建一个新的 `ItemTouchHelper` 并将其附加到我们的
    `RecyclerView` 上。我们应该在设置 `RecyclerView` 时这样做，我们在主活动的 `onCreate(Bundle?)` 函数中这样做。创建和附加看起来是这样的：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can now swipe items to remove them from the list. Note how our titles cannot
    be swiped, just as we intended.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以滑动项目以从列表中删除它们。注意，正如我们预期的那样，我们的标题不能被滑动。
- en: You may have noticed a small glitch – the last item is cut off as it animates
    upward. This is happening because `RecyclerView` shrinks to accommodate the new
    (smaller) number of items before the animation starts. A quick fix to this would
    be to fix the height of our `RecyclerView` by confining its bottom to the bottom
    of its parent.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到一个小问题——最后一个项目在向上动画时被截断了。这是因为 `RecyclerView` 在动画开始之前缩小以适应新的（更小的）项目数量。一个快速的修复方法是固定我们的
    `RecyclerView` 的高度，使其底部与其父容器的底部对齐。
- en: Exercise 6.05 – adding swipe to delete functionality
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.05 – 添加滑动删除功能
- en: 'We previously added `RecyclerView` to our app and then added items of different
    types to it. We will now allow users to delete some items (we want to let the
    users remove secret cat agents but not titles) by swiping them left or right:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已将 `RecyclerView` 添加到我们的应用程序中，并向其中添加了不同类型的项。现在，我们将允许用户通过左右滑动来删除一些项（我们希望让用户删除秘密猫特工，但不能删除标题）：
- en: 'To add item removal functionality to our adapter, add the following function
    to `ListItemsAdapter` right after the `setData(List<ListItemUiModel>)` function:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将项删除功能添加到我们的适配器中，在 `setData(List<ListItemUiModel>)` 函数之后添加以下函数到 `ListItemsAdapter`：
- en: '[PRE58]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, right before the closing curly bracket of your `ListItemsAdapter` class,
    add the following `callback` implementation to handle the user swiping a cat agent
    left or right:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的 `ListItemsAdapter` 类的结束括号之前，添加以下 `callback` 实现来处理用户向左或向右滑动猫代理的情况：
- en: '[PRE59]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have implemented an `ItemTouchHelper.SimpleCallback` instance, passing in
    the directions we were interested in – `LEFT` and `RIGHT`. Joining the values
    is achieved by using the `or` Boolean operator.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已实现了一个 `ItemTouchHelper.SimpleCallback` 实例，传递我们感兴趣的指令——`LEFT` 和 `RIGHT`。通过使用
    `or` 布尔运算符来连接这些值。
- en: We have overridden the `getMovementFlags` function to make sure we have only
    handled swiping on a cat agent view and not on a title. Creating flags for both
    `ItemTouchHelper.ACTION_STATE_SWIPE` and `ItemTouchHelper.ACTION_STATE_IDLE` allows
    us to intercept both swipe and release events respectively.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已重写 `getMovementFlags` 函数，以确保我们只处理猫代理视图上的滑动，而不是标题上的滑动。为 `ItemTouchHelper.ACTION_STATE_SWIPE`
    和 `ItemTouchHelper.ACTION_STATE_IDLE` 创建标志允许我们分别拦截滑动和释放事件。
- en: Once a swipe is completed (the user has lifted their finger from the screen),
    `onSwiped` will be called, and in response, we remove the item at the position
    provided by the dragged view holder.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成滑动（用户已从屏幕上抬起手指），`onSwiped` 将被调用，作为响应，我们将移除由拖动视图持有者提供的位置的项。
- en: 'At the top of your adapter, expose an instance of the `SwipeToDeleteCallback`
    class you just created:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适配器的顶部，公开您刚刚创建的 `SwipeToDeleteCallback` 类的一个实例：
- en: '[PRE60]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Lastly, tie it all together by implementing `ItemViewHelper` and attaching
    it to our `RecyclerView`. Add the following code to the `onCreate(Bundle?)` function
    of your `MainActivity` file right after assigning the layout manager to your adapter:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过实现 `ItemViewHelper` 并将其附加到我们的 `RecyclerView` 上来将所有这些整合在一起。将以下代码添加到您的 `MainActivity`
    文件的 `onCreate(Bundle?)` 函数中，在将布局管理器分配给适配器之后：
- en: '[PRE61]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To address the small visual glitch you would get when items are removed, scale
    `RecyclerView` to fit the screen by updating the code in `activity_main.xml`,
    as follows. The changes are in the `RecyclerView` tag, right before the `app:layout_constraintTop_toBottomOf`
    attribute:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决当项被删除时出现的微小视觉错误，通过更新 `activity_main.xml` 中的代码来调整 `RecyclerView` 以适应屏幕。更改位于
    `RecyclerView` 标签中，在 `app:layout_constraintTop_toBottomOf` 属性之前：
- en: '[PRE62]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that there are two changes – we added a constraint at the bottom of the
    view to the bottom of the parent, and we set the layout height to `0dp`. The latter
    change tells our app to calculate the height of `RecyclerView` based on its constraints:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有两个变化——我们在视图底部添加了一个约束到父视图的底部，并将布局高度设置为 `0dp`。后者的变化告诉我们的应用程序根据其约束来计算 `RecyclerView`
    的高度：
- en: '![Figure 6.12 – RecyclerView taking the full height of the layout](img/B19411_06_012.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – RecyclerView 占据布局的全部高度](img/B19411_06_012.jpg)'
- en: Figure 6.12 – RecyclerView taking the full height of the layout
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – RecyclerView 占据布局的全部高度
- en: 'Run your app. You should now be able to swipe secret cat agents left or right
    to remove them from the list. Note that `RecyclerView` handles the collapsing
    animation for us:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。现在，您应该能够通过左右滑动秘密猫特工来从列表中删除它们。请注意，`RecyclerView` 为我们处理折叠动画：
- en: '![Figure 6.13 – A cat being swiped to the right](img/B19411_06_013.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 向右滑动的猫](img/B19411_06_013.jpg)'
- en: Figure 6.13 – A cat being swiped to the right
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 向右滑动的猫
- en: Note how even though titles are item views, they cannot be swiped. You have
    implemented a callback for swiping gestures that distinguishes between different
    item types and responds to a swipe by deleting the swiped item. Now, you know
    how to remove items interactively. Next, you will learn how to add new items as
    well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管标题是项目视图，但它们不能被滑动。您已经实现了一个用于滑动手势的回调，它区分不同的项目类型，并通过删除被滑动的项来响应滑动。现在，您知道如何交互式地删除项。接下来，您将学习如何添加新项。
- en: Adding items interactively
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式添加项
- en: We have just learned how to remove items interactively. What about adding new
    items? Let’s look into it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何交互式地移除项目。那么添加新项目呢？让我们来看看。
- en: 'Similar to the way we implemented the removal of items, we start by adding
    a function to our adapter:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们实现移除项目的方式类似，我们首先在我们的适配器中添加一个函数：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that the implementation is very similar to the `removeItem(Int)` function
    we implemented earlier. This time, we also receive an item to add and a position
    to add it to. We then add it to our `listData` list and notify `RecyclerView`
    that we added an item in the requested position.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实现方式与之前我们实现的 `removeItem(Int)` 函数非常相似。这次，我们同样接收一个要添加的项目和一个添加位置。然后我们将它添加到我们的
    `listData` 列表中，并通知 `RecyclerView` 我们在请求的位置添加了一个项目。
- en: 'To trigger a call to `addItem(Int, ListItemUiModel)`, we can add a button to
    our main activity layout. This button can be as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发对 `addItem(Int, ListItemUiModel)` 的调用，我们可以在我们的主活动布局中添加一个按钮。此按钮可以如下所示：
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The app will now look like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 应用现在看起来是这样的：
- en: '![Figure 6.14 – The main layout with a button to add a cat](img/B19411_06_014.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 带有添加猫按钮的主布局](img/B19411_06_014.jpg)'
- en: Figure 6.14 – The main layout with a button to add a cat
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 带有添加猫按钮的主布局
- en: Don’t forget to update your `RecyclerView` so that its bottom will be constrained
    to the top of this button. Otherwise, the button and `RecyclerView` will overlap.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新你的 `RecyclerView`，使其底部约束到该按钮的顶部。否则，按钮和 `RecyclerView` 将会重叠。
- en: In a production app, you could add a rationale about what a new item would be.
    For example, you could have a form for a user to fill in different details. For
    the sake of simplicity, in our example, we will always add the same dummy item
    – an anonymous female secret cat agent.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个生产应用中，你可以添加关于新项目是什么的理由。例如，你可以有一个表单供用户填写不同的详细信息。为了简单起见，在我们的示例中，我们将始终添加相同的虚拟项目
    – 一个匿名的女性秘密猫特工。
- en: 'To add the item, we set `OnClickListener` on our button:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加项目，我们在按钮上设置 `OnClickListener`：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: And that is it. We add the item at position `1` so that it is added right below
    our first title, which is the item at position `0`. In a production app, you could
    have logic to determine the correct place to insert an item. It could be below
    the relevant title or always be added at the top, bottom, or in the correct place
    to preserve some existing order.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们在位置 `1` 添加项目，使其正好位于我们的第一个标题下方，即位置 `0` 的项目。在一个生产应用中，你可以有逻辑来决定插入项目的正确位置。它可以是相关标题下方，或者总是添加到顶部、底部或正确的位置以保持某些现有顺序。
- en: We can now run the app. We will now have a new `RecyclerView`. The newly added
    cats can be swiped away to be removed, just like the hardcoded cats before them.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行应用。现在我们将有一个新的 `RecyclerView`。新添加的猫可以被滑动移除，就像之前的硬编码猫一样。
- en: Exercise 6.06 – implementing an Add A Cat button
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.06 – 实现添加猫按钮
- en: 'Having implemented a mechanism to remove items, it is time we implemented a
    mechanism to add items:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了移除项目的机制后，现在是时候实现添加项目的机制了：
- en: 'Add a function to `ListItemsAdapter` to support adding items. Add it below
    the `removeItem(Int)` function:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ListItemsAdapter` 中添加一个函数以支持添加项目。在 `removeItem(Int)` 函数下方添加它：
- en: '[PRE66]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add a button to `activity_main.xml`, right after the `RecyclerView` tag:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `activity_main.xml` 中添加一个按钮，紧接在 `RecyclerView` 标签之后：
- en: '[PRE67]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that `android:text="Add A Cat"` is highlighted. If you hover your mouse
    over it, you will see that this is because of the hardcoded string. Click on the
    **Add** word to place the editor cursor over it.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 `android:text="Add A Cat"` 被高亮显示。如果你将鼠标悬停在其上，你会看到这是由于硬编码的字符串造成的。点击 **添加**
    单词，将编辑器光标放置在其上。
- en: Press *Option* + *Enter* (iOS) or *Alt* + *Enter* (Windows) to show the context
    menu, and then press *Enter* again to show the **Extract** **Resource** dialog.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Option* + *Enter*（iOS）或 *Alt* + *Enter*（Windows）以显示上下文菜单，然后再次按下 *Enter*
    以显示 **提取** **资源** 对话框。
- en: Name the resource `add_button_label`. Press **OK**.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资源命名为 `add_button_label`。按 **确定**。
- en: 'To change the bottom constraint on `RecyclerView` so that the button and `RecyclerView`
    do not overlap, within your `RecyclerView` tag, locate the following:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改 `RecyclerView` 的底部约束，以便按钮和 `RecyclerView` 不重叠，在你的 `RecyclerView` 标签内，找到以下内容：
- en: '[PRE68]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Replace it with the following line of code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码行替换它：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a lazy field, holding a reference to the button at the top of the class,
    right after the definition of `recyclerView`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部，紧接在 `recyclerView` 定义之后添加一个懒字段，持有按钮的引用：
- en: '[PRE70]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that `addItemButton` is defined as a view. This is because, in our code,
    we don’t need to know the type of view to add a click listener to it. Choosing
    the more abstract type allows us to later change the type of view in the layout
    without having to modify this code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`addItemButton`被定义为视图。这是因为，在我们的代码中，我们不需要知道视图的类型来向其添加点击监听器。选择更抽象的类型允许我们在以后更改布局中的视图类型，而无需修改此代码。
- en: 'Lastly, update `MainActivity` to handle the click. Find the line that says
    the following:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`MainActivity`以处理点击。找到以下内容的行：
- en: '[PRE71]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Right after it, add the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，添加以下内容：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will add a new item to `RecyclerView` every time the button is clicked.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每次点击按钮时向`RecyclerView`添加一个新项目。
- en: 'Run the app. You should see a new button at the bottom of your app:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用。你应该在你的应用底部看到一个新按钮：
- en: '![Figure 6.15 – An anonymous cat is added with the click of a button](img/B19411_06_015.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 点击按钮添加了一只匿名猫](img/B19411_06_015.jpg)'
- en: Figure 6.15 – An anonymous cat is added with the click of a button
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 点击按钮添加了一只匿名猫
- en: Try clicking it a few times. Every time you click it, a new, anonymous secret
    cat agent is added to your `RecyclerView`. You can swipe away the newly added
    cats, just like you could with the hardcoded ones.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击几次。每次点击，都会在`RecyclerView`中添加一个新的匿名秘密猫特工。你可以像处理硬编码的猫一样滑动掉新添加的猫。
- en: In this exercise, you added new items to `RecyclerView` in response to user
    interaction. You now know how to change the contents of `RecyclerView` at runtime.
    It is useful to know how to update lists at runtime because, quite often, the
    data you are presenting to your users changes while the app is running, and you
    want to present your users with a fresh, up-to-date state.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你根据用户交互向`RecyclerView`添加了新项目。你现在知道如何在运行时更改`RecyclerView`的内容。了解如何在运行时更新列表是有用的，因为，相当常见的是，你在应用运行时向用户展示的数据会发生变化，而你希望向用户提供一个新鲜、最新的状态。
- en: Activity 6.01 – managing a list of Items
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第6.01节 – 管理项目列表
- en: Imagine you want to develop a recipe management app. Your app would support
    sweet and savory recipes. Users of your app could add new sweet or savory recipes,
    scroll through the list of added recipes – grouped by flavor (sweet or savory)
    – click a recipe to get information about it, and finally, delete recipes by swiping
    them aside.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要开发一个食谱管理应用。你的应用将支持甜味和咸味食谱。你的应用用户可以添加新的甜味或咸味食谱，滚动查看已添加食谱的列表——按口味（甜味或咸味）分组——点击一个食谱以获取其信息，最后，通过滑动将其删除。
- en: The aim of this activity is to create an app with `RecyclerView` that lists
    the title of recipes, grouped by flavor. `RecyclerView` will support user interaction.
    Each recipe will have a title, a description, and a flavor. Interactions will
    include clicks and swipes.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是创建一个带有`RecyclerView`的应用，列出按口味分组的食谱标题。`RecyclerView`将支持用户交互。每个食谱将有一个标题、一个描述和一个口味。交互包括点击和滑动。
- en: A click will present a user with a dialog showing the description of the recipe.
    A swipe will remove the swiped recipe from the app. Finally, with two `EditText`
    fields (see [*Chapter 3*](B19411_03.xhtml#_idTextAnchor163), *Developing the UI
    with Fragments*) and two buttons, a user can add a new sweet or savory recipe
    respectively, with the title and description set to the values set in the `EditText`
    fields.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 点击将向用户展示一个对话框，显示食谱的描述。滑动将删除被滑动的食谱。最后，使用两个`EditText`字段（见[*第3章*](B19411_03.xhtml#_idTextAnchor163)，*使用片段开发UI*）和两个按钮，用户可以分别添加新的甜味或咸味食谱，标题和描述设置为`EditText`字段中设置的值。
- en: 'The steps to complete this are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作的步骤如下：
- en: Create a new empty activity app.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空活动应用。
- en: Add `RecyclerView` support to the app’s `build.gradle` file.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RecyclerView`支持添加到应用的`build.gradle`文件中。
- en: 'Add `RecyclerView`, two `EditText` fields, and two buttons to the main layout.
    It should look something like this:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RecyclerView`、两个`EditText`字段和两个按钮添加到主布局中。它应该看起来像这样：
- en: '![Figure 6.16 – The layout with RecyclerView, two EditText fields, and two
    buttons](img/B19411_06_016.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 带有RecyclerView、两个EditText字段和两个按钮的布局](img/B19411_06_016.jpg)'
- en: Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 带有RecyclerView、两个EditText字段和两个按钮的布局
- en: Add models for the flavor titles and recipes, and an enum for flavor.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加口味标题和食谱的模型，以及一个用于口味的枚举。
- en: Add a layout for the flavor titles.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加口味标题的布局。
- en: Add a layout for the recipe titles.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加食谱标题的布局。
- en: Add view holders for the flavor titles and recipe titles, as well as an adapter.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为风味标题和食谱标题添加视图持有者，以及适配器。
- en: Add click listeners to show a dialog with recipe descriptions.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加点击监听器以显示包含食谱描述的对话框。
- en: Update `MainActivity` to construct the new adapter, and hook up the buttons
    to add new savory and sweet recipes. Make sure the form is cleared after a recipe
    is added.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MainActivity` 更新为构建新的适配器，并将按钮连接到添加新的咸味和甜味食谱。确保在添加食谱后清除表单。
- en: Add a swipe helper to remove items.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个滑动助手以删除项目。
- en: 'The final output will be as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出将如下所示：
- en: "![Figure 6.17 – The Recipe Book \uFEFF\uFEFFapp](img/B19411_06_017.jpg)"
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 烹饪书 app](img/B19411_06_017.jpg)'
- en: Figure 6.17 – The Recipe Book app
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 烹饪书 app
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在[https://packt.link/By7eE](https://packt.link/By7eE)找到。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to add `RecyclerView` support to our project.
    We also learned how to add `RecyclerView` to our layout and how to populate it
    with items. We went through adding different item types, which is particularly
    useful for titles. We covered interaction with `RecyclerView`, responding to clicks
    on individual items and responding to swipe gestures.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将 `RecyclerView` 支持添加到我们的项目中。我们还学习了如何将 `RecyclerView` 添加到我们的布局中，以及如何用项目填充它。我们探讨了添加不同项目类型，这对于标题特别有用。我们涵盖了与
    `RecyclerView` 的交互，响应单个项目的点击以及响应滑动手势。
- en: Lastly, we learned how to dynamically add and remove items to and from `RecyclerView`.
    The world of `RecyclerView` is very rich, and we have only scratched the surface.
    Going further would be beyond the scope of this book. However, it is strongly
    recommended that you investigate it on your own so that you can have carousels,
    designed dividers, and fancier swipe effects in your apps.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何动态地向 `RecyclerView` 添加和删除项目。`RecyclerView` 的世界非常丰富，我们只是触及了表面。进一步探索将超出本书的范围。然而，强烈建议您自行研究，以便您可以在应用程序中拥有轮播图、设计分隔符和更复杂的滑动效果。
- en: 'You can start your exploration here: [https://packt.link/ClmMn](https://packt.link/ClmMn).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里开始您的探索：[https://packt.link/ClmMn](https://packt.link/ClmMn)。
- en: In the next chapter, we will look into requesting special permissions on behalf
    of our app to enable it to perform certain tasks, such as accessing a user’s contacts
    list or microphone. We will also look into using Google’s Maps API and accessing
    a user’s physical location.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨代表我们的应用程序请求特殊权限，以便它能够执行某些任务，例如访问用户的联系人列表或麦克风。我们还将探讨使用 Google 的 Maps
    API 和访问用户的物理位置。
