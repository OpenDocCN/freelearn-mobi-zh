- en: Composing User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile apps seem like simple systems, but they are often actually quite deep
    and complex systems, with many different parts that help them keep the appearance
    of being simple. The user interfaces of applications are the same; they may appear
    simple, but they are often complex arrangements of screens and dialogs designed
    to hide the complexities of the application from the user and provide a smoother
    experience. The easiest way to think about this is that traditional desktop applications
    and websites tend to be *wide*, while mobile applications tend to be *deep*.
  prefs: []
  type: TYPE_NORMAL
- en: This comment applies (on the surface at least) to the navigation of applications.
    Desktop applications tend to have a central *control* area where most of the work
    is done. Think of a document editor--the application centers around the document
    being written, and you never really *leave* that area. Instead of navigating away,
    dialogs pop up to fulfill a single task, which alters the document before they
    disappear. There are many variations on this theme, but desktop applications tend
    to follow the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications, on the other hand, tend to start at an *overview* screen
    of some sort, or launch directly into an *action* screen. The user then navigates
    *downward* into a task or item before either returning to the overview screen,
    or completing their task and being presented with a *result* of some sort (for
    example, booking a flight). Achieving a goal by navigating away from the overview
    screen, rather than simply opening a dialog on top of the content, requires a
    different approach to your application's design. As there is no central screen
    always available to the user, you often need to remind them of where they are,
    and what they are doing. This sort of repetition will be unthinkable on a desktop
    application where the information is always available in another window or panel
    of the application; however, on the limited space offered by a mobile phone, this
    becomes an essential tool to keep the user on track, and help them complete the
    task they are trying to fulfill.
  prefs: []
  type: TYPE_NORMAL
- en: This change in how the user navigates, requires that screens often present the
    same data, or have elements that are repeated all over the application. These
    elements are best encapsulated so that they can be easily reused throughout the
    application. Android offers the perfect way to encapsulate these groups of widgets
    in a way that can be more aware than a simple layout component--fragments. A **Fragment**
    is like a *miniature* `Activity`; each Fragment has a full life cycle, just like
    `Activity`, except that they are always contained within an `Activity` (refer
    to [Appendix A](8b58d03e-232e-49ec-8aba-344b3ed81d2d.xhtml) for details of the
    `Activity` life cycle). Using fragments allows your application to more easily
    adapt to various screen sizes. We'll be taking a closer look at fragments later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at various ways to break up a user interface,
    building modules that can be layered and reused to form complex behaviors without
    requiring complex code and wiring. We''ll be looking at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build custom groups of widgets that can be directly included in layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build Fragments that expose common functionality with a complete life
    cycle of their own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use ViewPager to display pages or tabs of widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a modular layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you''ve built a single `Activity` class with a layout composed out
    of two layout files containing widgets. This is a pretty normal state of affairs,
    but it''s not the best situation. Like in most user interfaces, the claim capturing
    screen can be divided into a range of very logical areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f60df92-53cd-4554-9ba7-4e31ce4b843a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In an Android user interface, you always have the individual widgets (such
    as `Button`, `TextView`, `ImageView`, and friends) at the bottom level, and `Activity`
    at the top level, but when you look at that screen mockup, you can instantly see
    that the screen can be divided into other layers in between `Activity` and widget.
    You can, of course, take each of the `CardView` layouts from this screen and place
    them in their own layout XML files, and then import them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `<include>` element to include one layout file into another,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This nicely separates out the layout for this part of the screen, allowing you
    to reuse it in layouts for larger physical screens or even in other `Activity`
    classes in the application. The problem is that every screen that wants to use
    this layout will need to also duplicate all the logic associated with it. While
    the logical decoupling of the logic and the layout is mostly a good thing (especially
    when you can overlay the logic on multiple different layouts), their coupling
    is normally quite tight.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DatePickerLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of these areas can easily be encapsulated in a Java class and reused elsewhere
    in your application. In [Chapter 3](75335d7f-3cda-4985-b992-965f46adc335.xhtml),
    *Taking Actions*, you wrote the `DatePickerWrapper` class, which can turn any
    `TextView` widget into a date selection widget. However, `DatePickerWrapper` doesn't
    create the `TextView` label or change the styling of the widgets to look like
    `TextInputLayout`. This means that you need to copy that styling into each layout
    where you want a date-picker, which can quickly lead to inconsistencies in your
    user interface. While it's good to have the events and state decoupled from the
    display logic, it would also be nice to have them grouped together in a single
    structure that can be reused without every layout having to specify the date picker
    widgets by hand, and then bind them to the `DatePickerWrapper` in its code.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s not obvious at first, the Android layout XML files can reference
    any `View` class and not just those defined in the core and support packages,
    and it can do so without any special tricks. All you need to do is reference the
    `View` class by its fully-qualified name, much like you''ve already done for several
    widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.support.constraint.ConstraintLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.support.v7.widget.CardView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.support.design.widget.TextInputLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the preceding are classes that you can look up in Android Studio, and even
    read their code if you like. Let''s get started by writing a `DatePickerLayout`
    to couple the layout XML with the `DatePickerWrapper`, and make the date picker
    reusable from any layout XML file in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Android panel of Android Studio, right-click on the layout directory
    under res:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee95da20-5eb2-40a0-a6b4-b86b058794d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Select New | Layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new layout file as `widget_date_picker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Root element field to `merge`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0fb35182-414c-430f-8a77-159e36ca6774.png)'
  prefs: []
  type: TYPE_IMG
- en: '`merge` is a special root element for layout files. Normally, the root element
    of a layout file is a `View` class that results in the file having a root widget
    when it''s inflated. The `merge` element doesn''t create a root widget; instead,
    it''s effectively skipped when the file is loaded, and its children are inflated
    directly. This makes it ideal for creating layout widgets, or reusable bits of
    layout, while also keeping the layout hierarchy flat and helping improve your
    application''s performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Change the editor mode to Text instead of Design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `layout_width` and `layout_height` attributes from the `merge` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following two `TextView` widgets into the merge element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding file, there are no `id` attributes set; this is because any
    layout the new widget is used in will be polluted with those `id` attributes,
    and `findViewById` can easily start returning unexpected results. When encapsulating
    parts of your layout, always consider what `id` values will appear in the layout,
    and where they might be used in code. `findViewById` simply finds the *first*
    matching `View` object in the layout and returns it, and doesn''t consider where
    that `View` might have come from (that is: an `<include>`, or special `View` class).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Android panel of Android Studio, right-click on your `base` package
    (that is, `com.packtpub.claim`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b9d0772-6c90-47e1-9fa4-79f2067ac612.png)'
  prefs: []
  type: TYPE_IMG
- en: Select New and Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `widget.DatePickerLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Superclass to `android.widget.LinearLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new package and class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare fields in the `DatePickerLayout` for to reference a `TextView` label,
    and the `DatePickerWrapper` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Any class accessible from a layout XML requires several constructor overloads,
    so it''s best to create a single `initialize` method that can be reused for all
    of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Still within the `initialize` method, use `LayoutInflator` to load the layout
    XML file you wrote, adding its contents as elements to the `DatePickerLayout`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The parameters for the inflate method are the layout resource, the `ViewGroup`
    (in this case, `DatePickerLayout`) that will contain the layout, and whether or
    not to actually attach the elements of the layout resource to the `ViewGroup`.
    As you are using a merge element in the layout resource, the third parameter must
    be `true`, because otherwise the contents of the layout will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `getChildAt` to retrieve the new `TextView` elements that have been loaded
    by the `LayoutInflator`, and assign the fields of the `DatePickerLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Overload the constructors and invoke the `initialize` method in each of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create getters and setters to make the `DatePickerLayout` usable from the `Activity`
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `DatePickerLayout` contains some of the user-interface state (the currently
    selected date), it''s expected to keep track of this through possible `Activity`
    restarts, if required (an `Activity` is recreated every time the user changes
    between portrait and landscape, as these are considered *configuration* changes).
    This will involve saving its state to a `Parcel`, and restoring it from a `Parcel`
    when requested to (a `Parcel` is a bit like a `byte[]` of `Serialized` objects,
    except that all the marshaling work needs to be implemented). You''ll need an
    inner class that can hold the state of the `DatePickerLayout` (and it''s parent
    class--`LinearLayout`). For convenience, the `View` class provides a `BaseSavedState`
    abstract class to take care of some of the implementation for you, so extend `BaseSavedState`
    in a static inner class named `SavedState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Objects crossing between `Activity` instances need to be `Parcelable`, because
    Android may need to store the objects temporarily through the `Activity` life
    cycle. Being able to store just the important bits of data and state, instead
    of the entire widget tree, is very useful for conserving memory when the user
    has a lot of applications running. `BaseSavedState` implements `Parcelable` and
    will allow the `DatePickerLayout` to remember its state when the `Activity` is
    destroyed and recreated by the system.
  prefs: []
  type: TYPE_NORMAL
- en: '`SavedState` will also need a constructor to load its fields from a `Parcel`
    object; a `CharSequence` cannot be read directly from a `Parcel`, but fortunately,
    `TextUtils` has a nice helper for reading `CharSequence` objects from `Parcel`
    objects for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `SavedState` needs the `writeToParcel` method implemented in order to
    actually write those fields to a `Parcel`; part of this is delegated to the `BaseSavedState`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `Parcelable` implementation requires a special `public static final`
    field called `CREATOR`, which will be used by the `Parcel` system to create instances
    and arrays of the `Parcelable` objects. This also applies for every subclass,
    so write the following static final into the `SavedState` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When implementing a vanilla `Parcelable` class, Android Studio has a nice generator
    that can be triggered from the class declaration hints (look for "Add Parcelable
    Implementation") that will write a simple `writeToParcel` method, `Parcel` handling
    constructor, and the `CREATOR` field. Check whether it's working though; it skips
    any field it doesn't know how to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DatePickerLayout` class, you need to override the `onSaveInstanceState`
    method and create the `SavedState` object that will be recorded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to restore the state from a `SavedState` object, which requires
    overriding `onRestoreInstanceState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Open the `content_capture_claim.xml` layout file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Text editor, if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the two `TextView` elements that describe the date-picker, and replace
    them with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Open the `CaptureClaimActivity` class in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the references to `DatePickerWrapper` with `DatePickerLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This new `DatePickerLayout` class allows you to reuse the same label and editor
    in any layout XML file in your application, while also coupling the required events
    in a single class. Any time you have a layout with `TextViewLayout` widgets, the
    new `DatePickerLayout` will fit right into the style and allow for safe date selection.
    It's also very important to implement the `onSaveInstanceState`/`onRestoreInstanceState`
    method on `View` subclasses if you intend to carry any state. These classes are
    marshaled, and new instances of the `View` are created every time a configuration
    state changes, which includes actions such as the user rotating the device (refer
    to [Appendix A](192d8c3c-7167-43cf-ae76-9c841f4ec1d2.xhtml) for more information
    on `Activity` life cycle).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in the application, it's time to build a simple data model that
    the user interface will back onto. Each claim will be represented by a `ClaimItem`
    object, and will contain any number of `Attachment` objects, each of which will
    reference the `File` that was attached, and have a marker to help decide how the
    attachment should be previewed. All these classes will need to be `Parcelable`,
    because they need to be saved in the `CaptureClaimActivity`. The `CaptureClaimActivity`
    will also use them as input and output parameters, and any time an object needs
    to be passed as a parameter to or from an `Activity`, it needs to be `Parcelable`.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also be creating a `Category` enum that links the Android IDs to an internal
    model that can be stored without having to worry about the Android IDs changing
    their values as the application evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Attachment class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Attachment` class represents files that have been attached to a `ClaimItem`
    by the user. These should always be files accessible by the application, and later
    on, we''ll take steps to ensure this by copying all the attachments into a private
    space before attaching them to a claim item. For now, follow these steps to create
    the `Attachment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android panel, right-click on your default package (that is, `com.packtpub.claim`)
    and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new class as `model.Attachment`, and in the Interface(s) box, add
    `Parcelable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47ff5cc6-2cfe-4906-bb56-d25f03734c85.png)'
  prefs: []
  type: TYPE_IMG
- en: Click OK to create the new package and class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attachments have different types, which can affect how they are previewed;
    for now, you''ll just have images and unknown types. Inside the new `Attachment`
    class, create an `enum` to represent these types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Attachment` class, declare its fields, a constructor, and getters and
    setters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `Parcelable` implementation for the `Attachment` class. This
    is best done by hand in this case, as neither `File` nor the `Type` `enum` will
    be understood by Android Studio''s `Parcelable` generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the top of the `Attachment` class, add its `Parcelable.Creator`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Category enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next part of the model is the `Category` enumeration. This will serve a
    double purpose--when you change the list of available resources in your application,
    their IDs can all change. This makes these IDs unsuited to long-term identification
    of items; however, they are very useful as identifiers while the application is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: They are unique within the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are integer types, which are very fast for comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used to directly identify user-interface components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Category` enum will serve as a way to bind between a long-term stable
    identifier (the enum name), and the potentially unstable (but often much faster)
    Android resource ID. Follow these quick steps to create the `Category` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `model` package, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `Category`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Kind field to Enum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new enum file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the enum constants, and map them to their appropriate Android resource
    IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the ID integer, private constructor, and getter method for the ID.
    Note the use of the `@IdRes` annotation, which indicates what should be used for
    these specific integers; attempting to pass anything other than an ID resource
    in here will result in a lint error in Android Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are annotations similar to `@IdRes` for all of the different resource
    types available on Android. They are located in the `android.support.annotation`
    package. Use them wherever you expect an integer value to reference an Android
    resource of some type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a method to look up a `Category` enum constant from its Android
    ID resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating the ClaimItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **ClaimItem** is the heart of this application''s object model. Each claim
    the user collects is represented in memory as a single `ClaimItem` instance. Here
    are the steps required to build the `ClaimItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `model` package, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `ClaimItem`, and in the Interface(s) box, add `Parcelable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the fields of the `ClaimItem` type, and a `public` default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Use Android Studio to generate getter and setter methods for all the fields,
    except the attachments field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create methods to add, remove, and list the `Attachment` objects for the `ClaimItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Parcelable` methods for the `ClaimItem` class; again, this is
    more complex than the Android Studio generator can typically handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! With the formality of an object model out of the way, you can continue
    building the user interface. The next stage will involve building `Fragment` classes
    that will help modularize the capturing of the `ClaimItem` data.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the category picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The category picker you created for the `CaptureClaimActivity` is just a group
    of widgets in a card right now, and while it's one of the simplest cards to use
    on the screen, it's also one of the largest by the amount of code written for
    it. The best way to encapsulate this part of the screen is to move the layout
    that appears inside the `CardView` into a `Fragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, why a `Fragment` class, and why not write another `Layout` class?
    `Fragment` classes are self-contained systems, and have their own life cycle within
    the context of their parent `Activity`. This means they can contain significantly
    more application logic, and can be reused more easily in other parts of the application.
    It''s also because in this case, we rely on the IDs of the radio buttons to know
    what has been checked by the user, which means that we can very easily start polluting
    layouts with IDs specific to this specific widget. Fragment classes don''t stop
    this from happening, but it''s expected behavior. You don''t expect ID pollution
    from `View` classes, but from a `Fragment`, it''s okay. Follow these simple steps
    to encapsulate the category picker in a new `Fragment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `ui` package in your project and select New| Fragment | Fragment
    (Blank).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Fragment` class `CategoryPickerFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn off Include fragment factory methods? and Include interface callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/56299f89-cc3c-4035-a157-319351dc8804.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Finish to create your new `Fragment` and its layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new `fragment_category_picker.xml` file, and change the editor view
    to Text mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the root node of the layout from `FrameLayout` to `LinearLayout`, and
    make it a `vertical` orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remove any contents of the `LinearLayout` placed there by the Android Studio
    template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `content_capture_claim.xml` layout file, and change the editor view
    to Text mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut the contents of the `LinearLayout` containing the existing category picker,
    the entire `RadioGroup` and `TextView` used as their label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Paste this as the content of the `LinearLayout` in the `fragment_category_picker.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `content_capture_claim.xml` layout file, you can now remove the `LinearLayout`
    for the category picker and replace it with a reference to the `Fragment` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `CategoryPickerFragment` class in Android Studio, and at the
    top of the class, declare the fields for the `RadioGroup` and `TextView` that
    you''ll use to track and update the user''s selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `onCreateView`, you''ll need to change how the `View` is inflated,
    because you need to capture the fields and set up the event listeners. Note the
    use of the `IconPickerWrapper` as the event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a simple getter and setter method to retrieve and alter state using
    the `Category` enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Open the `CaptureClaimActivity` in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the categories field to use `CategoryPickerFragment`, instead of a `RadioGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreate` method, remove the code that initialized the category picker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `FragmentManager` to retrieve the new `CategoryPickerFragment` from the
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that you're using the `getSupportFragmentManager` method, and not `getFragmentManager`.
    This is because `CategoryPickerFragment` is built on top of the support APIs and
    is backwards compatible all the way to API level 4 (Android 1.6). Android Studio
    typically prefers the support APIs when generating code as it offers a very simple
    and stable target, since your application links against a static target, and you
    are in control of which version to link against and when to upgrade. You can reuse
    `CategoryPickerFragment` anywhere in the application, just as you would a custom
    `View` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Linking against the platform APIs (instead of the equivalent support) reduces
    backward compatibility and requires more testing since your application may behave
    slightly differently on different versions of the platform. However, platform
    versions may be slightly faster, and will result in smaller applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Attachment Pager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having modularized the category picker, it's time to turn your attention to
    the attachments. When you implemented the file selection, you left a `Toast` in
    place to show where the code would normally attach the selected file to the `ClaimItem`
    being captured. This next stage will be to create a `Fragment` that will encapsulate
    the previewing of the `Attachment` objects. You'll also move much of the attachment
    logic into this `Fragment`. Although the code to connect to other applications
    and request permissions is commonly placed in an `Activity` class, `Fragment`
    classes are also capable of performing the same actions, and the attachment pager
    is a perfect opportunity to show this off.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Fragment` will show a pattern where the `Fragment` interacts with the
    `Activity` that it belongs to without directly sending events upward. The instinct
    of most developers when encountering a `Fragment` for the first time is to use
    the pattern in the template where the `Fragment` can send events upward to its
    `Activity`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/159c0075-e9be-4b03-8dfc-1cbdca5ac4ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, this is often not desirable. It''s generally a much better idea to
    push changes through the data model, and have it deliver the events to areas that
    are interested in the changes. This is part of a unidirectional event flow, and
    serves to keep the application much easier to maintain and debug, because the
    data model always represents the *authority* for all information and state within
    the application, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/f6a7e4d3-8802-46f7-ba1e-eee6ba32b4e4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Attachment preview widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of the attachments will be a `View` implementation, to allow
    attachments to be previewed within the pager. This class will need an area where
    the attachment can be previewed if it''s an image, or a placeholder icon can be
    displayed if it''s a file the application cannot read. Follow these steps to create
    the new widget and it''s layout XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the layout directory under res, and select New | Layout resource
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `widget_attachment_preview`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Root element field to `merge`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `merge` element, create an `ImageView` that can carry the preview
    of the attachment file. The `ImageView` will need a margin to automatically scale
    the image to its size on the screen (while maintaining the image''s proportions):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the drawable resource directory, and select New, Vector Asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Icon button, search for the `insert drive file` icon and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new resource `ic_unknown_file_type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next and then on Finish to create the new resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ic_unknown_file_type.xml` file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `fillColor` attribute of the path to `#FFBAB5AB`, and save and close
    the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `widget` package in your project, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `AttachmentPreview`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Superclass field to `android.support.v7.widget.CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create fields to reference the `Attachment` object and the `ImageView` that
    will render its preview onto the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the standard `View` subclass constructors and an `initialize` method
    that inflates the layout XML and captures the `ImageView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a simple getter for the `Attachment` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a setter to update the `Attachment` field, and also start the update
    of the preview on-screen. You''ll also create an inner class using the `ActionCommand`
    class you wrote in [Chapter 3](75335d7f-3cda-4985-b992-965f46adc335.xhtml), *Taking
    Actions*, which will attempt to load the actual images on a background thread
    before updating the widget on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a great example of using an `ActionCommand` object to
    improve the user experience. When the `Attachment` is actually specified on the
    `AttachmentPreview` widget, the onscreen preview is instantly queued, and the
    loading of the actual preview (which may take a second or two on a slower device)
    takes place in the background. This frees the main thread to continue processing
    events from the user, or start the loading of other previews that may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Attachment Pager Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ViewPager` class is a special type of Android widget called an adapter
    view (although some, such as `ViewPager`, don''t actually inherit from `AdapterView`,
    it shares much of the concepts). An `AdapterView` is used when it potentially
    needs to display more data than will fit on the screen at once, but maintain excellent
    performance. They do this by maintaining a small selection of widgets that will
    be displayed on the screen, and an `Adapter` that will populate the widgets with
    the data to display. Examples of `Adapter` widgets are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView`: A simple vertical scrolling list of similar items, such as phone
    contacts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`: A vertical scrolling grid of similar items, such as photos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackView`: A three-dimensional stack of items great for presenting media'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecyclerView`: A powerful all-purpose pooling view, originally added to replace
    `ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you wanted to display a scrolling list of images, for example, you would
    use a `RecyclerView` and provide it with an `Adapter` that could load previews
    of image files into `ImageView` widgets (much the same way as the `AttachmentPreview`
    class does):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26b634a8-dfa9-4b58-95ff-c18b6b7b25d0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`ViewPager` is a little different from the `AdapterView` classes described
    here; all of them only maintain as many widgets as what can fit on the screen
    at once. The normal `AdapterView` classes and `RecyclerView` all *recycle* their
    pool of widgets. When one widget is scrolled off the screen, it''s resized, populated
    with new data, and scrolled into view looking like a new widget. `ViewPager` doesn''t
    stop you from doing this, but it doesn''t do it for you. This is because `ViewPager`
    often contains large and complex tab layouts, which would be too expensive to
    try and recycle (or simply don''t repeat at all, in which case, recycling is useless).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this application, the user is unlikely to have many attachments, so you
    can get away with simply creating an `AttachmentPreview` instance for each of
    the attachments when they are displayed, which keeps the steps for implementing
    the `Adapter` much simpler and to the point:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your default package (that is, `com.packtpub.claim`) and select
    New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ui.attachments.AttachmentPreviewAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make its Superclass `android.support.v4.view.PagerAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This class will need a `List` of the `Attachment` objects it''s expected to
    translate into widgets for previewing, and it''ll need a setter to change what
    will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After changing the `List` of attachments, `AttachmentPreviewAdapter` is wrapping;
    it invokes `notifyDataSetChanged()`, which informs the `ViewPager` it's attached
    to things that have changed, and some rerendering may be required. This sort of
    functionality can be found in all the `Adapter` classes, and allows for the reactive
    behavior that users expect from their apps. When a new email arrives, it can just
    appear on the list they're looking at. As a developer, this system is nice because
    the events can bubble up from the data model rather than being tied to the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewPager` maintains separate lists of the widgets used to display data
    on the screen and the object model being displayed. The `ViewPager` creates the
    widgets by invoking `instantiateItem` on the `PagerAdapter` object, which is expected
    to add the widget to the `ViewPager` and return the data model object that it''s
    displaying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ViewPager` may also ask `PagerAdapter` to remove the widgets that are
    not visible to the user. This is typically when a view is not visible, and cannot
    be directly scrolled into view by the user (that is, it''s not directly to the
    left or right of the current view). The position argument passed to `destroyItem`
    is the position in the data model, not the index of the widget within the `ViewPager`,
    so you need a way to figure out which widget in the `ViewPager` actually needs
    to be removed. Here, we do it by simply iterating over all the child widgets in
    the `ViewPager` since there will never be many of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `ViewPager` needs a way to know which widget child of its is associated
    with which part of the data model; this is really easy for you in this class,
    because the `AttachmentPreview` class directly references the `Attachment` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of `PagerAdapter` is very naive and simple, but shows more
    of how the `Adapter` views work. They track their onscreen views completely independently
    of the dataset, and the order in which the child widgets appear on the screen
    doesn't have any direct relationship to the order in which the data model is presented.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create another `ActionCommand` class that will create the
    `Attachment` objects when the user selects an external file to attach to the claims.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Create Attachment Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user selects a file to attach to the claim, you''ll need to ensure
    that your application can always access the file. This means copying the file
    into your application''s private space, which can take a second or two. You also
    need to know what type of file it is, otherwise your application won''t know if
    it can render a preview of the attachment. For both of these, you''ll need an
    `ActionCommand` implementation that does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `model` package, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `commands.CreateAttachmentCommand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class Abstract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new package and class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class declaration to extend `ActionCommand<Uri, Attachment>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a directory to write the local files to, and a `ContentResolver` that
    can be used to read the files that the user selects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A `ContentResolver` allows applications to read each other's data, if they choose
    to expose it. In this case, you'll be using `content://` URIs that are commonly
    used in Android when data needs to be exposed safely between applications. A `ContentResolver`
    counterpart is a `ContentProvider` that exposes the data for other applications
    to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple utility method to copy the file from a `Uri` into a new, randomly
    named file. The file is randomly named so that no two files are likely to collide
    in name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onBackground` method to copy the file using the preceding utility
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, check the type of the file your command just created, and if it looks
    like an image, ensure that you can read it before returning. This avoids the application
    having to do the same check every time it wants to preview the attachment. We
    check whether the image is readable by attempting to read it using the `BitmapFactory`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This simple command class doesn't have any foreground work, and has been left
    abstract. Instead, it assumes that the work of handling the `Attachment` will
    be done elsewhere. The next part is the `AttachmentPagerFragment` class that will
    handle the `Attachment` objects created here by attaching them to the `ClaimItem`,
    and notifying the `AttachmentPreviewAdapter` that there is a new attachment to
    render.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Attachment Pager Fragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you''ve assembled all of the parts required for the attachments to
    be created and previewed, you need to actually populate the area where they will
    be previewed. The `AttachmentPagerFragment` class will not only serve to encapsulate
    the `ViewPager` used to preview the attachments, but will also encapsulate the
    logic required to add new attachments to the user''s claim. This will be done
    by moving the `onRequestPermissionsResult` and `onActivityResult` from the `CaptureClaimActivity`
    to the new `AttachmentPagerFragment` class. This process will require moving some
    of the code out of `CaptureClaimActivity` and into the `Fragment` class, so you''ll
    be in for some cutting and pasting. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layout resource named `fragment_attachment_pager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `content_capture_claim.xml` layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cut and paste the `ViewPager` from the bottom of `content_capture_claim.xml`
    into the `fragment_attachment_pager` layout file, overwriting all the content
    of the file. You''ll need to define the XML namespaces (the `xmlns` attributes)
    on the `ViewPager` element, so that the `fragment_attachment_pager.xml` file reads
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Create a New, Java Class in the `ui.attachments` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `AttachmentPagerFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make its Superclass `android.support.v4.app.Fragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CaptureClaimActivity` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cut the `REQUEST_ATTACH_FILE` and `REQUEST_ATTACH_PERMISSION` constants from
    the `CaptureClaimActivity` and paste them in `AttachmentPagerFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `AttachmentPagerAdapter` to help with rendering the attachment
    previews. As the `AttachmentPagerAdapter` can handle its list of `Attachment`
    object changing completely, you''ll only ever need one in each `AttachmentPagerFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create fields for the `ActionCommand` you''ll use to attach the files, and
    another to hold a reference to the `ViewPager` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `AttachmentPagerFragment` needs a reference to the `ClaimItem` it is previewing
    `Attachment` for. This will also allow it to add new `Attachment` objects to the
    claim without invoking its `Activity` to do so. The `Fragment` will also expose
    a method that can be called to notify it that the list of attachments on the `ClaimItem`
    has changed. This can be invoked by the `ClaimItem` itself later on, or through
    an event-bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `Fragment` `onCreate` method. This looks just like the `onCreate`
    method of an `Activity`, and is called after your `Fragment` has been attached
    to its context (in this case, to its `Activity` object). `AttachmentPagerFragment`
    will use `onCreate` to instantiate the `attachFileCommand` for later use, and
    it''ll do so using an anonymous inner class, inheriting from the `CreateAttachmentCommand`
    class that you just wrote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In any task that takes place in the background and then jumps back to the foreground,
    it's a good idea to check your context before running any code. In the preceding
    snippet, this takes the form of the `claimItem != null` check. If the command
    was started, and the user left the `Activity` (or similar), the foreground code
    could trigger errors by trying to alter variables that are invalid or `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `Fragment` is released completely (with no chance of a later restart),
    its `onDestroy` method is called. Use this method to release the `claimItem`,
    stopping any background tasks from modifying it when they get back to the foreground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `CategoryPickerFragment` you wrote earlier, `AttachmentPagerFragment`
    needs a `View` that will display when it''s inflated into a layout XML. In this
    case, you also need to adjust the `ViewPager` slightly, as the page margin is
    not exposed as an XML attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, cut and paste the `onAttachClick` method from `CaptureClaimActivity` into
    `AttachmentPagerFragment`. This will immediately cause errors, because `onAttachClick`
    uses the fact that an `Activity` is also a `Context`; so, `ContextCompat.checkSelfPermission`
    can use the `CaptureClaimAcitvity` as the `Context` to check. `Fragment` doesn''t
    inherit from `Context`, but it does expose the `getContext()` and `getActivity()`
    methods to retrieve the environment that it''s attached to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now cut and paste the `onRequestPermissionsResult`, `onAttachFileResult`, and
    `onActivityResult` methods over as well. These should copy over without any errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onAttachFileResult` method, you can now remove the `Toast` you put
    in as a placeholder. Instead, invoke the `attachFileCommand` with the selected
    file; this will automatically result in the previews also being updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `content_capture_claim.xml` layout file, include the new `AttachmentPagerFragment`
    where the `ViewPager` used to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CaptureClaimActivity`, create a new field for the `AttachmentPagerFragment`,
    and in `onCreate`, capture the field from the `FragmentManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the `onClick` method in `CaptureClaimActivity` to invoke `onAttachClick`
    on the `AttachmentPagerFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `AttachmentPagerFragment` is a multipurpose `Fragment`. Although it has
    all the logic required to attach files to a `ClaimItem`, it doesn't attempt to
    hook them up to any event listeners itself. As a result, you can easily use it
    as a read-only preview of attachments if (for example) the current user was reviewing
    someone else's travel expenses (in which case, they shouldn't be editing the data).
  prefs: []
  type: TYPE_NORMAL
- en: It's always a good idea to consider how a `Fragment` might be reused in different
    situations, and to rather push data and events down into them rather than having
    them making call upward to their `Activity` to know what should be done (which
    forces every `Activity` wanting to use the `Fragment` to provide that information).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the ClaimItem data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While you''ve linked the new `Fragment` classes to the `CaptureClaimAcitvity`,
    things aren''t quite finished yet. The `CaptureClaimActivity` doesn''t actually
    have a `ClaimItem` to capture and modify. For this, you''ll not only need to hold
    a reference to a `ClaimItem` in the `CaptureClaimActivity`, you''ll need to ensure
    that it is saved and restored through life cycle changes for the `Activity` as
    well. Fortunately, your model is all `Parcelable`, which keeps this easy. It''s
    time to capture a `ClaimItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CaptureClaimActivity` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you''ll need a way that a `ClaimItem` can be passed into the `CaptureClaimActivity`
    for editing. To keep this simple and flexible, you''ll allow them to be passed
    as an "extra" field on the `Intent`. When you use `extras` in an `Intent`, it''s
    a good idea to expose the name as a public constant so that they can be accessed
    by outside classes when creating the `Intent` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to save and restore the `ClaimItem` while it''s being edited,
    and for this, you''ll also need a key for the `Bundle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `private` field to reference the `ClaimItem` being edited, and
    you''ll also need to reference all the inputs and `Fragment` objects on the screen;
    `CaptureClaimActivity` should have `private` fields looking like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreate` method, ensure that you capture all the preceding fields
    after the call to `setContentView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you''ll need to check whether a `ClaimItem` has been passed in, either
    in the `savedInstanceState` `Bundle` (which will be populated if the `Activity`
    is being restarted due to a configuration change), or is being passed as an extra
    parameter on the `Intent` (a bit like a constructor argument):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `ClaimItem` wasn''t passed in through either of these mechanisms, you''ll
    want to create a new, empty `ClaimItem` to be edited by the user. On the other
    hand, if one was passed in, you''ll need to populate the user interface with its
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write a `utility` method to copy the data from the user interface widgets
    back into the `ClaimItem` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `Activity` is shutdown in ways that can result in it being restarted
    at a later time (and as a new instance), the `onSaveInstanceState` method is invoked
    with a `Bundle` where your `Activity` can save any state it needs to restore later
    (in this case, it''ll be the `ClaimItem` being edited). This will happen if your
    `Activity` is in the background and the OS needs to reclaim memory, or if the
    `Activity` restarts due to a configuration change (such as the user changing between
    the portrait and landscape modes). This is where you set up the contents of the
    `Bundle` that gets passed into `onCreate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to ensure that when the `CaptureClaimActivity` is closed, it returns
    the edited `ClaimItem` to the `Activity` that started it. This can be done by
    overloading the `finish()` method, which is invoked to close an `Activity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`CaptureClaimActivity` will always return a `ClaimItem` object; there is no
    notion of saving the `ClaimItem` or canceling its creation (although a calling
    `Activity` may choose to ignore the `ClaimItem` if it''s empty). The idea is to
    assume that the user knows what they are doing, and rather offer them a way to
    undo their changes once they''ve been made. This is much less disruptive to the
    user than always asking them "are you sure" questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it''s important that we give the user a visual method to exit the
    screen without using the Android back button. We''ll do this by putting a *back*
    navigation arrow on the `Toolbar`. First, write a handler that listens for the
    *home* button being selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, right-click on the drawable resource directory and choose New| Vector Asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Icon selector, search for `arrow back`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new Icon `ic_arrow_back_white_24dp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next and then on Finish to complete the wizard and create the new asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ic_arrow_back_white_24dp.xml` resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the path `android:fillColor` attribute to white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Open the `activity_capture_claim.xml` layout resource in Design mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the toolbar in the Component Tree panel:![](img/caab850f-21b9-4f23-ad79-e530047331a2.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, toggle to the View all attributes view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for navigationIcon, and use the resource selector to pick the `ic_arrow_back_white_24dp`
    icon resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the application now, you'll see that you can capture attachments
    for a claim, and when the device is rotated, or you navigate away using the home
    button, any data you've changed will remain the same when you return to the application.
    It's always important to consider what state you will need to maintain when navigating
    away from an `Activity`, as the `Activity` itself may need to be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good idea to separate the state of an `Activity` from the state
    of the application. While an `Activity` is busy editing a record, that record's
    data should remain encapsulated within the `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Try it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've isolated the category picker and the attachment logic into `Fragment`
    classes in this chapter; now try writing a Fragment to encapsulate the contents
    of the first `CardView` on the screen. Remember to rather push the `ClaimItem`
    down into the `Fragment` instead of having the `Fragment` push the change events
    up to the `Activity`. Name the new `Fragment` class `CaptureClaimDetailsFragment`
    and name its layout resource `fragment_capture_claim_details.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try pushing the logic to change the `Category` of the `ClaimItem`
    down into the `CategoryPickerFragment` in a way similar to how the `AttachmentPagerFragment`
    automatically adds new `Attachments` to the `ClaimItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a layout subclass, which of the following options is the best?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programmatically instantiating its child widgets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only having ID attributes in nested child widgets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding assigning ID attributes to child widgets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which of these applies to the `Bundle` passed at an `Activity` in `onCreate`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is populated in the `onSaveInstanceState` method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is populated automatically by the platform
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is never null
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the data for an `Adapter` changes, which of the mentioned happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will be detected by the `View` automatically
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be replaced by a new `Adapter` to reflect the changes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should notify any attached listeners
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragments and `View` classes should meet which of the following condition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They should have their data and state pushed into them from the `Activity`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should expose listener interfaces that their `Activity` implements to receive
    events
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should directly call event methods on their `Activity` by casting it to
    the correct class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned some of the practical techniques for breaking your
    user interface and application into modular components that can be reused. It's
    always a good idea to start with the finished user interface and break it up,
    preferably from the mockup stage. It's also good to identify where some parts
    of the system can serve multiple roles, for example, being both a read-only display
    and an editor. It's also a good idea to wrap components within other components,
    even if it's just conceptually. Keeping certain types of event handlers as their
    own modules makes them reusable over screens that don't share exactly the same
    widgets, but need to reuse the same logic.
  prefs: []
  type: TYPE_NORMAL
- en: When building user interfaces, it's a good idea to use an `Activity` to just
    wrap a collection of `Fragment` rather than nesting the screen logic in the `Activity`.
    This will allow the `Fragment` to take on specific responsibilities (such as attachments),
    making them more reusable elsewhere in your application. It also allows you far
    more flexibility when providing different layouts for different screen sizes.
    Devices with large screens might actually have more `Fragment` on the screen than
    smaller devices.
  prefs: []
  type: TYPE_NORMAL
- en: As a general best practice, always try and contain data and state by pushing
    it downward (as you do when you pass parameters to a method). This avoids `View`
    classes and `Fragment` from needing to be placed within specific parts of your
    application, just like a method doesn't need to know where it is being invoked
    from to do its job. This approach makes it much easier to move parts of the application
    around later on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at an Android system that makes this sort of
    modularization easier, and even more flexible. The data binding system is an incredibly
    powerful system that takes care of keeping user interfaces populated with data,
    and allows much of the presentation work to be bound directly to the layout XML
    files.
  prefs: []
  type: TYPE_NORMAL
