- en: Chapter 5. Showing Images on the Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 在屏幕上显示图像
- en: One of the basic skills we need to obtain in order to develop games is **image
    manipulation**. In this chapter, we'll discuss some aspects of this topic that
    will be useful for our game. We'll introduce the notion of Decks and Props and
    talk about how to handle them in order to make our game graphics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发游戏，我们需要获得的一项基本技能是**图像处理**。在本章中，我们将讨论一些对这个主题有用的方面，这将有助于我们的游戏。我们将介绍 Decks
    和 Props 的概念，并讨论如何处理它们以制作我们的游戏图形。
- en: Introduction to Decks and Props
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Decks 和道具简介
- en: In Moai SDK, all of the assets (images, tilesets, meshes, and surfaces) are
    defined in Decks. You can think of a Deck as the geometry of an object. **Decks**
    hold the actual image data for a sprite, for example. They're not shown in the
    screen, until you reference them using a Prop. You can think of Decks as the Prop's
    drawing method.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Moai SDK 中，所有的资产（图像、瓦片集、网格和表面）都在 Decks 中定义。你可以将 Deck 视为一个对象的几何形状。**Decks**
    存储了精灵的实际图像数据，例如。它们不会显示在屏幕上，直到你使用 Prop 引用它们。你可以将 Decks 视为 Prop 的绘制方法。
- en: There are many types of Decks `MOAIGfxQuad2D`, for example, handles one single
    image. `MOAITileDeck2D` is used to load a tileset (or atlas) and reference its
    tiles (we will use it later in the book).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的 Decks，例如 `MOAIGfxQuad2D` 处理单个图像。`MOAITileDeck2D` 用于加载瓦片集（或图集）并引用其瓦片（我们将在本书的后面使用它）。
- en: '**Props** are basically a collection of information and a reference to a given
    Deck. They hold information such as location, scale, and rotation; and are the
    actual objects that you see on the screen.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Props** 基本上是一组信息和给定 Deck 的引用。它们持有诸如位置、缩放和旋转等信息；并且是你在屏幕上看到的实际对象。'
- en: This separation is pretty useful, since it allows you to reuse the memory allocated
    to a specific asset. We will use this to handle all of our tiles and instead of
    loading the image for the back of the tile 20 times, we'll just load it once and
    point to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离非常实用，因为它允许你重复使用分配给特定资产的记忆。我们将使用它来处理所有的瓦片，而不是加载瓦片背面的图片20次，我们只需加载一次并指向它。
- en: Our first image
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一张图片
- en: The first thing we need to do is to have an actual image. We'll use the back
    of a tile from our *Concentration* game in this example, you can get it from the
    book's website, along with the full source code for this example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是有一个实际的图像。在这个例子中，我们将使用我们 *Concentration* 游戏的瓦片背面，你可以从本书的网站上获取它，以及这个例子的完整源代码。
- en: To begin with, we need a layer. A **layer** groups together one or more Props
    and serves as a way to control rendering priorities between different Prop sets.
    For example, you can have one layer for the background and another one on top
    of it for the objects, and when you add a new Prop on the background layer, it
    will be displayed below the Props on the objects layer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个层。一个**层**将一个或多个 Props 组合在一起，并作为在不同 Prop 集之间控制渲染优先级的一种方式。例如，你可以有一个用于背景的层，在其上方还有一个用于对象的层，当你向背景层添加一个新的
    Prop 时，它将显示在对象层的 Props 下方。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`MOAILayer` inherits from `MOAIProp`, so you can think of it as a Prop that
    groups other Props. You can call any of the methods of `MOAIProp` on a layer.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOAILayer` 继承自 `MOAIProp`，所以你可以将其视为一个将其他 Props 组合在一起的 Prop。你可以在一个层上调用 `MOAIProp`
    的任何方法。'
- en: 'In order to create a layer, you have to instantiate `MOAILayer2D` as follows
    (type this below the viewport initialization in the code for [Chapter 4](ch04.html
    "Chapter 4. Our First Game with Moai"), *Our First Game with Moai*):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个层，你必须按照以下方式实例化 `MOAILayer2D`（在代码中在视口初始化下方输入此内容，[第 4 章](ch04.html "第 4
    章. 使用 Moai 的第一个游戏")，*使用 Moai 的第一个游戏*）：
- en: 'First of all we create our layer:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建我们的层：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to tell that layer to use our viewport. This is done using the `setViewport()`
    method.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要告诉那个层使用我们的视口。这是通过使用 `setViewport()` 方法完成的。
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have to create our Deck. Since we're only displaying a simple image,
    we will use `MOAIGfxQuad2D` which serves that purpose.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建我们的 Deck。由于我们只显示一个简单的图像，我们将使用 `MOAIGfxQuad2D`，它用于此目的。
- en: We create the Deck object.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建 Deck 对象。
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `setTexture()` method and pass the path of our asset to it (in this
    case the back of a tile). This is where we tell the Deck to actually use our image.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `setTexture()` 方法并将我们资产的路径传递给它（在这种情况下是瓦片的背面）。这就是我们告诉 Deck 实际上使用我们的图像的地方。
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The third line sets the geometry. `MOAIGfxQuad2D` has a rectangular geometry.
    In order to define it, we can use `setRect`, which receives four numbers, `xMin`,
    `yMin`, `xMax`, and `yMax`.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三行设置几何形状。`MOAIGfxQuad2D` 有一个矩形几何形状。为了定义它，我们可以使用 `setRect`，它接收四个数字，`xMin`、`yMin`、`xMax`
    和 `yMax`。
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll use the convention that the object coordinate `(0, 0)` is in the center.
    In this way, since we want to show the image with a 62 x 62 size, the actual rectangle
    that holds it can be defined as the rectangle that has `xMin = -31`, `yMin = -31`,
    `xMax = 31`, and `yMax = 31`, since we want it to have its `(0,0)` at the center
    of the image. We could define it with `setRect ( 0, 0, 62, 62 )` and the center
    would be at the upper-left corner, but let's keep `(0,0)` at the center of the
    image convention for simplicity. Just note that this is pretty powerful. You could
    define the rectangles differently according to how you want to manipulate them.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将采用约定，对象坐标 `(0, 0)` 位于中心。这样，由于我们希望以 62 x 62 的大小显示图像，实际包含它的矩形可以定义为具有 `xMin
    = -31`、`yMin = -31`、`xMax = 31` 和 `yMax = 31` 的矩形，因为我们希望它的 `(0,0)` 位于图像的中心。我们可以用
    `setRect ( 0, 0, 62, 62 )` 来定义它，这样中心就会在左上角，但为了简单起见，让我们保持 `(0,0)` 在图像中心的约定。只需注意，这非常强大。你可以根据你想要如何操作它们来不同地定义矩形。
- en: '![Our first image](img/5064_05_01.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![我们的第一张图像](img/5064_05_01.jpg)'
- en: The next step is to set up our Prop.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置我们的属性。
- en: First of all we create Prop.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建属性。
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then we tell the Prop to use `imageGfx` as the Deck. This is the point where
    we connect them together. We're saying that this prop will be an instance of our
    back of tile image.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们告诉属性使用 `imageGfx` 作为牌组。这是我们将它们连接在一起的时刻。我们说的是这个属性将是我们瓷砖背面的图像实例。
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The third line moves the Prop to the center of the screen.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三行将属性移动到屏幕中心。
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We're using the `setLoc()` method to move the image to the back of the tile.
    You can change the parameters and see how it behaves. By default, `(0,0)` is the
    center of the screen, so negative values in *x* will move the object to the left
    and positive ones to the right. Negative values in *y* will move the object down
    and positive ones will move it up. This is not the same as the typical coordinate
    system used in computer graphics, which sets `(0,0)` at the top-left corner and
    the *y* axis grows downward.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `setLoc()` 方法将图像移动到瓷砖的背面。你可以更改参数并观察它的行为。默认情况下，`(0,0)` 是屏幕中心，所以 *x* 中的负值将对象移动到左边，正值将其移动到右边。*y*
    中的负值将对象向下移动，正值将其向上移动。这与计算机图形学中使用的典型坐标系不同，它将 `(0,0)` 设置在左上角，并且 *y* 轴向下增长。
- en: The next step is to insert our Prop into the layer we created, so it will render
    when the layer is rendered.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们的属性插入到我们创建的层中，这样它就会在层渲染时渲染。
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And the last step is to make that layer renderable.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使该层可渲染。
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is an interesting thing to talk about. What we are doing here is, first,
    creating a table that contains the layer as its first object, and then telling
    `MOAIRenderMgr` to use that table for rendering.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件有趣的事情来讨论。我们在这里所做的是，首先创建一个包含层作为其第一个对象的表，然后告诉 `MOAIRenderMgr` 使用那个表进行渲染。
- en: In order to configure rendering, we need to tell `MOAIRenderMgr` what we want
    to render. This is done using the **Render table**. As we discussed in [Chapter
    3](ch03.html "Chapter 3. Basic Moai SDK Concepts"), *Basic Moai SDK Concepts*,
    the table and subtables that you pass using `setRenderTable()` are the ones that
    will be rendered during the next rendering step. So, for example if you want to
    remove all of the objects that are rendering, you don't need to iterate through
    them, you just have to pass an empty table to the `setRenderTable()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置渲染，我们需要告诉 `MOAIRenderMgr` 我们想要渲染的内容。这是通过使用 **渲染表** 来完成的。正如我们在 [第 3 章](ch03.html
    "第 3 章。基本 Moai SDK 概念") 中所讨论的，*基本 Moai SDK 概念*，使用 `setRenderTable()` 传递的表和子表将在下一个渲染步骤中渲染。所以，例如，如果你想移除所有正在渲染的对象，你不需要遍历它们，你只需要将一个空表传递给
    `setRenderTable()` 方法。
- en: You have to be careful when handling this. Keep an eye on the table you're rendering
    if objects suddenly disappear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这个时，你必须小心。如果对象突然消失，请留意你正在渲染的表。
- en: Coordinate systems
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系
- en: Sooner or later, if you're developing multi-platform games, you'll need to understand
    the different coordinate systems that are involved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，如果你在开发多平台游戏，你需要了解涉及的不同坐标系。
- en: In Moai SDK, we have at least three coordinate systems that are important to
    remember and to make good use of.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Moai SDK 中，我们至少有三种重要的坐标系需要记住并有效利用。
- en: Window/Screen coordinates
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口/屏幕坐标
- en: This is the coordinate system attached to your window. You will typically have
    to deal with it when receiving mouse or touchscreen input. You might also use
    it to design your GUI. If you ever experience any strange behavior when clicking,
    always double-check that you're correctly transforming input coordinates to world
    or even model coordinates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是附加到您窗口上的坐标系。您通常在接收鼠标或触摸屏输入时需要处理它。您也可以使用它来设计您的 GUI。如果您在点击时遇到任何奇怪的行为，请务必检查您是否正确地将输入坐标转换为世界坐标或甚至模型坐标。
- en: World coordinates
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界坐标
- en: This is the coordinate system that you define when setting the scale for the
    viewport, and is the one that you'll normally use when positioning Props on the
    screen. This is where the multi-platform magic happens, since this coordinate
    system is the one that abstracts different screen resolutions so that you don't
    need to take them all into account. Aspect ratio changes need to be handled, but
    that's a separate topic by itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您在设置视口缩放时定义的坐标系，也是您在屏幕上定位 Prop 时通常会使用的坐标系。这是多平台魔法发生的地方，因为这个坐标系抽象了不同的屏幕分辨率，这样您就不需要考虑所有这些分辨率。需要处理纵横比变化，但这是一个单独的话题。
- en: Model coordinates
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型坐标
- en: This coordinate system is the one Props use. It's related to Prop geometry.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个坐标系是 Prop 使用的坐标系。它与 Prop 几何相关。
- en: It's really useful when checking for collisions. Given an arbitrary point in
    the world, converting it to model coordinates will give you a point that has a
    certain offset in *x* and *y* from the Prop's center. If you know the Prop's size,
    you can actually check if the point is inside the Prop's bounds.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查碰撞时非常有用。给定世界中的一个任意点，将其转换为模型坐标将得到一个在 *x* 和 *y* 方向上从 Prop 的中心有一定偏移的点。如果您知道
    Prop 的大小，您实际上可以检查该点是否在 Prop 的边界内。
- en: Changing between coordinate systems can simplify your game's logic a lot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在坐标系之间切换可以大大简化您的游戏逻辑。
- en: '![Model coordinates](img/5064_05_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![模型坐标](img/5064_05_02.jpg)'
- en: Luckily, this coordinate nightmare is really easy to address in Moai SDK.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Moai SDK 中处理这个坐标噩梦非常简单。
- en: 'There are some methods that will help us in this task:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法将帮助我们完成这项任务：
- en: '`MOAILayer2D` has methods to transform between window and world coordinates
    (`wndToWorld` and `worldToWnd`).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOAILayer2D` 有方法在窗口和世界坐标之间进行转换（`wndToWorld` 和 `worldToWnd`）。'
- en: '`MOAIProp2D` has methods to transform between world and model coordinates (`modelToWorld`
    and `worldToModel`).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOAIProp2D` 有方法在世界坐标和模型坐标之间进行转换（`modelToWorld` 和 `worldToModel`）。'
- en: So, you will want to use these methods in order to do your calculations based
    on what entity you're working with. We will use this when implementing the gameplay
    for our *Concentration* game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将想要使用这些方法，以便根据您正在处理的实体进行计算。当我们实现 *集中注意力* 游戏的游戏玩法时，我们会使用这些方法。
- en: Blend modes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合模式
- en: A nice feature that you'll be playing with for sure is **blend modes**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定会玩的一个很酷的功能是 **混合模式**。
- en: Moai SDK gives you the ability to define the blending mode for a certain Prop
    using the `setBlendMode()` method. This will allow you to modify the way its pixels
    are rendered on the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Moai SDK 允许您使用 `setBlendMode()` 方法为某个 Prop 定义混合模式。这将允许您修改其像素在屏幕上渲染的方式。
- en: You can choose between `MOAIProp2D.BLEND_NORMAL`, `MOAIProp2D.BLEND_ADD`, and
    `MOAIProp2D.BLEND_MULTIPLY`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择 `MOAIProp2D.BLEND_NORMAL`、`MOAIProp2D.BLEND_ADD` 和 `MOAIProp2D.BLEND_MULTIPLY`。
- en: '`MOAIProp2D.BLEND_NORMAL` is the default behavior and basically paints over
    pixels, covering whatever is underneath.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOAIProp2D.BLEND_NORMAL` 是默认行为，基本上会覆盖像素，覆盖其下的一切。'
- en: '`MOAIProp2D.BLEND_ADD` does additive blending. It adds the value for the pixel
    you''re trying to draw to the previous value of the pixel on the screen. This
    is really useful for particle systems and to obtain that popular glowing effect
    used to create *Tron*-like lights. It can also be used to create static lighting
    for a scene.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOAIProp2D.BLEND_ADD` 执行加法混合。它将您试图绘制的像素的值添加到屏幕上该像素的先前值。这对于粒子系统以及创建类似 *Tron*
    的发光效果非常有用。它还可以用于创建场景的静态照明。'
- en: '`MOAIProp2D.BLEND_MULTIPLY` multiplies the values of the pixel on the screen
    and the one it''s trying to paint. This is really useful for creating static shadows.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOAIProp2D.BLEND_MULTIPLY` 将屏幕上像素和它试图绘制的像素的值相乘。这对于创建静态阴影非常有用。'
- en: '![Blend modes](img/5064_05_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![混合模式](img/5064_05_03.jpg)'
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Decks and Props—objects that Moai SDK provides
    to handle images. We saw how to combine these objects, along with the viewport,
    and show an image on the screen. We also talked about coordinate systems and the
    importance of understanding them, and when to use which in order to make calculations
    easier (and correct!). We also introduced the usage of blend modes, which will
    come in handy for creating nice effects with lights and shadows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于牌组（Decks）和道具（Props）的内容——Moai SDK 提供用于处理图像的对象。我们看到了如何将这些对象与视口结合，并在屏幕上显示图像。我们还讨论了坐标系及其重要性，以及何时使用哪种坐标系以便于计算（并且正确！）我们还介绍了混合模式的使用，这对于创建灯光和阴影的漂亮效果非常有用。
- en: The next chapter will be the basis of our minimalist game framework, the Resource
    Manager. This contains code that will handle loading and caching objects in memory.
    We'll use it to avoid repeating initialization code when we need to use images
    or sounds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是我们极简游戏框架的基础，即资源管理器。这包含了处理内存中对象加载和缓存的代码。我们将使用它来避免在需要使用图像或声音时重复初始化代码。
