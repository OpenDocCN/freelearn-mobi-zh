- en: Chapter 5. Showing Images on the Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the basic skills we need to obtain in order to develop games is **image
    manipulation**. In this chapter, we'll discuss some aspects of this topic that
    will be useful for our game. We'll introduce the notion of Decks and Props and
    talk about how to handle them in order to make our game graphics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Decks and Props
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Moai SDK, all of the assets (images, tilesets, meshes, and surfaces) are
    defined in Decks. You can think of a Deck as the geometry of an object. **Decks**
    hold the actual image data for a sprite, for example. They're not shown in the
    screen, until you reference them using a Prop. You can think of Decks as the Prop's
    drawing method.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of Decks `MOAIGfxQuad2D`, for example, handles one single
    image. `MOAITileDeck2D` is used to load a tileset (or atlas) and reference its
    tiles (we will use it later in the book).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Props** are basically a collection of information and a reference to a given
    Deck. They hold information such as location, scale, and rotation; and are the
    actual objects that you see on the screen.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This separation is pretty useful, since it allows you to reuse the memory allocated
    to a specific asset. We will use this to handle all of our tiles and instead of
    loading the image for the back of the tile 20 times, we'll just load it once and
    point to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Our first image
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is to have an actual image. We'll use the back
    of a tile from our *Concentration* game in this example, you can get it from the
    book's website, along with the full source code for this example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need a layer. A **layer** groups together one or more Props
    and serves as a way to control rendering priorities between different Prop sets.
    For example, you can have one layer for the background and another one on top
    of it for the objects, and when you add a new Prop on the background layer, it
    will be displayed below the Props on the objects layer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MOAILayer` inherits from `MOAIProp`, so you can think of it as a Prop that
    groups other Props. You can call any of the methods of `MOAIProp` on a layer.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a layer, you have to instantiate `MOAILayer2D` as follows
    (type this below the viewport initialization in the code for [Chapter 4](ch04.html
    "Chapter 4. Our First Game with Moai"), *Our First Game with Moai*):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all we create our layer:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to tell that layer to use our viewport. This is done using the `setViewport()`
    method.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have to create our Deck. Since we're only displaying a simple image,
    we will use `MOAIGfxQuad2D` which serves that purpose.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the Deck object.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `setTexture()` method and pass the path of our asset to it (in this
    case the back of a tile). This is where we tell the Deck to actually use our image.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The third line sets the geometry. `MOAIGfxQuad2D` has a rectangular geometry.
    In order to define it, we can use `setRect`, which receives four numbers, `xMin`,
    `yMin`, `xMax`, and `yMax`.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll use the convention that the object coordinate `(0, 0)` is in the center.
    In this way, since we want to show the image with a 62 x 62 size, the actual rectangle
    that holds it can be defined as the rectangle that has `xMin = -31`, `yMin = -31`,
    `xMax = 31`, and `yMax = 31`, since we want it to have its `(0,0)` at the center
    of the image. We could define it with `setRect ( 0, 0, 62, 62 )` and the center
    would be at the upper-left corner, but let's keep `(0,0)` at the center of the
    image convention for simplicity. Just note that this is pretty powerful. You could
    define the rectangles differently according to how you want to manipulate them.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Our first image](img/5064_05_01.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The next step is to set up our Prop.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all we create Prop.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then we tell the Prop to use `imageGfx` as the Deck. This is the point where
    we connect them together. We're saying that this prop will be an instance of our
    back of tile image.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The third line moves the Prop to the center of the screen.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We're using the `setLoc()` method to move the image to the back of the tile.
    You can change the parameters and see how it behaves. By default, `(0,0)` is the
    center of the screen, so negative values in *x* will move the object to the left
    and positive ones to the right. Negative values in *y* will move the object down
    and positive ones will move it up. This is not the same as the typical coordinate
    system used in computer graphics, which sets `(0,0)` at the top-left corner and
    the *y* axis grows downward.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is to insert our Prop into the layer we created, so it will render
    when the layer is rendered.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And the last step is to make that layer renderable.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is an interesting thing to talk about. What we are doing here is, first,
    creating a table that contains the layer as its first object, and then telling
    `MOAIRenderMgr` to use that table for rendering.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure rendering, we need to tell `MOAIRenderMgr` what we want
    to render. This is done using the **Render table**. As we discussed in [Chapter
    3](ch03.html "Chapter 3. Basic Moai SDK Concepts"), *Basic Moai SDK Concepts*,
    the table and subtables that you pass using `setRenderTable()` are the ones that
    will be rendered during the next rendering step. So, for example if you want to
    remove all of the objects that are rendering, you don't need to iterate through
    them, you just have to pass an empty table to the `setRenderTable()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: You have to be careful when handling this. Keep an eye on the table you're rendering
    if objects suddenly disappear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate systems
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, if you're developing multi-platform games, you'll need to understand
    the different coordinate systems that are involved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In Moai SDK, we have at least three coordinate systems that are important to
    remember and to make good use of.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Window/Screen coordinates
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the coordinate system attached to your window. You will typically have
    to deal with it when receiving mouse or touchscreen input. You might also use
    it to design your GUI. If you ever experience any strange behavior when clicking,
    always double-check that you're correctly transforming input coordinates to world
    or even model coordinates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: World coordinates
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the coordinate system that you define when setting the scale for the
    viewport, and is the one that you'll normally use when positioning Props on the
    screen. This is where the multi-platform magic happens, since this coordinate
    system is the one that abstracts different screen resolutions so that you don't
    need to take them all into account. Aspect ratio changes need to be handled, but
    that's a separate topic by itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Model coordinates
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This coordinate system is the one Props use. It's related to Prop geometry.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: It's really useful when checking for collisions. Given an arbitrary point in
    the world, converting it to model coordinates will give you a point that has a
    certain offset in *x* and *y* from the Prop's center. If you know the Prop's size,
    you can actually check if the point is inside the Prop's bounds.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Changing between coordinate systems can simplify your game's logic a lot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Model coordinates](img/5064_05_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Luckily, this coordinate nightmare is really easy to address in Moai SDK.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some methods that will help us in this task:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`MOAILayer2D` has methods to transform between window and world coordinates
    (`wndToWorld` and `worldToWnd`).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOAIProp2D` has methods to transform between world and model coordinates (`modelToWorld`
    and `worldToModel`).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you will want to use these methods in order to do your calculations based
    on what entity you're working with. We will use this when implementing the gameplay
    for our *Concentration* game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Blend modes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nice feature that you'll be playing with for sure is **blend modes**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Moai SDK gives you the ability to define the blending mode for a certain Prop
    using the `setBlendMode()` method. This will allow you to modify the way its pixels
    are rendered on the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You can choose between `MOAIProp2D.BLEND_NORMAL`, `MOAIProp2D.BLEND_ADD`, and
    `MOAIProp2D.BLEND_MULTIPLY`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`MOAIProp2D.BLEND_NORMAL` is the default behavior and basically paints over
    pixels, covering whatever is underneath.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`MOAIProp2D.BLEND_ADD` does additive blending. It adds the value for the pixel
    you''re trying to draw to the previous value of the pixel on the screen. This
    is really useful for particle systems and to obtain that popular glowing effect
    used to create *Tron*-like lights. It can also be used to create static lighting
    for a scene.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`MOAIProp2D.BLEND_MULTIPLY` multiplies the values of the pixel on the screen
    and the one it''s trying to paint. This is really useful for creating static shadows.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Blend modes](img/5064_05_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![混合模式](img/5064_05_03.jpg)'
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Decks and Props—objects that Moai SDK provides
    to handle images. We saw how to combine these objects, along with the viewport,
    and show an image on the screen. We also talked about coordinate systems and the
    importance of understanding them, and when to use which in order to make calculations
    easier (and correct!). We also introduced the usage of blend modes, which will
    come in handy for creating nice effects with lights and shadows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于牌组（Decks）和道具（Props）的内容——Moai SDK 提供用于处理图像的对象。我们看到了如何将这些对象与视口结合，并在屏幕上显示图像。我们还讨论了坐标系及其重要性，以及何时使用哪种坐标系以便于计算（并且正确！）我们还介绍了混合模式的使用，这对于创建灯光和阴影的漂亮效果非常有用。
- en: The next chapter will be the basis of our minimalist game framework, the Resource
    Manager. This contains code that will handle loading and caching objects in memory.
    We'll use it to avoid repeating initialization code when we need to use images
    or sounds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是我们极简游戏框架的基础，即资源管理器。这包含了处理内存中对象加载和缓存的代码。我们将使用它来避免在需要使用图像或声音时重复初始化代码。
